<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_compressor_pager.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_compressor_pager.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

<span class="enscript-comment">/*
 *	Compressor Pager.
 *		Memory Object Management.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/upl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor_pager.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_external.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

<span class="enscript-comment">/* memory_object interfaces */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">compressor_memory_object_reference</span>(memory_object_t mem_obj);
<span class="enscript-type">void</span> <span class="enscript-function-name">compressor_memory_object_deallocate</span>(memory_object_t mem_obj);
kern_return_t <span class="enscript-function-name">compressor_memory_object_init</span>(
	memory_object_t		mem_obj,
	memory_object_control_t	control,
	memory_object_cluster_size_t pager_page_size);
kern_return_t <span class="enscript-function-name">compressor_memory_object_terminate</span>(memory_object_t mem_obj);
kern_return_t <span class="enscript-function-name">compressor_memory_object_data_request</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_cluster_size_t		length,
	__unused vm_prot_t	protection_required,
        memory_object_fault_info_t	fault_info);
kern_return_t <span class="enscript-function-name">compressor_memory_object_data_return</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_cluster_size_t			size,
	__unused memory_object_offset_t	*resid_offset,
	__unused <span class="enscript-type">int</span>		*io_error,
	__unused boolean_t	dirty,
	__unused boolean_t	kernel_copy,
	__unused <span class="enscript-type">int</span>	upl_flags);
kern_return_t <span class="enscript-function-name">compressor_memory_object_data_initialize</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_cluster_size_t		size);
kern_return_t <span class="enscript-function-name">compressor_memory_object_data_unlock</span>(
	__unused memory_object_t		mem_obj,
	__unused memory_object_offset_t	offset,
	__unused memory_object_size_t		size,
	__unused vm_prot_t		desired_access);
kern_return_t <span class="enscript-function-name">compressor_memory_object_synchronize</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_size_t		length,
	__unused vm_sync_t		flags);
kern_return_t <span class="enscript-function-name">compressor_memory_object_map</span>(
	__unused memory_object_t	mem_obj,
	__unused vm_prot_t		prot);
kern_return_t <span class="enscript-function-name">compressor_memory_object_last_unmap</span>(memory_object_t mem_obj);
kern_return_t <span class="enscript-function-name">compressor_memory_object_data_reclaim</span>(
	__unused memory_object_t	mem_obj,
	__unused boolean_t		reclaim_backing_store);

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> memory_object_pager_ops compressor_pager_ops = {
	compressor_memory_object_reference,
	compressor_memory_object_deallocate,
	compressor_memory_object_init,
	compressor_memory_object_terminate,
	compressor_memory_object_data_request,
	compressor_memory_object_data_return,
	compressor_memory_object_data_initialize,
	compressor_memory_object_data_unlock,
	compressor_memory_object_synchronize,
	compressor_memory_object_map,
	compressor_memory_object_last_unmap,
	compressor_memory_object_data_reclaim,
	<span class="enscript-string">&quot;compressor pager&quot;</span>
};

<span class="enscript-comment">/* internal data structures */</span>

<span class="enscript-type">struct</span> {
	uint64_t	data_returns;
	uint64_t	data_requests;
	uint64_t	put;
	uint64_t	get;
	uint64_t	state_clr;
	uint64_t	state_get;
	uint64_t	transfer;
} compressor_pager_stats;

<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> compressor_slot_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> compressor_pager {
	<span class="enscript-type">struct</span> ipc_object_header	cpgr_pager_header; <span class="enscript-comment">/* fake ip_kotype */</span>
	memory_object_pager_ops_t	cpgr_pager_ops;	<span class="enscript-comment">/* == &amp;compressor_pager_ops */</span>
	memory_object_control_t		cpgr_control;
	lck_mtx_t			cpgr_lock;

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			cpgr_references;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			cpgr_num_slots;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			cpgr_num_slots_occupied;
	<span class="enscript-type">union</span> {
		compressor_slot_t	cpgr_eslots[2]; <span class="enscript-comment">/* embedded slots */</span>
		compressor_slot_t	*cpgr_dslots;	<span class="enscript-comment">/* direct slots */</span>
		compressor_slot_t	**cpgr_islots;	<span class="enscript-comment">/* indirect slots */</span>
	} cpgr_slots;
} *compressor_pager_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">compressor_pager_lookup</span>(_mem_obj_, _cpgr_)			\
	MACRO_BEGIN							\
	<span class="enscript-keyword">if</span> (_mem_obj_ == NULL ||					\
	    _mem_obj_-&gt;mo_pager_ops != &amp;compressor_pager_ops) {		\
		_cpgr_ = NULL;						\
	} <span class="enscript-keyword">else</span> {							\
		_cpgr_ = (compressor_pager_t) _mem_obj_;		\
	}								\
	MACRO_END

zone_t compressor_pager_zone;

lck_grp_t	compressor_pager_lck_grp;
lck_grp_attr_t	compressor_pager_lck_grp_attr;
lck_attr_t	compressor_pager_lck_attr;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">compressor_pager_lock</span>(_cpgr_) \
	lck_mtx_lock(&amp;(_cpgr_)-&gt;cpgr_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">compressor_pager_unlock</span>(_cpgr_) \
	lck_mtx_unlock(&amp;(_cpgr_)-&gt;cpgr_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">compressor_pager_lock_init</span>(_cpgr_) \
	lck_mtx_init(&amp;(_cpgr_)-&gt;cpgr_lock, &amp;compressor_pager_lck_grp, &amp;compressor_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">compressor_pager_lock_destroy</span>(_cpgr_) \
	lck_mtx_destroy(&amp;(_cpgr_)-&gt;cpgr_lock, &amp;compressor_pager_lck_grp)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPRESSOR_SLOTS_CHUNK_SIZE</span>	(512)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPRESSOR_SLOTS_PER_CHUNK</span>	(COMPRESSOR_SLOTS_CHUNK_SIZE / sizeof (compressor_slot_t))

<span class="enscript-comment">/* forward declarations */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">compressor_pager_slots_chunk_free</span>(compressor_slot_t *chunk,
					       <span class="enscript-type">int</span> num_slots,
	                                       <span class="enscript-type">int</span> flags,
					       <span class="enscript-type">int</span> *failures);
<span class="enscript-type">void</span> <span class="enscript-function-name">compressor_pager_slot_lookup</span>(
	compressor_pager_t	pager,
	boolean_t		do_alloc,
	memory_object_offset_t	offset,
	compressor_slot_t	**slot_pp);

kern_return_t
<span class="enscript-function-name">compressor_memory_object_init</span>(
	memory_object_t		mem_obj,
	memory_object_control_t	control,
	__unused memory_object_cluster_size_t pager_page_size)
{
	compressor_pager_t		pager;

	assert(pager_page_size == PAGE_SIZE);

	memory_object_control_reference(control);

	compressor_pager_lookup(mem_obj, pager);
	compressor_pager_lock(pager);

	<span class="enscript-keyword">if</span> (pager-&gt;cpgr_control != MEMORY_OBJECT_CONTROL_NULL)
		panic(<span class="enscript-string">&quot;compressor_memory_object_init: bad request&quot;</span>);
	pager-&gt;cpgr_control = control;

	compressor_pager_unlock(pager);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_synchronize</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_size_t		length,
	__unused vm_sync_t		flags)
{
	compressor_pager_t	pager;

	compressor_pager_lookup(mem_obj, pager);

	memory_object_synchronize_completed(pager-&gt;cpgr_control, offset, length);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_map</span>(
	__unused memory_object_t	mem_obj,
	__unused vm_prot_t		prot)
{
	panic(<span class="enscript-string">&quot;compressor_memory_object_map&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_last_unmap</span>(
	__unused memory_object_t	mem_obj)
{
	panic(<span class="enscript-string">&quot;compressor_memory_object_last_unmap&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_data_reclaim</span>(
	__unused memory_object_t	mem_obj,
	__unused boolean_t		reclaim_backing_store)
{
	panic(<span class="enscript-string">&quot;compressor_memory_object_data_reclaim&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_terminate</span>(
	memory_object_t		mem_obj)
{
	memory_object_control_t	control;
	compressor_pager_t	pager;

	<span class="enscript-comment">/* 
	 * control port is a receive right, not a send right.
	 */</span>

	compressor_pager_lookup(mem_obj, pager);
	compressor_pager_lock(pager);

	<span class="enscript-comment">/*
	 * After memory_object_terminate both memory_object_init
	 * and a no-senders notification are possible, so we need
	 * to clean up our reference to the memory_object_control
	 * to prepare for a new init.
	 */</span>

	control = pager-&gt;cpgr_control;
	pager-&gt;cpgr_control = MEMORY_OBJECT_CONTROL_NULL;

	compressor_pager_unlock(pager);

	<span class="enscript-comment">/*
	 * Now we deallocate our reference on the control.
	 */</span>
	memory_object_control_deallocate(control);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">compressor_memory_object_reference</span>(
	memory_object_t		mem_obj)
{
	compressor_pager_t	pager;

	compressor_pager_lookup(mem_obj, pager);
	<span class="enscript-keyword">if</span> (pager == NULL)
		<span class="enscript-keyword">return</span>;

	compressor_pager_lock(pager);
	assert(pager-&gt;cpgr_references &gt; 0);
	pager-&gt;cpgr_references++;
	compressor_pager_unlock(pager);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">compressor_memory_object_deallocate</span>(
	memory_object_t		mem_obj)
{
	compressor_pager_t	pager;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		num_slots_freed;

	<span class="enscript-comment">/*
	 * Because we don't give out multiple first references
	 * for a memory object, there can't be a race
	 * between getting a deallocate call and creating
	 * a new reference for the object.
	 */</span>

	compressor_pager_lookup(mem_obj, pager);
	<span class="enscript-keyword">if</span> (pager == NULL)
		<span class="enscript-keyword">return</span>;

	compressor_pager_lock(pager);
	<span class="enscript-keyword">if</span> (--pager-&gt;cpgr_references &gt; 0) {
		compressor_pager_unlock(pager);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * We shouldn't get a deallocation call
	 * when the kernel has the object cached.
	 */</span>
	<span class="enscript-keyword">if</span> (pager-&gt;cpgr_control != MEMORY_OBJECT_CONTROL_NULL)
		panic(<span class="enscript-string">&quot;compressor_memory_object_deallocate(): bad request&quot;</span>);

	<span class="enscript-comment">/*
	 * Unlock the pager (though there should be no one
	 * waiting for it).
	 */</span>
	compressor_pager_unlock(pager);

	<span class="enscript-comment">/* free the compressor slots */</span>
	<span class="enscript-type">int</span> num_chunks;
	<span class="enscript-type">int</span> i;
	compressor_slot_t *chunk;

	num_chunks = (pager-&gt;cpgr_num_slots + COMPRESSOR_SLOTS_PER_CHUNK -1) / COMPRESSOR_SLOTS_PER_CHUNK;
	<span class="enscript-keyword">if</span> (num_chunks &gt; 1) {
		<span class="enscript-comment">/* we have an array of chunks */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; num_chunks; i++) {
			chunk = pager-&gt;cpgr_slots.cpgr_islots[i];
			<span class="enscript-keyword">if</span> (chunk != NULL) {
				num_slots_freed =
					compressor_pager_slots_chunk_free(
						chunk,
						COMPRESSOR_SLOTS_PER_CHUNK,
						0,
						NULL);
				pager-&gt;cpgr_slots.cpgr_islots[i] = NULL;
				kfree(chunk, COMPRESSOR_SLOTS_CHUNK_SIZE);
			}
		}
		kfree(pager-&gt;cpgr_slots.cpgr_islots,
		      num_chunks * <span class="enscript-keyword">sizeof</span> (pager-&gt;cpgr_slots.cpgr_islots[0]));
		pager-&gt;cpgr_slots.cpgr_islots = NULL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pager-&gt;cpgr_num_slots &gt; 2) {
		chunk = pager-&gt;cpgr_slots.cpgr_dslots;
		num_slots_freed =
			compressor_pager_slots_chunk_free(
				chunk,
				pager-&gt;cpgr_num_slots,
				0,
				NULL);
		pager-&gt;cpgr_slots.cpgr_dslots = NULL;
		kfree(chunk,
		      (pager-&gt;cpgr_num_slots *
		       <span class="enscript-keyword">sizeof</span> (pager-&gt;cpgr_slots.cpgr_dslots[0])));
	} <span class="enscript-keyword">else</span> {
		chunk = &amp;pager-&gt;cpgr_slots.cpgr_eslots[0];
		num_slots_freed =
			compressor_pager_slots_chunk_free(
				chunk,
				pager-&gt;cpgr_num_slots,
				0,
				NULL);
	}

	compressor_pager_lock_destroy(pager);
	zfree(compressor_pager_zone, pager);
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_data_request</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_cluster_size_t		length,
	__unused vm_prot_t	protection_required,
        __unused memory_object_fault_info_t	fault_info)
{
	compressor_pager_t	pager;
	kern_return_t		kr;
	compressor_slot_t	*slot_p;
	
	compressor_pager_stats.data_requests++;

	<span class="enscript-comment">/*
	 * Request must be on a page boundary and a multiple of pages.
	 */</span>
	<span class="enscript-keyword">if</span> ((offset &amp; PAGE_MASK) != 0 || (length &amp; PAGE_MASK) != 0)
		panic(<span class="enscript-string">&quot;compressor_memory_object_data_request(): bad alignment&quot;</span>);

	<span class="enscript-keyword">if</span> ((uint32_t)(offset/PAGE_SIZE) != (offset/PAGE_SIZE)) {
		panic(<span class="enscript-string">&quot;%s: offset 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) offset);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	compressor_pager_lookup(mem_obj, pager);

	<span class="enscript-keyword">if</span> (length == 0) {
		<span class="enscript-comment">/* we're only querying the pager for this page */</span>
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;compressor: data_request&quot;</span>);
	}

	<span class="enscript-comment">/* find the compressor slot for that page */</span>
	compressor_pager_slot_lookup(pager, FALSE, offset, &amp;slot_p);

	<span class="enscript-keyword">if</span> (offset / PAGE_SIZE &gt; pager-&gt;cpgr_num_slots) {
		<span class="enscript-comment">/* out of range */</span>
		kr = KERN_FAILURE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (slot_p == NULL || *slot_p == 0) {
		<span class="enscript-comment">/* compressor does not have this page */</span>
		kr = KERN_FAILURE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* compressor does have this page */</span>
		kr = KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * memory_object_data_initialize: check whether we already have each page, and
 * write it if we do not.  The implementation is far from optimized, and
 * also assumes that the default_pager is single-threaded.
 */</span>
<span class="enscript-comment">/*  It is questionable whether or not a pager should decide what is relevant */</span>
<span class="enscript-comment">/* and what is not in data sent from the kernel.  Data initialize has been */</span>
<span class="enscript-comment">/* changed to copy back all data sent to it in preparation for its eventual */</span>
<span class="enscript-comment">/* merge with data return.  It is the kernel that should decide what pages */</span>
<span class="enscript-comment">/* to write back.  As of the writing of this note, this is indeed the case */</span>
<span class="enscript-comment">/* the kernel writes back one page at a time through this interface */</span>

kern_return_t
<span class="enscript-function-name">compressor_memory_object_data_initialize</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_cluster_size_t		size)
{
	compressor_pager_t	pager;
	memory_object_offset_t	cur_offset;

	compressor_pager_lookup(mem_obj, pager);
	compressor_pager_lock(pager);

	<span class="enscript-keyword">for</span> (cur_offset = offset;
	     cur_offset &lt; offset + size;
	     cur_offset += PAGE_SIZE) {
		panic(<span class="enscript-string">&quot;do a data_return() if slot for this page is empty&quot;</span>);
	}

	compressor_pager_unlock(pager);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">compressor_memory_object_data_unlock</span>(
	__unused memory_object_t		mem_obj,
	__unused memory_object_offset_t	offset,
	__unused memory_object_size_t		size,
	__unused vm_prot_t		desired_access)
{
	panic(<span class="enscript-string">&quot;compressor_memory_object_data_unlock()&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}


<span class="enscript-comment">/*ARGSUSED*/</span>
kern_return_t
<span class="enscript-function-name">compressor_memory_object_data_return</span>(
	__unused memory_object_t			mem_obj,
	__unused memory_object_offset_t		offset,
	__unused memory_object_cluster_size_t	size,
	__unused memory_object_offset_t	*resid_offset,
	__unused <span class="enscript-type">int</span>		*io_error,
	__unused boolean_t	dirty,
	__unused boolean_t	kernel_copy,
	__unused <span class="enscript-type">int</span>		upl_flags)
{
	panic(<span class="enscript-string">&quot;compressor: data_return&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

<span class="enscript-comment">/*
 * Routine:	default_pager_memory_object_create
 * Purpose:
 * 	Handle requests for memory objects from the
 * 	kernel.
 * Notes:
 * 	Because we only give out the default memory
 * 	manager port to the kernel, we don't have to
 * 	be so paranoid about the contents.
 */</span>
kern_return_t
<span class="enscript-function-name">compressor_memory_object_create</span>(
	memory_object_size_t	new_size,
	memory_object_t		*new_mem_obj)
{
	compressor_pager_t	pager;
	<span class="enscript-type">int</span>			num_chunks;

	<span class="enscript-keyword">if</span> ((uint32_t)(new_size/PAGE_SIZE) != (new_size/PAGE_SIZE)) {
		<span class="enscript-comment">/* 32-bit overflow for number of pages */</span>
		panic(<span class="enscript-string">&quot;%s: size 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) new_size);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	pager = (compressor_pager_t) zalloc(compressor_pager_zone);
	<span class="enscript-keyword">if</span> (pager == NULL) {
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	compressor_pager_lock_init(pager);
	pager-&gt;cpgr_control = MEMORY_OBJECT_CONTROL_NULL;
	pager-&gt;cpgr_references = 1;
	pager-&gt;cpgr_num_slots = (uint32_t)(new_size/PAGE_SIZE);
	pager-&gt;cpgr_num_slots_occupied = 0;

	num_chunks = (pager-&gt;cpgr_num_slots + COMPRESSOR_SLOTS_PER_CHUNK - 1) / COMPRESSOR_SLOTS_PER_CHUNK;
	<span class="enscript-keyword">if</span> (num_chunks &gt; 1) {
		pager-&gt;cpgr_slots.cpgr_islots = kalloc(num_chunks * <span class="enscript-keyword">sizeof</span> (pager-&gt;cpgr_slots.cpgr_islots[0]));
		bzero(pager-&gt;cpgr_slots.cpgr_islots, num_chunks * <span class="enscript-keyword">sizeof</span> (pager-&gt;cpgr_slots.cpgr_islots[0]));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pager-&gt;cpgr_num_slots &gt; 2) {
		pager-&gt;cpgr_slots.cpgr_dslots = kalloc(pager-&gt;cpgr_num_slots * <span class="enscript-keyword">sizeof</span> (pager-&gt;cpgr_slots.cpgr_dslots[0]));
		bzero(pager-&gt;cpgr_slots.cpgr_dslots, pager-&gt;cpgr_num_slots * <span class="enscript-keyword">sizeof</span> (pager-&gt;cpgr_slots.cpgr_dslots[0]));
	} <span class="enscript-keyword">else</span> {
		pager-&gt;cpgr_slots.cpgr_eslots[0] = 0;
		pager-&gt;cpgr_slots.cpgr_eslots[1] = 0;
	}

	<span class="enscript-comment">/*
	 * Set up associations between this memory object
	 * and this compressor_pager structure
	 */</span>

	pager-&gt;cpgr_pager_ops = &amp;compressor_pager_ops;
	pager-&gt;cpgr_pager_header.io_bits = IKOT_MEMORY_OBJECT;

	*new_mem_obj = (memory_object_t) pager;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">compressor_pager_slots_chunk_free</span>(
	compressor_slot_t	*chunk,
	<span class="enscript-type">int</span>			num_slots,
	<span class="enscript-type">int</span>			flags,
	<span class="enscript-type">int</span>			*failures)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> retval;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_slots_freed;

	<span class="enscript-keyword">if</span> (failures)
		*failures = 0;
	num_slots_freed = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_slots; i++) {
		<span class="enscript-keyword">if</span> (chunk[i] != 0) {
			retval = vm_compressor_free(&amp;chunk[i], flags);

			<span class="enscript-keyword">if</span> (retval == 0)
				num_slots_freed++;
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (retval == -2)
					assert(flags &amp; C_DONT_BLOCK);

				<span class="enscript-keyword">if</span> (failures)
					*failures += 1;
			}
		}
	}
	<span class="enscript-keyword">return</span> num_slots_freed;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">compressor_pager_slot_lookup</span>(
	compressor_pager_t	pager,
	boolean_t		do_alloc,
	memory_object_offset_t	offset,
	compressor_slot_t	**slot_pp)
{
	<span class="enscript-type">int</span>			num_chunks;
	uint32_t		page_num;
	<span class="enscript-type">int</span>			chunk_idx;
	<span class="enscript-type">int</span>			slot_idx;
	compressor_slot_t	*chunk;
	compressor_slot_t	*t_chunk;

	page_num = (uint32_t)(offset/PAGE_SIZE);
	<span class="enscript-keyword">if</span> (page_num != (offset/PAGE_SIZE)) {
		<span class="enscript-comment">/* overflow */</span>
		panic(<span class="enscript-string">&quot;%s: offset 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) offset);
		*slot_pp = NULL;
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (page_num &gt; pager-&gt;cpgr_num_slots) {
		<span class="enscript-comment">/* out of range */</span>
		*slot_pp = NULL;
		<span class="enscript-keyword">return</span>;
	}
	num_chunks = (pager-&gt;cpgr_num_slots + COMPRESSOR_SLOTS_PER_CHUNK - 1) / COMPRESSOR_SLOTS_PER_CHUNK;
	<span class="enscript-keyword">if</span> (num_chunks &gt; 1) {
		<span class="enscript-comment">/* we have an array of chunks */</span>
		chunk_idx = page_num / COMPRESSOR_SLOTS_PER_CHUNK;
		chunk = pager-&gt;cpgr_slots.cpgr_islots[chunk_idx];

		<span class="enscript-keyword">if</span> (chunk == NULL &amp;&amp; do_alloc) {
			t_chunk = kalloc(COMPRESSOR_SLOTS_CHUNK_SIZE);
			bzero(t_chunk, COMPRESSOR_SLOTS_CHUNK_SIZE);

			compressor_pager_lock(pager);

			<span class="enscript-keyword">if</span> ((chunk = pager-&gt;cpgr_slots.cpgr_islots[chunk_idx]) == NULL) {
				chunk = pager-&gt;cpgr_slots.cpgr_islots[chunk_idx] = t_chunk;
				t_chunk = NULL;
			}
			compressor_pager_unlock(pager);
			
			<span class="enscript-keyword">if</span> (t_chunk)
				kfree(t_chunk, COMPRESSOR_SLOTS_CHUNK_SIZE);
		}
		<span class="enscript-keyword">if</span> (chunk == NULL) {
			*slot_pp = NULL;
		} <span class="enscript-keyword">else</span> {
			slot_idx = page_num % COMPRESSOR_SLOTS_PER_CHUNK;
			*slot_pp = &amp;chunk[slot_idx];
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pager-&gt;cpgr_num_slots &gt; 2) {
		slot_idx = page_num;
		*slot_pp = &amp;pager-&gt;cpgr_slots.cpgr_dslots[slot_idx];
	} <span class="enscript-keyword">else</span> {
		slot_idx = page_num;
		*slot_pp = &amp;pager-&gt;cpgr_slots.cpgr_eslots[slot_idx];
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_pager_init</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_setdefault(&amp;compressor_pager_lck_grp_attr);
	lck_grp_init(&amp;compressor_pager_lck_grp, <span class="enscript-string">&quot;compressor_pager&quot;</span>, &amp;compressor_pager_lck_grp_attr);
	lck_attr_setdefault(&amp;compressor_pager_lck_attr);

	compressor_pager_zone = zinit(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> compressor_pager),
				      10000 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> compressor_pager),
				      8192, <span class="enscript-string">&quot;compressor_pager&quot;</span>);
	zone_change(compressor_pager_zone, Z_CALLERACCT, FALSE);
	zone_change(compressor_pager_zone, Z_NOENCRYPT, TRUE);

	vm_compressor_init();
}

kern_return_t
<span class="enscript-function-name">vm_compressor_pager_put</span>(
	memory_object_t			mem_obj,
	memory_object_offset_t		offset,
	ppnum_t				ppnum,
	<span class="enscript-type">void</span>				**current_chead,
	<span class="enscript-type">char</span>				*scratch_buf,
	<span class="enscript-type">int</span>				*compressed_count_delta_p)
{
	compressor_pager_t	pager;
	compressor_slot_t	*slot_p;

	compressor_pager_stats.put++;

	*compressed_count_delta_p = 0;

	<span class="enscript-comment">/* This routine is called by the pageout thread.  The pageout thread */</span>
	<span class="enscript-comment">/* cannot be blocked by read activities unless the read activities   */</span>
	<span class="enscript-comment">/* Therefore the grant of vs lock must be done on a try versus a      */</span>
	<span class="enscript-comment">/* blocking basis.  The code below relies on the fact that the       */</span>
	<span class="enscript-comment">/* interface is synchronous.  Should this interface be again async   */</span>
	<span class="enscript-comment">/* for some type  of pager in the future the pages will have to be   */</span>
	<span class="enscript-comment">/* returned through a separate, asynchronous path.		     */</span>

	compressor_pager_lookup(mem_obj, pager);

	<span class="enscript-keyword">if</span> ((uint32_t)(offset/PAGE_SIZE) != (offset/PAGE_SIZE)) {
		<span class="enscript-comment">/* overflow */</span>
		panic(<span class="enscript-string">&quot;%s: offset 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) offset);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	compressor_pager_slot_lookup(pager, TRUE, offset, &amp;slot_p);

	<span class="enscript-keyword">if</span> (slot_p == NULL) {
		<span class="enscript-comment">/* out of range ? */</span>
		panic(<span class="enscript-string">&quot;vm_compressor_pager_put: out of range&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (*slot_p != 0) {
		<span class="enscript-comment">/*
		 * Already compressed: forget about the old one.
		 *
		 * This can happen after a vm_object_do_collapse() when
		 * the &quot;backing_object&quot; had some pages paged out and the
		 * &quot;object&quot; had an equivalent page resident.
		 */</span>
		vm_compressor_free(slot_p, 0);
		*compressed_count_delta_p -= 1;
	}
	<span class="enscript-keyword">if</span> (vm_compressor_put(ppnum, slot_p, current_chead, scratch_buf))
		<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
	*compressed_count_delta_p += 1;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


kern_return_t
<span class="enscript-function-name">vm_compressor_pager_get</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	ppnum_t			ppnum,
	<span class="enscript-type">int</span>			*my_fault_type,
	<span class="enscript-type">int</span>			flags,
	<span class="enscript-type">int</span>			*compressed_count_delta_p)
{
	compressor_pager_t	pager;
	kern_return_t		kr;
	compressor_slot_t	*slot_p;
	
	compressor_pager_stats.get++;

	*compressed_count_delta_p = 0;

	<span class="enscript-keyword">if</span> ((uint32_t)(offset/PAGE_SIZE) != (offset/PAGE_SIZE)) {
		panic(<span class="enscript-string">&quot;%s: offset 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) offset);
		<span class="enscript-keyword">return</span> KERN_MEMORY_ERROR;
	}

	compressor_pager_lookup(mem_obj, pager);

	<span class="enscript-comment">/* find the compressor slot for that page */</span>
	compressor_pager_slot_lookup(pager, FALSE, offset, &amp;slot_p);

	<span class="enscript-keyword">if</span> (offset / PAGE_SIZE &gt; pager-&gt;cpgr_num_slots) {
		<span class="enscript-comment">/* out of range */</span>
		kr = KERN_MEMORY_FAILURE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (slot_p == NULL || *slot_p == 0) {
		<span class="enscript-comment">/* compressor does not have this page */</span>
		kr = KERN_MEMORY_ERROR;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* compressor does have this page */</span>
		kr = KERN_SUCCESS;
	}
	*my_fault_type = DBG_COMPRESSOR_FAULT;
		
	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
		<span class="enscript-type">int</span>	retval;

		<span class="enscript-comment">/* get the page from the compressor */</span>
		retval = vm_compressor_get(ppnum, slot_p, flags);
		<span class="enscript-keyword">if</span> (retval == -1)
			kr = KERN_MEMORY_FAILURE;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retval == 1)
			*my_fault_type = DBG_COMPRESSOR_SWAPIN_FAULT;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retval == -2) {
			assert((flags &amp; C_DONT_BLOCK));
			kr = KERN_FAILURE;
		}
	}

	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
		assert(slot_p != NULL);
		<span class="enscript-keyword">if</span> (*slot_p != 0) {
			<span class="enscript-comment">/*
			 * We got the page for a copy-on-write fault
			 * and we kept the original in place.  Slot
			 * is still occupied.
			 */</span>
		} <span class="enscript-keyword">else</span> {
			*compressed_count_delta_p -= 1;
		}
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_compressor_pager_state_clr</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset)
{
	compressor_pager_t	pager;
	compressor_slot_t	*slot_p;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		num_slots_freed;
	
	compressor_pager_stats.state_clr++;

	<span class="enscript-keyword">if</span> ((uint32_t)(offset/PAGE_SIZE) != (offset/PAGE_SIZE)) {
		<span class="enscript-comment">/* overflow */</span>
		panic(<span class="enscript-string">&quot;%s: offset 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) offset);
		<span class="enscript-keyword">return</span> 0;
	}

	compressor_pager_lookup(mem_obj, pager);

	<span class="enscript-comment">/* find the compressor slot for that page */</span>
	compressor_pager_slot_lookup(pager, FALSE, offset, &amp;slot_p);

	num_slots_freed = 0;
	<span class="enscript-keyword">if</span> (slot_p &amp;&amp; *slot_p != 0) {
		vm_compressor_free(slot_p, 0);
		num_slots_freed++;
		assert(*slot_p == 0);
	}

	<span class="enscript-keyword">return</span> num_slots_freed;
}

vm_external_state_t
<span class="enscript-function-name">vm_compressor_pager_state_get</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset)
{
	compressor_pager_t	pager;
	compressor_slot_t	*slot_p;
	
	compressor_pager_stats.state_get++;

	<span class="enscript-keyword">if</span> ((uint32_t)(offset/PAGE_SIZE) != (offset/PAGE_SIZE)) {
		<span class="enscript-comment">/* overflow */</span>
		panic(<span class="enscript-string">&quot;%s: offset 0x%llx overflow\n&quot;</span>,
		      __FUNCTION__, (uint64_t) offset);
		<span class="enscript-keyword">return</span> VM_EXTERNAL_STATE_ABSENT;
	}

	compressor_pager_lookup(mem_obj, pager);

	<span class="enscript-comment">/* find the compressor slot for that page */</span>
	compressor_pager_slot_lookup(pager, FALSE, offset, &amp;slot_p);

	<span class="enscript-keyword">if</span> (offset / PAGE_SIZE &gt; pager-&gt;cpgr_num_slots) {
		<span class="enscript-comment">/* out of range */</span>
		<span class="enscript-keyword">return</span> VM_EXTERNAL_STATE_ABSENT;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (slot_p == NULL || *slot_p == 0) {
		<span class="enscript-comment">/* compressor does not have this page */</span>
		<span class="enscript-keyword">return</span> VM_EXTERNAL_STATE_ABSENT;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* compressor does have this page */</span>
		<span class="enscript-keyword">return</span> VM_EXTERNAL_STATE_EXISTS;
	}
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_compressor_pager_reap_pages</span>(
	memory_object_t		mem_obj,
	<span class="enscript-type">int</span>			flags)
{
	compressor_pager_t	pager;
	<span class="enscript-type">int</span>			num_chunks;
	<span class="enscript-type">int</span>			failures;
	<span class="enscript-type">int</span>			i;
	compressor_slot_t	*chunk;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		num_slots_freed;

	compressor_pager_lookup(mem_obj, pager);
	<span class="enscript-keyword">if</span> (pager == NULL)
		<span class="enscript-keyword">return</span> 0;

	compressor_pager_lock(pager);

	<span class="enscript-comment">/* reap the compressor slots */</span>
	num_slots_freed = 0;

	num_chunks = (pager-&gt;cpgr_num_slots + COMPRESSOR_SLOTS_PER_CHUNK -1) / COMPRESSOR_SLOTS_PER_CHUNK;
	<span class="enscript-keyword">if</span> (num_chunks &gt; 1) {
		<span class="enscript-comment">/* we have an array of chunks */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; num_chunks; i++) {
			chunk = pager-&gt;cpgr_slots.cpgr_islots[i];
			<span class="enscript-keyword">if</span> (chunk != NULL) {
				num_slots_freed +=
					compressor_pager_slots_chunk_free(
						chunk,
						COMPRESSOR_SLOTS_PER_CHUNK,
						flags,
						&amp;failures);
				<span class="enscript-keyword">if</span> (failures == 0) {
					pager-&gt;cpgr_slots.cpgr_islots[i] = NULL;
					kfree(chunk, COMPRESSOR_SLOTS_CHUNK_SIZE);
				}
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pager-&gt;cpgr_num_slots &gt; 2) {
		chunk = pager-&gt;cpgr_slots.cpgr_dslots;
		num_slots_freed +=
			compressor_pager_slots_chunk_free(
				chunk,
				pager-&gt;cpgr_num_slots,
				flags,
				NULL);
	} <span class="enscript-keyword">else</span> {
		chunk = &amp;pager-&gt;cpgr_slots.cpgr_eslots[0];
		num_slots_freed +=
			compressor_pager_slots_chunk_free(
				chunk,
				pager-&gt;cpgr_num_slots,
				flags,
				NULL);
	}

	compressor_pager_unlock(pager);

	<span class="enscript-keyword">return</span> num_slots_freed;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_pager_transfer</span>(
	memory_object_t		dst_mem_obj,
	memory_object_offset_t	dst_offset,
	memory_object_t		src_mem_obj,
	memory_object_offset_t	src_offset)
{
	compressor_pager_t	src_pager, dst_pager;
	compressor_slot_t	*src_slot_p, *dst_slot_p;
	
	compressor_pager_stats.transfer++;

	<span class="enscript-comment">/* find the compressor slot for the destination */</span>
	assert((uint32_t) dst_offset == dst_offset);
	compressor_pager_lookup(dst_mem_obj, dst_pager);
	assert(dst_offset / PAGE_SIZE &lt;= dst_pager-&gt;cpgr_num_slots);
	compressor_pager_slot_lookup(dst_pager, TRUE, (uint32_t) dst_offset,
				     &amp;dst_slot_p);
	assert(dst_slot_p != NULL);
	assert(*dst_slot_p == 0);

	<span class="enscript-comment">/* find the compressor slot for the source */</span>
	assert((uint32_t) src_offset == src_offset);
	compressor_pager_lookup(src_mem_obj, src_pager);
	assert(src_offset / PAGE_SIZE &lt;= src_pager-&gt;cpgr_num_slots);
	compressor_pager_slot_lookup(src_pager, FALSE, (uint32_t) src_offset,
				     &amp;src_slot_p);
	assert(src_slot_p != NULL);
	assert(*src_slot_p != 0);

	<span class="enscript-comment">/* transfer the slot from source to destination */</span>
	vm_compressor_transfer(dst_slot_p, src_slot_p);
	OSAddAtomic(-1, &amp;src_pager-&gt;cpgr_num_slots_occupied);
	OSAddAtomic(+1, &amp;dst_pager-&gt;cpgr_num_slots_occupied);
}

memory_object_offset_t
<span class="enscript-function-name">vm_compressor_pager_next_compressed</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset)
{
	compressor_pager_t	pager;
	uint32_t		num_chunks;
	uint32_t		page_num;
	uint32_t		chunk_idx;
	uint32_t		slot_idx;
	compressor_slot_t	*chunk;

	compressor_pager_lookup(mem_obj, pager);

	page_num = (uint32_t)(offset / PAGE_SIZE);
	<span class="enscript-keyword">if</span> (page_num != (offset/PAGE_SIZE)) {
		<span class="enscript-comment">/* overflow */</span>
		<span class="enscript-keyword">return</span> (memory_object_offset_t) -1;
	}
	<span class="enscript-keyword">if</span> (page_num &gt; pager-&gt;cpgr_num_slots) {
		<span class="enscript-comment">/* out of range */</span>
		<span class="enscript-keyword">return</span> (memory_object_offset_t) -1;
	}

	num_chunks = ((pager-&gt;cpgr_num_slots + COMPRESSOR_SLOTS_PER_CHUNK - 1) /
		      COMPRESSOR_SLOTS_PER_CHUNK);

	<span class="enscript-keyword">if</span> (num_chunks == 1) {
		<span class="enscript-keyword">if</span> (pager-&gt;cpgr_num_slots &gt; 2) {
			chunk = pager-&gt;cpgr_slots.cpgr_dslots;
		} <span class="enscript-keyword">else</span> {
			chunk = &amp;pager-&gt;cpgr_slots.cpgr_eslots[0];
		}
		<span class="enscript-keyword">for</span> (slot_idx = page_num;
		     slot_idx &lt; pager-&gt;cpgr_num_slots;
		     slot_idx++) {
			<span class="enscript-keyword">if</span> (chunk[slot_idx] != 0) {
				<span class="enscript-comment">/* found a non-NULL slot in this chunk */</span>
				<span class="enscript-keyword">return</span> (memory_object_offset_t) (slot_idx *
								 PAGE_SIZE);
			}
		}
		<span class="enscript-keyword">return</span> (memory_object_offset_t) -1;
	}

	<span class="enscript-comment">/* we have an array of chunks; find the next non-NULL chunk */</span>
	chunk = NULL;
	<span class="enscript-keyword">for</span> (chunk_idx = page_num / COMPRESSOR_SLOTS_PER_CHUNK,
		     slot_idx = page_num % COMPRESSOR_SLOTS_PER_CHUNK;
	     chunk_idx &lt; num_chunks;
	     chunk_idx++,
		     slot_idx = 0) {
		chunk = pager-&gt;cpgr_slots.cpgr_islots[chunk_idx];
		<span class="enscript-keyword">if</span> (chunk == NULL) {
			<span class="enscript-comment">/* no chunk here: try the next one */</span>
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* search for an occupied slot in this chunk */</span>
		<span class="enscript-keyword">for</span> (;
		     slot_idx &lt; COMPRESSOR_SLOTS_PER_CHUNK;
		     slot_idx++) {
			<span class="enscript-keyword">if</span> (chunk[slot_idx] != 0) {
				<span class="enscript-comment">/* found an occupied slot in this chunk */</span>
				uint32_t next_slot;

				next_slot = ((chunk_idx *
					      COMPRESSOR_SLOTS_PER_CHUNK) +
					     slot_idx);
				<span class="enscript-keyword">if</span> (next_slot &gt; pager-&gt;cpgr_num_slots) {
					<span class="enscript-comment">/* went beyond end of object */</span>
					<span class="enscript-keyword">return</span> (memory_object_offset_t) -1;
				}
				<span class="enscript-keyword">return</span> (memory_object_offset_t) (next_slot *
								 PAGE_SIZE);
			}
		}
	}
	<span class="enscript-keyword">return</span> (memory_object_offset_t) -1;
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_compressor_pager_get_count</span>(
	memory_object_t mem_obj)
{
	compressor_pager_t	pager;

	compressor_pager_lookup(mem_obj, pager);
	<span class="enscript-keyword">if</span> (pager == NULL)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">/*
	 * The caller should have the VM object locked and one
	 * needs that lock to do a page-in or page-out, so no
	 * need to lock the pager here.
	 */</span>
	assert(pager-&gt;cpgr_num_slots_occupied &gt;= 0);

	<span class="enscript-keyword">return</span> pager-&gt;cpgr_num_slots_occupied;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_pager_count</span>(
	memory_object_t	mem_obj,
	<span class="enscript-type">int</span>		compressed_count_delta,
	boolean_t	shared_lock,
	vm_object_t	object __unused)
{
	compressor_pager_t	pager;

	<span class="enscript-keyword">if</span> (compressed_count_delta == 0) {
		<span class="enscript-keyword">return</span>;
	}

	compressor_pager_lookup(mem_obj, pager);
	<span class="enscript-keyword">if</span> (pager == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (compressed_count_delta &lt; 0) {
		assert(pager-&gt;cpgr_num_slots_occupied &gt;=
		       (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -compressed_count_delta);
	}

	<span class="enscript-comment">/*
	 * The caller should have the VM object locked,
	 * shared or exclusive.
	 */</span>
	<span class="enscript-keyword">if</span> (shared_lock) {
		vm_object_lock_assert_shared(object);
		OSAddAtomic(compressed_count_delta,
			    &amp;pager-&gt;cpgr_num_slots_occupied);
	} <span class="enscript-keyword">else</span> {
		vm_object_lock_assert_exclusive(object);
		pager-&gt;cpgr_num_slots_occupied += compressed_count_delta;
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
kern_return_t
<span class="enscript-function-name">vm_compressor_pager_relocate</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	<span class="enscript-type">void</span>			**current_chead)
{
	<span class="enscript-comment">/*
	 * Has the page at this offset been compressed?
	 */</span>

	compressor_slot_t *slot_p;
	compressor_pager_t dst_pager;

	assert(mem_obj);
		
	compressor_pager_lookup(mem_obj, dst_pager);
	<span class="enscript-keyword">if</span> (dst_pager == NULL)
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	compressor_pager_slot_lookup(dst_pager, FALSE, offset, &amp;slot_p);
	<span class="enscript-keyword">return</span> (vm_compressor_relocate(current_chead, slot_p));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

</pre>
<hr />
</body></html>