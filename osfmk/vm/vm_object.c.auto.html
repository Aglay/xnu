<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_object.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_object.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm/vm_object.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Virtual memory object module.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_pagemap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;task_swapper.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_default.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_control_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/xpr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor_pager.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_purgeable_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_phantom_cache.h&gt;</span>
#<span class="enscript-reference">endif</span>

boolean_t vm_object_collapse_compressor_allowed = TRUE;

<span class="enscript-type">struct</span> vm_counters vm_counters;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING</span>
boolean_t vm_object_tracking_inited = FALSE;
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">static</span>,vm_object_tracking_lock_data);
btlog_t *vm_object_tracking_btlog;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_tracking_lock</span>(<span class="enscript-type">void</span> *context)
{
	simple_lock((simple_lock_t)context);
}
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_tracking_unlock</span>(<span class="enscript-type">void</span> *context)
{
	simple_unlock((simple_lock_t)context);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_tracking_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> vm_object_tracking;

	vm_object_tracking = 1;
	PE_parse_boot_argn(<span class="enscript-string">&quot;vm_object_tracking&quot;</span>, &amp;vm_object_tracking, 
			   <span class="enscript-keyword">sizeof</span> (vm_object_tracking));

	<span class="enscript-keyword">if</span> (vm_object_tracking) {
		simple_lock_init(&amp;vm_object_tracking_lock_data, 0);
		vm_object_tracking_btlog = btlog_create(
			50000,
			VM_OBJECT_TRACKING_BTDEPTH,
			vm_object_tracking_lock,
			vm_object_tracking_unlock,
			&amp;vm_object_tracking_lock_data);
		assert(vm_object_tracking_btlog);
		vm_object_tracking_inited = TRUE;
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJECT_TRACKING */</span>

<span class="enscript-comment">/*
 *	Virtual memory objects maintain the actual data
 *	associated with allocated virtual memory.  A given
 *	page of memory exists within exactly one object.
 *
 *	An object is only deallocated when all &quot;references&quot;
 *	are given up.
 *
 *	Associated with each object is a list of all resident
 *	memory pages belonging to that object; this list is
 *	maintained by the &quot;vm_page&quot; module, but locked by the object's
 *	lock.
 *
 *	Each object also records the memory object reference
 *	that is used by the kernel to request and write
 *	back data (the memory object, field &quot;pager&quot;), etc...
 *
 *	Virtual memory objects are allocated to provide
 *	zero-filled memory (vm_allocate) or map a user-defined
 *	memory object into a virtual address space (vm_map).
 *
 *	Virtual memory objects that refer to a user-defined
 *	memory object are called &quot;permanent&quot;, because all changes
 *	made in virtual memory are reflected back to the
 *	memory manager, which may then store it permanently.
 *	Other virtual memory objects are called &quot;temporary&quot;,
 *	meaning that changes need be written back only when
 *	necessary to reclaim pages, and that storage associated
 *	with the object can be discarded once it is no longer
 *	mapped.
 *
 *	A permanent memory object may be mapped into more
 *	than one virtual address space.  Moreover, two threads
 *	may attempt to make the first mapping of a memory
 *	object concurrently.  Only one thread is allowed to
 *	complete this mapping; all others wait for the
 *	&quot;pager_initialized&quot; field is asserted, indicating
 *	that the first thread has initialized all of the
 *	necessary fields in the virtual memory object structure.
 *
 *	The kernel relies on a *default memory manager* to
 *	provide backing storage for the zero-filled virtual
 *	memory objects.  The pager memory objects associated
 *	with these temporary virtual memory objects are only
 *	requested from the default memory manager when it
 *	becomes necessary.  Virtual memory objects
 *	that depend on the default memory manager are called
 *	&quot;internal&quot;.  The &quot;pager_created&quot; field is provided to
 *	indicate whether these ports have ever been allocated.
 *	
 *	The kernel may also create virtual memory objects to
 *	hold changed pages after a copy-on-write operation.
 *	In this case, the virtual memory object (and its
 *	backing storage -- its memory object) only contain
 *	those pages that have been changed.  The &quot;shadow&quot;
 *	field refers to the virtual memory object that contains
 *	the remainder of the contents.  The &quot;shadow_offset&quot;
 *	field indicates where in the &quot;shadow&quot; these contents begin.
 *	The &quot;copy&quot; field refers to a virtual memory object
 *	to which changed pages must be copied before changing
 *	this object, in order to implement another form
 *	of copy-on-write optimization.
 *
 *	The virtual memory object structure also records
 *	the attributes associated with its memory object.
 *	The &quot;pager_ready&quot;, &quot;can_persist&quot; and &quot;copy_strategy&quot;
 *	fields represent those attributes.  The &quot;cached_list&quot;
 *	field is used in the implementation of the persistence
 *	attribute.
 *
 * ZZZ Continue this comment.
 */</span>

<span class="enscript-comment">/* Forward declarations for internal functions. */</span>
<span class="enscript-type">static</span> kern_return_t	vm_object_terminate(
				vm_object_t	object);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_object_remove(
				vm_object_t	object);

<span class="enscript-type">static</span> kern_return_t	vm_object_copy_call(
				vm_object_t		src_object,
				vm_object_offset_t	src_offset,
				vm_object_size_t	size,
				vm_object_t		*_result_object);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		vm_object_do_collapse(
				vm_object_t	object,
				vm_object_t	backing_object);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		vm_object_do_bypass(
				vm_object_t	object,
				vm_object_t	backing_object);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		vm_object_release_pager(
	                        memory_object_t	pager,
				boolean_t	hashed);

<span class="enscript-type">static</span> zone_t		vm_object_zone;		<span class="enscript-comment">/* vm backing store zone */</span>

<span class="enscript-comment">/*
 *	All wired-down kernel memory belongs to a single virtual
 *	memory object (kernel_object) to avoid wasting data structures.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vm_object			kernel_object_store;
vm_object_t						kernel_object;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vm_object			compressor_object_store;
vm_object_t				compressor_object = &amp;compressor_object_store;

<span class="enscript-comment">/*
 *	The submap object is used as a placeholder for vm_map_submap
 *	operations.  The object is declared in vm_map.c because it
 *	is exported by the vm_map module.  The storage is declared
 *	here because it must be initialized here.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vm_object			vm_submap_object_store;

<span class="enscript-comment">/*
 *	Virtual memory objects are initialized from
 *	a template (see vm_object_allocate).
 *
 *	When adding a new field to the virtual memory
 *	object structure, be sure to add initialization
 *	(see _vm_object_allocate()).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vm_object			vm_object_template;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_purged_wired = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_purged_busy = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_purged_others = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
<span class="enscript-comment">/*
 *	Virtual memory objects that are not referenced by
 *	any address maps, but that are allowed to persist
 *	(an attribute specified by the associated memory manager),
 *	are kept in a queue (vm_object_cached_list).
 *
 *	When an object from this queue is referenced again,
 *	for example to make another address space mapping,
 *	it must be removed from the queue.  That is, the
 *	queue contains *only* objects with zero references.
 *
 *	The kernel may choose to terminate objects from this
 *	queue in order to reclaim storage.  The current policy
 *	is to permit a fixed maximum number of unreferenced
 *	objects (vm_object_cached_max).
 *
 *	A spin lock (accessed by routines
 *	vm_object_cache_{lock,lock_try,unlock}) governs the
 *	object cache.  It must be held when objects are
 *	added to or removed from the cache (in vm_object_terminate).
 *	The routines that acquire a reference to a virtual
 *	memory object based on one of the memory object ports
 *	must also lock the cache.
 *
 *	Ideally, the object cache should be more isolated
 *	from the reference mechanism, so that the lock need
 *	not be held to make simple references.
 */</span>
<span class="enscript-type">static</span> vm_object_t	vm_object_cache_trim(
				boolean_t called_from_vm_object_deallocate);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		vm_object_deactivate_all_pages(
				vm_object_t	object);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		vm_object_cached_high;	<span class="enscript-comment">/* highest # cached objects */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		vm_object_cached_max = 512;	<span class="enscript-comment">/* may be patched*/</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_cache_lock</span>()		\
		lck_mtx_lock(&amp;vm_object_cached_lock_data)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_cache_lock_try</span>()		\
		lck_mtx_try_lock(&amp;vm_object_cached_lock_data)

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VM_OBJECT_CACHE */</span>

<span class="enscript-type">static</span> queue_head_t	vm_object_cached_list;
<span class="enscript-type">static</span> uint32_t		vm_object_cache_pages_freed = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_cache_pages_moved = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_cache_pages_skipped = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_cache_adds = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_cached_count = 0;
<span class="enscript-type">static</span> lck_mtx_t	vm_object_cached_lock_data;
<span class="enscript-type">static</span> lck_mtx_ext_t	vm_object_cached_lock_data_ext;

<span class="enscript-type">static</span> uint32_t		vm_object_page_grab_failed = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_page_grab_skipped = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_page_grab_returned = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_page_grab_pmapped = 0;
<span class="enscript-type">static</span> uint32_t		vm_object_page_grab_reactivations = 0;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_cache_lock_spin</span>()		\
		lck_mtx_lock_spin(&amp;vm_object_cached_lock_data)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_cache_unlock</span>()	\
		lck_mtx_unlock(&amp;vm_object_cached_lock_data)

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	vm_object_cache_remove_locked(vm_object_t);


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_HASH_COUNT</span>		1024
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_HASH_LOCK_COUNT</span>	512

<span class="enscript-type">static</span> lck_mtx_t	vm_object_hashed_lock_data[VM_OBJECT_HASH_LOCK_COUNT];
<span class="enscript-type">static</span> lck_mtx_ext_t	vm_object_hashed_lock_data_ext[VM_OBJECT_HASH_LOCK_COUNT];

<span class="enscript-type">static</span> queue_head_t	vm_object_hashtable[VM_OBJECT_HASH_COUNT];
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone	*vm_object_hash_zone;

<span class="enscript-type">struct</span> vm_object_hash_entry {
	queue_chain_t		hash_link;	<span class="enscript-comment">/* hash chain link */</span>
	memory_object_t	pager;		<span class="enscript-comment">/* pager we represent */</span>
	vm_object_t		object;		<span class="enscript-comment">/* corresponding object */</span>
	boolean_t		waiting;	<span class="enscript-comment">/* someone waiting for
						 * termination */</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vm_object_hash_entry	*vm_object_hash_entry_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_HASH_ENTRY_NULL</span>	((vm_object_hash_entry_t) 0)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_HASH_SHIFT</span>	5
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_hash</span>(pager) \
	((<span class="enscript-type">int</span>)((((uintptr_t)pager) &gt;&gt; VM_OBJECT_HASH_SHIFT) % VM_OBJECT_HASH_COUNT))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_hash</span>(pager) \
	((<span class="enscript-type">int</span>)((((uintptr_t)pager) &gt;&gt; VM_OBJECT_HASH_SHIFT) % VM_OBJECT_HASH_LOCK_COUNT))

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_object_hash_entry_free</span>(
	vm_object_hash_entry_t	entry);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_object_reap</span>(vm_object_t object);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_object_reap_async</span>(vm_object_t object);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_object_reaper_thread</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> lck_mtx_t	vm_object_reaper_lock_data;
<span class="enscript-type">static</span> lck_mtx_ext_t	vm_object_reaper_lock_data_ext;

<span class="enscript-type">static</span> queue_head_t vm_object_reaper_queue; <span class="enscript-comment">/* protected by vm_object_reaper_lock() */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_object_reap_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_object_reap_count_async = 0;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_reaper_lock</span>()		\
		lck_mtx_lock(&amp;vm_object_reaper_lock_data)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_reaper_lock_spin</span>()		\
		lck_mtx_lock_spin(&amp;vm_object_reaper_lock_data)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_reaper_unlock</span>()	\
		lck_mtx_unlock(&amp;vm_object_reaper_lock_data)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-comment">/* I/O Re-prioritization request list */</span>
queue_head_t 	io_reprioritize_list;
lck_spin_t 	io_reprioritize_list_lock;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IO_REPRIORITIZE_LIST_LOCK</span>() 	\
		lck_spin_lock(&amp;io_reprioritize_list_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IO_REPRIORITIZE_LIST_UNLOCK</span>() 	\
		lck_spin_unlock(&amp;io_reprioritize_list_lock)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_IO_REPRIORITIZE_REQS</span> 	8192
zone_t 		io_reprioritize_req_zone;

<span class="enscript-comment">/* I/O Re-prioritization thread */</span>
<span class="enscript-type">int</span> io_reprioritize_wakeup = 0;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">io_reprioritize_thread</span>(<span class="enscript-type">void</span> *param __unused, wait_result_t wr __unused);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IO_REPRIO_THREAD_WAKEUP</span>() 	thread_wakeup((event_t)&amp;io_reprioritize_wakeup)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IO_REPRIO_THREAD_CONTINUATION</span>() 				\
{ 								\
	assert_wait(&amp;io_reprioritize_wakeup, THREAD_UNINT);	\
	thread_block(io_reprioritize_thread);			\
}

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_request_reprioritize</span>(vm_object_t, uint64_t, uint32_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_handle_prio_inversion</span>(vm_object_t, vm_page_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vm_decmp_upl_reprioritize</span>(upl_t, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">KERNEL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_DEBUG</span> KERNEL_DEBUG_CONSTANT
#<span class="enscript-reference">endif</span>


<span class="enscript-type">static</span> lck_mtx_t *
<span class="enscript-function-name">vm_object_hash_lock_spin</span>(
	memory_object_t	pager)
{
	<span class="enscript-type">int</span>	index;

	index = vm_object_lock_hash(pager);

	lck_mtx_lock_spin(&amp;vm_object_hashed_lock_data[index]);

	<span class="enscript-keyword">return</span> (&amp;vm_object_hashed_lock_data[index]);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_hash_unlock</span>(lck_mtx_t *lck)
{
	lck_mtx_unlock(lck);
}


<span class="enscript-comment">/*
 *	vm_object_hash_lookup looks up a pager in the hashtable
 *	and returns the corresponding entry, with optional removal.
 */</span>
<span class="enscript-type">static</span> vm_object_hash_entry_t
<span class="enscript-function-name">vm_object_hash_lookup</span>(
	memory_object_t	pager,
	boolean_t	remove_entry)
{
	queue_t			bucket;
	vm_object_hash_entry_t	entry;

	bucket = &amp;vm_object_hashtable[vm_object_hash(pager)];

	entry = (vm_object_hash_entry_t)queue_first(bucket);
	<span class="enscript-keyword">while</span> (!queue_end(bucket, (queue_entry_t)entry)) {
		<span class="enscript-keyword">if</span> (entry-&gt;pager == pager) {
			<span class="enscript-keyword">if</span> (remove_entry) {
				queue_remove(bucket, entry,
					     vm_object_hash_entry_t, hash_link);
			}
			<span class="enscript-keyword">return</span>(entry);
		}
		entry = (vm_object_hash_entry_t)queue_next(&amp;entry-&gt;hash_link);
	}
	<span class="enscript-keyword">return</span>(VM_OBJECT_HASH_ENTRY_NULL);
}

<span class="enscript-comment">/*
 *	vm_object_hash_enter enters the specified
 *	pager / cache object association in the hashtable.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_hash_insert</span>(
	vm_object_hash_entry_t	entry,
	vm_object_t		object)
{
	queue_t		bucket;

	assert(vm_object_hash_lookup(entry-&gt;pager, FALSE) == NULL);

	bucket = &amp;vm_object_hashtable[vm_object_hash(entry-&gt;pager)];

	queue_enter(bucket, entry, vm_object_hash_entry_t, hash_link);

	<span class="enscript-keyword">if</span> (object-&gt;hashed) {
		<span class="enscript-comment">/*
		 * &quot;hashed&quot; was pre-set on this (new) object to avoid
		 * locking issues in vm_object_enter() (can't attempt to
		 * grab the object lock while holding the hash lock as
		 * a spinlock), so no need to set it here (and no need to
		 * hold the object's lock).
		 */</span>
	} <span class="enscript-keyword">else</span> {
		vm_object_lock_assert_exclusive(object);
		object-&gt;hashed = TRUE;
	}

	entry-&gt;object = object;
}

<span class="enscript-type">static</span> vm_object_hash_entry_t
<span class="enscript-function-name">vm_object_hash_entry_alloc</span>(
	memory_object_t	pager)
{
	vm_object_hash_entry_t	entry;

	entry = (vm_object_hash_entry_t)zalloc(vm_object_hash_zone);
	entry-&gt;pager = pager;
	entry-&gt;object = VM_OBJECT_NULL;
	entry-&gt;waiting = FALSE;

	<span class="enscript-keyword">return</span>(entry);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_hash_entry_free</span>(
	vm_object_hash_entry_t	entry)
{
	zfree(vm_object_hash_zone, entry);
}

<span class="enscript-comment">/*
 *	vm_object_allocate:
 *
 *	Returns a new object with the given size.
 */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">_vm_object_allocate</span>(
	vm_object_size_t	size,
	vm_object_t		object)
{
	XPR(XPR_VM_OBJECT,
		<span class="enscript-string">&quot;vm_object_allocate, object 0x%X size 0x%X\n&quot;</span>,
		object, size, 0,0,0);

	*object = vm_object_template;
	queue_init(&amp;object-&gt;memq);
	queue_init(&amp;object-&gt;msr_q);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">UPL_DEBUG</span> || <span class="enscript-variable-name">CONFIG_IOSCHED</span>
	queue_init(&amp;object-&gt;uplq);
#<span class="enscript-reference">endif</span>
	vm_object_lock_init(object);
	object-&gt;vo_size = size;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING_OP_CREATED</span>
	<span class="enscript-keyword">if</span> (vm_object_tracking_inited) {
		<span class="enscript-type">void</span>	*bt[VM_OBJECT_TRACKING_BTDEPTH];
		<span class="enscript-type">int</span>	numsaved = 0;

		numsaved = OSBacktrace(bt, VM_OBJECT_TRACKING_BTDEPTH);
		btlog_add_entry(vm_object_tracking_btlog,
				object,
				VM_OBJECT_TRACKING_OP_CREATED,
				bt,
				numsaved);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJECT_TRACKING_OP_CREATED */</span>
}

__private_extern__ vm_object_t
<span class="enscript-function-name">vm_object_allocate</span>(
	vm_object_size_t	size)
{
	<span class="enscript-type">register</span> vm_object_t object;

	object = (vm_object_t) zalloc(vm_object_zone);
	
<span class="enscript-comment">//	dbgLog(object, size, 0, 2);			/* (TEST/DEBUG) */
</span>
	<span class="enscript-keyword">if</span> (object != VM_OBJECT_NULL)
		_vm_object_allocate(size, object);

	<span class="enscript-keyword">return</span> object;
}


lck_grp_t		vm_object_lck_grp;
lck_grp_t		vm_object_cache_lck_grp;
lck_grp_attr_t		vm_object_lck_grp_attr;
lck_attr_t		vm_object_lck_attr;
lck_attr_t		kernel_object_lck_attr;
lck_attr_t		compressor_object_lck_attr;

<span class="enscript-comment">/*
 *	vm_object_bootstrap:
 *
 *	Initialize the VM objects module.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_bootstrap</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	i;

	vm_object_zone = zinit((vm_size_t) <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vm_object),
				round_page(512*1024),
				round_page(12*1024),
				<span class="enscript-string">&quot;vm objects&quot;</span>);
	zone_change(vm_object_zone, Z_CALLERACCT, FALSE); <span class="enscript-comment">/* don't charge caller */</span>
	zone_change(vm_object_zone, Z_NOENCRYPT, TRUE);

	vm_object_init_lck_grp();

	queue_init(&amp;vm_object_cached_list);

	lck_mtx_init_ext(&amp;vm_object_cached_lock_data,
		&amp;vm_object_cached_lock_data_ext,
		&amp;vm_object_cache_lck_grp,
		&amp;vm_object_lck_attr);

	queue_init(&amp;vm_object_reaper_queue);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; VM_OBJECT_HASH_LOCK_COUNT; i++) {
		lck_mtx_init_ext(&amp;vm_object_hashed_lock_data[i],
				 &amp;vm_object_hashed_lock_data_ext[i],
				 &amp;vm_object_lck_grp,
				 &amp;vm_object_lck_attr);
	}
	lck_mtx_init_ext(&amp;vm_object_reaper_lock_data,
		&amp;vm_object_reaper_lock_data_ext,
		&amp;vm_object_lck_grp,
		&amp;vm_object_lck_attr);

	vm_object_hash_zone =
			zinit((vm_size_t) <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vm_object_hash_entry),
			      round_page(512*1024),
			      round_page(12*1024),
			      <span class="enscript-string">&quot;vm object hash entries&quot;</span>);
	zone_change(vm_object_hash_zone, Z_CALLERACCT, FALSE);
	zone_change(vm_object_hash_zone, Z_NOENCRYPT, TRUE);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; VM_OBJECT_HASH_COUNT; i++)
		queue_init(&amp;vm_object_hashtable[i]);


	<span class="enscript-comment">/*
	 *	Fill in a template object, for quick initialization
	 */</span>

	<span class="enscript-comment">/* memq; Lock; init after allocation */</span>
	vm_object_template.memq.prev = NULL;
	vm_object_template.memq.next = NULL;
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * We can't call vm_object_lock_init() here because that will
	 * allocate some memory and VM is not fully initialized yet.
	 * The lock will be initialized for each allocated object in
	 * _vm_object_allocate(), so we don't need to initialize it in
	 * the vm_object_template.
	 */</span>
	vm_object_lock_init(&amp;vm_object_template);
#<span class="enscript-reference">endif</span>
	vm_object_template.vo_size = 0;
	vm_object_template.memq_hint = VM_PAGE_NULL;
	vm_object_template.ref_count = 1;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
	vm_object_template.res_count = 1;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>
	vm_object_template.resident_page_count = 0;
	vm_object_template.wired_page_count = 0;
	vm_object_template.reusable_page_count = 0;
	vm_object_template.copy = VM_OBJECT_NULL;
	vm_object_template.shadow = VM_OBJECT_NULL;
	vm_object_template.vo_shadow_offset = (vm_object_offset_t) 0;
	vm_object_template.pager = MEMORY_OBJECT_NULL;
	vm_object_template.paging_offset = 0;
	vm_object_template.pager_control = MEMORY_OBJECT_CONTROL_NULL;
	vm_object_template.copy_strategy = MEMORY_OBJECT_COPY_SYMMETRIC;
	vm_object_template.paging_in_progress = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
	vm_object_template.__object1_unused_bits = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
	vm_object_template.activity_in_progress = 0;

	<span class="enscript-comment">/* Begin bitfields */</span>
	vm_object_template.all_wanted = 0; <span class="enscript-comment">/* all bits FALSE */</span>
	vm_object_template.pager_created = FALSE;
	vm_object_template.pager_initialized = FALSE;
	vm_object_template.pager_ready = FALSE;
	vm_object_template.pager_trusted = FALSE;
	vm_object_template.can_persist = FALSE;
	vm_object_template.internal = TRUE;
	vm_object_template.temporary = TRUE;
	vm_object_template.private = FALSE;
	vm_object_template.pageout = FALSE;
	vm_object_template.alive = TRUE;
	vm_object_template.purgable = VM_PURGABLE_DENY;
	vm_object_template.purgeable_when_ripe = FALSE;
	vm_object_template.shadowed = FALSE;
	vm_object_template.advisory_pageout = FALSE;
	vm_object_template.true_share = FALSE;
	vm_object_template.terminating = FALSE;
	vm_object_template.named = FALSE;
	vm_object_template.shadow_severed = FALSE;
	vm_object_template.phys_contiguous = FALSE;
	vm_object_template.nophyscache = FALSE;
	<span class="enscript-comment">/* End bitfields */</span>

	vm_object_template.cached_list.prev = NULL;
	vm_object_template.cached_list.next = NULL;
	vm_object_template.msr_q.prev = NULL;
	vm_object_template.msr_q.next = NULL;
	
	vm_object_template.last_alloc = (vm_object_offset_t) 0;
	vm_object_template.sequential = (vm_object_offset_t) 0;
	vm_object_template.pages_created = 0;
	vm_object_template.pages_used = 0;
	vm_object_template.scan_collisions = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
	vm_object_template.phantom_object_id = 0;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	vm_object_template.existence_map = VM_EXTERNAL_NULL;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
	vm_object_template.cow_hint = ~(vm_offset_t)0;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>
	vm_object_template.paging_object = VM_OBJECT_NULL;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>

	<span class="enscript-comment">/* cache bitfields */</span>
	vm_object_template.wimg_bits = VM_WIMG_USE_DEFAULT;
	vm_object_template.set_cache_attr = FALSE;
	vm_object_template.object_slid = FALSE;
	vm_object_template.code_signed = FALSE;
	vm_object_template.hashed = FALSE;
	vm_object_template.transposed = FALSE;
	vm_object_template.mapping_in_progress = FALSE;
	vm_object_template.phantom_isssd = FALSE;
	vm_object_template.volatile_empty = FALSE;
	vm_object_template.volatile_fault = FALSE;
	vm_object_template.all_reusable = FALSE;
	vm_object_template.blocked_access = FALSE;
	vm_object_template.__object2_unused_bits = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span> || <span class="enscript-variable-name">UPL_DEBUG</span>
	vm_object_template.uplq.prev = NULL;
	vm_object_template.uplq.next = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* UPL_DEBUG */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_PIP_DEBUG</span>
	bzero(&amp;vm_object_template.pip_holders,
	      <span class="enscript-keyword">sizeof</span> (vm_object_template.pip_holders));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PIP_DEBUG */</span>

	vm_object_template.objq.next = NULL;
	vm_object_template.objq.prev = NULL;

	vm_object_template.purgeable_queue_type = PURGEABLE_Q_TYPE_MAX;
	vm_object_template.purgeable_queue_group = 0;

	vm_object_template.vo_cache_ts = 0;

	vm_object_template.wire_tag = VM_KERN_MEMORY_NONE;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	bzero(&amp;vm_object_template.purgeable_owner_bt[0],
	      <span class="enscript-keyword">sizeof</span> (vm_object_template.purgeable_owner_bt));
	vm_object_template.vo_purgeable_volatilizer = NULL;
	bzero(&amp;vm_object_template.purgeable_volatilizer_bt[0],
	      <span class="enscript-keyword">sizeof</span> (vm_object_template.purgeable_volatilizer_bt));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-comment">/*
	 *	Initialize the &quot;kernel object&quot;
	 */</span>

	kernel_object = &amp;kernel_object_store;

<span class="enscript-comment">/*
 *	Note that in the following size specifications, we need to add 1 because 
 *	VM_MAX_KERNEL_ADDRESS (vm_last_addr) is a maximum address, not a size.
 */</span>

	_vm_object_allocate(VM_MAX_KERNEL_ADDRESS + 1,
			    kernel_object);

	_vm_object_allocate(VM_MAX_KERNEL_ADDRESS + 1,
			    compressor_object);
	kernel_object-&gt;copy_strategy = MEMORY_OBJECT_COPY_NONE;
	compressor_object-&gt;copy_strategy = MEMORY_OBJECT_COPY_NONE;

	<span class="enscript-comment">/*
	 *	Initialize the &quot;submap object&quot;.  Make it as large as the
	 *	kernel object so that no limit is imposed on submap sizes.
	 */</span>

	vm_submap_object = &amp;vm_submap_object_store;
	_vm_object_allocate(VM_MAX_KERNEL_ADDRESS + 1,
			    vm_submap_object);
	vm_submap_object-&gt;copy_strategy = MEMORY_OBJECT_COPY_NONE;

	<span class="enscript-comment">/*
	 * Create an &quot;extra&quot; reference to this object so that we never
	 * try to deallocate it; zfree doesn't like to be called with
	 * non-zone memory.
	 */</span>
	vm_object_reference(vm_submap_object);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	vm_external_module_initialize();
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_io_reprioritize_init</span>(<span class="enscript-type">void</span>)
{
	kern_return_t 	result;
	thread_t 	thread = THREAD_NULL;

	<span class="enscript-comment">/* Initialze the I/O reprioritization subsystem */</span>
        lck_spin_init(&amp;io_reprioritize_list_lock, &amp;vm_object_lck_grp, &amp;vm_object_lck_attr);
        queue_init(&amp;io_reprioritize_list);

	io_reprioritize_req_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> io_reprioritize_req),
					 MAX_IO_REPRIORITIZE_REQS * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> io_reprioritize_req),
                                      	 4096, <span class="enscript-string">&quot;io_reprioritize_req&quot;</span>);	

	result = kernel_thread_start_priority(io_reprioritize_thread, NULL, 95 <span class="enscript-comment">/* MAXPRI_KERNEL */</span>, &amp;thread);
        <span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
                thread_deallocate(thread);
        } <span class="enscript-keyword">else</span> {
                panic(<span class="enscript-string">&quot;Could not create io_reprioritize_thread&quot;</span>);
        }
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reaper_init</span>(<span class="enscript-type">void</span>)
{
	kern_return_t	kr;
	thread_t	thread;

	kr = kernel_thread_start_priority(
		(thread_continue_t) vm_object_reaper_thread,
		NULL,
		BASEPRI_PREEMPT - 1,
		&amp;thread);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;failed to launch vm_object_reaper_thread kr=0x%x&quot;</span>, kr);
	}
	thread_deallocate(thread);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 *	Finish initializing the kernel object.
	 */</span>
}


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_init_lck_grp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * initialze the vm_object lock world
	 */</span>
	lck_grp_attr_setdefault(&amp;vm_object_lck_grp_attr);
	lck_grp_init(&amp;vm_object_lck_grp, <span class="enscript-string">&quot;vm_object&quot;</span>, &amp;vm_object_lck_grp_attr);
	lck_grp_init(&amp;vm_object_cache_lck_grp, <span class="enscript-string">&quot;vm_object_cache&quot;</span>, &amp;vm_object_lck_grp_attr);
	lck_attr_setdefault(&amp;vm_object_lck_attr);
	lck_attr_setdefault(&amp;kernel_object_lck_attr);
	lck_attr_cleardebug(&amp;kernel_object_lck_attr);
	lck_attr_setdefault(&amp;compressor_object_lck_attr);
	lck_attr_cleardebug(&amp;compressor_object_lck_attr);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MIGHT_NOT_CACHE_SHADOWS</span>		1
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MIGHT_NOT_CACHE_SHADOWS</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> cache_shadows = TRUE;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MIGHT_NOT_CACHE_SHADOWS */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	vm_object_deallocate:
 *
 *	Release a reference to the specified object,
 *	gained either through a vm_object_allocate
 *	or a vm_object_reference call.  When all references
 *	are gone, storage associated with this object
 *	may be relinquished.
 *
 *	No object may be locked.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_deallocate_shared_successes = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_deallocate_shared_failures = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_deallocate_shared_swap_failures = 0;

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_deallocate</span>(
	<span class="enscript-type">register</span> vm_object_t	object)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
	boolean_t	retry_cache_trim = FALSE;
	uint32_t	try_failed_count = 0;
#<span class="enscript-reference">endif</span>
	vm_object_t	shadow = VM_OBJECT_NULL;
	
<span class="enscript-comment">//	if(object)dbgLog(object, object-&gt;ref_count, object-&gt;can_persist, 3);	/* (TEST/DEBUG) */
</span><span class="enscript-comment">//	else dbgLog(object, 0, 0, 3);	/* (TEST/DEBUG) */
</span>
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
	        <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (object == kernel_object || object == compressor_object) {
		vm_object_lock_shared(object);

		OSAddAtomic(-1, &amp;object-&gt;ref_count);

		<span class="enscript-keyword">if</span> (object-&gt;ref_count == 0) {
			<span class="enscript-keyword">if</span> (object == kernel_object)
				panic(<span class="enscript-string">&quot;vm_object_deallocate: losing kernel_object\n&quot;</span>);
			<span class="enscript-keyword">else</span>
				panic(<span class="enscript-string">&quot;vm_object_deallocate: losing compressor_object\n&quot;</span>);
		}
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (object-&gt;ref_count == 2 &amp;&amp;
	    object-&gt;named) {
		<span class="enscript-comment">/*
		 * This &quot;named&quot; object's reference count is about to
		 * drop from 2 to 1:
		 * we'll need to call memory_object_last_unmap().
		 */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;ref_count == 2 &amp;&amp;
		   object-&gt;internal &amp;&amp;
		   object-&gt;shadow != VM_OBJECT_NULL) {
		<span class="enscript-comment">/*
		 * This internal object's reference count is about to
		 * drop from 2 to 1 and it has a shadow object:
		 * we'll want to try and collapse this object with its
		 * shadow.
		 */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;ref_count &gt;= 2) { 
		UInt32		original_ref_count;
		<span class="enscript-type">volatile</span> UInt32	*ref_count_p;
		Boolean		atomic_swap;

		<span class="enscript-comment">/*
		 * The object currently looks like it is not being
		 * kept alive solely by the reference we're about to release.
		 * Let's try and release our reference without taking
		 * all the locks we would need if we had to terminate the
		 * object (cache lock + exclusive object lock).
		 * Lock the object &quot;shared&quot; to make sure we don't race with
		 * anyone holding it &quot;exclusive&quot;.
		 */</span>
	        vm_object_lock_shared(object);
		ref_count_p = (<span class="enscript-type">volatile</span> UInt32 *) &amp;object-&gt;ref_count;
		original_ref_count = object-&gt;ref_count;
		<span class="enscript-comment">/*
		 * Test again as &quot;ref_count&quot; could have changed.
		 * &quot;named&quot; shouldn't change.
		 */</span>
		<span class="enscript-keyword">if</span> (original_ref_count == 2 &amp;&amp;
		    object-&gt;named) {
			<span class="enscript-comment">/* need to take slow path for m_o_last_unmap() */</span>
			atomic_swap = FALSE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (original_ref_count == 2 &amp;&amp;
			   object-&gt;internal &amp;&amp;
			   object-&gt;shadow != VM_OBJECT_NULL) {
			<span class="enscript-comment">/* need to take slow path for vm_object_collapse() */</span>
			atomic_swap = FALSE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (original_ref_count &lt; 2) { 
			<span class="enscript-comment">/* need to take slow path for vm_object_terminate() */</span>
			atomic_swap = FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* try an atomic update with the shared lock */</span>
			atomic_swap = OSCompareAndSwap(
				original_ref_count,
				original_ref_count - 1,
				(UInt32 *) &amp;object-&gt;ref_count);
			<span class="enscript-keyword">if</span> (atomic_swap == FALSE) {
				vm_object_deallocate_shared_swap_failures++;
				<span class="enscript-comment">/* fall back to the slow path... */</span>
			}
		}
			
		vm_object_unlock(object);

		<span class="enscript-keyword">if</span> (atomic_swap) {
			<span class="enscript-comment">/*
			 * ref_count was updated atomically !
			 */</span>
			vm_object_deallocate_shared_successes++;
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * Someone else updated the ref_count at the same
		 * time and we lost the race.  Fall back to the usual
		 * slow but safe path...
		 */</span>
		vm_object_deallocate_shared_failures++;
	}

	<span class="enscript-keyword">while</span> (object != VM_OBJECT_NULL) {

		vm_object_lock(object);

		assert(object-&gt;ref_count &gt; 0);

		<span class="enscript-comment">/*
		 *	If the object has a named reference, and only
		 *	that reference would remain, inform the pager
		 *	about the last &quot;mapping&quot; reference going away.
		 */</span>
		<span class="enscript-keyword">if</span> ((object-&gt;ref_count == 2)  &amp;&amp; (object-&gt;named)) {
			memory_object_t	pager = object-&gt;pager;

			<span class="enscript-comment">/* Notify the Pager that there are no */</span>
			<span class="enscript-comment">/* more mappers for this object */</span>

			<span class="enscript-keyword">if</span> (pager != MEMORY_OBJECT_NULL) {
				vm_object_mapping_wait(object, THREAD_UNINT);
				vm_object_mapping_begin(object);
				vm_object_unlock(object);

				memory_object_last_unmap(pager);

				vm_object_lock(object);
				vm_object_mapping_end(object);
			}
			assert(object-&gt;ref_count &gt; 0);
		}

		<span class="enscript-comment">/*
		 *	Lose the reference. If other references
		 *	remain, then we are done, unless we need
		 *	to retry a cache trim.
		 *	If it is the last reference, then keep it
		 *	until any pending initialization is completed.
		 */</span>

		<span class="enscript-comment">/* if the object is terminating, it cannot go into */</span>
		<span class="enscript-comment">/* the cache and we obviously should not call      */</span>
		<span class="enscript-comment">/* terminate again.  */</span>

		<span class="enscript-keyword">if</span> ((object-&gt;ref_count &gt; 1) || object-&gt;terminating) {
			vm_object_lock_assert_exclusive(object);
			object-&gt;ref_count--;
			vm_object_res_deallocate(object);

			<span class="enscript-keyword">if</span> (object-&gt;ref_count == 1 &amp;&amp;
			    object-&gt;shadow != VM_OBJECT_NULL) {
				<span class="enscript-comment">/*
				 * There's only one reference left on this
				 * VM object.  We can't tell if it's a valid
				 * one (from a mapping for example) or if this
				 * object is just part of a possibly stale and
				 * useless shadow chain.
				 * We would like to try and collapse it into
				 * its parent, but we don't have any pointers
				 * back to this parent object.
				 * But we can try and collapse this object with
				 * its own shadows, in case these are useless
				 * too...
				 * We can't bypass this object though, since we
				 * don't know if this last reference on it is
				 * meaningful or not.
				 */</span>
				vm_object_collapse(object, 0, FALSE);
			}
			vm_object_unlock(object); 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
			<span class="enscript-keyword">if</span> (retry_cache_trim &amp;&amp;
			    ((object = vm_object_cache_trim(TRUE)) !=
			     VM_OBJECT_NULL)) {
				<span class="enscript-keyword">continue</span>;
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 *	We have to wait for initialization
		 *	before destroying or caching the object.
		 */</span>
		
		<span class="enscript-keyword">if</span> (object-&gt;pager_created &amp;&amp; ! object-&gt;pager_initialized) {
			assert(! object-&gt;can_persist);
			vm_object_assert_wait(object,
					      VM_OBJECT_EVENT_INITIALIZED,
					      THREAD_UNINT);
			vm_object_unlock(object);

			thread_block(THREAD_CONTINUE_NULL);
			<span class="enscript-keyword">continue</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
		<span class="enscript-comment">/*
		 *	If this object can persist, then enter it in
		 *	the cache. Otherwise, terminate it.
		 *
		 * 	NOTE:  Only permanent objects are cached, and
		 *	permanent objects cannot have shadows.  This
		 *	affects the residence counting logic in a minor
		 *	way (can do it in-line, mostly).
		 */</span>

		<span class="enscript-keyword">if</span> ((object-&gt;can_persist) &amp;&amp; (object-&gt;alive)) {
			<span class="enscript-comment">/*
			 *	Now it is safe to decrement reference count,
			 *	and to return if reference count is &gt; 0.
			 */</span>

			vm_object_lock_assert_exclusive(object);
			<span class="enscript-keyword">if</span> (--object-&gt;ref_count &gt; 0) {
				vm_object_res_deallocate(object);
				vm_object_unlock(object);

				<span class="enscript-keyword">if</span> (retry_cache_trim &amp;&amp;
				    ((object = vm_object_cache_trim(TRUE)) !=
				     VM_OBJECT_NULL)) {
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">return</span>;
			}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MIGHT_NOT_CACHE_SHADOWS</span>
			<span class="enscript-comment">/*
			 *	Remove shadow now if we don't
			 *	want to cache shadows.
			 */</span>
			<span class="enscript-keyword">if</span> (! cache_shadows) {
				shadow = object-&gt;shadow;
				object-&gt;shadow = VM_OBJECT_NULL;
			}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MIGHT_NOT_CACHE_SHADOWS */</span>

			<span class="enscript-comment">/*
			 *	Enter the object onto the queue of
			 *	cached objects, and deactivate
			 *	all of its pages.
			 */</span>
			assert(object-&gt;shadow == VM_OBJECT_NULL);
			VM_OBJ_RES_DECR(object);
			XPR(XPR_VM_OBJECT,
		      <span class="enscript-string">&quot;vm_o_deallocate: adding %x to cache, queue = (%x, %x)\n&quot;</span>,
				object,
				vm_object_cached_list.next,
				vm_object_cached_list.prev,0,0);


			vm_object_unlock(object);

			try_failed_count = 0;
			<span class="enscript-keyword">for</span> (;;) {
				vm_object_cache_lock();

				<span class="enscript-comment">/*
				 * if we try to take a regular lock here
				 * we risk deadlocking against someone
				 * holding a lock on this object while
				 * trying to vm_object_deallocate a different
				 * object
				 */</span>
				<span class="enscript-keyword">if</span> (vm_object_lock_try(object))
					<span class="enscript-keyword">break</span>;
				vm_object_cache_unlock();
				try_failed_count++;

				mutex_pause(try_failed_count);  <span class="enscript-comment">/* wait a bit */</span>
			}
			vm_object_cached_count++;
			<span class="enscript-keyword">if</span> (vm_object_cached_count &gt; vm_object_cached_high)
				vm_object_cached_high = vm_object_cached_count;
			queue_enter(&amp;vm_object_cached_list, object,
				vm_object_t, cached_list);
			vm_object_cache_unlock();

			vm_object_deactivate_all_pages(object);
			vm_object_unlock(object);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MIGHT_NOT_CACHE_SHADOWS</span>
			<span class="enscript-comment">/*
			 *	If we have a shadow that we need
			 *	to deallocate, do so now, remembering
			 *	to trim the cache later.
			 */</span>
			<span class="enscript-keyword">if</span> (! cache_shadows &amp;&amp; shadow != VM_OBJECT_NULL) {
				object = shadow;
				retry_cache_trim = TRUE;
				<span class="enscript-keyword">continue</span>;
			}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MIGHT_NOT_CACHE_SHADOWS */</span>

			<span class="enscript-comment">/*
			 *	Trim the cache. If the cache trim
			 *	returns with a shadow for us to deallocate,
			 *	then remember to retry the cache trim
			 *	when we are done deallocating the shadow.
			 *	Otherwise, we are done.
			 */</span>

			object = vm_object_cache_trim(TRUE);
			<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
				<span class="enscript-keyword">return</span>;
			}
			retry_cache_trim = TRUE;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VM_OBJECT_CACHE */</span>
		{
			<span class="enscript-comment">/*
			 *	This object is not cachable; terminate it.
			 */</span>
			XPR(XPR_VM_OBJECT,
	 <span class="enscript-string">&quot;vm_o_deallocate: !cacheable 0x%X res %d paging_ops %d thread 0x%p ref %d\n&quot;</span>,
			    object, object-&gt;resident_page_count,
			    object-&gt;paging_in_progress,
			    (<span class="enscript-type">void</span> *)current_thread(),object-&gt;ref_count);

			VM_OBJ_RES_DECR(object);	<span class="enscript-comment">/* XXX ? */</span>
			<span class="enscript-comment">/*
			 *	Terminate this object. If it had a shadow,
			 *	then deallocate it; otherwise, if we need
			 *	to retry a cache trim, do so now; otherwise,
			 *	we are done. &quot;pageout&quot; objects have a shadow,
			 *	but maintain a &quot;paging reference&quot; rather than
			 *	a normal reference.
			 */</span>
			shadow = object-&gt;pageout?VM_OBJECT_NULL:object-&gt;shadow;

			<span class="enscript-keyword">if</span> (vm_object_terminate(object) != KERN_SUCCESS) {
				<span class="enscript-keyword">return</span>;
			}
			<span class="enscript-keyword">if</span> (shadow != VM_OBJECT_NULL) {
				object = shadow;
				<span class="enscript-keyword">continue</span>;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
			<span class="enscript-keyword">if</span> (retry_cache_trim &amp;&amp;
			    ((object = vm_object_cache_trim(TRUE)) !=
			     VM_OBJECT_NULL)) {
				<span class="enscript-keyword">continue</span>;
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span>;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
	assert(! retry_cache_trim);
#<span class="enscript-reference">endif</span>
}



vm_page_t
<span class="enscript-function-name">vm_object_page_grab</span>(
	vm_object_t	object)
{
	vm_page_t	p, next_p;
	<span class="enscript-type">int</span>		p_limit = 0;
	<span class="enscript-type">int</span>		p_skipped = 0;

	vm_object_lock_assert_exclusive(object);

	next_p = (vm_page_t)queue_first(&amp;object-&gt;memq);
	p_limit = MIN(50, object-&gt;resident_page_count);

	<span class="enscript-keyword">while</span> (!queue_end(&amp;object-&gt;memq, (queue_entry_t)next_p) &amp;&amp; --p_limit &gt; 0) {

		p = next_p;
		next_p = (vm_page_t)queue_next(&amp;next_p-&gt;listq);

		<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p) || p-&gt;busy || p-&gt;cleaning || p-&gt;laundry || p-&gt;fictitious)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">move_page_in_obj</span>;

		<span class="enscript-keyword">if</span> (p-&gt;pmapped || p-&gt;dirty || p-&gt;precious) {
			vm_page_lockspin_queues();

			<span class="enscript-keyword">if</span> (p-&gt;pmapped) {
				<span class="enscript-type">int</span> refmod_state;

				vm_object_page_grab_pmapped++;

				<span class="enscript-keyword">if</span> (p-&gt;reference == FALSE || p-&gt;dirty == FALSE) {

					refmod_state = pmap_get_refmod(p-&gt;phys_page);

					<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_REFERENCED)
						p-&gt;reference = TRUE;
					<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_MODIFIED) {
						SET_PAGE_DIRTY(p, FALSE);
					}
				}
				<span class="enscript-keyword">if</span> (p-&gt;dirty == FALSE &amp;&amp; p-&gt;precious == FALSE) {

					refmod_state = pmap_disconnect(p-&gt;phys_page);

					<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_REFERENCED)
						p-&gt;reference = TRUE;
					<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_MODIFIED) {
						SET_PAGE_DIRTY(p, FALSE);
					}

					<span class="enscript-keyword">if</span> (p-&gt;dirty == FALSE)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">take_page</span>;
				}
			}
			<span class="enscript-keyword">if</span> (p-&gt;inactive &amp;&amp; p-&gt;reference == TRUE) {
				vm_page_activate(p);

				VM_STAT_INCR(reactivations);
				vm_object_page_grab_reactivations++;
			}
			vm_page_unlock_queues();
<span class="enscript-reference">move_page_in_obj</span>:
			queue_remove(&amp;object-&gt;memq, p, vm_page_t, listq);
			queue_enter(&amp;object-&gt;memq, p, vm_page_t, listq);

			p_skipped++;
			<span class="enscript-keyword">continue</span>;
		}
		vm_page_lockspin_queues();
<span class="enscript-reference">take_page</span>:
		vm_page_free_prepare_queues(p);
		vm_object_page_grab_returned++;
		vm_object_page_grab_skipped += p_skipped;

		vm_page_unlock_queues();

		vm_page_free_prepare_object(p, TRUE);
		
		<span class="enscript-keyword">return</span> (p);
	}
	vm_object_page_grab_skipped += p_skipped;
	vm_object_page_grab_failed++;

	<span class="enscript-keyword">return</span> (NULL);
}



#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EVICT_PREPARE_LIMIT</span>	64
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EVICT_AGE</span>		10

<span class="enscript-type">static</span>	clock_sec_t	vm_object_cache_aging_ts = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_cache_remove_locked</span>(
	vm_object_t	object)
{
	queue_remove(&amp;vm_object_cached_list, object, vm_object_t, objq);
	object-&gt;objq.next = NULL;
	object-&gt;objq.prev = NULL;

	vm_object_cached_count--;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_cache_remove</span>(
	vm_object_t	object)
{
	vm_object_cache_lock_spin();

	<span class="enscript-keyword">if</span> (object-&gt;objq.next || object-&gt;objq.prev)
		vm_object_cache_remove_locked(object);

	vm_object_cache_unlock();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_cache_add</span>(
	vm_object_t	object)
{
	clock_sec_t sec;
	clock_nsec_t nsec;

	<span class="enscript-keyword">if</span> (object-&gt;resident_page_count == 0)
		<span class="enscript-keyword">return</span>;
	clock_get_system_nanotime(&amp;sec, &amp;nsec);

	vm_object_cache_lock_spin();

	<span class="enscript-keyword">if</span> (object-&gt;objq.next == NULL &amp;&amp; object-&gt;objq.prev == NULL) {
		queue_enter(&amp;vm_object_cached_list, object, vm_object_t, objq);
		object-&gt;vo_cache_ts = sec + EVICT_AGE;
		object-&gt;vo_cache_pages_to_scan = object-&gt;resident_page_count;

		vm_object_cached_count++;
		vm_object_cache_adds++;
	}
	vm_object_cache_unlock();
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_object_cache_evict</span>(
	<span class="enscript-type">int</span>	num_to_evict,
	<span class="enscript-type">int</span>	max_objects_to_examine)
{
	vm_object_t	object = VM_OBJECT_NULL;
	vm_object_t	next_obj = VM_OBJECT_NULL;
	vm_page_t	local_free_q = VM_PAGE_NULL;
	vm_page_t	p;
	vm_page_t	next_p;
	<span class="enscript-type">int</span>		object_cnt = 0;
	vm_page_t	ep_array[EVICT_PREPARE_LIMIT];
	<span class="enscript-type">int</span>		ep_count;
	<span class="enscript-type">int</span>		ep_limit;
	<span class="enscript-type">int</span>		ep_index;
	<span class="enscript-type">int</span>		ep_freed = 0;
	<span class="enscript-type">int</span>		ep_moved = 0;
	uint32_t	ep_skipped = 0;
	clock_sec_t	sec;
	clock_nsec_t	nsec;

	KERNEL_DEBUG(0x13001ec | DBG_FUNC_START, 0, 0, 0, 0, 0);
	<span class="enscript-comment">/*
	 * do a couple of quick checks to see if it's 
	 * worthwhile grabbing the lock
	 */</span>
	<span class="enscript-keyword">if</span> (queue_empty(&amp;vm_object_cached_list)) {
		KERNEL_DEBUG(0x13001ec | DBG_FUNC_END, 0, 0, 0, 0, 0);
		<span class="enscript-keyword">return</span> (0);
	}
	clock_get_system_nanotime(&amp;sec, &amp;nsec);

	<span class="enscript-comment">/*
	 * the object on the head of the queue has not
	 * yet sufficiently aged
	 */</span>
	<span class="enscript-keyword">if</span> (sec &lt; vm_object_cache_aging_ts) {
		KERNEL_DEBUG(0x13001ec | DBG_FUNC_END, 0, 0, 0, 0, 0);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/*
	 * don't need the queue lock to find 
	 * and lock an object on the cached list
	 */</span>
	vm_page_unlock_queues();

	vm_object_cache_lock_spin();

	<span class="enscript-keyword">for</span> (;;) {
		next_obj = (vm_object_t)queue_first(&amp;vm_object_cached_list);

		<span class="enscript-keyword">while</span> (!queue_end(&amp;vm_object_cached_list, (queue_entry_t)next_obj) &amp;&amp; object_cnt++ &lt; max_objects_to_examine) {

			object = next_obj;
			next_obj = (vm_object_t)queue_next(&amp;next_obj-&gt;objq);
			
			<span class="enscript-keyword">if</span> (sec &lt; object-&gt;vo_cache_ts) {
				KERNEL_DEBUG(0x130020c, object, object-&gt;resident_page_count, object-&gt;vo_cache_ts, sec, 0);

				vm_object_cache_aging_ts = object-&gt;vo_cache_ts;
				object = VM_OBJECT_NULL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (!vm_object_lock_try_scan(object)) {
				<span class="enscript-comment">/*
				 * just skip over this guy for now... if we find
				 * an object to steal pages from, we'll revist in a bit...
				 * hopefully, the lock will have cleared
				 */</span>
				KERNEL_DEBUG(0x13001f8, object, object-&gt;resident_page_count, 0, 0, 0);

				object = VM_OBJECT_NULL;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (queue_empty(&amp;object-&gt;memq) || object-&gt;vo_cache_pages_to_scan == 0) {
				<span class="enscript-comment">/*
				 * this case really shouldn't happen, but it's not fatal
				 * so deal with it... if we don't remove the object from
				 * the list, we'll never move past it.
				 */</span>
				KERNEL_DEBUG(0x13001fc, object, object-&gt;resident_page_count, ep_freed, ep_moved, 0);
				
				vm_object_cache_remove_locked(object);
				vm_object_unlock(object);
				object = VM_OBJECT_NULL;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/*
			 * we have a locked object with pages...
			 * time to start harvesting
			 */</span>
			<span class="enscript-keyword">break</span>;
		}
		vm_object_cache_unlock();

		<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * object is locked at this point and
		 * has resident pages
		 */</span>
		next_p = (vm_page_t)queue_first(&amp;object-&gt;memq);

		<span class="enscript-comment">/*
		 * break the page scan into 2 pieces to minimize the time spent
		 * behind the page queue lock...
		 * the list of pages on these unused objects is likely to be cold
		 * w/r to the cpu cache which increases the time to scan the list
		 * tenfold...  and we may have a 'run' of pages we can't utilize that
		 * needs to be skipped over...
		 */</span>
		<span class="enscript-keyword">if</span> ((ep_limit = num_to_evict - (ep_freed + ep_moved)) &gt; EVICT_PREPARE_LIMIT)
			ep_limit = EVICT_PREPARE_LIMIT;
		ep_count = 0;

		<span class="enscript-keyword">while</span> (!queue_end(&amp;object-&gt;memq, (queue_entry_t)next_p) &amp;&amp; object-&gt;vo_cache_pages_to_scan &amp;&amp; ep_count &lt; ep_limit) {

			p = next_p;
			next_p = (vm_page_t)queue_next(&amp;next_p-&gt;listq);

			object-&gt;vo_cache_pages_to_scan--;

			<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p) || p-&gt;busy || p-&gt;cleaning || p-&gt;laundry) {
				queue_remove(&amp;object-&gt;memq, p, vm_page_t, listq);
				queue_enter(&amp;object-&gt;memq, p, vm_page_t, listq);

				ep_skipped++;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (p-&gt;wpmapped || p-&gt;dirty || p-&gt;precious) {
				queue_remove(&amp;object-&gt;memq, p, vm_page_t, listq);
				queue_enter(&amp;object-&gt;memq, p, vm_page_t, listq);

				pmap_clear_reference(p-&gt;phys_page);
			}
			ep_array[ep_count++] = p;
		}
		KERNEL_DEBUG(0x13001f4 | DBG_FUNC_START, object, object-&gt;resident_page_count, ep_freed, ep_moved, 0);

		vm_page_lockspin_queues();

		<span class="enscript-keyword">for</span> (ep_index = 0; ep_index &lt; ep_count; ep_index++) {

			p = ep_array[ep_index];

			<span class="enscript-keyword">if</span> (p-&gt;wpmapped || p-&gt;dirty || p-&gt;precious) {
				p-&gt;reference = FALSE;
				p-&gt;no_cache = FALSE;

				<span class="enscript-comment">/*
				 * we've already filtered out pages that are in the laundry
				 * so if we get here, this page can't be on the pageout queue
				 */</span>
				assert(!p-&gt;pageout_queue);

				vm_page_queues_remove(p);
				vm_page_enqueue_inactive(p, TRUE);

				ep_moved++;
			} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
				vm_phantom_cache_add_ghost(p);
#<span class="enscript-reference">endif</span>
				vm_page_free_prepare_queues(p);

				assert(p-&gt;pageq.next == NULL &amp;&amp; p-&gt;pageq.prev == NULL);
				<span class="enscript-comment">/*
				 * Add this page to our list of reclaimed pages,
				 * to be freed later.
				 */</span>
				p-&gt;pageq.next = (queue_entry_t) local_free_q;
				local_free_q = p;

				ep_freed++;
			}
		}
		vm_page_unlock_queues();

		KERNEL_DEBUG(0x13001f4 | DBG_FUNC_END, object, object-&gt;resident_page_count, ep_freed, ep_moved, 0);

		<span class="enscript-keyword">if</span> (local_free_q) {
			vm_page_free_list(local_free_q, TRUE);
			local_free_q = VM_PAGE_NULL;
		}
		<span class="enscript-keyword">if</span> (object-&gt;vo_cache_pages_to_scan == 0) {
			KERNEL_DEBUG(0x1300208, object, object-&gt;resident_page_count, ep_freed, ep_moved, 0);

			vm_object_cache_remove(object);

			KERNEL_DEBUG(0x13001fc, object, object-&gt;resident_page_count, ep_freed, ep_moved, 0);
		}
		<span class="enscript-comment">/*
		 * done with this object
		 */</span>
		vm_object_unlock(object);
		object = VM_OBJECT_NULL;

		<span class="enscript-comment">/*
		 * at this point, we are not holding any locks
		 */</span>
		<span class="enscript-keyword">if</span> ((ep_freed + ep_moved) &gt;= num_to_evict) {
			<span class="enscript-comment">/*
			 * we've reached our target for the
			 * number of pages to evict
			 */</span>
			<span class="enscript-keyword">break</span>;
		}
		vm_object_cache_lock_spin();
	}
	<span class="enscript-comment">/*
	 * put the page queues lock back to the caller's
	 * idea of it 
	 */</span>
	vm_page_lock_queues();

	vm_object_cache_pages_freed += ep_freed;
	vm_object_cache_pages_moved += ep_moved;
	vm_object_cache_pages_skipped += ep_skipped;

	KERNEL_DEBUG(0x13001ec | DBG_FUNC_END, ep_freed, 0, 0, 0, 0);
	<span class="enscript-keyword">return</span> (ep_freed);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
<span class="enscript-comment">/*
 *	Check to see whether we really need to trim
 *	down the cache. If so, remove an object from
 *	the cache, terminate it, and repeat.
 *
 *	Called with, and returns with, cache lock unlocked.
 */</span>
vm_object_t
<span class="enscript-function-name">vm_object_cache_trim</span>(
	boolean_t called_from_vm_object_deallocate)
{
	<span class="enscript-type">register</span> vm_object_t object = VM_OBJECT_NULL;
	vm_object_t shadow;

	<span class="enscript-keyword">for</span> (;;) {

		<span class="enscript-comment">/*
		 *	If we no longer need to trim the cache,
		 *	then we are done.
		 */</span>
		<span class="enscript-keyword">if</span> (vm_object_cached_count &lt;= vm_object_cached_max)
			<span class="enscript-keyword">return</span> VM_OBJECT_NULL;

		vm_object_cache_lock();
		<span class="enscript-keyword">if</span> (vm_object_cached_count &lt;= vm_object_cached_max) {
			vm_object_cache_unlock();
			<span class="enscript-keyword">return</span> VM_OBJECT_NULL;
		}

		<span class="enscript-comment">/*
		 *	We must trim down the cache, so remove
		 *	the first object in the cache.
		 */</span>
		XPR(XPR_VM_OBJECT,
		<span class="enscript-string">&quot;vm_object_cache_trim: removing from front of cache (%x, %x)\n&quot;</span>,
			vm_object_cached_list.next,
			vm_object_cached_list.prev, 0, 0, 0);

		object = (vm_object_t) queue_first(&amp;vm_object_cached_list);
		<span class="enscript-keyword">if</span>(object == (vm_object_t) &amp;vm_object_cached_list) {
			<span class="enscript-comment">/* something's wrong with the calling parameter or */</span>
			<span class="enscript-comment">/* the value of vm_object_cached_count, just fix   */</span>
			<span class="enscript-comment">/* and return */</span>
			<span class="enscript-keyword">if</span>(vm_object_cached_max &lt; 0)
				vm_object_cached_max = 0;
			vm_object_cached_count = 0;
			vm_object_cache_unlock();
			<span class="enscript-keyword">return</span> VM_OBJECT_NULL;
		}
		vm_object_lock(object);
		queue_remove(&amp;vm_object_cached_list, object, vm_object_t,
			     cached_list);
		vm_object_cached_count--;

		vm_object_cache_unlock();
		<span class="enscript-comment">/*
		 *	Since this object is in the cache, we know
		 *	that it is initialized and has no references.
		 *	Take a reference to avoid recursive deallocations.
		 */</span>

		assert(object-&gt;pager_initialized);
		assert(object-&gt;ref_count == 0);
		vm_object_lock_assert_exclusive(object);
		object-&gt;ref_count++;

		<span class="enscript-comment">/*
		 *	Terminate the object.
		 *	If the object had a shadow, we let vm_object_deallocate
		 *	deallocate it. &quot;pageout&quot; objects have a shadow, but
		 *	maintain a &quot;paging reference&quot; rather than a normal
		 *	reference.
		 *	(We are careful here to limit recursion.)
		 */</span>
		shadow = object-&gt;pageout?VM_OBJECT_NULL:object-&gt;shadow;

		<span class="enscript-keyword">if</span>(vm_object_terminate(object) != KERN_SUCCESS)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (shadow != VM_OBJECT_NULL) {
			<span class="enscript-keyword">if</span> (called_from_vm_object_deallocate) {
				<span class="enscript-keyword">return</span> shadow;
			} <span class="enscript-keyword">else</span> {
				vm_object_deallocate(shadow);
			}
		}
	}
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 *	Routine:	vm_object_terminate
 *	Purpose:
 *		Free all resources associated with a vm_object.
 *	In/out conditions:
 *		Upon entry, the object must be locked,
 *		and the object must have exactly one reference.
 *
 *		The shadow object reference is left alone.
 *
 *		The object must be unlocked if its found that pages
 *		must be flushed to a backing object.  If someone
 *		manages to map the object while it is being flushed
 *		the object is returned unlocked and unchanged.  Otherwise,
 *		upon exit, the cache will be unlocked, and the
 *		object will cease to exist.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vm_object_terminate</span>(
	vm_object_t	object)
{
	vm_object_t	shadow_object;

	XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;vm_object_terminate, object 0x%X ref %d\n&quot;</span>,
		object, object-&gt;ref_count, 0, 0, 0);

	<span class="enscript-keyword">if</span> (!object-&gt;pageout &amp;&amp; (!object-&gt;temporary || object-&gt;can_persist) &amp;&amp;
	    (object-&gt;pager != NULL || object-&gt;shadow_severed)) {
		<span class="enscript-comment">/*
		 * Clear pager_trusted bit so that the pages get yanked
		 * out of the object instead of cleaned in place.  This
		 * prevents a deadlock in XMM and makes more sense anyway.
		 */</span>
		object-&gt;pager_trusted = FALSE;

		vm_object_reap_pages(object, REAP_TERMINATE);
	}
	<span class="enscript-comment">/*
	 *	Make sure the object isn't already being terminated
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;terminating) {
		vm_object_lock_assert_exclusive(object);
		object-&gt;ref_count--;
		assert(object-&gt;ref_count &gt; 0);
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	<span class="enscript-comment">/*
	 * Did somebody get a reference to the object while we were
	 * cleaning it?
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;ref_count != 1) {
		vm_object_lock_assert_exclusive(object);
		object-&gt;ref_count--;
		assert(object-&gt;ref_count &gt; 0);
		vm_object_res_deallocate(object);
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	<span class="enscript-comment">/*
	 *	Make sure no one can look us up now.
	 */</span>

	object-&gt;terminating = TRUE;
	object-&gt;alive = FALSE;

	<span class="enscript-keyword">if</span> ( !object-&gt;internal &amp;&amp; (object-&gt;objq.next || object-&gt;objq.prev))
		vm_object_cache_remove(object);

	<span class="enscript-keyword">if</span> (object-&gt;hashed) {
		lck_mtx_t	*lck;

		lck = vm_object_hash_lock_spin(object-&gt;pager);
		vm_object_remove(object);
		vm_object_hash_unlock(lck);
	}
	<span class="enscript-comment">/*
	 *	Detach the object from its shadow if we are the shadow's
	 *	copy. The reference we hold on the shadow must be dropped
	 *	by our caller.
	 */</span>
	<span class="enscript-keyword">if</span> (((shadow_object = object-&gt;shadow) != VM_OBJECT_NULL) &amp;&amp;
	    !(object-&gt;pageout)) {
		vm_object_lock(shadow_object);
		<span class="enscript-keyword">if</span> (shadow_object-&gt;copy == object)
			shadow_object-&gt;copy = VM_OBJECT_NULL;
		vm_object_unlock(shadow_object);
	}

	<span class="enscript-keyword">if</span> (object-&gt;paging_in_progress != 0 ||
	    object-&gt;activity_in_progress != 0) {
		<span class="enscript-comment">/*
		 * There are still some paging_in_progress references
		 * on this object, meaning that there are some paging
		 * or other I/O operations in progress for this VM object.
		 * Such operations take some paging_in_progress references
		 * up front to ensure that the object doesn't go away, but
		 * they may also need to acquire a reference on the VM object,
		 * to map it in kernel space, for example.  That means that
		 * they may end up releasing the last reference on the VM
		 * object, triggering its termination, while still holding
		 * paging_in_progress references.  Waiting for these
		 * pending paging_in_progress references to go away here would
		 * deadlock.
		 *
		 * To avoid deadlocking, we'll let the vm_object_reaper_thread
		 * complete the VM object termination if it still holds
		 * paging_in_progress references at this point.
		 *
		 * No new paging_in_progress should appear now that the
		 * VM object is &quot;terminating&quot; and not &quot;alive&quot;.
		 */</span>
		vm_object_reap_async(object);
		vm_object_unlock(object);
		<span class="enscript-comment">/*
		 * Return KERN_FAILURE to let the caller know that we
		 * haven't completed the termination and it can't drop this
		 * object's reference on its shadow object yet.
		 * The reaper thread will take care of that once it has
		 * completed this object's termination.
		 */</span>
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
	<span class="enscript-comment">/*
	 * complete the VM object termination
	 */</span>
	vm_object_reap(object);
	object = VM_OBJECT_NULL;

	<span class="enscript-comment">/*
	 * the object lock was released by vm_object_reap()
	 *
	 * KERN_SUCCESS means that this object has been terminated
	 * and no longer needs its shadow object but still holds a
	 * reference on it.
	 * The caller is responsible for dropping that reference.
	 * We can't call vm_object_deallocate() here because that
	 * would create a recursion.
	 */</span>
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 * vm_object_reap():
 *
 * Complete the termination of a VM object after it's been marked
 * as &quot;terminating&quot; and &quot;!alive&quot; by vm_object_terminate().
 *
 * The VM object must be locked by caller.
 * The lock will be released on return and the VM object is no longer valid.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reap</span>(
	vm_object_t object)
{
	memory_object_t		pager;

	vm_object_lock_assert_exclusive(object);
	assert(object-&gt;paging_in_progress == 0);
	assert(object-&gt;activity_in_progress == 0);

	vm_object_reap_count++;

	<span class="enscript-comment">/*
	 * Disown this purgeable object to cleanup its owner's purgeable
	 * ledgers.  We need to do this before disconnecting the object
	 * from its pager, to properly account for compressed pages.
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;internal &amp;&amp;
	    object-&gt;purgable != VM_PURGABLE_DENY) {
		vm_purgeable_accounting(object,
					object-&gt;purgable,
					TRUE); <span class="enscript-comment">/* disown */</span>
	}

	pager = object-&gt;pager;
	object-&gt;pager = MEMORY_OBJECT_NULL;

	<span class="enscript-keyword">if</span> (pager != MEMORY_OBJECT_NULL)
		memory_object_control_disable(object-&gt;pager_control);

	object-&gt;ref_count--;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
	assert(object-&gt;res_count == 0);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

	assert (object-&gt;ref_count == 0);

	<span class="enscript-comment">/*
	 * remove from purgeable queue if it's on
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;internal) {
		task_t owner;

		owner = object-&gt;vo_purgeable_owner;

		VM_OBJECT_UNWIRED(object);

		<span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_DENY) {
			<span class="enscript-comment">/* not purgeable: nothing to do */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_VOLATILE) {
			purgeable_q_t queue;

			assert(object-&gt;vo_purgeable_owner == NULL);

			queue = vm_purgeable_object_remove(object);
			assert(queue);

			<span class="enscript-keyword">if</span> (object-&gt;purgeable_when_ripe) {
				<span class="enscript-comment">/*
				 * Must take page lock for this -
				 * using it to protect token queue
				 */</span>
				vm_page_lock_queues();
				vm_purgeable_token_delete_first(queue);
        
				assert(queue-&gt;debug_count_objects&gt;=0);
				vm_page_unlock_queues();
			}

			<span class="enscript-comment">/*
			 * Update &quot;vm_page_purgeable_count&quot; in bulk and mark
			 * object as VM_PURGABLE_EMPTY to avoid updating 
			 * &quot;vm_page_purgeable_count&quot; again in vm_page_remove()
			 * when reaping the pages.
			 */</span>
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> delta;
			assert(object-&gt;resident_page_count &gt;=
			       object-&gt;wired_page_count);
			delta = (object-&gt;resident_page_count -
				 object-&gt;wired_page_count);
			<span class="enscript-keyword">if</span> (delta != 0) {
				assert(vm_page_purgeable_count &gt;= delta);
				OSAddAtomic(-delta,
					    (SInt32 *)&amp;vm_page_purgeable_count);
			}
			<span class="enscript-keyword">if</span> (object-&gt;wired_page_count != 0) {
				assert(vm_page_purgeable_wired_count &gt;=
				       object-&gt;wired_page_count);
				OSAddAtomic(-object-&gt;wired_page_count,
					    (SInt32 *)&amp;vm_page_purgeable_wired_count);
			}
			object-&gt;purgable = VM_PURGABLE_EMPTY;
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_NONVOLATILE ||
			 object-&gt;purgable == VM_PURGABLE_EMPTY) {
			<span class="enscript-comment">/* remove from nonvolatile queue */</span>
			assert(object-&gt;vo_purgeable_owner == TASK_NULL);
			vm_purgeable_nonvolatile_dequeue(object);
		} <span class="enscript-keyword">else</span> {
			panic(<span class="enscript-string">&quot;object %p in unexpected purgeable state 0x%x\n&quot;</span>,
			      object, object-&gt;purgable);
		}
		assert(object-&gt;objq.next == NULL);
		assert(object-&gt;objq.prev == NULL);
	}
    
	<span class="enscript-comment">/*
	 *	Clean or free the pages, as appropriate.
	 *	It is possible for us to find busy/absent pages,
	 *	if some faults on this object were aborted.
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;pageout) {
		assert(object-&gt;shadow != VM_OBJECT_NULL);

		vm_pageout_object_terminate(object);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((object-&gt;temporary &amp;&amp; !object-&gt;can_persist) || (pager == MEMORY_OBJECT_NULL))) {

		vm_object_reap_pages(object, REAP_REAP);
	}
	assert(queue_empty(&amp;object-&gt;memq));
	assert(object-&gt;paging_in_progress == 0);
	assert(object-&gt;activity_in_progress == 0);
	assert(object-&gt;ref_count == 0);

	<span class="enscript-comment">/*
	 * If the pager has not already been released by
	 * vm_object_destroy, we need to terminate it and
	 * release our reference to it here.
	 */</span>
	<span class="enscript-keyword">if</span> (pager != MEMORY_OBJECT_NULL) {
		vm_object_unlock(object);
		vm_object_release_pager(pager, object-&gt;hashed);
		vm_object_lock(object);
	}

	<span class="enscript-comment">/* kick off anyone waiting on terminating */</span>
	object-&gt;terminating = FALSE;
	vm_object_paging_begin(object);
	vm_object_paging_end(object);
	vm_object_unlock(object);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	vm_external_destroy(object-&gt;existence_map, object-&gt;vo_size);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>

	object-&gt;shadow = VM_OBJECT_NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING</span>
	<span class="enscript-keyword">if</span> (vm_object_tracking_inited) {
		btlog_remove_entries_for_element(vm_object_tracking_btlog,
						 object);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJECT_TRACKING */</span>

	vm_object_lock_destroy(object);
	<span class="enscript-comment">/*
	 *	Free the space for the object.
	 */</span>
	zfree(vm_object_zone, object);
	object = VM_OBJECT_NULL;
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_max_batch = 256;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">V_O_R_MAX_BATCH</span> 128

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BATCH_LIMIT</span>(max) 	(vm_max_batch &gt;= max ? max : vm_max_batch)


#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_OBJ_REAP_FREELIST</span>(_local_free_q, do_disconnect)		\
	MACRO_BEGIN							\
	<span class="enscript-keyword">if</span> (_local_free_q) {						\
		<span class="enscript-keyword">if</span> (do_disconnect) {					\
			vm_page_t m;					\
			<span class="enscript-keyword">for</span> (m = _local_free_q;				\
			     m != VM_PAGE_NULL;				\
			     m = (vm_page_t) m-&gt;pageq.next) {		\
				<span class="enscript-keyword">if</span> (m-&gt;pmapped) {			\
					pmap_disconnect(m-&gt;phys_page);	\
				}					\
			}						\
		}							\
		vm_page_free_list(_local_free_q, TRUE);			\
		_local_free_q = VM_PAGE_NULL;				\
	}								\
	MACRO_END


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reap_pages</span>(
	vm_object_t 	object,
	<span class="enscript-type">int</span>		reap_type)
{
	vm_page_t	p;
	vm_page_t	next;
	vm_page_t	local_free_q = VM_PAGE_NULL;
	<span class="enscript-type">int</span>		loop_count;
	boolean_t	disconnect_on_release;
	pmap_flush_context	pmap_flush_context_storage;

	<span class="enscript-keyword">if</span> (reap_type == REAP_DATA_FLUSH) {
		<span class="enscript-comment">/*
		 * We need to disconnect pages from all pmaps before
		 * releasing them to the free list
		 */</span>
		disconnect_on_release = TRUE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Either the caller has already disconnected the pages
		 * from all pmaps, or we disconnect them here as we add
		 * them to out local list of pages to be released.
		 * No need to re-disconnect them when we release the pages
		 * to the free list.
		 */</span>
		disconnect_on_release = FALSE;
	}
		
<span class="enscript-reference">restart_after_sleep</span>:
	<span class="enscript-keyword">if</span> (queue_empty(&amp;object-&gt;memq))
		<span class="enscript-keyword">return</span>;
	loop_count = BATCH_LIMIT(V_O_R_MAX_BATCH);

	<span class="enscript-keyword">if</span> (reap_type == REAP_PURGEABLE)
		pmap_flush_context_init(&amp;pmap_flush_context_storage);

	vm_page_lockspin_queues();

	next = (vm_page_t)queue_first(&amp;object-&gt;memq);

	<span class="enscript-keyword">while</span> (!queue_end(&amp;object-&gt;memq, (queue_entry_t)next)) {

		p = next;
		next = (vm_page_t)queue_next(&amp;next-&gt;listq);

		<span class="enscript-keyword">if</span> (--loop_count == 0) {
					
			vm_page_unlock_queues();

			<span class="enscript-keyword">if</span> (local_free_q) {

				<span class="enscript-keyword">if</span> (reap_type == REAP_PURGEABLE) {
					pmap_flush(&amp;pmap_flush_context_storage);
					pmap_flush_context_init(&amp;pmap_flush_context_storage);
				}
				<span class="enscript-comment">/*
				 * Free the pages we reclaimed so far
				 * and take a little break to avoid
				 * hogging the page queue lock too long
				 */</span>
				VM_OBJ_REAP_FREELIST(local_free_q,
						     disconnect_on_release);
			} <span class="enscript-keyword">else</span>
				mutex_pause(0);

			loop_count = BATCH_LIMIT(V_O_R_MAX_BATCH);

			vm_page_lockspin_queues();
		}
		<span class="enscript-keyword">if</span> (reap_type == REAP_DATA_FLUSH || reap_type == REAP_TERMINATE) {

			<span class="enscript-keyword">if</span> (p-&gt;busy || p-&gt;cleaning) {

				vm_page_unlock_queues();
				<span class="enscript-comment">/*
				 * free the pages reclaimed so far
				 */</span>
				VM_OBJ_REAP_FREELIST(local_free_q,
						     disconnect_on_release);

				PAGE_SLEEP(object, p, THREAD_UNINT);

				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart_after_sleep</span>;
			}
			<span class="enscript-keyword">if</span> (p-&gt;laundry) {
				p-&gt;pageout = FALSE;

				vm_pageout_steal_laundry(p, TRUE);
			}
		}
		<span class="enscript-keyword">switch</span> (reap_type) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">REAP_DATA_FLUSH</span>:
			<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p)) {
				<span class="enscript-comment">/*
				 * this is an odd case... perhaps we should
				 * zero-fill this page since we're conceptually
				 * tossing its data at this point, but leaving
				 * it on the object to honor the 'wire' contract
				 */</span>
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">REAP_PURGEABLE</span>:
			<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p)) {
				<span class="enscript-comment">/*
				 * can't purge a wired page
				 */</span>
				vm_page_purged_wired++;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (p-&gt;laundry &amp;&amp; !p-&gt;busy &amp;&amp; !p-&gt;cleaning) {
				p-&gt;pageout = FALSE;

				vm_pageout_steal_laundry(p, TRUE);
			}
			<span class="enscript-keyword">if</span> (p-&gt;cleaning || p-&gt;laundry || p-&gt;absent) {
				<span class="enscript-comment">/*
				 * page is being acted upon,
				 * so don't mess with it
				 */</span>
				vm_page_purged_others++;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (p-&gt;busy) {
				<span class="enscript-comment">/*
				 * We can't reclaim a busy page but we can
				 * make it more likely to be paged (it's not wired) to make
				 * sure that it gets considered by
				 * vm_pageout_scan() later.
				 */</span>
				vm_page_deactivate(p);
				vm_page_purged_busy++;
				<span class="enscript-keyword">continue</span>;
			}

			assert(p-&gt;object != kernel_object);

			<span class="enscript-comment">/*
			 * we can discard this page...
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;pmapped == TRUE) {
				<span class="enscript-comment">/*
				 * unmap the page
				 */</span>
				pmap_disconnect_options(p-&gt;phys_page, PMAP_OPTIONS_NOFLUSH | PMAP_OPTIONS_NOREFMOD, (<span class="enscript-type">void</span> *)&amp;pmap_flush_context_storage);
			}
			vm_page_purged_count++;

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">REAP_TERMINATE</span>:
			<span class="enscript-keyword">if</span> (p-&gt;absent || p-&gt;private) {
				<span class="enscript-comment">/*
				 *	For private pages, VM_PAGE_FREE just
				 *	leaves the page structure around for
				 *	its owner to clean up.  For absent
				 *	pages, the structure is returned to
				 *	the appropriate pool.
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (p-&gt;fictitious) {
				assert (p-&gt;phys_page == vm_page_guard_addr);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (!p-&gt;dirty &amp;&amp; p-&gt;wpmapped)
				p-&gt;dirty = pmap_is_modified(p-&gt;phys_page);

			<span class="enscript-keyword">if</span> ((p-&gt;dirty || p-&gt;precious) &amp;&amp; !p-&gt;error &amp;&amp; object-&gt;alive) {

				assert(!object-&gt;internal);
			
				<span class="enscript-keyword">if</span> (!p-&gt;laundry) {
					vm_page_queues_remove(p);
					<span class="enscript-comment">/*
					 * flush page... page will be freed
					 * upon completion of I/O
					 */</span>
					(<span class="enscript-type">void</span>)vm_pageout_cluster(p, TRUE, FALSE, FALSE);
				}
				vm_page_unlock_queues();
				<span class="enscript-comment">/*
				 * free the pages reclaimed so far
				 */</span>
				VM_OBJ_REAP_FREELIST(local_free_q,
						     disconnect_on_release);

				vm_object_paging_wait(object, THREAD_UNINT);

				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart_after_sleep</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">REAP_REAP</span>:
			<span class="enscript-keyword">break</span>;
		}
		vm_page_free_prepare_queues(p);
		assert(p-&gt;pageq.next == NULL &amp;&amp; p-&gt;pageq.prev == NULL);
		<span class="enscript-comment">/*
		 * Add this page to our list of reclaimed pages,
		 * to be freed later.
		 */</span>
		p-&gt;pageq.next = (queue_entry_t) local_free_q;
		local_free_q = p;
	}
	vm_page_unlock_queues();

	<span class="enscript-comment">/*
	 * Free the remaining reclaimed pages
	 */</span>
	<span class="enscript-keyword">if</span> (reap_type == REAP_PURGEABLE)
		pmap_flush(&amp;pmap_flush_context_storage);

	VM_OBJ_REAP_FREELIST(local_free_q,
			     disconnect_on_release);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reap_async</span>(
	vm_object_t	object)
{
	vm_object_lock_assert_exclusive(object);

	vm_object_reaper_lock_spin();

	vm_object_reap_count_async++;

	<span class="enscript-comment">/* enqueue the VM object... */</span>
	queue_enter(&amp;vm_object_reaper_queue, object,
		    vm_object_t, cached_list);

	vm_object_reaper_unlock();

	<span class="enscript-comment">/* ... and wake up the reaper thread */</span>
	thread_wakeup((event_t) &amp;vm_object_reaper_queue);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reaper_thread</span>(<span class="enscript-type">void</span>)
{
	vm_object_t	object, shadow_object;

	vm_object_reaper_lock_spin();

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;vm_object_reaper_queue)) {
		queue_remove_first(&amp;vm_object_reaper_queue,
				   object,
				   vm_object_t,
				   cached_list);

		vm_object_reaper_unlock();
		vm_object_lock(object);

		assert(object-&gt;terminating);
		assert(!object-&gt;alive);
		
		<span class="enscript-comment">/*
		 * The pageout daemon might be playing with our pages.
		 * Now that the object is dead, it won't touch any more
		 * pages, but some pages might already be on their way out.
		 * Hence, we wait until the active paging activities have
		 * ceased before we break the association with the pager
		 * itself.
		 */</span>
		<span class="enscript-keyword">while</span> (object-&gt;paging_in_progress != 0 ||
			object-&gt;activity_in_progress != 0) {
			vm_object_wait(object,
				       VM_OBJECT_EVENT_PAGING_IN_PROGRESS,
				       THREAD_UNINT);
			vm_object_lock(object);
		}

		shadow_object =
			object-&gt;pageout ? VM_OBJECT_NULL : object-&gt;shadow;

		vm_object_reap(object);
		<span class="enscript-comment">/* cache is unlocked and object is no longer valid */</span>
		object = VM_OBJECT_NULL;

		<span class="enscript-keyword">if</span> (shadow_object != VM_OBJECT_NULL) {
			<span class="enscript-comment">/*
			 * Drop the reference &quot;object&quot; was holding on
			 * its shadow object.
			 */</span>
			vm_object_deallocate(shadow_object);
			shadow_object = VM_OBJECT_NULL;
		}
		vm_object_reaper_lock_spin();
	}

	<span class="enscript-comment">/* wait for more work... */</span>
	assert_wait((event_t) &amp;vm_object_reaper_queue, THREAD_UNINT);

	vm_object_reaper_unlock();

	thread_block((thread_continue_t) vm_object_reaper_thread);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_pager_wakeup
 *	Purpose:	Wake up anyone waiting for termination of a pager.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pager_wakeup</span>(
	memory_object_t	pager)
{
	vm_object_hash_entry_t	entry;
	boolean_t		waiting = FALSE;
	lck_mtx_t		*lck;

	<span class="enscript-comment">/*
	 *	If anyone was waiting for the memory_object_terminate
	 *	to be queued, wake them up now.
	 */</span>
	lck = vm_object_hash_lock_spin(pager);
	entry = vm_object_hash_lookup(pager, TRUE);
	<span class="enscript-keyword">if</span> (entry != VM_OBJECT_HASH_ENTRY_NULL)
		waiting = entry-&gt;waiting;
	vm_object_hash_unlock(lck);

	<span class="enscript-keyword">if</span> (entry != VM_OBJECT_HASH_ENTRY_NULL) {
		<span class="enscript-keyword">if</span> (waiting)
			thread_wakeup((event_t) pager);
		vm_object_hash_entry_free(entry);
	}
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_release_pager
 *	Purpose:	Terminate the pager and, upon completion,
 *			release our last reference to it.
 *			just like memory_object_terminate, except
 *			that we wake up anyone blocked in vm_object_enter
 *			waiting for termination message to be queued
 *			before calling memory_object_init.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_release_pager</span>(
	memory_object_t	pager,
	boolean_t	hashed)
{

	<span class="enscript-comment">/*
	 *	Terminate the pager.
	 */</span>

	(<span class="enscript-type">void</span>) memory_object_terminate(pager);

	<span class="enscript-keyword">if</span> (hashed == TRUE) {
		<span class="enscript-comment">/*
		 *	Wakeup anyone waiting for this terminate
		 *      and remove the entry from the hash
		 */</span>
		vm_object_pager_wakeup(pager);
	}
	<span class="enscript-comment">/*
	 *	Release reference to pager.
	 */</span>
	memory_object_deallocate(pager);
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_destroy
 *	Purpose:
 *		Shut down a VM object, despite the
 *		presence of address map (or other) references
 *		to the vm_object.
 */</span>
kern_return_t
<span class="enscript-function-name">vm_object_destroy</span>(
	vm_object_t		object,
	__unused kern_return_t		reason)
{
	memory_object_t		old_pager;

	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span>(KERN_SUCCESS);

	<span class="enscript-comment">/*
	 *	Remove the pager association immediately.
	 *
	 *	This will prevent the memory manager from further
	 *	meddling.  [If it wanted to flush data or make
	 *	other changes, it should have done so before performing
	 *	the destroy call.]
	 */</span>

	vm_object_lock(object);
	object-&gt;can_persist = FALSE;
	object-&gt;named = FALSE;
	object-&gt;alive = FALSE;

	<span class="enscript-keyword">if</span> (object-&gt;hashed) {
		lck_mtx_t	*lck;
		<span class="enscript-comment">/*
		 *	Rip out the pager from the vm_object now...
		 */</span>
		lck = vm_object_hash_lock_spin(object-&gt;pager);
		vm_object_remove(object);
		vm_object_hash_unlock(lck);
	}
	old_pager = object-&gt;pager;
	object-&gt;pager = MEMORY_OBJECT_NULL;
	<span class="enscript-keyword">if</span> (old_pager != MEMORY_OBJECT_NULL)
		memory_object_control_disable(object-&gt;pager_control);

	<span class="enscript-comment">/*
	 * Wait for the existing paging activity (that got
	 * through before we nulled out the pager) to subside.
	 */</span>

	vm_object_paging_wait(object, THREAD_UNINT);
	vm_object_unlock(object);

	<span class="enscript-comment">/*
	 *	Terminate the object now.
	 */</span>
	<span class="enscript-keyword">if</span> (old_pager != MEMORY_OBJECT_NULL) {
		vm_object_release_pager(old_pager, object-&gt;hashed);

		<span class="enscript-comment">/* 
		 * JMM - Release the caller's reference.  This assumes the
		 * caller had a reference to release, which is a big (but
		 * currently valid) assumption if this is driven from the
		 * vnode pager (it is holding a named reference when making
		 * this call)..
		 */</span>
		vm_object_deallocate(object);

	}
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span> DEBUG
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span>
uint32_t vm_object_deactivate_all_pages_batches = 0;
uint32_t vm_object_deactivate_all_pages_pages = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJ_DEACT_ALL_STATS */</span>
<span class="enscript-comment">/*
 *	vm_object_deactivate_all_pages
 *
 *	Deactivate all pages in the specified object.  (Keep its pages
 *	in memory even though it is no longer referenced.)
 *
 *	The object must be locked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_deactivate_all_pages</span>(
	<span class="enscript-type">register</span> vm_object_t	object)
{
	<span class="enscript-type">register</span> vm_page_t	p;
	<span class="enscript-type">int</span>			loop_count;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span>
	<span class="enscript-type">int</span>			pages_count;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJ_DEACT_ALL_STATS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">V_O_D_A_P_MAX_BATCH</span>	256

	loop_count = BATCH_LIMIT(V_O_D_A_P_MAX_BATCH);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span>
	pages_count = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJ_DEACT_ALL_STATS */</span>
	vm_page_lock_queues();
	queue_iterate(&amp;object-&gt;memq, p, vm_page_t, listq) {
		<span class="enscript-keyword">if</span> (--loop_count == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span>
			hw_atomic_add(&amp;vm_object_deactivate_all_pages_batches,
				      1);
			hw_atomic_add(&amp;vm_object_deactivate_all_pages_pages,
				      pages_count);
			pages_count = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJ_DEACT_ALL_STATS */</span>
			lck_mtx_yield(&amp;vm_page_queue_lock);
			loop_count = BATCH_LIMIT(V_O_D_A_P_MAX_BATCH);
		}
		<span class="enscript-keyword">if</span> (!p-&gt;busy &amp;&amp; !p-&gt;throttled) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span>
			pages_count++;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJ_DEACT_ALL_STATS */</span>
			vm_page_deactivate(p);
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJ_DEACT_ALL_STATS</span>
	<span class="enscript-keyword">if</span> (pages_count) {
		hw_atomic_add(&amp;vm_object_deactivate_all_pages_batches, 1);
		hw_atomic_add(&amp;vm_object_deactivate_all_pages_pages,
			      pages_count);
		pages_count = 0;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJ_DEACT_ALL_STATS */</span>
	vm_page_unlock_queues();
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VM_OBJECT_CACHE */</span>



<span class="enscript-comment">/*
 * The &quot;chunk&quot; macros are used by routines below when looking for pages to deactivate.  These
 * exist because of the need to handle shadow chains.  When deactivating pages, we only
 * want to deactive the ones at the top most level in the object chain.  In order to do
 * this efficiently, the specified address range is divided up into &quot;chunks&quot; and we use
 * a bit map to keep track of which pages have already been processed as we descend down
 * the shadow chain.  These chunk macros hide the details of the bit map implementation
 * as much as we can.
 *
 * For convenience, we use a 64-bit data type as the bit map, and therefore a chunk is
 * set to 64 pages.  The bit map is indexed from the low-order end, so that the lowest
 * order bit represents page 0 in the current range and highest order bit represents
 * page 63.
 *
 * For further convenience, we also use negative logic for the page state in the bit map.
 * The bit is set to 1 to indicate it has not yet been seen, and to 0 to indicate it has
 * been processed.  This way we can simply test the 64-bit long word to see if it's zero
 * to easily tell if the whole range has been processed.  Therefore, the bit map starts
 * out with all the bits set.  The macros below hide all these details from the caller.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAGES_IN_A_CHUNK</span>	64	<span class="enscript-comment">/* The number of pages in the chunk must */</span>
					<span class="enscript-comment">/* be the same as the number of bits in  */</span>
					<span class="enscript-comment">/* the chunk_state_t type. We use 64     */</span>
					<span class="enscript-comment">/* just for convenience.		 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUNK_SIZE</span>	(PAGES_IN_A_CHUNK * PAGE_SIZE_64)	<span class="enscript-comment">/* Size of a chunk in bytes */</span>

<span class="enscript-type">typedef</span> uint64_t	chunk_state_t;

<span class="enscript-comment">/*
 * The bit map uses negative logic, so we start out with all 64 bits set to indicate
 * that no pages have been processed yet.  Also, if len is less than the full CHUNK_SIZE,
 * then we mark pages beyond the len as having been &quot;processed&quot; so that we don't waste time
 * looking at pages in that range.  This can save us from unnecessarily chasing down the 
 * shadow chain.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHUNK_INIT</span>(c, len) 						\
	MACRO_BEGIN							\
	uint64_t p;							\
									\
	(c) = 0xffffffffffffffffLL; 					\
									\
	<span class="enscript-keyword">for</span> (p = (len) / PAGE_SIZE_64; p &lt; PAGES_IN_A_CHUNK; p++)	\
		MARK_PAGE_HANDLED(c, p);				\
	MACRO_END


<span class="enscript-comment">/*
 * Return true if all pages in the chunk have not yet been processed.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHUNK_NOT_COMPLETE</span>(c)	((c) != 0)

<span class="enscript-comment">/*
 * Return true if the page at offset 'p' in the bit map has already been handled
 * while processing a higher level object in the shadow chain.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGE_ALREADY_HANDLED</span>(c, p)	(((c) &amp; (1LL &lt;&lt; (p))) == 0)

<span class="enscript-comment">/*
 * Mark the page at offset 'p' in the bit map as having been processed.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MARK_PAGE_HANDLED</span>(c, p) \
MACRO_BEGIN \
	(c) = (c) &amp; ~(1LL &lt;&lt; (p)); \
MACRO_END


<span class="enscript-comment">/*
 * Return true if the page at the given offset has been paged out.  Object is
 * locked upon entry and returned locked.
 */</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">page_is_paged_out</span>(
	vm_object_t		object,
	vm_object_offset_t	offset)
{
	kern_return_t	kr;
	memory_object_t	pager;

	<span class="enscript-comment">/*
	 * Check the existence map for the page if we have one, otherwise
	 * ask the pager about this page.
	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
	<span class="enscript-keyword">if</span> (object-&gt;existence_map) {
		<span class="enscript-keyword">if</span> (vm_external_state_get(object-&gt;existence_map, offset)
		    == VM_EXTERNAL_STATE_EXISTS) {
			<span class="enscript-comment">/*
			 * We found the page
			 */</span>

			<span class="enscript-keyword">return</span> TRUE;
		}
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGEMAP */</span>
	<span class="enscript-keyword">if</span> (object-&gt;internal &amp;&amp;
	   object-&gt;alive &amp;&amp;
	   !object-&gt;terminating &amp;&amp;
	   object-&gt;pager_ready) {

		<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {
			<span class="enscript-keyword">if</span> (VM_COMPRESSOR_PAGER_STATE_GET(object, offset) 
			    == VM_EXTERNAL_STATE_EXISTS) {
				<span class="enscript-keyword">return</span> TRUE;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> FALSE;
			}
		}

		<span class="enscript-comment">/*
		 * We're already holding a &quot;paging in progress&quot; reference
		 * so the object can't disappear when we release the lock.
		 */</span>

		assert(object-&gt;paging_in_progress);
		pager = object-&gt;pager;
		vm_object_unlock(object);

		kr = memory_object_data_request(
			pager,
			offset + object-&gt;paging_offset,
			0,	<span class="enscript-comment">/* just poke the pager */</span>
			VM_PROT_READ,
			NULL);

		vm_object_lock(object);

		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {

			<span class="enscript-comment">/*
			 * We found the page
			 */</span>

			<span class="enscript-keyword">return</span> TRUE;
		}
	}

	<span class="enscript-keyword">return</span> FALSE;
}



<span class="enscript-comment">/*
 * madvise_free_debug
 *
 * To help debug madvise(MADV_FREE*) mis-usage, this triggers a
 * zero-fill as soon as a page is affected by a madvise(MADV_FREE*), to
 * simulate the loss of the page's contents as if the page had been
 * reclaimed and then re-faulted.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">int</span> madvise_free_debug = 1;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEBUG */</span>
<span class="enscript-type">int</span> madvise_free_debug = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

<span class="enscript-comment">/*
 * Deactivate the pages in the specified object and range.  If kill_page is set, also discard any
 * page modified state from the pmap.  Update the chunk_state as we go along.  The caller must specify
 * a size that is less than or equal to the CHUNK_SIZE.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">deactivate_pages_in_object</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_object_size_t	size,
	boolean_t               kill_page,
	boolean_t		reusable_page,
	boolean_t		all_reusable,
	chunk_state_t		*chunk_state,
	pmap_flush_context      *pfc,
	<span class="enscript-type">struct</span> pmap		*pmap,
	vm_map_offset_t		pmap_offset)
{
	vm_page_t	m;
	<span class="enscript-type">int</span>		p;
	<span class="enscript-type">struct</span> vm_page_delayed_work	dw_array[DEFAULT_DELAYED_WORK_LIMIT];
	<span class="enscript-type">struct</span> vm_page_delayed_work	*dwp;
	<span class="enscript-type">int</span>		dw_count;
	<span class="enscript-type">int</span>		dw_limit;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	reusable = 0;

	<span class="enscript-comment">/*
	 * Examine each page in the chunk.  The variable 'p' is the page number relative to the start of the
	 * chunk.  Since this routine is called once for each level in the shadow chain, the chunk_state may
	 * have pages marked as having been processed already.  We stop the loop early if we find we've handled
	 * all the pages in the chunk.
	 */</span>

	dwp = &amp;dw_array[0];
	dw_count = 0;
	dw_limit = DELAYED_WORK_LIMIT(DEFAULT_DELAYED_WORK_LIMIT);

	<span class="enscript-keyword">for</span>(p = 0; size &amp;&amp; CHUNK_NOT_COMPLETE(*chunk_state); p++, size -= PAGE_SIZE_64, offset += PAGE_SIZE_64, pmap_offset += PAGE_SIZE_64) {

		<span class="enscript-comment">/*
		 * If this offset has already been found and handled in a higher level object, then don't
		 * do anything with it in the current shadow object.
		 */</span>

		<span class="enscript-keyword">if</span> (PAGE_ALREADY_HANDLED(*chunk_state, p))
			<span class="enscript-keyword">continue</span>;
	
		<span class="enscript-comment">/*
		 * See if the page at this offset is around.  First check to see if the page is resident,
		 * then if not, check the existence map or with the pager.
		 */</span>

	        <span class="enscript-keyword">if</span> ((m = vm_page_lookup(object, offset)) != VM_PAGE_NULL) {

			<span class="enscript-comment">/*
			 * We found a page we were looking for.  Mark it as &quot;handled&quot; now in the chunk_state
			 * so that we won't bother looking for a page at this offset again if there are more
			 * shadow objects.  Then deactivate the page.
			 */</span>

			MARK_PAGE_HANDLED(*chunk_state, p);
	
			<span class="enscript-keyword">if</span> (( !VM_PAGE_WIRED(m)) &amp;&amp; (!m-&gt;private) &amp;&amp; (!m-&gt;gobbled) &amp;&amp; (!m-&gt;busy) &amp;&amp; (!m-&gt;laundry)) {
				<span class="enscript-type">int</span>	clear_refmod;
				<span class="enscript-type">int</span>	pmap_options;
	
				dwp-&gt;dw_mask = 0;

				pmap_options = 0;
				clear_refmod = VM_MEM_REFERENCED;
				dwp-&gt;dw_mask |= DW_clear_reference;

				<span class="enscript-keyword">if</span> ((kill_page) &amp;&amp; (object-&gt;internal)) {
					<span class="enscript-keyword">if</span> (madvise_free_debug) {
						<span class="enscript-comment">/*
						 * zero-fill the page now
						 * to simulate it being
						 * reclaimed and re-faulted.
						 */</span>
						pmap_zero_page(m-&gt;phys_page);
					}
			        	m-&gt;precious = FALSE;
				        m-&gt;dirty = FALSE;

					clear_refmod |= VM_MEM_MODIFIED;
					<span class="enscript-keyword">if</span> (m-&gt;throttled) {
						<span class="enscript-comment">/*
						 * This page is now clean and
						 * reclaimable.  Move it out
						 * of the throttled queue, so
						 * that vm_pageout_scan() can
						 * find it.
						 */</span>
						dwp-&gt;dw_mask |= DW_move_page;
					}
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
					vm_external_state_clr(object-&gt;existence_map, offset);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
					VM_COMPRESSOR_PAGER_STATE_CLR(object,
								      offset);

					<span class="enscript-keyword">if</span> (reusable_page &amp;&amp; !m-&gt;reusable) {
						assert(!all_reusable);
						assert(!object-&gt;all_reusable);
						m-&gt;reusable = TRUE;
						object-&gt;reusable_page_count++;
						assert(object-&gt;resident_page_count &gt;= object-&gt;reusable_page_count);
						reusable++;
						<span class="enscript-comment">/*
						 * Tell pmap this page is now
						 * &quot;reusable&quot; (to update pmap
						 * stats for all mappings).
						 */</span>
						pmap_options |=	PMAP_OPTIONS_SET_REUSABLE;
					}
				}
				pmap_options |= PMAP_OPTIONS_NOFLUSH;
				pmap_clear_refmod_options(m-&gt;phys_page,
							  clear_refmod,
							  pmap_options,
							  (<span class="enscript-type">void</span> *)pfc);

				<span class="enscript-keyword">if</span> (!m-&gt;throttled &amp;&amp; !(reusable_page || all_reusable))
					dwp-&gt;dw_mask |= DW_move_page;
				
				<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask)
					VM_PAGE_ADD_DELAYED_WORK(dwp, m,
								 dw_count);

				<span class="enscript-keyword">if</span> (dw_count &gt;= dw_limit) {
					<span class="enscript-keyword">if</span> (reusable) {
						OSAddAtomic(reusable,
							    &amp;vm_page_stats_reusable.reusable_count);
						vm_page_stats_reusable.reusable += reusable;
						reusable = 0;
					}
					vm_page_do_delayed_work(object, VM_KERN_MEMORY_NONE, &amp;dw_array[0], dw_count);

					dwp = &amp;dw_array[0];
					dw_count = 0;
				}
			}

		} <span class="enscript-keyword">else</span> {

			<span class="enscript-comment">/*
			 * The page at this offset isn't memory resident, check to see if it's
			 * been paged out.  If so, mark it as handled so we don't bother looking
			 * for it in the shadow chain.
			 */</span>

			<span class="enscript-keyword">if</span> (page_is_paged_out(object, offset)) {
				MARK_PAGE_HANDLED(*chunk_state, p);

				<span class="enscript-comment">/*
				 * If we're killing a non-resident page, then clear the page in the existence 
				 * map so we don't bother paging it back in if it's touched again in the future.
				 */</span>

				<span class="enscript-keyword">if</span> ((kill_page) &amp;&amp; (object-&gt;internal)) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
					vm_external_state_clr(object-&gt;existence_map, offset);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
					VM_COMPRESSOR_PAGER_STATE_CLR(object,
								      offset);
					<span class="enscript-keyword">if</span> (pmap != PMAP_NULL &amp;&amp;
					    (COMPRESSED_PAGER_IS_ACTIVE ||
					     DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE)) {
						<span class="enscript-comment">/*
						 * Tell pmap that this page
						 * is no longer mapped, to
						 * adjust the footprint ledger
						 * because this page is no
						 * longer compressed.
						 */</span>
						pmap_remove_options(
							pmap,
							pmap_offset,
							(pmap_offset +
							 PAGE_SIZE),
							PMAP_OPTIONS_REMOVE);
					}
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (reusable) {
		OSAddAtomic(reusable, &amp;vm_page_stats_reusable.reusable_count);
		vm_page_stats_reusable.reusable += reusable;	
		reusable = 0;
	}
		
	<span class="enscript-keyword">if</span> (dw_count)
		vm_page_do_delayed_work(object, VM_KERN_MEMORY_NONE, &amp;dw_array[0], dw_count);
}


<span class="enscript-comment">/*
 * Deactive a &quot;chunk&quot; of the given range of the object starting at offset.  A &quot;chunk&quot;
 * will always be less than or equal to the given size.  The total range is divided up
 * into chunks for efficiency and performance related to the locks and handling the shadow
 * chain.  This routine returns how much of the given &quot;size&quot; it actually processed.  It's
 * up to the caler to loop and keep calling this routine until the entire range they want
 * to process has been done.
 */</span>

<span class="enscript-type">static</span> vm_object_size_t
<span class="enscript-function-name">deactivate_a_chunk</span>(
	vm_object_t		orig_object,
	vm_object_offset_t	offset,
	vm_object_size_t	size,
	boolean_t               kill_page,
	boolean_t		reusable_page,
	boolean_t		all_reusable,
	pmap_flush_context      *pfc,
	<span class="enscript-type">struct</span> pmap		*pmap,
	vm_map_offset_t		pmap_offset)
{
	vm_object_t		object;
	vm_object_t		tmp_object;
	vm_object_size_t	length;
	chunk_state_t		chunk_state;


	<span class="enscript-comment">/*
	 * Get set to do a chunk.  We'll do up to CHUNK_SIZE, but no more than the
	 * remaining size the caller asked for.
	 */</span>

	length = MIN(size, CHUNK_SIZE);

	<span class="enscript-comment">/*
	 * The chunk_state keeps track of which pages we've already processed if there's
	 * a shadow chain on this object.  At this point, we haven't done anything with this
	 * range of pages yet, so initialize the state to indicate no pages processed yet.
	 */</span>

	CHUNK_INIT(chunk_state, length);
	object = orig_object;

	<span class="enscript-comment">/*
	 * Start at the top level object and iterate around the loop once for each object
	 * in the shadow chain.  We stop processing early if we've already found all the pages
	 * in the range.  Otherwise we stop when we run out of shadow objects.
	 */</span>

	<span class="enscript-keyword">while</span> (object &amp;&amp; CHUNK_NOT_COMPLETE(chunk_state)) {
		vm_object_paging_begin(object);

		deactivate_pages_in_object(object, offset, length, kill_page, reusable_page, all_reusable, &amp;chunk_state, pfc, pmap, pmap_offset);

		vm_object_paging_end(object);

		<span class="enscript-comment">/*
		 * We've finished with this object, see if there's a shadow object.  If
		 * there is, update the offset and lock the new object.  We also turn off
		 * kill_page at this point since we only kill pages in the top most object.
		 */</span>

		tmp_object = object-&gt;shadow;

		<span class="enscript-keyword">if</span> (tmp_object) {
			kill_page = FALSE;
			reusable_page = FALSE;
			all_reusable = FALSE;
		        offset += object-&gt;vo_shadow_offset;
		        vm_object_lock(tmp_object);
		}

		<span class="enscript-keyword">if</span> (object != orig_object)
		        vm_object_unlock(object);

		object = tmp_object;
	}

	<span class="enscript-keyword">if</span> (object &amp;&amp; object != orig_object)
	        vm_object_unlock(object);

	<span class="enscript-keyword">return</span> length;
}



<span class="enscript-comment">/*
 * Move any resident pages in the specified range to the inactive queue.  If kill_page is set,
 * we also clear the modified status of the page and &quot;forget&quot; any changes that have been made
 * to the page.
 */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_deactivate_pages</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_object_size_t	size,
	boolean_t               kill_page,
	boolean_t		reusable_page,
	<span class="enscript-type">struct</span> pmap		*pmap,
	vm_map_offset_t		pmap_offset)
{
	vm_object_size_t	length;
	boolean_t		all_reusable;
	pmap_flush_context	pmap_flush_context_storage;

	<span class="enscript-comment">/*
	 * We break the range up into chunks and do one chunk at a time.  This is for
	 * efficiency and performance while handling the shadow chains and the locks.	
	 * The deactivate_a_chunk() function returns how much of the range it processed.
	 * We keep calling this routine until the given size is exhausted.
	 */</span>


	all_reusable = FALSE;
#<span class="enscript-reference">if</span> 11
	<span class="enscript-comment">/*
	 * For the sake of accurate &quot;reusable&quot; pmap stats, we need 
	 * to tell pmap about each page that is no longer &quot;reusable&quot;,
	 * so we can't do the &quot;all_reusable&quot; optimization.
	 */</span>
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (reusable_page &amp;&amp;
	    object-&gt;internal &amp;&amp;
	    object-&gt;vo_size != 0 &amp;&amp;
	    object-&gt;vo_size == size &amp;&amp;
	    object-&gt;reusable_page_count == 0) {
		all_reusable = TRUE;
		reusable_page = FALSE;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((reusable_page || all_reusable) &amp;&amp; object-&gt;all_reusable) {
		<span class="enscript-comment">/* This means MADV_FREE_REUSABLE has been called twice, which 
		 * is probably illegal. */</span>
		<span class="enscript-keyword">return</span>;
	}

	pmap_flush_context_init(&amp;pmap_flush_context_storage);

	<span class="enscript-keyword">while</span> (size) {
		length = deactivate_a_chunk(object, offset, size, kill_page, reusable_page, all_reusable, &amp;pmap_flush_context_storage, pmap, pmap_offset);

		size -= length;
		offset += length;
		pmap_offset += length;
	}
	pmap_flush(&amp;pmap_flush_context_storage);

	<span class="enscript-keyword">if</span> (all_reusable) {
		<span class="enscript-keyword">if</span> (!object-&gt;all_reusable) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> reusable;

			object-&gt;all_reusable = TRUE;
			assert(object-&gt;reusable_page_count == 0);
			<span class="enscript-comment">/* update global stats */</span>
			reusable = object-&gt;resident_page_count;
			OSAddAtomic(reusable,
				    &amp;vm_page_stats_reusable.reusable_count);
			vm_page_stats_reusable.reusable += reusable;
			vm_page_stats_reusable.all_reusable_calls++;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (reusable_page) {
		vm_page_stats_reusable.partial_reusable_calls++;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reuse_pages</span>(
	vm_object_t		object,
	vm_object_offset_t	start_offset,
	vm_object_offset_t	end_offset,
	boolean_t		allow_partial_reuse)
{
	vm_object_offset_t	cur_offset;
	vm_page_t		m;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		reused, reusable;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_OBJECT_REUSE_PAGE</span>(object, m, reused)				\
	MACRO_BEGIN							\
		<span class="enscript-keyword">if</span> ((m) != VM_PAGE_NULL &amp;&amp;				\
		    (m)-&gt;reusable) {					\
			assert((object)-&gt;reusable_page_count &lt;=		\
			       (object)-&gt;resident_page_count);		\
			assert((object)-&gt;reusable_page_count &gt; 0);	\
			(object)-&gt;reusable_page_count--;		\
			(m)-&gt;reusable = FALSE;				\
			(reused)++;					\
			<span class="enscript-comment">/*						\
			 * Tell pmap that this page is no longer	\
			 * &quot;reusable&quot;, to update the &quot;reusable&quot; stats	\
			 * for all the pmaps that have mapped this	\
			 * page.					\
			 */</span>						\
			pmap_clear_refmod_options((m)-&gt;phys_page,	\
						  0, <span class="enscript-comment">/* refmod */</span>	\
						  (PMAP_OPTIONS_CLEAR_REUSABLE \
						   | PMAP_OPTIONS_NOFLUSH), \
						  NULL);		\
		}							\
	MACRO_END

	reused = 0;
	reusable = 0;

	vm_object_lock_assert_exclusive(object);

	<span class="enscript-keyword">if</span> (object-&gt;all_reusable) {
		panic(<span class="enscript-string">&quot;object %p all_reusable: can't update pmap stats\n&quot;</span>,
		      object);
		assert(object-&gt;reusable_page_count == 0);
		object-&gt;all_reusable = FALSE;
		<span class="enscript-keyword">if</span> (end_offset - start_offset == object-&gt;vo_size ||
		    !allow_partial_reuse) {
			vm_page_stats_reusable.all_reuse_calls++;
			reused = object-&gt;resident_page_count;
		} <span class="enscript-keyword">else</span> {
			vm_page_stats_reusable.partial_reuse_calls++;
			queue_iterate(&amp;object-&gt;memq, m, vm_page_t, listq) {
				<span class="enscript-keyword">if</span> (m-&gt;offset &lt; start_offset ||
				    m-&gt;offset &gt;= end_offset) {
					m-&gt;reusable = TRUE;
					object-&gt;reusable_page_count++;
					assert(object-&gt;resident_page_count &gt;= object-&gt;reusable_page_count);
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> {
					assert(!m-&gt;reusable);
					reused++;
				}
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;resident_page_count &gt;
		   ((end_offset - start_offset) &gt;&gt; PAGE_SHIFT)) {
		vm_page_stats_reusable.partial_reuse_calls++;
		<span class="enscript-keyword">for</span> (cur_offset = start_offset;
		     cur_offset &lt; end_offset;
		     cur_offset += PAGE_SIZE_64) {
			<span class="enscript-keyword">if</span> (object-&gt;reusable_page_count == 0) {
				<span class="enscript-keyword">break</span>;
			}
			m = vm_page_lookup(object, cur_offset);
			VM_OBJECT_REUSE_PAGE(object, m, reused);
		}
	} <span class="enscript-keyword">else</span> {
		vm_page_stats_reusable.partial_reuse_calls++;
		queue_iterate(&amp;object-&gt;memq, m, vm_page_t, listq) {
			<span class="enscript-keyword">if</span> (object-&gt;reusable_page_count == 0) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (m-&gt;offset &lt; start_offset ||
			    m-&gt;offset &gt;= end_offset) {
				<span class="enscript-keyword">continue</span>;
			}
			VM_OBJECT_REUSE_PAGE(object, m, reused);
		}
	}

	<span class="enscript-comment">/* update global stats */</span>
	OSAddAtomic(reusable-reused, &amp;vm_page_stats_reusable.reusable_count);
	vm_page_stats_reusable.reused += reused;
	vm_page_stats_reusable.reusable += reusable;
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_pmap_protect
 *
 *	Purpose:
 *		Reduces the permission for all physical
 *		pages in the specified object range.
 *
 *		If removing write permission only, it is
 *		sufficient to protect only the pages in
 *		the top-level object; only those pages may
 *		have write permission.
 *
 *		If removing all access, we must follow the
 *		shadow chain from the top-level object to
 *		remove access to all pages in shadowed objects.
 *
 *		The object must *not* be locked.  The object must
 *		be temporary/internal.  
 *
 *              If pmap is not NULL, this routine assumes that
 *              the only mappings for the pages are in that
 *              pmap.
 */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pmap_protect</span>(
	<span class="enscript-type">register</span> vm_object_t		object,
	<span class="enscript-type">register</span> vm_object_offset_t	offset,
	vm_object_size_t		size,
	pmap_t				pmap,
	vm_map_offset_t			pmap_start,
	vm_prot_t			prot)
{
	vm_object_pmap_protect_options(object, offset, size,
				       pmap, pmap_start, prot, 0);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pmap_protect_options</span>(
	<span class="enscript-type">register</span> vm_object_t		object,
	<span class="enscript-type">register</span> vm_object_offset_t	offset,
	vm_object_size_t		size,
	pmap_t				pmap,
	vm_map_offset_t			pmap_start,
	vm_prot_t			prot,
	<span class="enscript-type">int</span>				options)
{
	pmap_flush_context	pmap_flush_context_storage;
	boolean_t		delayed_pmap_flush = FALSE;

	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span>;
	size = vm_object_round_page(size);
	offset = vm_object_trunc_page(offset);

	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (object-&gt;phys_contiguous) {
		<span class="enscript-keyword">if</span> (pmap != NULL) {
			vm_object_unlock(object);
			pmap_protect_options(pmap,
					     pmap_start,
					     pmap_start + size,
					     prot,
					     options &amp; ~PMAP_OPTIONS_NOFLUSH,
					     NULL);
		} <span class="enscript-keyword">else</span> {
			vm_object_offset_t phys_start, phys_end, phys_addr;

			phys_start = object-&gt;vo_shadow_offset + offset;
			phys_end = phys_start + size;
			assert(phys_start &lt;= phys_end);
			assert(phys_end &lt;= object-&gt;vo_shadow_offset + object-&gt;vo_size);
			vm_object_unlock(object);

			pmap_flush_context_init(&amp;pmap_flush_context_storage);
			delayed_pmap_flush = FALSE;

			<span class="enscript-keyword">for</span> (phys_addr = phys_start;
			     phys_addr &lt; phys_end;
			     phys_addr += PAGE_SIZE_64) {
				pmap_page_protect_options(
					(ppnum_t) (phys_addr &gt;&gt; PAGE_SHIFT),
					prot,
					options | PMAP_OPTIONS_NOFLUSH,
					(<span class="enscript-type">void</span> *)&amp;pmap_flush_context_storage);
				delayed_pmap_flush = TRUE;
			}
			<span class="enscript-keyword">if</span> (delayed_pmap_flush == TRUE)
				pmap_flush(&amp;pmap_flush_context_storage);
		}
		<span class="enscript-keyword">return</span>;
	}

	assert(object-&gt;internal);

	<span class="enscript-keyword">while</span> (TRUE) {
	   <span class="enscript-keyword">if</span> (ptoa_64(object-&gt;resident_page_count) &gt; size/2 &amp;&amp; pmap != PMAP_NULL) {
		vm_object_unlock(object);
		pmap_protect_options(pmap, pmap_start, pmap_start + size, prot,
				     options &amp; ~PMAP_OPTIONS_NOFLUSH, NULL);
		<span class="enscript-keyword">return</span>;
	    }

	   pmap_flush_context_init(&amp;pmap_flush_context_storage);
	   delayed_pmap_flush = FALSE;

	    <span class="enscript-comment">/*
	     * if we are doing large ranges with respect to resident
	     * page count then we should interate over pages otherwise
	     * inverse page look-up will be faster
	     */</span>
	    <span class="enscript-keyword">if</span> (ptoa_64(object-&gt;resident_page_count / 4) &lt;  size) {
		vm_page_t		p;
		vm_object_offset_t	end;

		end = offset + size;

		queue_iterate(&amp;object-&gt;memq, p, vm_page_t, listq) {
			<span class="enscript-keyword">if</span> (!p-&gt;fictitious &amp;&amp; (offset &lt;= p-&gt;offset) &amp;&amp; (p-&gt;offset &lt; end)) {
				vm_map_offset_t start;

				start = pmap_start + p-&gt;offset - offset;

				<span class="enscript-keyword">if</span> (pmap != PMAP_NULL)
					pmap_protect_options(
						pmap,
						start,
						start + PAGE_SIZE_64,
						prot,
						options | PMAP_OPTIONS_NOFLUSH,
						&amp;pmap_flush_context_storage);
				<span class="enscript-keyword">else</span>
					pmap_page_protect_options(
						p-&gt;phys_page,
						prot,
						options | PMAP_OPTIONS_NOFLUSH,
						&amp;pmap_flush_context_storage);
					delayed_pmap_flush = TRUE;
			}
		}

	   } <span class="enscript-keyword">else</span> {
		vm_page_t		p;
		vm_object_offset_t	end;
		vm_object_offset_t	target_off;

		end = offset + size;

		<span class="enscript-keyword">for</span> (target_off = offset; 
		     target_off &lt; end; target_off += PAGE_SIZE) {

			p = vm_page_lookup(object, target_off);

			<span class="enscript-keyword">if</span> (p != VM_PAGE_NULL) {
				vm_object_offset_t start;

				start = pmap_start + (p-&gt;offset - offset);

				<span class="enscript-keyword">if</span> (pmap != PMAP_NULL)
					pmap_protect_options(
						pmap,
						start,
						start + PAGE_SIZE_64,
						prot,
						options | PMAP_OPTIONS_NOFLUSH,
						&amp;pmap_flush_context_storage);
				<span class="enscript-keyword">else</span>
					pmap_page_protect_options(
						p-&gt;phys_page,
						prot,
						options | PMAP_OPTIONS_NOFLUSH,
						&amp;pmap_flush_context_storage);
					delayed_pmap_flush = TRUE;
		    	}
		}
	    }
	    <span class="enscript-keyword">if</span> (delayed_pmap_flush == TRUE)
		    pmap_flush(&amp;pmap_flush_context_storage);

	    <span class="enscript-keyword">if</span> (prot == VM_PROT_NONE) {
		<span class="enscript-comment">/*
		 * Must follow shadow chain to remove access
		 * to pages in shadowed objects.
		 */</span>
		<span class="enscript-type">register</span> vm_object_t	next_object;

		next_object = object-&gt;shadow;
		<span class="enscript-keyword">if</span> (next_object != VM_OBJECT_NULL) {
		    offset += object-&gt;vo_shadow_offset;
		    vm_object_lock(next_object);
		    vm_object_unlock(object);
		    object = next_object;
		}
		<span class="enscript-keyword">else</span> {
		    <span class="enscript-comment">/*
		     * End of chain - we are done.
		     */</span>
		    <span class="enscript-keyword">break</span>;
		}
	    }
	    <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Pages in shadowed objects may never have
		 * write permission - we may stop here.
		 */</span>
		<span class="enscript-keyword">break</span>;
	    }
	}

	vm_object_unlock(object);
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_copy_slowly
 *
 *	Description:
 *		Copy the specified range of the source
 *		virtual memory object without using
 *		protection-based optimizations (such
 *		as copy-on-write).  The pages in the
 *		region are actually copied.
 *
 *	In/out conditions:
 *		The caller must hold a reference and a lock
 *		for the source virtual memory object.  The source
 *		object will be returned *unlocked*.
 *
 *	Results:
 *		If the copy is completed successfully, KERN_SUCCESS is
 *		returned.  If the caller asserted the interruptible
 *		argument, and an interruption occurred while waiting
 *		for a user-generated event, MACH_SEND_INTERRUPTED is
 *		returned.  Other values may be returned to indicate
 *		hard errors during the copy operation.
 *
 *		A new virtual memory object is returned in a
 *		parameter (_result_object).  The contents of this
 *		new object, starting at a zero offset, are a copy
 *		of the source memory region.  In the event of
 *		an error, this parameter will contain the value
 *		VM_OBJECT_NULL.
 */</span>
__private_extern__ kern_return_t
<span class="enscript-function-name">vm_object_copy_slowly</span>(
	<span class="enscript-type">register</span> vm_object_t	src_object,
	vm_object_offset_t	src_offset,
	vm_object_size_t	size,
	boolean_t		interruptible,
	vm_object_t		*_result_object)	<span class="enscript-comment">/* OUT */</span>
{
	vm_object_t		new_object;
	vm_object_offset_t	new_offset;

	<span class="enscript-type">struct</span> vm_object_fault_info fault_info;

	XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;v_o_c_slowly obj 0x%x off 0x%x size 0x%x\n&quot;</span>,
	    src_object, src_offset, size, 0, 0);

	<span class="enscript-keyword">if</span> (size == 0) {
		vm_object_unlock(src_object);
		*_result_object = VM_OBJECT_NULL;
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);
	}

	<span class="enscript-comment">/*
	 *	Prevent destruction of the source object while we copy.
	 */</span>

	vm_object_reference_locked(src_object);
	vm_object_unlock(src_object);

	<span class="enscript-comment">/*
	 *	Create a new object to hold the copied pages.
	 *	A few notes:
	 *		We fill the new object starting at offset 0,
	 *		 regardless of the input offset.
	 *		We don't bother to lock the new object within
	 *		 this routine, since we have the only reference.
	 */</span>

	new_object = vm_object_allocate(size);
	new_offset = 0;

	assert(size == trunc_page_64(size));	<span class="enscript-comment">/* Will the loop terminate? */</span>

	fault_info.interruptible = interruptible;
	fault_info.behavior  = VM_BEHAVIOR_SEQUENTIAL;
	fault_info.user_tag = 0;
	fault_info.pmap_options = 0;
	fault_info.lo_offset = src_offset;
	fault_info.hi_offset = src_offset + size;
	fault_info.no_cache  = FALSE;
	fault_info.stealth = TRUE;
	fault_info.io_sync = FALSE;
	fault_info.cs_bypass = FALSE;
	fault_info.mark_zf_absent = FALSE;
	fault_info.batch_pmap_op = FALSE;

	<span class="enscript-keyword">for</span> ( ;
	    size != 0 ;
	    src_offset += PAGE_SIZE_64, 
			new_offset += PAGE_SIZE_64, size -= PAGE_SIZE_64
	    ) {
		vm_page_t	new_page;
		vm_fault_return_t result;

		vm_object_lock(new_object);

		<span class="enscript-keyword">while</span> ((new_page = vm_page_alloc(new_object, new_offset))
				== VM_PAGE_NULL) {

			vm_object_unlock(new_object);

			<span class="enscript-keyword">if</span> (!vm_page_wait(interruptible)) {
				vm_object_deallocate(new_object);
				vm_object_deallocate(src_object);
				*_result_object = VM_OBJECT_NULL;
				<span class="enscript-keyword">return</span>(MACH_SEND_INTERRUPTED);
			}
			vm_object_lock(new_object);
		}
		vm_object_unlock(new_object);

		<span class="enscript-keyword">do</span> {
			vm_prot_t	prot = VM_PROT_READ;
			vm_page_t	_result_page;
			vm_page_t	top_page;
			<span class="enscript-type">register</span>
			vm_page_t	result_page;
			kern_return_t	error_code;

			vm_object_lock(src_object);

			<span class="enscript-keyword">if</span> (src_object-&gt;internal &amp;&amp;
			    src_object-&gt;shadow == VM_OBJECT_NULL &amp;&amp;
			    (vm_page_lookup(src_object,
					    src_offset) == VM_PAGE_NULL) &amp;&amp;
			    (src_object-&gt;pager == NULL ||
			     (VM_COMPRESSOR_PAGER_STATE_GET(src_object,
							    src_offset) ==
			      VM_EXTERNAL_STATE_ABSENT))) {
				<span class="enscript-comment">/*
				 * This page is neither resident nor compressed
				 * and there's no shadow object below 
				 * &quot;src_object&quot;, so this page is really missing.
				 * There's no need to zero-fill it just to copy
				 * it:  let's leave it missing in &quot;new_object&quot;
				 * and get zero-filled on demand.
				 */</span>
				vm_object_unlock(src_object);
				<span class="enscript-comment">/* free the unused &quot;new_page&quot;... */</span>
				vm_object_lock(new_object);
				VM_PAGE_FREE(new_page);
				new_page = VM_PAGE_NULL;
				vm_object_unlock(new_object);
				<span class="enscript-comment">/* ...and go to next page in &quot;src_object&quot; */</span>
				result = VM_FAULT_SUCCESS;
				<span class="enscript-keyword">break</span>;
			}

			vm_object_paging_begin(src_object);

			<span class="enscript-keyword">if</span> (size &gt; (vm_size_t) -1) {
				<span class="enscript-comment">/* 32-bit overflow */</span>
				fault_info.cluster_size = (vm_size_t) (0 - PAGE_SIZE);
			} <span class="enscript-keyword">else</span> {
				fault_info.cluster_size = (vm_size_t) size;
				assert(fault_info.cluster_size == size);
			}

			XPR(XPR_VM_FAULT,<span class="enscript-string">&quot;vm_object_copy_slowly -&gt; vm_fault_page&quot;</span>,0,0,0,0,0);
			_result_page = VM_PAGE_NULL;
			result = vm_fault_page(src_object, src_offset,
				VM_PROT_READ, FALSE,
				FALSE, <span class="enscript-comment">/* page not looked up */</span>
				&amp;prot, &amp;_result_page, &amp;top_page,
			        (<span class="enscript-type">int</span> *)0,
				&amp;error_code, FALSE, FALSE, &amp;fault_info);

			<span class="enscript-keyword">switch</span>(result) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_SUCCESS</span>:
				result_page = _result_page;

				<span class="enscript-comment">/*
				 *	Copy the page to the new object.
				 *
				 *	POLICY DECISION:
				 *		If result_page is clean,
				 *		we could steal it instead
				 *		of copying.
				 */</span>

				vm_page_copy(result_page, new_page);
				vm_object_unlock(result_page-&gt;object);

				<span class="enscript-comment">/*
				 *	Let go of both pages (make them
				 *	not busy, perform wakeup, activate).
				 */</span>
				vm_object_lock(new_object);
				SET_PAGE_DIRTY(new_page, FALSE);
				PAGE_WAKEUP_DONE(new_page);
				vm_object_unlock(new_object);

				vm_object_lock(result_page-&gt;object);
				PAGE_WAKEUP_DONE(result_page);

				vm_page_lockspin_queues();
				<span class="enscript-keyword">if</span> (!result_page-&gt;active &amp;&amp;
				    !result_page-&gt;inactive &amp;&amp;
				    !result_page-&gt;throttled)
					vm_page_activate(result_page);
				vm_page_activate(new_page);
				vm_page_unlock_queues();

				<span class="enscript-comment">/*
				 *	Release paging references and
				 *	top-level placeholder page, if any.
				 */</span>

				vm_fault_cleanup(result_page-&gt;object,
						 top_page);

				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_RETRY</span>:
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_SHORTAGE</span>:
				<span class="enscript-keyword">if</span> (vm_page_wait(interruptible))
					<span class="enscript-keyword">break</span>;
				<span class="enscript-comment">/* fall thru */</span>

			<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_INTERRUPTED</span>:
				vm_object_lock(new_object);
				VM_PAGE_FREE(new_page);
				vm_object_unlock(new_object);
					
				vm_object_deallocate(new_object);
				vm_object_deallocate(src_object);
				*_result_object = VM_OBJECT_NULL;
				<span class="enscript-keyword">return</span>(MACH_SEND_INTERRUPTED);

			<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_SUCCESS_NO_VM_PAGE</span>:
				<span class="enscript-comment">/* success but no VM page: fail */</span>
				vm_object_paging_end(src_object);
				vm_object_unlock(src_object);
				<span class="enscript-comment">/*FALLTHROUGH*/</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_ERROR</span>:
				<span class="enscript-comment">/*
				 * A policy choice:
				 *	(a) ignore pages that we can't
				 *	    copy
				 *	(b) return the null object if
				 *	    any page fails [chosen]
				 */</span>

				vm_object_lock(new_object);
				VM_PAGE_FREE(new_page);
				vm_object_unlock(new_object);

				vm_object_deallocate(new_object);
				vm_object_deallocate(src_object);
				*_result_object = VM_OBJECT_NULL;
				<span class="enscript-keyword">return</span>(error_code ? error_code:
				       KERN_MEMORY_ERROR);

			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;vm_object_copy_slowly: unexpected error&quot;</span>
				      <span class="enscript-string">&quot; 0x%x from vm_fault_page()\n&quot;</span>, result);
			}
		} <span class="enscript-keyword">while</span> (result != VM_FAULT_SUCCESS);
	}

	<span class="enscript-comment">/*
	 *	Lose the extra reference, and return our object.
	 */</span>
	vm_object_deallocate(src_object);
	*_result_object = new_object;
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_copy_quickly
 *
 *	Purpose:
 *		Copy the specified range of the source virtual
 *		memory object, if it can be done without waiting
 *		for user-generated events.
 *
 *	Results:
 *		If the copy is successful, the copy is returned in
 *		the arguments; otherwise, the arguments are not
 *		affected.
 *
 *	In/out conditions:
 *		The object should be unlocked on entry and exit.
 */</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
__private_extern__ boolean_t
<span class="enscript-function-name">vm_object_copy_quickly</span>(
	vm_object_t		*_object,		<span class="enscript-comment">/* INOUT */</span>
	__unused vm_object_offset_t	offset,	<span class="enscript-comment">/* IN */</span>
	__unused vm_object_size_t	size,	<span class="enscript-comment">/* IN */</span>
	boolean_t		*_src_needs_copy,	<span class="enscript-comment">/* OUT */</span>
	boolean_t		*_dst_needs_copy)	<span class="enscript-comment">/* OUT */</span>
{
	vm_object_t	object = *_object;
	memory_object_copy_strategy_t copy_strategy;

	XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;v_o_c_quickly obj 0x%x off 0x%x size 0x%x\n&quot;</span>,
	    *_object, offset, size, 0, 0);
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
		*_src_needs_copy = FALSE;
		*_dst_needs_copy = FALSE;
		<span class="enscript-keyword">return</span>(TRUE);
	}

	vm_object_lock(object);

	copy_strategy = object-&gt;copy_strategy;

	<span class="enscript-keyword">switch</span> (copy_strategy) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORY_OBJECT_COPY_SYMMETRIC</span>:

		<span class="enscript-comment">/*
		 *	Symmetric copy strategy.
		 *	Make another reference to the object.
		 *	Leave object/offset unchanged.
		 */</span>

		vm_object_reference_locked(object);
		object-&gt;shadowed = TRUE;
		vm_object_unlock(object);

		<span class="enscript-comment">/*
		 *	Both source and destination must make
		 *	shadows, and the source must be made
		 *	read-only if not already.
		 */</span>

		*_src_needs_copy = TRUE;
		*_dst_needs_copy = TRUE;

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORY_OBJECT_COPY_DELAY</span>:
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span>(FALSE);

	<span class="enscript-reference">default</span>:
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span>(FALSE);
	}
	<span class="enscript-keyword">return</span>(TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_call_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_call_sleep_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_call_restart_count = 0;

<span class="enscript-comment">/*
 *	Routine:	vm_object_copy_call [internal]
 *
 *	Description:
 *		Copy the source object (src_object), using the
 *		user-managed copy algorithm.
 *
 *	In/out conditions:
 *		The source object must be locked on entry.  It
 *		will be *unlocked* on exit.
 *
 *	Results:
 *		If the copy is successful, KERN_SUCCESS is returned.
 *		A new object that represents the copied virtual
 *		memory is returned in a parameter (*_result_object).
 *		If the return value indicates an error, this parameter
 *		is not valid.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vm_object_copy_call</span>(
	vm_object_t		src_object,
	vm_object_offset_t	src_offset,
	vm_object_size_t	size,
	vm_object_t		*_result_object)	<span class="enscript-comment">/* OUT */</span>
{
	kern_return_t	kr;
	vm_object_t	copy;
	boolean_t	check_ready = FALSE;
	uint32_t	try_failed_count = 0;

	<span class="enscript-comment">/*
	 *	If a copy is already in progress, wait and retry.
	 *
	 *	XXX
	 *	Consider making this call interruptable, as Mike
	 *	intended it to be.
	 *
	 *	XXXO
	 *	Need a counter or version or something to allow
	 *	us to use the copy that the currently requesting
	 *	thread is obtaining -- is it worth adding to the
	 *	vm object structure? Depends how common this case it.
	 */</span>
	copy_call_count++;
	<span class="enscript-keyword">while</span> (vm_object_wanted(src_object, VM_OBJECT_EVENT_COPY_CALL)) {
		vm_object_sleep(src_object, VM_OBJECT_EVENT_COPY_CALL,
			       THREAD_UNINT);
		copy_call_restart_count++;
	}

	<span class="enscript-comment">/*
	 *	Indicate (for the benefit of memory_object_create_copy)
	 *	that we want a copy for src_object. (Note that we cannot
	 *	do a real assert_wait before calling memory_object_copy,
	 *	so we simply set the flag.)
	 */</span>

	vm_object_set_wanted(src_object, VM_OBJECT_EVENT_COPY_CALL);
	vm_object_unlock(src_object);

	<span class="enscript-comment">/*
	 *	Ask the memory manager to give us a memory object
	 *	which represents a copy of the src object.
	 *	The memory manager may give us a memory object
	 *	which we already have, or it may give us a
	 *	new memory object. This memory object will arrive
	 *	via memory_object_create_copy.
	 */</span>

	kr = KERN_FAILURE;	<span class="enscript-comment">/* XXX need to change memory_object.defs */</span>
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> kr;
	}

	<span class="enscript-comment">/*
	 *	Wait for the copy to arrive.
	 */</span>
	vm_object_lock(src_object);
	<span class="enscript-keyword">while</span> (vm_object_wanted(src_object, VM_OBJECT_EVENT_COPY_CALL)) {
		vm_object_sleep(src_object, VM_OBJECT_EVENT_COPY_CALL,
			       THREAD_UNINT);
		copy_call_sleep_count++;
	}
<span class="enscript-reference">Retry</span>:
	assert(src_object-&gt;copy != VM_OBJECT_NULL);
	copy = src_object-&gt;copy;
	<span class="enscript-keyword">if</span> (!vm_object_lock_try(copy)) {
		vm_object_unlock(src_object);

		try_failed_count++;
		mutex_pause(try_failed_count);	<span class="enscript-comment">/* wait a bit */</span>

		vm_object_lock(src_object);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
	}
	<span class="enscript-keyword">if</span> (copy-&gt;vo_size &lt; src_offset+size)
		copy-&gt;vo_size = src_offset+size;

	<span class="enscript-keyword">if</span> (!copy-&gt;pager_ready)
		check_ready = TRUE;

	<span class="enscript-comment">/*
	 *	Return the copy.
	 */</span>
	*_result_object = copy;
	vm_object_unlock(copy);
	vm_object_unlock(src_object);

	<span class="enscript-comment">/* Wait for the copy to be ready. */</span>
	<span class="enscript-keyword">if</span> (check_ready == TRUE) {
		vm_object_lock(copy);
		<span class="enscript-keyword">while</span> (!copy-&gt;pager_ready) {
			vm_object_sleep(copy, VM_OBJECT_EVENT_PAGER_READY, THREAD_UNINT);
		}
		vm_object_unlock(copy);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_delayed_lock_collisions = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_delayed_max_collisions = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_delayed_lock_contention = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> copy_delayed_protect_iterate = 0;

<span class="enscript-comment">/*
 *	Routine:	vm_object_copy_delayed [internal]
 *
 *	Description:
 *		Copy the specified virtual memory object, using
 *		the asymmetric copy-on-write algorithm.
 *
 *	In/out conditions:
 *		The src_object must be locked on entry.  It will be unlocked
 *		on exit - so the caller must also hold a reference to it.
 *
 *		This routine will not block waiting for user-generated
 *		events.  It is not interruptible.
 */</span>
__private_extern__ vm_object_t
<span class="enscript-function-name">vm_object_copy_delayed</span>(
	vm_object_t		src_object,
	vm_object_offset_t	src_offset,
	vm_object_size_t	size,
	boolean_t		src_object_shared)
{
	vm_object_t		new_copy = VM_OBJECT_NULL;
	vm_object_t		old_copy;
	vm_page_t		p;
	vm_object_size_t	copy_size = src_offset + size;
	pmap_flush_context	pmap_flush_context_storage;
	boolean_t		delayed_pmap_flush = FALSE;


	<span class="enscript-type">int</span> collisions = 0;
	<span class="enscript-comment">/*
	 *	The user-level memory manager wants to see all of the changes
	 *	to this object, but it has promised not to make any changes on
 	 *	its own.
	 *
	 *	Perform an asymmetric copy-on-write, as follows:
	 *		Create a new object, called a &quot;copy object&quot; to hold
	 *		 pages modified by the new mapping  (i.e., the copy,
	 *		 not the original mapping).
	 *		Record the original object as the backing object for
	 *		 the copy object.  If the original mapping does not
	 *		 change a page, it may be used read-only by the copy.
	 *		Record the copy object in the original object.
	 *		 When the original mapping causes a page to be modified,
	 *		 it must be copied to a new page that is &quot;pushed&quot; to
	 *		 the copy object.
	 *		Mark the new mapping (the copy object) copy-on-write.
	 *		 This makes the copy object itself read-only, allowing
	 *		 it to be reused if the original mapping makes no
	 *		 changes, and simplifying the synchronization required
	 *		 in the &quot;push&quot; operation described above.
	 *
	 *	The copy-on-write is said to be assymetric because the original
	 *	object is *not* marked copy-on-write. A copied page is pushed
	 *	to the copy object, regardless which party attempted to modify
	 *	the page.
	 *
	 *	Repeated asymmetric copy operations may be done. If the
	 *	original object has not been changed since the last copy, its
	 *	copy object can be reused. Otherwise, a new copy object can be
	 *	inserted between the original object and its previous copy
	 *	object.  Since any copy object is read-only, this cannot affect
	 *	affect the contents of the previous copy object.
	 *
	 *	Note that a copy object is higher in the object tree than the
	 *	original object; therefore, use of the copy object recorded in
	 *	the original object must be done carefully, to avoid deadlock.
	 */</span>

	copy_size = vm_object_round_page(copy_size);
 <span class="enscript-reference">Retry</span>:
 
	<span class="enscript-comment">/*
	 * Wait for paging in progress.
	 */</span>
	<span class="enscript-keyword">if</span> (!src_object-&gt;true_share &amp;&amp;
	    (src_object-&gt;paging_in_progress != 0 ||
	     src_object-&gt;activity_in_progress != 0)) {
	        <span class="enscript-keyword">if</span> (src_object_shared == TRUE) {
		        vm_object_unlock(src_object);
			vm_object_lock(src_object);
			src_object_shared = FALSE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
		}
		vm_object_paging_wait(src_object, THREAD_UNINT);
	}
	<span class="enscript-comment">/*
	 *	See whether we can reuse the result of a previous
	 *	copy operation.
	 */</span>

	old_copy = src_object-&gt;copy;
	<span class="enscript-keyword">if</span> (old_copy != VM_OBJECT_NULL) {
	        <span class="enscript-type">int</span> lock_granted;

		<span class="enscript-comment">/*
		 *	Try to get the locks (out of order)
		 */</span>
		<span class="enscript-keyword">if</span> (src_object_shared == TRUE)
		        lock_granted = vm_object_lock_try_shared(old_copy);
		<span class="enscript-keyword">else</span>
		        lock_granted = vm_object_lock_try(old_copy);

		<span class="enscript-keyword">if</span> (!lock_granted) {
			vm_object_unlock(src_object);

			<span class="enscript-keyword">if</span> (collisions++ == 0)
				copy_delayed_lock_contention++;
			mutex_pause(collisions);

			<span class="enscript-comment">/* Heisenberg Rules */</span>
			copy_delayed_lock_collisions++;

			<span class="enscript-keyword">if</span> (collisions &gt; copy_delayed_max_collisions)
				copy_delayed_max_collisions = collisions;

			<span class="enscript-keyword">if</span> (src_object_shared == TRUE)
			        vm_object_lock_shared(src_object);
			<span class="enscript-keyword">else</span>
			        vm_object_lock(src_object);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
		}

		<span class="enscript-comment">/*
		 *	Determine whether the old copy object has
		 *	been modified.
		 */</span>

		<span class="enscript-keyword">if</span> (old_copy-&gt;resident_page_count == 0 &amp;&amp;
		    !old_copy-&gt;pager_created) {
			<span class="enscript-comment">/*
			 *	It has not been modified.
			 *
			 *	Return another reference to
			 *	the existing copy-object if
			 *	we can safely grow it (if
			 *	needed).
			 */</span>

			<span class="enscript-keyword">if</span> (old_copy-&gt;vo_size &lt; copy_size) {
			        <span class="enscript-keyword">if</span> (src_object_shared == TRUE) {
				        vm_object_unlock(old_copy);
					vm_object_unlock(src_object);
				
					vm_object_lock(src_object);
					src_object_shared = FALSE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
				}
				<span class="enscript-comment">/*
				 * We can't perform a delayed copy if any of the
				 * pages in the extended range are wired (because
				 * we can't safely take write permission away from
				 * wired pages).  If the pages aren't wired, then
				 * go ahead and protect them.
				 */</span>
				copy_delayed_protect_iterate++;

				pmap_flush_context_init(&amp;pmap_flush_context_storage);
				delayed_pmap_flush = FALSE;

				queue_iterate(&amp;src_object-&gt;memq, p, vm_page_t, listq) {
					<span class="enscript-keyword">if</span> (!p-&gt;fictitious &amp;&amp; 
					    p-&gt;offset &gt;= old_copy-&gt;vo_size &amp;&amp; 
					    p-&gt;offset &lt; copy_size) {
						<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p)) {
							vm_object_unlock(old_copy);
							vm_object_unlock(src_object);

							<span class="enscript-keyword">if</span> (new_copy != VM_OBJECT_NULL) {
								vm_object_unlock(new_copy);
								vm_object_deallocate(new_copy);
							}
							<span class="enscript-keyword">if</span> (delayed_pmap_flush == TRUE)
								pmap_flush(&amp;pmap_flush_context_storage);

							<span class="enscript-keyword">return</span> VM_OBJECT_NULL;
						} <span class="enscript-keyword">else</span> {
							pmap_page_protect_options(p-&gt;phys_page, (VM_PROT_ALL &amp; ~VM_PROT_WRITE),
										  PMAP_OPTIONS_NOFLUSH, (<span class="enscript-type">void</span> *)&amp;pmap_flush_context_storage);
							delayed_pmap_flush = TRUE;
						}
					}
				}
				<span class="enscript-keyword">if</span> (delayed_pmap_flush == TRUE)
					pmap_flush(&amp;pmap_flush_context_storage);

				old_copy-&gt;vo_size = copy_size;
			}
			<span class="enscript-keyword">if</span> (src_object_shared == TRUE)
			        vm_object_reference_shared(old_copy);
			<span class="enscript-keyword">else</span>
			        vm_object_reference_locked(old_copy);
			vm_object_unlock(old_copy);
			vm_object_unlock(src_object);

			<span class="enscript-keyword">if</span> (new_copy != VM_OBJECT_NULL) {
				vm_object_unlock(new_copy);
				vm_object_deallocate(new_copy);
			}
			<span class="enscript-keyword">return</span>(old_copy);
		}
		
		

		<span class="enscript-comment">/*
		 * Adjust the size argument so that the newly-created 
		 * copy object will be large enough to back either the
		 * old copy object or the new mapping.
		 */</span>
		<span class="enscript-keyword">if</span> (old_copy-&gt;vo_size &gt; copy_size)
			copy_size = old_copy-&gt;vo_size;

		<span class="enscript-keyword">if</span> (new_copy == VM_OBJECT_NULL) {
			vm_object_unlock(old_copy);
			vm_object_unlock(src_object);
			new_copy = vm_object_allocate(copy_size);
			vm_object_lock(src_object);
			vm_object_lock(new_copy);

			src_object_shared = FALSE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
		}
		new_copy-&gt;vo_size = copy_size;	

		<span class="enscript-comment">/*
		 *	The copy-object is always made large enough to
		 *	completely shadow the original object, since
		 *	it may have several users who want to shadow
		 *	the original object at different points.
		 */</span>

		assert((old_copy-&gt;shadow == src_object) &amp;&amp;
		    (old_copy-&gt;vo_shadow_offset == (vm_object_offset_t) 0));

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (new_copy == VM_OBJECT_NULL) {
		vm_object_unlock(src_object);
		new_copy = vm_object_allocate(copy_size);
		vm_object_lock(src_object);
		vm_object_lock(new_copy);

		src_object_shared = FALSE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
	}

	<span class="enscript-comment">/*
	 * We now have the src object locked, and the new copy object
	 * allocated and locked (and potentially the old copy locked).
	 * Before we go any further, make sure we can still perform
	 * a delayed copy, as the situation may have changed.
	 *
	 * Specifically, we can't perform a delayed copy if any of the
	 * pages in the range are wired (because we can't safely take
	 * write permission away from wired pages).  If the pages aren't
	 * wired, then go ahead and protect them.
	 */</span>
	copy_delayed_protect_iterate++;

	pmap_flush_context_init(&amp;pmap_flush_context_storage);
	delayed_pmap_flush = FALSE;

	queue_iterate(&amp;src_object-&gt;memq, p, vm_page_t, listq) {
		<span class="enscript-keyword">if</span> (!p-&gt;fictitious &amp;&amp; p-&gt;offset &lt; copy_size) {
			<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p)) {
				<span class="enscript-keyword">if</span> (old_copy)
					vm_object_unlock(old_copy);
				vm_object_unlock(src_object);
				vm_object_unlock(new_copy);
				vm_object_deallocate(new_copy);

				<span class="enscript-keyword">if</span> (delayed_pmap_flush == TRUE)
					pmap_flush(&amp;pmap_flush_context_storage);

				<span class="enscript-keyword">return</span> VM_OBJECT_NULL;
			} <span class="enscript-keyword">else</span> {
				pmap_page_protect_options(p-&gt;phys_page, (VM_PROT_ALL &amp; ~VM_PROT_WRITE),
							  PMAP_OPTIONS_NOFLUSH, (<span class="enscript-type">void</span> *)&amp;pmap_flush_context_storage);
				delayed_pmap_flush = TRUE;
			}
		}
	}
	<span class="enscript-keyword">if</span> (delayed_pmap_flush == TRUE)
		pmap_flush(&amp;pmap_flush_context_storage);

	<span class="enscript-keyword">if</span> (old_copy != VM_OBJECT_NULL) {
		<span class="enscript-comment">/*
		 *	Make the old copy-object shadow the new one.
		 *	It will receive no more pages from the original
		 *	object.
		 */</span>

		<span class="enscript-comment">/* remove ref. from old_copy */</span>
		vm_object_lock_assert_exclusive(src_object);
		src_object-&gt;ref_count--;
		assert(src_object-&gt;ref_count &gt; 0);
		vm_object_lock_assert_exclusive(old_copy);
		old_copy-&gt;shadow = new_copy;
		vm_object_lock_assert_exclusive(new_copy);
		assert(new_copy-&gt;ref_count &gt; 0);
		new_copy-&gt;ref_count++;		<span class="enscript-comment">/* for old_copy-&gt;shadow ref. */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TASK_SWAPPER</span>
		<span class="enscript-keyword">if</span> (old_copy-&gt;res_count) {
			VM_OBJ_RES_INCR(new_copy);
			VM_OBJ_RES_DECR(src_object);
		}
#<span class="enscript-reference">endif</span>

		vm_object_unlock(old_copy);	<span class="enscript-comment">/* done with old_copy */</span>
	}

	<span class="enscript-comment">/*
	 *	Point the new copy at the existing object.
	 */</span>
	vm_object_lock_assert_exclusive(new_copy);
	new_copy-&gt;shadow = src_object;
	new_copy-&gt;vo_shadow_offset = 0;
	new_copy-&gt;shadowed = TRUE;	<span class="enscript-comment">/* caller must set needs_copy */</span>

	vm_object_lock_assert_exclusive(src_object);
	vm_object_reference_locked(src_object);
	src_object-&gt;copy = new_copy;
	vm_object_unlock(src_object);
	vm_object_unlock(new_copy);

	XPR(XPR_VM_OBJECT,
		<span class="enscript-string">&quot;vm_object_copy_delayed: used copy object %X for source %X\n&quot;</span>,
		new_copy, src_object, 0, 0, 0);

	<span class="enscript-keyword">return</span> new_copy;
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_copy_strategically
 *
 *	Purpose:
 *		Perform a copy according to the source object's
 *		declared strategy.  This operation may block,
 *		and may be interrupted.
 */</span>
__private_extern__ kern_return_t
<span class="enscript-function-name">vm_object_copy_strategically</span>(
	<span class="enscript-type">register</span> vm_object_t	src_object,
	vm_object_offset_t	src_offset,
	vm_object_size_t	size,
	vm_object_t		*dst_object,	<span class="enscript-comment">/* OUT */</span>
	vm_object_offset_t	*dst_offset,	<span class="enscript-comment">/* OUT */</span>
	boolean_t		*dst_needs_copy) <span class="enscript-comment">/* OUT */</span>
{
	boolean_t	result;
	boolean_t	interruptible = THREAD_ABORTSAFE; <span class="enscript-comment">/* XXX */</span>
	boolean_t	object_lock_shared = FALSE;
	memory_object_copy_strategy_t copy_strategy;

	assert(src_object != VM_OBJECT_NULL);

	copy_strategy = src_object-&gt;copy_strategy;

	<span class="enscript-keyword">if</span> (copy_strategy == MEMORY_OBJECT_COPY_DELAY) {
	        vm_object_lock_shared(src_object);
		object_lock_shared = TRUE;
	} <span class="enscript-keyword">else</span>
	        vm_object_lock(src_object);

	<span class="enscript-comment">/*
	 *	The copy strategy is only valid if the memory manager
	 *	is &quot;ready&quot;. Internal objects are always ready.
	 */</span>

	<span class="enscript-keyword">while</span> (!src_object-&gt;internal &amp;&amp; !src_object-&gt;pager_ready) {
		wait_result_t wait_result;

		<span class="enscript-keyword">if</span> (object_lock_shared == TRUE) {
		        vm_object_unlock(src_object);
			vm_object_lock(src_object);
			object_lock_shared = FALSE;
			<span class="enscript-keyword">continue</span>;
		}
		wait_result = vm_object_sleep(	src_object,
						VM_OBJECT_EVENT_PAGER_READY,
						interruptible);
		<span class="enscript-keyword">if</span> (wait_result != THREAD_AWAKENED) {
			vm_object_unlock(src_object);
			*dst_object = VM_OBJECT_NULL;
			*dst_offset = 0;
			*dst_needs_copy = FALSE;
			<span class="enscript-keyword">return</span>(MACH_SEND_INTERRUPTED);
		}
	}

	<span class="enscript-comment">/*
	 *	Use the appropriate copy strategy.
	 */</span>

	<span class="enscript-keyword">switch</span> (copy_strategy) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORY_OBJECT_COPY_DELAY</span>:
		*dst_object = vm_object_copy_delayed(src_object,
						     src_offset, size, object_lock_shared);
		<span class="enscript-keyword">if</span> (*dst_object != VM_OBJECT_NULL) {
			*dst_offset = src_offset;
			*dst_needs_copy = TRUE;
			result = KERN_SUCCESS;
			<span class="enscript-keyword">break</span>;
		}
		vm_object_lock(src_object);
		<span class="enscript-comment">/* fall thru when delayed copy not allowed */</span>

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORY_OBJECT_COPY_NONE</span>:
		result = vm_object_copy_slowly(src_object, src_offset, size,
					       interruptible, dst_object);
		<span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
			*dst_offset = 0;
			*dst_needs_copy = FALSE;
		}
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORY_OBJECT_COPY_CALL</span>:
		result = vm_object_copy_call(src_object, src_offset, size,
				dst_object);
		<span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
			*dst_offset = src_offset;
			*dst_needs_copy = TRUE;
		}
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORY_OBJECT_COPY_SYMMETRIC</span>:
		XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;v_o_c_strategically obj 0x%x off 0x%x size 0x%x\n&quot;</span>, src_object, src_offset, size, 0, 0);
		vm_object_unlock(src_object);
		result = KERN_MEMORY_RESTART_COPY;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;copy_strategically: bad strategy&quot;</span>);
		result = KERN_INVALID_ARGUMENT;
	}
	<span class="enscript-keyword">return</span>(result);
}

<span class="enscript-comment">/*
 *	vm_object_shadow:
 *
 *	Create a new object which is backed by the
 *	specified existing object range.  The source
 *	object reference is deallocated.
 *
 *	The new object and offset into that object
 *	are returned in the source parameters.
 */</span>
boolean_t vm_object_shadow_check = TRUE;

__private_extern__ boolean_t
<span class="enscript-function-name">vm_object_shadow</span>(
	vm_object_t		*object,	<span class="enscript-comment">/* IN/OUT */</span>
	vm_object_offset_t	*offset,	<span class="enscript-comment">/* IN/OUT */</span>
	vm_object_size_t	length)
{
	<span class="enscript-type">register</span> vm_object_t	source;
	<span class="enscript-type">register</span> vm_object_t	result;

	source = *object;
	assert(source != VM_OBJECT_NULL);
	<span class="enscript-keyword">if</span> (source == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span> FALSE;

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * XXX FBDP
	 * This assertion is valid but it gets triggered by Rosetta for example
	 * due to a combination of vm_remap() that changes a VM object's
	 * copy_strategy from SYMMETRIC to DELAY and vm_protect(VM_PROT_COPY)
	 * that then sets &quot;needs_copy&quot; on its map entry.  This creates a
	 * mapping situation that VM should never see and doesn't know how to
	 * handle.
	 * It's not clear if this can create any real problem but we should
	 * look into fixing this, probably by having vm_protect(VM_PROT_COPY)
	 * do more than just set &quot;needs_copy&quot; to handle the copy-on-write...
	 * In the meantime, let's disable the assertion.
	 */</span>
	assert(source-&gt;copy_strategy == MEMORY_OBJECT_COPY_SYMMETRIC);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 *	Determine if we really need a shadow.
	 *
	 *	If the source object is larger than what we are trying
	 *	to create, then force the shadow creation even if the
	 *	ref count is 1.  This will allow us to [potentially]
	 *	collapse the underlying object away in the future
	 *	(freeing up the extra data it might contain and that
	 *	we don't need).
	 */</span>
	<span class="enscript-keyword">if</span> (vm_object_shadow_check &amp;&amp;
	    source-&gt;vo_size == length &amp;&amp;
	    source-&gt;ref_count == 1 &amp;&amp;
	    (source-&gt;shadow == VM_OBJECT_NULL ||
	     source-&gt;shadow-&gt;copy == VM_OBJECT_NULL) )
	{
		source-&gt;shadowed = FALSE;
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-comment">/*
	 *	Allocate a new object with the given length
	 */</span>

	<span class="enscript-keyword">if</span> ((result = vm_object_allocate(length)) == VM_OBJECT_NULL)
		panic(<span class="enscript-string">&quot;vm_object_shadow: no object for shadowing&quot;</span>);

	<span class="enscript-comment">/*
	 *	The new object shadows the source object, adding
	 *	a reference to it.  Our caller changes his reference
	 *	to point to the new object, removing a reference to
	 *	the source object.  Net result: no change of reference
	 *	count.
	 */</span>
	result-&gt;shadow = source;
	
	<span class="enscript-comment">/*
	 *	Store the offset into the source object,
	 *	and fix up the offset into the new object.
	 */</span>

	result-&gt;vo_shadow_offset = *offset;

	<span class="enscript-comment">/*
	 *	Return the new things
	 */</span>

	*offset = 0;
	*object = result;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 *	The relationship between vm_object structures and
 *	the memory_object requires careful synchronization.
 *
 *	All associations are created by memory_object_create_named
 *  for external pagers and vm_object_pager_create for internal
 *  objects as follows:
 *
 *		pager:	the memory_object itself, supplied by
 *			the user requesting a mapping (or the kernel,
 *			when initializing internal objects); the
 *			kernel simulates holding send rights by keeping
 *			a port reference;
 *
 *		pager_request:
 *			the memory object control port,
 *			created by the kernel; the kernel holds
 *			receive (and ownership) rights to this
 *			port, but no other references.
 *
 *	When initialization is complete, the &quot;initialized&quot; field
 *	is asserted.  Other mappings using a particular memory object,
 *	and any references to the vm_object gained through the
 *	port association must wait for this initialization to occur.
 *
 *	In order to allow the memory manager to set attributes before
 *	requests (notably virtual copy operations, but also data or
 *	unlock requests) are made, a &quot;ready&quot; attribute is made available.
 *	Only the memory manager may affect the value of this attribute.
 *	Its value does not affect critical kernel functions, such as
 *	internal object initialization or destruction.  [Furthermore,
 *	memory objects created by the kernel are assumed to be ready
 *	immediately; the default memory manager need not explicitly
 *	set the &quot;ready&quot; attribute.]
 *
 *	[Both the &quot;initialized&quot; and &quot;ready&quot; attribute wait conditions
 *	use the &quot;pager&quot; field as the wait event.]
 *
 *	The port associations can be broken down by any of the
 *	following routines:
 *		vm_object_terminate:
 *			No references to the vm_object remain, and
 *			the object cannot (or will not) be cached.
 *			This is the normal case, and is done even
 *			though one of the other cases has already been
 *			done.
 *		memory_object_destroy:
 *			The memory manager has requested that the
 *			kernel relinquish references to the memory
 *			object. [The memory manager may not want to
 *			destroy the memory object, but may wish to
 *			refuse or tear down existing memory mappings.]
 *
 *	Each routine that breaks an association must break all of
 *	them at once.  At some later time, that routine must clear
 *	the pager field and release the memory object references.
 *	[Furthermore, each routine must cope with the simultaneous
 *	or previous operations of the others.]
 *
 *	In addition to the lock on the object, the vm_object_hash_lock
 *	governs the associations.  References gained through the
 *	association require use of the hash lock.
 *
 *	Because the pager field may be cleared spontaneously, it
 *	cannot be used to determine whether a memory object has
 *	ever been associated with a particular vm_object.  [This
 *	knowledge is important to the shadow object mechanism.]
 *	For this reason, an additional &quot;created&quot; attribute is
 *	provided.
 *
 *	During various paging operations, the pager reference found in the
 *	vm_object must be valid.  To prevent this from being released,
 *	(other than being removed, i.e., made null), routines may use
 *	the vm_object_paging_begin/end routines [actually, macros].
 *	The implementation uses the &quot;paging_in_progress&quot; and &quot;wanted&quot; fields.
 *	[Operations that alter the validity of the pager values include the
 *	termination routines and vm_object_collapse.]
 */</span>


<span class="enscript-comment">/*
 *	Routine:	vm_object_enter
 *	Purpose:
 *		Find a VM object corresponding to the given
 *		pager; if no such object exists, create one,
 *		and initialize the pager.
 */</span>
vm_object_t
<span class="enscript-function-name">vm_object_enter</span>(
	memory_object_t		pager,
	vm_object_size_t	size,
	boolean_t		internal,
	boolean_t		init,
	boolean_t		named)
{
	<span class="enscript-type">register</span> vm_object_t	object;
	vm_object_t		new_object;
	boolean_t		must_init;
	vm_object_hash_entry_t	entry, new_entry;
	uint32_t        try_failed_count = 0;
	lck_mtx_t	*lck;

	<span class="enscript-keyword">if</span> (pager == MEMORY_OBJECT_NULL)
		<span class="enscript-keyword">return</span>(vm_object_allocate(size));

	new_object = VM_OBJECT_NULL;
	new_entry = VM_OBJECT_HASH_ENTRY_NULL;
	must_init = init;

	<span class="enscript-comment">/*
	 *	Look for an object associated with this port.
	 */</span>
<span class="enscript-reference">Retry</span>:
	lck = vm_object_hash_lock_spin(pager);
	<span class="enscript-keyword">do</span> {
		entry = vm_object_hash_lookup(pager, FALSE);

		<span class="enscript-keyword">if</span> (entry == VM_OBJECT_HASH_ENTRY_NULL) {
			<span class="enscript-keyword">if</span> (new_object == VM_OBJECT_NULL) {
				<span class="enscript-comment">/*
				 *	We must unlock to create a new object;
				 *	if we do so, we must try the lookup again.
				 */</span>
				vm_object_hash_unlock(lck);
				assert(new_entry == VM_OBJECT_HASH_ENTRY_NULL);
				new_entry = vm_object_hash_entry_alloc(pager);
				new_object = vm_object_allocate(size);
				<span class="enscript-comment">/*
				 * Set new_object-&gt;hashed now, while noone
				 * knows about this object yet and we
				 * don't need to lock it.  Once it's in
				 * the hash table, we would have to lock
				 * the object to set its &quot;hashed&quot; bit and
				 * we can't lock the object while holding
				 * the hash lock as a spinlock...
				 */</span>
				new_object-&gt;hashed = TRUE;
				lck = vm_object_hash_lock_spin(pager);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 *	Lookup failed twice, and we have something
				 *	to insert; set the object.
				 */</span>
				<span class="enscript-comment">/*
				 * We can't lock the object here since we're
				 * holding the hash lock as a spin lock.
				 * We've already pre-set &quot;new_object-&gt;hashed&quot;
				 * when we created &quot;new_object&quot; above, so we
				 * won't need to modify the object in
				 * vm_object_hash_insert().
				 */</span>
				assert(new_object-&gt;hashed);
				vm_object_hash_insert(new_entry, new_object);
				entry = new_entry;
				new_entry = VM_OBJECT_HASH_ENTRY_NULL;
				new_object = VM_OBJECT_NULL;
				must_init = TRUE;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (entry-&gt;object == VM_OBJECT_NULL) {
			<span class="enscript-comment">/*
		 	 *	If a previous object is being terminated,
			 *	we must wait for the termination message
			 *	to be queued (and lookup the entry again).
			 */</span>
			entry-&gt;waiting = TRUE;
			entry = VM_OBJECT_HASH_ENTRY_NULL;
			assert_wait((event_t) pager, THREAD_UNINT);
			vm_object_hash_unlock(lck);

			thread_block(THREAD_CONTINUE_NULL);
			lck = vm_object_hash_lock_spin(pager);
		}
	} <span class="enscript-keyword">while</span> (entry == VM_OBJECT_HASH_ENTRY_NULL);

	object = entry-&gt;object;
	assert(object != VM_OBJECT_NULL);

	<span class="enscript-keyword">if</span> (!must_init) {
	        <span class="enscript-keyword">if</span> ( !vm_object_lock_try(object)) {

		        vm_object_hash_unlock(lck);

		        try_failed_count++;
			mutex_pause(try_failed_count);  <span class="enscript-comment">/* wait a bit */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
		}
		assert(!internal || object-&gt;internal);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
		<span class="enscript-keyword">if</span> (object-&gt;ref_count == 0) {
			<span class="enscript-keyword">if</span> ( !vm_object_cache_lock_try()) {

				vm_object_hash_unlock(lck);
				vm_object_unlock(object);

				try_failed_count++;
				mutex_pause(try_failed_count);  <span class="enscript-comment">/* wait a bit */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
			}
			XPR(XPR_VM_OBJECT_CACHE,
			    <span class="enscript-string">&quot;vm_object_enter: removing %x from cache, head (%x, %x)\n&quot;</span>,
				object,
				vm_object_cached_list.next,
				vm_object_cached_list.prev, 0,0);
			queue_remove(&amp;vm_object_cached_list, object,
				     vm_object_t, cached_list);
			vm_object_cached_count--;

			vm_object_cache_unlock();
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (named) {
			assert(!object-&gt;named);
			object-&gt;named = TRUE;
		}
		vm_object_lock_assert_exclusive(object);
		object-&gt;ref_count++;
		vm_object_res_reference(object);

		vm_object_hash_unlock(lck);
		vm_object_unlock(object);

		VM_STAT_INCR(hits);
	} <span class="enscript-keyword">else</span>
		vm_object_hash_unlock(lck);

	assert(object-&gt;ref_count &gt; 0);

	VM_STAT_INCR(lookups);

	XPR(XPR_VM_OBJECT,
		<span class="enscript-string">&quot;vm_o_enter: pager 0x%x obj 0x%x must_init %d\n&quot;</span>,
		pager, object, must_init, 0, 0);

	<span class="enscript-comment">/*
	 *	If we raced to create a vm_object but lost, let's
	 *	throw away ours.
	 */</span>

	<span class="enscript-keyword">if</span> (new_object != VM_OBJECT_NULL) {
		<span class="enscript-comment">/*
		 * Undo the pre-setting of &quot;new_object-&gt;hashed&quot; before
		 * deallocating &quot;new_object&quot;, since we did not insert it
		 * into the hash table after all.
		 */</span>
		assert(new_object-&gt;hashed);
		new_object-&gt;hashed = FALSE;
		vm_object_deallocate(new_object);
	}

	<span class="enscript-keyword">if</span> (new_entry != VM_OBJECT_HASH_ENTRY_NULL)
		vm_object_hash_entry_free(new_entry);

	<span class="enscript-keyword">if</span> (must_init) {
		memory_object_control_t control;

		<span class="enscript-comment">/*
		 *	Allocate request port.
		 */</span>

		control = memory_object_control_allocate(object);
		assert (control != MEMORY_OBJECT_CONTROL_NULL);

		vm_object_lock(object);
		assert(object != kernel_object);

		<span class="enscript-comment">/*
		 *	Copy the reference we were given.
		 */</span>

		memory_object_reference(pager);
		object-&gt;pager_created = TRUE;
		object-&gt;pager = pager;
		object-&gt;internal = internal;
		object-&gt;pager_trusted = internal;
		<span class="enscript-keyword">if</span> (!internal) {
			<span class="enscript-comment">/* copy strategy invalid until set by memory manager */</span>
			object-&gt;copy_strategy = MEMORY_OBJECT_COPY_INVALID;
		}
		object-&gt;pager_control = control;
		object-&gt;pager_ready = FALSE;

		vm_object_unlock(object);

		<span class="enscript-comment">/*
		 *	Let the pager know we're using it.
		 */</span>

		(<span class="enscript-type">void</span>) memory_object_init(pager,
			object-&gt;pager_control,
			PAGE_SIZE);

		vm_object_lock(object);
		<span class="enscript-keyword">if</span> (named)
			object-&gt;named = TRUE;
		<span class="enscript-keyword">if</span> (internal) {
			object-&gt;pager_ready = TRUE;
			vm_object_wakeup(object, VM_OBJECT_EVENT_PAGER_READY);
		}

		object-&gt;pager_initialized = TRUE;
		vm_object_wakeup(object, VM_OBJECT_EVENT_INITIALIZED);
	} <span class="enscript-keyword">else</span> {
		vm_object_lock(object);
	}

	<span class="enscript-comment">/*
	 *	[At this point, the object must be locked]
	 */</span>

	<span class="enscript-comment">/*
	 *	Wait for the work above to be done by the first
	 *	thread to map this object.
	 */</span>

	<span class="enscript-keyword">while</span> (!object-&gt;pager_initialized) {
		vm_object_sleep(object,
				VM_OBJECT_EVENT_INITIALIZED,
				THREAD_UNINT);
	}
	vm_object_unlock(object);

	XPR(XPR_VM_OBJECT,
	    <span class="enscript-string">&quot;vm_object_enter: vm_object %x, memory_object %x, internal %d\n&quot;</span>,
	    object, object-&gt;pager, internal, 0,0);
	<span class="enscript-keyword">return</span>(object);
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_pager_create
 *	Purpose:
 *		Create a memory object for an internal object.
 *	In/out conditions:
 *		The object is locked on entry and exit;
 *		it may be unlocked within this call.
 *	Limitations:
 *		Only one thread may be performing a
 *		vm_object_pager_create on an object at
 *		a time.  Presumably, only the pageout
 *		daemon will be using this routine.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pager_create</span>(
	<span class="enscript-type">register</span> vm_object_t	object)
{
	memory_object_t		pager;
	vm_object_hash_entry_t	entry;
	lck_mtx_t		*lck;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	vm_object_size_t	size;
	vm_external_map_t	map;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>

	XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;vm_object_pager_create, object 0x%X\n&quot;</span>,
		object, 0,0,0,0);

	assert(object != kernel_object);

	<span class="enscript-keyword">if</span> (memory_manager_default_check() != KERN_SUCCESS)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 *	Prevent collapse or termination by holding a paging reference
	 */</span>

	vm_object_paging_begin(object);
	<span class="enscript-keyword">if</span> (object-&gt;pager_created) {
		<span class="enscript-comment">/*
		 *	Someone else got to it first...
		 *	wait for them to finish initializing the ports
		 */</span>
		<span class="enscript-keyword">while</span> (!object-&gt;pager_initialized) {
			vm_object_sleep(object,
				        VM_OBJECT_EVENT_INITIALIZED,
				        THREAD_UNINT);
		}
		vm_object_paging_end(object);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 *	Indicate that a memory object has been assigned
	 *	before dropping the lock, to prevent a race.
	 */</span>

	object-&gt;pager_created = TRUE;
	object-&gt;paging_offset = 0;
		
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	size = object-&gt;vo_size;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
	vm_object_unlock(object);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	<span class="enscript-keyword">if</span> (DEFAULT_PAGER_IS_ACTIVE) {
		map = vm_external_create(size);
		vm_object_lock(object);
		assert(object-&gt;vo_size == size);
		object-&gt;existence_map = map;
		vm_object_unlock(object);
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>

	<span class="enscript-keyword">if</span> ((uint32_t) object-&gt;vo_size != object-&gt;vo_size) {
		panic(<span class="enscript-string">&quot;vm_object_pager_create(): object size 0x%llx &gt;= 4GB\n&quot;</span>,
		      (uint64_t) object-&gt;vo_size);
	}

	<span class="enscript-comment">/*
	 *	Create the [internal] pager, and associate it with this object.
	 *
	 *	We make the association here so that vm_object_enter()
	 * 	can look up the object to complete initializing it.  No
	 *	user will ever map this object.
	 */</span>
	{
		memory_object_default_t		dmm;

		<span class="enscript-comment">/* acquire a reference for the default memory manager */</span>
		dmm = memory_manager_default_reference();

		assert(object-&gt;temporary);

		<span class="enscript-comment">/* create our new memory object */</span>
		assert((vm_size_t) object-&gt;vo_size == object-&gt;vo_size);
		(<span class="enscript-type">void</span>) memory_object_create(dmm, (vm_size_t) object-&gt;vo_size,
					    &amp;pager);

		memory_object_default_deallocate(dmm);
       }

	entry = vm_object_hash_entry_alloc(pager);

	vm_object_lock(object);
	lck = vm_object_hash_lock_spin(pager);
	vm_object_hash_insert(entry, object);
	vm_object_hash_unlock(lck);
	vm_object_unlock(object);

	<span class="enscript-comment">/*
	 *	A reference was returned by
	 *	memory_object_create(), and it is
	 *	copied by vm_object_enter().
	 */</span>

	<span class="enscript-keyword">if</span> (vm_object_enter(pager, object-&gt;vo_size, TRUE, TRUE, FALSE) != object)
		panic(<span class="enscript-string">&quot;vm_object_pager_create: mismatch&quot;</span>);

	<span class="enscript-comment">/*
	 *	Drop the reference we were passed.
	 */</span>
	memory_object_deallocate(pager);

	vm_object_lock(object);

	<span class="enscript-comment">/*
	 *	Release the paging reference
	 */</span>
	vm_object_paging_end(object);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_compressor_pager_create</span>(
	<span class="enscript-type">register</span> vm_object_t	object)
{
	memory_object_t		pager;
	vm_object_hash_entry_t	entry;
	lck_mtx_t		*lck;
	vm_object_t		pager_object = VM_OBJECT_NULL;

	assert(object != kernel_object);

	<span class="enscript-comment">/*
	 *	Prevent collapse or termination by holding a paging reference
	 */</span>

	vm_object_paging_begin(object);
	<span class="enscript-keyword">if</span> (object-&gt;pager_created) {
		<span class="enscript-comment">/*
		 *	Someone else got to it first...
		 *	wait for them to finish initializing the ports
		 */</span>
		<span class="enscript-keyword">while</span> (!object-&gt;pager_initialized) {
			vm_object_sleep(object,
				        VM_OBJECT_EVENT_INITIALIZED,
				        THREAD_UNINT);
		}
		vm_object_paging_end(object);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 *	Indicate that a memory object has been assigned
	 *	before dropping the lock, to prevent a race.
	 */</span>

	object-&gt;pager_created = TRUE;
	object-&gt;paging_offset = 0;
		
	vm_object_unlock(object);

	<span class="enscript-keyword">if</span> ((uint32_t) (object-&gt;vo_size/PAGE_SIZE) !=
	    (object-&gt;vo_size/PAGE_SIZE)) {
		panic(<span class="enscript-string">&quot;vm_object_compressor_pager_create(%p): &quot;</span>
		      <span class="enscript-string">&quot;object size 0x%llx &gt;= 0x%llx\n&quot;</span>,
		      object,
		      (uint64_t) object-&gt;vo_size,
		      0x0FFFFFFFFULL*PAGE_SIZE);
	}

	<span class="enscript-comment">/*
	 *	Create the [internal] pager, and associate it with this object.
	 *
	 *	We make the association here so that vm_object_enter()
	 * 	can look up the object to complete initializing it.  No
	 *	user will ever map this object.
	 */</span>
	{
		assert(object-&gt;temporary);

		<span class="enscript-comment">/* create our new memory object */</span>
		assert((uint32_t) (object-&gt;vo_size/PAGE_SIZE) ==
		       (object-&gt;vo_size/PAGE_SIZE));
		(<span class="enscript-type">void</span>) compressor_memory_object_create(
			(memory_object_size_t) object-&gt;vo_size,
			&amp;pager);
		<span class="enscript-keyword">if</span> (pager == NULL) {
			panic(<span class="enscript-string">&quot;vm_object_compressor_pager_create(): &quot;</span>
			      <span class="enscript-string">&quot;no pager for object %p size 0x%llx\n&quot;</span>,
			      object, (uint64_t) object-&gt;vo_size);
		}
       }

	entry = vm_object_hash_entry_alloc(pager);

	vm_object_lock(object);
	lck = vm_object_hash_lock_spin(pager);
	vm_object_hash_insert(entry, object);
	vm_object_hash_unlock(lck);
	vm_object_unlock(object);

	<span class="enscript-comment">/*
	 *	A reference was returned by
	 *	memory_object_create(), and it is
	 *	copied by vm_object_enter().
	 */</span>

	pager_object = vm_object_enter(pager, object-&gt;vo_size, TRUE, TRUE, FALSE);

	<span class="enscript-keyword">if</span> (pager_object != object) {
		panic(<span class="enscript-string">&quot;vm_object_compressor_pager_create: mismatch (pager: %p, pager_object: %p, orig_object: %p, orig_object size: 0x%llx)\n&quot;</span>, pager, pager_object, object, (uint64_t) object-&gt;vo_size);
	}

	<span class="enscript-comment">/*
	 *	Drop the reference we were passed.
	 */</span>
	memory_object_deallocate(pager);

	vm_object_lock(object);

	<span class="enscript-comment">/*
	 *	Release the paging reference
	 */</span>
	vm_object_paging_end(object);
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_remove
 *	Purpose:
 *		Eliminate the pager/object association
 *		for this pager.
 *	Conditions:
 *		The object cache must be locked.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_remove</span>(
	vm_object_t	object)
{
	memory_object_t pager;

	<span class="enscript-keyword">if</span> ((pager = object-&gt;pager) != MEMORY_OBJECT_NULL) {
		vm_object_hash_entry_t	entry;

		entry = vm_object_hash_lookup(pager, FALSE);
		<span class="enscript-keyword">if</span> (entry != VM_OBJECT_HASH_ENTRY_NULL)
			entry-&gt;object = VM_OBJECT_NULL;
	}

}

<span class="enscript-comment">/*
 *	Global variables for vm_object_collapse():
 *
 *		Counts for normal collapses and bypasses.
 *		Debugging variables, to watch or disable collapse.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">long</span>	object_collapses = 0;
<span class="enscript-type">static</span> <span class="enscript-type">long</span>	object_bypasses  = 0;

<span class="enscript-type">static</span> boolean_t	vm_object_collapse_allowed = TRUE;
<span class="enscript-type">static</span> boolean_t	vm_object_bypass_allowed = TRUE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	vm_external_discarded;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	vm_external_collapsed;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_collapse_encrypted = 0;

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_object_do_collapse_compressor</span>(vm_object_t object,
				      vm_object_t backing_object);
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_do_collapse_compressor</span>(
	vm_object_t object,
	vm_object_t backing_object)
{
	vm_object_offset_t new_offset, backing_offset;
	vm_object_size_t size;

	vm_counters.do_collapse_compressor++;

	vm_object_lock_assert_exclusive(object);
	vm_object_lock_assert_exclusive(backing_object);

	size = object-&gt;vo_size;

	<span class="enscript-comment">/*
	 *	Move all compressed pages from backing_object
	 *	to the parent.
	 */</span>

	<span class="enscript-keyword">for</span> (backing_offset = object-&gt;vo_shadow_offset;
	     backing_offset &lt; object-&gt;vo_shadow_offset + object-&gt;vo_size;
	     backing_offset += PAGE_SIZE) {
		memory_object_offset_t backing_pager_offset;

		<span class="enscript-comment">/* find the next compressed page at or after this offset */</span>
		backing_pager_offset = (backing_offset +
					backing_object-&gt;paging_offset);
		backing_pager_offset = vm_compressor_pager_next_compressed(
			backing_object-&gt;pager,
			backing_pager_offset);
		<span class="enscript-keyword">if</span> (backing_pager_offset == (memory_object_offset_t) -1) {
			<span class="enscript-comment">/* no more compressed pages */</span>
			<span class="enscript-keyword">break</span>;
		}
		backing_offset = (backing_pager_offset -
				  backing_object-&gt;paging_offset);

		new_offset = backing_offset - object-&gt;vo_shadow_offset;

		<span class="enscript-keyword">if</span> (new_offset &gt;= object-&gt;vo_size) {
			<span class="enscript-comment">/* we're out of the scope of &quot;object&quot;: done */</span>
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> ((vm_page_lookup(object, new_offset) != VM_PAGE_NULL) ||
		    (vm_compressor_pager_state_get(object-&gt;pager,
						   (new_offset +
						    object-&gt;paging_offset)) ==
		     VM_EXTERNAL_STATE_EXISTS)) {
			<span class="enscript-comment">/*
			 * This page already exists in object, resident or
			 * compressed.
			 * We don't need this compressed page in backing_object
			 * and it will be reclaimed when we release
			 * backing_object.
			 */</span>
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * backing_object has this page in the VM compressor and
		 * we need to transfer it to object.
		 */</span>
		vm_counters.do_collapse_compressor_pages++;
		vm_compressor_pager_transfer(
			<span class="enscript-comment">/* destination: */</span>
			object-&gt;pager,
			(new_offset + object-&gt;paging_offset),
			<span class="enscript-comment">/* source: */</span>
			backing_object-&gt;pager,
			(backing_offset + backing_object-&gt;paging_offset));
	}
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_do_collapse
 *	Purpose:
 *		Collapse an object with the object backing it.
 *		Pages in the backing object are moved into the
 *		parent, and the backing object is deallocated.
 *	Conditions:
 *		Both objects and the cache are locked; the page
 *		queues are unlocked.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_do_collapse</span>(
	vm_object_t object,
	vm_object_t backing_object)
{
	vm_page_t p, pp;
	vm_object_offset_t new_offset, backing_offset;
	vm_object_size_t size;

	vm_object_lock_assert_exclusive(object);
	vm_object_lock_assert_exclusive(backing_object);

	assert(object-&gt;purgable == VM_PURGABLE_DENY);
	assert(backing_object-&gt;purgable == VM_PURGABLE_DENY);

	backing_offset = object-&gt;vo_shadow_offset;
	size = object-&gt;vo_size;

	<span class="enscript-comment">/*
	 *	Move all in-memory pages from backing_object
	 *	to the parent.  Pages that have been paged out
	 *	will be overwritten by any of the parent's
	 *	pages that shadow them.
	 */</span>
	
	<span class="enscript-keyword">while</span> (!queue_empty(&amp;backing_object-&gt;memq)) {
		
		p = (vm_page_t) queue_first(&amp;backing_object-&gt;memq);
		
		new_offset = (p-&gt;offset - backing_offset);
		
		assert(!p-&gt;busy || p-&gt;absent);

		<span class="enscript-comment">/*
		 *	If the parent has a page here, or if
		 *	this page falls outside the parent,
		 *	dispose of it.
		 *
		 *	Otherwise, move it as planned.
		 */</span>
		
		<span class="enscript-keyword">if</span> (p-&gt;offset &lt; backing_offset || new_offset &gt;= size) {
			VM_PAGE_FREE(p);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * ENCRYPTED SWAP:
			 * The encryption key includes the &quot;pager&quot; and the
			 * &quot;paging_offset&quot;.  These will not change during the 
			 * object collapse, so we can just move an encrypted
			 * page from one object to the other in this case.
			 * We can't decrypt the page here, since we can't drop
			 * the object lock.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;encrypted) {
				vm_object_collapse_encrypted++;
			}
			pp = vm_page_lookup(object, new_offset);
			<span class="enscript-keyword">if</span> (pp == VM_PAGE_NULL) {

				<span class="enscript-keyword">if</span> (VM_COMPRESSOR_PAGER_STATE_GET(object,
								  new_offset)
				    == VM_EXTERNAL_STATE_EXISTS) {
					<span class="enscript-comment">/*
					 * Parent object has this page
					 * in the VM compressor.
					 * Throw away the backing
					 * object's page.
					 */</span>
					VM_PAGE_FREE(p);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 *	Parent now has no page.
					 *	Move the backing object's page
					 * 	up.
					 */</span>
					vm_page_rename(p, object, new_offset,
						       TRUE);
				}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pp-&gt;absent) {

				<span class="enscript-comment">/*
				 *	Parent has an absent page...
				 *	it's not being paged in, so
				 *	it must really be missing from
				 *	the parent.
				 *
				 *	Throw out the absent page...
				 *	any faults looking for that
				 *	page will restart with the new
				 *	one.
				 */</span>

				VM_PAGE_FREE(pp);
				vm_page_rename(p, object, new_offset, TRUE);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
			} <span class="enscript-keyword">else</span> {
				assert(! pp-&gt;absent);

				<span class="enscript-comment">/*
				 *	Parent object has a real page.
				 *	Throw away the backing object's
				 *	page.
				 */</span>
				VM_PAGE_FREE(p);
			}
		}
	}

	<span class="enscript-keyword">if</span> (vm_object_collapse_compressor_allowed &amp;&amp;
	    object-&gt;pager != MEMORY_OBJECT_NULL &amp;&amp;
	    backing_object-&gt;pager != MEMORY_OBJECT_NULL) {

		<span class="enscript-comment">/* move compressed pages from backing_object to object */</span>
		vm_object_do_collapse_compressor(object, backing_object);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (backing_object-&gt;pager != MEMORY_OBJECT_NULL) {
		vm_object_hash_entry_t	entry;

#<span class="enscript-reference">if</span>	!<span class="enscript-variable-name">MACH_PAGEMAP</span>
		assert((!object-&gt;pager_created &amp;&amp;
			(object-&gt;pager == MEMORY_OBJECT_NULL)) ||
		       (!backing_object-&gt;pager_created &amp;&amp;
			(backing_object-&gt;pager == MEMORY_OBJECT_NULL)));
#<span class="enscript-reference">else</span> 
		assert(!object-&gt;pager_created &amp;&amp;
		       object-&gt;pager == MEMORY_OBJECT_NULL);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !MACH_PAGEMAP */</span>

		<span class="enscript-comment">/*
		 *	Move the pager from backing_object to object.
		 *
		 *	XXX We're only using part of the paging space
		 *	for keeps now... we ought to discard the
		 *	unused portion.
		 */</span>

		assert(!object-&gt;paging_in_progress);
		assert(!object-&gt;activity_in_progress);
		assert(!object-&gt;pager_created);
		assert(object-&gt;pager == NULL);
		object-&gt;pager = backing_object-&gt;pager;

		<span class="enscript-keyword">if</span> (backing_object-&gt;hashed) {
			lck_mtx_t	*lck;

			lck = vm_object_hash_lock_spin(backing_object-&gt;pager);
			entry = vm_object_hash_lookup(object-&gt;pager, FALSE);
			assert(entry != VM_OBJECT_HASH_ENTRY_NULL);
			entry-&gt;object = object;
			vm_object_hash_unlock(lck);

			object-&gt;hashed = TRUE;
		}
		object-&gt;pager_created = backing_object-&gt;pager_created;
		object-&gt;pager_control = backing_object-&gt;pager_control;
		object-&gt;pager_ready = backing_object-&gt;pager_ready;
		object-&gt;pager_initialized = backing_object-&gt;pager_initialized;
		object-&gt;paging_offset =
		    backing_object-&gt;paging_offset + backing_offset;
		<span class="enscript-keyword">if</span> (object-&gt;pager_control != MEMORY_OBJECT_CONTROL_NULL) {
			memory_object_control_collapse(object-&gt;pager_control,
						       object);
		}
		<span class="enscript-comment">/* the backing_object has lost its pager: reset all fields */</span>
		backing_object-&gt;pager_created = FALSE;
		backing_object-&gt;pager_control = NULL;
		backing_object-&gt;pager_ready = FALSE;
		backing_object-&gt;paging_offset = 0;
		backing_object-&gt;pager = NULL;
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	<span class="enscript-comment">/*
	 *	If the shadow offset is 0, the use the existence map from
	 *	the backing object if there is one. If the shadow offset is
	 *	not zero, toss it.
	 *
	 *	XXX - If the shadow offset is not 0 then a bit copy is needed
	 *	if the map is to be salvaged.  For now, we just just toss the
	 *	old map, giving the collapsed object no map. This means that
	 *	the pager is invoked for zero fill pages.  If analysis shows
	 *	that this happens frequently and is a performance hit, then
	 *	this code should be fixed to salvage the map.
	 */</span>
	assert(object-&gt;existence_map == VM_EXTERNAL_NULL);
	<span class="enscript-keyword">if</span> (backing_offset || (size != backing_object-&gt;vo_size)) {
		vm_external_discarded++;
		vm_external_destroy(backing_object-&gt;existence_map,
			backing_object-&gt;vo_size);
	}
	<span class="enscript-keyword">else</span> {
		vm_external_collapsed++;
		object-&gt;existence_map = backing_object-&gt;existence_map;
	}
	backing_object-&gt;existence_map = VM_EXTERNAL_NULL;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>

	<span class="enscript-comment">/*
	 *	Object now shadows whatever backing_object did.
	 *	Note that the reference to backing_object-&gt;shadow
	 *	moves from within backing_object to within object.
	 */</span>
	
	assert(!object-&gt;phys_contiguous);
	assert(!backing_object-&gt;phys_contiguous);
	object-&gt;shadow = backing_object-&gt;shadow;
	<span class="enscript-keyword">if</span> (object-&gt;shadow) {
		object-&gt;vo_shadow_offset += backing_object-&gt;vo_shadow_offset;
		<span class="enscript-comment">/* &quot;backing_object&quot; gave its shadow to &quot;object&quot; */</span>
		backing_object-&gt;shadow = VM_OBJECT_NULL;
		backing_object-&gt;vo_shadow_offset = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* no shadow, therefore no shadow offset... */</span>
		object-&gt;vo_shadow_offset = 0;
	}
	assert((object-&gt;shadow == VM_OBJECT_NULL) ||
	       (object-&gt;shadow-&gt;copy != backing_object));

	<span class="enscript-comment">/*
	 *	Discard backing_object.
	 *
	 *	Since the backing object has no pages, no
	 *	pager left, and no object references within it,
	 *	all that is necessary is to dispose of it.
	 */</span>
	object_collapses++;
	
	assert(backing_object-&gt;ref_count == 1);
	assert(backing_object-&gt;resident_page_count == 0);
	assert(backing_object-&gt;paging_in_progress == 0);
	assert(backing_object-&gt;activity_in_progress == 0);
	assert(backing_object-&gt;shadow == VM_OBJECT_NULL);
	assert(backing_object-&gt;vo_shadow_offset == 0);

	<span class="enscript-keyword">if</span> (backing_object-&gt;pager != MEMORY_OBJECT_NULL) {
		<span class="enscript-comment">/* ... unless it has a pager; need to terminate pager too */</span>
		vm_counters.do_collapse_terminate++;
		<span class="enscript-keyword">if</span> (vm_object_terminate(backing_object) != KERN_SUCCESS) {
			vm_counters.do_collapse_terminate_failure++;
		}
		<span class="enscript-keyword">return</span>;
	}

	assert(backing_object-&gt;pager == NULL);

	backing_object-&gt;alive = FALSE;
	vm_object_unlock(backing_object);

	XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;vm_object_collapse, collapsed 0x%X\n&quot;</span>,
		backing_object, 0,0,0,0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING</span>
	<span class="enscript-keyword">if</span> (vm_object_tracking_inited) {
		btlog_remove_entries_for_element(vm_object_tracking_btlog,
						 backing_object);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJECT_TRACKING */</span>

	vm_object_lock_destroy(backing_object);

	zfree(vm_object_zone, backing_object);
	
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_do_bypass</span>(
	vm_object_t object,
	vm_object_t backing_object)
{
	<span class="enscript-comment">/*
	 *	Make the parent shadow the next object
	 *	in the chain.
	 */</span>
	
	vm_object_lock_assert_exclusive(object);
	vm_object_lock_assert_exclusive(backing_object);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
	<span class="enscript-comment">/*
	 *	Do object reference in-line to 
	 *	conditionally increment shadow's
	 *	residence count.  If object is not
	 *	resident, leave residence count
	 *	on shadow alone.
	 */</span>
	<span class="enscript-keyword">if</span> (backing_object-&gt;shadow != VM_OBJECT_NULL) {
		vm_object_lock(backing_object-&gt;shadow);
		vm_object_lock_assert_exclusive(backing_object-&gt;shadow);
		backing_object-&gt;shadow-&gt;ref_count++;
		<span class="enscript-keyword">if</span> (object-&gt;res_count != 0)
			vm_object_res_reference(backing_object-&gt;shadow);
		vm_object_unlock(backing_object-&gt;shadow);
	}
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>
	vm_object_reference(backing_object-&gt;shadow);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

	assert(!object-&gt;phys_contiguous);
	assert(!backing_object-&gt;phys_contiguous);
	object-&gt;shadow = backing_object-&gt;shadow;
	<span class="enscript-keyword">if</span> (object-&gt;shadow) {
		object-&gt;vo_shadow_offset += backing_object-&gt;vo_shadow_offset;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* no shadow, therefore no shadow offset... */</span>
		object-&gt;vo_shadow_offset = 0;
	}
	
	<span class="enscript-comment">/*
	 *	Backing object might have had a copy pointer
	 *	to us.  If it did, clear it. 
	 */</span>
	<span class="enscript-keyword">if</span> (backing_object-&gt;copy == object) {
		backing_object-&gt;copy = VM_OBJECT_NULL;
	}
	
	<span class="enscript-comment">/*
	 *	Drop the reference count on backing_object.
#if	TASK_SWAPPER
	 *	Since its ref_count was at least 2, it
	 *	will not vanish; so we don't need to call
	 *	vm_object_deallocate.
	 *	[with a caveat for &quot;named&quot; objects]
	 * 
	 *	The res_count on the backing object is
	 *	conditionally decremented.  It's possible
	 *	(via vm_pageout_scan) to get here with
	 *	a &quot;swapped&quot; object, which has a 0 res_count,
	 *	in which case, the backing object res_count
	 *	is already down by one.
#else
	 *	Don't call vm_object_deallocate unless
	 *	ref_count drops to zero.
	 *
	 *	The ref_count can drop to zero here if the
	 *	backing object could be bypassed but not
	 *	collapsed, such as when the backing object
	 *	is temporary and cachable.
#endif
	 */</span>
	<span class="enscript-keyword">if</span> (backing_object-&gt;ref_count &gt; 2 ||
	    (!backing_object-&gt;named &amp;&amp; backing_object-&gt;ref_count &gt; 1)) {
		vm_object_lock_assert_exclusive(backing_object);
		backing_object-&gt;ref_count--;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
		<span class="enscript-keyword">if</span> (object-&gt;res_count != 0)
			vm_object_res_deallocate(backing_object);
		assert(backing_object-&gt;ref_count &gt; 0);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>
		vm_object_unlock(backing_object);
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 *	Drop locks so that we can deallocate
		 *	the backing object.
		 */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
		<span class="enscript-keyword">if</span> (object-&gt;res_count == 0) {
			<span class="enscript-comment">/* XXX get a reference for the deallocate below */</span>
			vm_object_res_reference(backing_object);
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>
		<span class="enscript-comment">/*
		 * vm_object_collapse (the caller of this function) is
		 * now called from contexts that may not guarantee that a
		 * valid reference is held on the object... w/o a valid
		 * reference, it is unsafe and unwise (you will definitely
		 * regret it) to unlock the object and then retake the lock
		 * since the object may be terminated and recycled in between.
		 * The &quot;activity_in_progress&quot; reference will keep the object
		 * 'stable'.
		 */</span>
		vm_object_activity_begin(object);
		vm_object_unlock(object);

		vm_object_unlock(backing_object);
		vm_object_deallocate(backing_object);

		<span class="enscript-comment">/*
		 *	Relock object. We don't have to reverify
		 *	its state since vm_object_collapse will
		 *	do that for us as it starts at the
		 *	top of its loop.
		 */</span>

		vm_object_lock(object);
		vm_object_activity_end(object);
	}
	
	object_bypasses++;
}

		
<span class="enscript-comment">/*
 *	vm_object_collapse:
 *
 *	Perform an object collapse or an object bypass if appropriate.
 *	The real work of collapsing and bypassing is performed in
 *	the routines vm_object_do_collapse and vm_object_do_bypass.
 *
 *	Requires that the object be locked and the page queues be unlocked.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_collapse_calls = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_collapse_objects = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_collapse_do_collapse = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_object_collapse_do_bypass = 0;

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_collapse</span>(
	<span class="enscript-type">register</span> vm_object_t			object,
	<span class="enscript-type">register</span> vm_object_offset_t		hint_offset,
	boolean_t				can_bypass)
{
	<span class="enscript-type">register</span> vm_object_t			backing_object;
	<span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			rcount;
	<span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			size;
	vm_object_t				original_object;
	<span class="enscript-type">int</span>					object_lock_type;
	<span class="enscript-type">int</span>					backing_object_lock_type;

	vm_object_collapse_calls++;

	<span class="enscript-keyword">if</span> (! vm_object_collapse_allowed &amp;&amp;
	    ! (can_bypass &amp;&amp; vm_object_bypass_allowed)) {
		<span class="enscript-keyword">return</span>;
	}

	XPR(XPR_VM_OBJECT, <span class="enscript-string">&quot;vm_object_collapse, obj 0x%X\n&quot;</span>, 
		object, 0,0,0,0);

	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span>;

	original_object = object;

	<span class="enscript-comment">/*
	 * The top object was locked &quot;exclusive&quot; by the caller.
	 * In the first pass, to determine if we can collapse the shadow chain,
	 * take a &quot;shared&quot; lock on the shadow objects.  If we can collapse,
	 * we'll have to go down the chain again with exclusive locks.
	 */</span>
	object_lock_type = OBJECT_LOCK_EXCLUSIVE;
	backing_object_lock_type = OBJECT_LOCK_SHARED;

<span class="enscript-reference">retry</span>:
	object = original_object;
	vm_object_lock_assert_exclusive(object);

	<span class="enscript-keyword">while</span> (TRUE) {
		vm_object_collapse_objects++;
		<span class="enscript-comment">/*
		 *	Verify that the conditions are right for either
		 *	collapse or bypass:
		 */</span>

		<span class="enscript-comment">/*
		 *	There is a backing object, and
		 */</span>
	
		backing_object = object-&gt;shadow;
		<span class="enscript-keyword">if</span> (backing_object == VM_OBJECT_NULL) {
			<span class="enscript-keyword">if</span> (object != original_object) {
				vm_object_unlock(object);
			}
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">if</span> (backing_object_lock_type == OBJECT_LOCK_SHARED) {
			vm_object_lock_shared(backing_object);
		} <span class="enscript-keyword">else</span> {
			vm_object_lock(backing_object);
		}

		<span class="enscript-comment">/*
		 *	No pages in the object are currently
		 *	being paged out, and
		 */</span>
		<span class="enscript-keyword">if</span> (object-&gt;paging_in_progress != 0 ||
		    object-&gt;activity_in_progress != 0) {
			<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
			<span class="enscript-keyword">if</span> (object != original_object) {
				vm_object_unlock(object);
			}
			object = backing_object;
			object_lock_type = backing_object_lock_type;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 *	...
		 *		The backing object is not read_only,
		 *		and no pages in the backing object are
		 *		currently being paged out.
		 *		The backing object is internal.
		 *
		 */</span>
	
		<span class="enscript-keyword">if</span> (!backing_object-&gt;internal ||
		    backing_object-&gt;paging_in_progress != 0 ||
		    backing_object-&gt;activity_in_progress != 0) {
			<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
			<span class="enscript-keyword">if</span> (object != original_object) {
				vm_object_unlock(object);
			}
			object = backing_object;
			object_lock_type = backing_object_lock_type;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * Purgeable objects are not supposed to engage in
		 * copy-on-write activities, so should not have
		 * any shadow objects or be a shadow object to another
		 * object.
		 * Collapsing a purgeable object would require some
		 * updates to the purgeable compressed ledgers.
		 */</span>
		<span class="enscript-keyword">if</span> (object-&gt;purgable != VM_PURGABLE_DENY ||
		    backing_object-&gt;purgable != VM_PURGABLE_DENY) {
			panic(<span class="enscript-string">&quot;vm_object_collapse() attempting to collapse &quot;</span>
			      <span class="enscript-string">&quot;purgeable object: %p(%d) %p(%d)\n&quot;</span>,
			      object, object-&gt;purgable,
			      backing_object, backing_object-&gt;purgable);
			<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
			<span class="enscript-keyword">if</span> (object != original_object) {
				vm_object_unlock(object);
			}
			object = backing_object;
			object_lock_type = backing_object_lock_type;
			<span class="enscript-keyword">continue</span>;
		}
	
		<span class="enscript-comment">/*
		 *	The backing object can't be a copy-object:
		 *	the shadow_offset for the copy-object must stay
		 *	as 0.  Furthermore (for the 'we have all the
		 *	pages' case), if we bypass backing_object and
		 *	just shadow the next object in the chain, old
		 *	pages from that object would then have to be copied
		 *	BOTH into the (former) backing_object and into the
		 *	parent object.
		 */</span>
		<span class="enscript-keyword">if</span> (backing_object-&gt;shadow != VM_OBJECT_NULL &amp;&amp;
		    backing_object-&gt;shadow-&gt;copy == backing_object) {
			<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
			<span class="enscript-keyword">if</span> (object != original_object) {
				vm_object_unlock(object);
			}
			object = backing_object;
			object_lock_type = backing_object_lock_type;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 *	We can now try to either collapse the backing
		 *	object (if the parent is the only reference to
		 *	it) or (perhaps) remove the parent's reference
		 *	to it.
		 *
		 *	If there is exactly one reference to the backing
		 *	object, we may be able to collapse it into the
		 *	parent.
		 *
		 *	If MACH_PAGEMAP is defined:
		 *	The parent must not have a pager created for it,
		 *	since collapsing a backing_object dumps new pages
		 *	into the parent that its pager doesn't know about
		 *	(and the collapse code can't merge the existence
		 *	maps).
		 *	Otherwise:
		 *	As long as one of the objects is still not known
		 *	to the pager, we can collapse them.
		 */</span>
		<span class="enscript-keyword">if</span> (backing_object-&gt;ref_count == 1 &amp;&amp;
		    (vm_object_collapse_compressor_allowed ||
		     !object-&gt;pager_created 
#<span class="enscript-reference">if</span>	!<span class="enscript-variable-name">MACH_PAGEMAP</span>
		     || (!backing_object-&gt;pager_created)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/*!MACH_PAGEMAP */</span>
		    ) &amp;&amp; vm_object_collapse_allowed) {

			<span class="enscript-comment">/*
			 * We need the exclusive lock on the VM objects.
			 */</span>
			<span class="enscript-keyword">if</span> (backing_object_lock_type != OBJECT_LOCK_EXCLUSIVE) {
				<span class="enscript-comment">/*
				 * We have an object and its shadow locked 
				 * &quot;shared&quot;.  We can't just upgrade the locks
				 * to &quot;exclusive&quot;, as some other thread might
				 * also have these objects locked &quot;shared&quot; and
				 * attempt to upgrade one or the other to 
				 * &quot;exclusive&quot;.  The upgrades would block
				 * forever waiting for the other &quot;shared&quot; locks
				 * to get released.
				 * So we have to release the locks and go
				 * down the shadow chain again (since it could
				 * have changed) with &quot;exclusive&quot; locking.
				 */</span>
				vm_object_unlock(backing_object);
				<span class="enscript-keyword">if</span> (object != original_object)
					vm_object_unlock(object);
				object_lock_type = OBJECT_LOCK_EXCLUSIVE;
				backing_object_lock_type = OBJECT_LOCK_EXCLUSIVE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}

			XPR(XPR_VM_OBJECT, 
		   <span class="enscript-string">&quot;vm_object_collapse: %x to %x, pager %x, pager_control %x\n&quot;</span>,
				backing_object, object,
				backing_object-&gt;pager, 
				backing_object-&gt;pager_control, 0);

			<span class="enscript-comment">/*
			 *	Collapse the object with its backing
			 *	object, and try again with the object's
			 *	new backing object.
			 */</span>

			vm_object_do_collapse(object, backing_object);
			vm_object_collapse_do_collapse++;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 *	Collapsing the backing object was not possible
		 *	or permitted, so let's try bypassing it.
		 */</span>

		<span class="enscript-keyword">if</span> (! (can_bypass &amp;&amp; vm_object_bypass_allowed)) {
			<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
			<span class="enscript-keyword">if</span> (object != original_object) {
				vm_object_unlock(object);
			}
			object = backing_object;
			object_lock_type = backing_object_lock_type;
			<span class="enscript-keyword">continue</span>;
		}


		<span class="enscript-comment">/*
		 *	If the object doesn't have all its pages present,
		 *	we have to make sure no pages in the backing object
		 *	&quot;show through&quot; before bypassing it.
		 */</span>
		size = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)atop(object-&gt;vo_size);
		rcount = object-&gt;resident_page_count;

		<span class="enscript-keyword">if</span> (rcount != size) {
			vm_object_offset_t	offset;
			vm_object_offset_t	backing_offset;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     	backing_rcount;

			<span class="enscript-comment">/*
			 *	If the backing object has a pager but no pagemap,
			 *	then we cannot bypass it, because we don't know
			 *	what pages it has.
			 */</span>
			<span class="enscript-keyword">if</span> (backing_object-&gt;pager_created
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
			    &amp;&amp; (backing_object-&gt;existence_map == VM_EXTERNAL_NULL)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
				) {
				<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
				<span class="enscript-keyword">if</span> (object != original_object) {
					vm_object_unlock(object);
				}
				object = backing_object;
				object_lock_type = backing_object_lock_type;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 *	If the object has a pager but no pagemap,
			 *	then we cannot bypass it, because we don't know
			 *	what pages it has.
			 */</span>
			<span class="enscript-keyword">if</span> (object-&gt;pager_created
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
			    &amp;&amp; (object-&gt;existence_map == VM_EXTERNAL_NULL)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
				) {
				<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
				<span class="enscript-keyword">if</span> (object != original_object) {
					vm_object_unlock(object);
				}
				object = backing_object;
				object_lock_type = backing_object_lock_type;
				<span class="enscript-keyword">continue</span>;
			}

			backing_offset = object-&gt;vo_shadow_offset;
			backing_rcount = backing_object-&gt;resident_page_count;

			<span class="enscript-keyword">if</span> ( (<span class="enscript-type">int</span>)backing_rcount - (<span class="enscript-type">int</span>)(atop(backing_object-&gt;vo_size) - size) &gt; (<span class="enscript-type">int</span>)rcount) {
                                <span class="enscript-comment">/*
				 * we have enough pages in the backing object to guarantee that
				 * at least 1 of them must be 'uncovered' by a resident page
				 * in the object we're evaluating, so move on and
				 * try to collapse the rest of the shadow chain
				 */</span>
				<span class="enscript-keyword">if</span> (object != original_object) {
					vm_object_unlock(object);
				}
				object = backing_object;
				object_lock_type = backing_object_lock_type;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 *	If all of the pages in the backing object are
			 *	shadowed by the parent object, the parent
			 *	object no longer has to shadow the backing
			 *	object; it can shadow the next one in the
			 *	chain.
			 *
			 *	If the backing object has existence info,
			 *	we must check examine its existence info
			 *	as well.
			 *
			 */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">EXISTS_IN_OBJECT</span>(obj, off, rc) \
	((vm_external_state_get((obj)-&gt;existence_map,	\
				(vm_offset_t)(off))	\
	  == VM_EXTERNAL_STATE_EXISTS) ||		\
	 (VM_COMPRESSOR_PAGER_STATE_GET((obj), (off))	\
	  == VM_EXTERNAL_STATE_EXISTS) ||		\
	 ((rc) &amp;&amp; vm_page_lookup((obj), (off)) != VM_PAGE_NULL &amp;&amp; (rc)--))
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">EXISTS_IN_OBJECT</span>(obj, off, rc)			\
	((VM_COMPRESSOR_PAGER_STATE_GET((obj), (off))	\
	  == VM_EXTERNAL_STATE_EXISTS) ||		\
	 ((rc) &amp;&amp; vm_page_lookup((obj), (off)) != VM_PAGE_NULL &amp;&amp; (rc)--))
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>

			<span class="enscript-comment">/*
			 * Check the hint location first
			 * (since it is often the quickest way out of here).
			 */</span>
			<span class="enscript-keyword">if</span> (object-&gt;cow_hint != ~(vm_offset_t)0)
				hint_offset = (vm_object_offset_t)object-&gt;cow_hint;
			<span class="enscript-keyword">else</span>
				hint_offset = (hint_offset &gt; 8 * PAGE_SIZE_64) ?
				              (hint_offset - 8 * PAGE_SIZE_64) : 0;

			<span class="enscript-keyword">if</span> (EXISTS_IN_OBJECT(backing_object, hint_offset +
			                     backing_offset, backing_rcount) &amp;&amp;
			    !EXISTS_IN_OBJECT(object, hint_offset, rcount)) {
				<span class="enscript-comment">/* dependency right at the hint */</span>
				object-&gt;cow_hint = (vm_offset_t) hint_offset; <span class="enscript-comment">/* atomic */</span>
				<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
				<span class="enscript-keyword">if</span> (object != original_object) {
					vm_object_unlock(object);
				}
				object = backing_object;
				object_lock_type = backing_object_lock_type;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * If the object's window onto the backing_object
			 * is large compared to the number of resident
			 * pages in the backing object, it makes sense to
			 * walk the backing_object's resident pages first.
			 *
			 * NOTE: Pages may be in both the existence map and/or
                         * resident, so if we don't find a dependency while
			 * walking the backing object's resident page list
			 * directly, and there is an existence map, we'll have
			 * to run the offset based 2nd pass.  Because we may
			 * have to run both passes, we need to be careful
			 * not to decrement 'rcount' in the 1st pass
			 */</span>
			<span class="enscript-keyword">if</span> (backing_rcount &amp;&amp; backing_rcount &lt; (size / 8)) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rc = rcount;
				vm_page_t p;

				backing_rcount = backing_object-&gt;resident_page_count;
				p = (vm_page_t)queue_first(&amp;backing_object-&gt;memq);
				<span class="enscript-keyword">do</span> {
					offset = (p-&gt;offset - backing_offset);

					<span class="enscript-keyword">if</span> (offset &lt; object-&gt;vo_size &amp;&amp;
					    offset != hint_offset &amp;&amp;
					    !EXISTS_IN_OBJECT(object, offset, rc)) {
						<span class="enscript-comment">/* found a dependency */</span>
						object-&gt;cow_hint = (vm_offset_t) offset; <span class="enscript-comment">/* atomic */</span>
						
						<span class="enscript-keyword">break</span>;
					}
					p = (vm_page_t) queue_next(&amp;p-&gt;listq);

				} <span class="enscript-keyword">while</span> (--backing_rcount);
				<span class="enscript-keyword">if</span> (backing_rcount != 0 ) {
					<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
					<span class="enscript-keyword">if</span> (object != original_object) {
						vm_object_unlock(object);
					}
					object = backing_object;
					object_lock_type = backing_object_lock_type;
					<span class="enscript-keyword">continue</span>;
				}
			}

			<span class="enscript-comment">/*
			 * Walk through the offsets looking for pages in the
			 * backing object that show through to the object.
			 */</span>
			<span class="enscript-keyword">if</span> (backing_rcount
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
			    || backing_object-&gt;existence_map
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
				) {
				offset = hint_offset;
				
				<span class="enscript-keyword">while</span>((offset =
				      (offset + PAGE_SIZE_64 &lt; object-&gt;vo_size) ?
				      (offset + PAGE_SIZE_64) : 0) != hint_offset) {

					<span class="enscript-keyword">if</span> (EXISTS_IN_OBJECT(backing_object, offset +
				            backing_offset, backing_rcount) &amp;&amp;
					    !EXISTS_IN_OBJECT(object, offset, rcount)) {
						<span class="enscript-comment">/* found a dependency */</span>
						object-&gt;cow_hint = (vm_offset_t) offset; <span class="enscript-comment">/* atomic */</span>
						<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-keyword">if</span> (offset != hint_offset) {
					<span class="enscript-comment">/* try and collapse the rest of the shadow chain */</span>
					<span class="enscript-keyword">if</span> (object != original_object) {
						vm_object_unlock(object);
					}
					object = backing_object;
					object_lock_type = backing_object_lock_type;
					<span class="enscript-keyword">continue</span>;
				}
			}
		}

		<span class="enscript-comment">/*
		 * We need &quot;exclusive&quot; locks on the 2 VM objects.
		 */</span>
		<span class="enscript-keyword">if</span> (backing_object_lock_type != OBJECT_LOCK_EXCLUSIVE) {
			vm_object_unlock(backing_object);
			<span class="enscript-keyword">if</span> (object != original_object)
				vm_object_unlock(object);
			object_lock_type = OBJECT_LOCK_EXCLUSIVE;
			backing_object_lock_type = OBJECT_LOCK_EXCLUSIVE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		<span class="enscript-comment">/* reset the offset hint for any objects deeper in the chain */</span>
		object-&gt;cow_hint = (vm_offset_t)0;

		<span class="enscript-comment">/*
		 *	All interesting pages in the backing object
		 *	already live in the parent or its pager.
		 *	Thus we can bypass the backing object.
		 */</span>

		vm_object_do_bypass(object, backing_object);
		vm_object_collapse_do_bypass++;

		<span class="enscript-comment">/*
		 *	Try again with this object's new backing object.
		 */</span>

		<span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">/* NOT REACHED */</span>
	<span class="enscript-comment">/*
	if (object != original_object) {
		vm_object_unlock(object);
	}
	*/</span>
}

<span class="enscript-comment">/*
 *	Routine:	vm_object_page_remove: [internal]
 *	Purpose:
 *		Removes all physical pages in the specified
 *		object range from the object's list of pages.
 *
 *	In/out conditions:
 *		The object must be locked.
 *		The object must not have paging_in_progress, usually
 *		guaranteed by not having a pager.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_object_page_remove_lookup = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_object_page_remove_iterate = 0;

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_page_remove</span>(
	<span class="enscript-type">register</span> vm_object_t		object,
	<span class="enscript-type">register</span> vm_object_offset_t	start,
	<span class="enscript-type">register</span> vm_object_offset_t	end)
{
	<span class="enscript-type">register</span> vm_page_t	p, next;

	<span class="enscript-comment">/*
	 *	One and two page removals are most popular.
	 *	The factor of 16 here is somewhat arbitrary.
	 *	It balances vm_object_lookup vs iteration.
	 */</span>

	<span class="enscript-keyword">if</span> (atop_64(end - start) &lt; (<span class="enscript-type">unsigned</span>)object-&gt;resident_page_count/16) {
		vm_object_page_remove_lookup++;

		<span class="enscript-keyword">for</span> (; start &lt; end; start += PAGE_SIZE_64) {
			p = vm_page_lookup(object, start);
			<span class="enscript-keyword">if</span> (p != VM_PAGE_NULL) {
				assert(!p-&gt;cleaning &amp;&amp; !p-&gt;pageout &amp;&amp; !p-&gt;laundry);
				<span class="enscript-keyword">if</span> (!p-&gt;fictitious &amp;&amp; p-&gt;pmapped)
				        pmap_disconnect(p-&gt;phys_page);
				VM_PAGE_FREE(p);
			}
		}
	} <span class="enscript-keyword">else</span> {
		vm_object_page_remove_iterate++;

		p = (vm_page_t) queue_first(&amp;object-&gt;memq);
		<span class="enscript-keyword">while</span> (!queue_end(&amp;object-&gt;memq, (queue_entry_t) p)) {
			next = (vm_page_t) queue_next(&amp;p-&gt;listq);
			<span class="enscript-keyword">if</span> ((start &lt;= p-&gt;offset) &amp;&amp; (p-&gt;offset &lt; end)) {
				assert(!p-&gt;cleaning &amp;&amp; !p-&gt;pageout &amp;&amp; !p-&gt;laundry);
				<span class="enscript-keyword">if</span> (!p-&gt;fictitious &amp;&amp; p-&gt;pmapped)
				        pmap_disconnect(p-&gt;phys_page);
				VM_PAGE_FREE(p);
			}
			p = next;
		}
	}
}


<span class="enscript-comment">/*
 *	Routine:	vm_object_coalesce
 *	Function:	Coalesces two objects backing up adjoining
 *			regions of memory into a single object.
 *
 *	returns TRUE if objects were combined.
 *
 *	NOTE:	Only works at the moment if the second object is NULL -
 *		if it's not, which object do we lock first?
 *
 *	Parameters:
 *		prev_object	First object to coalesce
 *		prev_offset	Offset into prev_object
 *		next_object	Second object into coalesce
 *		next_offset	Offset into next_object
 *
 *		prev_size	Size of reference to prev_object
 *		next_size	Size of reference to next_object
 *
 *	Conditions:
 *	The object(s) must *not* be locked. The map must be locked
 *	to preserve the reference to the object(s).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> vm_object_coalesce_count = 0;

__private_extern__ boolean_t
<span class="enscript-function-name">vm_object_coalesce</span>(
	<span class="enscript-type">register</span> vm_object_t		prev_object,
	vm_object_t			next_object,
	vm_object_offset_t		prev_offset,
	__unused vm_object_offset_t next_offset,
	vm_object_size_t		prev_size,
	vm_object_size_t		next_size)
{
	vm_object_size_t	newsize;

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">lint</span>
	next_offset++;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* lint */</span>

	<span class="enscript-keyword">if</span> (next_object != VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span>(FALSE);
	}

	<span class="enscript-keyword">if</span> (prev_object == VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span>(TRUE);
	}

	XPR(XPR_VM_OBJECT,
       <span class="enscript-string">&quot;vm_object_coalesce: 0x%X prev_off 0x%X prev_size 0x%X next_size 0x%X\n&quot;</span>,
		prev_object, prev_offset, prev_size, next_size, 0);

	vm_object_lock(prev_object);

	<span class="enscript-comment">/*
	 *	Try to collapse the object first
	 */</span>
	vm_object_collapse(prev_object, prev_offset, TRUE);

	<span class="enscript-comment">/*
	 *	Can't coalesce if pages not mapped to
	 *	prev_entry may be in use any way:
	 *	. more than one reference
	 *	. paged out
	 *	. shadows another object
	 *	. has a copy elsewhere
	 *	. is purgeable
	 *	. paging references (pages might be in page-list)
	 */</span>

	<span class="enscript-keyword">if</span> ((prev_object-&gt;ref_count &gt; 1) ||
	    prev_object-&gt;pager_created ||
	    (prev_object-&gt;shadow != VM_OBJECT_NULL) ||
	    (prev_object-&gt;copy != VM_OBJECT_NULL) ||
	    (prev_object-&gt;true_share != FALSE) ||
	    (prev_object-&gt;purgable != VM_PURGABLE_DENY) ||
	    (prev_object-&gt;paging_in_progress != 0) ||
	    (prev_object-&gt;activity_in_progress != 0)) {
		vm_object_unlock(prev_object);
		<span class="enscript-keyword">return</span>(FALSE);
	}

	vm_object_coalesce_count++;

	<span class="enscript-comment">/*
	 *	Remove any pages that may still be in the object from
	 *	a previous deallocation.
	 */</span>
	vm_object_page_remove(prev_object,
		prev_offset + prev_size,
		prev_offset + prev_size + next_size);

	<span class="enscript-comment">/*
	 *	Extend the object if necessary.
	 */</span>
	newsize = prev_offset + prev_size + next_size;
	<span class="enscript-keyword">if</span> (newsize &gt; prev_object-&gt;vo_size) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
		<span class="enscript-comment">/*
		 *	We cannot extend an object that has existence info,
		 *	since the existence info might then fail to cover
		 *	the entire object.
		 *
		 *	This assertion must be true because the object
		 *	has no pager, and we only create existence info
		 *	for objects with pagers.
		 */</span>
		assert(prev_object-&gt;existence_map == VM_EXTERNAL_NULL);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
		prev_object-&gt;vo_size = newsize;
	}

	vm_object_unlock(prev_object);
	<span class="enscript-keyword">return</span>(TRUE);
}

kern_return_t
<span class="enscript-function-name">vm_object_populate_with_private</span>(
		vm_object_t		object,
		vm_object_offset_t	offset,
		ppnum_t			phys_page,
		vm_size_t		size)
{
	ppnum_t			base_page;
	vm_object_offset_t	base_offset;


	<span class="enscript-keyword">if</span> (!object-&gt;private)
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	base_page = phys_page;

	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (!object-&gt;phys_contiguous) {
		vm_page_t	m;

		<span class="enscript-keyword">if</span> ((base_offset = trunc_page_64(offset)) != offset) {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
		base_offset += object-&gt;paging_offset;

		<span class="enscript-keyword">while</span> (size) {
			m = vm_page_lookup(object, base_offset);

			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
				<span class="enscript-keyword">if</span> (m-&gt;fictitious) {
					<span class="enscript-keyword">if</span> (m-&gt;phys_page != vm_page_guard_addr) {

						vm_page_lockspin_queues();
						m-&gt;private = TRUE;
						vm_page_unlock_queues();

						m-&gt;fictitious = FALSE;
						m-&gt;phys_page = base_page;
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;phys_page != base_page) {

				        <span class="enscript-keyword">if</span> ( !m-&gt;private) {
						<span class="enscript-comment">/*
						 * we'd leak a real page... that can't be right
						 */</span>
						panic(<span class="enscript-string">&quot;vm_object_populate_with_private - %p not private&quot;</span>, m);
					}
					<span class="enscript-keyword">if</span> (m-&gt;pmapped) {
					        <span class="enscript-comment">/*
						 * pmap call to clear old mapping
						 */</span>
					        pmap_disconnect(m-&gt;phys_page);
					}
					m-&gt;phys_page = base_page;
				}
				<span class="enscript-keyword">if</span> (m-&gt;encrypted) {
					<span class="enscript-comment">/*
					 * we should never see this on a ficticious or private page
					 */</span>
					panic(<span class="enscript-string">&quot;vm_object_populate_with_private - %p encrypted&quot;</span>, m);
				}

			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">while</span> ((m = vm_page_grab_fictitious()) == VM_PAGE_NULL)
                			vm_page_more_fictitious();	

				<span class="enscript-comment">/*
				 * private normally requires lock_queues but since we
				 * are initializing the page, its not necessary here
				 */</span>
				m-&gt;private = TRUE;
				m-&gt;fictitious = FALSE;
				m-&gt;phys_page = base_page;
				m-&gt;unusual = TRUE;
				m-&gt;busy = FALSE;

	    			vm_page_insert(m, object, base_offset);
			}
			base_page++;									<span class="enscript-comment">/* Go to the next physical page */</span>
			base_offset += PAGE_SIZE;
			size -= PAGE_SIZE;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* NOTE: we should check the original settings here */</span>
		<span class="enscript-comment">/* if we have a size &gt; zero a pmap call should be made */</span>
		<span class="enscript-comment">/* to disable the range */</span>	

		<span class="enscript-comment">/* pmap_? */</span>
		
		<span class="enscript-comment">/* shadows on contiguous memory are not allowed */</span>
		<span class="enscript-comment">/* we therefore can use the offset field */</span>
		object-&gt;vo_shadow_offset = (vm_object_offset_t)phys_page &lt;&lt; PAGE_SHIFT;
		object-&gt;vo_size = size;
	}
	vm_object_unlock(object);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	memory_object_free_from_cache:
 *
 *	Walk the vm_object cache list, removing and freeing vm_objects 
 *	which are backed by the pager identified by the caller, (pager_ops).  
 *	Remove up to &quot;count&quot; objects, if there are that may available
 *	in the cache.
 *
 *	Walk the list at most once, return the number of vm_objects
 *	actually freed.
 */</span>

__private_extern__ kern_return_t
<span class="enscript-function-name">memory_object_free_from_cache</span>(
	__unused host_t		host,
	__unused memory_object_pager_ops_t pager_ops,
	<span class="enscript-type">int</span>		*count)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
	<span class="enscript-type">int</span>	object_released = 0;

	<span class="enscript-type">register</span> vm_object_t object = VM_OBJECT_NULL;
	vm_object_t shadow;

<span class="enscript-comment">/*
	if(host == HOST_NULL)
		return(KERN_INVALID_ARGUMENT);
*/</span>

 <span class="enscript-reference">try_again</span>:
	vm_object_cache_lock();

	queue_iterate(&amp;vm_object_cached_list, object, 
					vm_object_t, cached_list) {
		<span class="enscript-keyword">if</span> (object-&gt;pager &amp;&amp;
		    (pager_ops == object-&gt;pager-&gt;mo_pager_ops)) {
			vm_object_lock(object);
			queue_remove(&amp;vm_object_cached_list, object, 
					vm_object_t, cached_list);
			vm_object_cached_count--;

			vm_object_cache_unlock();
			<span class="enscript-comment">/*
		 	*	Since this object is in the cache, we know
		 	*	that it is initialized and has only a pager's
			*	(implicit) reference. Take a reference to avoid
			*	recursive deallocations.
		 	*/</span>

			assert(object-&gt;pager_initialized);
			assert(object-&gt;ref_count == 0);
			vm_object_lock_assert_exclusive(object);
			object-&gt;ref_count++;

			<span class="enscript-comment">/*
		 	*	Terminate the object.
		 	*	If the object had a shadow, we let 
			*	vm_object_deallocate deallocate it. 
			*	&quot;pageout&quot; objects have a shadow, but
		 	*	maintain a &quot;paging reference&quot; rather 
			*	than a normal reference.
		 	*	(We are careful here to limit recursion.)
		 	*/</span>
			shadow = object-&gt;pageout?VM_OBJECT_NULL:object-&gt;shadow;

			<span class="enscript-keyword">if</span> ((vm_object_terminate(object) == KERN_SUCCESS)
					&amp;&amp; (shadow != VM_OBJECT_NULL)) {
				vm_object_deallocate(shadow);
			}
		
			<span class="enscript-keyword">if</span>(object_released++ == *count)
				<span class="enscript-keyword">return</span> KERN_SUCCESS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
		}
	}
	vm_object_cache_unlock();
	*count  = object_released;
#<span class="enscript-reference">else</span>
	*count = 0;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}



kern_return_t
<span class="enscript-function-name">memory_object_create_named</span>(
	memory_object_t	pager,
	memory_object_offset_t	size,
	memory_object_control_t		*control)
{
	vm_object_t 		object;
	vm_object_hash_entry_t	entry;
	lck_mtx_t		*lck;

	*control = MEMORY_OBJECT_CONTROL_NULL;
	<span class="enscript-keyword">if</span> (pager == MEMORY_OBJECT_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	lck = vm_object_hash_lock_spin(pager);
	entry = vm_object_hash_lookup(pager, FALSE);

	<span class="enscript-keyword">if</span> ((entry != VM_OBJECT_HASH_ENTRY_NULL) &amp;&amp;
			(entry-&gt;object != VM_OBJECT_NULL)) {
		<span class="enscript-keyword">if</span> (entry-&gt;object-&gt;named == TRUE)
			panic(<span class="enscript-string">&quot;memory_object_create_named: caller already holds the right&quot;</span>);	}
	vm_object_hash_unlock(lck);

	<span class="enscript-keyword">if</span> ((object = vm_object_enter(pager, size, FALSE, FALSE, TRUE)) == VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span>(KERN_INVALID_OBJECT);
	}
	
	<span class="enscript-comment">/* wait for object (if any) to be ready */</span>
	<span class="enscript-keyword">if</span> (object != VM_OBJECT_NULL) {
		vm_object_lock(object);
		object-&gt;named = TRUE;
		<span class="enscript-keyword">while</span> (!object-&gt;pager_ready) {
			vm_object_sleep(object,
					VM_OBJECT_EVENT_PAGER_READY,
					THREAD_UNINT);
		}
		*control = object-&gt;pager_control;
		vm_object_unlock(object);
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


<span class="enscript-comment">/*
 *	Routine:	memory_object_recover_named [user interface]
 *	Purpose:
 *		Attempt to recover a named reference for a VM object.
 *		VM will verify that the object has not already started
 *		down the termination path, and if it has, will optionally
 *		wait for that to finish.
 *	Returns:
 *		KERN_SUCCESS - we recovered a named reference on the object
 *		KERN_FAILURE - we could not recover a reference (object dead)
 *		KERN_INVALID_ARGUMENT - bad memory object control
 */</span>
kern_return_t
<span class="enscript-function-name">memory_object_recover_named</span>(
	memory_object_control_t	control,
	boolean_t		wait_on_terminating)
{
	vm_object_t		object;

	object = memory_object_control_to_vm_object(control);
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}
<span class="enscript-reference">restart</span>:
	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (object-&gt;terminating &amp;&amp; wait_on_terminating) {
		vm_object_wait(object, 
			VM_OBJECT_EVENT_PAGING_IN_PROGRESS, 
			THREAD_UNINT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}

	<span class="enscript-keyword">if</span> (!object-&gt;alive) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	<span class="enscript-keyword">if</span> (object-&gt;named == TRUE) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
	<span class="enscript-keyword">if</span> ((object-&gt;ref_count == 0) &amp;&amp; (!object-&gt;terminating)) {
		<span class="enscript-keyword">if</span> (!vm_object_cache_lock_try()) {
			vm_object_unlock(object);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
		queue_remove(&amp;vm_object_cached_list, object,
				     vm_object_t, cached_list);
		vm_object_cached_count--;
		XPR(XPR_VM_OBJECT_CACHE,
		    <span class="enscript-string">&quot;memory_object_recover_named: removing %X, head (%X, %X)\n&quot;</span>,
		    object, 
		    vm_object_cached_list.next,
		    vm_object_cached_list.prev, 0,0);
		
		vm_object_cache_unlock();
	}
#<span class="enscript-reference">endif</span>
	object-&gt;named = TRUE;
	vm_object_lock_assert_exclusive(object);
	object-&gt;ref_count++;
	vm_object_res_reference(object);
	<span class="enscript-keyword">while</span> (!object-&gt;pager_ready) {
		vm_object_sleep(object,
				VM_OBJECT_EVENT_PAGER_READY,
				THREAD_UNINT);
	}
	vm_object_unlock(object);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


<span class="enscript-comment">/*
 *	vm_object_release_name:  
 *
 *	Enforces name semantic on memory_object reference count decrement
 *	This routine should not be called unless the caller holds a name
 *	reference gained through the memory_object_create_named.
 *
 *	If the TERMINATE_IDLE flag is set, the call will return if the
 *	reference count is not 1. i.e. idle with the only remaining reference
 *	being the name.
 *	If the decision is made to proceed the name field flag is set to
 *	false and the reference count is decremented.  If the RESPECT_CACHE
 *	flag is set and the reference count has gone to zero, the 
 *	memory_object is checked to see if it is cacheable otherwise when
 *	the reference count is zero, it is simply terminated.
 */</span>

__private_extern__ kern_return_t
<span class="enscript-function-name">vm_object_release_name</span>(
	vm_object_t	object,
	<span class="enscript-type">int</span>		flags)
{
	vm_object_t	shadow;
	boolean_t	original_object = TRUE;

	<span class="enscript-keyword">while</span> (object != VM_OBJECT_NULL) {

		vm_object_lock(object);

		assert(object-&gt;alive);
		<span class="enscript-keyword">if</span> (original_object)
			assert(object-&gt;named);
		assert(object-&gt;ref_count &gt; 0);

		<span class="enscript-comment">/*
		 *	We have to wait for initialization before
		 *	destroying or caching the object.
		 */</span>

		<span class="enscript-keyword">if</span> (object-&gt;pager_created &amp;&amp; !object-&gt;pager_initialized) {
			assert(!object-&gt;can_persist);
			vm_object_assert_wait(object,
					VM_OBJECT_EVENT_INITIALIZED,
					THREAD_UNINT);
			vm_object_unlock(object);
			thread_block(THREAD_CONTINUE_NULL);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (((object-&gt;ref_count &gt; 1)
			&amp;&amp; (flags &amp; MEMORY_OBJECT_TERMINATE_IDLE))
			|| (object-&gt;terminating)) {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (flags &amp; MEMORY_OBJECT_RELEASE_NO_OP) {
				vm_object_unlock(object);
				<span class="enscript-keyword">return</span> KERN_SUCCESS;
			}
		}
		
		<span class="enscript-keyword">if</span> ((flags &amp; MEMORY_OBJECT_RESPECT_CACHE) &amp;&amp;
					(object-&gt;ref_count == 1)) {
			<span class="enscript-keyword">if</span> (original_object)
				object-&gt;named = FALSE;
			vm_object_unlock(object);
			<span class="enscript-comment">/* let vm_object_deallocate push this thing into */</span>
			<span class="enscript-comment">/* the cache, if that it is where it is bound */</span>
			vm_object_deallocate(object);
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}
		VM_OBJ_RES_DECR(object);
		shadow = object-&gt;pageout?VM_OBJECT_NULL:object-&gt;shadow;

		<span class="enscript-keyword">if</span> (object-&gt;ref_count == 1) {
			<span class="enscript-keyword">if</span> (vm_object_terminate(object) != KERN_SUCCESS) {
				<span class="enscript-keyword">if</span> (original_object) {
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">return</span> KERN_SUCCESS;
				}
			}
			<span class="enscript-keyword">if</span> (shadow != VM_OBJECT_NULL) {
				original_object = FALSE;
				object = shadow;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		} <span class="enscript-keyword">else</span> {
			vm_object_lock_assert_exclusive(object);
			object-&gt;ref_count--;
			assert(object-&gt;ref_count &gt; 0);
			<span class="enscript-keyword">if</span>(original_object)
				object-&gt;named = FALSE;
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}
	}
	<span class="enscript-comment">/*NOTREACHED*/</span>
	assert(0);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}


__private_extern__ kern_return_t
<span class="enscript-function-name">vm_object_lock_request</span>(
	vm_object_t			object,
	vm_object_offset_t		offset,
	vm_object_size_t		size,
	memory_object_return_t		should_return,
	<span class="enscript-type">int</span>				flags,
	vm_prot_t			prot)
{
	__unused boolean_t	should_flush;

	should_flush = flags &amp; MEMORY_OBJECT_DATA_FLUSH;

        XPR(XPR_MEMORY_OBJECT,
	    <span class="enscript-string">&quot;vm_o_lock_request, obj 0x%X off 0x%X size 0x%X flags %X prot %X\n&quot;</span>,
	    object, offset, size, 
 	    (((should_return&amp;1)&lt;&lt;1)|should_flush), prot);

	<span class="enscript-comment">/*
	 *	Check for bogus arguments.
	 */</span>
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> ((prot &amp; ~VM_PROT_ALL) != 0 &amp;&amp; prot != VM_PROT_NO_CHANGE)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	size = round_page_64(size);

	<span class="enscript-comment">/*
	 *	Lock the object, and acquire a paging reference to
	 *	prevent the memory_object reference from being released.
	 */</span>
	vm_object_lock(object);
	vm_object_paging_begin(object);

	(<span class="enscript-type">void</span>)vm_object_update(object,
		offset, size, NULL, NULL, should_return, flags, prot);

	vm_object_paging_end(object);
	vm_object_unlock(object);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Empty a purgeable object by grabbing the physical pages assigned to it and
 * putting them on the free queue without writing them to backing store, etc.
 * When the pages are next touched they will be demand zero-fill pages.  We
 * skip pages which are busy, being paged in/out, wired, etc.  We do _not_
 * skip referenced/dirty pages, pages on the active queue, etc.  We're more
 * than happy to grab these since this is a purgeable object.  We mark the
 * object as &quot;empty&quot; after reaping its pages.
 *
 * On entry the object must be locked and it must be
 * purgeable with no delayed copies pending.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_purge</span>(vm_object_t object, <span class="enscript-type">int</span> flags)
{
        vm_object_lock_assert_exclusive(object);

	<span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_DENY)
		<span class="enscript-keyword">return</span>;

	assert(object-&gt;copy == VM_OBJECT_NULL);
	assert(object-&gt;copy_strategy == MEMORY_OBJECT_COPY_NONE);

	<span class="enscript-comment">/*
	 * We need to set the object's state to VM_PURGABLE_EMPTY *before*
	 * reaping its pages.  We update vm_page_purgeable_count in bulk
	 * and we don't want vm_page_remove() to update it again for each
	 * page we reap later.
	 *
	 * For the purgeable ledgers, pages from VOLATILE and EMPTY objects
	 * are all accounted for in the &quot;volatile&quot; ledgers, so this does not
	 * make any difference.
	 * If we transitioned directly from NONVOLATILE to EMPTY,
	 * vm_page_purgeable_count must have been updated when the object
	 * was dequeued from its volatile queue and the purgeable ledgers
	 * must have also been updated accordingly at that time (in
	 * vm_object_purgable_control()).
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_VOLATILE) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> delta;
		assert(object-&gt;resident_page_count &gt;=
		       object-&gt;wired_page_count);
		delta = (object-&gt;resident_page_count -
			 object-&gt;wired_page_count);
		<span class="enscript-keyword">if</span> (delta != 0) {
			assert(vm_page_purgeable_count &gt;=
			       delta);
			OSAddAtomic(-delta,
				    (SInt32 *)&amp;vm_page_purgeable_count);
		}
		<span class="enscript-keyword">if</span> (object-&gt;wired_page_count != 0) {
			assert(vm_page_purgeable_wired_count &gt;=
			       object-&gt;wired_page_count);
			OSAddAtomic(-object-&gt;wired_page_count,
				    (SInt32 *)&amp;vm_page_purgeable_wired_count);
		}
		object-&gt;purgable = VM_PURGABLE_EMPTY;
	}
	assert(object-&gt;purgable == VM_PURGABLE_EMPTY);
	
	vm_object_reap_pages(object, REAP_PURGEABLE);

	<span class="enscript-keyword">if</span> (object-&gt;pager != NULL &amp;&amp;
	    COMPRESSED_PAGER_IS_ACTIVE) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pgcount;

		<span class="enscript-keyword">if</span> (object-&gt;activity_in_progress == 0 &amp;&amp;
		    object-&gt;paging_in_progress == 0) {
			<span class="enscript-comment">/*
			 * Also reap any memory coming from this object
			 * in the VM compressor.
			 *
			 * There are no operations in progress on the VM object
			 * and no operation can start while we're holding the
			 * VM object lock, so it's safe to reap the compressed
			 * pages and update the page counts.
			 */</span>
			pgcount = vm_compressor_pager_get_count(object-&gt;pager);
			<span class="enscript-keyword">if</span> (pgcount) {
				pgcount = vm_compressor_pager_reap_pages(object-&gt;pager, flags);
				vm_compressor_pager_count(object-&gt;pager,
							  -pgcount,
							  FALSE, <span class="enscript-comment">/* shared */</span>
							  object);
				vm_purgeable_compressed_update(object,
							       -pgcount);
			}
			<span class="enscript-keyword">if</span> ( !(flags &amp; C_DONT_BLOCK)) {
				assert(vm_compressor_pager_get_count(object-&gt;pager)
				       == 0);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * There's some kind of paging activity in progress
			 * for this object, which could result in a page
			 * being compressed or decompressed, possibly while
			 * the VM object is not locked, so it could race
			 * with us.
			 *
			 * We can't really synchronize this without possibly 
			 * causing a deadlock when the compressor needs to
			 * allocate or free memory while compressing or
			 * decompressing a page from a purgeable object
			 * mapped in the kernel_map...
			 *
			 * So let's not attempt to purge the compressor
			 * pager if there's any kind of operation in
			 * progress on the VM object.
			 */</span>
		}
	}

	vm_object_lock_assert_exclusive(object);
}
				

<span class="enscript-comment">/*
 * vm_object_purgeable_control() allows the caller to control and investigate the
 * state of a purgeable object.  A purgeable object is created via a call to
 * vm_allocate() with VM_FLAGS_PURGABLE specified.  A purgeable object will
 * never be coalesced with any other object -- even other purgeable objects --
 * and will thus always remain a distinct object.  A purgeable object has
 * special semantics when its reference count is exactly 1.  If its reference
 * count is greater than 1, then a purgeable object will behave like a normal
 * object and attempts to use this interface will result in an error return
 * of KERN_INVALID_ARGUMENT.
 *
 * A purgeable object may be put into a &quot;volatile&quot; state which will make the
 * object's pages elligable for being reclaimed without paging to backing
 * store if the system runs low on memory.  If the pages in a volatile
 * purgeable object are reclaimed, the purgeable object is said to have been
 * &quot;emptied.&quot;  When a purgeable object is emptied the system will reclaim as
 * many pages from the object as it can in a convenient manner (pages already
 * en route to backing store or busy for other reasons are left as is).  When
 * a purgeable object is made volatile, its pages will generally be reclaimed
 * before other pages in the application's working set.  This semantic is
 * generally used by applications which can recreate the data in the object
 * faster than it can be paged in.  One such example might be media assets
 * which can be reread from a much faster RAID volume.
 *
 * A purgeable object may be designated as &quot;non-volatile&quot; which means it will
 * behave like all other objects in the system with pages being written to and
 * read from backing store as needed to satisfy system memory needs.  If the
 * object was emptied before the object was made non-volatile, that fact will
 * be returned as the old state of the purgeable object (see
 * VM_PURGABLE_SET_STATE below).  In this case, any pages of the object which
 * were reclaimed as part of emptying the object will be refaulted in as
 * zero-fill on demand.  It is up to the application to note that an object
 * was emptied and recreate the objects contents if necessary.  When a
 * purgeable object is made non-volatile, its pages will generally not be paged
 * out to backing store in the immediate future.  A purgeable object may also
 * be manually emptied.
 *
 * Finally, the current state (non-volatile, volatile, volatile &amp; empty) of a
 * volatile purgeable object may be queried at any time.  This information may
 * be used as a control input to let the application know when the system is
 * experiencing memory pressure and is reclaiming memory.
 *
 * The specified address may be any address within the purgeable object.  If
 * the specified address does not represent any object in the target task's
 * virtual address space, then KERN_INVALID_ADDRESS will be returned.  If the
 * object containing the specified address is not a purgeable object, then
 * KERN_INVALID_ARGUMENT will be returned.  Otherwise, KERN_SUCCESS will be
 * returned.
 *
 * The control parameter may be any one of VM_PURGABLE_SET_STATE or
 * VM_PURGABLE_GET_STATE.  For VM_PURGABLE_SET_STATE, the in/out parameter
 * state is used to set the new state of the purgeable object and return its
 * old state.  For VM_PURGABLE_GET_STATE, the current state of the purgeable
 * object is returned in the parameter state.
 *
 * The in/out parameter state may be one of VM_PURGABLE_NONVOLATILE,
 * VM_PURGABLE_VOLATILE or VM_PURGABLE_EMPTY.  These, respectively, represent
 * the non-volatile, volatile and volatile/empty states described above.
 * Setting the state of a purgeable object to VM_PURGABLE_EMPTY will
 * immediately reclaim as many pages in the object as can be conveniently
 * collected (some may have already been written to backing store or be
 * otherwise busy).
 *
 * The process of making a purgeable object non-volatile and determining its
 * previous state is atomic.  Thus, if a purgeable object is made
 * VM_PURGABLE_NONVOLATILE and the old state is returned as
 * VM_PURGABLE_VOLATILE, then the purgeable object's previous contents are
 * completely intact and will remain so until the object is made volatile
 * again.  If the old state is returned as VM_PURGABLE_EMPTY then the object
 * was reclaimed while it was in a volatile state and its previous contents
 * have been lost.
 */</span>
<span class="enscript-comment">/*
 * The object must be locked.
 */</span>
kern_return_t
<span class="enscript-function-name">vm_object_purgable_control</span>(
	vm_object_t	object,
	vm_purgable_t	control,
	<span class="enscript-type">int</span>		*state)
{
	<span class="enscript-type">int</span>		old_state;
	<span class="enscript-type">int</span>		new_state;

	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
		<span class="enscript-comment">/*
		 * Object must already be present or it can't be purgeable.
		 */</span>
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vm_object_lock_assert_exclusive(object);

	<span class="enscript-comment">/*
	 * Get current state of the purgeable object.
	 */</span>
	old_state = object-&gt;purgable;
	<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_DENY)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
    
	<span class="enscript-comment">/* purgeable cant have delayed copies - now or in the future */</span>
	assert(object-&gt;copy == VM_OBJECT_NULL); 
	assert(object-&gt;copy_strategy == MEMORY_OBJECT_COPY_NONE);

	<span class="enscript-comment">/*
	 * Execute the desired operation.
	 */</span>
	<span class="enscript-keyword">if</span> (control == VM_PURGABLE_GET_STATE) {
		*state = old_state;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">if</span> ((*state) &amp; VM_PURGABLE_DEBUG_EMPTY) {
		object-&gt;volatile_empty = TRUE;
	}
	<span class="enscript-keyword">if</span> ((*state) &amp; VM_PURGABLE_DEBUG_FAULT) {
		object-&gt;volatile_fault = TRUE;
	}

	new_state = *state &amp; VM_PURGABLE_STATE_MASK;
	<span class="enscript-keyword">if</span> (new_state == VM_PURGABLE_VOLATILE &amp;&amp;
	    object-&gt;volatile_empty) {
		new_state = VM_PURGABLE_EMPTY;
	}

	<span class="enscript-keyword">switch</span> (new_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_DENY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_NONVOLATILE</span>:
		object-&gt;purgable = new_state;

		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_VOLATILE) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> delta;

			assert(object-&gt;resident_page_count &gt;=
			       object-&gt;wired_page_count);
			delta = (object-&gt;resident_page_count -
				 object-&gt;wired_page_count);

			assert(vm_page_purgeable_count &gt;= delta);

			<span class="enscript-keyword">if</span> (delta != 0) {
				OSAddAtomic(-delta,
					    (SInt32 *)&amp;vm_page_purgeable_count);
			}
			<span class="enscript-keyword">if</span> (object-&gt;wired_page_count != 0) {
				assert(vm_page_purgeable_wired_count &gt;=
				       object-&gt;wired_page_count);
				OSAddAtomic(-object-&gt;wired_page_count,
					    (SInt32 *)&amp;vm_page_purgeable_wired_count);
			}

			vm_page_lock_queues();

			<span class="enscript-comment">/* object should be on a queue */</span>
			assert(object-&gt;objq.next != NULL &amp;&amp;
			       object-&gt;objq.prev != NULL);
			purgeable_q_t queue;

			<span class="enscript-comment">/*
			 * Move object from its volatile queue to the
			 * non-volatile queue...
			 */</span>
			queue = vm_purgeable_object_remove(object);
			assert(queue);

			<span class="enscript-keyword">if</span> (object-&gt;purgeable_when_ripe) {
				vm_purgeable_token_delete_last(queue);
			}
			assert(queue-&gt;debug_count_objects&gt;=0);

			vm_page_unlock_queues();
		}
		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_VOLATILE ||
		    old_state == VM_PURGABLE_EMPTY) {
			<span class="enscript-comment">/*
			 * Transfer the object's pages from the volatile to
			 * non-volatile ledgers.
			 */</span>
			vm_purgeable_accounting(object, VM_PURGABLE_VOLATILE,
						FALSE);
		}

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_VOLATILE</span>:
		<span class="enscript-keyword">if</span> (object-&gt;volatile_fault) {
			vm_page_t	p;
			<span class="enscript-type">int</span>		refmod;

			queue_iterate(&amp;object-&gt;memq, p, vm_page_t, listq) {
				<span class="enscript-keyword">if</span> (p-&gt;busy ||
				    VM_PAGE_WIRED(p) ||
				    p-&gt;fictitious) {
					<span class="enscript-keyword">continue</span>;
				}
				refmod = pmap_disconnect(p-&gt;phys_page);
				<span class="enscript-keyword">if</span> ((refmod &amp; VM_MEM_MODIFIED) &amp;&amp;
				    !p-&gt;dirty) {
					SET_PAGE_DIRTY(p, FALSE);
				}
			}
		}
					       
		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_EMPTY &amp;&amp;
		    object-&gt;resident_page_count == 0 &amp;&amp;
		    object-&gt;pager == NULL)
			<span class="enscript-keyword">break</span>;

		purgeable_q_t queue;
        
		<span class="enscript-comment">/* find the correct queue */</span>
		<span class="enscript-keyword">if</span> ((*state&amp;VM_PURGABLE_ORDERING_MASK) == VM_PURGABLE_ORDERING_OBSOLETE)
		        queue = &amp;purgeable_queues[PURGEABLE_Q_TYPE_OBSOLETE];
		<span class="enscript-keyword">else</span> {
		        <span class="enscript-keyword">if</span> ((*state&amp;VM_PURGABLE_BEHAVIOR_MASK) == VM_PURGABLE_BEHAVIOR_FIFO)
			        queue = &amp;purgeable_queues[PURGEABLE_Q_TYPE_FIFO];
			<span class="enscript-keyword">else</span>
			        queue = &amp;purgeable_queues[PURGEABLE_Q_TYPE_LIFO];
		}
        
		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_NONVOLATILE ||
		    old_state == VM_PURGABLE_EMPTY) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> delta;

			<span class="enscript-keyword">if</span> ((*state &amp; VM_PURGABLE_NO_AGING_MASK) ==
			    VM_PURGABLE_NO_AGING) {
				object-&gt;purgeable_when_ripe = FALSE;
			} <span class="enscript-keyword">else</span> {
				object-&gt;purgeable_when_ripe = TRUE;
			}
				
			<span class="enscript-keyword">if</span> (object-&gt;purgeable_when_ripe) {
				kern_return_t result;

				<span class="enscript-comment">/* try to add token... this can fail */</span>
				vm_page_lock_queues();

				result = vm_purgeable_token_add(queue);
				<span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
					vm_page_unlock_queues();
					<span class="enscript-keyword">return</span> result;
				}
				vm_page_unlock_queues();
			}

			assert(object-&gt;resident_page_count &gt;=
			       object-&gt;wired_page_count);
			delta = (object-&gt;resident_page_count -
				 object-&gt;wired_page_count);

			<span class="enscript-keyword">if</span> (delta != 0) {
				OSAddAtomic(delta,
					    &amp;vm_page_purgeable_count);
			}
			<span class="enscript-keyword">if</span> (object-&gt;wired_page_count != 0) {
				OSAddAtomic(object-&gt;wired_page_count,
					    &amp;vm_page_purgeable_wired_count);
			}

			object-&gt;purgable = new_state;

			<span class="enscript-comment">/* object should be on &quot;non-volatile&quot; queue */</span>
			assert(object-&gt;objq.next != NULL);
			assert(object-&gt;objq.prev != NULL);
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_VOLATILE) {
			purgeable_q_t	old_queue;
			boolean_t	purgeable_when_ripe;

		        <span class="enscript-comment">/*
			 * if reassigning priorities / purgeable groups, we don't change the
			 * token queue. So moving priorities will not make pages stay around longer.
			 * Reasoning is that the algorithm gives most priority to the most important
			 * object. If a new token is added, the most important object' priority is boosted.
			 * This biases the system already for purgeable queues that move a lot.
			 * It doesn't seem more biasing is neccessary in this case, where no new object is added.
			 */</span>
		        assert(object-&gt;objq.next != NULL &amp;&amp; object-&gt;objq.prev != NULL); <span class="enscript-comment">/* object should be on a queue */</span>
            
			old_queue = vm_purgeable_object_remove(object);
			assert(old_queue);
            
			<span class="enscript-keyword">if</span> ((*state &amp; VM_PURGABLE_NO_AGING_MASK) ==
			    VM_PURGABLE_NO_AGING) {
				purgeable_when_ripe = FALSE;
			} <span class="enscript-keyword">else</span> {
				purgeable_when_ripe = TRUE;
			}
				
			<span class="enscript-keyword">if</span> (old_queue != queue ||
			    (purgeable_when_ripe !=
			     object-&gt;purgeable_when_ripe)) {
				kern_return_t result;

			        <span class="enscript-comment">/* Changing queue. Have to move token. */</span>
			        vm_page_lock_queues();
				<span class="enscript-keyword">if</span> (object-&gt;purgeable_when_ripe) {
					vm_purgeable_token_delete_last(old_queue);
				}
				object-&gt;purgeable_when_ripe = purgeable_when_ripe;
				<span class="enscript-keyword">if</span> (object-&gt;purgeable_when_ripe) {
					result = vm_purgeable_token_add(queue);
					assert(result==KERN_SUCCESS);   <span class="enscript-comment">/* this should never fail since we just freed a token */</span>
				}
				vm_page_unlock_queues();

			}
		};
		vm_purgeable_object_add(object, queue, (*state&amp;VM_VOLATILE_GROUP_MASK)&gt;&gt;VM_VOLATILE_GROUP_SHIFT );
		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_NONVOLATILE) {
			vm_purgeable_accounting(object, VM_PURGABLE_NONVOLATILE,
						FALSE);
		}

		assert(queue-&gt;debug_count_objects&gt;=0);
        
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_EMPTY</span>:
		<span class="enscript-keyword">if</span> (object-&gt;volatile_fault) {
			vm_page_t	p;
			<span class="enscript-type">int</span>		refmod;

			queue_iterate(&amp;object-&gt;memq, p, vm_page_t, listq) {
				<span class="enscript-keyword">if</span> (p-&gt;busy ||
				    VM_PAGE_WIRED(p) ||
				    p-&gt;fictitious) {
					<span class="enscript-keyword">continue</span>;
				}
				refmod = pmap_disconnect(p-&gt;phys_page);
				<span class="enscript-keyword">if</span> ((refmod &amp; VM_MEM_MODIFIED) &amp;&amp;
				    !p-&gt;dirty) {
					SET_PAGE_DIRTY(p, FALSE);
				}
			}
		}

		<span class="enscript-keyword">if</span> (old_state == new_state) {
			<span class="enscript-comment">/* nothing changes */</span>
			<span class="enscript-keyword">break</span>;
		}

		assert(old_state == VM_PURGABLE_NONVOLATILE ||
		       old_state == VM_PURGABLE_VOLATILE);
		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_VOLATILE) {
			purgeable_q_t old_queue;

			<span class="enscript-comment">/* object should be on a queue */</span>
			assert(object-&gt;objq.next != NULL &amp;&amp;
			       object-&gt;objq.prev != NULL);

			old_queue = vm_purgeable_object_remove(object);
			assert(old_queue);
			<span class="enscript-keyword">if</span> (object-&gt;purgeable_when_ripe) {
				vm_page_lock_queues();
				vm_purgeable_token_delete_first(old_queue);
				vm_page_unlock_queues();
			}
		}

		<span class="enscript-keyword">if</span> (old_state == VM_PURGABLE_NONVOLATILE) {
			<span class="enscript-comment">/*
			 * This object's pages were previously accounted as
			 * &quot;non-volatile&quot; and now need to be accounted as
			 * &quot;volatile&quot;.
			 */</span>
			vm_purgeable_accounting(object, VM_PURGABLE_NONVOLATILE,
						FALSE);
			<span class="enscript-comment">/*
			 * Set to VM_PURGABLE_EMPTY because the pages are no
			 * longer accounted in the &quot;non-volatile&quot; ledger
			 * and are also not accounted for in
			 * &quot;vm_page_purgeable_count&quot;.
			 */</span>
			object-&gt;purgable = VM_PURGABLE_EMPTY;
		}

		(<span class="enscript-type">void</span>) vm_object_purge(object, 0);
		assert(object-&gt;purgable == VM_PURGABLE_EMPTY);

		<span class="enscript-keyword">break</span>;
	}

	*state = old_state;

	vm_object_lock_assert_exclusive(object);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vm_object_get_page_counts</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_object_size_t	size,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*resident_page_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*dirty_page_count)
{

	kern_return_t		kr = KERN_SUCCESS;
	boolean_t		count_dirty_pages = FALSE;
	vm_page_t		p = VM_PAGE_NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 		local_resident_count = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		local_dirty_count = 0;
	vm_object_offset_t	cur_offset = 0;
	vm_object_offset_t	end_offset = 0;

	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;


	cur_offset = offset;
	
	end_offset = offset + size;

	vm_object_lock_assert_exclusive(object);

	<span class="enscript-keyword">if</span> (dirty_page_count != NULL) {

		count_dirty_pages = TRUE;
	}

	<span class="enscript-keyword">if</span> (resident_page_count != NULL &amp;&amp; count_dirty_pages == FALSE) {
		<span class="enscript-comment">/*
		 * Fast path when:
		 * - we only want the resident page count, and,
		 * - the entire object is exactly covered by the request.
		 */</span>
		<span class="enscript-keyword">if</span> (offset == 0 &amp;&amp; (object-&gt;vo_size == size)) {

			*resident_page_count = object-&gt;resident_page_count;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (object-&gt;resident_page_count &lt;= (size &gt;&gt; PAGE_SHIFT)) {

		queue_iterate(&amp;object-&gt;memq, p, vm_page_t, listq) {
		
			<span class="enscript-keyword">if</span> (p-&gt;offset &gt;= cur_offset &amp;&amp; p-&gt;offset &lt; end_offset) {

				local_resident_count++;

				<span class="enscript-keyword">if</span> (count_dirty_pages) {
					
					<span class="enscript-keyword">if</span> (p-&gt;dirty || (p-&gt;wpmapped &amp;&amp; pmap_is_modified(p-&gt;phys_page))) {
						
						local_dirty_count++;
					}
				}
			}
		}
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-keyword">for</span> (cur_offset = offset; cur_offset &lt; end_offset; cur_offset += PAGE_SIZE_64) {
	
			p = vm_page_lookup(object, cur_offset);
		
			<span class="enscript-keyword">if</span> (p != VM_PAGE_NULL) {

				local_resident_count++;

				<span class="enscript-keyword">if</span> (count_dirty_pages) {
					
					<span class="enscript-keyword">if</span> (p-&gt;dirty || (p-&gt;wpmapped &amp;&amp; pmap_is_modified(p-&gt;phys_page))) {
				
						local_dirty_count++;
					}
				}
			}
		}

	}

	<span class="enscript-keyword">if</span> (resident_page_count != NULL) {
		*resident_page_count = local_resident_count;
	}

	<span class="enscript-keyword">if</span> (dirty_page_count != NULL) {
		*dirty_page_count = local_dirty_count;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> kr;
}


#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
<span class="enscript-comment">/*
 * vm_object_res_deallocate
 *
 * (recursively) decrement residence counts on vm objects and their shadows.
 * Called from vm_object_deallocate and when swapping out an object.
 *
 * The object is locked, and remains locked throughout the function,
 * even as we iterate down the shadow chain.  Locks on intermediate objects
 * will be dropped, but not the original object.
 *
 * NOTE: this function used to use recursion, rather than iteration.
 */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_res_deallocate</span>(
	vm_object_t	object)
{
	vm_object_t orig_object = object;
	<span class="enscript-comment">/*
	 * Object is locked so it can be called directly
	 * from vm_object_deallocate.  Original object is never
	 * unlocked.
	 */</span>
	assert(object-&gt;res_count &gt; 0);
	<span class="enscript-keyword">while</span>  (--object-&gt;res_count == 0) {
		assert(object-&gt;ref_count &gt;= object-&gt;res_count);
		vm_object_deactivate_all_pages(object);
		<span class="enscript-comment">/* iterate on shadow, if present */</span>
		<span class="enscript-keyword">if</span> (object-&gt;shadow != VM_OBJECT_NULL) {
			vm_object_t tmp_object = object-&gt;shadow;
			vm_object_lock(tmp_object);
			<span class="enscript-keyword">if</span> (object != orig_object)
				vm_object_unlock(object);
			object = tmp_object;
			assert(object-&gt;res_count &gt; 0);
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (object != orig_object)
		vm_object_unlock(object);
}

<span class="enscript-comment">/*
 * vm_object_res_reference
 *
 * Internal function to increment residence count on a vm object
 * and its shadows.  It is called only from vm_object_reference, and
 * when swapping in a vm object, via vm_map_swap.
 *
 * The object is locked, and remains locked throughout the function,
 * even as we iterate down the shadow chain.  Locks on intermediate objects
 * will be dropped, but not the original object.
 *
 * NOTE: this function used to use recursion, rather than iteration.
 */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_res_reference</span>(
	vm_object_t	object)
{
	vm_object_t orig_object = object;
	<span class="enscript-comment">/* 
	 * Object is locked, so this can be called directly
	 * from vm_object_reference.  This lock is never released.
	 */</span>
	<span class="enscript-keyword">while</span>  ((++object-&gt;res_count == 1)  &amp;&amp; 
		(object-&gt;shadow != VM_OBJECT_NULL)) {
		vm_object_t tmp_object = object-&gt;shadow;

		assert(object-&gt;ref_count &gt;= object-&gt;res_count);
		vm_object_lock(tmp_object);
		<span class="enscript-keyword">if</span> (object != orig_object)
			vm_object_unlock(object);
		object = tmp_object;
	}
	<span class="enscript-keyword">if</span> (object != orig_object)
		vm_object_unlock(object);
	assert(orig_object-&gt;ref_count &gt;= orig_object-&gt;res_count);
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

<span class="enscript-comment">/*
 *	vm_object_reference:
 *
 *	Gets another reference to the given object.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">vm_object_reference</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">vm_object_reference</span>
#<span class="enscript-reference">endif</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_reference</span>(
	<span class="enscript-type">register</span> vm_object_t	object)
{
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL)
		<span class="enscript-keyword">return</span>;

	vm_object_lock(object);
	assert(object-&gt;ref_count &gt; 0);
	vm_object_reference_locked(object);
	vm_object_unlock(object);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
<span class="enscript-comment">/*
 * Scale the vm_object_cache
 * This is required to make sure that the vm_object_cache is big
 * enough to effectively cache the mapped file.
 * This is really important with UBC as all the regular file vnodes
 * have memory object associated with them. Havving this cache too
 * small results in rapid reclaim of vnodes and hurts performance a LOT!
 *
 * This is also needed as number of vnodes can be dynamically scaled.
 */</span>
kern_return_t
<span class="enscript-function-name">adjust_vm_object_cache</span>(
	__unused vm_size_t oval,
	__unused vm_size_t nval)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_CACHE</span>
	vm_object_cached_max = nval;
	vm_object_cache_trim(FALSE);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>


<span class="enscript-comment">/*
 * vm_object_transpose
 *
 * This routine takes two VM objects of the same size and exchanges
 * their backing store.
 * The objects should be &quot;quiesced&quot; via a UPL operation with UPL_SET_IO_WIRE
 * and UPL_BLOCK_ACCESS if they are referenced anywhere.
 *
 * The VM objects must not be locked by caller.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_object_transpose_count = 0;
kern_return_t
<span class="enscript-function-name">vm_object_transpose</span>(
	vm_object_t		object1,
	vm_object_t		object2,
	vm_object_size_t	transpose_size)
{
	vm_object_t		tmp_object;
	kern_return_t		retval;
	boolean_t		object1_locked, object2_locked;
	vm_page_t		page;
	vm_object_offset_t	page_offset;
	lck_mtx_t		*hash_lck;
	vm_object_hash_entry_t	hash_entry;

	tmp_object = VM_OBJECT_NULL;
	object1_locked = FALSE; object2_locked = FALSE;

	<span class="enscript-keyword">if</span> (object1 == object2 ||
	    object1 == VM_OBJECT_NULL ||
	    object2 == VM_OBJECT_NULL) {
		<span class="enscript-comment">/*
		 * If the 2 VM objects are the same, there's
		 * no point in exchanging their backing store.
		 */</span>
		retval = KERN_INVALID_VALUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Since we need to lock both objects at the same time,
	 * make sure we always lock them in the same order to
	 * avoid deadlocks.
	 */</span>
	<span class="enscript-keyword">if</span> (object1 &gt;  object2) {
		tmp_object = object1;
		object1 = object2;
		object2 = tmp_object;
	}

	<span class="enscript-comment">/*
	 * Allocate a temporary VM object to hold object1's contents
	 * while we copy object2 to object1.
	 */</span>
	tmp_object = vm_object_allocate(transpose_size);
	vm_object_lock(tmp_object);
	tmp_object-&gt;can_persist = FALSE;


	<span class="enscript-comment">/*
	 * Grab control of the 1st VM object.
	 */</span>
	vm_object_lock(object1);
	object1_locked = TRUE;
	<span class="enscript-keyword">if</span> (!object1-&gt;alive || object1-&gt;terminating ||
	    object1-&gt;copy || object1-&gt;shadow || object1-&gt;shadowed ||
	    object1-&gt;purgable != VM_PURGABLE_DENY) {
		<span class="enscript-comment">/*
		 * We don't deal with copy or shadow objects (yet).
		 */</span>
		retval = KERN_INVALID_VALUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * We're about to mess with the object's backing store and 
	 * taking a &quot;paging_in_progress&quot; reference wouldn't be enough
	 * to prevent any paging activity on this object, so the caller should
	 * have &quot;quiesced&quot; the objects beforehand, via a UPL operation with
	 * UPL_SET_IO_WIRE (to make sure all the pages are there and wired)
	 * and UPL_BLOCK_ACCESS (to mark the pages &quot;busy&quot;).
	 * 
	 * Wait for any paging operation to complete (but only paging, not 
	 * other kind of activities not linked to the pager).  After we're
	 * statisfied that there's no more paging in progress, we keep the
	 * object locked, to guarantee that no one tries to access its pager.
	 */</span>
	vm_object_paging_only_wait(object1, THREAD_UNINT);

	<span class="enscript-comment">/*
	 * Same as above for the 2nd object...
	 */</span>
	vm_object_lock(object2);
	object2_locked = TRUE;
	<span class="enscript-keyword">if</span> (! object2-&gt;alive || object2-&gt;terminating ||
	    object2-&gt;copy || object2-&gt;shadow || object2-&gt;shadowed ||
	    object2-&gt;purgable != VM_PURGABLE_DENY) {
		retval = KERN_INVALID_VALUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	vm_object_paging_only_wait(object2, THREAD_UNINT);


	<span class="enscript-keyword">if</span> (object1-&gt;vo_size != object2-&gt;vo_size ||
	    object1-&gt;vo_size != transpose_size) {
		<span class="enscript-comment">/*
		 * If the 2 objects don't have the same size, we can't
		 * exchange their backing stores or one would overflow.
		 * If their size doesn't match the caller's
		 * &quot;transpose_size&quot;, we can't do it either because the
		 * transpose operation will affect the entire span of 
		 * the objects.
		 */</span>
		retval = KERN_INVALID_VALUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}


	<span class="enscript-comment">/*
	 * Transpose the lists of resident pages.
	 * This also updates the resident_page_count and the memq_hint.
	 */</span>
	<span class="enscript-keyword">if</span> (object1-&gt;phys_contiguous || queue_empty(&amp;object1-&gt;memq)) {
		<span class="enscript-comment">/*
		 * No pages in object1, just transfer pages
		 * from object2 to object1.  No need to go through
		 * an intermediate object.
		 */</span>
		<span class="enscript-keyword">while</span> (!queue_empty(&amp;object2-&gt;memq)) {
			page = (vm_page_t) queue_first(&amp;object2-&gt;memq);
			vm_page_rename(page, object1, page-&gt;offset, FALSE);
		}
		assert(queue_empty(&amp;object2-&gt;memq));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object2-&gt;phys_contiguous || queue_empty(&amp;object2-&gt;memq)) {
		<span class="enscript-comment">/*
		 * No pages in object2, just transfer pages
		 * from object1 to object2.  No need to go through
		 * an intermediate object.
		 */</span>
		<span class="enscript-keyword">while</span> (!queue_empty(&amp;object1-&gt;memq)) {
			page = (vm_page_t) queue_first(&amp;object1-&gt;memq);
			vm_page_rename(page, object2, page-&gt;offset, FALSE);
		}
		assert(queue_empty(&amp;object1-&gt;memq));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* transfer object1's pages to tmp_object */</span>
		<span class="enscript-keyword">while</span> (!queue_empty(&amp;object1-&gt;memq)) {
			page = (vm_page_t) queue_first(&amp;object1-&gt;memq);
			page_offset = page-&gt;offset;
			vm_page_remove(page, TRUE);
			page-&gt;offset = page_offset;
			queue_enter(&amp;tmp_object-&gt;memq, page, vm_page_t, listq);
		}
		assert(queue_empty(&amp;object1-&gt;memq));
		<span class="enscript-comment">/* transfer object2's pages to object1 */</span>
		<span class="enscript-keyword">while</span> (!queue_empty(&amp;object2-&gt;memq)) {
			page = (vm_page_t) queue_first(&amp;object2-&gt;memq);
			vm_page_rename(page, object1, page-&gt;offset, FALSE);
		}
		assert(queue_empty(&amp;object2-&gt;memq));
		<span class="enscript-comment">/* transfer tmp_object's pages to object2 */</span>
		<span class="enscript-keyword">while</span> (!queue_empty(&amp;tmp_object-&gt;memq)) {
			page = (vm_page_t) queue_first(&amp;tmp_object-&gt;memq);
			queue_remove(&amp;tmp_object-&gt;memq, page,
				     vm_page_t, listq);
			vm_page_insert(page, object2, page-&gt;offset);
		}
		assert(queue_empty(&amp;tmp_object-&gt;memq));
	}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">__TRANSPOSE_FIELD</span>(field)				\
MACRO_BEGIN							\
	tmp_object-&gt;field = object1-&gt;field;			\
	object1-&gt;field = object2-&gt;field;			\
	object2-&gt;field = tmp_object-&gt;field;			\
MACRO_END

	<span class="enscript-comment">/* &quot;Lock&quot; refers to the object not its contents */</span>
	<span class="enscript-comment">/* &quot;size&quot; should be identical */</span>
	assert(object1-&gt;vo_size == object2-&gt;vo_size);
	<span class="enscript-comment">/* &quot;memq_hint&quot; was updated above when transposing pages */</span>
	<span class="enscript-comment">/* &quot;ref_count&quot; refers to the object not its contents */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TASK_SWAPPER</span>
	<span class="enscript-comment">/* &quot;res_count&quot; refers to the object not its contents */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* &quot;resident_page_count&quot; was updated above when transposing pages */</span>
	<span class="enscript-comment">/* &quot;wired_page_count&quot; was updated above when transposing pages */</span>
	<span class="enscript-comment">/* &quot;reusable_page_count&quot; was updated above when transposing pages */</span>
	<span class="enscript-comment">/* there should be no &quot;copy&quot; */</span>
	assert(!object1-&gt;copy);
	assert(!object2-&gt;copy);
	<span class="enscript-comment">/* there should be no &quot;shadow&quot; */</span>
	assert(!object1-&gt;shadow);
	assert(!object2-&gt;shadow);
	__TRANSPOSE_FIELD(vo_shadow_offset); <span class="enscript-comment">/* used by phys_contiguous objects */</span>
	__TRANSPOSE_FIELD(pager);
	__TRANSPOSE_FIELD(paging_offset);
	__TRANSPOSE_FIELD(pager_control);
	<span class="enscript-comment">/* update the memory_objects' pointers back to the VM objects */</span>
	<span class="enscript-keyword">if</span> (object1-&gt;pager_control != MEMORY_OBJECT_CONTROL_NULL) {
		memory_object_control_collapse(object1-&gt;pager_control,
					       object1);
	}
	<span class="enscript-keyword">if</span> (object2-&gt;pager_control != MEMORY_OBJECT_CONTROL_NULL) {
		memory_object_control_collapse(object2-&gt;pager_control,
					       object2);
	}
	__TRANSPOSE_FIELD(copy_strategy);
	<span class="enscript-comment">/* &quot;paging_in_progress&quot; refers to the object not its contents */</span>
	assert(!object1-&gt;paging_in_progress);
	assert(!object2-&gt;paging_in_progress);
	assert(object1-&gt;activity_in_progress);
	assert(object2-&gt;activity_in_progress);
	<span class="enscript-comment">/* &quot;all_wanted&quot; refers to the object not its contents */</span>
	__TRANSPOSE_FIELD(pager_created);
	__TRANSPOSE_FIELD(pager_initialized);
	__TRANSPOSE_FIELD(pager_ready);
	__TRANSPOSE_FIELD(pager_trusted);
	__TRANSPOSE_FIELD(can_persist);
	__TRANSPOSE_FIELD(internal);
	__TRANSPOSE_FIELD(temporary);
	__TRANSPOSE_FIELD(private);
	__TRANSPOSE_FIELD(pageout);
	<span class="enscript-comment">/* &quot;alive&quot; should be set */</span>
	assert(object1-&gt;alive);
	assert(object2-&gt;alive);
	<span class="enscript-comment">/* &quot;purgeable&quot; should be non-purgeable */</span>
	assert(object1-&gt;purgable == VM_PURGABLE_DENY);
	assert(object2-&gt;purgable == VM_PURGABLE_DENY);
	<span class="enscript-comment">/* &quot;shadowed&quot; refers to the the object not its contents */</span>
	__TRANSPOSE_FIELD(purgeable_when_ripe);
	__TRANSPOSE_FIELD(advisory_pageout);
	__TRANSPOSE_FIELD(true_share);
	<span class="enscript-comment">/* &quot;terminating&quot; should not be set */</span>
	assert(!object1-&gt;terminating);
	assert(!object2-&gt;terminating);
	__TRANSPOSE_FIELD(named);
	<span class="enscript-comment">/* &quot;shadow_severed&quot; refers to the object not its contents */</span>
	__TRANSPOSE_FIELD(phys_contiguous);
	__TRANSPOSE_FIELD(nophyscache);
	<span class="enscript-comment">/* &quot;cached_list.next&quot; points to transposed object */</span>
	object1-&gt;cached_list.next = (queue_entry_t) object2;
	object2-&gt;cached_list.next = (queue_entry_t) object1;
	<span class="enscript-comment">/* &quot;cached_list.prev&quot; should be NULL */</span>
	assert(object1-&gt;cached_list.prev == NULL);
	assert(object2-&gt;cached_list.prev == NULL);
	<span class="enscript-comment">/* &quot;msr_q&quot; is linked to the object not its contents */</span>
	assert(queue_empty(&amp;object1-&gt;msr_q));
	assert(queue_empty(&amp;object2-&gt;msr_q));
	__TRANSPOSE_FIELD(last_alloc);
	__TRANSPOSE_FIELD(sequential);
	__TRANSPOSE_FIELD(pages_created);
	__TRANSPOSE_FIELD(pages_used);
	__TRANSPOSE_FIELD(scan_collisions);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
	__TRANSPOSE_FIELD(existence_map);
#<span class="enscript-reference">endif</span>
	__TRANSPOSE_FIELD(cow_hint);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	__TRANSPOSE_FIELD(paging_object);
#<span class="enscript-reference">endif</span>
	__TRANSPOSE_FIELD(wimg_bits);
	__TRANSPOSE_FIELD(set_cache_attr);
	__TRANSPOSE_FIELD(code_signed);
	<span class="enscript-keyword">if</span> (object1-&gt;hashed) {
		hash_lck = vm_object_hash_lock_spin(object2-&gt;pager);
		hash_entry = vm_object_hash_lookup(object2-&gt;pager, FALSE);
		assert(hash_entry != VM_OBJECT_HASH_ENTRY_NULL);
		hash_entry-&gt;object = object2;
		vm_object_hash_unlock(hash_lck);
	}
	<span class="enscript-keyword">if</span> (object2-&gt;hashed) {
		hash_lck = vm_object_hash_lock_spin(object1-&gt;pager);
		hash_entry = vm_object_hash_lookup(object1-&gt;pager, FALSE);
		assert(hash_entry != VM_OBJECT_HASH_ENTRY_NULL);
		hash_entry-&gt;object = object1;
		vm_object_hash_unlock(hash_lck);
	}
	__TRANSPOSE_FIELD(hashed);
	object1-&gt;transposed = TRUE;
	object2-&gt;transposed = TRUE;
	__TRANSPOSE_FIELD(mapping_in_progress);
	__TRANSPOSE_FIELD(volatile_empty);
	__TRANSPOSE_FIELD(volatile_fault);
	__TRANSPOSE_FIELD(all_reusable);
	assert(object1-&gt;blocked_access);
	assert(object2-&gt;blocked_access);
	assert(object1-&gt;__object2_unused_bits == 0);
	assert(object2-&gt;__object2_unused_bits == 0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">UPL_DEBUG</span>
	<span class="enscript-comment">/* &quot;uplq&quot; refers to the object not its contents (see upl_transpose()) */</span>
#<span class="enscript-reference">endif</span>
	assert((object1-&gt;purgable == VM_PURGABLE_DENY) || (object1-&gt;objq.next == NULL));
	assert((object1-&gt;purgable == VM_PURGABLE_DENY) || (object1-&gt;objq.prev == NULL));
	assert((object2-&gt;purgable == VM_PURGABLE_DENY) || (object2-&gt;objq.next == NULL));
	assert((object2-&gt;purgable == VM_PURGABLE_DENY) || (object2-&gt;objq.prev == NULL));

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">__TRANSPOSE_FIELD</span>

	retval = KERN_SUCCESS;

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 * Cleanup.
	 */</span>
	<span class="enscript-keyword">if</span> (tmp_object != VM_OBJECT_NULL) {
		vm_object_unlock(tmp_object);
		<span class="enscript-comment">/*
		 * Re-initialize the temporary object to avoid
		 * deallocating a real pager.
		 */</span>
		_vm_object_allocate(transpose_size, tmp_object);
		vm_object_deallocate(tmp_object);
		tmp_object = VM_OBJECT_NULL;
	}

	<span class="enscript-keyword">if</span> (object1_locked) {
		vm_object_unlock(object1);
		object1_locked = FALSE;
	}
	<span class="enscript-keyword">if</span> (object2_locked) {
		vm_object_unlock(object2);
		object2_locked = FALSE;
	}

	vm_object_transpose_count++;

	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-comment">/*
 *      vm_object_cluster_size
 *
 *      Determine how big a cluster we should issue an I/O for...
 *
 *	Inputs:   *start == offset of page needed
 *		  *length == maximum cluster pager can handle
 *	Outputs:  *start == beginning offset of cluster
 *		  *length == length of cluster to try
 *
 *	The original *start will be encompassed by the cluster
 *
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> speculative_reads_disabled;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ignore_is_ssd;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> preheat_max_bytes = MAX_UPL_TRANSFER_BYTES;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> preheat_min_bytes = (1024 * 32);


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_cluster_size</span>(vm_object_t object, vm_object_offset_t *start,
		       vm_size_t *length, vm_object_fault_info_t fault_info, uint32_t *io_streaming)
{
	vm_size_t		pre_heat_size;
	vm_size_t		tail_size;
	vm_size_t		head_size;
	vm_size_t		max_length;
	vm_size_t		cluster_size;
	vm_object_offset_t	object_size;
	vm_object_offset_t	orig_start;
	vm_object_offset_t	target_start;
	vm_object_offset_t	offset;
	vm_behavior_t		behavior;
	boolean_t		look_behind = TRUE;
	boolean_t		look_ahead  = TRUE;
	boolean_t		isSSD = FALSE;
	uint32_t		throttle_limit;
	<span class="enscript-type">int</span>			sequential_run;
	<span class="enscript-type">int</span>			sequential_behavior = VM_BEHAVIOR_SEQUENTIAL;
	vm_size_t		max_ph_size;
	vm_size_t		min_ph_size;

	assert( !(*length &amp; PAGE_MASK));
	assert( !(*start &amp; PAGE_MASK_64));

	<span class="enscript-comment">/*
	 * remember maxiumum length of run requested
	 */</span>
	max_length = *length;
	<span class="enscript-comment">/*
	 * we'll always return a cluster size of at least
	 * 1 page, since the original fault must always
	 * be processed
	 */</span>
	*length = PAGE_SIZE;
	*io_streaming = 0;

	<span class="enscript-keyword">if</span> (speculative_reads_disabled || fault_info == NULL) {
	        <span class="enscript-comment">/*
		 * no cluster... just fault the page in
		 */</span>
	        <span class="enscript-keyword">return</span>;
	}
	orig_start = *start;
	target_start = orig_start;
	cluster_size = round_page(fault_info-&gt;cluster_size);
	behavior = fault_info-&gt;behavior;

	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (object-&gt;pager == MEMORY_OBJECT_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	<span class="enscript-comment">/* pager is gone for this object, nothing more to do */</span>

	<span class="enscript-keyword">if</span> (!ignore_is_ssd)
		vnode_pager_get_isSSD(object-&gt;pager, &amp;isSSD);

	min_ph_size = round_page(preheat_min_bytes);
	max_ph_size = round_page(preheat_max_bytes);

	<span class="enscript-keyword">if</span> (isSSD) {
		min_ph_size /= 2;
		max_ph_size /= 8;
	}
	<span class="enscript-keyword">if</span> (min_ph_size &lt; PAGE_SIZE)
		min_ph_size = PAGE_SIZE;

	<span class="enscript-keyword">if</span> (max_ph_size &lt; PAGE_SIZE)
		max_ph_size = PAGE_SIZE;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (max_ph_size &gt; MAX_UPL_TRANSFER_BYTES)
		max_ph_size = MAX_UPL_TRANSFER_BYTES;

	<span class="enscript-keyword">if</span> (max_length &gt; max_ph_size) 
	        max_length = max_ph_size;

	<span class="enscript-keyword">if</span> (max_length &lt;= PAGE_SIZE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (object-&gt;internal)
	        object_size = object-&gt;vo_size;
	<span class="enscript-keyword">else</span>
	        vnode_pager_get_object_size(object-&gt;pager, &amp;object_size);

	object_size = round_page_64(object_size);

	<span class="enscript-keyword">if</span> (orig_start &gt;= object_size) {
	        <span class="enscript-comment">/*
		 * fault occurred beyond the EOF...
		 * we need to punt w/o changing the
		 * starting offset
		 */</span>
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (object-&gt;pages_used &gt; object-&gt;pages_created) {
	        <span class="enscript-comment">/*
		 * must have wrapped our 32 bit counters
		 * so reset
		 */</span>
 	        object-&gt;pages_used = object-&gt;pages_created = 0;
	}
	<span class="enscript-keyword">if</span> ((sequential_run = object-&gt;sequential)) {
		  <span class="enscript-keyword">if</span> (sequential_run &lt; 0) {
		          sequential_behavior = VM_BEHAVIOR_RSEQNTL;
			  sequential_run = 0 - sequential_run;
		  } <span class="enscript-keyword">else</span> {
		          sequential_behavior = VM_BEHAVIOR_SEQUENTIAL;
		  }

	}
	<span class="enscript-keyword">switch</span> (behavior) {

	<span class="enscript-reference">default</span>:
	        behavior = VM_BEHAVIOR_DEFAULT;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_DEFAULT</span>:
	        <span class="enscript-keyword">if</span> (object-&gt;internal &amp;&amp; fault_info-&gt;user_tag == VM_MEMORY_STACK)
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-keyword">if</span> (sequential_run &gt;= (3 * PAGE_SIZE)) {
		        pre_heat_size = sequential_run + PAGE_SIZE;

			<span class="enscript-keyword">if</span> (sequential_behavior == VM_BEHAVIOR_SEQUENTIAL)
			        look_behind = FALSE;
			<span class="enscript-keyword">else</span>
			        look_ahead = FALSE;

			*io_streaming = 1;
		} <span class="enscript-keyword">else</span> {

			<span class="enscript-keyword">if</span> (object-&gt;pages_created &lt; (20 * (min_ph_size &gt;&gt; PAGE_SHIFT))) {
			        <span class="enscript-comment">/*
				 * prime the pump
				 */</span>
			        pre_heat_size = min_ph_size;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Linear growth in PH size: The maximum size is max_length...
				 * this cacluation will result in a size that is neither a 
				 * power of 2 nor a multiple of PAGE_SIZE... so round
				 * it up to the nearest PAGE_SIZE boundary
				 */</span>
				pre_heat_size = (max_length * (uint64_t)object-&gt;pages_used) / object-&gt;pages_created;

				<span class="enscript-keyword">if</span> (pre_heat_size &lt; min_ph_size)
					pre_heat_size = min_ph_size;
				<span class="enscript-keyword">else</span>
					pre_heat_size = round_page(pre_heat_size);
			}
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_RANDOM</span>:
	        <span class="enscript-keyword">if</span> ((pre_heat_size = cluster_size) &lt;= PAGE_SIZE)
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	        <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_SEQUENTIAL</span>:
	        <span class="enscript-keyword">if</span> ((pre_heat_size = cluster_size) == 0)
		        pre_heat_size = sequential_run + PAGE_SIZE;
		look_behind = FALSE;
		*io_streaming = 1;

	        <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_RSEQNTL</span>:
	        <span class="enscript-keyword">if</span> ((pre_heat_size = cluster_size) == 0)
		        pre_heat_size = sequential_run + PAGE_SIZE;
		look_ahead = FALSE;
		*io_streaming = 1;

	        <span class="enscript-keyword">break</span>;

	}
	throttle_limit = (uint32_t) max_length;
	assert(throttle_limit == max_length);

	<span class="enscript-keyword">if</span> (vnode_pager_get_throttle_io_limit(object-&gt;pager, &amp;throttle_limit) == KERN_SUCCESS) {
		<span class="enscript-keyword">if</span> (max_length &gt; throttle_limit)
			max_length = throttle_limit;
	}
	<span class="enscript-keyword">if</span> (pre_heat_size &gt; max_length)
	        pre_heat_size = max_length;

	<span class="enscript-keyword">if</span> (behavior == VM_BEHAVIOR_DEFAULT &amp;&amp; (pre_heat_size &gt; min_ph_size)) {

		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> consider_free = vm_page_free_count + vm_page_cleaned_count;
		
		<span class="enscript-keyword">if</span> (consider_free &lt; vm_page_throttle_limit) {
			pre_heat_size = trunc_page(pre_heat_size / 16);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (consider_free &lt; vm_page_free_target) {
			pre_heat_size = trunc_page(pre_heat_size / 4);
		}
		
		<span class="enscript-keyword">if</span> (pre_heat_size &lt; min_ph_size)
			pre_heat_size = min_ph_size;
	}
	<span class="enscript-keyword">if</span> (look_ahead == TRUE) {
	        <span class="enscript-keyword">if</span> (look_behind == TRUE) { 
			<span class="enscript-comment">/*
			 * if we get here its due to a random access... 
			 * so we want to center the original fault address
			 * within the cluster we will issue... make sure
			 * to calculate 'head_size' as a multiple of PAGE_SIZE...
			 * 'pre_heat_size' is a multiple of PAGE_SIZE but not
			 * necessarily an even number of pages so we need to truncate
			 * the result to a PAGE_SIZE boundary
			 */</span>
			head_size = trunc_page(pre_heat_size / 2);

			<span class="enscript-keyword">if</span> (target_start &gt; head_size)
				target_start -= head_size;
			<span class="enscript-keyword">else</span>
				target_start = 0;

			<span class="enscript-comment">/*
			 * 'target_start' at this point represents the beginning offset
			 * of the cluster we are considering... 'orig_start' will be in
			 * the center of this cluster if we didn't have to clip the start
			 * due to running into the start of the file
			 */</span>
		}
	        <span class="enscript-keyword">if</span> ((target_start + pre_heat_size) &gt; object_size)
		        pre_heat_size = (vm_size_t)(round_page_64(object_size - target_start));
		<span class="enscript-comment">/*
		 * at this point caclulate the number of pages beyond the original fault
		 * address that we want to consider... this is guaranteed not to extend beyond
		 * the current EOF...
		 */</span>
		assert((vm_size_t)(orig_start - target_start) == (orig_start - target_start));
	        tail_size = pre_heat_size - (vm_size_t)(orig_start - target_start) - PAGE_SIZE;
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (pre_heat_size &gt; target_start) {
			<span class="enscript-comment">/*
			 * since pre_heat_size is always smaller then 2^32,
			 * if it is larger then target_start (a 64 bit value)
			 * it is safe to clip target_start to 32 bits
			 */</span>
	                pre_heat_size = (vm_size_t) target_start;
		}
		tail_size = 0;
	}
	assert( !(target_start &amp; PAGE_MASK_64));
	assert( !(pre_heat_size &amp; PAGE_MASK));

	<span class="enscript-keyword">if</span> (pre_heat_size &lt;= PAGE_SIZE)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (look_behind == TRUE) {
	        <span class="enscript-comment">/*
		 * take a look at the pages before the original
		 * faulting offset... recalculate this in case
		 * we had to clip 'pre_heat_size' above to keep 
		 * from running past the EOF.
		 */</span>
	        head_size = pre_heat_size - tail_size - PAGE_SIZE;

	        <span class="enscript-keyword">for</span> (offset = orig_start - PAGE_SIZE_64; head_size; offset -= PAGE_SIZE_64, head_size -= PAGE_SIZE) {
		        <span class="enscript-comment">/*
			 * don't poke below the lowest offset 
			 */</span>
		        <span class="enscript-keyword">if</span> (offset &lt; fault_info-&gt;lo_offset)
			        <span class="enscript-keyword">break</span>;
		        <span class="enscript-comment">/*
			 * for external objects and internal objects w/o an existence map
			 * vm_externl_state_get will return VM_EXTERNAL_STATE_UNKNOWN
			 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
		        <span class="enscript-keyword">if</span> (vm_external_state_get(object-&gt;existence_map, offset) == VM_EXTERNAL_STATE_ABSENT) {
			        <span class="enscript-comment">/*
				 * we know for a fact that the pager can't provide the page
				 * so don't include it or any pages beyond it in this cluster
				 */</span>
			        <span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGEMAP */</span>
			<span class="enscript-keyword">if</span> (VM_COMPRESSOR_PAGER_STATE_GET(object, offset)
			    == VM_EXTERNAL_STATE_ABSENT) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (vm_page_lookup(object, offset) != VM_PAGE_NULL) {
			        <span class="enscript-comment">/*
				 * don't bridge resident pages
				 */</span>
			        <span class="enscript-keyword">break</span>;
			}
			*start = offset;
			*length += PAGE_SIZE;
		}
	}
	<span class="enscript-keyword">if</span> (look_ahead == TRUE) {
	        <span class="enscript-keyword">for</span> (offset = orig_start + PAGE_SIZE_64; tail_size; offset += PAGE_SIZE_64, tail_size -= PAGE_SIZE) {
		        <span class="enscript-comment">/*
			 * don't poke above the highest offset 
			 */</span>
		        <span class="enscript-keyword">if</span> (offset &gt;= fault_info-&gt;hi_offset)
			        <span class="enscript-keyword">break</span>;
			assert(offset &lt; object_size);

		        <span class="enscript-comment">/*
			 * for external objects and internal objects w/o an existence map
			 * vm_externl_state_get will return VM_EXTERNAL_STATE_UNKNOWN
			 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
		        <span class="enscript-keyword">if</span> (vm_external_state_get(object-&gt;existence_map, offset) == VM_EXTERNAL_STATE_ABSENT) {
			        <span class="enscript-comment">/*
				 * we know for a fact that the pager can't provide the page
				 * so don't include it or any pages beyond it in this cluster
				 */</span>
			        <span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGEMAP */</span>
			<span class="enscript-keyword">if</span> (VM_COMPRESSOR_PAGER_STATE_GET(object, offset) == VM_EXTERNAL_STATE_ABSENT) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (vm_page_lookup(object, offset) != VM_PAGE_NULL) {
			        <span class="enscript-comment">/*
				 * don't bridge resident pages
				 */</span>
			        <span class="enscript-keyword">break</span>;
			}
			*length += PAGE_SIZE;
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (*length &gt; max_length)
		*length = max_length;

	vm_object_unlock(object);
	
	DTRACE_VM1(clustersize, vm_size_t, *length);
}


<span class="enscript-comment">/*
 * Allow manipulation of individual page state.  This is actually part of
 * the UPL regimen but takes place on the VM object rather than on a UPL
 */</span>

kern_return_t
<span class="enscript-function-name">vm_object_page_op</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	<span class="enscript-type">int</span>			ops,
	ppnum_t			*phys_entry,
	<span class="enscript-type">int</span>			*flags)
{
	vm_page_t		dst_page;

	vm_object_lock(object);

	<span class="enscript-keyword">if</span>(ops &amp; UPL_POP_PHYSICAL) {
		<span class="enscript-keyword">if</span>(object-&gt;phys_contiguous) {
			<span class="enscript-keyword">if</span> (phys_entry) {
				*phys_entry = (ppnum_t)
					(object-&gt;vo_shadow_offset &gt;&gt; PAGE_SHIFT);
			}
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		} <span class="enscript-keyword">else</span> {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span> KERN_INVALID_OBJECT;
		}
	}
	<span class="enscript-keyword">if</span>(object-&gt;phys_contiguous) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> KERN_INVALID_OBJECT;
	}

	<span class="enscript-keyword">while</span>(TRUE) {
		<span class="enscript-keyword">if</span>((dst_page = vm_page_lookup(object,offset)) == VM_PAGE_NULL) {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}

		<span class="enscript-comment">/* Sync up on getting the busy bit */</span>
		<span class="enscript-keyword">if</span>((dst_page-&gt;busy || dst_page-&gt;cleaning) &amp;&amp; 
			   (((ops &amp; UPL_POP_SET) &amp;&amp; 
			   (ops &amp; UPL_POP_BUSY)) || (ops &amp; UPL_POP_DUMP))) {
			<span class="enscript-comment">/* someone else is playing with the page, we will */</span>
			<span class="enscript-comment">/* have to wait */</span>
			PAGE_SLEEP(object, dst_page, THREAD_UNINT);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_DUMP) {
			<span class="enscript-keyword">if</span> (dst_page-&gt;pmapped == TRUE)
			        pmap_disconnect(dst_page-&gt;phys_page);

			VM_PAGE_FREE(dst_page);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (flags) {
		        *flags = 0;

			<span class="enscript-comment">/* Get the condition of flags before requested ops */</span>
			<span class="enscript-comment">/* are undertaken */</span>

			<span class="enscript-keyword">if</span>(dst_page-&gt;dirty) *flags |= UPL_POP_DIRTY;
			<span class="enscript-keyword">if</span>(dst_page-&gt;pageout) *flags |= UPL_POP_PAGEOUT;
			<span class="enscript-keyword">if</span>(dst_page-&gt;precious) *flags |= UPL_POP_PRECIOUS;
			<span class="enscript-keyword">if</span>(dst_page-&gt;absent) *flags |= UPL_POP_ABSENT;
			<span class="enscript-keyword">if</span>(dst_page-&gt;busy) *flags |= UPL_POP_BUSY;
		}

		<span class="enscript-comment">/* The caller should have made a call either contingent with */</span>
		<span class="enscript-comment">/* or prior to this call to set UPL_POP_BUSY */</span>
		<span class="enscript-keyword">if</span>(ops &amp; UPL_POP_SET) {
			<span class="enscript-comment">/* The protection granted with this assert will */</span>
			<span class="enscript-comment">/* not be complete.  If the caller violates the */</span>
			<span class="enscript-comment">/* convention and attempts to change page state */</span>
			<span class="enscript-comment">/* without first setting busy we may not see it */</span>
			<span class="enscript-comment">/* because the page may already be busy.  However */</span>
			<span class="enscript-comment">/* if such violations occur we will assert sooner */</span>
			<span class="enscript-comment">/* or later. */</span>
			assert(dst_page-&gt;busy || (ops &amp; UPL_POP_BUSY));
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_DIRTY) {
				SET_PAGE_DIRTY(dst_page, FALSE);
			}
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_PAGEOUT) dst_page-&gt;pageout = TRUE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_PRECIOUS) dst_page-&gt;precious = TRUE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_ABSENT) dst_page-&gt;absent = TRUE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_BUSY) dst_page-&gt;busy = TRUE;
		}

		<span class="enscript-keyword">if</span>(ops &amp; UPL_POP_CLR) {
			assert(dst_page-&gt;busy);
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_DIRTY) dst_page-&gt;dirty = FALSE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_PAGEOUT) dst_page-&gt;pageout = FALSE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_PRECIOUS) dst_page-&gt;precious = FALSE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_ABSENT) dst_page-&gt;absent = FALSE;
			<span class="enscript-keyword">if</span> (ops &amp; UPL_POP_BUSY) {
			        dst_page-&gt;busy = FALSE;
				PAGE_WAKEUP(dst_page);
			}
		}

		<span class="enscript-keyword">if</span> (dst_page-&gt;encrypted) {
			<span class="enscript-comment">/*
			 * ENCRYPTED SWAP:
			 * We need to decrypt this encrypted page before the
			 * caller can access its contents.
			 * But if the caller really wants to access the page's
			 * contents, they have to keep the page &quot;busy&quot;.
			 * Otherwise, the page could get recycled or re-encrypted
			 * at any time.
			 */</span>
			<span class="enscript-keyword">if</span> ((ops &amp; UPL_POP_SET) &amp;&amp; (ops &amp; UPL_POP_BUSY) &amp;&amp;
			    dst_page-&gt;busy) {
				<span class="enscript-comment">/*
				 * The page is stable enough to be accessed by
				 * the caller, so make sure its contents are
				 * not encrypted.
				 */</span>
				vm_page_decrypt(dst_page, 0);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * The page is not busy, so don't bother
				 * decrypting it, since anything could
				 * happen to it between now and when the
				 * caller wants to access it.
				 * We should not give the caller access
				 * to this page.
				 */</span>
				assert(!phys_entry);
			}
		}

		<span class="enscript-keyword">if</span> (phys_entry) {
			<span class="enscript-comment">/*
			 * The physical page number will remain valid
			 * only if the page is kept busy.
			 * ENCRYPTED SWAP: make sure we don't let the
			 * caller access an encrypted page.
			 */</span>
			assert(dst_page-&gt;busy);
			assert(!dst_page-&gt;encrypted);
			*phys_entry = dst_page-&gt;phys_page;
		}

		<span class="enscript-keyword">break</span>;
	}

	vm_object_unlock(object);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
				
}

<span class="enscript-comment">/*
 * vm_object_range_op offers performance enhancement over 
 * vm_object_page_op for page_op functions which do not require page 
 * level state to be returned from the call.  Page_op was created to provide 
 * a low-cost alternative to page manipulation via UPLs when only a single 
 * page was involved.  The range_op call establishes the ability in the _op 
 * family of functions to work on multiple pages where the lack of page level
 * state handling allows the caller to avoid the overhead of the upl structures.
 */</span>

kern_return_t
<span class="enscript-function-name">vm_object_range_op</span>(
	vm_object_t		object,
	vm_object_offset_t	offset_beg,
	vm_object_offset_t	offset_end,
	<span class="enscript-type">int</span>                     ops,
	uint32_t		*range)
{
        vm_object_offset_t	offset;
	vm_page_t		dst_page;

	<span class="enscript-keyword">if</span> (offset_end - offset_beg &gt; (uint32_t) -1) {
		<span class="enscript-comment">/* range is too big and would overflow &quot;*range&quot; */</span>
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	} 
	<span class="enscript-keyword">if</span> (object-&gt;resident_page_count == 0) {
	        <span class="enscript-keyword">if</span> (range) {
		        <span class="enscript-keyword">if</span> (ops &amp; UPL_ROP_PRESENT) {
			        *range = 0;
			} <span class="enscript-keyword">else</span> {
			        *range = (uint32_t) (offset_end - offset_beg);
				assert(*range == (offset_end - offset_beg));
			}
		}
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (object-&gt;phys_contiguous) {
		vm_object_unlock(object);
	        <span class="enscript-keyword">return</span> KERN_INVALID_OBJECT;
	}
	
	offset = offset_beg &amp; ~PAGE_MASK_64;

	<span class="enscript-keyword">while</span> (offset &lt; offset_end) {
		dst_page = vm_page_lookup(object, offset);
		<span class="enscript-keyword">if</span> (dst_page != VM_PAGE_NULL) {
			<span class="enscript-keyword">if</span> (ops &amp; UPL_ROP_DUMP) {
				<span class="enscript-keyword">if</span> (dst_page-&gt;busy || dst_page-&gt;cleaning) {
					<span class="enscript-comment">/*
					 * someone else is playing with the 
					 * page, we will have to wait
					 */</span>
				        PAGE_SLEEP(object, dst_page, THREAD_UNINT);
					<span class="enscript-comment">/*
					 * need to relook the page up since it's
					 * state may have changed while we slept
					 * it might even belong to a different object
					 * at this point
					 */</span>
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (dst_page-&gt;laundry) {
					dst_page-&gt;pageout = FALSE;
					
					vm_pageout_steal_laundry(dst_page, FALSE);
				}
				<span class="enscript-keyword">if</span> (dst_page-&gt;pmapped == TRUE)
				        pmap_disconnect(dst_page-&gt;phys_page);

				VM_PAGE_FREE(dst_page);

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ops &amp; UPL_ROP_ABSENT)
					   &amp;&amp; (!dst_page-&gt;absent || dst_page-&gt;busy)) {
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ops &amp; UPL_ROP_PRESENT)
		        <span class="enscript-keyword">break</span>;

		offset += PAGE_SIZE;
	}
	vm_object_unlock(object);

	<span class="enscript-keyword">if</span> (range) {
	        <span class="enscript-keyword">if</span> (offset &gt; offset_end)
		        offset = offset_end;
		<span class="enscript-keyword">if</span>(offset &gt; offset_beg) {
			*range = (uint32_t) (offset - offset_beg);
			assert(*range == (offset - offset_beg));
		} <span class="enscript-keyword">else</span> {
			*range = 0;
		}
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Used to point a pager directly to a range of memory (when the pager may be associated
 *   with a non-device vnode).  Takes a virtual address, an offset, and a size.  We currently
 *   expect that the virtual address will denote the start of a range that is physically contiguous.
 */</span>
kern_return_t <span class="enscript-function-name">pager_map_to_phys_contiguous</span>(
	memory_object_control_t	object,
	memory_object_offset_t	offset,
	addr64_t		base_vaddr,
	vm_size_t		size)
{
	ppnum_t page_num;
	boolean_t clobbered_private;
	kern_return_t retval;
	vm_object_t pager_object;

	page_num = pmap_find_phys(kernel_pmap, base_vaddr);

	<span class="enscript-keyword">if</span> (!page_num) {
		retval = KERN_FAILURE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	pager_object = memory_object_control_to_vm_object(object);

	<span class="enscript-keyword">if</span> (!pager_object) {
		retval = KERN_FAILURE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	clobbered_private = pager_object-&gt;private;
	pager_object-&gt;private = TRUE;
	retval = vm_object_populate_with_private(pager_object, offset, page_num, size);

	<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS)
		pager_object-&gt;private = clobbered_private;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> retval;
}

uint32_t scan_object_collision = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_lock</span>(vm_object_t object)
{
        <span class="enscript-keyword">if</span> (object == vm_pageout_scan_wants_object) {
	        scan_object_collision++;
	        mutex_pause(2);
	}
        lck_rw_lock_exclusive(&amp;object-&gt;Lock);
}

boolean_t
<span class="enscript-function-name">vm_object_lock_avoid</span>(vm_object_t object)
{
        <span class="enscript-keyword">if</span> (object == vm_pageout_scan_wants_object) {
	        scan_object_collision++;
		<span class="enscript-keyword">return</span> TRUE;
	}
	<span class="enscript-keyword">return</span> FALSE;
}

boolean_t
<span class="enscript-function-name">_vm_object_lock_try</span>(vm_object_t object)
{
	<span class="enscript-keyword">return</span> (lck_rw_try_lock_exclusive(&amp;object-&gt;Lock));
}

boolean_t
<span class="enscript-function-name">vm_object_lock_try</span>(vm_object_t object)
{
	<span class="enscript-comment">/*
	 * Called from hibernate path so check before blocking.
	 */</span>
	<span class="enscript-keyword">if</span> (vm_object_lock_avoid(object) &amp;&amp; ml_get_interrupts_enabled() &amp;&amp; get_preemption_level()==0) {
		mutex_pause(2);
	}
	<span class="enscript-keyword">return</span> _vm_object_lock_try(object);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_lock_shared</span>(vm_object_t object)
{
        <span class="enscript-keyword">if</span> (vm_object_lock_avoid(object)) {
	        mutex_pause(2);
	}
	lck_rw_lock_shared(&amp;object-&gt;Lock);
}

boolean_t
<span class="enscript-function-name">vm_object_lock_try_shared</span>(vm_object_t object)
{
        <span class="enscript-keyword">if</span> (vm_object_lock_avoid(object)) {
	        mutex_pause(2);
	}
	<span class="enscript-keyword">return</span> (lck_rw_try_lock_shared(&amp;object-&gt;Lock));
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_object_change_wimg_mode_count = 0;

<span class="enscript-comment">/*
 * The object must be locked
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_change_wimg_mode</span>(vm_object_t object, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> wimg_mode)
{
	vm_page_t p;

	vm_object_lock_assert_exclusive(object);

	vm_object_paging_wait(object, THREAD_UNINT);

	queue_iterate(&amp;object-&gt;memq, p, vm_page_t, listq) {

		<span class="enscript-keyword">if</span> (!p-&gt;fictitious)
			pmap_set_cache_attributes(p-&gt;phys_page, wimg_mode);
	}
	<span class="enscript-keyword">if</span> (wimg_mode == VM_WIMG_USE_DEFAULT)
		object-&gt;set_cache_attr = FALSE;
	<span class="enscript-keyword">else</span>
		object-&gt;set_cache_attr = TRUE;

	object-&gt;wimg_bits = wimg_mode;

	vm_object_change_wimg_mode_count++;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

kern_return_t <span class="enscript-function-name">vm_object_pack</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*purgeable_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*wired_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*clean_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*dirty_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	dirty_budget,
	boolean_t	*shared,
	vm_object_t	src_object,
	<span class="enscript-type">struct</span> default_freezer_handle *df_handle)
{
	kern_return_t	kr = KERN_SUCCESS;
	
	vm_object_lock(src_object);

	*purgeable_count = *wired_count = *clean_count = *dirty_count = 0;
	*shared = FALSE;

	<span class="enscript-keyword">if</span> (!src_object-&gt;alive || src_object-&gt;terminating){
		kr = KERN_FAILURE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (src_object-&gt;purgable == VM_PURGABLE_VOLATILE) {
		*purgeable_count = src_object-&gt;resident_page_count;
		
		<span class="enscript-comment">/* If the default freezer handle is null, we're just walking the pages to discover how many can be hibernated */</span>
		<span class="enscript-keyword">if</span> (df_handle != NULL) {
			purgeable_q_t queue;
			<span class="enscript-comment">/* object should be on a queue */</span>
			assert(src_object-&gt;objq.next != NULL &amp;&amp;
			       src_object-&gt;objq.prev != NULL);

			queue = vm_purgeable_object_remove(src_object);
			assert(queue);
			<span class="enscript-keyword">if</span> (src_object-&gt;purgeable_when_ripe) {
				vm_page_lock_queues();
				vm_purgeable_token_delete_first(queue);
				vm_page_unlock_queues();
			}

			vm_object_purge(src_object, 0);
			assert(src_object-&gt;purgable == VM_PURGABLE_EMPTY);

			<span class="enscript-comment">/*
			 * This object was &quot;volatile&quot; so its pages must have
			 * already been accounted as &quot;volatile&quot;: no change
			 * in accounting now that it's &quot;empty&quot;.
			 */</span>
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (src_object-&gt;ref_count == 1) {
		vm_object_pack_pages(wired_count, clean_count, dirty_count, dirty_budget, src_object, df_handle);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (src_object-&gt;internal) {
			*shared = TRUE;
		}
	}
<span class="enscript-reference">done</span>:
	vm_object_unlock(src_object);
	
	<span class="enscript-keyword">return</span> kr;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pack_pages</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*wired_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*clean_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*dirty_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		dirty_budget,
	vm_object_t		src_object,
	<span class="enscript-type">struct</span> default_freezer_handle *df_handle)
{
	vm_page_t p, next;

	next = (vm_page_t)queue_first(&amp;src_object-&gt;memq);

	<span class="enscript-keyword">while</span> (!queue_end(&amp;src_object-&gt;memq, (queue_entry_t)next)) {
		p = next;
		next = (vm_page_t)queue_next(&amp;next-&gt;listq);
		
		<span class="enscript-comment">/* Finish up if we've hit our pageout limit */</span>
		<span class="enscript-keyword">if</span> (dirty_budget &amp;&amp; (dirty_budget == *dirty_count)) {
			<span class="enscript-keyword">break</span>;
		}
		assert(!p-&gt;laundry);

		<span class="enscript-keyword">if</span> (p-&gt;fictitious || p-&gt;busy ) 
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (p-&gt;absent || p-&gt;unusual || p-&gt;error)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(p)) {
			(*wired_count)++;
			<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-keyword">if</span> (df_handle == NULL) {
			<span class="enscript-keyword">if</span> (p-&gt;dirty || pmap_is_modified(p-&gt;phys_page)) {
				(*dirty_count)++;
			} <span class="enscript-keyword">else</span> {
				(*clean_count)++;				
			}
			<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-keyword">if</span> (p-&gt;cleaning) {
			p-&gt;pageout = TRUE;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (p-&gt;pmapped == TRUE) {
			<span class="enscript-type">int</span> refmod_state;
		 	refmod_state = pmap_disconnect(p-&gt;phys_page);
			<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_MODIFIED) {
				SET_PAGE_DIRTY(p, FALSE);
			}
		}
		
		<span class="enscript-keyword">if</span> (p-&gt;dirty) {
			default_freezer_pack_page(p, df_handle);	
			(*dirty_count)++;
		}
		<span class="enscript-keyword">else</span> {
			VM_PAGE_FREE(p);
			(*clean_count)++;
		}
	}
}


<span class="enscript-comment">/*
 * This routine does the &quot;relocation&quot; of previously
 * compressed pages belonging to this object that are
 * residing in a number of compressed segments into
 * a set of compressed segments dedicated to hold
 * compressed pages belonging to this object.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *freezer_chead;
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *freezer_compressor_scratch_buf;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> c_freezer_compression_count;
<span class="enscript-type">extern</span> AbsoluteTime c_freezer_last_yield_ts;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_FREE_BATCH</span>	32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FREEZER_DUTY_CYCLE_ON_MS</span>	5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FREEZER_DUTY_CYCLE_OFF_MS</span>	5

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">c_freezer_should_yield</span>(<span class="enscript-type">void</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">c_freezer_should_yield</span>()
{
	AbsoluteTime	cur_time;
	uint64_t	nsecs;

	assert(c_freezer_last_yield_ts);
	clock_get_uptime(&amp;cur_time);

	SUB_ABSOLUTETIME(&amp;cur_time, &amp;c_freezer_last_yield_ts);
	absolutetime_to_nanoseconds(cur_time, &amp;nsecs);

	<span class="enscript-keyword">if</span> (nsecs &gt; 1000 * 1000 * FREEZER_DUTY_CYCLE_ON_MS)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_compressed_freezer_done</span>()
{
	vm_compressor_finished_filling(&amp;freezer_chead);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_compressed_freezer_pageout</span>(
	vm_object_t object)
{
	vm_page_t 			p;
	vm_page_t   			local_freeq = NULL;
	<span class="enscript-type">int</span>         			local_freed = 0;
	kern_return_t			retval = KERN_SUCCESS;
	<span class="enscript-type">int</span>				obj_resident_page_count_snapshot = 0;

	assert(object != VM_OBJECT_NULL);

	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized || object-&gt;pager == MEMORY_OBJECT_NULL)  {
			
		<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized) {

			vm_object_collapse(object, (vm_object_offset_t) 0, TRUE);

			<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized)
				vm_object_compressor_pager_create(object);
		}

		<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized || object-&gt;pager == MEMORY_OBJECT_NULL)  {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span>;
		}
	}
			
	<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {
		vm_object_offset_t	curr_offset = 0;

		<span class="enscript-comment">/*
		 * Go through the object and make sure that any
		 * previously compressed pages are relocated into
		 * a compressed segment associated with our &quot;freezer_chead&quot;.
		 */</span>
		<span class="enscript-keyword">while</span> (curr_offset &lt; object-&gt;vo_size) {

			curr_offset = vm_compressor_pager_next_compressed(object-&gt;pager, curr_offset);
	
			<span class="enscript-keyword">if</span> (curr_offset == (vm_object_offset_t) -1)
				<span class="enscript-keyword">break</span>;

			retval = vm_compressor_pager_relocate(object-&gt;pager, curr_offset, &amp;freezer_chead);

			<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS)
				<span class="enscript-keyword">break</span>;

			curr_offset += PAGE_SIZE_64;
		}
	}

	<span class="enscript-comment">/*
	 * We can't hold the object lock while heading down into the compressed pager
	 * layer because we might need the kernel map lock down there to allocate new
	 * compressor data structures. And if this same object is mapped in the kernel
	 * and there's a fault on it, then that thread will want the object lock while
	 * holding the kernel map lock.
	 *
	 * Since we are going to drop/grab the object lock repeatedly, we must make sure
	 * we won't be stuck in an infinite loop if the same page(s) keep getting
	 * decompressed. So we grab a snapshot of the number of pages in the object and
	 * we won't process any more than that number of pages.
	 */</span>

	obj_resident_page_count_snapshot = object-&gt;resident_page_count;

	vm_object_activity_begin(object);

	<span class="enscript-keyword">while</span> ((obj_resident_page_count_snapshot--) &amp;&amp; !queue_empty(&amp;object-&gt;memq)) {

		p = (vm_page_t)queue_first(&amp;object-&gt;memq);

		KERNEL_DEBUG(0xe0430004 | DBG_FUNC_START, object, local_freed, 0, 0, 0);

		vm_page_lockspin_queues();

		<span class="enscript-keyword">if</span> (p-&gt;cleaning || p-&gt;fictitious || p-&gt;busy || p-&gt;absent || p-&gt;unusual || p-&gt;error || VM_PAGE_WIRED(p)) {
			<span class="enscript-keyword">if</span> (p-&gt;cleaning)
				p-&gt;pageout = TRUE;

			vm_page_unlock_queues();

			KERNEL_DEBUG(0xe0430004 | DBG_FUNC_END, object, local_freed, 1, 0, 0);

			queue_remove(&amp;object-&gt;memq, p, vm_page_t, listq);
			queue_enter(&amp;object-&gt;memq, p, vm_page_t, listq);

			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (p-&gt;pmapped == TRUE) {
			<span class="enscript-type">int</span> refmod_state, pmap_flags;

			<span class="enscript-keyword">if</span> (p-&gt;dirty || p-&gt;precious) {
				pmap_flags = PMAP_OPTIONS_COMPRESSOR;
			} <span class="enscript-keyword">else</span> {
				pmap_flags = PMAP_OPTIONS_COMPRESSOR_IFF_MODIFIED;
			}

			refmod_state = pmap_disconnect_options(p-&gt;phys_page, pmap_flags, NULL);
			<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_MODIFIED) {
				SET_PAGE_DIRTY(p, FALSE);
			}
		}
		
		<span class="enscript-keyword">if</span> (p-&gt;dirty == FALSE &amp;&amp; p-&gt;precious == FALSE) {
			<span class="enscript-comment">/*
			 * Clean and non-precious page.
			 */</span>
			vm_page_unlock_queues();
			VM_PAGE_FREE(p);

			KERNEL_DEBUG(0xe0430004 | DBG_FUNC_END, object, local_freed, 2, 0, 0);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (p-&gt;laundry) {
			p-&gt;pageout = FALSE;
			vm_pageout_steal_laundry(p, TRUE);
		}

		vm_page_queues_remove(p);
		vm_page_unlock_queues();


		<span class="enscript-comment">/*
		 * In case the compressor fails to compress this page, we need it at
		 * the back of the object memq so that we don't keep trying to process it.
		 * Make the move here while we have the object lock held.
		 */</span>

		queue_remove(&amp;object-&gt;memq, p, vm_page_t, listq);
		queue_enter(&amp;object-&gt;memq, p, vm_page_t, listq);

		<span class="enscript-comment">/*
		 * Grab an activity_in_progress here for vm_pageout_compress_page() to consume.
		 *
		 * Mark the page busy so no one messes with it while we have the object lock dropped.
		 */</span>

		p-&gt;busy = TRUE;

		vm_object_activity_begin(object);

		vm_object_unlock(object);

		<span class="enscript-comment">/*
		 * arg3 == FALSE  tells vm_pageout_compress_page that we don't hold the object lock and the pager may not be initialized.
		 */</span>
		<span class="enscript-keyword">if</span> (vm_pageout_compress_page(&amp;freezer_chead, freezer_compressor_scratch_buf, p, FALSE) == KERN_SUCCESS) {
			<span class="enscript-comment">/*
			 * page has already been un-tabled from the object via 'vm_page_remove'
			 */</span>
			p-&gt;pageq.next = (queue_entry_t)local_freeq;
			local_freeq = p;
			local_freed++;

			<span class="enscript-keyword">if</span> (local_freed &gt;= MAX_FREE_BATCH) {
		
				vm_page_free_list(local_freeq, TRUE);
				
				local_freeq = NULL;
				local_freed = 0;
			}
			c_freezer_compression_count++;
		}
		KERNEL_DEBUG(0xe0430004 | DBG_FUNC_END, object, local_freed, 0, 0, 0);

		<span class="enscript-keyword">if</span> (local_freed == 0 &amp;&amp; c_freezer_should_yield()) {

			thread_yield_internal(FREEZER_DUTY_CYCLE_OFF_MS);
			clock_get_uptime(&amp;c_freezer_last_yield_ts);
		}

		vm_object_lock(object);
	}

	<span class="enscript-keyword">if</span> (local_freeq) {
		vm_page_free_list(local_freeq, TRUE);
				
		local_freeq = NULL;
		local_freed = 0;
	}
	
	vm_object_activity_end(object);

	vm_object_unlock(object);

	<span class="enscript-keyword">if</span> (c_freezer_should_yield()) {

		thread_yield_internal(FREEZER_DUTY_CYCLE_OFF_MS);
		clock_get_uptime(&amp;c_freezer_last_yield_ts);
	}
}

kern_return_t
<span class="enscript-function-name">vm_object_pagein</span>(
	vm_object_t object)
{
	memory_object_t	pager;
	kern_return_t	kr;

	vm_object_lock(object);

	pager = object-&gt;pager;

	<span class="enscript-keyword">if</span> (!object-&gt;pager_ready || pager == MEMORY_OBJECT_NULL) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
	
	vm_object_paging_wait(object, THREAD_UNINT);
	vm_object_paging_begin(object);

	object-&gt;blocked_access = TRUE;
	vm_object_unlock(object);
	
	kr = memory_object_data_reclaim(pager, TRUE);

	vm_object_lock(object);

	object-&gt;blocked_access = FALSE;
	vm_object_paging_end(object);

	vm_object_unlock(object);
	
	<span class="enscript-keyword">return</span> kr;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pageout</span>(
	vm_object_t object)
{
	vm_page_t 			p, next;
	<span class="enscript-type">struct</span>	vm_pageout_queue 	*iq;
	boolean_t			need_unlock = TRUE;

	iq = &amp;vm_pageout_queue_internal;
	
	assert(object != VM_OBJECT_NULL );
	assert(!DEFAULT_PAGER_IS_ACTIVE &amp;&amp; !DEFAULT_FREEZER_IS_ACTIVE);
	
	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (!object-&gt;internal ||
	    object-&gt;terminating ||
	    !object-&gt;alive) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized || object-&gt;pager == MEMORY_OBJECT_NULL)  {
			
		<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized) {

			vm_object_collapse(object, (vm_object_offset_t) 0, TRUE);

			<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized)
				vm_object_compressor_pager_create(object);
		}

		<span class="enscript-keyword">if</span> (!object-&gt;pager_initialized || object-&gt;pager == MEMORY_OBJECT_NULL)  {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span>;
		}
	}
			
<span class="enscript-reference">ReScan</span>:	
	next = (vm_page_t)queue_first(&amp;object-&gt;memq);

	<span class="enscript-keyword">while</span> (!queue_end(&amp;object-&gt;memq, (queue_entry_t)next)) {
		p = next;
		next = (vm_page_t)queue_next(&amp;next-&gt;listq);
		
		<span class="enscript-keyword">if</span> (!(p-&gt;active || p-&gt;inactive || p-&gt;speculative) ||
		    p-&gt;encrypted_cleaning ||
		    p-&gt;cleaning ||
		    p-&gt;laundry ||
		    p-&gt;pageout ||
		    p-&gt;busy ||
		    p-&gt;absent ||
		    p-&gt;error ||
		    p-&gt;fictitious ||
		    VM_PAGE_WIRED(p)) {
			<span class="enscript-comment">/*
			 * Page is already being cleaned or can't be cleaned.
			 */</span>
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Throw to the pageout queue */</span>

		vm_page_lockspin_queues();
		need_unlock = TRUE;

		<span class="enscript-keyword">if</span> (vm_compressor_low_on_space()) {
			vm_page_unlock_queues();
			<span class="enscript-keyword">break</span>;		
		}

		<span class="enscript-keyword">if</span> (VM_PAGE_Q_THROTTLED(iq)) {
					
			iq-&gt;pgo_draining = TRUE;
					
			assert_wait((event_t) (&amp;iq-&gt;pgo_laundry + 1),
				    THREAD_INTERRUPTIBLE);
			vm_page_unlock_queues();
			vm_object_unlock(object);
					
			thread_block(THREAD_CONTINUE_NULL);

			vm_object_lock(object);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ReScan</span>;
		}

		assert(!p-&gt;fictitious);
		assert(!p-&gt;busy);
		assert(!p-&gt;absent);
		assert(!p-&gt;unusual);
		assert(!p-&gt;error);
		assert(!VM_PAGE_WIRED(p));
		assert(!p-&gt;cleaning);

		<span class="enscript-keyword">if</span> (p-&gt;pmapped == TRUE) {
			<span class="enscript-type">int</span> refmod_state;
			<span class="enscript-type">int</span> pmap_options;

			pmap_options = 0;
			<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE ||
			    DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {
				<span class="enscript-comment">/*
				 * Tell pmap the page should be accounted
				 * for as &quot;compressed&quot; if it's been modified.
				 */</span>
				pmap_options =
					PMAP_OPTIONS_COMPRESSOR_IFF_MODIFIED;
				<span class="enscript-keyword">if</span> (p-&gt;dirty || p-&gt;precious) {
					<span class="enscript-comment">/*
					 * We already know it's been modified,
					 * so tell pmap to account for it
					 * as &quot;compressed&quot;.
					 */</span>
					pmap_options = PMAP_OPTIONS_COMPRESSOR;
				}
			}
			refmod_state = pmap_disconnect_options(p-&gt;phys_page,
							       pmap_options,
							       NULL);
			<span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_MODIFIED) {
				SET_PAGE_DIRTY(p, FALSE);
			}
		}

		<span class="enscript-keyword">if</span> (!p-&gt;dirty &amp;&amp; !p-&gt;precious) {
			vm_page_unlock_queues();
			VM_PAGE_FREE(p);
			<span class="enscript-keyword">continue</span>;
		}

		vm_page_queues_remove(p);
		<span class="enscript-keyword">if</span> (vm_pageout_cluster(p, TRUE, FALSE, TRUE))
			need_unlock = FALSE;

		<span class="enscript-keyword">if</span> (need_unlock == TRUE)
			vm_page_unlock_queues();
	}

	vm_object_unlock(object);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_request_reprioritize</span>(vm_object_t o, uint64_t blkno, uint32_t len, <span class="enscript-type">int</span> prio)
{
	io_reprioritize_req_t 	req;
	<span class="enscript-type">struct</span> vnode 		*devvp = NULL;	

	<span class="enscript-keyword">if</span>(vnode_pager_get_object_devvp(o-&gt;pager, (uintptr_t *)&amp;devvp) != KERN_SUCCESS)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-comment">/*
	 * Create the request for I/O reprioritization.
	 * We use the noblock variant of zalloc because we're holding the object
	 * lock here and we could cause a deadlock in low memory conditions.
	 */</span>
	req = (io_reprioritize_req_t)zalloc_noblock(io_reprioritize_req_zone);
	<span class="enscript-keyword">if</span> (req == NULL)
		<span class="enscript-keyword">return</span>;
	req-&gt;blkno = blkno;
	req-&gt;len = len;
	req-&gt;priority = prio;
	req-&gt;devvp = devvp;

	<span class="enscript-comment">/* Insert request into the reprioritization list */</span>
	IO_REPRIORITIZE_LIST_LOCK();
	queue_enter(&amp;io_reprioritize_list, req, io_reprioritize_req_t, io_reprioritize_list);
	IO_REPRIORITIZE_LIST_UNLOCK();

	<span class="enscript-comment">/* Wakeup reprioritize thread */</span>
	IO_REPRIO_THREAD_WAKEUP();	

	<span class="enscript-keyword">return</span>;		
}	

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_decmp_upl_reprioritize</span>(upl_t upl, <span class="enscript-type">int</span> prio)
{
	<span class="enscript-type">int</span> offset;
	vm_object_t object;
	io_reprioritize_req_t 	req;
	<span class="enscript-type">struct</span> vnode            *devvp = NULL;
	uint64_t 		blkno;
	uint32_t 		len;
	upl_t 			io_upl;
	uint64_t 		*io_upl_reprio_info;
	<span class="enscript-type">int</span> 			io_upl_size;

	<span class="enscript-keyword">if</span> ((upl-&gt;flags &amp; UPL_TRACKED_BY_OBJECT) == 0 || (upl-&gt;flags &amp; UPL_EXPEDITE_SUPPORTED) == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* 
	 * We dont want to perform any allocations with the upl lock held since that might 
	 * result in a deadlock. If the system is low on memory, the pageout thread would 
	 * try to pageout stuff and might wait on this lock. If we are waiting for the memory to
	 * be freed up by the pageout thread, it would be a deadlock.
	 */</span>


	<span class="enscript-comment">/* First step is just to get the size of the upl to find out how big the reprio info is */</span>
	<span class="enscript-keyword">if</span>(!upl_try_lock(upl))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (upl-&gt;decmp_io_upl == NULL) {
		<span class="enscript-comment">/* The real I/O upl was destroyed by the time we came in here. Nothing to do. */</span>
		upl_unlock(upl);
		<span class="enscript-keyword">return</span>;
	}

	io_upl = upl-&gt;decmp_io_upl;
	assert((io_upl-&gt;flags &amp; UPL_DECMP_REAL_IO) != 0);
	io_upl_size = io_upl-&gt;size;
	upl_unlock(upl);
	
	<span class="enscript-comment">/* Now perform the allocation */</span>
	io_upl_reprio_info = (uint64_t *)kalloc(<span class="enscript-keyword">sizeof</span>(uint64_t) * (io_upl_size / PAGE_SIZE));
	<span class="enscript-keyword">if</span> (io_upl_reprio_info == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Now again take the lock, recheck the state and grab out the required info */</span>
	<span class="enscript-keyword">if</span>(!upl_try_lock(upl))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (upl-&gt;decmp_io_upl == NULL || upl-&gt;decmp_io_upl != io_upl) {
		<span class="enscript-comment">/* The real I/O upl was destroyed by the time we came in here. Nothing to do. */</span>
		upl_unlock(upl);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	memcpy(io_upl_reprio_info, io_upl-&gt;upl_reprio_info, <span class="enscript-keyword">sizeof</span>(uint64_t) * (io_upl_size / PAGE_SIZE));

	<span class="enscript-comment">/* Get the VM object for this UPL */</span>
	<span class="enscript-keyword">if</span> (io_upl-&gt;flags &amp; UPL_SHADOWED) {
		object = io_upl-&gt;map_object-&gt;shadow;
	} <span class="enscript-keyword">else</span> {
		object = io_upl-&gt;map_object;
	}

	<span class="enscript-comment">/* Get the dev vnode ptr for this object */</span>
	<span class="enscript-keyword">if</span>(!object || !object-&gt;pager || 
	   vnode_pager_get_object_devvp(object-&gt;pager, (uintptr_t *)&amp;devvp) != KERN_SUCCESS) {
		upl_unlock(upl);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	upl_unlock(upl);

	<span class="enscript-comment">/* Now we have all the information needed to do the expedite */</span>

	offset = 0;
	<span class="enscript-keyword">while</span> (offset &lt; io_upl_size) {
		blkno 	= io_upl_reprio_info[(offset / PAGE_SIZE)] &amp; UPL_REPRIO_INFO_MASK;
		len 	= (io_upl_reprio_info[(offset / PAGE_SIZE)] &gt;&gt; UPL_REPRIO_INFO_SHIFT) &amp; UPL_REPRIO_INFO_MASK;	

		<span class="enscript-comment">/*
		 * This implementation may cause some spurious expedites due to the 
		 * fact that we dont cleanup the blkno &amp; len from the upl_reprio_info 
		 * even after the I/O is complete. 
		 */</span>
		
		<span class="enscript-keyword">if</span> (blkno != 0 &amp;&amp; len != 0) {
			<span class="enscript-comment">/* Create the request for I/O reprioritization */</span>
       	 		req = (io_reprioritize_req_t)zalloc(io_reprioritize_req_zone);
        		assert(req != NULL);
        		req-&gt;blkno = blkno;
        		req-&gt;len = len;
        		req-&gt;priority = prio;
        		req-&gt;devvp = devvp;

        		<span class="enscript-comment">/* Insert request into the reprioritization list */</span>
        		IO_REPRIORITIZE_LIST_LOCK();
        		queue_enter(&amp;io_reprioritize_list, req, io_reprioritize_req_t, io_reprioritize_list);
        		IO_REPRIORITIZE_LIST_UNLOCK();		
			
			offset += len;
		} <span class="enscript-keyword">else</span> {
			offset += PAGE_SIZE;
		}
	}

	<span class="enscript-comment">/* Wakeup reprioritize thread */</span>
        IO_REPRIO_THREAD_WAKEUP();

<span class="enscript-reference">out</span>:
	kfree(io_upl_reprio_info, <span class="enscript-keyword">sizeof</span>(uint64_t) * (io_upl_size / PAGE_SIZE));
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_handle_prio_inversion</span>(vm_object_t o, vm_page_t m)
{
	upl_t upl;
        upl_page_info_t *pl;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, num_pages;
        <span class="enscript-type">int</span> cur_tier;

	cur_tier = proc_get_effective_thread_policy(current_thread(), TASK_POLICY_IO);

	<span class="enscript-comment">/* 
	Scan through all UPLs associated with the object to find the 
	UPL containing the contended page.
	*/</span> 
	queue_iterate(&amp;o-&gt;uplq, upl, upl_t, uplq) {
		<span class="enscript-keyword">if</span> (((upl-&gt;flags &amp; UPL_EXPEDITE_SUPPORTED) == 0) || upl-&gt;upl_priority &lt;= cur_tier)
			<span class="enscript-keyword">continue</span>;
		pl = UPL_GET_INTERNAL_PAGE_LIST(upl);
                num_pages = (upl-&gt;size / PAGE_SIZE);
                
		<span class="enscript-comment">/*
		For each page in the UPL page list, see if it matches the contended
		page and was issued as a low prio I/O. 
		*/</span>
		<span class="enscript-keyword">for</span>(i=0; i &lt; num_pages; i++) {
			<span class="enscript-keyword">if</span>(UPL_PAGE_PRESENT(pl,i) &amp;&amp; m-&gt;phys_page == pl[i].phys_addr) {
				<span class="enscript-keyword">if</span> ((upl-&gt;flags &amp; UPL_DECMP_REQ) &amp;&amp; upl-&gt;decmp_io_upl) {
                        		KERNEL_DEBUG_CONSTANT((MACHDBG_CODE(DBG_MACH_VM, VM_PAGE_EXPEDITE)) | DBG_FUNC_NONE, upl-&gt;upl_creator, m, upl, upl-&gt;upl_priority, 0);
					vm_decmp_upl_reprioritize(upl, cur_tier);
					<span class="enscript-keyword">break</span>;
				}
				KERNEL_DEBUG_CONSTANT((MACHDBG_CODE(DBG_MACH_VM, VM_PAGE_EXPEDITE)) | DBG_FUNC_NONE, upl-&gt;upl_creator, m, upl-&gt;upl_reprio_info[i], upl-&gt;upl_priority, 0);
				<span class="enscript-keyword">if</span> (UPL_REPRIO_INFO_BLKNO(upl, i) != 0 &amp;&amp; UPL_REPRIO_INFO_LEN(upl, i) != 0) 
					vm_page_request_reprioritize(o, UPL_REPRIO_INFO_BLKNO(upl, i), UPL_REPRIO_INFO_LEN(upl, i), cur_tier);
                                <span class="enscript-keyword">break</span>;
                         }
		 }
		 <span class="enscript-comment">/* Check if we found any hits */</span>
                 <span class="enscript-keyword">if</span> (i != num_pages)
			<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">return</span>;
}	

wait_result_t
<span class="enscript-function-name">vm_page_sleep</span>(vm_object_t o, vm_page_t m, <span class="enscript-type">int</span> interruptible)
{
	wait_result_t ret;

	KERNEL_DEBUG((MACHDBG_CODE(DBG_MACH_VM, VM_PAGE_SLEEP)) | DBG_FUNC_START, o, m, 0, 0, 0);	
	
	<span class="enscript-keyword">if</span> (o-&gt;io_tracking &amp;&amp; ((m-&gt;busy == TRUE) || (m-&gt;cleaning == TRUE) || VM_PAGE_WIRED(m))) {
		<span class="enscript-comment">/* 
		Indicates page is busy due to an I/O. Issue a reprioritize request if necessary.
		*/</span>
		vm_page_handle_prio_inversion(o,m);
	}
	m-&gt;wanted = TRUE;
	ret = thread_sleep_vm_object(o, m, interruptible);
	KERNEL_DEBUG((MACHDBG_CODE(DBG_MACH_VM, VM_PAGE_SLEEP)) | DBG_FUNC_END, o, m, 0, 0, 0);
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">io_reprioritize_thread</span>(<span class="enscript-type">void</span> *param __unused, wait_result_t wr __unused)
{
	io_reprioritize_req_t   req = NULL;
	
	<span class="enscript-keyword">while</span>(1) {

		IO_REPRIORITIZE_LIST_LOCK();
		<span class="enscript-keyword">if</span> (queue_empty(&amp;io_reprioritize_list)) {
			IO_REPRIORITIZE_LIST_UNLOCK();
			<span class="enscript-keyword">break</span>;
		}
			
		queue_remove_first(&amp;io_reprioritize_list, req, io_reprioritize_req_t, io_reprioritize_list);   
		IO_REPRIORITIZE_LIST_UNLOCK();
		
		vnode_pager_issue_reprioritize_io(req-&gt;devvp, req-&gt;blkno, req-&gt;len, req-&gt;priority);
		zfree(io_reprioritize_req_zone, req);	
	}	
	
	IO_REPRIO_THREAD_CONTINUATION();
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>