<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_kern.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_kern.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm/vm_kern.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Kernel memory management.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/cpm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

<span class="enscript-comment">/*
 *	Variables exported by this module.
 */</span>

vm_map_t	kernel_map;
vm_map_t	kernel_pageable_map;

<span class="enscript-type">extern</span> boolean_t vm_kernel_ready;

<span class="enscript-comment">/*
 * Forward declarations for internal functions.
 */</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">kmem_alloc_pages</span>(
	<span class="enscript-type">register</span> vm_object_t		object,
	<span class="enscript-type">register</span> vm_object_offset_t	offset,
	<span class="enscript-type">register</span> vm_object_size_t	size);

kern_return_t
<span class="enscript-function-name">kmem_alloc_contig</span>(
	vm_map_t		map,
	vm_offset_t		*addrp,
	vm_size_t		size,
	vm_offset_t 		mask,
	ppnum_t			max_pnum,
	ppnum_t			pnum_mask,
	<span class="enscript-type">int</span> 			flags,
	vm_tag_t                tag)
{
	vm_object_t		object;
	vm_object_offset_t	offset;
	vm_map_offset_t		map_addr; 
	vm_map_offset_t		map_mask;
	vm_map_size_t		map_size, i;
	vm_map_entry_t		entry;
	vm_page_t		m, pages;
	kern_return_t		kr;

	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL || (flags &amp; ~(KMA_KOBJECT | KMA_LOMEM | KMA_NOPAGEWAIT))) 
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	map_size = vm_map_round_page(size,
				     VM_MAP_PAGE_MASK(map));
	map_mask = (vm_map_offset_t)mask;
	
	<span class="enscript-comment">/* Check for zero allocation size (either directly or via overflow) */</span>
	<span class="enscript-keyword">if</span> (map_size == 0) {
		*addrp = 0;
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/*
	 *	Allocate a new object (if necessary) and the reference we
	 *	will be donating to the map entry.  We must do this before
	 *	locking the map, or risk deadlock with the default pager.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; KMA_KOBJECT) != 0) {
		object = kernel_object;
		vm_object_reference(object);
	} <span class="enscript-keyword">else</span> {
		object = vm_object_allocate(map_size);
	}

	kr = vm_map_find_space(map, &amp;map_addr, map_size, map_mask, 0, &amp;entry);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kr) {
		vm_object_deallocate(object);
		<span class="enscript-keyword">return</span> kr;
	}

	<span class="enscript-keyword">if</span> (object == kernel_object) {
		offset = map_addr;
	} <span class="enscript-keyword">else</span> {
		offset = 0;
	}
	VME_OBJECT_SET(entry, object);
	VME_OFFSET_SET(entry, offset);
	VME_ALIAS_SET(entry, tag);

	<span class="enscript-comment">/* Take an extra object ref in case the map entry gets deleted */</span>
	vm_object_reference(object);
	vm_map_unlock(map);

	kr = cpm_allocate(CAST_DOWN(vm_size_t, map_size), &amp;pages, max_pnum, pnum_mask, FALSE, flags);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		vm_map_remove(map,
			      vm_map_trunc_page(map_addr,
						VM_MAP_PAGE_MASK(map)),
			      vm_map_round_page(map_addr + map_size,
						VM_MAP_PAGE_MASK(map)),
			      0);
		vm_object_deallocate(object);
		*addrp = 0;
		<span class="enscript-keyword">return</span> kr;
	}

	vm_object_lock(object);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; map_size; i += PAGE_SIZE) {
		m = pages;
		pages = NEXT_PAGE(m);
		*(NEXT_PAGE_PTR(m)) = VM_PAGE_NULL;
		m-&gt;busy = FALSE;
		vm_page_insert(m, object, offset + i);
	}
	vm_object_unlock(object);

	kr = vm_map_wire(map,
			 vm_map_trunc_page(map_addr,
					   VM_MAP_PAGE_MASK(map)),
			 vm_map_round_page(map_addr + map_size,
					   VM_MAP_PAGE_MASK(map)),
			 VM_PROT_DEFAULT | VM_PROT_MEMORY_TAG_MAKE(tag),
			 FALSE);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		<span class="enscript-keyword">if</span> (object == kernel_object) {
			vm_object_lock(object);
			vm_object_page_remove(object, offset, offset + map_size);
			vm_object_unlock(object);
		}
		vm_map_remove(map,
			      vm_map_trunc_page(map_addr,
						VM_MAP_PAGE_MASK(map)), 
			      vm_map_round_page(map_addr + map_size,
						VM_MAP_PAGE_MASK(map)),
			      0);
		vm_object_deallocate(object);
		<span class="enscript-keyword">return</span> kr;
	}
	vm_object_deallocate(object);

	<span class="enscript-keyword">if</span> (object == kernel_object)
		vm_map_simplify(map, map_addr);

	*addrp = (vm_offset_t) map_addr;
	assert((vm_map_offset_t) *addrp == map_addr);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Master entry point for allocating kernel memory.
 * NOTE: this routine is _never_ interrupt safe.
 *
 * map		: map to allocate into
 * addrp	: pointer to start address of new memory
 * size		: size of memory requested
 * flags	: options
 *		  KMA_HERE		*addrp is base address, else &quot;anywhere&quot;
 *		  KMA_NOPAGEWAIT	don't wait for pages if unavailable
 *		  KMA_KOBJECT		use kernel_object
 *		  KMA_LOMEM		support for 32 bit devices in a 64 bit world
 *					if set and a lomemory pool is available
 *					grab pages from it... this also implies
 *					KMA_NOPAGEWAIT
 */</span>

kern_return_t
<span class="enscript-function-name">kernel_memory_allocate</span>(
	<span class="enscript-type">register</span> vm_map_t	map,
	<span class="enscript-type">register</span> vm_offset_t	*addrp,
	<span class="enscript-type">register</span> vm_size_t	size,
	<span class="enscript-type">register</span> vm_offset_t	mask,
	<span class="enscript-type">int</span>			flags,
	vm_tag_t                tag)
{
	vm_object_t 		object;
	vm_object_offset_t 	offset;
	vm_object_offset_t 	pg_offset;
	vm_map_entry_t 		entry = NULL;
	vm_map_offset_t 	map_addr, fill_start;
	vm_map_offset_t		map_mask;
	vm_map_size_t		map_size, fill_size;
	kern_return_t 		kr, pe_result;
	vm_page_t		mem;
	vm_page_t		guard_page_list = NULL;
	vm_page_t		wired_page_list = NULL;
	<span class="enscript-type">int</span>			guard_page_count = 0;
	<span class="enscript-type">int</span>			wired_page_count = 0;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			vm_alloc_flags;
	vm_prot_t		kma_prot;

	<span class="enscript-keyword">if</span> (! vm_kernel_ready) {
		panic(<span class="enscript-string">&quot;kernel_memory_allocate: VM is not ready&quot;</span>);
	}

	map_size = vm_map_round_page(size,
				     VM_MAP_PAGE_MASK(map));
	map_mask = (vm_map_offset_t) mask;

	vm_alloc_flags = VM_MAKE_TAG(tag);

	<span class="enscript-comment">/* Check for zero allocation size (either directly or via overflow) */</span>
	<span class="enscript-keyword">if</span> (map_size == 0) {
		*addrp = 0;
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/*
	 * limit the size of a single extent of wired memory
	 * to try and limit the damage to the system if
	 * too many pages get wired down
	 * limit raised to 2GB with 128GB max physical limit
	 */</span>
        <span class="enscript-keyword">if</span> ( !(flags &amp; KMA_VAONLY) &amp;&amp; map_size &gt; (1ULL &lt;&lt; 31)) {
                <span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
        }

	<span class="enscript-comment">/*
	 * Guard pages:
	 *
	 * Guard pages are implemented as ficticious pages.  By placing guard pages
	 * on either end of a stack, they can help detect cases where a thread walks
	 * off either end of its stack.  They are allocated and set up here and attempts
	 * to access those pages are trapped in vm_fault_page().
	 *
	 * The map_size we were passed may include extra space for
	 * guard pages.  If those were requested, then back it out of fill_size
	 * since vm_map_find_space() takes just the actual size not including
	 * guard pages.  Similarly, fill_start indicates where the actual pages
	 * will begin in the range.
	 */</span>

	fill_start = 0;
	fill_size = map_size;

	<span class="enscript-keyword">if</span> (flags &amp; KMA_GUARD_FIRST) {
		vm_alloc_flags |= VM_FLAGS_GUARD_BEFORE;
		fill_start += PAGE_SIZE_64;
		fill_size -= PAGE_SIZE_64;
		<span class="enscript-keyword">if</span> (map_size &lt; fill_start + fill_size) {
			<span class="enscript-comment">/* no space for a guard page */</span>
			*addrp = 0;
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}
		guard_page_count++;
	}
	<span class="enscript-keyword">if</span> (flags &amp; KMA_GUARD_LAST) {
		vm_alloc_flags |= VM_FLAGS_GUARD_AFTER;
		fill_size -= PAGE_SIZE_64;
		<span class="enscript-keyword">if</span> (map_size &lt;= fill_start + fill_size) {
			<span class="enscript-comment">/* no space for a guard page */</span>
			*addrp = 0;
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}
		guard_page_count++;
	}
	wired_page_count = (<span class="enscript-type">int</span>) (fill_size / PAGE_SIZE_64);
	assert(wired_page_count * PAGE_SIZE_64 == fill_size);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; guard_page_count; i++) {
		<span class="enscript-keyword">for</span> (;;) {
			mem = vm_page_grab_guard();

			<span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (flags &amp; KMA_NOPAGEWAIT) {
				kr = KERN_RESOURCE_SHORTAGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			vm_page_more_fictitious();
		}
		mem-&gt;pageq.next = (queue_entry_t)guard_page_list;
		guard_page_list = mem;
	}

	<span class="enscript-keyword">if</span> (! (flags &amp; KMA_VAONLY)) {
	<span class="enscript-keyword">for</span> (i = 0; i &lt; wired_page_count; i++) {
		uint64_t	unavailable;
		
		<span class="enscript-keyword">for</span> (;;) {
		        <span class="enscript-keyword">if</span> (flags &amp; KMA_LOMEM)
			        mem = vm_page_grablo();
			<span class="enscript-keyword">else</span>
			        mem = vm_page_grab();

		        <span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL)
			        <span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (flags &amp; KMA_NOPAGEWAIT) {
				kr = KERN_RESOURCE_SHORTAGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> ((flags &amp; KMA_LOMEM) &amp;&amp; (vm_lopage_needed == TRUE)) {
				kr = KERN_RESOURCE_SHORTAGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			unavailable = (vm_page_wire_count + vm_page_free_target) * PAGE_SIZE;

			<span class="enscript-keyword">if</span> (unavailable &gt; max_mem || map_size &gt; (max_mem - unavailable)) {
				kr = KERN_RESOURCE_SHORTAGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			VM_PAGE_WAIT();
		}
		mem-&gt;pageq.next = (queue_entry_t)wired_page_list;
		wired_page_list = mem;
	}
	}

	<span class="enscript-comment">/*
	 *	Allocate a new object (if necessary).  We must do this before
	 *	locking the map, or risk deadlock with the default pager.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; KMA_KOBJECT) != 0) {
		object = kernel_object;
		vm_object_reference(object);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((flags &amp; KMA_COMPRESSOR) != 0) {
		object = compressor_object;
		vm_object_reference(object);
	} <span class="enscript-keyword">else</span> {
		object = vm_object_allocate(map_size);
	}

	kr = vm_map_find_space(map, &amp;map_addr,
			       fill_size, map_mask,
			       vm_alloc_flags, &amp;entry);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kr) {
		vm_object_deallocate(object);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (object == kernel_object || object == compressor_object) {
		offset = map_addr;
	} <span class="enscript-keyword">else</span> {
		offset = 0;
	}
	VME_OBJECT_SET(entry, object);
	VME_OFFSET_SET(entry, offset);
	
	<span class="enscript-keyword">if</span> (object != compressor_object)
		entry-&gt;wired_count++;

	<span class="enscript-keyword">if</span> (flags &amp; KMA_PERMANENT)
		entry-&gt;permanent = TRUE;

	<span class="enscript-keyword">if</span> (object != kernel_object &amp;&amp; object != compressor_object)
		vm_object_reference(object);

	vm_object_lock(object);
	vm_map_unlock(map);

	pg_offset = 0;

	<span class="enscript-keyword">if</span> (fill_start) {
		<span class="enscript-keyword">if</span> (guard_page_list == NULL)
			panic(<span class="enscript-string">&quot;kernel_memory_allocate: guard_page_list == NULL&quot;</span>);

		mem = guard_page_list;
		guard_page_list = (vm_page_t)mem-&gt;pageq.next;
		mem-&gt;pageq.next = NULL;

		vm_page_insert(mem, object, offset + pg_offset);

		mem-&gt;busy = FALSE;
		pg_offset += PAGE_SIZE_64;
	}

	kma_prot = VM_PROT_READ | VM_PROT_WRITE;

	<span class="enscript-keyword">if</span> (flags &amp; KMA_VAONLY) {
		pg_offset = fill_start + fill_size;
	} <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">for</span> (pg_offset = fill_start; pg_offset &lt; fill_start + fill_size; pg_offset += PAGE_SIZE_64) {
		<span class="enscript-keyword">if</span> (wired_page_list == NULL)
			panic(<span class="enscript-string">&quot;kernel_memory_allocate: wired_page_list == NULL&quot;</span>);

		mem = wired_page_list;
		wired_page_list = (vm_page_t)mem-&gt;pageq.next;
		mem-&gt;pageq.next = NULL;
		mem-&gt;wire_count++;

		vm_page_insert_wired(mem, object, offset + pg_offset, tag);

		mem-&gt;busy = FALSE;
		mem-&gt;pmapped = TRUE;
		mem-&gt;wpmapped = TRUE;

		PMAP_ENTER_OPTIONS(kernel_pmap, map_addr + pg_offset, mem,
				   kma_prot, VM_PROT_NONE, ((flags &amp; KMA_KSTACK) ? VM_MEM_STACK : 0), TRUE,
				   PMAP_OPTIONS_NOWAIT, pe_result);

		<span class="enscript-keyword">if</span> (pe_result == KERN_RESOURCE_SHORTAGE) {
			vm_object_unlock(object);

			PMAP_ENTER(kernel_pmap, map_addr + pg_offset, mem, 
				   kma_prot, VM_PROT_NONE, ((flags &amp; KMA_KSTACK) ? VM_MEM_STACK : 0), TRUE);

			vm_object_lock(object);
		}
		<span class="enscript-keyword">if</span> (flags &amp; KMA_NOENCRYPT) {
			bzero(CAST_DOWN(<span class="enscript-type">void</span> *, (map_addr + pg_offset)), PAGE_SIZE);

			pmap_set_noencrypt(mem-&gt;phys_page);
		}
	}
	}
	<span class="enscript-keyword">if</span> ((fill_start + fill_size) &lt; map_size) {
		<span class="enscript-keyword">if</span> (guard_page_list == NULL)
			panic(<span class="enscript-string">&quot;kernel_memory_allocate: guard_page_list == NULL&quot;</span>);

		mem = guard_page_list;
		guard_page_list = (vm_page_t)mem-&gt;pageq.next;
		mem-&gt;pageq.next = NULL;

		vm_page_insert(mem, object, offset + pg_offset);

		mem-&gt;busy = FALSE;
	}
	<span class="enscript-keyword">if</span> (guard_page_list || wired_page_list)
		panic(<span class="enscript-string">&quot;kernel_memory_allocate: non empty list\n&quot;</span>);

	<span class="enscript-keyword">if</span> (! (flags &amp; KMA_VAONLY)) {
	vm_page_lockspin_queues();
	vm_page_wire_count += wired_page_count;
	vm_page_unlock_queues();
	}

	vm_object_unlock(object);

	<span class="enscript-comment">/*
	 * now that the pages are wired, we no longer have to fear coalesce
	 */</span>
	<span class="enscript-keyword">if</span> (object == kernel_object || object == compressor_object)
		vm_map_simplify(map, map_addr);
	<span class="enscript-keyword">else</span>
		vm_object_deallocate(object);

	<span class="enscript-comment">/*
	 *	Return the memory, not zeroed.
	 */</span>
	*addrp = CAST_DOWN(vm_offset_t, map_addr);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (guard_page_list)
		vm_page_free_list(guard_page_list, FALSE);

	<span class="enscript-keyword">if</span> (wired_page_list)
		vm_page_free_list(wired_page_list, FALSE);

	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">kernel_memory_populate</span>(
	vm_map_t	map,
	vm_offset_t	addr,
	vm_size_t	size,
	<span class="enscript-type">int</span>		flags,
	vm_tag_t        tag)
{
	vm_object_t		object;
	vm_object_offset_t	offset, pg_offset;
	kern_return_t		kr, pe_result;
	vm_page_t		mem;
	vm_page_t		page_list = NULL;
	<span class="enscript-type">int</span>			page_count = 0;
	<span class="enscript-type">int</span>			i;

	page_count = (<span class="enscript-type">int</span>) (size / PAGE_SIZE_64);

	assert((flags &amp; (KMA_COMPRESSOR|KMA_KOBJECT)) != (KMA_COMPRESSOR|KMA_KOBJECT));

	<span class="enscript-keyword">if</span> (flags &amp; KMA_COMPRESSOR) {

		pg_offset = page_count * PAGE_SIZE_64;

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">for</span> (;;) {
				mem = vm_page_grab();

				<span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL)
					<span class="enscript-keyword">break</span>;
				
				VM_PAGE_WAIT();
			}
			mem-&gt;pageq.next = (queue_entry_t) page_list;
			page_list = mem;

			pg_offset -= PAGE_SIZE_64;

			kr = pmap_enter_options(kernel_pmap,
						  addr + pg_offset, mem-&gt;phys_page,
						  VM_PROT_READ | VM_PROT_WRITE, VM_PROT_NONE, 0, TRUE,
						  PMAP_OPTIONS_INTERNAL, NULL);
			assert(kr == KERN_SUCCESS);

		} <span class="enscript-keyword">while</span> (pg_offset);

		offset = addr;
		object = compressor_object;

		vm_object_lock(object);

		<span class="enscript-keyword">for</span> (pg_offset = 0;
		     pg_offset &lt; size;
		     pg_offset += PAGE_SIZE_64) {

			mem = page_list;
			page_list = (vm_page_t) mem-&gt;pageq.next;
			mem-&gt;pageq.next = NULL;

			vm_page_insert(mem, object, offset + pg_offset);
			assert(mem-&gt;busy);

			mem-&gt;busy = FALSE;
			mem-&gt;pmapped = TRUE;
			mem-&gt;wpmapped = TRUE;
			mem-&gt;compressor = TRUE;
		}
		vm_object_unlock(object);

		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; page_count; i++) {
		<span class="enscript-keyword">for</span> (;;) {
			<span class="enscript-keyword">if</span> (flags &amp; KMA_LOMEM)
				mem = vm_page_grablo();
			<span class="enscript-keyword">else</span>
				mem = vm_page_grab();
			
			<span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (flags &amp; KMA_NOPAGEWAIT) {
				kr = KERN_RESOURCE_SHORTAGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> ((flags &amp; KMA_LOMEM) &amp;&amp;
			    (vm_lopage_needed == TRUE)) {
				kr = KERN_RESOURCE_SHORTAGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			VM_PAGE_WAIT();
		}
		mem-&gt;pageq.next = (queue_entry_t) page_list;
		page_list = mem;
	}
	<span class="enscript-keyword">if</span> (flags &amp; KMA_KOBJECT) {
		offset = addr;
		object = kernel_object;

		vm_object_lock(object);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If it's not the kernel object, we need to:
		 *      lock map;
		 *      lookup entry;
		 *      lock object;
		 *	take reference on object;
		 *      unlock map;
		 */</span>
		panic(<span class="enscript-string">&quot;kernel_memory_populate(%p,0x%llx,0x%llx,0x%x): &quot;</span>
		      <span class="enscript-string">&quot;!KMA_KOBJECT&quot;</span>,
		      map, (uint64_t) addr, (uint64_t) size, flags);
	}

	<span class="enscript-keyword">for</span> (pg_offset = 0;
	     pg_offset &lt; size;
	     pg_offset += PAGE_SIZE_64) {

		<span class="enscript-keyword">if</span> (page_list == NULL)
			panic(<span class="enscript-string">&quot;kernel_memory_populate: page_list == NULL&quot;</span>);

		mem = page_list;
		page_list = (vm_page_t) mem-&gt;pageq.next;
		mem-&gt;pageq.next = NULL;

		mem-&gt;wire_count++;

		vm_page_insert_wired(mem, object, offset + pg_offset, tag);

		mem-&gt;busy = FALSE;
		mem-&gt;pmapped = TRUE;
		mem-&gt;wpmapped = TRUE;

		PMAP_ENTER_OPTIONS(kernel_pmap, addr + pg_offset, mem,
				   VM_PROT_READ | VM_PROT_WRITE, VM_PROT_NONE,
				   ((flags &amp; KMA_KSTACK) ? VM_MEM_STACK : 0), TRUE,
				   PMAP_OPTIONS_NOWAIT, pe_result);

		<span class="enscript-keyword">if</span> (pe_result == KERN_RESOURCE_SHORTAGE) {

			vm_object_unlock(object);

			PMAP_ENTER(kernel_pmap, addr + pg_offset, mem,
				   VM_PROT_READ | VM_PROT_WRITE, VM_PROT_NONE,
				   ((flags &amp; KMA_KSTACK) ? VM_MEM_STACK : 0), TRUE);

			vm_object_lock(object);
		}
		<span class="enscript-keyword">if</span> (flags &amp; KMA_NOENCRYPT) {
			bzero(CAST_DOWN(<span class="enscript-type">void</span> *, (addr + pg_offset)), PAGE_SIZE);
			pmap_set_noencrypt(mem-&gt;phys_page);
		}
	}
	vm_page_lock_queues();
	vm_page_wire_count += page_count;
	vm_page_unlock_queues();

	vm_object_unlock(object);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (page_list)
		vm_page_free_list(page_list, FALSE);

	<span class="enscript-keyword">return</span> kr;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">kernel_memory_depopulate</span>(
	vm_map_t	map,
	vm_offset_t	addr,
	vm_size_t	size,
	<span class="enscript-type">int</span>		flags)
{
	vm_object_t		object;
	vm_object_offset_t	offset, pg_offset;
	vm_page_t		mem;
	vm_page_t		local_freeq = NULL;

	assert((flags &amp; (KMA_COMPRESSOR|KMA_KOBJECT)) != (KMA_COMPRESSOR|KMA_KOBJECT));

	<span class="enscript-keyword">if</span> (flags &amp; KMA_COMPRESSOR) {
		offset = addr;
		object = compressor_object;

		vm_object_lock(object);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; KMA_KOBJECT) {
		offset = addr;
		object = kernel_object;

		vm_object_lock(object);
	} <span class="enscript-keyword">else</span> {
		offset = 0;
		object = NULL;
                <span class="enscript-comment">/*
                 * If it's not the kernel object, we need to:
                 *      lock map;
                 *      lookup entry;
                 *      lock object;
                 *      unlock map;
                 */</span>
		panic(<span class="enscript-string">&quot;kernel_memory_depopulate(%p,0x%llx,0x%llx,0x%x): &quot;</span>
		      <span class="enscript-string">&quot;!KMA_KOBJECT&quot;</span>,
		      map, (uint64_t) addr, (uint64_t) size, flags);
	}
	pmap_protect(kernel_map-&gt;pmap, offset, offset + size, VM_PROT_NONE);

	<span class="enscript-keyword">for</span> (pg_offset = 0;
	     pg_offset &lt; size;
	     pg_offset += PAGE_SIZE_64) {

		mem = vm_page_lookup(object, offset + pg_offset);

		assert(mem);

		pmap_disconnect(mem-&gt;phys_page);

		mem-&gt;busy = TRUE;

		assert(mem-&gt;tabled);
		vm_page_remove(mem, TRUE);
		assert(mem-&gt;busy);

		assert(mem-&gt;pageq.next == NULL &amp;&amp;
		       mem-&gt;pageq.prev == NULL);
		mem-&gt;pageq.next = (queue_entry_t)local_freeq;
		local_freeq = mem;
	}
	vm_object_unlock(object);

	<span class="enscript-keyword">if</span> (local_freeq)
		vm_page_free_list(local_freeq, TRUE);
}

<span class="enscript-comment">/*
 *	kmem_alloc:
 *
 *	Allocate wired-down memory in the kernel's address map
 *	or a submap.  The memory is not zero-filled.
 */</span>

kern_return_t
<span class="enscript-function-name">kmem_alloc_external</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size)
{
    <span class="enscript-keyword">return</span> (kmem_alloc(map, addrp, size, vm_tag_bt()));
}

kern_return_t
<span class="enscript-function-name">kmem_alloc</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size,
	vm_tag_t        tag)
{
	kern_return_t kr = kernel_memory_allocate(map, addrp, size, 0, 0, tag);
	TRACE_MACHLEAKS(KMEM_ALLOC_CODE, KMEM_ALLOC_CODE_2, size, *addrp);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	kmem_realloc:
 *
 *	Reallocate wired-down memory in the kernel's address map
 *	or a submap.  Newly allocated pages are not zeroed.
 *	This can only be used on regions allocated with kmem_alloc.
 *
 *	If successful, the pages in the old region are mapped twice.
 *	The old region is unchanged.  Use kmem_free to get rid of it.
 */</span>
kern_return_t
<span class="enscript-function-name">kmem_realloc</span>(
	vm_map_t		map,
	vm_offset_t		oldaddr,
	vm_size_t		oldsize,
	vm_offset_t		*newaddrp,
	vm_size_t		newsize,
	vm_tag_t		tag)
{
	vm_object_t		object;
	vm_object_offset_t	offset;
	vm_map_offset_t		oldmapmin;
	vm_map_offset_t		oldmapmax;
	vm_map_offset_t		newmapaddr;
	vm_map_size_t		oldmapsize;
	vm_map_size_t		newmapsize;
	vm_map_entry_t		oldentry;
	vm_map_entry_t		newentry;
	vm_page_t		mem;
	kern_return_t		kr;

	oldmapmin = vm_map_trunc_page(oldaddr,
				      VM_MAP_PAGE_MASK(map));
	oldmapmax = vm_map_round_page(oldaddr + oldsize,
				      VM_MAP_PAGE_MASK(map));
	oldmapsize = oldmapmax - oldmapmin;
	newmapsize = vm_map_round_page(newsize,
				       VM_MAP_PAGE_MASK(map));


	<span class="enscript-comment">/*
	 *	Find the VM object backing the old region.
	 */</span>

	vm_map_lock(map);

	<span class="enscript-keyword">if</span> (!vm_map_lookup_entry(map, oldmapmin, &amp;oldentry))
		panic(<span class="enscript-string">&quot;kmem_realloc&quot;</span>);
	object = VME_OBJECT(oldentry);

	<span class="enscript-comment">/*
	 *	Increase the size of the object and
	 *	fill in the new region.
	 */</span>

	vm_object_reference(object);
	<span class="enscript-comment">/* by grabbing the object lock before unlocking the map */</span>
	<span class="enscript-comment">/* we guarantee that we will panic if more than one     */</span>
	<span class="enscript-comment">/* attempt is made to realloc a kmem_alloc'd area       */</span>
	vm_object_lock(object);
	vm_map_unlock(map);
	<span class="enscript-keyword">if</span> (object-&gt;vo_size != oldmapsize)
		panic(<span class="enscript-string">&quot;kmem_realloc&quot;</span>);
	object-&gt;vo_size = newmapsize;
	vm_object_unlock(object);

	<span class="enscript-comment">/* allocate the new pages while expanded portion of the */</span>
	<span class="enscript-comment">/* object is still not mapped */</span>
	kmem_alloc_pages(object, vm_object_round_page(oldmapsize),
			 vm_object_round_page(newmapsize-oldmapsize));

	<span class="enscript-comment">/*
	 *	Find space for the new region.
	 */</span>

	kr = vm_map_find_space(map, &amp;newmapaddr, newmapsize,
			       (vm_map_offset_t) 0, 0, &amp;newentry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		vm_object_lock(object);
		<span class="enscript-keyword">for</span>(offset = oldmapsize; 
		    offset &lt; newmapsize; offset += PAGE_SIZE) {
	    		<span class="enscript-keyword">if</span> ((mem = vm_page_lookup(object, offset)) != VM_PAGE_NULL) {
				VM_PAGE_FREE(mem);
			}
		}
		object-&gt;vo_size = oldmapsize;
		vm_object_unlock(object);
		vm_object_deallocate(object);
		<span class="enscript-keyword">return</span> kr;
	}
	VME_OBJECT_SET(newentry, object);
	VME_OFFSET_SET(newentry, 0);
	VME_ALIAS_SET(newentry, tag);
	assert(newentry-&gt;wired_count == 0);

	
	<span class="enscript-comment">/* add an extra reference in case we have someone doing an */</span>
	<span class="enscript-comment">/* unexpected deallocate */</span>
	vm_object_reference(object);
	vm_map_unlock(map);

	kr = vm_map_wire(map, newmapaddr, newmapaddr + newmapsize,
			 VM_PROT_DEFAULT | VM_PROT_MEMORY_TAG_MAKE(tag), FALSE);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kr) {
		vm_map_remove(map, newmapaddr, newmapaddr + newmapsize, 0);
		vm_object_lock(object);
		<span class="enscript-keyword">for</span>(offset = oldsize; offset &lt; newmapsize; offset += PAGE_SIZE) {
	    		<span class="enscript-keyword">if</span> ((mem = vm_page_lookup(object, offset)) != VM_PAGE_NULL) {
				VM_PAGE_FREE(mem);
			}
		}
		object-&gt;vo_size = oldmapsize;
		vm_object_unlock(object);
		vm_object_deallocate(object);
		<span class="enscript-keyword">return</span> (kr);
	}
	vm_object_deallocate(object);

	*newaddrp = CAST_DOWN(vm_offset_t, newmapaddr);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	kmem_alloc_kobject:
 *
 *	Allocate wired-down memory in the kernel's address map
 *	or a submap.  The memory is not zero-filled.
 *
 *	The memory is allocated in the kernel_object.
 *	It may not be copied with vm_map_copy, and
 *	it may not be reallocated with kmem_realloc.
 */</span>

kern_return_t
<span class="enscript-function-name">kmem_alloc_kobject_external</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size)
{
    <span class="enscript-keyword">return</span> (kmem_alloc_kobject(map, addrp, size, vm_tag_bt()));
}

kern_return_t
<span class="enscript-function-name">kmem_alloc_kobject</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size,
	vm_tag_t        tag)
{
	<span class="enscript-keyword">return</span> kernel_memory_allocate(map, addrp, size, 0, KMA_KOBJECT, tag);
}

<span class="enscript-comment">/*
 *	kmem_alloc_aligned:
 *
 *	Like kmem_alloc_kobject, except that the memory is aligned.
 *	The size should be a power-of-2.
 */</span>

kern_return_t
<span class="enscript-function-name">kmem_alloc_aligned</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size,
	vm_tag_t        tag)
{
	<span class="enscript-keyword">if</span> ((size &amp; (size - 1)) != 0)
		panic(<span class="enscript-string">&quot;kmem_alloc_aligned: size not aligned&quot;</span>);
	<span class="enscript-keyword">return</span> kernel_memory_allocate(map, addrp, size, size - 1, KMA_KOBJECT, tag);
}

<span class="enscript-comment">/*
 *	kmem_alloc_pageable:
 *
 *	Allocate pageable memory in the kernel's address map.
 */</span>

kern_return_t
<span class="enscript-function-name">kmem_alloc_pageable_external</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size)
{
    <span class="enscript-keyword">return</span> (kmem_alloc_pageable(map, addrp, size, vm_tag_bt()));
}

kern_return_t
<span class="enscript-function-name">kmem_alloc_pageable</span>(
	vm_map_t	map,
	vm_offset_t	*addrp,
	vm_size_t	size,
	vm_tag_t        tag)
{
	vm_map_offset_t map_addr;
	vm_map_size_t	map_size;
	kern_return_t kr;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">normal</span>
	map_addr = (vm_map_min(map)) + PAGE_SIZE;
#<span class="enscript-reference">else</span>
	map_addr = vm_map_min(map);
#<span class="enscript-reference">endif</span>
	map_size = vm_map_round_page(size,
				     VM_MAP_PAGE_MASK(map));

	kr = vm_map_enter(map, &amp;map_addr, map_size,
			  (vm_map_offset_t) 0, 
			  VM_FLAGS_ANYWHERE | VM_MAKE_TAG(tag),
			  VM_OBJECT_NULL, (vm_object_offset_t) 0, FALSE,
			  VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	*addrp = CAST_DOWN(vm_offset_t, map_addr);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	kmem_free:
 *
 *	Release a region of kernel virtual memory allocated
 *	with kmem_alloc, kmem_alloc_kobject, or kmem_alloc_pageable,
 *	and return the physical pages associated with that region.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">kmem_free</span>(
	vm_map_t	map,
	vm_offset_t	addr,
	vm_size_t	size)
{
	kern_return_t kr;

	assert(addr &gt;= VM_MIN_KERNEL_AND_KEXT_ADDRESS);

	TRACE_MACHLEAKS(KMEM_FREE_CODE, KMEM_FREE_CODE_2, size, addr);

	<span class="enscript-keyword">if</span>(size == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
		printf(<span class="enscript-string">&quot;kmem_free called with size==0 for map: %p with addr: 0x%llx\n&quot;</span>,map,(uint64_t)addr);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span>;
	}

	kr = vm_map_remove(map,
			   vm_map_trunc_page(addr,
					     VM_MAP_PAGE_MASK(map)),
			   vm_map_round_page(addr + size,
					     VM_MAP_PAGE_MASK(map)), 
			   VM_MAP_REMOVE_KUNWIRE);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;kmem_free&quot;</span>);
}

<span class="enscript-comment">/*
 *	Allocate new pages in an object.
 */</span>

kern_return_t
<span class="enscript-function-name">kmem_alloc_pages</span>(
	<span class="enscript-type">register</span> vm_object_t		object,
	<span class="enscript-type">register</span> vm_object_offset_t	offset,
	<span class="enscript-type">register</span> vm_object_size_t	size)
{
	vm_object_size_t		alloc_size;

	alloc_size = vm_object_round_page(size);
        vm_object_lock(object);
	<span class="enscript-keyword">while</span> (alloc_size) {
	    <span class="enscript-type">register</span> vm_page_t	mem;


	    <span class="enscript-comment">/*
	     *	Allocate a page
	     */</span>
	    <span class="enscript-keyword">while</span> (VM_PAGE_NULL == 
		  (mem = vm_page_alloc(object, offset))) {
		vm_object_unlock(object);
		VM_PAGE_WAIT();
		vm_object_lock(object);
	    }
	    mem-&gt;busy = FALSE;

	    alloc_size -= PAGE_SIZE;
	    offset += PAGE_SIZE;
	}
	vm_object_unlock(object);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	kmem_suballoc:
 *
 *	Allocates a map to manage a subrange
 *	of the kernel virtual address space.
 *
 *	Arguments are as follows:
 *
 *	parent		Map to take range from
 *	addr		Address of start of range (IN/OUT)
 *	size		Size of range to find
 *	pageable	Can region be paged
 *	anywhere	Can region be located anywhere in map
 *	new_map		Pointer to new submap
 */</span>
kern_return_t
<span class="enscript-function-name">kmem_suballoc</span>(
	vm_map_t	parent,
	vm_offset_t	*addr,
	vm_size_t	size,
	boolean_t	pageable,
	<span class="enscript-type">int</span>		flags,
	vm_map_t	*new_map)
{
	vm_map_t	map;
	vm_map_offset_t	map_addr;
	vm_map_size_t	map_size;
	kern_return_t	kr;

	map_size = vm_map_round_page(size,
				     VM_MAP_PAGE_MASK(parent));

	<span class="enscript-comment">/*
	 *	Need reference on submap object because it is internal
	 *	to the vm_system.  vm_object_enter will never be called
	 *	on it (usual source of reference for vm_map_enter).
	 */</span>
	vm_object_reference(vm_submap_object);

	map_addr = ((flags &amp; VM_FLAGS_ANYWHERE)
		    ? vm_map_min(parent)
		    : vm_map_trunc_page(*addr,
					VM_MAP_PAGE_MASK(parent)));

	kr = vm_map_enter(parent, &amp;map_addr, map_size,
			  (vm_map_offset_t) 0, flags,
			  vm_submap_object, (vm_object_offset_t) 0, FALSE,
			  VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		vm_object_deallocate(vm_submap_object);
		<span class="enscript-keyword">return</span> (kr);
	}

	pmap_reference(vm_map_pmap(parent));
	map = vm_map_create(vm_map_pmap(parent), map_addr, map_addr + map_size, pageable);
	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL)
		panic(<span class="enscript-string">&quot;kmem_suballoc: vm_map_create failed&quot;</span>);	<span class="enscript-comment">/* &quot;can't happen&quot; */</span>
	<span class="enscript-comment">/* inherit the parent map's page size */</span>
	vm_map_set_page_shift(map, VM_MAP_PAGE_SHIFT(parent));

	kr = vm_map_submap(parent, map_addr, map_addr + map_size, map, map_addr, FALSE);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		<span class="enscript-comment">/*
		 * See comment preceding vm_map_submap().
		 */</span>
		vm_map_remove(parent, map_addr, map_addr + map_size, VM_MAP_NO_FLAGS);
		vm_map_deallocate(map);	<span class="enscript-comment">/* also removes ref to pmap */</span>
		vm_object_deallocate(vm_submap_object);
		<span class="enscript-keyword">return</span> (kr);
	}
	*addr = CAST_DOWN(vm_offset_t, map_addr);
	*new_map = map;
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	kmem_init:
 *
 *	Initialize the kernel's virtual memory map, taking
 *	into account all memory allocated up to this time.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kmem_init</span>(
	vm_offset_t	start,
	vm_offset_t	end)
{
	vm_map_offset_t map_start;
	vm_map_offset_t map_end;

	map_start = vm_map_trunc_page(start,
				      VM_MAP_PAGE_MASK(kernel_map));
	map_end = vm_map_round_page(end,
				    VM_MAP_PAGE_MASK(kernel_map));

	kernel_map = vm_map_create(pmap_kernel(),VM_MIN_KERNEL_AND_KEXT_ADDRESS,
			    map_end, FALSE);
	<span class="enscript-comment">/*
	 *	Reserve virtual memory allocated up to this time.
	 */</span>
	<span class="enscript-keyword">if</span> (start != VM_MIN_KERNEL_AND_KEXT_ADDRESS) {
		vm_map_offset_t map_addr;
		kern_return_t kr;
 
		map_addr = VM_MIN_KERNEL_AND_KEXT_ADDRESS;
		kr = vm_map_enter(kernel_map,
			&amp;map_addr, 
		    	(vm_map_size_t)(map_start - VM_MIN_KERNEL_AND_KEXT_ADDRESS),
			(vm_map_offset_t) 0,
			VM_FLAGS_FIXED | VM_FLAGS_NO_PMAP_CHECK,
			VM_OBJECT_NULL, 
			(vm_object_offset_t) 0, FALSE,
			VM_PROT_NONE, VM_PROT_NONE,
			VM_INHERIT_DEFAULT);
		
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			panic(<span class="enscript-string">&quot;kmem_init(0x%llx,0x%llx): vm_map_enter(0x%llx,0x%llx) error 0x%x\n&quot;</span>,
			      (uint64_t) start, (uint64_t) end,
			      (uint64_t) VM_MIN_KERNEL_AND_KEXT_ADDRESS,
			      (uint64_t) (map_start - VM_MIN_KERNEL_AND_KEXT_ADDRESS),
			      kr);
		}	
	}

	<span class="enscript-comment">/*
	 * Set the default global user wire limit which limits the amount of
	 * memory that can be locked via mlock().  We set this to the total
	 * amount of memory that are potentially usable by a user app (max_mem)
	 * minus a certain amount.  This can be overridden via a sysctl.
	 */</span>
	vm_global_no_user_wire_amount = MIN(max_mem*20/100,
					    VM_NOT_USER_WIREABLE);
	vm_global_user_wire_limit = max_mem - vm_global_no_user_wire_amount;
	
	<span class="enscript-comment">/* the default per user limit is the same as the global limit */</span>
	vm_user_wire_limit = vm_global_user_wire_limit;
}


<span class="enscript-comment">/*
 *	Routine:	copyinmap
 *	Purpose:
 *		Like copyin, except that fromaddr is an address
 *		in the specified VM map.  This implementation
 *		is incomplete; it handles the current user map
 *		and the kernel map/submaps.
 */</span>
kern_return_t
<span class="enscript-function-name">copyinmap</span>(
	vm_map_t		map,
	vm_map_offset_t		fromaddr,
	<span class="enscript-type">void</span>			*todata,
	vm_size_t		length)
{
	kern_return_t	kr = KERN_SUCCESS;
	vm_map_t oldmap;

	<span class="enscript-keyword">if</span> (vm_map_pmap(map) == pmap_kernel())
	{
		<span class="enscript-comment">/* assume a correct copy */</span>
		memcpy(todata, CAST_DOWN(<span class="enscript-type">void</span> *, fromaddr), length);
	} 
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (current_map() == map)
	{
		<span class="enscript-keyword">if</span> (copyin(fromaddr, todata, length) != 0)
			kr = KERN_INVALID_ADDRESS;
	}
	<span class="enscript-keyword">else</span>
	{
		vm_map_reference(map);
		oldmap = vm_map_switch(map);
		<span class="enscript-keyword">if</span> (copyin(fromaddr, todata, length) != 0)
			kr = KERN_INVALID_ADDRESS;
		vm_map_switch(oldmap);
		vm_map_deallocate(map);
	}
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	copyoutmap
 *	Purpose:
 *		Like copyout, except that toaddr is an address
 *		in the specified VM map.  This implementation
 *		is incomplete; it handles the current user map
 *		and the kernel map/submaps.
 */</span>
kern_return_t
<span class="enscript-function-name">copyoutmap</span>(
	vm_map_t		map,
	<span class="enscript-type">void</span>			*fromdata,
	vm_map_address_t	toaddr,
	vm_size_t		length)
{
	<span class="enscript-keyword">if</span> (vm_map_pmap(map) == pmap_kernel()) {
		<span class="enscript-comment">/* assume a correct copy */</span>
		memcpy(CAST_DOWN(<span class="enscript-type">void</span> *, toaddr), fromdata, length);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">if</span> (current_map() != map)
		<span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;

	<span class="enscript-keyword">if</span> (copyout(fromdata, toaddr, length) != 0)
		<span class="enscript-keyword">return</span> KERN_INVALID_ADDRESS;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


kern_return_t
<span class="enscript-function-name">vm_conflict_check</span>(
	vm_map_t		map,
	vm_map_offset_t	off,
	vm_map_size_t		len,
	memory_object_t	pager,
	vm_object_offset_t	file_off)
{
	vm_map_entry_t		entry;
	vm_object_t		obj;
	vm_object_offset_t	obj_off;
	vm_map_t		base_map;
	vm_map_offset_t		base_offset;
	vm_map_offset_t		original_offset;
	kern_return_t		kr;
	vm_map_size_t		local_len;

	base_map = map;
	base_offset = off;
	original_offset = off;
	kr = KERN_SUCCESS;
	vm_map_lock(map);
	<span class="enscript-keyword">while</span>(vm_map_lookup_entry(map, off, &amp;entry)) {
		local_len = len;

		<span class="enscript-keyword">if</span> (VME_OBJECT(entry) == VM_OBJECT_NULL) {
			vm_map_unlock(map);
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}
		<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map) {
			vm_map_t	old_map;

			old_map = map;
			vm_map_lock(VME_SUBMAP(entry));
			map = VME_SUBMAP(entry);
			off = VME_OFFSET(entry) + (off - entry-&gt;vme_start);
			vm_map_unlock(old_map);
			<span class="enscript-keyword">continue</span>;
		}
		obj = VME_OBJECT(entry);
		obj_off = (off - entry-&gt;vme_start) + VME_OFFSET(entry);
		<span class="enscript-keyword">while</span>(obj-&gt;shadow) {
			obj_off += obj-&gt;vo_shadow_offset;
			obj = obj-&gt;shadow;
		}
		<span class="enscript-keyword">if</span>((obj-&gt;pager_created) &amp;&amp; (obj-&gt;pager == pager)) {
			<span class="enscript-keyword">if</span>(((obj-&gt;paging_offset) + obj_off) == file_off) {
				<span class="enscript-keyword">if</span>(off != base_offset) {
					vm_map_unlock(map);
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				}
				kr = KERN_ALREADY_WAITING;
			} <span class="enscript-keyword">else</span> {
			       	vm_object_offset_t	obj_off_aligned;
				vm_object_offset_t	file_off_aligned;

				obj_off_aligned = obj_off &amp; ~PAGE_MASK;
				file_off_aligned = file_off &amp; ~PAGE_MASK;

				<span class="enscript-keyword">if</span> (file_off_aligned == (obj-&gt;paging_offset + obj_off_aligned)) {
				        <span class="enscript-comment">/*
					 * the target map and the file offset start in the same page
					 * but are not identical... 
					 */</span>
				        vm_map_unlock(map);
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				}
				<span class="enscript-keyword">if</span> ((file_off &lt; (obj-&gt;paging_offset + obj_off_aligned)) &amp;&amp;
				    ((file_off + len) &gt; (obj-&gt;paging_offset + obj_off_aligned))) {
				        <span class="enscript-comment">/*
					 * some portion of the tail of the I/O will fall
					 * within the encompass of the target map
					 */</span>
				        vm_map_unlock(map);
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				}
				<span class="enscript-keyword">if</span> ((file_off_aligned &gt; (obj-&gt;paging_offset + obj_off)) &amp;&amp;
				    (file_off_aligned &lt; (obj-&gt;paging_offset + obj_off) + len)) {
				        <span class="enscript-comment">/*
					 * the beginning page of the file offset falls within
					 * the target map's encompass
					 */</span>
				        vm_map_unlock(map);
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				}
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(kr != KERN_SUCCESS) {
		        vm_map_unlock(map);
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}

		<span class="enscript-keyword">if</span>(len &lt;= ((entry-&gt;vme_end - entry-&gt;vme_start) -
						(off - entry-&gt;vme_start))) {
			vm_map_unlock(map);
			<span class="enscript-keyword">return</span> kr;
		} <span class="enscript-keyword">else</span> {
			len -= (entry-&gt;vme_end - entry-&gt;vme_start) -
						(off - entry-&gt;vme_start);
		}
		base_offset = base_offset + (local_len - len);
		file_off = file_off + (local_len - len);
		off = base_offset;
		<span class="enscript-keyword">if</span>(map != base_map) {
			vm_map_unlock(map);
			vm_map_lock(base_map);
			map = base_map;
		}
	}

	vm_map_unlock(map);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *
 *	The following two functions are to be used when exposing kernel
 *	addresses to userspace via any of the various debug or info
 *	facilities that exist. These are basically the same as VM_KERNEL_ADDRPERM()
 *	and VM_KERNEL_UNSLIDE_OR_PERM() except they use a different random seed and
 *	are exported to KEXTs.
 *
 *	NOTE: USE THE MACRO VERSIONS OF THESE FUNCTIONS (in vm_param.h) FROM WITHIN THE KERNEL
 */</span>

<span class="enscript-comment">/*
 *	vm_kernel_addrperm_external:
 *
 *	Used when exposing an address to userspace which is in the kernel's
 *	&quot;heap&quot;. These addresses are not loaded from anywhere and are resultingly
 *	unslid. We apply a permutation value to obscure the address.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_kernel_addrperm_external</span>(
	vm_offset_t addr,
	vm_offset_t *perm_addr)
{
	<span class="enscript-keyword">if</span> (addr == 0) {
		*perm_addr = 0;
		<span class="enscript-keyword">return</span>;
	}

	*perm_addr = (addr + vm_kernel_addrperm_ext);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *	vm_kernel_unslide_or_perm_external:
 *
 *	Use this macro when exposing an address to userspace that could come from
 *	either kernel text/data *or* the heap.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_kernel_unslide_or_perm_external</span>(
	vm_offset_t addr,
	vm_offset_t *up_addr)
{
	<span class="enscript-keyword">if</span> (VM_KERNEL_IS_SLID(addr) || VM_KERNEL_IS_KEXT(addr) ||
        VM_KERNEL_IS_PRELINKTEXT(addr) || VM_KERNEL_IS_PRELINKINFO(addr) ||
        VM_KERNEL_IS_KEXT_LINKEDIT(addr)) {
		*up_addr = addr - vm_kernel_slide;
		<span class="enscript-keyword">return</span>;
	}

	vm_kernel_addrperm_external(addr, up_addr);
	<span class="enscript-keyword">return</span>;
}
</pre>
<hr />
</body></html>