<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_phantom_cache.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_phantom_cache.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_phantom_cache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor.h&gt;</span>


uint32_t phantom_cache_eval_period_in_msecs = 250;
uint32_t phantom_cache_thrashing_threshold_ssd = 1000;
uint32_t phantom_cache_thrashing_threshold = 100;

<span class="enscript-comment">/*
 * Number of consecutive thrashing periods required before
 * vm_phantom_cache_check_pressure() returns true.
 */</span>
<span class="enscript-type">unsigned</span> phantom_cache_contiguous_periods = 2;

clock_sec_t	pc_start_of_eval_period_sec = 0;
clock_nsec_t	pc_start_of_eval_period_nsec = 0;
boolean_t	pc_need_eval_reset = FALSE;

<span class="enscript-comment">/* One bit per recent sampling period. Bit 0 = current period. */</span>
uint32_t	pc_history = 0;

uint32_t	sample_period_ghost_added_count = 0;
uint32_t	sample_period_ghost_added_count_ssd = 0;
uint32_t	sample_period_ghost_found_count = 0;
uint32_t	sample_period_ghost_found_count_ssd = 0;

uint32_t	vm_phantom_object_id = 1;
#<span class="enscript-reference">define</span>		<span class="enscript-variable-name">VM_PHANTOM_OBJECT_ID_AFTER_WRAP</span>	1000000

vm_ghost_t	vm_phantom_cache;
uint32_t	vm_phantom_cache_nindx = 1;
uint32_t	vm_phantom_cache_num_entries = 0;
uint32_t	vm_phantom_cache_size;

<span class="enscript-type">typedef</span>	uint32_t	vm_phantom_hash_entry_t;
vm_phantom_hash_entry_t	*vm_phantom_cache_hash;
uint32_t	vm_phantom_cache_hash_size;
uint32_t	vm_ghost_hash_mask;		<span class="enscript-comment">/* Mask for hash function */</span>
uint32_t	vm_ghost_bucket_hash;		<span class="enscript-comment">/* Basic bucket hash */</span>


<span class="enscript-type">int</span> pg_masks[4] = {
	0x1, 0x2, 0x4, 0x8
};


#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_phantom_hash</span>(obj_id, offset) (\
		( (natural_t)((uintptr_t)obj_id * vm_ghost_bucket_hash) + (offset ^ vm_ghost_bucket_hash)) &amp; vm_ghost_hash_mask)


<span class="enscript-type">struct</span> phantom_cache_stats {
	uint32_t	pcs_wrapped;
	uint32_t	pcs_added_page_to_entry;
	uint32_t	pcs_added_new_entry;
	uint32_t	pcs_replaced_entry;

	uint32_t	pcs_lookup_found_page_in_cache;
	uint32_t	pcs_lookup_entry_not_in_cache;
	uint32_t	pcs_lookup_page_not_in_entry;

	uint32_t	pcs_updated_phantom_state;
} phantom_cache_stats;


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_phantom_cache_init</span>()
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	num_entries;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	log1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	size;

	num_entries = (uint32_t)(((max_mem / PAGE_SIZE) / 4) / VM_GHOST_PAGES_PER_ENTRY);
	vm_phantom_cache_num_entries = 1;

	<span class="enscript-keyword">while</span> (vm_phantom_cache_num_entries &lt; num_entries)
		vm_phantom_cache_num_entries &lt;&lt;= 1;

	vm_phantom_cache_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vm_ghost) * vm_phantom_cache_num_entries;
	vm_phantom_cache_hash_size = <span class="enscript-keyword">sizeof</span>(vm_phantom_hash_entry_t) * vm_phantom_cache_num_entries;

	<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, (vm_offset_t *)(&amp;vm_phantom_cache), vm_phantom_cache_size, 0, KMA_KOBJECT | KMA_PERMANENT, VM_KERN_MEMORY_PHANTOM_CACHE) != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;vm_phantom_cache_init: kernel_memory_allocate failed\n&quot;</span>);
	bzero(vm_phantom_cache, vm_phantom_cache_size);

	<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, (vm_offset_t *)(&amp;vm_phantom_cache_hash), vm_phantom_cache_hash_size, 0, KMA_KOBJECT | KMA_PERMANENT, VM_KERN_MEMORY_PHANTOM_CACHE) != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;vm_phantom_cache_init: kernel_memory_allocate failed\n&quot;</span>);
	bzero(vm_phantom_cache_hash, vm_phantom_cache_hash_size);


	vm_ghost_hash_mask = vm_phantom_cache_num_entries - 1;

	<span class="enscript-comment">/*
	 *	Calculate object_id shift value for hashing algorithm:
	 *		O = log2(sizeof(struct vm_object))
	 *		B = log2(vm_page_bucket_count)
	 *	        hash shifts the object_id left by
	 *		B/2 - O
	 */</span>
	size = vm_phantom_cache_num_entries;
	<span class="enscript-keyword">for</span> (log1 = 0; size &gt; 1; log1++) 
		size /= 2;
	
	vm_ghost_bucket_hash = 1 &lt;&lt; ((log1 + 1) &gt;&gt; 1);		<span class="enscript-comment">/* Get (ceiling of sqrt of table size) */</span>
	vm_ghost_bucket_hash |= 1 &lt;&lt; ((log1 + 1) &gt;&gt; 2);		<span class="enscript-comment">/* Get (ceiling of quadroot of table size) */</span>
	vm_ghost_bucket_hash |= 1;				<span class="enscript-comment">/* Set bit and add 1 - always must be 1 to insure unique series */</span>

	<span class="enscript-keyword">if</span> (vm_ghost_hash_mask &amp; vm_phantom_cache_num_entries)
		printf(<span class="enscript-string">&quot;vm_phantom_cache_init: WARNING -- strange page hash\n&quot;</span>);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_phantom_cache_add_ghost</span>(vm_page_t m)
{
	vm_ghost_t	vpce;
	<span class="enscript-type">int</span>		ghost_index;
	<span class="enscript-type">int</span>		pg_mask;
	boolean_t	isSSD = FALSE;
	vm_phantom_hash_entry_t ghost_hash_index;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
	vm_object_lock_assert_exclusive(m-&gt;object);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (vm_phantom_cache_num_entries == 0)
		<span class="enscript-keyword">return</span>;
	
	pg_mask = pg_masks[(m-&gt;offset &gt;&gt; PAGE_SHIFT) &amp; VM_GHOST_PAGE_MASK];

	<span class="enscript-keyword">if</span> (m-&gt;object-&gt;phantom_object_id == 0) {

		vnode_pager_get_isSSD(m-&gt;object-&gt;pager, &amp;isSSD);

		<span class="enscript-keyword">if</span> (isSSD == TRUE)
			m-&gt;object-&gt;phantom_isssd = TRUE;

		m-&gt;object-&gt;phantom_object_id = vm_phantom_object_id++;
		
		<span class="enscript-keyword">if</span> (vm_phantom_object_id == 0)
			vm_phantom_object_id = VM_PHANTOM_OBJECT_ID_AFTER_WRAP;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ( (vpce = vm_phantom_cache_lookup_ghost(m, 0)) ) {
			vpce-&gt;g_pages_held |= pg_mask;
			
			phantom_cache_stats.pcs_added_page_to_entry++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	<span class="enscript-comment">/*
	 * if we're here then the vm_ghost_t of this vm_page_t
	 * is not present in the phantom cache... take the next
	 * available entry in the LRU first evicting the existing
	 * entry if we've wrapped the ring
	 */</span>
	ghost_index = vm_phantom_cache_nindx++;

	<span class="enscript-keyword">if</span> (vm_phantom_cache_nindx == vm_phantom_cache_num_entries) {
		vm_phantom_cache_nindx = 1;

		phantom_cache_stats.pcs_wrapped++;
	}
	vpce = &amp;vm_phantom_cache[ghost_index];

	<span class="enscript-keyword">if</span> (vpce-&gt;g_obj_id) {
		<span class="enscript-comment">/*
		 * we're going to replace an existing entry
		 * so first remove it from the hash
		 */</span>
		vm_ghost_t	nvpce;

		ghost_hash_index = vm_phantom_hash(vpce-&gt;g_obj_id, vpce-&gt;g_obj_offset);

		nvpce = &amp;vm_phantom_cache[vm_phantom_cache_hash[ghost_hash_index]];

		<span class="enscript-keyword">if</span> (nvpce == vpce) {
			vm_phantom_cache_hash[ghost_hash_index] = vpce-&gt;g_next_index;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">for</span> (;;) {
				<span class="enscript-keyword">if</span> (nvpce-&gt;g_next_index == 0)
					panic(<span class="enscript-string">&quot;didn't find ghost in hash\n&quot;</span>);

				<span class="enscript-keyword">if</span> (&amp;vm_phantom_cache[nvpce-&gt;g_next_index] == vpce) {
					nvpce-&gt;g_next_index = vpce-&gt;g_next_index;
					<span class="enscript-keyword">break</span>;
				}
				nvpce = &amp;vm_phantom_cache[nvpce-&gt;g_next_index];
			}
		}
		phantom_cache_stats.pcs_replaced_entry++;
	} <span class="enscript-keyword">else</span>
		phantom_cache_stats.pcs_added_new_entry++;

	vpce-&gt;g_pages_held = pg_mask;
	vpce-&gt;g_obj_offset = (m-&gt;offset &gt;&gt; (PAGE_SHIFT + VM_GHOST_PAGE_SHIFT)) &amp; VM_GHOST_OFFSET_MASK;
	vpce-&gt;g_obj_id = m-&gt;object-&gt;phantom_object_id;

	ghost_hash_index = vm_phantom_hash(vpce-&gt;g_obj_id, vpce-&gt;g_obj_offset);
	vpce-&gt;g_next_index = vm_phantom_cache_hash[ghost_hash_index];
	vm_phantom_cache_hash[ghost_hash_index] = ghost_index;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (m-&gt;object-&gt;phantom_isssd)
		OSAddAtomic(1, &amp;sample_period_ghost_added_count_ssd);
	<span class="enscript-keyword">else</span>
		OSAddAtomic(1, &amp;sample_period_ghost_added_count);
}


vm_ghost_t
<span class="enscript-function-name">vm_phantom_cache_lookup_ghost</span>(vm_page_t m, uint32_t pg_mask)
{
	uint64_t	g_obj_offset;
	uint32_t	g_obj_id;
	uint32_t	ghost_index;

	<span class="enscript-keyword">if</span> ((g_obj_id = m-&gt;object-&gt;phantom_object_id) == 0) {
		<span class="enscript-comment">/*
		 * no entries in phantom cache for this object
		 */</span>
		<span class="enscript-keyword">return</span> (NULL);
	}
	g_obj_offset = (m-&gt;offset &gt;&gt; (PAGE_SHIFT + VM_GHOST_PAGE_SHIFT)) &amp; VM_GHOST_OFFSET_MASK;

	ghost_index = vm_phantom_cache_hash[vm_phantom_hash(g_obj_id, g_obj_offset)];

	<span class="enscript-keyword">while</span> (ghost_index) {
		vm_ghost_t      vpce;

		vpce = &amp;vm_phantom_cache[ghost_index];

		<span class="enscript-keyword">if</span> (vpce-&gt;g_obj_id == g_obj_id &amp;&amp; vpce-&gt;g_obj_offset == g_obj_offset) {

			<span class="enscript-keyword">if</span> (pg_mask == 0 || (vpce-&gt;g_pages_held &amp; pg_mask)) {
				phantom_cache_stats.pcs_lookup_found_page_in_cache++;

				<span class="enscript-keyword">return</span> (vpce);
			}
			phantom_cache_stats.pcs_lookup_page_not_in_entry++;

			<span class="enscript-keyword">return</span> (NULL);
		}
		ghost_index = vpce-&gt;g_next_index;
	}
	phantom_cache_stats.pcs_lookup_entry_not_in_cache++;

	<span class="enscript-keyword">return</span> (NULL);
}



<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_phantom_cache_update</span>(vm_page_t m)
{
	<span class="enscript-type">int</span>		pg_mask;
	vm_ghost_t      vpce;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
	vm_object_lock_assert_exclusive(m-&gt;object);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (vm_phantom_cache_num_entries == 0)
		<span class="enscript-keyword">return</span>;
	
	pg_mask = pg_masks[(m-&gt;offset &gt;&gt; PAGE_SHIFT) &amp; VM_GHOST_PAGE_MASK];
	
	<span class="enscript-keyword">if</span> ( (vpce = vm_phantom_cache_lookup_ghost(m, pg_mask)) ) {

		vpce-&gt;g_pages_held &amp;= ~pg_mask;

		phantom_cache_stats.pcs_updated_phantom_state++;

		<span class="enscript-keyword">if</span> (m-&gt;object-&gt;phantom_isssd)
			OSAddAtomic(1, &amp;sample_period_ghost_found_count_ssd);
		<span class="enscript-keyword">else</span>
			OSAddAtomic(1, &amp;sample_period_ghost_found_count);
	}
}


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHANTOM_CACHE_DEBUG</span>	1

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">PHANTOM_CACHE_DEBUG</span>

<span class="enscript-type">int</span>	sample_period_ghost_counts_indx = 0;

<span class="enscript-type">struct</span> {
	uint32_t	added;
	uint32_t	found;
	uint32_t	added_ssd;
	uint32_t	found_ssd;
	uint32_t	elapsed_ms;
	boolean_t	pressure_detected;
} sample_period_ghost_counts[256];

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Determine if the file cache is thrashing from sampling interval statistics.
 *
 * Pages added to the phantom cache = pages evicted from the file cache.
 * Pages found in the phantom cache = reads of pages that were recently evicted.
 * Threshold is the latency-dependent number of reads we consider thrashing.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">is_thrashing</span>(uint32_t added, uint32_t found, uint32_t threshold)
{
	<span class="enscript-comment">/* Ignore normal activity below the threshold. */</span>
	<span class="enscript-keyword">if</span> (added &lt; threshold || found &lt; threshold)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-comment">/*
	 * When thrashing in a way that we can mitigate, most of the pages read
	 * into the file cache were recently evicted, and 'found' will be close
	 * to 'added'.
	 *
	 * When replacing the current working set because a new app is
	 * launched, we see very high read traffic with sporadic phantom cache
	 * hits.
	 *
	 * This is not thrashing, or freeing up memory wouldn't help much
	 * anyway.
	 */</span>
	<span class="enscript-keyword">if</span> (found &lt; added / 2)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * the following function is never called
 * from multiple threads simultaneously due
 * to a condition variable used to serialize
 * at the compressor level... thus no need
 * to provide locking for the sample processing
 */</span>
boolean_t
<span class="enscript-function-name">vm_phantom_cache_check_pressure</span>()
{
        clock_sec_t	cur_ts_sec;
        clock_nsec_t	cur_ts_nsec;
	uint64_t	elapsed_msecs_in_eval;
	boolean_t	pressure_detected = FALSE;

	clock_get_system_nanotime(&amp;cur_ts_sec, &amp;cur_ts_nsec);

	elapsed_msecs_in_eval = vm_compressor_compute_elapsed_msecs(cur_ts_sec, cur_ts_nsec, pc_start_of_eval_period_sec, pc_start_of_eval_period_nsec);

	<span class="enscript-comment">/*
	 * Reset evaluation period after phantom_cache_eval_period_in_msecs or
	 * whenever vm_phantom_cache_restart_sample has been called.
	 */</span>
	<span class="enscript-keyword">if</span> (elapsed_msecs_in_eval &gt;= phantom_cache_eval_period_in_msecs) {
		pc_need_eval_reset = TRUE;
	}

	<span class="enscript-keyword">if</span> (pc_need_eval_reset == TRUE) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PHANTOM_CACHE_DEBUG</span>
		<span class="enscript-comment">/*
		 * maintain some info about the last 256 sample periods
		 */</span>
		sample_period_ghost_counts[sample_period_ghost_counts_indx].added = sample_period_ghost_added_count;
		sample_period_ghost_counts[sample_period_ghost_counts_indx].found = sample_period_ghost_found_count;
		sample_period_ghost_counts[sample_period_ghost_counts_indx].added_ssd = sample_period_ghost_added_count_ssd;
		sample_period_ghost_counts[sample_period_ghost_counts_indx].found_ssd = sample_period_ghost_found_count_ssd;
		sample_period_ghost_counts[sample_period_ghost_counts_indx].elapsed_ms = (uint32_t)elapsed_msecs_in_eval;

		sample_period_ghost_counts_indx++;

		<span class="enscript-keyword">if</span> (sample_period_ghost_counts_indx &gt;= 256)
			sample_period_ghost_counts_indx = 0;
#<span class="enscript-reference">endif</span>
		sample_period_ghost_added_count = 0;
		sample_period_ghost_found_count = 0;
		sample_period_ghost_added_count_ssd = 0;
		sample_period_ghost_found_count_ssd = 0;

		pc_start_of_eval_period_sec = cur_ts_sec;
		pc_start_of_eval_period_nsec = cur_ts_nsec;
		pc_history &lt;&lt;= 1;
		pc_need_eval_reset = FALSE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Since the trashing rate is really a function of the read latency of the disk
		 * we have to consider both the SSD and spinning disk case since the file cache
		 * could be backed by either or even both flavors.  When the object is first
		 * assigned a phantom_object_id, we query the pager to determine if the backing
		 * backing media is an SSD and remember that answer in the vm_object.  We use
		 * that info to maintains counts for both the SSD and spinning disk cases.
		 */</span>
		<span class="enscript-keyword">if</span> (is_thrashing(sample_period_ghost_added_count,
				 sample_period_ghost_found_count,
				 phantom_cache_thrashing_threshold) ||
		    is_thrashing(sample_period_ghost_added_count_ssd,
				 sample_period_ghost_found_count_ssd,
				 phantom_cache_thrashing_threshold_ssd)) {
			<span class="enscript-comment">/* Thrashing in the current period: Set bit 0. */</span>
			pc_history |= 1;
		}
	}

	<span class="enscript-comment">/*
	 * Declare pressure_detected after phantom_cache_contiguous_periods.
	 *
	 * Create a bitmask with the N low bits set. These bits must all be set
	 * in pc_history. The high bits of pc_history are ignored.
	 */</span>
	uint32_t bitmask = (1u &lt;&lt; phantom_cache_contiguous_periods) - 1;
	<span class="enscript-keyword">if</span> ((pc_history &amp; bitmask) == bitmask)
		pressure_detected = TRUE;

	<span class="enscript-keyword">if</span> (vm_page_external_count &gt; ((AVAILABLE_MEMORY) * 50) / 100)
		pressure_detected = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PHANTOM_CACHE_DEBUG</span>
	sample_period_ghost_counts[sample_period_ghost_counts_indx].pressure_detected = pressure_detected;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (pressure_detected);
}

<span class="enscript-comment">/*
 * Restart the current sampling because conditions have changed significantly,
 * and we don't want to react to old data.
 *
 * This function can be called from any thread.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_phantom_cache_restart_sample</span>(<span class="enscript-type">void</span>)
{
	pc_need_eval_reset = TRUE;
}
</pre>
<hr />
</body></html>