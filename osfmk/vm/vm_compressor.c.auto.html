<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_compressor.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_compressor.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_phantom_cache.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host.h&gt;</span>		<span class="enscript-comment">/* for host_info() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_alerts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_object_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>

<span class="enscript-comment">/*
 * vm_compressor_mode has a heirarchy of control to set its value.
 * boot-args are checked first, then device-tree, and finally
 * the default value that is defined below. See vm_fault_init() for
 * the boot-arg &amp; device-tree code.
 */</span>


<span class="enscript-type">int</span>		vm_compressor_mode = VM_PAGER_COMPRESSOR_WITH_SWAP;
<span class="enscript-type">int</span>		vm_scale = 16;


<span class="enscript-type">int</span>		vm_compressor_is_active = 0;
<span class="enscript-type">int</span>		vm_compression_limit = 0;
<span class="enscript-type">int</span>		vm_compressor_available = 0;

<span class="enscript-type">extern</span> boolean_t vm_swap_up;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	vm_pageout_io_throttle(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	not_in_kdp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_DATA</span> || <span class="enscript-variable-name">CHECKSUM_THE_SWAP</span> || <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hash_string</span>(<span class="enscript-type">char</span> *cp, <span class="enscript-type">int</span> len);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNPACK_C_SIZE</span>(cs)	((cs-&gt;c_size == (PAGE_SIZE-1)) ? PAGE_SIZE : cs-&gt;c_size)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PACK_C_SIZE</span>(cs, size)	(cs-&gt;c_size = ((size == PAGE_SIZE) ? PAGE_SIZE - 1 : size))


<span class="enscript-type">struct</span> c_sv_hash_entry {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span>	{
			uint32_t	c_sv_he_ref;
			uint32_t	c_sv_he_data;
		} c_sv_he;
		uint64_t	c_sv_he_record;

	} c_sv_he_un;	
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">he_ref</span>	c_sv_he_un.c_sv_he.c_sv_he_ref
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">he_data</span>	c_sv_he_un.c_sv_he.c_sv_he_data
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">he_record</span> c_sv_he_un.c_sv_he_record

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SV_HASH_MAX_MISS</span>	32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SV_HASH_SIZE</span>		((1 &lt;&lt; 10))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SV_HASH_MASK</span>		((1 &lt;&lt; 10) - 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SV_CSEG_ID</span>		((1 &lt;&lt; 22) - 1)


<span class="enscript-type">struct</span>  c_slot_mapping {
        uint32_t        s_cseg:22, 	<span class="enscript-comment">/* segment number + 1 */</span>
			<span class="enscript-reference">s_cindx</span>:10;	<span class="enscript-comment">/* index in the segment */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SLOT_MAX_INDEX</span>	(1 &lt;&lt; 10)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> c_slot_mapping *c_slot_mapping_t;


<span class="enscript-type">union</span> c_segu {
	c_segment_t	c_seg;
	uint32_t	c_segno;
};



#<span class="enscript-reference">define</span> <span class="enscript-function-name">C_SLOT_PACK_PTR</span>(ptr)		(((uintptr_t)ptr - (uintptr_t) VM_MIN_KERNEL_AND_KEXT_ADDRESS) &gt;&gt; 2)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">C_SLOT_UNPACK_PTR</span>(cslot)	((uintptr_t)(cslot-&gt;c_packed_ptr &lt;&lt; 2) + (uintptr_t) VM_MIN_KERNEL_AND_KEXT_ADDRESS)


uint32_t	c_segment_count = 0;
uint32_t	c_segment_count_max = 0;

uint64_t	c_generation_id = 0;
uint64_t	c_generation_id_flush_barrier;


#<span class="enscript-reference">define</span>		<span class="enscript-variable-name">HIBERNATE_FLUSHING_SECS_TO_COMPLETE</span>	120

boolean_t	hibernate_no_swapspace = FALSE;
clock_sec_t	hibernate_flushing_deadline = 0;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>
<span class="enscript-type">char</span>	*c_compressed_record_sbuf;
<span class="enscript-type">char</span>	*c_compressed_record_ebuf;
<span class="enscript-type">char</span>	*c_compressed_record_cptr;
#<span class="enscript-reference">endif</span>


queue_head_t	c_age_list_head;
queue_head_t	c_swapout_list_head;
queue_head_t	c_swappedin_list_head;
queue_head_t	c_swappedout_list_head;
queue_head_t	c_swappedout_sparse_list_head;
queue_head_t	c_major_list_head;
queue_head_t	c_filling_list_head;
queue_head_t	c_bad_list_head;

uint32_t	c_age_count = 0;
uint32_t	c_swapout_count = 0;
uint32_t	c_swappedin_count = 0;
uint32_t	c_swappedout_count = 0;
uint32_t	c_swappedout_sparse_count = 0;
uint32_t	c_major_count = 0;
uint32_t	c_filling_count = 0;
uint32_t	c_empty_count = 0;
uint32_t	c_bad_count = 0;


queue_head_t	c_minor_list_head;
uint32_t	c_minor_count = 0;

<span class="enscript-type">int</span>		c_overage_swapped_count = 0;
<span class="enscript-type">int</span>		c_overage_swapped_limit = 0;

<span class="enscript-type">int</span>		c_seg_fixed_array_len;
<span class="enscript-type">union</span>  c_segu	*c_segments;
vm_offset_t	c_buffers;
vm_size_t       c_buffers_size;
caddr_t		c_segments_next_page;
boolean_t	c_segments_busy;
uint32_t	c_segments_available;
uint32_t	c_segments_limit;
uint32_t	c_segments_nearing_limit;

uint32_t	c_segment_svp_in_hash;
uint32_t	c_segment_svp_hash_succeeded;
uint32_t	c_segment_svp_hash_failed;
uint32_t	c_segment_svp_zero_compressions;
uint32_t	c_segment_svp_nonzero_compressions;
uint32_t	c_segment_svp_zero_decompressions;
uint32_t	c_segment_svp_nonzero_decompressions;

uint32_t	c_segment_noncompressible_pages;

uint32_t	c_segment_pages_compressed;
uint32_t	c_segment_pages_compressed_limit;
uint32_t	c_segment_pages_compressed_nearing_limit;
uint32_t	c_free_segno_head = (uint32_t)-1;

uint32_t	vm_compressor_minorcompact_threshold_divisor = 10;
uint32_t	vm_compressor_majorcompact_threshold_divisor = 10;
uint32_t	vm_compressor_unthrottle_threshold_divisor = 10;
uint32_t	vm_compressor_catchup_threshold_divisor = 10;

#<span class="enscript-reference">define</span>		<span class="enscript-variable-name">C_SEGMENTS_PER_PAGE</span>	(PAGE_SIZE / sizeof(union c_segu))


lck_grp_attr_t	vm_compressor_lck_grp_attr;
lck_attr_t	vm_compressor_lck_attr;
lck_grp_t	vm_compressor_lck_grp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
lck_mtx_t	*c_list_lock;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>
lck_spin_t	*c_list_lock;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>

lck_rw_t	c_master_lock;
boolean_t	decompressions_blocked = FALSE;

zone_t		compressor_segment_zone;
<span class="enscript-type">int</span>		c_compressor_swap_trigger = 0;

uint32_t	compressor_cpus;
<span class="enscript-type">char</span>		*compressor_scratch_bufs;
<span class="enscript-type">char</span>		*kdp_compressor_scratch_buf;
<span class="enscript-type">char</span>		*kdp_compressor_decompressed_page;
addr64_t	kdp_compressor_decompressed_page_paddr;
ppnum_t		kdp_compressor_decompressed_page_ppnum;

clock_sec_t	start_of_sample_period_sec = 0;
clock_nsec_t	start_of_sample_period_nsec = 0;
clock_sec_t	start_of_eval_period_sec = 0;
clock_nsec_t	start_of_eval_period_nsec = 0;
uint32_t	sample_period_decompression_count = 0;
uint32_t	sample_period_compression_count = 0;
uint32_t	last_eval_decompression_count = 0;
uint32_t	last_eval_compression_count = 0;

#<span class="enscript-reference">define</span>		<span class="enscript-variable-name">DECOMPRESSION_SAMPLE_MAX_AGE</span>		(60 * 30)

boolean_t	vm_swapout_ripe_segments = FALSE;
uint32_t	vm_ripe_target_age = (60 * 60 * 48);

uint32_t	swapout_target_age = 0;
uint32_t	age_of_decompressions_during_sample_period[DECOMPRESSION_SAMPLE_MAX_AGE];
uint32_t	overage_decompressions_during_sample_period = 0;

<span class="enscript-type">void</span>		do_fastwake_warmup(<span class="enscript-type">void</span>);
boolean_t	fastwake_warmup = FALSE;
boolean_t	fastwake_recording_in_progress = FALSE;
clock_sec_t	dont_trim_until_ts = 0;

uint64_t	c_segment_warmup_count;
uint64_t	first_c_segment_to_warm_generation_id = 0;
uint64_t	last_c_segment_to_warm_generation_id = 0;
boolean_t	hibernate_flushing = FALSE;

int64_t		c_segment_input_bytes __attribute__((aligned(8))) = 0;
int64_t		c_segment_compressed_bytes __attribute__((aligned(8))) = 0;
int64_t		compressor_bytes_used __attribute__((aligned(8))) = 0;


<span class="enscript-type">struct</span> c_sv_hash_entry c_segment_sv_hash_table[C_SV_HASH_SIZE]  __attribute__ ((aligned (8)));


<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">compressor_needs_to_swap</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_compressor_swap_trigger_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_compressor_do_delayed_compactions</span>(boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_compressor_compact_and_swap</span>(boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_compressor_age_swapped_in_segments</span>(boolean_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_compressor_take_paging_space_action</span>(<span class="enscript-type">void</span>);

boolean_t <span class="enscript-function-name">vm_compressor_low_on_space</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">compute_swapout_target_age</span>(<span class="enscript-type">void</span>);

boolean_t <span class="enscript-function-name">c_seg_major_compact</span>(c_segment_t, c_segment_t);
boolean_t <span class="enscript-function-name">c_seg_major_compact_ok</span>(c_segment_t, c_segment_t);

<span class="enscript-type">int</span>  <span class="enscript-function-name">c_seg_minor_compaction_and_unlock</span>(c_segment_t, boolean_t);
<span class="enscript-type">int</span>  <span class="enscript-function-name">c_seg_do_minor_compaction_and_unlock</span>(c_segment_t, boolean_t, boolean_t, boolean_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">c_seg_try_minor_compaction_and_unlock</span>(c_segment_t c_seg);
<span class="enscript-type">void</span> <span class="enscript-function-name">c_seg_need_delayed_compaction</span>(c_segment_t);

<span class="enscript-type">void</span> <span class="enscript-function-name">c_seg_move_to_sparse_list</span>(c_segment_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">c_seg_insert_into_q</span>(queue_head_t *, c_segment_t);

uint64_t <span class="enscript-function-name">vm_available_memory</span>(<span class="enscript-type">void</span>);
uint64_t <span class="enscript-function-name">vm_compressor_pages_compressed</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dp_pages_free, dp_pages_reserve;

uint64_t
<span class="enscript-function-name">vm_available_memory</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (((uint64_t)AVAILABLE_NON_COMPRESSED_MEMORY) * PAGE_SIZE_64);
}


uint64_t
<span class="enscript-function-name">vm_compressor_pages_compressed</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (c_segment_pages_compressed * PAGE_SIZE_64);
}


boolean_t
<span class="enscript-function-name">vm_compression_available</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> ( !(COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE))
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (c_segments_available &gt;= c_segments_limit || c_segment_pages_compressed &gt;= c_segment_pages_compressed_limit)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">return</span> (TRUE);
}


boolean_t
<span class="enscript-function-name">vm_compressor_low_on_space</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> ((c_segment_pages_compressed &gt; c_segment_pages_compressed_nearing_limit) ||
	    (c_segment_count &gt; c_segments_nearing_limit))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">return</span> (FALSE);
}
	    

<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_wants_task_throttled</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task == kernel_task)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (vm_compressor_mode == COMPRESSED_PAGER_IS_ACTIVE || vm_compressor_mode == DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {
		<span class="enscript-keyword">if</span> ((vm_compressor_low_on_space() || HARD_THROTTLE_LIMIT_REACHED()) &amp;&amp;
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)pmap_compressed(task-&gt;map-&gt;pmap) &gt; (c_segment_pages_compressed / 4))
			<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (((dp_pages_free + dp_pages_reserve &lt; 2000) &amp;&amp; VM_DYNAMIC_PAGING_ENABLED(memory_manager_default)) &amp;&amp;
		    get_task_resident_size(task) &gt; (((AVAILABLE_NON_COMPRESSED_MEMORY) * PAGE_SIZE) / 5))
			<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}



<span class="enscript-type">static</span> uint32_t	no_paging_space_action_in_progress = 0;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_send_low_swap_note</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_take_paging_space_action</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (no_paging_space_action_in_progress == 0) {

		<span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, (UInt32 *)&amp;no_paging_space_action_in_progress)) {

			<span class="enscript-keyword">if</span> (no_paging_space_action()) {
				memorystatus_send_low_swap_note();
			}

			no_paging_space_action_in_progress = 0;
		}
	}
}



<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_init_locks</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_setdefault(&amp;vm_compressor_lck_grp_attr);
	lck_grp_init(&amp;vm_compressor_lck_grp, <span class="enscript-string">&quot;vm_compressor&quot;</span>, &amp;vm_compressor_lck_grp_attr);
	lck_attr_setdefault(&amp;vm_compressor_lck_attr);

	lck_rw_init(&amp;c_master_lock, &amp;vm_compressor_lck_grp, &amp;vm_compressor_lck_attr);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_decompressor_lock</span>(<span class="enscript-type">void</span>)
{
	PAGE_REPLACEMENT_ALLOWED(TRUE);

	decompressions_blocked = TRUE;
	
	PAGE_REPLACEMENT_ALLOWED(FALSE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_decompressor_unlock</span>(<span class="enscript-type">void</span>)
{
	PAGE_REPLACEMENT_ALLOWED(TRUE);

	decompressions_blocked = FALSE;

	PAGE_REPLACEMENT_ALLOWED(FALSE);

	thread_wakeup((event_t)&amp;decompressions_blocked);
}



<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_init</span>(<span class="enscript-type">void</span>)
{
	thread_t	thread;
	<span class="enscript-type">struct</span> c_slot	cs_dummy;
	c_slot_t cs  = &amp;cs_dummy;
	<span class="enscript-type">int</span>		c_segment_min_size;
	<span class="enscript-type">int</span>		c_segment_padded_size;

	<span class="enscript-comment">/*
	 * ensure that any pointer that gets created from
	 * the vm_page zone can be packed properly
	 */</span>
	cs-&gt;c_packed_ptr = C_SLOT_PACK_PTR(zone_map_min_address);

	<span class="enscript-keyword">if</span> (C_SLOT_UNPACK_PTR(cs) != (uintptr_t)zone_map_min_address)
		panic(<span class="enscript-string">&quot;C_SLOT_UNPACK_PTR failed on zone_map_min_address - %p&quot;</span>, (<span class="enscript-type">void</span> *)zone_map_min_address);

	cs-&gt;c_packed_ptr = C_SLOT_PACK_PTR(zone_map_max_address);

	<span class="enscript-keyword">if</span> (C_SLOT_UNPACK_PTR(cs) != (uintptr_t)zone_map_max_address)
		panic(<span class="enscript-string">&quot;C_SLOT_UNPACK_PTR failed on zone_map_max_address - %p&quot;</span>, (<span class="enscript-type">void</span> *)zone_map_max_address);


	assert((C_SEGMENTS_PER_PAGE * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">union</span> c_segu)) == PAGE_SIZE);

	PE_parse_boot_argn(<span class="enscript-string">&quot;vm_compression_limit&quot;</span>, &amp;vm_compression_limit, <span class="enscript-keyword">sizeof</span> (vm_compression_limit));

	<span class="enscript-keyword">if</span> (max_mem &lt;= (3ULL * 1024ULL * 1024ULL * 1024ULL)) {
		vm_compressor_minorcompact_threshold_divisor = 11;
		vm_compressor_majorcompact_threshold_divisor = 13;
		vm_compressor_unthrottle_threshold_divisor = 20;
		vm_compressor_catchup_threshold_divisor = 35;
	} <span class="enscript-keyword">else</span> {
		vm_compressor_minorcompact_threshold_divisor = 20;
		vm_compressor_majorcompact_threshold_divisor = 25;
		vm_compressor_unthrottle_threshold_divisor = 35;
		vm_compressor_catchup_threshold_divisor = 50;
	}
	<span class="enscript-comment">/*
	 * vm_page_init_lck_grp is now responsible for calling vm_compressor_init_locks
	 * c_master_lock needs to be available early so that &quot;vm_page_find_contiguous&quot; can
	 * use PAGE_REPLACEMENT_ALLOWED to coordinate with the compressor.
	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
	c_list_lock = lck_mtx_alloc_init(&amp;vm_compressor_lck_grp, &amp;vm_compressor_lck_attr);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>
	c_list_lock = lck_spin_alloc_init(&amp;vm_compressor_lck_grp, &amp;vm_compressor_lck_attr);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>


	queue_init(&amp;c_bad_list_head);
	queue_init(&amp;c_age_list_head);
	queue_init(&amp;c_minor_list_head);
	queue_init(&amp;c_major_list_head);
	queue_init(&amp;c_filling_list_head);
	queue_init(&amp;c_swapout_list_head);
	queue_init(&amp;c_swappedin_list_head);
	queue_init(&amp;c_swappedout_list_head);
	queue_init(&amp;c_swappedout_sparse_list_head);

	c_segment_min_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_segment) + (C_SEG_SLOT_VAR_ARRAY_MIN_LEN * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_slot));
	
	<span class="enscript-keyword">for</span> (c_segment_padded_size = 128; c_segment_padded_size &lt; c_segment_min_size; c_segment_padded_size = c_segment_padded_size &lt;&lt; 1);

	compressor_segment_zone = zinit(c_segment_padded_size, 128000 * c_segment_padded_size, PAGE_SIZE, <span class="enscript-string">&quot;compressor_segment&quot;</span>);
	zone_change(compressor_segment_zone, Z_CALLERACCT, FALSE);
	zone_change(compressor_segment_zone, Z_NOENCRYPT, TRUE);

	c_seg_fixed_array_len = (c_segment_padded_size - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_segment)) / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_slot);
	
	c_free_segno_head = -1;
	c_segments_available = 0;

	<span class="enscript-keyword">if</span> (vm_compression_limit == 0) {
		c_segment_pages_compressed_limit = (uint32_t)((max_mem / PAGE_SIZE)) * vm_scale;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">OLD_SWAP_LIMIT</span>	(1024 * 1024 * 16)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SWAP_LIMIT</span>	(1024 * 1024 * 128)
	
		<span class="enscript-keyword">if</span> (c_segment_pages_compressed_limit &gt; (OLD_SWAP_LIMIT))
			c_segment_pages_compressed_limit = OLD_SWAP_LIMIT;

		<span class="enscript-keyword">if</span> (c_segment_pages_compressed_limit &lt; (uint32_t)(max_mem / PAGE_SIZE_64))
		        c_segment_pages_compressed_limit = (uint32_t)(max_mem / PAGE_SIZE_64);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (vm_compression_limit &lt; MAX_SWAP_LIMIT)
			c_segment_pages_compressed_limit = vm_compression_limit;
		<span class="enscript-keyword">else</span>
			c_segment_pages_compressed_limit = MAX_SWAP_LIMIT;
	}
	<span class="enscript-keyword">if</span> ((c_segments_limit = c_segment_pages_compressed_limit / (C_SEG_BUFSIZE / PAGE_SIZE)) &gt; C_SEG_MAX_LIMIT)
		c_segments_limit = C_SEG_MAX_LIMIT;

	c_segment_pages_compressed_nearing_limit = (c_segment_pages_compressed_limit * 98) / 100;
	c_segments_nearing_limit = (c_segments_limit * 98) / 100;

	c_segments_busy = FALSE;

	<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, (vm_offset_t *)(&amp;c_segments), (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">union</span> c_segu) * c_segments_limit), 0, KMA_KOBJECT | KMA_VAONLY | KMA_PERMANENT, VM_KERN_MEMORY_COMPRESSOR) != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;vm_compressor_init: kernel_memory_allocate failed - c_segments\n&quot;</span>);
	c_buffers_size = (vm_size_t)C_SEG_ALLOCSIZE * (vm_size_t)c_segments_limit;
	<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, &amp;c_buffers, c_buffers_size, 0, KMA_COMPRESSOR | KMA_VAONLY | KMA_PERMANENT, VM_KERN_MEMORY_COMPRESSOR) != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;vm_compressor_init: kernel_memory_allocate failed - c_buffers\n&quot;</span>);

	c_segments_next_page = (caddr_t)c_segments;

	{
		host_basic_info_data_t hinfo;
		mach_msg_type_number_t count = HOST_BASIC_INFO_COUNT;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BSD_HOST</span> 1
		host_info((host_t)BSD_HOST, HOST_BASIC_INFO, (host_info_t)&amp;hinfo, &amp;count);

		compressor_cpus = hinfo.max_cpus;

		compressor_scratch_bufs = kalloc_tag(compressor_cpus * WKdm_SCRATCH_BUF_SIZE, VM_KERN_MEMORY_COMPRESSOR);

		kdp_compressor_scratch_buf = kalloc_tag(WKdm_SCRATCH_BUF_SIZE, VM_KERN_MEMORY_COMPRESSOR);
		kdp_compressor_decompressed_page = kalloc_tag(PAGE_SIZE, VM_KERN_MEMORY_COMPRESSOR);
		kdp_compressor_decompressed_page_paddr = kvtophys((vm_offset_t)kdp_compressor_decompressed_page);
		kdp_compressor_decompressed_page_ppnum = (ppnum_t) atop(kdp_compressor_decompressed_page_paddr);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>		
	freezer_compressor_scratch_buf = kalloc_tag(WKdm_SCRATCH_BUF_SIZE, VM_KERN_MEMORY_COMPRESSOR);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>
	<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, (vm_offset_t *)&amp;c_compressed_record_sbuf, (vm_size_t)C_SEG_ALLOCSIZE + (PAGE_SIZE * 2), 0, KMA_KOBJECT, VM_KERN_MEMORY_COMPRESSOR) != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;vm_compressor_init: kernel_memory_allocate failed - c_compressed_record_sbuf\n&quot;</span>);

	c_compressed_record_cptr = c_compressed_record_sbuf;
	c_compressed_record_ebuf = c_compressed_record_sbuf + C_SEG_ALLOCSIZE + (PAGE_SIZE * 2);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (kernel_thread_start_priority((thread_continue_t)vm_compressor_swap_trigger_thread, NULL,
					 BASEPRI_PREEMPT - 1, &amp;thread) != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_compressor_swap_trigger_thread: create failed&quot;</span>);
	}
	thread_deallocate(thread);

	assert(default_pager_init_flag == 0);
		
	<span class="enscript-keyword">if</span> (vm_pageout_internal_start() != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_compressor_init: Failed to start the internal pageout thread.\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE)
		vm_compressor_swap_init();

	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED)
		vm_compressor_is_active = 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	memorystatus_freeze_enabled = TRUE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

	default_pager_init_flag = 1;
	vm_compressor_available = 1;

	vm_page_reactivate_all_throttled();
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VALIDATE_C_SEGMENTS</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_validate</span>(c_segment_t c_seg, boolean_t must_be_compact)
{
	<span class="enscript-type">int</span>		c_indx;
	int32_t		bytes_used;
	int32_t		bytes_unused;
	uint32_t	c_rounded_size;
	uint32_t	c_size;
	c_slot_t	cs;

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_firstemptyslot &lt; c_seg-&gt;c_nextslot) {
		c_indx = c_seg-&gt;c_firstemptyslot;
		cs = C_SEG_SLOT_FROM_INDEX(c_seg, c_indx);

		<span class="enscript-keyword">if</span> (cs == NULL)
			panic(<span class="enscript-string">&quot;c_seg_validate:  no slot backing c_firstemptyslot&quot;</span>);
	
		<span class="enscript-keyword">if</span> (cs-&gt;c_size)
			panic(<span class="enscript-string">&quot;c_seg_validate:  c_firstemptyslot has non-zero size (%d)\n&quot;</span>, cs-&gt;c_size);
	}
	bytes_used = 0;
	bytes_unused = 0;

	<span class="enscript-keyword">for</span> (c_indx = 0; c_indx &lt; c_seg-&gt;c_nextslot; c_indx++) {
		
		cs = C_SEG_SLOT_FROM_INDEX(c_seg, c_indx);

		c_size = UNPACK_C_SIZE(cs);

		c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;

		bytes_used += c_rounded_size;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
		<span class="enscript-keyword">if</span> (c_size &amp;&amp; cs-&gt;c_hash_compressed_data != hash_string((<span class="enscript-type">char</span> *)&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], c_size))
			panic(<span class="enscript-string">&quot;compressed data doesn't match original&quot;</span>);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">if</span> (bytes_used != c_seg-&gt;c_bytes_used)
		panic(<span class="enscript-string">&quot;c_seg_validate: bytes_used mismatch - found %d, segment has %d\n&quot;</span>, bytes_used, c_seg-&gt;c_bytes_used);

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used &gt; C_SEG_OFFSET_TO_BYTES((int32_t)c_seg-&gt;c_nextoffset))
		panic(<span class="enscript-string">&quot;c_seg_validate: c_bytes_used &gt; c_nextoffset - c_nextoffset = %d,  c_bytes_used = %d\n&quot;</span>,
		      (int32_t)C_SEG_OFFSET_TO_BYTES((int32_t)c_seg-&gt;c_nextoffset), c_seg-&gt;c_bytes_used);

	<span class="enscript-keyword">if</span> (must_be_compact) {
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used != C_SEG_OFFSET_TO_BYTES((int32_t)c_seg-&gt;c_nextoffset))
			panic(<span class="enscript-string">&quot;c_seg_validate: c_bytes_used doesn't match c_nextoffset - c_nextoffset = %d,  c_bytes_used = %d\n&quot;</span>,
			      (int32_t)C_SEG_OFFSET_TO_BYTES((int32_t)c_seg-&gt;c_nextoffset), c_seg-&gt;c_bytes_used);
	}
}

#<span class="enscript-reference">endif</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_need_delayed_compaction</span>(c_segment_t c_seg)
{
	boolean_t	clear_busy = FALSE;

	<span class="enscript-keyword">if</span> ( !lck_mtx_try_lock_spin_always(c_list_lock)) {
		C_SEG_BUSY(c_seg);
		
		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
		lck_mtx_lock_spin_always(c_list_lock);
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		clear_busy = TRUE;
	}
	assert(c_seg-&gt;c_state != C_IS_FILLING);

	<span class="enscript-keyword">if</span> (!c_seg-&gt;c_on_minorcompact_q &amp;&amp; !(C_SEG_IS_ONDISK(c_seg))) {
		queue_enter(&amp;c_minor_list_head, c_seg, c_segment_t, c_list);
		c_seg-&gt;c_on_minorcompact_q = 1;
		c_minor_count++;
	}
	lck_mtx_unlock_always(c_list_lock);
	
	<span class="enscript-keyword">if</span> (clear_busy == TRUE)
		C_SEG_WAKEUP_DONE(c_seg);
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> c_seg_moved_to_sparse_list = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_move_to_sparse_list</span>(c_segment_t c_seg)
{
	boolean_t	clear_busy = FALSE;

	<span class="enscript-keyword">if</span> ( !lck_mtx_try_lock_spin_always(c_list_lock)) {
		C_SEG_BUSY(c_seg);

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
		lck_mtx_lock_spin_always(c_list_lock);
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
		
		clear_busy = TRUE;
	}
	c_seg_switch_state(c_seg, C_ON_SWAPPEDOUTSPARSE_Q, FALSE);

	c_seg_moved_to_sparse_list++;

	lck_mtx_unlock_always(c_list_lock);

	<span class="enscript-keyword">if</span> (clear_busy == TRUE)
		C_SEG_WAKEUP_DONE(c_seg);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_insert_into_q</span>(queue_head_t *qhead, c_segment_t c_seg)
{
	c_segment_t c_seg_next;

	<span class="enscript-keyword">if</span> (queue_empty(qhead)) {
		queue_enter(qhead, c_seg, c_segment_t, c_age_list);
	} <span class="enscript-keyword">else</span> {
		c_seg_next = (c_segment_t)queue_first(qhead);

		<span class="enscript-keyword">while</span> (TRUE) {

			<span class="enscript-keyword">if</span> (c_seg-&gt;c_generation_id &lt; c_seg_next-&gt;c_generation_id) {
				queue_insert_before(qhead, c_seg, c_seg_next, c_segment_t, c_age_list);
				<span class="enscript-keyword">break</span>;
			}
			c_seg_next = (c_segment_t) queue_next(&amp;c_seg_next-&gt;c_age_list);
		
			<span class="enscript-keyword">if</span> (queue_end(qhead, (queue_entry_t) c_seg_next)) {
				queue_enter(qhead, c_seg, c_segment_t, c_age_list);
				<span class="enscript-keyword">break</span>;
			}
		}
	}
}


<span class="enscript-type">int</span> try_minor_compaction_failed = 0;
<span class="enscript-type">int</span> try_minor_compaction_succeeded = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_try_minor_compaction_and_unlock</span>(c_segment_t c_seg)
{

	assert(c_seg-&gt;c_on_minorcompact_q);
	<span class="enscript-comment">/*
	 * c_seg is currently on the delayed minor compaction
	 * queue and we have c_seg locked... if we can get the
	 * c_list_lock w/o blocking (if we blocked we could deadlock
	 * because the lock order is c_list_lock then c_seg's lock)
	 * we'll pull it from the delayed list and free it directly
	 */</span>
	<span class="enscript-keyword">if</span> ( !lck_mtx_try_lock_spin_always(c_list_lock)) {
		<span class="enscript-comment">/*
		 * c_list_lock is held, we need to bail
		 */</span>
		try_minor_compaction_failed++;

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
	} <span class="enscript-keyword">else</span> {
		try_minor_compaction_succeeded++;

		C_SEG_BUSY(c_seg);
		c_seg_do_minor_compaction_and_unlock(c_seg, TRUE, FALSE, FALSE);
	}
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">c_seg_do_minor_compaction_and_unlock</span>(c_segment_t c_seg, boolean_t clear_busy, boolean_t need_list_lock, boolean_t disallow_page_replacement)
{
	<span class="enscript-type">int</span>	c_seg_freed;

	assert(c_seg-&gt;c_busy);

	<span class="enscript-comment">/*
	 * check for the case that can occur when we are not swapping
	 * and this segment has been major compacted in the past
	 * and moved to the majorcompact q to remove it from further
	 * consideration... if the occupancy falls too low we need
	 * to put it back on the age_q so that it will be considered
	 * in the next major compaction sweep... if we don't do this
	 * we will eventually run into the c_segments_limit
	 */</span>
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_state == C_ON_MAJORCOMPACT_Q &amp;&amp; C_SEG_SHOULD_MAJORCOMPACT(c_seg)) {
		
		c_seg_switch_state(c_seg, C_ON_AGE_Q, FALSE);
	}
	<span class="enscript-keyword">if</span> (!c_seg-&gt;c_on_minorcompact_q) {
		<span class="enscript-keyword">if</span> (clear_busy == TRUE)
			C_SEG_WAKEUP_DONE(c_seg);

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">return</span> (0);
	}
	queue_remove(&amp;c_minor_list_head, c_seg, c_segment_t, c_list);
	c_seg-&gt;c_on_minorcompact_q = 0;
	c_minor_count--;
	
	lck_mtx_unlock_always(c_list_lock);

	<span class="enscript-keyword">if</span> (disallow_page_replacement == TRUE) {
		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
	}
	c_seg_freed = c_seg_minor_compaction_and_unlock(c_seg, clear_busy);

	<span class="enscript-keyword">if</span> (disallow_page_replacement == TRUE)
		PAGE_REPLACEMENT_DISALLOWED(FALSE);

	<span class="enscript-keyword">if</span> (need_list_lock == TRUE)
		lck_mtx_lock_spin_always(c_list_lock);

	<span class="enscript-keyword">return</span> (c_seg_freed);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_wait_on_busy</span>(c_segment_t c_seg)
{
	c_seg-&gt;c_wanted = 1;
	assert_wait((event_t) (c_seg), THREAD_UNINT);

	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
	thread_block(THREAD_CONTINUE_NULL);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_switch_state</span>(c_segment_t c_seg, <span class="enscript-type">int</span> new_state, boolean_t insert_head)
{
	<span class="enscript-type">int</span>	old_state = c_seg-&gt;c_state;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
	<span class="enscript-keyword">if</span> (new_state != C_IS_FILLING)
		lck_mtx_assert(&amp;c_seg-&gt;c_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(c_list_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">switch</span> (old_state) {

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_IS_EMPTY</span>:
			assert(new_state == C_IS_FILLING || new_state == C_IS_FREE);

			c_empty_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_IS_FILLING</span>:
			assert(new_state == C_ON_AGE_Q || new_state == C_ON_SWAPOUT_Q);

			queue_remove(&amp;c_filling_list_head, c_seg, c_segment_t, c_age_list);
			c_filling_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_AGE_Q</span>:
			assert(new_state == C_ON_SWAPOUT_Q || new_state == C_ON_MAJORCOMPACT_Q ||
			       new_state == C_IS_FREE);

			queue_remove(&amp;c_age_list_head, c_seg, c_segment_t, c_age_list);
			c_age_count--;
			<span class="enscript-keyword">break</span>;
		
	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPPEDIN_Q</span>:
			assert(new_state == C_ON_AGE_Q || new_state == C_IS_FREE);

			queue_remove(&amp;c_swappedin_list_head, c_seg, c_segment_t, c_age_list);
			c_swappedin_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPOUT_Q</span>:
			assert(new_state == C_ON_SWAPPEDOUT_Q || new_state == C_ON_SWAPPEDOUTSPARSE_Q ||
			       new_state == C_ON_AGE_Q || new_state == C_IS_FREE || new_state == C_IS_EMPTY);

			queue_remove(&amp;c_swapout_list_head, c_seg, c_segment_t, c_age_list);
			thread_wakeup((event_t)&amp;compaction_swapper_running);
			c_swapout_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPPEDOUT_Q</span>:
			assert(new_state == C_ON_SWAPPEDIN_Q || new_state == C_ON_SWAPPEDOUTSPARSE_Q ||
			       new_state == C_ON_BAD_Q || new_state == C_IS_EMPTY || new_state == C_IS_FREE);

			queue_remove(&amp;c_swappedout_list_head, c_seg, c_segment_t, c_age_list);
			c_swappedout_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPPEDOUTSPARSE_Q</span>:
			assert(new_state == C_ON_SWAPPEDIN_Q ||
			       new_state == C_ON_BAD_Q || new_state == C_IS_EMPTY || new_state == C_IS_FREE);

			queue_remove(&amp;c_swappedout_sparse_list_head, c_seg, c_segment_t, c_age_list);
			c_swappedout_sparse_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_MAJORCOMPACT_Q</span>:
			assert(new_state == C_ON_AGE_Q || new_state == C_IS_FREE);

			queue_remove(&amp;c_major_list_head, c_seg, c_segment_t, c_age_list);
			c_major_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_BAD_Q</span>:
			assert(new_state == C_IS_FREE);

			queue_remove(&amp;c_bad_list_head, c_seg, c_segment_t, c_age_list);
			c_bad_count--;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;c_seg %p has bad c_state = %d\n&quot;</span>, c_seg, old_state);
	}

	<span class="enscript-keyword">switch</span>(new_state) {
	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_IS_FREE</span>:
			assert(old_state != C_IS_FILLING);

			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_IS_EMPTY</span>:
			assert(old_state == C_ON_SWAPOUT_Q || old_state == C_ON_SWAPPEDOUT_Q || old_state == C_ON_SWAPPEDOUTSPARSE_Q);

			c_empty_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_IS_FILLING</span>:
			assert(old_state == C_IS_EMPTY);

			queue_enter(&amp;c_filling_list_head, c_seg, c_segment_t, c_age_list);
			c_filling_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_AGE_Q</span>:
			assert(old_state == C_IS_FILLING || old_state == C_ON_SWAPPEDIN_Q ||
			       old_state == C_ON_MAJORCOMPACT_Q || old_state == C_ON_SWAPOUT_Q);

			<span class="enscript-keyword">if</span> (old_state == C_IS_FILLING)
				queue_enter(&amp;c_age_list_head, c_seg, c_segment_t, c_age_list);
			<span class="enscript-keyword">else</span>
				c_seg_insert_into_q(&amp;c_age_list_head, c_seg);
			c_age_count++;
			<span class="enscript-keyword">break</span>;
		
	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPPEDIN_Q</span>:
			assert(c_seg-&gt;c_state == C_ON_SWAPPEDOUT_Q || c_seg-&gt;c_state == C_ON_SWAPPEDOUTSPARSE_Q);

			<span class="enscript-keyword">if</span> (insert_head == TRUE)
				queue_enter_first(&amp;c_swappedin_list_head, c_seg, c_segment_t, c_age_list);
			<span class="enscript-keyword">else</span>
				queue_enter(&amp;c_swappedin_list_head, c_seg, c_segment_t, c_age_list);
			c_swappedin_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPOUT_Q</span>:
			assert(old_state == C_ON_AGE_Q || old_state == C_IS_FILLING);

			<span class="enscript-keyword">if</span> (insert_head == TRUE)
				queue_enter_first(&amp;c_swapout_list_head, c_seg, c_segment_t, c_age_list);
			<span class="enscript-keyword">else</span>
				queue_enter(&amp;c_swapout_list_head, c_seg, c_segment_t, c_age_list);
			c_swapout_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPPEDOUT_Q</span>:
			assert(c_seg-&gt;c_state == C_ON_SWAPOUT_Q);

			<span class="enscript-keyword">if</span> (insert_head == TRUE)
				queue_enter_first(&amp;c_swappedout_list_head, c_seg, c_segment_t, c_age_list);
			<span class="enscript-keyword">else</span>
				queue_enter(&amp;c_swappedout_list_head, c_seg, c_segment_t, c_age_list);
			c_swappedout_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_SWAPPEDOUTSPARSE_Q</span>:
			assert(c_seg-&gt;c_state == C_ON_SWAPOUT_Q || c_seg-&gt;c_state == C_ON_SWAPPEDOUT_Q);
			
			c_seg_insert_into_q(&amp;c_swappedout_sparse_list_head, c_seg);
			c_swappedout_sparse_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_MAJORCOMPACT_Q</span>:
			assert(c_seg-&gt;c_state == C_ON_AGE_Q);

			<span class="enscript-keyword">if</span> (insert_head == TRUE)
				queue_enter_first(&amp;c_major_list_head, c_seg, c_segment_t, c_age_list);
			<span class="enscript-keyword">else</span>
				queue_enter(&amp;c_major_list_head, c_seg, c_segment_t, c_age_list);
			c_major_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-keyword">case</span> <span class="enscript-reference">C_ON_BAD_Q</span>:
			assert(c_seg-&gt;c_state == C_ON_SWAPPEDOUT_Q || c_seg-&gt;c_state == C_ON_SWAPPEDOUTSPARSE_Q);

			<span class="enscript-keyword">if</span> (insert_head == TRUE)
				queue_enter_first(&amp;c_bad_list_head, c_seg, c_segment_t, c_age_list);
			<span class="enscript-keyword">else</span>
				queue_enter(&amp;c_bad_list_head, c_seg, c_segment_t, c_age_list);
			c_bad_count++;
			<span class="enscript-keyword">break</span>;

	        <span class="enscript-reference">default</span>:
		       panic(<span class="enscript-string">&quot;c_seg %p requesting bad c_state = %d\n&quot;</span>, c_seg, new_state);
	}
	c_seg-&gt;c_state = new_state;
}



<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_free</span>(c_segment_t c_seg)
{
	assert(c_seg-&gt;c_busy);

	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
	lck_mtx_lock_spin_always(c_list_lock);
	lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

	c_seg_free_locked(c_seg);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_free_locked</span>(c_segment_t c_seg)
{
	<span class="enscript-type">int</span>		segno;
	<span class="enscript-type">int</span>		pages_populated = 0;
	int32_t		*c_buffer = NULL;
	uint64_t	c_swap_handle = 0;

	assert(c_seg-&gt;c_busy);
	assert(!c_seg-&gt;c_on_minorcompact_q);
	assert(!c_seg-&gt;c_busy_swapping);

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_overage_swap == TRUE) {
		c_overage_swapped_count--;
		c_seg-&gt;c_overage_swap = FALSE;
	}	
	<span class="enscript-keyword">if</span> ( !(C_SEG_IS_ONDISK(c_seg)))
		c_buffer = c_seg-&gt;c_store.c_buffer;
	<span class="enscript-keyword">else</span>
		c_swap_handle = c_seg-&gt;c_store.c_swap_handle;

	c_seg_switch_state(c_seg, C_IS_FREE, FALSE);

	lck_mtx_unlock_always(c_list_lock);

	<span class="enscript-keyword">if</span> (c_buffer) {
		pages_populated = (round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset))) / PAGE_SIZE;
		c_seg-&gt;c_store.c_buffer = NULL;
	} <span class="enscript-keyword">else</span>
		c_seg-&gt;c_store.c_swap_handle = (uint64_t)-1;

	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

	<span class="enscript-keyword">if</span> (c_buffer) {
		<span class="enscript-keyword">if</span> (pages_populated)
			kernel_memory_depopulate(kernel_map, (vm_offset_t) c_buffer, pages_populated * PAGE_SIZE, KMA_COMPRESSOR);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_swap_handle) {
                <span class="enscript-comment">/*
                 * Free swap space on disk.
		 */</span>
		vm_swap_free(c_swap_handle);
	}
	lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

	C_SEG_WAKEUP_DONE(c_seg);
	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

	segno = c_seg-&gt;c_mysegno;

	lck_mtx_lock_spin_always(c_list_lock);
	<span class="enscript-comment">/*
	 * because the c_buffer is now associated with the segno,
	 * we can't put the segno back on the free list until
	 * after we have depopulated the c_buffer range, or 
	 * we run the risk of depopulating a range that is 
	 * now being used in one of the compressor heads
	 */</span>
	c_segments[segno].c_segno = c_free_segno_head;
	c_free_segno_head = segno;
	c_segment_count--;

	lck_mtx_unlock_always(c_list_lock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
	lck_mtx_destroy(&amp;c_seg-&gt;c_lock, &amp;vm_compressor_lck_grp);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>
	lck_spin_destroy(&amp;c_seg-&gt;c_lock, &amp;vm_compressor_lck_grp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_slot_var_array_len)
		kfree(c_seg-&gt;c_slot_var_array, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_slot) * c_seg-&gt;c_slot_var_array_len);

	zfree(compressor_segment_zone, c_seg);
}


<span class="enscript-type">int</span> c_seg_trim_page_count = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_trim_tail</span>(c_segment_t c_seg)
{
	c_slot_t	cs;
	uint32_t	c_size;
	uint32_t	c_offset;
	uint32_t	c_rounded_size;
	uint16_t	current_nextslot;
	uint32_t	current_populated_offset;

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used == 0)
		<span class="enscript-keyword">return</span>;
	current_nextslot = c_seg-&gt;c_nextslot;
	current_populated_offset = c_seg-&gt;c_populated_offset;
		
	<span class="enscript-keyword">while</span> (c_seg-&gt;c_nextslot) {

		cs = C_SEG_SLOT_FROM_INDEX(c_seg, (c_seg-&gt;c_nextslot - 1));

		c_size = UNPACK_C_SIZE(cs);

		<span class="enscript-keyword">if</span> (c_size) {
			<span class="enscript-keyword">if</span> (current_nextslot != c_seg-&gt;c_nextslot) {
				c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;
				c_offset = cs-&gt;c_offset + C_SEG_BYTES_TO_OFFSET(c_rounded_size);

				c_seg-&gt;c_nextoffset = c_offset;
				c_seg-&gt;c_populated_offset = (c_offset + (C_SEG_BYTES_TO_OFFSET(PAGE_SIZE) - 1)) &amp; ~(C_SEG_BYTES_TO_OFFSET(PAGE_SIZE) - 1);

				<span class="enscript-keyword">if</span> (c_seg-&gt;c_firstemptyslot &gt; c_seg-&gt;c_nextslot)
					c_seg-&gt;c_firstemptyslot = c_seg-&gt;c_nextslot;

				c_seg_trim_page_count += ((round_page_32(C_SEG_OFFSET_TO_BYTES(current_populated_offset)) -
							   round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset))) / PAGE_SIZE);
			}
			<span class="enscript-keyword">break</span>;
		}		
		c_seg-&gt;c_nextslot--;
	}
	assert(c_seg-&gt;c_nextslot);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">c_seg_minor_compaction_and_unlock</span>(c_segment_t c_seg, boolean_t clear_busy)
{
	c_slot_mapping_t slot_ptr;
	uint32_t	c_offset = 0;
	uint32_t	old_populated_offset;
	uint32_t	c_rounded_size;
	uint32_t	c_size;
	<span class="enscript-type">int</span>		c_indx = 0;
	<span class="enscript-type">int</span>		i;
	c_slot_t	c_dst;
	c_slot_t	c_src;
	boolean_t	need_unlock = TRUE;

	assert(c_seg-&gt;c_busy);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VALIDATE_C_SEGMENTS</span>
	c_seg_validate(c_seg, FALSE);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used == 0) {
		c_seg_free(c_seg);
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_firstemptyslot &gt;= c_seg-&gt;c_nextslot || C_SEG_UNUSED_BYTES(c_seg) &lt; PAGE_SIZE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VALIDATE_C_SEGMENTS</span>
	c_seg-&gt;c_was_minor_compacted++;
#<span class="enscript-reference">endif</span>
	c_indx = c_seg-&gt;c_firstemptyslot;
	c_dst = C_SEG_SLOT_FROM_INDEX(c_seg, c_indx);
	
	old_populated_offset = c_seg-&gt;c_populated_offset;
	c_offset = c_dst-&gt;c_offset;

	<span class="enscript-keyword">for</span> (i = c_indx + 1; i &lt; c_seg-&gt;c_nextslot &amp;&amp; c_offset &lt; c_seg-&gt;c_nextoffset; i++) {

		c_src = C_SEG_SLOT_FROM_INDEX(c_seg, i);

		c_size = UNPACK_C_SIZE(c_src);

		<span class="enscript-keyword">if</span> (c_size == 0)
			<span class="enscript-keyword">continue</span>;

		memcpy(&amp;c_seg-&gt;c_store.c_buffer[c_offset], &amp;c_seg-&gt;c_store.c_buffer[c_src-&gt;c_offset], c_size);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_DATA</span>
		c_dst-&gt;c_hash_data = c_src-&gt;c_hash_data;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
		c_dst-&gt;c_hash_compressed_data = c_src-&gt;c_hash_compressed_data;
#<span class="enscript-reference">endif</span>
		c_dst-&gt;c_size = c_src-&gt;c_size;
		c_dst-&gt;c_packed_ptr = c_src-&gt;c_packed_ptr;
		c_dst-&gt;c_offset = c_offset;

		slot_ptr = (c_slot_mapping_t)C_SLOT_UNPACK_PTR(c_dst);
		slot_ptr-&gt;s_cindx = c_indx;

		c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;

		c_offset += C_SEG_BYTES_TO_OFFSET(c_rounded_size);
		PACK_C_SIZE(c_src, 0);
		c_indx++;

		c_dst = C_SEG_SLOT_FROM_INDEX(c_seg, c_indx);
	}
	c_seg-&gt;c_firstemptyslot = c_indx;
	c_seg-&gt;c_nextslot = c_indx;
	c_seg-&gt;c_nextoffset = c_offset;
	c_seg-&gt;c_populated_offset = (c_offset + (C_SEG_BYTES_TO_OFFSET(PAGE_SIZE) - 1)) &amp; ~(C_SEG_BYTES_TO_OFFSET(PAGE_SIZE) - 1);
	c_seg-&gt;c_bytes_unused = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VALIDATE_C_SEGMENTS</span>
	c_seg_validate(c_seg, TRUE);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (old_populated_offset &gt; c_seg-&gt;c_populated_offset) {
		uint32_t	gc_size;
		int32_t		*gc_ptr;

		gc_size = C_SEG_OFFSET_TO_BYTES(old_populated_offset - c_seg-&gt;c_populated_offset);
		gc_ptr = &amp;c_seg-&gt;c_store.c_buffer[c_seg-&gt;c_populated_offset];

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		kernel_memory_depopulate(kernel_map, (vm_offset_t)gc_ptr, gc_size, KMA_COMPRESSOR);

		<span class="enscript-keyword">if</span> (clear_busy == TRUE)
			lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
		<span class="enscript-keyword">else</span>
			need_unlock = FALSE;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (need_unlock == TRUE) {
		<span class="enscript-keyword">if</span> (clear_busy == TRUE)
			C_SEG_WAKEUP_DONE(c_seg);

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
	}
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_alloc_nextslot</span>(c_segment_t c_seg)
{
	<span class="enscript-type">struct</span> c_slot	*old_slot_array = NULL;
	<span class="enscript-type">struct</span> c_slot	*new_slot_array = NULL;
	<span class="enscript-type">int</span>		newlen;
	<span class="enscript-type">int</span>		oldlen;

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_nextslot &lt; c_seg_fixed_array_len)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((c_seg-&gt;c_nextslot - c_seg_fixed_array_len) &gt;= c_seg-&gt;c_slot_var_array_len) {

		oldlen = c_seg-&gt;c_slot_var_array_len;
		old_slot_array = c_seg-&gt;c_slot_var_array;

		<span class="enscript-keyword">if</span> (oldlen == 0)
			newlen = C_SEG_SLOT_VAR_ARRAY_MIN_LEN;
		<span class="enscript-keyword">else</span>
			newlen = oldlen * 2;

		new_slot_array = (<span class="enscript-type">struct</span> c_slot *)kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_slot) * newlen);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">if</span> (old_slot_array)
			memcpy((<span class="enscript-type">char</span> *)new_slot_array, (<span class="enscript-type">char</span> *)old_slot_array, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_slot) * oldlen);

		c_seg-&gt;c_slot_var_array_len = newlen;
		c_seg-&gt;c_slot_var_array = new_slot_array;

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
		
		<span class="enscript-keyword">if</span> (old_slot_array)
			kfree(old_slot_array, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_slot) * oldlen);
	}
}



<span class="enscript-type">struct</span> {
	uint64_t asked_permission;
	uint64_t compactions;
	uint64_t moved_slots;
	uint64_t moved_bytes;
	uint64_t wasted_space_in_swapouts;
	uint64_t count_of_swapouts;
	uint64_t count_of_freed_segs;
} c_seg_major_compact_stats;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_MAJOR_COMPACTION_SIZE_APPROPRIATE</span>	((C_SEG_BUFSIZE * 90) / 100)


boolean_t
<span class="enscript-function-name">c_seg_major_compact_ok</span>(
	c_segment_t c_seg_dst,
	c_segment_t c_seg_src)
{

	c_seg_major_compact_stats.asked_permission++;

	<span class="enscript-keyword">if</span> (c_seg_src-&gt;c_bytes_used &gt;= C_MAJOR_COMPACTION_SIZE_APPROPRIATE &amp;&amp;
	    c_seg_dst-&gt;c_bytes_used &gt;= C_MAJOR_COMPACTION_SIZE_APPROPRIATE)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (c_seg_dst-&gt;c_nextoffset &gt;= C_SEG_OFF_LIMIT || c_seg_dst-&gt;c_nextslot &gt;= C_SLOT_MAX_INDEX) {
		<span class="enscript-comment">/*
		 * destination segment is full... can't compact
		 */</span>
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">return</span> (TRUE);
}


boolean_t
<span class="enscript-function-name">c_seg_major_compact</span>(
	c_segment_t c_seg_dst,
	c_segment_t c_seg_src)
{
	c_slot_mapping_t slot_ptr;
	uint32_t	c_rounded_size;
	uint32_t	c_size;
	uint16_t	dst_slot;
	<span class="enscript-type">int</span>		i;
	c_slot_t	c_dst;
	c_slot_t	c_src;
	boolean_t	keep_compacting = TRUE;
	
	<span class="enscript-comment">/*
	 * segments are not locked but they are both marked c_busy
	 * which keeps c_decompress from working on them...
	 * we can safely allocate new pages, move compressed data
	 * from c_seg_src to c_seg_dst and update both c_segment's
	 * state w/o holding the master lock
	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VALIDATE_C_SEGMENTS</span>
	c_seg_dst-&gt;c_was_major_compacted++;
	c_seg_src-&gt;c_was_major_donor++;
#<span class="enscript-reference">endif</span>
	c_seg_major_compact_stats.compactions++;

	dst_slot = c_seg_dst-&gt;c_nextslot;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; c_seg_src-&gt;c_nextslot; i++) {

		c_src = C_SEG_SLOT_FROM_INDEX(c_seg_src, i);

		c_size = UNPACK_C_SIZE(c_src);

		<span class="enscript-keyword">if</span> (c_size == 0) {
			<span class="enscript-comment">/* BATCH: move what we have so far; */</span>
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (C_SEG_OFFSET_TO_BYTES(c_seg_dst-&gt;c_populated_offset - c_seg_dst-&gt;c_nextoffset) &lt; (<span class="enscript-type">unsigned</span>) c_size) {
			<span class="enscript-type">int</span>	size_to_populate;

			<span class="enscript-comment">/* doesn't fit */</span>
			size_to_populate = C_SEG_BUFSIZE - C_SEG_OFFSET_TO_BYTES(c_seg_dst-&gt;c_populated_offset);

		    	<span class="enscript-keyword">if</span> (size_to_populate == 0) {
				<span class="enscript-comment">/* can't fit */</span>
				keep_compacting = FALSE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (size_to_populate &gt; C_SEG_MAX_POPULATE_SIZE)
				size_to_populate = C_SEG_MAX_POPULATE_SIZE;

			kernel_memory_populate(kernel_map,
					       (vm_offset_t) &amp;c_seg_dst-&gt;c_store.c_buffer[c_seg_dst-&gt;c_populated_offset],
					       size_to_populate,
					       KMA_COMPRESSOR, 
					       VM_KERN_MEMORY_COMPRESSOR);

			c_seg_dst-&gt;c_populated_offset += C_SEG_BYTES_TO_OFFSET(size_to_populate);
			assert(C_SEG_OFFSET_TO_BYTES(c_seg_dst-&gt;c_populated_offset) &lt;= C_SEG_BUFSIZE);
		}
		c_seg_alloc_nextslot(c_seg_dst);

		c_dst = C_SEG_SLOT_FROM_INDEX(c_seg_dst, c_seg_dst-&gt;c_nextslot);

		memcpy(&amp;c_seg_dst-&gt;c_store.c_buffer[c_seg_dst-&gt;c_nextoffset], &amp;c_seg_src-&gt;c_store.c_buffer[c_src-&gt;c_offset], c_size);

		c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;

		c_seg_major_compact_stats.moved_slots++;
		c_seg_major_compact_stats.moved_bytes += c_size;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_DATA</span>
		c_dst-&gt;c_hash_data = c_src-&gt;c_hash_data;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
		c_dst-&gt;c_hash_compressed_data = c_src-&gt;c_hash_compressed_data;
#<span class="enscript-reference">endif</span>
		c_dst-&gt;c_size = c_src-&gt;c_size;
		c_dst-&gt;c_packed_ptr = c_src-&gt;c_packed_ptr;
		c_dst-&gt;c_offset = c_seg_dst-&gt;c_nextoffset;

		<span class="enscript-keyword">if</span> (c_seg_dst-&gt;c_firstemptyslot == c_seg_dst-&gt;c_nextslot)
			c_seg_dst-&gt;c_firstemptyslot++;
		c_seg_dst-&gt;c_nextslot++;
		c_seg_dst-&gt;c_bytes_used += c_rounded_size;
		c_seg_dst-&gt;c_nextoffset += C_SEG_BYTES_TO_OFFSET(c_rounded_size);

		PACK_C_SIZE(c_src, 0);

		c_seg_src-&gt;c_bytes_used -= c_rounded_size;
		c_seg_src-&gt;c_bytes_unused += c_rounded_size;
		c_seg_src-&gt;c_firstemptyslot = 0;

		<span class="enscript-keyword">if</span> (c_seg_dst-&gt;c_nextoffset &gt;= C_SEG_OFF_LIMIT || c_seg_dst-&gt;c_nextslot &gt;= C_SLOT_MAX_INDEX) {
			<span class="enscript-comment">/* dest segment is now full */</span>
			keep_compacting = FALSE;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (dst_slot &lt; c_seg_dst-&gt;c_nextslot) {

		PAGE_REPLACEMENT_ALLOWED(TRUE);
		<span class="enscript-comment">/*
		 * we've now locked out c_decompress from 
		 * converting the slot passed into it into
		 * a c_segment_t which allows us to use 
		 * the backptr to change which c_segment and
		 * index the slot points to
		 */</span>
		<span class="enscript-keyword">while</span> (dst_slot &lt; c_seg_dst-&gt;c_nextslot) {

			c_dst = C_SEG_SLOT_FROM_INDEX(c_seg_dst, dst_slot);
			
			slot_ptr = (c_slot_mapping_t)C_SLOT_UNPACK_PTR(c_dst);
			<span class="enscript-comment">/* &lt;csegno=0,indx=0&gt; would mean &quot;empty slot&quot;, so use csegno+1 */</span>
			slot_ptr-&gt;s_cseg = c_seg_dst-&gt;c_mysegno + 1;
			slot_ptr-&gt;s_cindx = dst_slot++;
		}
		PAGE_REPLACEMENT_ALLOWED(FALSE);
	}
	<span class="enscript-keyword">return</span> (keep_compacting);
}


uint64_t
<span class="enscript-function-name">vm_compressor_compute_elapsed_msecs</span>(clock_sec_t end_sec, clock_nsec_t end_nsec, clock_sec_t start_sec, clock_nsec_t start_nsec)
{
        uint64_t end_msecs;
        uint64_t start_msecs;
  
	end_msecs = (end_sec * 1000) + end_nsec / 1000000;
	start_msecs = (start_sec * 1000) + start_nsec / 1000000;

	<span class="enscript-keyword">return</span> (end_msecs - start_msecs);
}



uint32_t compressor_eval_period_in_msecs = 250;
uint32_t compressor_sample_min_in_msecs = 500;
uint32_t compressor_sample_max_in_msecs = 10000;
uint32_t compressor_thrashing_threshold_per_10msecs = 50;
uint32_t compressor_thrashing_min_per_10msecs = 20;

<span class="enscript-comment">/* When true, reset sample data next chance we get. */</span>
<span class="enscript-type">static</span> boolean_t	compressor_need_sample_reset = FALSE;

<span class="enscript-type">extern</span> uint32_t vm_page_filecache_min;


<span class="enscript-type">void</span>
<span class="enscript-function-name">compute_swapout_target_age</span>(<span class="enscript-type">void</span>)
{
        clock_sec_t	cur_ts_sec;
        clock_nsec_t	cur_ts_nsec;
	uint32_t	min_operations_needed_in_this_sample;
	uint64_t	elapsed_msecs_in_eval;
	uint64_t	elapsed_msecs_in_sample;
	boolean_t	need_eval_reset = FALSE;

	clock_get_system_nanotime(&amp;cur_ts_sec, &amp;cur_ts_nsec);

	elapsed_msecs_in_sample = vm_compressor_compute_elapsed_msecs(cur_ts_sec, cur_ts_nsec, start_of_sample_period_sec, start_of_sample_period_nsec);

	<span class="enscript-keyword">if</span> (compressor_need_sample_reset ||
	    elapsed_msecs_in_sample &gt;= compressor_sample_max_in_msecs) {
		compressor_need_sample_reset = TRUE;
		need_eval_reset = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	elapsed_msecs_in_eval = vm_compressor_compute_elapsed_msecs(cur_ts_sec, cur_ts_nsec, start_of_eval_period_sec, start_of_eval_period_nsec);
	
	<span class="enscript-keyword">if</span> (elapsed_msecs_in_eval &lt; compressor_eval_period_in_msecs)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	need_eval_reset = TRUE;

	KERNEL_DEBUG(0xe0400020 | DBG_FUNC_START, elapsed_msecs_in_eval, sample_period_compression_count, sample_period_decompression_count, 0, 0);

	min_operations_needed_in_this_sample = (compressor_thrashing_min_per_10msecs * (uint32_t)elapsed_msecs_in_eval) / 10;

	<span class="enscript-keyword">if</span> ((sample_period_compression_count - last_eval_compression_count) &lt; min_operations_needed_in_this_sample ||
	    (sample_period_decompression_count - last_eval_decompression_count) &lt; min_operations_needed_in_this_sample) {
		
		KERNEL_DEBUG(0xe0400020 | DBG_FUNC_END, sample_period_compression_count - last_eval_compression_count,
			     sample_period_decompression_count - last_eval_decompression_count, 0, 1, 0);

		swapout_target_age = 0;

		compressor_need_sample_reset = TRUE;
		need_eval_reset = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	last_eval_compression_count = sample_period_compression_count;
	last_eval_decompression_count = sample_period_decompression_count;

	<span class="enscript-keyword">if</span> (elapsed_msecs_in_sample &lt; compressor_sample_min_in_msecs) {

		KERNEL_DEBUG(0xe0400020 | DBG_FUNC_END, swapout_target_age, 0, 0, 5, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (sample_period_decompression_count &gt; ((compressor_thrashing_threshold_per_10msecs * elapsed_msecs_in_sample) / 10)) {

		uint64_t	running_total;
		uint64_t	working_target;
		uint64_t	aging_target;
		uint32_t	oldest_age_of_csegs_sampled = 0;
		uint64_t	working_set_approximation = 0;

		swapout_target_age = 0;

		working_target = (sample_period_decompression_count / 100) * 95;		<span class="enscript-comment">/* 95 percent */</span>
		aging_target = (sample_period_decompression_count / 100) * 1;			<span class="enscript-comment">/* 1 percent */</span>
		running_total = 0;

		<span class="enscript-keyword">for</span> (oldest_age_of_csegs_sampled = 0; oldest_age_of_csegs_sampled &lt; DECOMPRESSION_SAMPLE_MAX_AGE; oldest_age_of_csegs_sampled++) {

			running_total += age_of_decompressions_during_sample_period[oldest_age_of_csegs_sampled];

			working_set_approximation += oldest_age_of_csegs_sampled * age_of_decompressions_during_sample_period[oldest_age_of_csegs_sampled];

			<span class="enscript-keyword">if</span> (running_total &gt;= working_target)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (oldest_age_of_csegs_sampled &lt; DECOMPRESSION_SAMPLE_MAX_AGE) {

			working_set_approximation = (working_set_approximation * 1000) / elapsed_msecs_in_sample;

			<span class="enscript-keyword">if</span> (working_set_approximation &lt; VM_PAGE_COMPRESSOR_COUNT) {

				running_total = overage_decompressions_during_sample_period;

				<span class="enscript-keyword">for</span> (oldest_age_of_csegs_sampled = DECOMPRESSION_SAMPLE_MAX_AGE - 1; oldest_age_of_csegs_sampled; oldest_age_of_csegs_sampled--) {
					running_total += age_of_decompressions_during_sample_period[oldest_age_of_csegs_sampled];

					<span class="enscript-keyword">if</span> (running_total &gt;= aging_target)
						<span class="enscript-keyword">break</span>;
				}
				swapout_target_age = (uint32_t)cur_ts_sec - oldest_age_of_csegs_sampled;

				KERNEL_DEBUG(0xe0400020 | DBG_FUNC_END, swapout_target_age, working_set_approximation, VM_PAGE_COMPRESSOR_COUNT, 2, 0);
			} <span class="enscript-keyword">else</span> {
				KERNEL_DEBUG(0xe0400020 | DBG_FUNC_END, working_set_approximation, VM_PAGE_COMPRESSOR_COUNT, 0, 3, 0);
			}
		} <span class="enscript-keyword">else</span>
			KERNEL_DEBUG(0xe0400020 | DBG_FUNC_END, working_target, running_total, 0, 4, 0);

		compressor_need_sample_reset = TRUE;
		need_eval_reset = TRUE;
	} <span class="enscript-keyword">else</span>
		KERNEL_DEBUG(0xe0400020 | DBG_FUNC_END, sample_period_decompression_count, (compressor_thrashing_threshold_per_10msecs * elapsed_msecs_in_sample) / 10, 0, 6, 0);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (compressor_need_sample_reset == TRUE) {
		bzero(age_of_decompressions_during_sample_period, <span class="enscript-keyword">sizeof</span>(age_of_decompressions_during_sample_period));
		overage_decompressions_during_sample_period = 0;

		start_of_sample_period_sec = cur_ts_sec;
		start_of_sample_period_nsec = cur_ts_nsec;
		sample_period_decompression_count = 0;
		sample_period_compression_count = 0;
		last_eval_decompression_count = 0;
		last_eval_compression_count = 0;
		compressor_need_sample_reset = FALSE;
	}
	<span class="enscript-keyword">if</span> (need_eval_reset == TRUE) {
		start_of_eval_period_sec = cur_ts_sec;
		start_of_eval_period_nsec = cur_ts_nsec;
	}
}


<span class="enscript-type">int</span>		compaction_swapper_inited = 0;
<span class="enscript-type">int</span>		compaction_swapper_init_now = 0;
<span class="enscript-type">int</span>		compaction_swapper_running = 0;
<span class="enscript-type">int</span>		compaction_swapper_abort = 0;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
boolean_t	memorystatus_kill_on_VM_thrashing(boolean_t);
boolean_t	memorystatus_kill_on_FC_thrashing(boolean_t);
<span class="enscript-type">int</span>		compressor_thrashing_induced_jetsam = 0;
<span class="enscript-type">int</span>		filecache_thrashing_induced_jetsam = 0;
<span class="enscript-type">static</span> boolean_t	vm_compressor_thrashing_detected = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">compressor_needs_to_swap</span>(<span class="enscript-type">void</span>)
{
	boolean_t	should_swap = FALSE;

	<span class="enscript-keyword">if</span> (vm_swapout_ripe_segments == TRUE &amp;&amp; c_overage_swapped_count &lt; c_overage_swapped_limit) {
		c_segment_t	c_seg;
		clock_sec_t	now;
		clock_sec_t	age;
		clock_nsec_t	nsec;
		
		clock_get_system_nanotime(&amp;now,  &amp;nsec);
		age = 0;

		lck_mtx_lock_spin_always(c_list_lock);

		<span class="enscript-keyword">if</span> ( !queue_empty(&amp;c_age_list_head)) {
			c_seg = (c_segment_t) queue_first(&amp;c_age_list_head);

			age = now - c_seg-&gt;c_creation_ts;
		}
		lck_mtx_unlock_always(c_list_lock);

		<span class="enscript-keyword">if</span> (age &gt;= vm_ripe_target_age)
			<span class="enscript-keyword">return</span> (TRUE);
	}
	<span class="enscript-keyword">if</span> ((vm_compressor_mode == VM_PAGER_COMPRESSOR_WITH_SWAP) &amp;&amp; vm_swap_up == TRUE) {
		<span class="enscript-keyword">if</span> (COMPRESSOR_NEEDS_TO_SWAP()) {
			<span class="enscript-keyword">return</span> (TRUE);
		}
		<span class="enscript-keyword">if</span> (VM_PAGE_Q_THROTTLED(&amp;vm_pageout_queue_external) &amp;&amp; vm_page_anonymous_count &lt; (vm_page_inactive_count / 20)) {
			<span class="enscript-keyword">return</span> (TRUE);
		}
		<span class="enscript-keyword">if</span> (vm_page_free_count &lt; (vm_page_free_reserved - (COMPRESSOR_FREE_RESERVED_LIMIT * 2)))
			<span class="enscript-keyword">return</span> (TRUE);
	}
	compute_swapout_target_age();
			
	<span class="enscript-keyword">if</span> (swapout_target_age) {
		c_segment_t	c_seg;

		lck_mtx_lock_spin_always(c_list_lock);

		<span class="enscript-keyword">if</span> (!queue_empty(&amp;c_age_list_head)) {

			c_seg = (c_segment_t) queue_first(&amp;c_age_list_head);

			<span class="enscript-keyword">if</span> (c_seg-&gt;c_creation_ts &gt; swapout_target_age)
				swapout_target_age = 0;
		}
		lck_mtx_unlock_always(c_list_lock);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
	<span class="enscript-keyword">if</span> (vm_phantom_cache_check_pressure())
		should_swap = TRUE;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (swapout_target_age)
		should_swap = TRUE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-keyword">if</span> (should_swap || c_segment_pages_compressed &gt; c_segment_pages_compressed_nearing_limit) {

		<span class="enscript-keyword">if</span> (vm_compressor_thrashing_detected == FALSE) {
			vm_compressor_thrashing_detected = TRUE;
				
			<span class="enscript-keyword">if</span> (swapout_target_age || c_segment_pages_compressed &gt; c_segment_pages_compressed_nearing_limit) {
				memorystatus_kill_on_VM_thrashing(TRUE <span class="enscript-comment">/* async */</span>);
				compressor_thrashing_induced_jetsam++;
			} <span class="enscript-keyword">else</span> {
				memorystatus_kill_on_FC_thrashing(TRUE <span class="enscript-comment">/* async */</span>);
				filecache_thrashing_induced_jetsam++;
			}
		}
		<span class="enscript-comment">/*
		 * let the jetsam take precedence over
		 * any major compactions we might have
		 * been able to do... otherwise we run
		 * the risk of doing major compactions
		 * on segments we're about to free up
		 * due to the jetsam activity.
		 */</span>
		should_swap = FALSE;
	}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

	<span class="enscript-keyword">if</span> (should_swap == FALSE) {
		<span class="enscript-comment">/*
		 * COMPRESSOR_NEEDS_TO_MAJOR_COMPACT returns true only if we're
		 * about to run out of available compressor segments... in this
		 * case, we absolutely need to run a major compaction even if
		 * we've just kicked off a jetsam or we don't otherwise need to
		 * swap... terminating objects releases
		 * pages back to the uncompressed cache, but does not guarantee
		 * that we will free up even a single compression segment
		 */</span>
		should_swap = COMPRESSOR_NEEDS_TO_MAJOR_COMPACT();
	}

	<span class="enscript-comment">/*
	 * returning TRUE when swap_supported == FALSE
	 * will cause the major compaction engine to
	 * run, but will not trigger any swapping...
	 * segments that have been major compacted
	 * will be moved to the majorcompact queue
	 */</span>
	<span class="enscript-keyword">return</span> (should_swap);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-comment">/*
 * This function is called from the jetsam thread after killing something to
 * mitigate thrashing.
 *
 * We need to restart our thrashing detection heuristics since memory pressure
 * has potentially changed significantly, and we don't want to detect on old
 * data from before the jetsam.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_thrashing_jetsam_done</span>(<span class="enscript-type">void</span>)
{
	vm_compressor_thrashing_detected = FALSE;

	<span class="enscript-comment">/* Were we compressor-thrashing or filecache-thrashing? */</span>
	<span class="enscript-keyword">if</span> (swapout_target_age) {
		swapout_target_age = 0;
		compressor_need_sample_reset = TRUE;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
	<span class="enscript-keyword">else</span> {
		vm_phantom_cache_restart_sample();
	}
#<span class="enscript-reference">endif</span>
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

uint32_t vm_wake_compactor_swapper_calls = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_wake_compactor_swapper</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (compaction_swapper_running || c_segment_count == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (c_minor_count || COMPRESSOR_NEEDS_TO_MAJOR_COMPACT()) {

		lck_mtx_lock_spin_always(c_list_lock);

		fastwake_warmup = FALSE;

		<span class="enscript-keyword">if</span> (compaction_swapper_running == 0) {

			vm_wake_compactor_swapper_calls++;

			thread_wakeup((event_t)&amp;c_compressor_swap_trigger);
			
			compaction_swapper_running = 1;
		}
		lck_mtx_unlock_always(c_list_lock);
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_consider_swapping</span>()
{
	c_segment_t	c_seg, c_seg_next;
	clock_sec_t	now;
	clock_nsec_t	nsec;


	lck_mtx_lock_spin_always(c_list_lock);

	compaction_swapper_abort = 1;

	<span class="enscript-keyword">while</span> (compaction_swapper_running) {
		assert_wait((event_t)&amp;compaction_swapper_running, THREAD_UNINT);

		lck_mtx_unlock_always(c_list_lock);
		
		thread_block(THREAD_CONTINUE_NULL);

		lck_mtx_lock_spin_always(c_list_lock);
	}
	compaction_swapper_abort = 0;
	compaction_swapper_running = 1;

	vm_swapout_ripe_segments = TRUE;

	<span class="enscript-keyword">if</span> (!queue_empty(&amp;c_major_list_head)) {
		
		clock_get_system_nanotime(&amp;now, &amp;nsec);
			
		c_seg = (c_segment_t)queue_first(&amp;c_major_list_head);

		<span class="enscript-keyword">while</span> (!queue_end(&amp;c_major_list_head, (queue_entry_t)c_seg)) {

			<span class="enscript-keyword">if</span> (c_overage_swapped_count &gt;= c_overage_swapped_limit)
				<span class="enscript-keyword">break</span>;

			c_seg_next = (c_segment_t) queue_next(&amp;c_seg-&gt;c_age_list);

			<span class="enscript-keyword">if</span> ((now - c_seg-&gt;c_creation_ts) &gt;= vm_ripe_target_age) {
			
				lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
				
				c_seg_switch_state(c_seg, C_ON_AGE_Q, FALSE);

				lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
			}
			c_seg = c_seg_next;
		}
	}
	vm_compressor_compact_and_swap(FALSE);

	compaction_swapper_running = 0;

	vm_swapout_ripe_segments = FALSE;
	
	lck_mtx_unlock_always(c_list_lock);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_consider_waking_compactor_swapper</span>(<span class="enscript-type">void</span>)
{
	boolean_t	need_wakeup = FALSE;

	<span class="enscript-keyword">if</span> (compaction_swapper_running)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (c_segment_count == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!compaction_swapper_inited &amp;&amp; !compaction_swapper_init_now) {
		compaction_swapper_init_now = 1;
		need_wakeup = TRUE;
	}

	<span class="enscript-keyword">if</span> (c_minor_count &amp;&amp; (COMPRESSOR_NEEDS_TO_MINOR_COMPACT())) {

		need_wakeup = TRUE;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compressor_needs_to_swap()) {

		need_wakeup = TRUE;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_minor_count) {
		uint64_t	total_bytes;

		total_bytes = compressor_object-&gt;resident_page_count * PAGE_SIZE_64;

		<span class="enscript-keyword">if</span> ((total_bytes - compressor_bytes_used) &gt; total_bytes / 10)
			need_wakeup = TRUE;
	}
	<span class="enscript-keyword">if</span> (need_wakeup == TRUE) {
			
		lck_mtx_lock_spin_always(c_list_lock);

		fastwake_warmup = FALSE;

		<span class="enscript-keyword">if</span> (compaction_swapper_running == 0) {
			memoryshot(VM_WAKEUP_COMPACTOR_SWAPPER, DBG_FUNC_NONE);

			thread_wakeup((event_t)&amp;c_compressor_swap_trigger);

			compaction_swapper_running = 1;
		}
		lck_mtx_unlock_always(c_list_lock);
	}
}


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">C_SWAPOUT_LIMIT</span>			4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DELAYED_COMPACTIONS_PER_PASS</span>	30

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_do_delayed_compactions</span>(boolean_t flush_all)
{
	c_segment_t	c_seg;
	<span class="enscript-type">int</span>		number_compacted = 0;
	boolean_t	needs_to_swap = FALSE;


	lck_mtx_assert(c_list_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_minor_list_head) &amp;&amp; needs_to_swap == FALSE) {
		
		c_seg = (c_segment_t)queue_first(&amp;c_minor_list_head);
		
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {

			lck_mtx_unlock_always(c_list_lock);
			c_seg_wait_on_busy(c_seg);
			lck_mtx_lock_spin_always(c_list_lock);

			<span class="enscript-keyword">continue</span>;
		}
		C_SEG_BUSY(c_seg);

		c_seg_do_minor_compaction_and_unlock(c_seg, TRUE, FALSE, TRUE);

		<span class="enscript-keyword">if</span> (vm_swap_up == TRUE &amp;&amp; (number_compacted++ &gt; DELAYED_COMPACTIONS_PER_PASS)) {
			
			<span class="enscript-keyword">if</span> ((flush_all == TRUE || compressor_needs_to_swap() == TRUE) &amp;&amp; c_swapout_count &lt; C_SWAPOUT_LIMIT)
				needs_to_swap = TRUE;

			number_compacted = 0;
		}
		lck_mtx_lock_spin_always(c_list_lock);
	}
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SEGMENT_SWAPPEDIN_AGE_LIMIT</span>	10

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_age_swapped_in_segments</span>(boolean_t flush_all)
{
	c_segment_t	c_seg;
	clock_sec_t	now;
	clock_nsec_t	nsec;

	clock_get_system_nanotime(&amp;now,  &amp;nsec);
			
	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_swappedin_list_head)) {

		c_seg = (c_segment_t)queue_first(&amp;c_swappedin_list_head);

		<span class="enscript-keyword">if</span> (flush_all == FALSE &amp;&amp; (now - c_seg-&gt;c_swappedin_ts) &lt; C_SEGMENT_SWAPPEDIN_AGE_LIMIT)
			<span class="enscript-keyword">break</span>;
			
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		c_seg_switch_state(c_seg, C_ON_AGE_Q, FALSE);

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_flush</span>(<span class="enscript-type">void</span>)
{
	uint64_t	vm_swap_put_failures_at_start;
	wait_result_t	wait_result = 0;
	AbsoluteTime	startTime, endTime;
	clock_sec_t	now_sec;
	clock_nsec_t	now_nsec;
	uint64_t	nsec;

	HIBLOG(<span class="enscript-string">&quot;vm_compressor_flush - starting\n&quot;</span>);

	clock_get_uptime(&amp;startTime);

	lck_mtx_lock_spin_always(c_list_lock);

	fastwake_warmup = FALSE;
	compaction_swapper_abort = 1;

	<span class="enscript-keyword">while</span> (compaction_swapper_running) {
		assert_wait((event_t)&amp;compaction_swapper_running, THREAD_UNINT);

		lck_mtx_unlock_always(c_list_lock);
		
		thread_block(THREAD_CONTINUE_NULL);

		lck_mtx_lock_spin_always(c_list_lock);
	}
	compaction_swapper_abort = 0;
	compaction_swapper_running = 1;

	hibernate_flushing = TRUE;
	hibernate_no_swapspace = FALSE;
	c_generation_id_flush_barrier = c_generation_id + 1000;

	clock_get_system_nanotime(&amp;now_sec, &amp;now_nsec);
	hibernate_flushing_deadline = now_sec + HIBERNATE_FLUSHING_SECS_TO_COMPLETE;

	vm_swap_put_failures_at_start = vm_swap_put_failures;

	vm_compressor_compact_and_swap(TRUE);

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_swapout_list_head)) {

		assert_wait_timeout((event_t) &amp;compaction_swapper_running, THREAD_INTERRUPTIBLE, 5000, 1000*NSEC_PER_USEC);

		lck_mtx_unlock_always(c_list_lock);
		
		wait_result = thread_block(THREAD_CONTINUE_NULL);

		lck_mtx_lock_spin_always(c_list_lock);

		<span class="enscript-keyword">if</span> (wait_result == THREAD_TIMED_OUT)
			<span class="enscript-keyword">break</span>;
	}
	hibernate_flushing = FALSE;
	compaction_swapper_running = 0;

	<span class="enscript-keyword">if</span> (vm_swap_put_failures &gt; vm_swap_put_failures_at_start)
		HIBLOG(<span class="enscript-string">&quot;vm_compressor_flush failed to clean %llu segments - vm_page_compressor_count(%d)\n&quot;</span>,
		       vm_swap_put_failures - vm_swap_put_failures_at_start, VM_PAGE_COMPRESSOR_COUNT);
	
	lck_mtx_unlock_always(c_list_lock);

        clock_get_uptime(&amp;endTime);
        SUB_ABSOLUTETIME(&amp;endTime, &amp;startTime);
        absolutetime_to_nanoseconds(endTime, &amp;nsec);

	HIBLOG(<span class="enscript-string">&quot;vm_compressor_flush completed - took %qd msecs\n&quot;</span>, nsec / 1000000ULL);
}


<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	vm_swap_file_set_tuneables(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>		compaction_swap_trigger_thread_awakened = 0;


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_swap_trigger_thread</span>(<span class="enscript-type">void</span>)
{
	current_thread()-&gt;options |= TH_OPT_VMPRIV;

	<span class="enscript-comment">/*
	 * compaction_swapper_init_now is set when the first call to
	 * vm_consider_waking_compactor_swapper is made from 
	 * vm_pageout_scan... since this function is called upon 
	 * thread creation, we want to make sure to delay adjusting
	 * the tuneables until we are awakened via vm_pageout_scan
	 * so that we are at a point where the vm_swapfile_open will
	 * be operating on the correct directory (in case the default
	 * of /var/vm/  is overridden by the dymanic_pager 
	 */</span>
	<span class="enscript-keyword">if</span> (compaction_swapper_init_now &amp;&amp; !compaction_swapper_inited) {
		<span class="enscript-keyword">if</span> (vm_compressor_mode == VM_PAGER_COMPRESSOR_WITH_SWAP)
			vm_swap_file_set_tuneables();

		<span class="enscript-keyword">if</span> (vm_restricted_to_single_processor == TRUE)
			thread_vm_bind_group_add();

		compaction_swapper_inited = 1;
	}
	lck_mtx_lock_spin_always(c_list_lock);

	compaction_swap_trigger_thread_awakened++;

	vm_compressor_compact_and_swap(FALSE);

	assert_wait((event_t)&amp;c_compressor_swap_trigger, THREAD_UNINT);

	compaction_swapper_running = 0;
	thread_wakeup((event_t)&amp;compaction_swapper_running);

	lck_mtx_unlock_always(c_list_lock);
		
	thread_block((thread_continue_t)vm_compressor_swap_trigger_thread);
	
	<span class="enscript-comment">/* NOTREACHED */</span>
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_record_warmup_start</span>(<span class="enscript-type">void</span>)
{
	c_segment_t	c_seg;

	lck_mtx_lock_spin_always(c_list_lock);

	<span class="enscript-keyword">if</span> (first_c_segment_to_warm_generation_id == 0) {
		<span class="enscript-keyword">if</span> (!queue_empty(&amp;c_age_list_head)) {

			c_seg = (c_segment_t)queue_last(&amp;c_age_list_head);

			first_c_segment_to_warm_generation_id = c_seg-&gt;c_generation_id;
		} <span class="enscript-keyword">else</span>
			first_c_segment_to_warm_generation_id = 0;

		fastwake_recording_in_progress = TRUE;
	}
	lck_mtx_unlock_always(c_list_lock);
}


<span class="enscript-type">void</span> 
<span class="enscript-function-name">vm_compressor_record_warmup_end</span>(<span class="enscript-type">void</span>)
{
	c_segment_t	c_seg;

	lck_mtx_lock_spin_always(c_list_lock);

	<span class="enscript-keyword">if</span> (fastwake_recording_in_progress == TRUE) {

		<span class="enscript-keyword">if</span> (!queue_empty(&amp;c_age_list_head)) {

			c_seg = (c_segment_t)queue_last(&amp;c_age_list_head);

			last_c_segment_to_warm_generation_id = c_seg-&gt;c_generation_id;
		} <span class="enscript-keyword">else</span>
			last_c_segment_to_warm_generation_id = first_c_segment_to_warm_generation_id;

		fastwake_recording_in_progress = FALSE;

		HIBLOG(<span class="enscript-string">&quot;vm_compressor_record_warmup (%qd - %qd)\n&quot;</span>, first_c_segment_to_warm_generation_id, last_c_segment_to_warm_generation_id);
	}
	lck_mtx_unlock_always(c_list_lock);
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DELAY_TRIM_ON_WAKE_SECS</span>		4

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_delay_trim</span>(<span class="enscript-type">void</span>)
{
        clock_sec_t	sec;
	clock_nsec_t	nsec;

	clock_get_system_nanotime(&amp;sec, &amp;nsec);
	dont_trim_until_ts = sec + DELAY_TRIM_ON_WAKE_SECS;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_do_warmup</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock_spin_always(c_list_lock);
	
	<span class="enscript-keyword">if</span> (first_c_segment_to_warm_generation_id == last_c_segment_to_warm_generation_id) {
		first_c_segment_to_warm_generation_id = last_c_segment_to_warm_generation_id = 0;

		lck_mtx_unlock_always(c_list_lock);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (compaction_swapper_running == 0) {

		fastwake_warmup = TRUE;
		compaction_swapper_running = 1;
		thread_wakeup((event_t)&amp;c_compressor_swap_trigger);
	}
	lck_mtx_unlock_always(c_list_lock);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">do_fastwake_warmup</span>(<span class="enscript-type">void</span>)
{
	uint64_t	my_thread_id;
	c_segment_t	c_seg = NULL;
	AbsoluteTime	startTime, endTime;
	uint64_t	nsec;


	HIBLOG(<span class="enscript-string">&quot;vm_compressor_fastwake_warmup (%qd - %qd) - starting\n&quot;</span>, first_c_segment_to_warm_generation_id, last_c_segment_to_warm_generation_id);

	clock_get_uptime(&amp;startTime);

	lck_mtx_unlock_always(c_list_lock);

	my_thread_id = current_thread()-&gt;thread_id;
	proc_set_task_policy_thread(kernel_task, my_thread_id,
				    TASK_POLICY_INTERNAL, TASK_POLICY_IO, THROTTLE_LEVEL_COMPRESSOR_TIER2);

	PAGE_REPLACEMENT_DISALLOWED(TRUE);

	lck_mtx_lock_spin_always(c_list_lock);

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_swappedout_list_head) &amp;&amp; fastwake_warmup == TRUE) {

		c_seg = (c_segment_t) queue_first(&amp;c_swappedout_list_head);

		<span class="enscript-keyword">if</span> (c_seg-&gt;c_generation_id &lt; first_c_segment_to_warm_generation_id || 
		    c_seg-&gt;c_generation_id &gt; last_c_segment_to_warm_generation_id)
			<span class="enscript-keyword">break</span>;

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
		lck_mtx_unlock_always(c_list_lock);
		
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {
			PAGE_REPLACEMENT_DISALLOWED(FALSE);
			c_seg_wait_on_busy(c_seg);
			PAGE_REPLACEMENT_DISALLOWED(TRUE);
		} <span class="enscript-keyword">else</span> {
			c_seg_swapin(c_seg, TRUE);

			lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
			c_segment_warmup_count++;

			PAGE_REPLACEMENT_DISALLOWED(FALSE);
			vm_pageout_io_throttle();
			PAGE_REPLACEMENT_DISALLOWED(TRUE);
		}
		lck_mtx_lock_spin_always(c_list_lock);
	}
	lck_mtx_unlock_always(c_list_lock);

	PAGE_REPLACEMENT_DISALLOWED(FALSE);

	proc_set_task_policy_thread(kernel_task, my_thread_id,
				    TASK_POLICY_INTERNAL, TASK_POLICY_IO, THROTTLE_LEVEL_COMPRESSOR_TIER0);

        clock_get_uptime(&amp;endTime);
        SUB_ABSOLUTETIME(&amp;endTime, &amp;startTime);
        absolutetime_to_nanoseconds(endTime, &amp;nsec);

	HIBLOG(<span class="enscript-string">&quot;vm_compressor_fastwake_warmup completed - took %qd msecs\n&quot;</span>, nsec / 1000000ULL);

	lck_mtx_lock_spin_always(c_list_lock);

	first_c_segment_to_warm_generation_id = last_c_segment_to_warm_generation_id = 0;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_compact_and_swap</span>(boolean_t flush_all)
{
	c_segment_t	c_seg, c_seg_next;
	boolean_t	keep_compacting;
	clock_sec_t	now;
	clock_nsec_t	nsec;


	<span class="enscript-keyword">if</span> (fastwake_warmup == TRUE) {
		uint64_t	starting_warmup_count;

		starting_warmup_count = c_segment_warmup_count;

		KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 11) | DBG_FUNC_START, c_segment_warmup_count,
				      first_c_segment_to_warm_generation_id, last_c_segment_to_warm_generation_id, 0, 0);
		do_fastwake_warmup();
		KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 11) | DBG_FUNC_END, c_segment_warmup_count, c_segment_warmup_count - starting_warmup_count, 0, 0, 0);

		fastwake_warmup = FALSE;
	}

	<span class="enscript-comment">/*
	 * it's possible for the c_age_list_head to be empty if we
	 * hit our limits for growing the compressor pool and we subsequently
	 * hibernated... on the next hibernation we could see the queue as
	 * empty and not proceeed even though we have a bunch of segments on
	 * the swapped in queue that need to be dealt with.
	 */</span>
	vm_compressor_do_delayed_compactions(flush_all);

	vm_compressor_age_swapped_in_segments(flush_all);

	<span class="enscript-comment">/*
	 * we only need to grab the timestamp once per
	 * invocation of this function since the 
	 * timescale we're interested in is measured
	 * in days
	 */</span>
	clock_get_system_nanotime(&amp;now,  &amp;nsec);

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_age_list_head) &amp;&amp; compaction_swapper_abort == 0) {

		<span class="enscript-keyword">if</span> (hibernate_flushing == TRUE) {
			clock_sec_t	sec;

			<span class="enscript-keyword">if</span> (hibernate_should_abort()) {
				HIBLOG(<span class="enscript-string">&quot;vm_compressor_flush - hibernate_should_abort returned TRUE\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (hibernate_no_swapspace == TRUE) {
				HIBLOG(<span class="enscript-string">&quot;vm_compressor_flush - out of swap space\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}
			clock_get_system_nanotime(&amp;sec, &amp;nsec);
		
			<span class="enscript-keyword">if</span> (sec &gt; hibernate_flushing_deadline) {
				HIBLOG(<span class="enscript-string">&quot;vm_compressor_flush - failed to finish before deadline\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (c_swapout_count &gt;= C_SWAPOUT_LIMIT) {

			assert_wait_timeout((event_t) &amp;compaction_swapper_running, THREAD_INTERRUPTIBLE, 100, 1000*NSEC_PER_USEC);

			lck_mtx_unlock_always(c_list_lock);

			thread_block(THREAD_CONTINUE_NULL);

			lck_mtx_lock_spin_always(c_list_lock);
		}
		<span class="enscript-comment">/*
		 * Minor compactions
		 */</span>
		vm_compressor_do_delayed_compactions(flush_all);

		vm_compressor_age_swapped_in_segments(flush_all);

		<span class="enscript-keyword">if</span> (c_swapout_count &gt;= C_SWAPOUT_LIMIT) {
			<span class="enscript-comment">/*
			 * we timed out on the above thread_block
			 * let's loop around and try again
			 * the timeout allows us to continue
			 * to do minor compactions to make
			 * more memory available
			 */</span>
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * Swap out segments?
		 */</span>
		<span class="enscript-keyword">if</span> (flush_all == FALSE) {
			boolean_t	needs_to_swap;

			lck_mtx_unlock_always(c_list_lock);

			needs_to_swap = compressor_needs_to_swap();

			<span class="enscript-keyword">if</span> (needs_to_swap == TRUE &amp;&amp; vm_swap_low_on_space())
				vm_compressor_take_paging_space_action();

			lck_mtx_lock_spin_always(c_list_lock);
			
			<span class="enscript-keyword">if</span> (needs_to_swap == FALSE)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (queue_empty(&amp;c_age_list_head))
			<span class="enscript-keyword">break</span>;
		c_seg = (c_segment_t) queue_first(&amp;c_age_list_head);

		assert(c_seg-&gt;c_state == C_ON_AGE_Q);

		<span class="enscript-keyword">if</span> (flush_all == TRUE &amp;&amp; c_seg-&gt;c_generation_id &gt; c_generation_id_flush_barrier)
			<span class="enscript-keyword">break</span>;
		
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {

			lck_mtx_unlock_always(c_list_lock);
			c_seg_wait_on_busy(c_seg);
			lck_mtx_lock_spin_always(c_list_lock);

			<span class="enscript-keyword">continue</span>;
		}
		C_SEG_BUSY(c_seg);

		<span class="enscript-keyword">if</span> (c_seg_do_minor_compaction_and_unlock(c_seg, FALSE, TRUE, TRUE)) {
			<span class="enscript-comment">/*
			 * found an empty c_segment and freed it
			 * so go grab the next guy in the queue
			 */</span>
			c_seg_major_compact_stats.count_of_freed_segs++;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * Major compaction
		 */</span>
		keep_compacting = TRUE;

		<span class="enscript-keyword">while</span> (keep_compacting == TRUE) {
					
			assert(c_seg-&gt;c_busy);

			<span class="enscript-comment">/* look for another segment to consolidate */</span>

			c_seg_next = (c_segment_t) queue_next(&amp;c_seg-&gt;c_age_list);
			
			<span class="enscript-keyword">if</span> (queue_end(&amp;c_age_list_head, (queue_entry_t)c_seg_next))
				<span class="enscript-keyword">break</span>;

			assert(c_seg_next-&gt;c_state == C_ON_AGE_Q);

			<span class="enscript-keyword">if</span> (c_seg_major_compact_ok(c_seg, c_seg_next) == FALSE)
				<span class="enscript-keyword">break</span>;

			lck_mtx_lock_spin_always(&amp;c_seg_next-&gt;c_lock);

			<span class="enscript-keyword">if</span> (c_seg_next-&gt;c_busy) {

				lck_mtx_unlock_always(c_list_lock);
				c_seg_wait_on_busy(c_seg_next);
				lck_mtx_lock_spin_always(c_list_lock);

				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* grab that segment */</span>
			C_SEG_BUSY(c_seg_next);

			<span class="enscript-keyword">if</span> (c_seg_do_minor_compaction_and_unlock(c_seg_next, FALSE, TRUE, TRUE)) {
				<span class="enscript-comment">/*
				 * found an empty c_segment and freed it
				 * so we can't continue to use c_seg_next
				 */</span>
				c_seg_major_compact_stats.count_of_freed_segs++;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/* unlock the list ... */</span>
			lck_mtx_unlock_always(c_list_lock);

			<span class="enscript-comment">/* do the major compaction */</span>

			keep_compacting = c_seg_major_compact(c_seg, c_seg_next);

			PAGE_REPLACEMENT_DISALLOWED(TRUE);

			lck_mtx_lock_spin_always(&amp;c_seg_next-&gt;c_lock);
			<span class="enscript-comment">/*
			 * run a minor compaction on the donor segment
			 * since we pulled at least some of it's 
			 * data into our target...  if we've emptied
			 * it, now is a good time to free it which
			 * c_seg_minor_compaction_and_unlock also takes care of
			 *
			 * by passing TRUE, we ask for c_busy to be cleared
			 * and c_wanted to be taken care of
			 */</span>
			<span class="enscript-keyword">if</span> (c_seg_minor_compaction_and_unlock(c_seg_next, TRUE))
				c_seg_major_compact_stats.count_of_freed_segs++;

			PAGE_REPLACEMENT_DISALLOWED(FALSE);

			<span class="enscript-comment">/* relock the list */</span>
			lck_mtx_lock_spin_always(c_list_lock);

		} <span class="enscript-comment">/* major compaction */</span>

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		assert(c_seg-&gt;c_busy);
		assert(!c_seg-&gt;c_on_minorcompact_q);

		<span class="enscript-keyword">if</span> (vm_swap_up == TRUE) {
			<span class="enscript-comment">/*
			 * This mode of putting a generic c_seg on the swapout list is
			 * only supported when we have general swap ON i.e.
			 * we compress pages into c_segs as we process them off
			 * the paging queues in vm_pageout_scan().
			 */</span>
			<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_SWAPBACKED)
				c_seg_switch_state(c_seg, C_ON_SWAPOUT_Q, FALSE);
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> ((vm_swapout_ripe_segments == TRUE &amp;&amp; c_overage_swapped_count &lt; c_overage_swapped_limit)) {
					<span class="enscript-comment">/*
					 * we are running compressor sweeps with swap-behind
					 * make sure the c_seg has aged enough before swapping it
					 * out...
					 */</span>
					<span class="enscript-keyword">if</span> ((now - c_seg-&gt;c_creation_ts) &gt;= vm_ripe_target_age) {
						c_seg-&gt;c_overage_swap = TRUE;
						c_overage_swapped_count++;
						c_seg_switch_state(c_seg, C_ON_SWAPOUT_Q, FALSE);
					}
				}
			}
		}
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_state == C_ON_AGE_Q) {
			<span class="enscript-comment">/*
			 * this c_seg didn't get moved to the swapout queue
			 * so we need to move it out of the way...
			 * we just did a major compaction on it so put it
			 * on that queue
			 */</span> 
			c_seg_switch_state(c_seg, C_ON_MAJORCOMPACT_Q, FALSE);
		} <span class="enscript-keyword">else</span> {
			c_seg_major_compact_stats.wasted_space_in_swapouts += C_SEG_BUFSIZE - c_seg-&gt;c_bytes_used;
			c_seg_major_compact_stats.count_of_swapouts++;
		}
		C_SEG_WAKEUP_DONE(c_seg);

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">if</span> (c_swapout_count) {
			lck_mtx_unlock_always(c_list_lock);

			thread_wakeup((event_t)&amp;c_swapout_list_head);
			
			lck_mtx_lock_spin_always(c_list_lock);
		}
	}
}


<span class="enscript-type">static</span> c_segment_t
<span class="enscript-function-name">c_seg_allocate</span>(c_segment_t *current_chead)
{
	c_segment_t	c_seg;
	<span class="enscript-type">int</span>		min_needed;
	<span class="enscript-type">int</span>		size_to_populate;

	<span class="enscript-keyword">if</span> (vm_compressor_low_on_space())
		vm_compressor_take_paging_space_action();

	<span class="enscript-keyword">if</span> ( (c_seg = *current_chead) == NULL ) {
		uint32_t	c_segno;

		lck_mtx_lock_spin_always(c_list_lock);

		<span class="enscript-keyword">while</span> (c_segments_busy == TRUE) {
			assert_wait((event_t) (&amp;c_segments_busy), THREAD_UNINT);
	
			lck_mtx_unlock_always(c_list_lock);

			thread_block(THREAD_CONTINUE_NULL);

			lck_mtx_lock_spin_always(c_list_lock);
		}
		<span class="enscript-keyword">if</span> (c_free_segno_head == (uint32_t)-1) {
			uint32_t	c_segments_available_new;

			<span class="enscript-keyword">if</span> (c_segments_available &gt;= c_segments_limit || c_segment_pages_compressed &gt;= c_segment_pages_compressed_limit) {
				lck_mtx_unlock_always(c_list_lock);

				<span class="enscript-keyword">return</span> (NULL);
			}
			c_segments_busy = TRUE;
			lck_mtx_unlock_always(c_list_lock);

			kernel_memory_populate(kernel_map, (vm_offset_t)c_segments_next_page, 
						PAGE_SIZE, KMA_KOBJECT, VM_KERN_MEMORY_COMPRESSOR);
			c_segments_next_page += PAGE_SIZE;

			c_segments_available_new = c_segments_available + C_SEGMENTS_PER_PAGE;

			<span class="enscript-keyword">if</span> (c_segments_available_new &gt; c_segments_limit)
				c_segments_available_new = c_segments_limit;

			<span class="enscript-keyword">for</span> (c_segno = c_segments_available + 1; c_segno &lt; c_segments_available_new; c_segno++)
				c_segments[c_segno - 1].c_segno = c_segno;

			lck_mtx_lock_spin_always(c_list_lock);

			c_segments[c_segno - 1].c_segno = c_free_segno_head;
			c_free_segno_head = c_segments_available;
			c_segments_available = c_segments_available_new;

			c_segments_busy = FALSE;
			thread_wakeup((event_t) (&amp;c_segments_busy));
		}
		c_segno = c_free_segno_head;
		assert(c_segno &gt;= 0 &amp;&amp; c_segno &lt; c_segments_limit);

		c_free_segno_head = c_segments[c_segno].c_segno;

		<span class="enscript-comment">/*
		 * do the rest of the bookkeeping now while we're still behind
		 * the list lock and grab our generation id now into a local
		 * so that we can install it once we have the c_seg allocated
		 */</span>
		c_segment_count++;
		<span class="enscript-keyword">if</span> (c_segment_count &gt; c_segment_count_max)
			c_segment_count_max = c_segment_count;

		lck_mtx_unlock_always(c_list_lock);

		c_seg = (c_segment_t)zalloc(compressor_segment_zone);
		bzero((<span class="enscript-type">char</span> *)c_seg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> c_segment));

		c_seg-&gt;c_store.c_buffer = (int32_t *)C_SEG_BUFFER_ADDRESS(c_segno);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
		lck_mtx_init(&amp;c_seg-&gt;c_lock, &amp;vm_compressor_lck_grp, &amp;vm_compressor_lck_attr);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>
		lck_spin_init(&amp;c_seg-&gt;c_lock, &amp;vm_compressor_lck_grp, &amp;vm_compressor_lck_attr);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>
	
		c_seg-&gt;c_state = C_IS_EMPTY;
		c_seg-&gt;c_firstemptyslot = C_SLOT_MAX_INDEX;
		c_seg-&gt;c_mysegno = c_segno;

		lck_mtx_lock_spin_always(c_list_lock);
		c_empty_count++;
		c_seg_switch_state(c_seg, C_IS_FILLING, FALSE);
		c_segments[c_segno].c_seg = c_seg;
		lck_mtx_unlock_always(c_list_lock);

		*current_chead = c_seg;
	}
	c_seg_alloc_nextslot(c_seg);

	size_to_populate = C_SEG_ALLOCSIZE - C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset);
	
	<span class="enscript-keyword">if</span> (size_to_populate) {

		min_needed = PAGE_SIZE + (C_SEG_ALLOCSIZE - C_SEG_BUFSIZE);

		<span class="enscript-keyword">if</span> (C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset - c_seg-&gt;c_nextoffset) &lt; (<span class="enscript-type">unsigned</span>) min_needed) {

			<span class="enscript-keyword">if</span> (size_to_populate &gt; C_SEG_MAX_POPULATE_SIZE)
				size_to_populate = C_SEG_MAX_POPULATE_SIZE;

			kernel_memory_populate(kernel_map,
					       (vm_offset_t) &amp;c_seg-&gt;c_store.c_buffer[c_seg-&gt;c_populated_offset],
					       size_to_populate,
					       KMA_COMPRESSOR,
					       VM_KERN_MEMORY_COMPRESSOR);
		} <span class="enscript-keyword">else</span>
			size_to_populate = 0;
	}
	PAGE_REPLACEMENT_DISALLOWED(TRUE);

	lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

	<span class="enscript-keyword">if</span> (size_to_populate)
		c_seg-&gt;c_populated_offset += C_SEG_BYTES_TO_OFFSET(size_to_populate);

	<span class="enscript-keyword">return</span> (c_seg);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">c_current_seg_filled</span>(c_segment_t c_seg, c_segment_t *current_chead)
{
	uint32_t	unused_bytes;
	uint32_t	offset_to_depopulate;
	<span class="enscript-type">int</span>		new_state = C_ON_AGE_Q;
	clock_sec_t	sec;
	clock_nsec_t	nsec;

	unused_bytes = trunc_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset - c_seg-&gt;c_nextoffset));

	<span class="enscript-keyword">if</span> (unused_bytes) {

		offset_to_depopulate = C_SEG_BYTES_TO_OFFSET(round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_nextoffset)));

		<span class="enscript-comment">/*
		 *  release the extra physical page(s) at the end of the segment
		 */</span>
		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		kernel_memory_depopulate(
			kernel_map,
			(vm_offset_t) &amp;c_seg-&gt;c_store.c_buffer[offset_to_depopulate],
			unused_bytes,
			KMA_COMPRESSOR);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		c_seg-&gt;c_populated_offset = offset_to_depopulate;
	}
	assert(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset) &lt;= C_SEG_BUFSIZE);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-keyword">if</span> (current_chead == (c_segment_t*)&amp;freezer_chead &amp;&amp; DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED &amp;&amp;
	    c_freezer_swapout_count &lt; VM_MAX_FREEZER_CSEG_SWAP_COUNT) {
		new_state = C_ON_SWAPOUT_Q;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

	clock_get_system_nanotime(&amp;sec, &amp;nsec);
	c_seg-&gt;c_creation_ts = (uint32_t)sec;

	lck_mtx_lock_spin_always(c_list_lock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_state == C_ON_SWAPOUT_Q)
		c_freezer_swapout_count++;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

	c_seg-&gt;c_generation_id = c_generation_id++;
	c_seg_switch_state(c_seg, new_state, FALSE);

	lck_mtx_unlock_always(c_list_lock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_state == C_ON_SWAPOUT_Q)
		thread_wakeup((event_t)&amp;c_swapout_list_head);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_state == C_ON_AGE_Q &amp;&amp; C_SEG_UNUSED_BYTES(c_seg) &gt;= PAGE_SIZE)
		c_seg_need_delayed_compaction(c_seg);

	*current_chead = NULL;
}

<span class="enscript-comment">/*
 * returns with c_seg locked
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_swapin_requeue</span>(c_segment_t c_seg, boolean_t has_data)
{
        clock_sec_t	sec;
        clock_nsec_t	nsec;

	clock_get_system_nanotime(&amp;sec, &amp;nsec);

	lck_mtx_lock_spin_always(c_list_lock);
	lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

	c_seg-&gt;c_busy_swapping = 0;

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_overage_swap == TRUE) {
		c_overage_swapped_count--;
		c_seg-&gt;c_overage_swap = FALSE;
	}	
	<span class="enscript-keyword">if</span> (has_data == TRUE) {
		c_seg_switch_state(c_seg, C_ON_SWAPPEDIN_Q, FALSE);
	} <span class="enscript-keyword">else</span> {
		c_seg-&gt;c_store.c_buffer = (int32_t*) NULL;
		c_seg-&gt;c_populated_offset = C_SEG_BYTES_TO_OFFSET(0);

		c_seg_switch_state(c_seg, C_ON_BAD_Q, FALSE);
	}
	c_seg-&gt;c_swappedin_ts = (uint32_t)sec;

	lck_mtx_unlock_always(c_list_lock);
}



<span class="enscript-comment">/*
 * c_seg has to be locked and is returned locked.
 * PAGE_REPLACMENT_DISALLOWED has to be TRUE on entry and is returned TRUE
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">c_seg_swapin</span>(c_segment_t c_seg, boolean_t force_minor_compaction)
{
	vm_offset_t	addr = 0;
	uint32_t	io_size = 0;
	uint64_t	f_offset;

	assert(C_SEG_IS_ONDISK(c_seg));
	
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CHECKSUM_THE_SWAP</span>
	c_seg_trim_tail(c_seg);
#<span class="enscript-reference">endif</span>
	io_size = round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset));
	f_offset = c_seg-&gt;c_store.c_swap_handle;

	C_SEG_BUSY(c_seg);
	c_seg-&gt;c_busy_swapping = 1;
	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

	PAGE_REPLACEMENT_DISALLOWED(FALSE);

	addr = (vm_offset_t)C_SEG_BUFFER_ADDRESS(c_seg-&gt;c_mysegno);

	kernel_memory_populate(kernel_map, addr, io_size, KMA_COMPRESSOR, VM_KERN_MEMORY_COMPRESSOR);

	<span class="enscript-keyword">if</span> (vm_swap_get(addr, f_offset, io_size) != KERN_SUCCESS) {
		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		kernel_memory_depopulate(kernel_map, addr, io_size, KMA_COMPRESSOR);

		c_seg_swapin_requeue(c_seg, FALSE);
	} <span class="enscript-keyword">else</span> {
		c_seg-&gt;c_store.c_buffer = (int32_t*) addr;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
		vm_swap_decrypt(c_seg);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_SWAP</span>
		<span class="enscript-keyword">if</span> (c_seg-&gt;cseg_swap_size != io_size)
			panic(<span class="enscript-string">&quot;swapin size doesn't match swapout size&quot;</span>);

		<span class="enscript-keyword">if</span> (c_seg-&gt;cseg_hash != hash_string((<span class="enscript-type">char</span>*) c_seg-&gt;c_store.c_buffer, (<span class="enscript-type">int</span>)io_size)) {
			panic(<span class="enscript-string">&quot;c_seg_swapin - Swap hash mismatch\n&quot;</span>);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CHECKSUM_THE_SWAP */</span>

		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		<span class="enscript-keyword">if</span> (force_minor_compaction == TRUE) {
			lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
			
			c_seg_minor_compaction_and_unlock(c_seg, FALSE);
		}
		OSAddAtomic64(c_seg-&gt;c_bytes_used, &amp;compressor_bytes_used);

		c_seg_swapin_requeue(c_seg, TRUE);
	}
	C_SEG_WAKEUP_DONE(c_seg);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">c_segment_sv_hash_drop_ref</span>(<span class="enscript-type">int</span> hash_indx)
{
	<span class="enscript-type">struct</span> c_sv_hash_entry o_sv_he, n_sv_he;

	<span class="enscript-keyword">while</span> (1) {

		o_sv_he.he_record = c_segment_sv_hash_table[hash_indx].he_record;

		n_sv_he.he_ref = o_sv_he.he_ref - 1;
		n_sv_he.he_data = o_sv_he.he_data;

		<span class="enscript-keyword">if</span> (OSCompareAndSwap64((UInt64)o_sv_he.he_record, (UInt64)n_sv_he.he_record, (UInt64 *) &amp;c_segment_sv_hash_table[hash_indx].he_record) == TRUE) {
			<span class="enscript-keyword">if</span> (n_sv_he.he_ref == 0)
				OSAddAtomic(-1, &amp;c_segment_svp_in_hash);
			<span class="enscript-keyword">break</span>;
		}
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">c_segment_sv_hash_insert</span>(uint32_t data)
{
	<span class="enscript-type">int</span>		hash_sindx;
	<span class="enscript-type">int</span>		misses;
	<span class="enscript-type">struct</span> c_sv_hash_entry o_sv_he, n_sv_he;
	boolean_t	got_ref = FALSE;

	<span class="enscript-keyword">if</span> (data == 0)
		OSAddAtomic(1, &amp;c_segment_svp_zero_compressions);
	<span class="enscript-keyword">else</span>
		OSAddAtomic(1, &amp;c_segment_svp_nonzero_compressions);

	hash_sindx = data &amp; C_SV_HASH_MASK;
	
	<span class="enscript-keyword">for</span> (misses = 0; misses &lt; C_SV_HASH_MAX_MISS; misses++)
	{
		o_sv_he.he_record = c_segment_sv_hash_table[hash_sindx].he_record;

		<span class="enscript-keyword">while</span> (o_sv_he.he_data == data || o_sv_he.he_ref == 0) {
			n_sv_he.he_ref = o_sv_he.he_ref + 1;
			n_sv_he.he_data = data;

			<span class="enscript-keyword">if</span> (OSCompareAndSwap64((UInt64)o_sv_he.he_record, (UInt64)n_sv_he.he_record, (UInt64 *) &amp;c_segment_sv_hash_table[hash_sindx].he_record) == TRUE) {
				<span class="enscript-keyword">if</span> (n_sv_he.he_ref == 1)
					OSAddAtomic(1, &amp;c_segment_svp_in_hash);
				got_ref = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			o_sv_he.he_record = c_segment_sv_hash_table[hash_sindx].he_record;
		}
		<span class="enscript-keyword">if</span> (got_ref == TRUE)
			<span class="enscript-keyword">break</span>;
		hash_sindx++;

		<span class="enscript-keyword">if</span> (hash_sindx == C_SV_HASH_SIZE)
			hash_sindx = 0;
	}
	<span class="enscript-keyword">if</span> (got_ref == FALSE)
		<span class="enscript-keyword">return</span>(-1);

	<span class="enscript-keyword">return</span> (hash_sindx);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">c_compressed_record_data</span>(<span class="enscript-type">char</span> *src, <span class="enscript-type">int</span> c_size)
{
	<span class="enscript-keyword">if</span> ((c_compressed_record_cptr + c_size + 4) &gt;= c_compressed_record_ebuf)
		panic(<span class="enscript-string">&quot;c_compressed_record_cptr &gt;= c_compressed_record_ebuf&quot;</span>);

	*(<span class="enscript-type">int</span> *)((<span class="enscript-type">void</span> *)c_compressed_record_cptr) = c_size;

	c_compressed_record_cptr += 4;

	memcpy(c_compressed_record_cptr, src, c_size);
	c_compressed_record_cptr += c_size;
}
#<span class="enscript-reference">endif</span>


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">c_compress_page</span>(<span class="enscript-type">char</span> *src, c_slot_mapping_t slot_ptr, c_segment_t *current_chead, <span class="enscript-type">char</span> *scratch_buf)
{
	<span class="enscript-type">int</span>		c_size;
	<span class="enscript-type">int</span>		c_rounded_size = 0;
	<span class="enscript-type">int</span>		max_csize;
	c_slot_t	cs;
	c_segment_t	c_seg;

	KERNEL_DEBUG(0xe0400000 | DBG_FUNC_START, *current_chead, 0, 0, 0, 0);
<span class="enscript-reference">retry</span>:
	<span class="enscript-keyword">if</span> ((c_seg = c_seg_allocate(current_chead)) == NULL)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-comment">/*
	 * returns with c_seg lock held
	 * and PAGE_REPLACEMENT_DISALLOWED(TRUE)...
	 * c_nextslot has been allocated and
	 * c_store.c_buffer populated
	 */</span>
	assert(c_seg-&gt;c_state == C_IS_FILLING);

	cs = C_SEG_SLOT_FROM_INDEX(c_seg, c_seg-&gt;c_nextslot);

	cs-&gt;c_packed_ptr = C_SLOT_PACK_PTR(slot_ptr);
	assert(slot_ptr == (c_slot_mapping_t)C_SLOT_UNPACK_PTR(cs));

	cs-&gt;c_offset = c_seg-&gt;c_nextoffset;

	max_csize = C_SEG_BUFSIZE - C_SEG_OFFSET_TO_BYTES((int32_t)cs-&gt;c_offset);

	<span class="enscript-keyword">if</span> (max_csize &gt; PAGE_SIZE)
		max_csize = PAGE_SIZE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_DATA</span>
	cs-&gt;c_hash_data = hash_string(src, PAGE_SIZE);
#<span class="enscript-reference">endif</span>

	c_size = WKdm_compress_new((<span class="enscript-type">const</span> WK_word *)(uintptr_t)src, (WK_word *)(uintptr_t)&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset],
				  (WK_word *)(uintptr_t)scratch_buf, max_csize - 4);
	assert(c_size &lt;= (max_csize - 4) &amp;&amp; c_size &gt;= -1);

	<span class="enscript-keyword">if</span> (c_size == -1) {

		<span class="enscript-keyword">if</span> (max_csize &lt; PAGE_SIZE) {
			c_current_seg_filled(c_seg, current_chead);
			assert(*current_chead == NULL);

			lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

			PAGE_REPLACEMENT_DISALLOWED(FALSE);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
		c_size = PAGE_SIZE;

		memcpy(&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], src, c_size);

		OSAddAtomic(1, &amp;c_segment_noncompressible_pages);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_size == 0) {
		<span class="enscript-type">int</span>		hash_index;

		<span class="enscript-comment">/*
		 * special case - this is a page completely full of a single 32 bit value
		 */</span>
		hash_index = c_segment_sv_hash_insert(*(uint32_t *)(uintptr_t)src);

		<span class="enscript-keyword">if</span> (hash_index != -1) {
			slot_ptr-&gt;s_cindx = hash_index;
			slot_ptr-&gt;s_cseg = C_SV_CSEG_ID;

			OSAddAtomic(1, &amp;c_segment_svp_hash_succeeded);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>
			c_compressed_record_data(src, 4);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sv_compression</span>;
		}
		c_size = 4;
		
		memcpy(&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], src, c_size);

		OSAddAtomic(1, &amp;c_segment_svp_hash_failed);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>
	c_compressed_record_data((<span class="enscript-type">char</span> *)&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], c_size);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
	cs-&gt;c_hash_compressed_data = hash_string((<span class="enscript-type">char</span> *)&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], c_size);
#<span class="enscript-reference">endif</span>
	c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;

	PACK_C_SIZE(cs, c_size);
	c_seg-&gt;c_bytes_used += c_rounded_size;
	c_seg-&gt;c_nextoffset += C_SEG_BYTES_TO_OFFSET(c_rounded_size);

	slot_ptr-&gt;s_cindx = c_seg-&gt;c_nextslot++;
	<span class="enscript-comment">/* &lt;csegno=0,indx=0&gt; would mean &quot;empty slot&quot;, so use csegno+1 */</span>
	slot_ptr-&gt;s_cseg = c_seg-&gt;c_mysegno + 1; 

<span class="enscript-reference">sv_compression</span>:
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_nextoffset &gt;= C_SEG_OFF_LIMIT || c_seg-&gt;c_nextslot &gt;= C_SLOT_MAX_INDEX) {
		c_current_seg_filled(c_seg, current_chead);
		assert(*current_chead == NULL);
	}
	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

	PAGE_REPLACEMENT_DISALLOWED(FALSE);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>
	<span class="enscript-keyword">if</span> ((c_compressed_record_cptr - c_compressed_record_sbuf) &gt;= C_SEG_ALLOCSIZE) {
		c_compressed_record_write(c_compressed_record_sbuf, (<span class="enscript-type">int</span>)(c_compressed_record_cptr - c_compressed_record_sbuf));
		c_compressed_record_cptr = c_compressed_record_sbuf;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (c_size) {
		OSAddAtomic64(c_size, &amp;c_segment_compressed_bytes);
		OSAddAtomic64(c_rounded_size, &amp;compressor_bytes_used);
	}
	OSAddAtomic64(PAGE_SIZE, &amp;c_segment_input_bytes);

	OSAddAtomic(1, &amp;c_segment_pages_compressed);
	OSAddAtomic(1, &amp;sample_period_compression_count);

	KERNEL_DEBUG(0xe0400000 | DBG_FUNC_END, *current_chead, c_size, c_segment_input_bytes, c_segment_compressed_bytes, 0);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">c_decompress_page</span>(<span class="enscript-type">char</span> *dst, <span class="enscript-type">volatile</span> c_slot_mapping_t slot_ptr, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> *zeroslot)
{
	c_slot_t	cs;
	c_segment_t	c_seg;
	<span class="enscript-type">int</span>		c_indx;
	<span class="enscript-type">int</span>		c_rounded_size;
	uint32_t	c_size;
	<span class="enscript-type">int</span>		retval = 0;
	boolean_t	need_unlock = TRUE;
	boolean_t	consider_defragmenting = FALSE;
	boolean_t	kdp_mode = FALSE;

	<span class="enscript-keyword">if</span> (flags &amp; C_KDP) {
		<span class="enscript-keyword">if</span> (not_in_kdp) {
			panic(<span class="enscript-string">&quot;C_KDP passed to decompress page from outside of debugger context&quot;</span>);
		}

		assert((flags &amp; C_KEEP) ==  C_KEEP);
		assert((flags &amp; C_DONT_BLOCK) == C_DONT_BLOCK);

		<span class="enscript-keyword">if</span> ((flags &amp; (C_DONT_BLOCK | C_KEEP)) != (C_DONT_BLOCK | C_KEEP)) {
			<span class="enscript-keyword">return</span> (-2);
		}

		kdp_mode = TRUE;
	}

<span class="enscript-reference">ReTry</span>:
	<span class="enscript-keyword">if</span> (!kdp_mode) {
		PAGE_REPLACEMENT_DISALLOWED(TRUE);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (kdp_lck_rw_lock_is_acquired_exclusive(&amp;c_master_lock)) {
			<span class="enscript-keyword">return</span> (-2);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	<span class="enscript-comment">/*
	 * if hibernation is enabled, it indicates (via a call
	 * to 'vm_decompressor_lock' that no further
	 * decompressions are allowed once it reaches
	 * the point of flushing all of the currently dirty
	 * anonymous memory through the compressor and out
	 * to disk... in this state we allow freeing of compressed
	 * pages and must honor the C_DONT_BLOCK case
	 */</span>
	<span class="enscript-keyword">if</span> (dst &amp;&amp; decompressions_blocked == TRUE) {
		<span class="enscript-keyword">if</span> (flags &amp; C_DONT_BLOCK) {

			<span class="enscript-keyword">if</span> (!kdp_mode) {
				PAGE_REPLACEMENT_DISALLOWED(FALSE);
			}

			*zeroslot = 0;
			<span class="enscript-keyword">return</span> (-2);
		}
		<span class="enscript-comment">/*
		 * it's safe to atomically assert and block behind the
		 * lock held in shared mode because &quot;decompressions_blocked&quot; is
		 * only set and cleared and the thread_wakeup done when the lock
		 * is held exclusively
		 */</span>
		assert_wait((event_t)&amp;decompressions_blocked, THREAD_UNINT);

		PAGE_REPLACEMENT_DISALLOWED(FALSE);

		thread_block(THREAD_CONTINUE_NULL);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ReTry</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* s_cseg is actually &quot;segno+1&quot; */</span>
	c_seg = c_segments[slot_ptr-&gt;s_cseg - 1].c_seg;

	<span class="enscript-keyword">if</span> (!kdp_mode) {
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (kdp_lck_mtx_lock_spin_is_acquired(&amp;c_seg-&gt;c_lock)) {
			<span class="enscript-keyword">return</span> (-2);
		}
	}

	assert(c_seg-&gt;c_state != C_IS_EMPTY &amp;&amp; c_seg-&gt;c_state != C_IS_FREE);

	<span class="enscript-keyword">if</span> (flags &amp; C_DONT_BLOCK) {
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy || (C_SEG_IS_ONDISK(c_seg) &amp;&amp; dst)) {
			*zeroslot = 0;

			retval = -2;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {

		PAGE_REPLACEMENT_DISALLOWED(FALSE);

		c_seg_wait_on_busy(c_seg);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ReTry</span>;
	}
	c_indx = slot_ptr-&gt;s_cindx;

	cs = C_SEG_SLOT_FROM_INDEX(c_seg, c_indx);

	c_size = UNPACK_C_SIZE(cs);

	c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;

	<span class="enscript-keyword">if</span> (dst) {
		uint32_t	age_of_cseg;
		clock_sec_t	cur_ts_sec;
		clock_nsec_t	cur_ts_nsec;

		<span class="enscript-keyword">if</span> (C_SEG_IS_ONDISK(c_seg)) {
			assert(kdp_mode == FALSE);
			c_seg_swapin(c_seg, FALSE);

			retval = 1;
		}		
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_state == C_ON_BAD_Q) {
			assert(c_seg-&gt;c_store.c_buffer == NULL);

			retval = -1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">c_seg_invalid_data</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
		<span class="enscript-keyword">if</span> (cs-&gt;c_hash_compressed_data != hash_string((<span class="enscript-type">char</span> *)&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], c_size))
			panic(<span class="enscript-string">&quot;compressed data doesn't match original&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (c_rounded_size == PAGE_SIZE) {
			<span class="enscript-comment">/*
			 * page wasn't compressible... just copy it out
			 */</span>
			memcpy(dst, &amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset], PAGE_SIZE);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_size == 4) {
			int32_t		data;
			int32_t		*dptr;

			<span class="enscript-comment">/*
			 * page was populated with a single value
			 * that didn't fit into our fast hash
			 * so we packed it in as a single non-compressed value
			 * that we need to populate the page with
			 */</span>
			dptr = (int32_t *)(uintptr_t)dst;
			data = *(int32_t *)(&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset]);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
			memset_word(dptr, data, PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(int32_t));
#<span class="enscript-reference">else</span>
			{
			<span class="enscript-type">int</span>		i;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(int32_t)); i++)
				*dptr++ = data;
			}
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			uint32_t	my_cpu_no;
			<span class="enscript-type">char</span>		*scratch_buf;

			<span class="enscript-keyword">if</span> (!kdp_mode) {
				<span class="enscript-comment">/*
				 * we're behind the c_seg lock held in spin mode
				 * which means pre-emption is disabled... therefore
				 * the following sequence is atomic and safe
				 */</span>
				my_cpu_no = cpu_number();

				assert(my_cpu_no &lt; compressor_cpus);

				scratch_buf = &amp;compressor_scratch_bufs[my_cpu_no * WKdm_SCRATCH_BUF_SIZE];
			} <span class="enscript-keyword">else</span> {
				scratch_buf = kdp_compressor_scratch_buf;
			}
			WKdm_decompress_new((WK_word *)(uintptr_t)&amp;c_seg-&gt;c_store.c_buffer[cs-&gt;c_offset],
					    (WK_word *)(uintptr_t)dst, (WK_word *)(uintptr_t)scratch_buf, c_size);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_DATA</span>
		<span class="enscript-keyword">if</span> (cs-&gt;c_hash_data != hash_string(dst, PAGE_SIZE))
			panic(<span class="enscript-string">&quot;decompressed data doesn't match original&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_swappedin_ts == 0 &amp;&amp; !kdp_mode) {

			clock_get_system_nanotime(&amp;cur_ts_sec, &amp;cur_ts_nsec);

			age_of_cseg = (uint32_t)cur_ts_sec - c_seg-&gt;c_creation_ts;

			<span class="enscript-keyword">if</span> (age_of_cseg &lt; DECOMPRESSION_SAMPLE_MAX_AGE)
				OSAddAtomic(1, &amp;age_of_decompressions_during_sample_period[age_of_cseg]);
			<span class="enscript-keyword">else</span>
				OSAddAtomic(1, &amp;overage_decompressions_during_sample_period);

			OSAddAtomic(1, &amp;sample_period_decompression_count);
		}
	}
<span class="enscript-reference">c_seg_invalid_data</span>:

	<span class="enscript-keyword">if</span> (flags &amp; C_KEEP) {
		*zeroslot = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	assert(kdp_mode == FALSE);
	c_seg-&gt;c_bytes_unused += c_rounded_size;
	c_seg-&gt;c_bytes_used -= c_rounded_size;
	PACK_C_SIZE(cs, 0);

	<span class="enscript-keyword">if</span> (c_indx &lt; c_seg-&gt;c_firstemptyslot)
		c_seg-&gt;c_firstemptyslot = c_indx;

	OSAddAtomic(-1, &amp;c_segment_pages_compressed);

	<span class="enscript-keyword">if</span> (c_seg-&gt;c_state != C_ON_BAD_Q &amp;&amp; !(C_SEG_IS_ONDISK(c_seg))) {
		<span class="enscript-comment">/*
		 * C_SEG_IS_ONDISK == TRUE can occur when we're doing a
		 * free of a compressed page (i.e. dst == NULL)
		 */</span>
		OSAddAtomic64(-c_rounded_size, &amp;compressor_bytes_used);
	}
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_state != C_IS_FILLING) {
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used == 0) {
			<span class="enscript-keyword">if</span> ( !(C_SEG_IS_ONDISK(c_seg))) {
				<span class="enscript-type">int</span>	pages_populated;

				pages_populated = (round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset))) / PAGE_SIZE;
				c_seg-&gt;c_populated_offset = C_SEG_BYTES_TO_OFFSET(0);

				<span class="enscript-keyword">if</span> (pages_populated) {

					assert(c_seg-&gt;c_state != C_ON_BAD_Q);
					assert(c_seg-&gt;c_store.c_buffer != NULL);

					C_SEG_BUSY(c_seg);
					lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

					kernel_memory_depopulate(kernel_map, (vm_offset_t) c_seg-&gt;c_store.c_buffer, pages_populated * PAGE_SIZE, KMA_COMPRESSOR);

					lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
					C_SEG_WAKEUP_DONE(c_seg);
				}
				<span class="enscript-keyword">if</span> (!c_seg-&gt;c_on_minorcompact_q)
					c_seg_need_delayed_compaction(c_seg);
			} <span class="enscript-keyword">else</span>
				assert(c_seg-&gt;c_state == C_ON_SWAPPEDOUTSPARSE_Q);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_seg-&gt;c_on_minorcompact_q) {

			assert(c_seg-&gt;c_state != C_ON_BAD_Q);

			<span class="enscript-keyword">if</span> (C_SEG_SHOULD_MINORCOMPACT(c_seg)) {
				c_seg_try_minor_compaction_and_unlock(c_seg);
				need_unlock = FALSE;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( !(C_SEG_IS_ONDISK(c_seg))) {

			<span class="enscript-keyword">if</span> (c_seg-&gt;c_state != C_ON_BAD_Q &amp;&amp; c_seg-&gt;c_state != C_ON_SWAPOUT_Q &amp;&amp; C_SEG_UNUSED_BYTES(c_seg) &gt;= PAGE_SIZE) {
				c_seg_need_delayed_compaction(c_seg);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_seg-&gt;c_state != C_ON_SWAPPEDOUTSPARSE_Q &amp;&amp; C_SEG_ONDISK_IS_SPARSE(c_seg)) {

			c_seg_move_to_sparse_list(c_seg);
			consider_defragmenting = TRUE;
		}
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (kdp_mode) {
		<span class="enscript-keyword">return</span> retval;
	}

	<span class="enscript-keyword">if</span> (need_unlock == TRUE)
		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

	PAGE_REPLACEMENT_DISALLOWED(FALSE);

	<span class="enscript-keyword">if</span> (consider_defragmenting == TRUE)
		vm_swap_consider_defragmenting();


	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_compressor_get</span>(ppnum_t pn, <span class="enscript-type">int</span> *slot, <span class="enscript-type">int</span> flags)
{
	c_slot_mapping_t  slot_ptr;
	<span class="enscript-type">char</span>	*dst;
	<span class="enscript-type">int</span>	zeroslot = 1;
	<span class="enscript-type">int</span>	retval;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
	dst = PHYSMAP_PTOV((uint64_t)pn &lt;&lt; (uint64_t)PAGE_SHIFT);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;unsupported architecture&quot;</span>
#<span class="enscript-reference">endif</span>
	slot_ptr = (c_slot_mapping_t)slot;

	<span class="enscript-keyword">if</span> (slot_ptr-&gt;s_cseg == C_SV_CSEG_ID) {
		int32_t		data;
		int32_t		*dptr;

		<span class="enscript-comment">/*
		 * page was populated with a single value
		 * that found a home in our hash table
		 * grab that value from the hash and populate the page
		 * that we need to populate the page with
		 */</span>
		dptr = (int32_t *)(uintptr_t)dst;
		data = c_segment_sv_hash_table[slot_ptr-&gt;s_cindx].he_data;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
		memset_word(dptr, data, PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(int32_t));
#<span class="enscript-reference">else</span>
		{
		<span class="enscript-type">int</span>		i;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(int32_t)); i++)
			*dptr++ = data;
		}
#<span class="enscript-reference">endif</span>
		c_segment_sv_hash_drop_ref(slot_ptr-&gt;s_cindx);

		<span class="enscript-keyword">if</span> ( !(flags &amp; C_KEEP)) {
			OSAddAtomic(-1, &amp;c_segment_pages_compressed);
			*slot = 0;
		}
		<span class="enscript-keyword">if</span> (data)
			OSAddAtomic(1, &amp;c_segment_svp_nonzero_decompressions);
		<span class="enscript-keyword">else</span>
			OSAddAtomic(1, &amp;c_segment_svp_zero_decompressions);

		<span class="enscript-keyword">return</span> (0);
	}

	retval = c_decompress_page(dst, slot_ptr, flags, &amp;zeroslot);

	<span class="enscript-comment">/*
	 * zeroslot will be set to 0 by c_decompress_page if (flags &amp; C_KEEP)
	 * or (flags &amp; C_DONT_BLOCK) and we found 'c_busy' or 'C_SEG_IS_ONDISK' to be TRUE
	 */</span>
	<span class="enscript-keyword">if</span> (zeroslot) {
		*slot = 0;
	}
	<span class="enscript-comment">/*
	 * returns 0 if we successfully decompressed a page from a segment already in memory
	 * returns 1 if we had to first swap in the segment, before successfully decompressing the page
	 * returns -1 if we encountered an error swapping in the segment - decompression failed
	 * returns -2 if (flags &amp; C_DONT_BLOCK) and we found 'c_busy' or 'C_SEG_IS_ONDISK' to be true
	 */</span>
	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_compressor_free</span>(<span class="enscript-type">int</span> *slot, <span class="enscript-type">int</span> flags)
{
	c_slot_mapping_t  slot_ptr;
	<span class="enscript-type">int</span>	zeroslot = 1;
	<span class="enscript-type">int</span>	retval;

	assert(flags == 0 || flags == C_DONT_BLOCK);

	slot_ptr = (c_slot_mapping_t)slot;

	<span class="enscript-keyword">if</span> (slot_ptr-&gt;s_cseg == C_SV_CSEG_ID) {

		c_segment_sv_hash_drop_ref(slot_ptr-&gt;s_cindx);
		OSAddAtomic(-1, &amp;c_segment_pages_compressed);

		*slot = 0;
		<span class="enscript-keyword">return</span> (0);
	}
	retval = c_decompress_page(NULL, slot_ptr, flags, &amp;zeroslot);
	<span class="enscript-comment">/*
	 * returns 0 if we successfully freed the specified compressed page
	 * returns -2 if (flags &amp; C_DONT_BLOCK) and we found 'c_busy' set
	 */</span>

	<span class="enscript-keyword">if</span> (retval == 0)
		*slot = 0;
	<span class="enscript-keyword">else</span>
		assert(retval == -2);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_compressor_put</span>(ppnum_t pn, <span class="enscript-type">int</span> *slot, <span class="enscript-type">void</span>  **current_chead, <span class="enscript-type">char</span> *scratch_buf)
{
	<span class="enscript-type">char</span>	*src;
	<span class="enscript-type">int</span>	retval;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
	src = PHYSMAP_PTOV((uint64_t)pn &lt;&lt; (uint64_t)PAGE_SHIFT);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;unsupported architecture&quot;</span>
#<span class="enscript-reference">endif</span>
	retval = c_compress_page(src, (c_slot_mapping_t)slot, (c_segment_t *)current_chead, scratch_buf);

	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_transfer</span>(
	<span class="enscript-type">int</span>	*dst_slot_p,
	<span class="enscript-type">int</span>	*src_slot_p)
{
	c_slot_mapping_t	dst_slot, src_slot;
	c_segment_t		c_seg;
	<span class="enscript-type">int</span>			c_indx;
	c_slot_t		cs;

	src_slot = (c_slot_mapping_t) src_slot_p;

	<span class="enscript-keyword">if</span> (src_slot-&gt;s_cseg == C_SV_CSEG_ID) {
		*dst_slot_p = *src_slot_p;
		*src_slot_p = 0;
		<span class="enscript-keyword">return</span>;
	}
	dst_slot = (c_slot_mapping_t) dst_slot_p;
<span class="enscript-reference">Retry</span>:
	PAGE_REPLACEMENT_DISALLOWED(TRUE);
	<span class="enscript-comment">/* get segment for src_slot */</span>
	c_seg = c_segments[src_slot-&gt;s_cseg -1].c_seg;
	<span class="enscript-comment">/* lock segment */</span>
	lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
	<span class="enscript-comment">/* wait if it's busy */</span>
	<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy &amp;&amp; !c_seg-&gt;c_busy_swapping) {
		PAGE_REPLACEMENT_DISALLOWED(FALSE);
		c_seg_wait_on_busy(c_seg);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
	}
	<span class="enscript-comment">/* find the c_slot */</span>
	c_indx = src_slot-&gt;s_cindx;
	cs = C_SEG_SLOT_FROM_INDEX(c_seg, c_indx);
	<span class="enscript-comment">/* point the c_slot back to dst_slot instead of src_slot */</span>
	cs-&gt;c_packed_ptr = C_SLOT_PACK_PTR(dst_slot);
	<span class="enscript-comment">/* transfer */</span>
	*dst_slot_p = *src_slot_p;
	*src_slot_p = 0;
	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
	PAGE_REPLACEMENT_DISALLOWED(FALSE);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

<span class="enscript-type">int</span>	freezer_finished_filling = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_finished_filling</span>(
	<span class="enscript-type">void</span>	**current_chead)
{
	c_segment_t	c_seg;

	<span class="enscript-keyword">if</span> ((c_seg = *(c_segment_t *)current_chead) == NULL)
		<span class="enscript-keyword">return</span>;

	assert(c_seg-&gt;c_state == C_IS_FILLING);
	
	lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

	c_current_seg_filled(c_seg, (c_segment_t *)current_chead);

	lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

	freezer_finished_filling++;
}


<span class="enscript-comment">/*
 * This routine is used to transfer the compressed chunks from
 * the c_seg/cindx pointed to by slot_p into a new c_seg headed
 * by the current_chead and a new cindx within that c_seg.
 *
 * Currently, this routine is only used by the &quot;freezer backed by
 * compressor with swap&quot; mode to create a series of c_segs that
 * only contain compressed data belonging to one task. So, we 
 * move a task's previously compressed data into a set of new
 * c_segs which will also hold the task's yet to be compressed data.
 */</span>

kern_return_t
<span class="enscript-function-name">vm_compressor_relocate</span>(
	<span class="enscript-type">void</span>		**current_chead,
	<span class="enscript-type">int</span>		*slot_p)
{
	c_slot_mapping_t 	slot_ptr;
	c_slot_mapping_t	src_slot;
	uint32_t		c_rounded_size;
	uint32_t		c_size;
	uint16_t		dst_slot;
	c_slot_t		c_dst;
	c_slot_t		c_src;
	<span class="enscript-type">int</span>			c_indx;
	c_segment_t		c_seg_dst = NULL;
	c_segment_t		c_seg_src = NULL;
	kern_return_t		kr = KERN_SUCCESS;


	src_slot = (c_slot_mapping_t) slot_p;

	<span class="enscript-keyword">if</span> (src_slot-&gt;s_cseg == C_SV_CSEG_ID) {
		<span class="enscript-comment">/*
		 * no need to relocate... this is a page full of a single
		 * value which is hashed to a single entry not contained
		 * in a c_segment_t
		 */</span>
		<span class="enscript-keyword">return</span> (kr);
	}

<span class="enscript-reference">Relookup_dst</span>:
	c_seg_dst = c_seg_allocate((c_segment_t *)current_chead);
	<span class="enscript-comment">/*
	 * returns with c_seg lock held
	 * and PAGE_REPLACEMENT_DISALLOWED(TRUE)...
	 * c_nextslot has been allocated and
	 * c_store.c_buffer populated
	 */</span>
	<span class="enscript-keyword">if</span> (c_seg_dst == NULL) {
		<span class="enscript-comment">/*
		 * Out of compression segments?
		 */</span>
		kr = KERN_RESOURCE_SHORTAGE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	assert(c_seg_dst-&gt;c_busy == 0);

	C_SEG_BUSY(c_seg_dst);

	dst_slot = c_seg_dst-&gt;c_nextslot;
	
	lck_mtx_unlock_always(&amp;c_seg_dst-&gt;c_lock);

<span class="enscript-reference">Relookup_src</span>:
	c_seg_src = c_segments[src_slot-&gt;s_cseg - 1].c_seg;

	assert(c_seg_dst != c_seg_src);

	lck_mtx_lock_spin_always(&amp;c_seg_src-&gt;c_lock);

	<span class="enscript-keyword">if</span> (C_SEG_IS_ONDISK(c_seg_src)) {
	
		<span class="enscript-comment">/*
		 * A &quot;thaw&quot; can mark a process as eligible for
		 * another freeze cycle without bringing any of
		 * its swapped out c_segs back from disk (because
		 * that is done on-demand).
		 *
		 * If the src c_seg we find for our pre-compressed
		 * data is already on-disk, then we are dealing
		 * with an app's data that is already packed and
		 * swapped out. Don't do anything.
		 */</span>
		
		PAGE_REPLACEMENT_DISALLOWED(FALSE);

		lck_mtx_unlock_always(&amp;c_seg_src-&gt;c_lock);

		c_seg_src = NULL;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (c_seg_src-&gt;c_busy) {

		PAGE_REPLACEMENT_DISALLOWED(FALSE);
		c_seg_wait_on_busy(c_seg_src);
			
		c_seg_src = NULL;

		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Relookup_src</span>;
	}

	C_SEG_BUSY(c_seg_src);

	lck_mtx_unlock_always(&amp;c_seg_src-&gt;c_lock);
	
	PAGE_REPLACEMENT_DISALLOWED(FALSE);

	<span class="enscript-comment">/* find the c_slot */</span>
	c_indx = src_slot-&gt;s_cindx;

	c_src = C_SEG_SLOT_FROM_INDEX(c_seg_src, c_indx);

	c_size = UNPACK_C_SIZE(c_src);

	assert(c_size);

	<span class="enscript-keyword">if</span> (c_size &gt; (uint32_t)(C_SEG_BUFSIZE - C_SEG_OFFSET_TO_BYTES((int32_t)c_seg_dst-&gt;c_nextoffset))) {
		<span class="enscript-comment">/*
		 * This segment is full. We need a new one.
		 */</span>

		PAGE_REPLACEMENT_DISALLOWED(TRUE);
	
		lck_mtx_lock_spin_always(&amp;c_seg_src-&gt;c_lock);
		C_SEG_WAKEUP_DONE(c_seg_src);
		lck_mtx_unlock_always(&amp;c_seg_src-&gt;c_lock);

		c_seg_src = NULL;

		lck_mtx_lock_spin_always(&amp;c_seg_dst-&gt;c_lock);

		assert(c_seg_dst-&gt;c_busy);
		assert(c_seg_dst-&gt;c_state == C_IS_FILLING);
		assert(!c_seg_dst-&gt;c_on_minorcompact_q);

		c_current_seg_filled(c_seg_dst, (c_segment_t *)current_chead);
		assert(*current_chead == NULL);
	
		C_SEG_WAKEUP_DONE(c_seg_dst);
	
		lck_mtx_unlock_always(&amp;c_seg_dst-&gt;c_lock);

		c_seg_dst = NULL;

		PAGE_REPLACEMENT_DISALLOWED(FALSE);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Relookup_dst</span>;
	}

	c_dst = C_SEG_SLOT_FROM_INDEX(c_seg_dst, c_seg_dst-&gt;c_nextslot);

	memcpy(&amp;c_seg_dst-&gt;c_store.c_buffer[c_seg_dst-&gt;c_nextoffset], &amp;c_seg_src-&gt;c_store.c_buffer[c_src-&gt;c_offset], c_size);

	c_rounded_size = (c_size + C_SEG_OFFSET_ALIGNMENT_MASK) &amp; ~C_SEG_OFFSET_ALIGNMENT_MASK;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_DATA</span>
	c_dst-&gt;c_hash_data = c_src-&gt;c_hash_data;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_COMPRESSED_DATA</span>
	c_dst-&gt;c_hash_compressed_data = c_src-&gt;c_hash_compressed_data;
#<span class="enscript-reference">endif</span>

	c_dst-&gt;c_size = c_src-&gt;c_size;
	c_dst-&gt;c_packed_ptr = c_src-&gt;c_packed_ptr;
	c_dst-&gt;c_offset = c_seg_dst-&gt;c_nextoffset;

	<span class="enscript-keyword">if</span> (c_seg_dst-&gt;c_firstemptyslot == c_seg_dst-&gt;c_nextslot)
		c_seg_dst-&gt;c_firstemptyslot++;

	c_seg_dst-&gt;c_nextslot++;
	c_seg_dst-&gt;c_bytes_used += c_rounded_size;
	c_seg_dst-&gt;c_nextoffset += C_SEG_BYTES_TO_OFFSET(c_rounded_size);
		

	PACK_C_SIZE(c_src, 0);

	c_seg_src-&gt;c_bytes_used -= c_rounded_size;
	c_seg_src-&gt;c_bytes_unused += c_rounded_size;
	
	<span class="enscript-keyword">if</span> (c_indx &lt; c_seg_src-&gt;c_firstemptyslot) {
		c_seg_src-&gt;c_firstemptyslot = c_indx;
	}

	c_dst = C_SEG_SLOT_FROM_INDEX(c_seg_dst, dst_slot);
		
	PAGE_REPLACEMENT_ALLOWED(TRUE);
	slot_ptr = (c_slot_mapping_t)C_SLOT_UNPACK_PTR(c_dst);
	<span class="enscript-comment">/* &lt;csegno=0,indx=0&gt; would mean &quot;empty slot&quot;, so use csegno+1 */</span>
	slot_ptr-&gt;s_cseg = c_seg_dst-&gt;c_mysegno + 1;
	slot_ptr-&gt;s_cindx = dst_slot;

	PAGE_REPLACEMENT_ALLOWED(FALSE);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (c_seg_src) {

		lck_mtx_lock_spin_always(&amp;c_seg_src-&gt;c_lock);

		C_SEG_WAKEUP_DONE(c_seg_src);

		<span class="enscript-keyword">if</span> (c_seg_src-&gt;c_bytes_used == 0 &amp;&amp; c_seg_src-&gt;c_state != C_IS_FILLING) {
			<span class="enscript-keyword">if</span> (!c_seg_src-&gt;c_on_minorcompact_q)
				c_seg_need_delayed_compaction(c_seg_src);
		}

		lck_mtx_unlock_always(&amp;c_seg_src-&gt;c_lock);
	}
	
	<span class="enscript-keyword">if</span> (c_seg_dst) {

		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		lck_mtx_lock_spin_always(&amp;c_seg_dst-&gt;c_lock);

		<span class="enscript-keyword">if</span> (c_seg_dst-&gt;c_nextoffset &gt;= C_SEG_OFF_LIMIT || c_seg_dst-&gt;c_nextslot &gt;= C_SLOT_MAX_INDEX) {
			<span class="enscript-comment">/*
			 * Nearing or exceeded maximum slot and offset capacity.
			 */</span>
			assert(c_seg_dst-&gt;c_busy);
			assert(c_seg_dst-&gt;c_state == C_IS_FILLING);
			assert(!c_seg_dst-&gt;c_on_minorcompact_q);

			c_current_seg_filled(c_seg_dst, (c_segment_t *)current_chead);
			assert(*current_chead == NULL);
		}  
		
		C_SEG_WAKEUP_DONE(c_seg_dst);

		lck_mtx_unlock_always(&amp;c_seg_dst-&gt;c_lock);

		c_seg_dst = NULL;

		PAGE_REPLACEMENT_DISALLOWED(FALSE);
	}

	<span class="enscript-keyword">return</span> kr;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>
</pre>
<hr />
</body></html>