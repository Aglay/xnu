<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>bsd_vm.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">bsd_vm.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_traps.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/upl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_object_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_purgeable_internal.h&gt;</span>


<span class="enscript-comment">/* BSD VM COMPONENT INTERFACES */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_map_nentries</span>(
	vm_map_t);

vm_offset_t
<span class="enscript-function-name">get_map_start</span>(
	vm_map_t);

vm_offset_t
<span class="enscript-function-name">get_map_end</span>(
	vm_map_t);

<span class="enscript-comment">/*
 * 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_map_nentries</span>(
	vm_map_t map)
{
	<span class="enscript-keyword">return</span>(map-&gt;hdr.nentries);
}

mach_vm_offset_t
<span class="enscript-function-name">mach_get_vm_start</span>(vm_map_t map)
{
	<span class="enscript-keyword">return</span>( vm_map_first_entry(map)-&gt;vme_start);
}

mach_vm_offset_t
<span class="enscript-function-name">mach_get_vm_end</span>(vm_map_t map)
{
	<span class="enscript-keyword">return</span>( vm_map_last_entry(map)-&gt;vme_end);
}

<span class="enscript-comment">/* 
 * BSD VNODE PAGER 
 */</span>

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> memory_object_pager_ops vnode_pager_ops = {
	vnode_pager_reference,
	vnode_pager_deallocate,
	vnode_pager_init,
	vnode_pager_terminate,
	vnode_pager_data_request,
	vnode_pager_data_return,
	vnode_pager_data_initialize,
	vnode_pager_data_unlock,
	vnode_pager_synchronize,
	vnode_pager_map,
	vnode_pager_last_unmap,
	NULL, <span class="enscript-comment">/* data_reclaim */</span>
	<span class="enscript-string">&quot;vnode pager&quot;</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vnode_pager {
	<span class="enscript-type">struct</span> ipc_object_header	pager_header;	<span class="enscript-comment">/* fake ip_kotype()		*/</span>
	memory_object_pager_ops_t pager_ops;	<span class="enscript-comment">/* == &amp;vnode_pager_ops	     */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		ref_count;	<span class="enscript-comment">/* reference count	     */</span>
	memory_object_control_t control_handle;	<span class="enscript-comment">/* mem object control handle */</span>
	<span class="enscript-type">struct</span> vnode		*vnode_handle;	<span class="enscript-comment">/* vnode handle 	     */</span>
} *vnode_pager_t;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">pager_ikot</span> pager_header.io_bits

ipc_port_t
<span class="enscript-function-name">trigger_name_to_port</span>(			<span class="enscript-comment">/* forward */</span>
	mach_port_t);

kern_return_t
<span class="enscript-function-name">vnode_pager_cluster_read</span>(		<span class="enscript-comment">/* forward */</span>
	vnode_pager_t, 
	vm_object_offset_t,
	vm_object_offset_t,
	uint32_t,
	vm_size_t);

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_cluster_write</span>(		<span class="enscript-comment">/* forward */</span>
	vnode_pager_t,
	vm_object_offset_t,
	vm_size_t,
	vm_object_offset_t *,
	<span class="enscript-type">int</span> *,
	<span class="enscript-type">int</span>);


vnode_pager_t
<span class="enscript-function-name">vnode_object_create</span>(			<span class="enscript-comment">/* forward */</span>
	<span class="enscript-type">struct</span> vnode *);

vnode_pager_t
<span class="enscript-function-name">vnode_pager_lookup</span>(			<span class="enscript-comment">/* forward */</span>
	memory_object_t);

zone_t	vnode_pager_zone;


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_PAGER_NULL</span>	((vnode_pager_t) 0)

<span class="enscript-comment">/* TODO: Should be set dynamically by vnode_pager_init() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUSTER_SHIFT</span> 	1

<span class="enscript-comment">/* TODO: Should be set dynamically by vnode_pager_bootstrap() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_VNODE</span>		10000


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">int</span> pagerdebug=0;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAGER_ALL</span>		0xffffffff
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PAGER_INIT</span>		0x00000001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PAGER_PAGEIN</span>	0x00000002

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGER_DEBUG</span>(LEVEL, A) {if ((pagerdebug &amp; LEVEL)==LEVEL){printf A;}}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGER_DEBUG</span>(LEVEL, A)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_resetpcontrol</span>(<span class="enscript-type">int</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_cs_validated_resets;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Routine:	mach_macx_triggers
 *	Function:
 *		Syscall interface to set the call backs for low and
 *		high water marks.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mach_macx_triggers</span>(
	<span class="enscript-type">struct</span> macx_triggers_args *args)
{
	<span class="enscript-type">int</span>	hi_water = args-&gt;hi_water;
	<span class="enscript-type">int</span>	low_water = args-&gt;low_water;
	<span class="enscript-type">int</span>	flags = args-&gt;flags;
	mach_port_t	trigger_name = args-&gt;alert_port;
	kern_return_t kr;
	memory_object_default_t	default_pager;
	ipc_port_t		trigger_port;

	default_pager = MEMORY_OBJECT_DEFAULT_NULL;
	kr = host_default_memory_manager(host_priv_self(), 
					&amp;default_pager, 0);
	<span class="enscript-keyword">if</span>(kr != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (((flags &amp; SWAP_ENCRYPT_ON) &amp;&amp; (flags &amp; SWAP_ENCRYPT_OFF)) || 
	    ((flags &amp; SWAP_COMPACT_ENABLE) &amp;&amp; (flags &amp; SWAP_COMPACT_DISABLE))) {
		<span class="enscript-comment">/* can't have it both ways */</span>
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (default_pager_init_flag == 0) {
               start_def_pager(NULL);
               default_pager_init_flag = 1;
	}

	<span class="enscript-keyword">if</span> (flags &amp; SWAP_ENCRYPT_ON) {
		<span class="enscript-comment">/* ENCRYPTED SWAP: tell default_pager to encrypt */</span>
		default_pager_triggers(default_pager,
				       0, 0,
				       SWAP_ENCRYPT_ON,
				       IP_NULL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; SWAP_ENCRYPT_OFF) {
		<span class="enscript-comment">/* ENCRYPTED SWAP: tell default_pager not to encrypt */</span>
		default_pager_triggers(default_pager,
				       0, 0,
				       SWAP_ENCRYPT_OFF,
				       IP_NULL);
	}

	<span class="enscript-keyword">if</span> (flags &amp; USE_EMERGENCY_SWAP_FILE_FIRST) {
		<span class="enscript-comment">/*
		 * Time to switch to the emergency segment.
		 */</span>
		<span class="enscript-keyword">return</span> default_pager_triggers(default_pager,
					0, 0, 
					USE_EMERGENCY_SWAP_FILE_FIRST,
					IP_NULL);
	}

	<span class="enscript-keyword">if</span> (flags &amp; SWAP_FILE_CREATION_ERROR) {
		<span class="enscript-comment">/* 
		 * For some reason, the dynamic pager failed to create a swap file.
	 	 */</span>
		trigger_port = trigger_name_to_port(trigger_name);
		<span class="enscript-keyword">if</span>(trigger_port == NULL) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">/* trigger_port is locked and active */</span>
		ipc_port_make_send_locked(trigger_port); 
		ip_unlock(trigger_port);
		default_pager_triggers(default_pager,
					0, 0, 
					SWAP_FILE_CREATION_ERROR,
					trigger_port);
	}

	<span class="enscript-keyword">if</span> (flags &amp; HI_WAT_ALERT) {
		trigger_port = trigger_name_to_port(trigger_name);
		<span class="enscript-keyword">if</span>(trigger_port == NULL) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">/* trigger_port is locked and active */</span>
		ipc_port_make_send_locked(trigger_port); 
		ip_unlock(trigger_port);
		default_pager_triggers(default_pager, 
				       hi_water, low_water,
				       HI_WAT_ALERT, trigger_port);
	}

	<span class="enscript-keyword">if</span> (flags &amp; LO_WAT_ALERT) {
		trigger_port = trigger_name_to_port(trigger_name);
		<span class="enscript-keyword">if</span>(trigger_port == NULL) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">/* trigger_port is locked and active */</span>
		ipc_port_make_send_locked(trigger_port);
		ip_unlock(trigger_port);
		default_pager_triggers(default_pager, 
				       hi_water, low_water,
				       LO_WAT_ALERT, trigger_port);
	}


	<span class="enscript-keyword">if</span> (flags &amp; PROC_RESUME) {

		<span class="enscript-comment">/*
		 * For this call, hi_water is used to pass in the pid of the process we want to resume
		 * or unthrottle.  This is of course restricted to the superuser (checked inside of 
		 * proc_resetpcontrol).
		 */</span>

		<span class="enscript-keyword">return</span> proc_resetpcontrol(hi_water);
	}

	<span class="enscript-comment">/*
	 * Set thread scheduling priority and policy for the current thread
	 * it is assumed for the time being that the thread setting the alert
	 * is the same one which will be servicing it.
	 *
	 * XXX This does not belong in the kernel XXX
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; HI_WAT_ALERT) {
		thread_precedence_policy_data_t		pre;
		thread_extended_policy_data_t		ext;

		ext.timeshare = FALSE;
		pre.importance = INT32_MAX;

		thread_policy_set(current_thread(),
				  THREAD_EXTENDED_POLICY,
				  (thread_policy_t)&amp;ext,
				  THREAD_EXTENDED_POLICY_COUNT);

		thread_policy_set(current_thread(),
				  THREAD_PRECEDENCE_POLICY,
				  (thread_policy_t)&amp;pre,
				  THREAD_PRECEDENCE_POLICY_COUNT);

		current_thread()-&gt;options |= TH_OPT_VMPRIV;
	}
 
	<span class="enscript-keyword">if</span> (flags &amp; (SWAP_COMPACT_DISABLE | SWAP_COMPACT_ENABLE)) {
		<span class="enscript-keyword">return</span> macx_backing_store_compaction(flags &amp; (SWAP_COMPACT_DISABLE | SWAP_COMPACT_ENABLE));
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 *
 */</span>
ipc_port_t
<span class="enscript-function-name">trigger_name_to_port</span>(
	mach_port_t	trigger_name)
{
	ipc_port_t	trigger_port;
	ipc_space_t	space;

	<span class="enscript-keyword">if</span> (trigger_name == 0)
		<span class="enscript-keyword">return</span> (NULL);

	space  = current_space();
	<span class="enscript-keyword">if</span>(ipc_port_translate_receive(space, CAST_MACH_PORT_TO_NAME(trigger_name), 
						&amp;trigger_port) != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">return</span> trigger_port;
}


<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	uiomove64(addr64_t, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_RUN</span>	32

<span class="enscript-type">int</span>
<span class="enscript-function-name">memory_object_control_uiomove</span>(
	memory_object_control_t	control,
	memory_object_offset_t	offset,
	<span class="enscript-type">void</span>		*	uio,
	<span class="enscript-type">int</span>			start_offset,
	<span class="enscript-type">int</span>			io_requested,
	<span class="enscript-type">int</span>			mark_dirty,
	<span class="enscript-type">int</span>			take_reference)
{
	vm_object_t		object;
	vm_page_t		dst_page;
	<span class="enscript-type">int</span>			xsize;
	<span class="enscript-type">int</span>			retval = 0;
	<span class="enscript-type">int</span>			cur_run;
	<span class="enscript-type">int</span>			cur_needed;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			orig_offset;
	vm_page_t		page_run[MAX_RUN];

	object = memory_object_control_to_vm_object(control);
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span> (0);
	}
	assert(!object-&gt;internal);

	vm_object_lock(object);

	<span class="enscript-keyword">if</span> (mark_dirty &amp;&amp; object-&gt;copy != VM_OBJECT_NULL) {
		<span class="enscript-comment">/*
		 * We can't modify the pages without honoring
		 * copy-on-write obligations first, so fall off
		 * this optimized path and fall back to the regular
		 * path.
		 */</span>
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span> 0;
	}
	orig_offset = start_offset;
	    
	<span class="enscript-keyword">while</span> (io_requested &amp;&amp; retval == 0) {

		cur_needed = (start_offset + io_requested + (PAGE_SIZE - 1)) / PAGE_SIZE;

		<span class="enscript-keyword">if</span> (cur_needed &gt; MAX_RUN)
		        cur_needed = MAX_RUN;

		<span class="enscript-keyword">for</span> (cur_run = 0; cur_run &lt; cur_needed; ) {

		        <span class="enscript-keyword">if</span> ((dst_page = vm_page_lookup(object, offset)) == VM_PAGE_NULL)
			        <span class="enscript-keyword">break</span>;


			<span class="enscript-keyword">if</span> (dst_page-&gt;busy || dst_page-&gt;cleaning) {
				<span class="enscript-comment">/*
				 * someone else is playing with the page... if we've
				 * already collected pages into this run, go ahead
				 * and process now, we can't block on this
				 * page while holding other pages in the BUSY state
				 * otherwise we will wait
				 */</span>
				<span class="enscript-keyword">if</span> (cur_run)
					<span class="enscript-keyword">break</span>;
				PAGE_SLEEP(object, dst_page, THREAD_UNINT);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (dst_page-&gt;laundry) {
				dst_page-&gt;pageout = FALSE;
				
				vm_pageout_steal_laundry(dst_page, FALSE);
			}
			<span class="enscript-comment">/*
			 * this routine is only called when copying
			 * to/from real files... no need to consider
			 * encrypted swap pages
			 */</span>
			assert(!dst_page-&gt;encrypted);

		        <span class="enscript-keyword">if</span> (mark_dirty) {
				SET_PAGE_DIRTY(dst_page, FALSE);
				<span class="enscript-keyword">if</span> (dst_page-&gt;cs_validated &amp;&amp; 
				    !dst_page-&gt;cs_tainted) {
					<span class="enscript-comment">/*
					 * CODE SIGNING:
					 * We're modifying a code-signed
					 * page: force revalidate
					 */</span>
					dst_page-&gt;cs_validated = FALSE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
                                        vm_cs_validated_resets++;
#<span class="enscript-reference">endif</span>
					pmap_disconnect(dst_page-&gt;phys_page);
				}
			}
			dst_page-&gt;busy = TRUE;

			page_run[cur_run++] = dst_page;

			offset += PAGE_SIZE_64;
		}
		<span class="enscript-keyword">if</span> (cur_run == 0)
		        <span class="enscript-comment">/*
			 * we hit a 'hole' in the cache or
			 * a page we don't want to try to handle,
			 * so bail at this point
			 * we'll unlock the object below
			 */</span>
		        <span class="enscript-keyword">break</span>;
		vm_object_unlock(object);

		<span class="enscript-keyword">for</span> (i = 0; i &lt; cur_run; i++) {
		  
		        dst_page = page_run[i];

			<span class="enscript-keyword">if</span> ((xsize = PAGE_SIZE - start_offset) &gt; io_requested)
			        xsize = io_requested;

			<span class="enscript-keyword">if</span> ( (retval = uiomove64((addr64_t)(((addr64_t)(dst_page-&gt;phys_page) &lt;&lt; PAGE_SHIFT) + start_offset), xsize, uio)) )
			        <span class="enscript-keyword">break</span>;

			io_requested -= xsize;
			start_offset = 0;
		}
		vm_object_lock(object);

		<span class="enscript-comment">/*
		 * if we have more than 1 page to work on
		 * in the current run, or the original request
		 * started at offset 0 of the page, or we're
		 * processing multiple batches, we will move
		 * the pages to the tail of the inactive queue
		 * to implement an LRU for read/write accesses
		 *
		 * the check for orig_offset == 0 is there to 
		 * mitigate the cost of small (&lt; page_size) requests
		 * to the same page (this way we only move it once)
		 */</span>
		<span class="enscript-keyword">if</span> (take_reference &amp;&amp; (cur_run &gt; 1 || orig_offset == 0)) {

			vm_page_lockspin_queues();

			<span class="enscript-keyword">for</span> (i = 0; i &lt; cur_run; i++)
				vm_page_lru(page_run[i]);

			vm_page_unlock_queues();
		}
		<span class="enscript-keyword">for</span> (i = 0; i &lt; cur_run; i++) {
		        dst_page = page_run[i];

			<span class="enscript-comment">/*
			 * someone is explicitly referencing this page...
			 * update clustered and speculative state
			 * 
			 */</span>
			<span class="enscript-keyword">if</span> (dst_page-&gt;clustered)
				VM_PAGE_CONSUME_CLUSTERED(dst_page);

			PAGE_WAKEUP_DONE(dst_page);
		}
		orig_offset = 0;
	}
	vm_object_unlock(object);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_bootstrap</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">register</span> vm_size_t      size;

	size = (vm_size_t) <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_pager);
	vnode_pager_zone = zinit(size, (vm_size_t) MAX_VNODE*size,
				PAGE_SIZE, <span class="enscript-string">&quot;vnode pager structures&quot;</span>);
	zone_change(vnode_pager_zone, Z_CALLERACCT, FALSE);
	zone_change(vnode_pager_zone, Z_NOENCRYPT, TRUE);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_CODE_DECRYPTION</span>
	apple_protect_pager_bootstrap();
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_CODE_DECRYPTION */</span>
	swapfile_pager_bootstrap();
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *
 */</span>
memory_object_t
<span class="enscript-function-name">vnode_pager_setup</span>(
	<span class="enscript-type">struct</span> vnode	*vp,
	__unused memory_object_t	pager)
{
	vnode_pager_t	vnode_object;

	vnode_object = vnode_object_create(vp);
	<span class="enscript-keyword">if</span> (vnode_object == VNODE_PAGER_NULL)
		panic(<span class="enscript-string">&quot;vnode_pager_setup: vnode_object_create() failed&quot;</span>);
	<span class="enscript-keyword">return</span>((memory_object_t)vnode_object);
}

<span class="enscript-comment">/*
 *
 */</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_init</span>(memory_object_t mem_obj, 
		memory_object_control_t control, 
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DEBUG</span>
		 __unused
#<span class="enscript-reference">endif</span>
		 memory_object_cluster_size_t pg_size)
{
	vnode_pager_t   vnode_object;
	kern_return_t   kr;
	memory_object_attr_info_data_t  attributes;


	PAGER_DEBUG(PAGER_ALL, (<span class="enscript-string">&quot;vnode_pager_init: %p, %p, %lx\n&quot;</span>, mem_obj, control, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)pg_size));

	<span class="enscript-keyword">if</span> (control == MEMORY_OBJECT_CONTROL_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	vnode_object = vnode_pager_lookup(mem_obj);

	memory_object_control_reference(control);

	vnode_object-&gt;control_handle = control;

	attributes.copy_strategy = MEMORY_OBJECT_COPY_DELAY;
	<span class="enscript-comment">/* attributes.cluster_size = (1 &lt;&lt; (CLUSTER_SHIFT + PAGE_SHIFT));*/</span>
	attributes.cluster_size = (1 &lt;&lt; (PAGE_SHIFT));
	attributes.may_cache_object = TRUE;
	attributes.temporary = TRUE;

	kr = memory_object_change_attributes(
					control,
					MEMORY_OBJECT_ATTRIBUTE_INFO,
					(memory_object_info_t) &amp;attributes,
					MEMORY_OBJECT_ATTR_INFO_COUNT);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;vnode_pager_init: memory_object_change_attributes() failed&quot;</span>);

	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *
 */</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_data_return</span>(
        memory_object_t		mem_obj,
        memory_object_offset_t	offset,
        memory_object_cluster_size_t		data_cnt,
        memory_object_offset_t	*resid_offset,
	<span class="enscript-type">int</span>			*io_error,
	__unused boolean_t		dirty,
	__unused boolean_t		kernel_copy,
	<span class="enscript-type">int</span>			upl_flags)  
{
	<span class="enscript-type">register</span> vnode_pager_t	vnode_object;

	vnode_object = vnode_pager_lookup(mem_obj);

	vnode_pager_cluster_write(vnode_object, offset, data_cnt, resid_offset, io_error, upl_flags);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_data_initialize</span>(
	__unused memory_object_t		mem_obj,
	__unused memory_object_offset_t	offset,
	__unused memory_object_cluster_size_t		data_cnt)
{
	panic(<span class="enscript-string">&quot;vnode_pager_data_initialize&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_data_unlock</span>(
	__unused memory_object_t		mem_obj,
	__unused memory_object_offset_t	offset,
	__unused memory_object_size_t		size,
	__unused vm_prot_t		desired_access)
{
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_isinuse</span>(
	memory_object_t		mem_obj,
	uint32_t		*isinuse)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops) {
		*isinuse = 1;
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vnode_object = vnode_pager_lookup(mem_obj);

	*isinuse = vnode_pager_isinuse(vnode_object-&gt;vnode_handle);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_throttle_io_limit</span>(
	memory_object_t		mem_obj,
	uint32_t		*limit)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	vnode_object = vnode_pager_lookup(mem_obj);

	(<span class="enscript-type">void</span>)vnode_pager_return_throttle_io_limit(vnode_object-&gt;vnode_handle, limit);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_isSSD</span>(
	memory_object_t		mem_obj,
	boolean_t		*isSSD)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	vnode_object = vnode_pager_lookup(mem_obj);

	*isSSD = vnode_pager_isSSD(vnode_object-&gt;vnode_handle);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_object_size</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	*length)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops) {
		*length = 0;
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vnode_object = vnode_pager_lookup(mem_obj);

	*length = vnode_pager_get_filesize(vnode_object-&gt;vnode_handle);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_object_name</span>(
	memory_object_t		mem_obj,
	<span class="enscript-type">char</span>			*pathname,
	vm_size_t		pathname_len,
	<span class="enscript-type">char</span>			*filename,
	vm_size_t		filename_len,
	boolean_t		*truncated_path_p)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vnode_object = vnode_pager_lookup(mem_obj);

	<span class="enscript-keyword">return</span> vnode_pager_get_name(vnode_object-&gt;vnode_handle,
				    pathname,
				    pathname_len,
				    filename,
				    filename_len,
				    truncated_path_p);
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_object_mtime</span>(
	memory_object_t		mem_obj,
	<span class="enscript-type">struct</span> timespec		*mtime,
	<span class="enscript-type">struct</span> timespec		*cs_mtime)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vnode_object = vnode_pager_lookup(mem_obj);

	<span class="enscript-keyword">return</span> vnode_pager_get_mtime(vnode_object-&gt;vnode_handle,
				     mtime,
				     cs_mtime);
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_object_cs_blobs</span>(
	memory_object_t	mem_obj,
	<span class="enscript-type">void</span>		**blobs)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj == MEMORY_OBJECT_NULL ||
	    mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vnode_object = vnode_pager_lookup(mem_obj);

	<span class="enscript-keyword">return</span> vnode_pager_get_cs_blobs(vnode_object-&gt;vnode_handle,
					blobs);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECK_CS_VALIDATION_BITMAP</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_cs_check_validation_bitmap</span>( 
	memory_object_t	mem_obj, 
	memory_object_offset_t	offset,
        <span class="enscript-type">int</span>		optype	)
{
	vnode_pager_t	vnode_object;

	<span class="enscript-keyword">if</span> (mem_obj == MEMORY_OBJECT_NULL ||
	    mem_obj-&gt;mo_pager_ops != &amp;vnode_pager_ops) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	vnode_object = vnode_pager_lookup(mem_obj);
	<span class="enscript-keyword">return</span> ubc_cs_check_validation_bitmap( vnode_object-&gt;vnode_handle, offset, optype );
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CHECK_CS_VALIDATION_BITMAP */</span>

<span class="enscript-comment">/*
 *
 */</span>
kern_return_t	
<span class="enscript-function-name">vnode_pager_data_request</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	__unused memory_object_cluster_size_t	length,
	__unused vm_prot_t	desired_access,
	memory_object_fault_info_t	fault_info)
{
	vnode_pager_t		vnode_object;
	memory_object_offset_t	base_offset;
	vm_size_t		size;
	uint32_t		io_streaming = 0;

	vnode_object = vnode_pager_lookup(mem_obj);

	size = MAX_UPL_TRANSFER_BYTES;
	base_offset = offset;

	<span class="enscript-keyword">if</span> (memory_object_cluster_size(vnode_object-&gt;control_handle, &amp;base_offset, &amp;size, &amp;io_streaming, fault_info) != KERN_SUCCESS)
	        size = PAGE_SIZE;

	assert(offset &gt;= base_offset &amp;&amp;
	       offset &lt; base_offset + size);

	<span class="enscript-keyword">return</span> vnode_pager_cluster_read(vnode_object, base_offset, offset, io_streaming, size);
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_reference</span>(
	memory_object_t		mem_obj)
{	
	<span class="enscript-type">register</span> vnode_pager_t	vnode_object;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		new_ref_count;

	vnode_object = vnode_pager_lookup(mem_obj);
	new_ref_count = hw_atomic_add(&amp;vnode_object-&gt;ref_count, 1);
	assert(new_ref_count &gt; 1);
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_deallocate</span>(
	memory_object_t		mem_obj)
{
	<span class="enscript-type">register</span> vnode_pager_t	vnode_object;

	PAGER_DEBUG(PAGER_ALL, (<span class="enscript-string">&quot;vnode_pager_deallocate: %p\n&quot;</span>, mem_obj));

	vnode_object = vnode_pager_lookup(mem_obj);

	<span class="enscript-keyword">if</span> (hw_atomic_sub(&amp;vnode_object-&gt;ref_count, 1) == 0) {
		<span class="enscript-keyword">if</span> (vnode_object-&gt;vnode_handle != NULL) {
			vnode_pager_vrele(vnode_object-&gt;vnode_handle);
		}
		zfree(vnode_pager_zone, vnode_object);
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *
 */</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_terminate</span>(
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DEBUG</span>
	__unused
#<span class="enscript-reference">endif</span>
	memory_object_t	mem_obj)
{
	PAGER_DEBUG(PAGER_ALL, (<span class="enscript-string">&quot;vnode_pager_terminate: %p\n&quot;</span>, mem_obj));

	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *
 */</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_synchronize</span>(
	memory_object_t		mem_obj,
	memory_object_offset_t	offset,
	memory_object_size_t		length,
	__unused vm_sync_t		sync_flags)
{
	<span class="enscript-type">register</span> vnode_pager_t	vnode_object;

	PAGER_DEBUG(PAGER_ALL, (<span class="enscript-string">&quot;vnode_pager_synchronize: %p\n&quot;</span>, mem_obj));

	vnode_object = vnode_pager_lookup(mem_obj);

	memory_object_synchronize_completed(vnode_object-&gt;control_handle, offset, length);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *
 */</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_map</span>(
	memory_object_t		mem_obj,
	vm_prot_t		prot)
{
	vnode_pager_t		vnode_object;
	<span class="enscript-type">int</span>			ret;
	kern_return_t		kr;

	PAGER_DEBUG(PAGER_ALL, (<span class="enscript-string">&quot;vnode_pager_map: %p %x\n&quot;</span>, mem_obj, prot));

	vnode_object = vnode_pager_lookup(mem_obj);

	ret = ubc_map(vnode_object-&gt;vnode_handle, prot);

	<span class="enscript-keyword">if</span> (ret != 0) {
		kr = KERN_FAILURE;
	} <span class="enscript-keyword">else</span> {
		kr = KERN_SUCCESS;
	}

	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_last_unmap</span>(
	memory_object_t		mem_obj)
{
	<span class="enscript-type">register</span> vnode_pager_t	vnode_object;

	PAGER_DEBUG(PAGER_ALL, (<span class="enscript-string">&quot;vnode_pager_last_unmap: %p\n&quot;</span>, mem_obj));

	vnode_object = vnode_pager_lookup(mem_obj);

	ubc_unmap(vnode_object-&gt;vnode_handle);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}



<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_cluster_write</span>(
	vnode_pager_t		vnode_object,
	vm_object_offset_t	offset,
	vm_size_t		cnt,
	vm_object_offset_t   *	resid_offset,
	<span class="enscript-type">int</span>		     *  io_error,
	<span class="enscript-type">int</span>			upl_flags)
{
	vm_size_t	size;
	<span class="enscript-type">int</span>		errno;

	<span class="enscript-keyword">if</span> (upl_flags &amp; UPL_MSYNC) {

	        upl_flags |= UPL_VNODE_PAGER;

		<span class="enscript-keyword">if</span> ( (upl_flags &amp; UPL_IOSYNC) &amp;&amp; io_error)
		        upl_flags |= UPL_KEEPCACHED;

	        <span class="enscript-keyword">while</span> (cnt) {
			size = (cnt &lt; MAX_UPL_TRANSFER_BYTES) ? cnt : MAX_UPL_TRANSFER_BYTES; <span class="enscript-comment">/* effective max */</span>

			assert((upl_size_t) size == size);
			vnode_pageout(vnode_object-&gt;vnode_handle, 
				      NULL, (upl_offset_t)0, offset, (upl_size_t)size, upl_flags, &amp;errno);

			<span class="enscript-keyword">if</span> ( (upl_flags &amp; UPL_KEEPCACHED) ) {
			        <span class="enscript-keyword">if</span> ( (*io_error = errno) )
				        <span class="enscript-keyword">break</span>;
			}
			cnt    -= size;
			offset += size;
		}
		<span class="enscript-keyword">if</span> (resid_offset)
			*resid_offset = offset;

	} <span class="enscript-keyword">else</span> {
	        vm_object_offset_t      vnode_size;
	        vm_object_offset_t	base_offset;

	        <span class="enscript-comment">/*
		 * this is the pageout path
		 */</span>
		vnode_size = vnode_pager_get_filesize(vnode_object-&gt;vnode_handle);

		<span class="enscript-keyword">if</span> (vnode_size &gt; (offset + PAGE_SIZE)) {
		        <span class="enscript-comment">/*
			 * preset the maximum size of the cluster
			 * and put us on a nice cluster boundary...
			 * and then clip the size to insure we
			 * don't request past the end of the underlying file
			 */</span>
		        size = MAX_UPL_TRANSFER_BYTES;
		        base_offset = offset &amp; ~((<span class="enscript-type">signed</span>)(size - 1));

			<span class="enscript-keyword">if</span> ((base_offset + size) &gt; vnode_size)
			        size = round_page(((vm_size_t)(vnode_size - base_offset)));
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * we've been requested to page out a page beyond the current
			 * end of the 'file'... don't try to cluster in this case...
			 * we still need to send this page through because it might
			 * be marked precious and the underlying filesystem may need
			 * to do something with it (besides page it out)...
			 */</span>
		        base_offset = offset;
			size = PAGE_SIZE;
		}
		assert((upl_size_t) size == size);
	        vnode_pageout(vnode_object-&gt;vnode_handle,
			      NULL, (upl_offset_t)(offset - base_offset), base_offset, (upl_size_t) size,
			      (upl_flags &amp; UPL_IOSYNC) | UPL_VNODE_PAGER, NULL);
	}
}


<span class="enscript-comment">/*
 *
 */</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_cluster_read</span>(
	vnode_pager_t		vnode_object,
	vm_object_offset_t	base_offset,
	vm_object_offset_t	offset,
	uint32_t		io_streaming,
	vm_size_t		cnt)
{
	<span class="enscript-type">int</span>		local_error = 0;
	<span class="enscript-type">int</span>		kret;
	<span class="enscript-type">int</span>		flags = 0;

	assert(! (cnt &amp; PAGE_MASK));

	<span class="enscript-keyword">if</span> (io_streaming)
		flags |= UPL_IOSTREAMING;

	assert((upl_size_t) cnt == cnt);
	kret = vnode_pagein(vnode_object-&gt;vnode_handle,
			    (upl_t) NULL,
			    (upl_offset_t) (offset - base_offset),
			    base_offset,
			    (upl_size_t) cnt,
			    flags,
			    &amp;local_error);
<span class="enscript-comment">/*
	if(kret == PAGER_ABSENT) {
	Need to work out the defs here, 1 corresponds to PAGER_ABSENT 
	defined in bsd/vm/vm_pager.h  However, we should not be including 
	that file here it is a layering violation.
*/</span>
	<span class="enscript-keyword">if</span> (kret == 1) {
		<span class="enscript-type">int</span>	uplflags;
		upl_t	upl = NULL;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	count = 0;
		kern_return_t	kr;

		uplflags = (UPL_NO_SYNC |
			    UPL_CLEAN_IN_PLACE |
			    UPL_SET_INTERNAL);
		count = 0;
		assert((upl_size_t) cnt == cnt);
		kr = memory_object_upl_request(vnode_object-&gt;control_handle,
					       base_offset, (upl_size_t) cnt,
					       &amp;upl, NULL, &amp;count, uplflags);
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
			upl_abort(upl, 0);
			upl_deallocate(upl);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We couldn't gather the page list, probably
			 * because the memory object doesn't have a link
			 * to a VM object anymore (forced unmount, for
			 * example).  Just return an error to the vm_fault()
			 * path and let it handle it.
			 */</span>
		}

		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;

}


<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_release_from_cache</span>(
		<span class="enscript-type">int</span>	*cnt)
{
	memory_object_free_from_cache(
			&amp;realhost, &amp;vnode_pager_ops, cnt);
}

<span class="enscript-comment">/*
 *
 */</span>
vnode_pager_t
<span class="enscript-function-name">vnode_object_create</span>(
        <span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-type">register</span> vnode_pager_t  vnode_object;

	vnode_object = (<span class="enscript-type">struct</span> vnode_pager *) zalloc(vnode_pager_zone);
	<span class="enscript-keyword">if</span> (vnode_object == VNODE_PAGER_NULL)
		<span class="enscript-keyword">return</span>(VNODE_PAGER_NULL);

	<span class="enscript-comment">/*
	 * The vm_map call takes both named entry ports and raw memory
	 * objects in the same parameter.  We need to make sure that
	 * vm_map does not see this object as a named entry port.  So,
	 * we reserve the first word in the object for a fake ip_kotype
	 * setting - that will tell vm_map to use it as a memory object.
	 */</span>
	vnode_object-&gt;pager_ops = &amp;vnode_pager_ops;
	vnode_object-&gt;pager_ikot = IKOT_MEMORY_OBJECT;
	vnode_object-&gt;ref_count = 1;
	vnode_object-&gt;control_handle = MEMORY_OBJECT_CONTROL_NULL;
	vnode_object-&gt;vnode_handle = vp;

	<span class="enscript-keyword">return</span>(vnode_object);
}

<span class="enscript-comment">/*
 *
 */</span>
vnode_pager_t
<span class="enscript-function-name">vnode_pager_lookup</span>(
	memory_object_t	 name)
{
	vnode_pager_t	vnode_object;

	vnode_object = (vnode_pager_t)name;
	assert(vnode_object-&gt;pager_ops == &amp;vnode_pager_ops);
	<span class="enscript-keyword">return</span> (vnode_object);
}


<span class="enscript-comment">/*********************** proc_info implementation *************/</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/bsdtask_info.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">fill_vnodeinfoforaddr</span>( vm_map_entry_t entry, uintptr_t * vnodeaddr, uint32_t * vid);


<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_procregioninfo</span>(task_t task, uint64_t arg, <span class="enscript-type">struct</span> proc_regioninfo_internal *pinfo, uintptr_t *vnodeaddr, uint32_t  *vid)
{

	vm_map_t map;
	vm_map_offset_t	address = (vm_map_offset_t )arg;
	vm_map_entry_t		tmp_entry;
	vm_map_entry_t		entry;
	vm_map_offset_t		start;
	vm_region_extended_info_data_t extended;
	vm_region_top_info_data_t top;

	    task_lock(task);
	    map = task-&gt;map;
	    <span class="enscript-keyword">if</span> (map == VM_MAP_NULL) 
	    {
			task_unlock(task);
			<span class="enscript-keyword">return</span>(0);
	    }
	    vm_map_reference(map); 
	    task_unlock(task);
	    
	    vm_map_lock_read(map);

	    start = address;
	    <span class="enscript-keyword">if</span> (!vm_map_lookup_entry(map, start, &amp;tmp_entry)) {
		<span class="enscript-keyword">if</span> ((entry = tmp_entry-&gt;vme_next) == vm_map_to_entry(map)) {
			vm_map_unlock_read(map);
	    		vm_map_deallocate(map); 
		   	<span class="enscript-keyword">return</span>(0);
		}
	    } <span class="enscript-keyword">else</span> {
		entry = tmp_entry;
	    }

	    start = entry-&gt;vme_start;

	    pinfo-&gt;pri_offset = VME_OFFSET(entry);
	    pinfo-&gt;pri_protection = entry-&gt;protection;
	    pinfo-&gt;pri_max_protection = entry-&gt;max_protection;
	    pinfo-&gt;pri_inheritance = entry-&gt;inheritance;
	    pinfo-&gt;pri_behavior = entry-&gt;behavior;
	    pinfo-&gt;pri_user_wired_count = entry-&gt;user_wired_count;
	    pinfo-&gt;pri_user_tag = VME_ALIAS(entry);

	    <span class="enscript-keyword">if</span> (entry-&gt;is_sub_map) {
		pinfo-&gt;pri_flags |= PROC_REGION_SUBMAP;
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (entry-&gt;is_shared)
			pinfo-&gt;pri_flags |= PROC_REGION_SHARED;
	    }


	    extended.protection = entry-&gt;protection;
	    extended.user_tag = VME_ALIAS(entry);
	    extended.pages_resident = 0;
	    extended.pages_swapped_out = 0;
	    extended.pages_shared_now_private = 0;
	    extended.pages_dirtied = 0;
	    extended.external_pager = 0;
	    extended.shadow_depth = 0;

	    vm_map_region_walk(map, start, entry, VME_OFFSET(entry), entry-&gt;vme_end - start, &amp;extended);

	    <span class="enscript-keyword">if</span> (extended.external_pager &amp;&amp; extended.ref_count == 2 &amp;&amp; extended.share_mode == SM_SHARED)
	            extended.share_mode = SM_PRIVATE;

	    top.private_pages_resident = 0;
	    top.shared_pages_resident = 0;
	    vm_map_region_top_walk(entry, &amp;top);

	
	    pinfo-&gt;pri_pages_resident = extended.pages_resident;
	    pinfo-&gt;pri_pages_shared_now_private = extended.pages_shared_now_private;
	    pinfo-&gt;pri_pages_swapped_out = extended.pages_swapped_out;
	    pinfo-&gt;pri_pages_dirtied = extended.pages_dirtied;
	    pinfo-&gt;pri_ref_count = extended.ref_count;
	    pinfo-&gt;pri_shadow_depth = extended.shadow_depth;
	    pinfo-&gt;pri_share_mode = extended.share_mode;

	    pinfo-&gt;pri_private_pages_resident = top.private_pages_resident;
	    pinfo-&gt;pri_shared_pages_resident = top.shared_pages_resident;
	    pinfo-&gt;pri_obj_id = top.obj_id;
		
	    pinfo-&gt;pri_address = (uint64_t)start;
	    pinfo-&gt;pri_size = (uint64_t)(entry-&gt;vme_end - start);
	    pinfo-&gt;pri_depth = 0;
	
	    <span class="enscript-keyword">if</span> ((vnodeaddr != 0) &amp;&amp; (entry-&gt;is_sub_map == 0)) {
		*vnodeaddr = (uintptr_t)0;

		<span class="enscript-keyword">if</span> (fill_vnodeinfoforaddr(entry, vnodeaddr, vid) ==0) {
			vm_map_unlock_read(map);
	    		vm_map_deallocate(map); 
			<span class="enscript-keyword">return</span>(1);
		}
	    }

	    vm_map_unlock_read(map);
	    vm_map_deallocate(map); 
	    <span class="enscript-keyword">return</span>(1);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_procregioninfo_onlymappedvnodes</span>(task_t task, uint64_t arg, <span class="enscript-type">struct</span> proc_regioninfo_internal *pinfo, uintptr_t *vnodeaddr, uint32_t  *vid)
{

	vm_map_t map;
	vm_map_offset_t	address = (vm_map_offset_t )arg;
	vm_map_entry_t		tmp_entry;
	vm_map_entry_t		entry;

	task_lock(task);
	map = task-&gt;map;
	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL) 
	{
		task_unlock(task);
		<span class="enscript-keyword">return</span>(0);
	}
	vm_map_reference(map); 
	task_unlock(task);
	
	vm_map_lock_read(map);

	<span class="enscript-keyword">if</span> (!vm_map_lookup_entry(map, address, &amp;tmp_entry)) {
		<span class="enscript-keyword">if</span> ((entry = tmp_entry-&gt;vme_next) == vm_map_to_entry(map)) {
			vm_map_unlock_read(map);
			vm_map_deallocate(map); 
		   	<span class="enscript-keyword">return</span>(0);
		}
	} <span class="enscript-keyword">else</span> {
		entry = tmp_entry;
	}

	<span class="enscript-keyword">while</span> (entry != vm_map_to_entry(map)) {
		*vnodeaddr = 0;
		*vid = 0;

		<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map == 0) {
			<span class="enscript-keyword">if</span> (fill_vnodeinfoforaddr(entry, vnodeaddr, vid)) {

				pinfo-&gt;pri_offset = VME_OFFSET(entry);
				pinfo-&gt;pri_protection = entry-&gt;protection;
				pinfo-&gt;pri_max_protection = entry-&gt;max_protection;
				pinfo-&gt;pri_inheritance = entry-&gt;inheritance;
				pinfo-&gt;pri_behavior = entry-&gt;behavior;
				pinfo-&gt;pri_user_wired_count = entry-&gt;user_wired_count;
				pinfo-&gt;pri_user_tag = VME_ALIAS(entry);
				
				<span class="enscript-keyword">if</span> (entry-&gt;is_shared)
					pinfo-&gt;pri_flags |= PROC_REGION_SHARED;
				
				pinfo-&gt;pri_pages_resident = 0;
				pinfo-&gt;pri_pages_shared_now_private = 0;
				pinfo-&gt;pri_pages_swapped_out = 0;
				pinfo-&gt;pri_pages_dirtied = 0;
				pinfo-&gt;pri_ref_count = 0;
				pinfo-&gt;pri_shadow_depth = 0;
				pinfo-&gt;pri_share_mode = 0;
				
				pinfo-&gt;pri_private_pages_resident = 0;
				pinfo-&gt;pri_shared_pages_resident = 0;
				pinfo-&gt;pri_obj_id = 0;
				
				pinfo-&gt;pri_address = (uint64_t)entry-&gt;vme_start;
				pinfo-&gt;pri_size = (uint64_t)(entry-&gt;vme_end - entry-&gt;vme_start);
				pinfo-&gt;pri_depth = 0;
	
				vm_map_unlock_read(map);
				vm_map_deallocate(map); 
				<span class="enscript-keyword">return</span>(1);
			}
		}

		<span class="enscript-comment">/* Keep searching for a vnode-backed mapping */</span>
		entry = entry-&gt;vme_next;
	}

	vm_map_unlock_read(map);
	vm_map_deallocate(map); 
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fill_vnodeinfoforaddr</span>(
	vm_map_entry_t			entry,
	uintptr_t * vnodeaddr,
	uint32_t * vid)
{
	vm_object_t	top_object, object;
	memory_object_t memory_object;
	memory_object_pager_ops_t pager_ops;
	kern_return_t	kr;
	<span class="enscript-type">int</span>		shadow_depth;


	<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map) {
		<span class="enscript-keyword">return</span>(0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * The last object in the shadow chain has the
		 * relevant pager information.
		 */</span>
		top_object = VME_OBJECT(entry);
		<span class="enscript-keyword">if</span> (top_object == VM_OBJECT_NULL) {
			object = VM_OBJECT_NULL;
			shadow_depth = 0;
		} <span class="enscript-keyword">else</span> {
			vm_object_lock(top_object);
			<span class="enscript-keyword">for</span> (object = top_object, shadow_depth = 0;
			     object-&gt;shadow != VM_OBJECT_NULL;
			     object = object-&gt;shadow, shadow_depth++) {
				vm_object_lock(object-&gt;shadow);
				vm_object_unlock(object);
			}
		}
	}

	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span>(0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;internal) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span>(0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (! object-&gt;pager_ready ||
		   object-&gt;terminating ||
		   ! object-&gt;alive) {
		vm_object_unlock(object);
		<span class="enscript-keyword">return</span>(0);
	} <span class="enscript-keyword">else</span> {
		memory_object = object-&gt;pager;
		pager_ops = memory_object-&gt;mo_pager_ops;
		<span class="enscript-keyword">if</span> (pager_ops == &amp;vnode_pager_ops) {
			kr = vnode_pager_get_object_vnode(
				memory_object,
				vnodeaddr, vid);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
				vm_object_unlock(object);
				<span class="enscript-keyword">return</span>(0);
			}
		} <span class="enscript-keyword">else</span> {
			vm_object_unlock(object);
			<span class="enscript-keyword">return</span>(0);
		}
	}
	vm_object_unlock(object);
	<span class="enscript-keyword">return</span>(1);
}

kern_return_t 
<span class="enscript-function-name">vnode_pager_get_object_vnode</span> (
	memory_object_t		mem_obj,
	uintptr_t * vnodeaddr,
	uint32_t * vid)
{
	vnode_pager_t	vnode_object;

	vnode_object = vnode_pager_lookup(mem_obj);
	<span class="enscript-keyword">if</span> (vnode_object-&gt;vnode_handle)  {
		*vnodeaddr = (uintptr_t)vnode_object-&gt;vnode_handle;
		*vid = (uint32_t)vnode_vid((<span class="enscript-type">void</span> *)vnode_object-&gt;vnode_handle);	

		<span class="enscript-keyword">return</span>(KERN_SUCCESS);
	}
	
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
kern_return_t
<span class="enscript-function-name">vnode_pager_get_object_devvp</span>(
	memory_object_t 	mem_obj,
	uintptr_t 		*devvp)
{
	<span class="enscript-type">struct</span> vnode 	*vp;
	uint32_t 	vid;

	<span class="enscript-keyword">if</span>(vnode_pager_get_object_vnode(mem_obj, (uintptr_t *)&amp;vp, (uint32_t *)&amp;vid) != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	*devvp = (uintptr_t)vnode_mountdevvp(vp);
	<span class="enscript-keyword">if</span> (*devvp)
		<span class="enscript-keyword">return</span> (KERN_SUCCESS);	
	<span class="enscript-keyword">return</span> (KERN_FAILURE);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Find the underlying vnode object for the given vm_map_entry.  If found, return with the
 * object locked, otherwise return NULL with nothing locked.
 */</span>

vm_object_t
<span class="enscript-function-name">find_vnode_object</span>(
	vm_map_entry_t	entry
)
{
	vm_object_t			top_object, object;
	memory_object_t 		memory_object;
	memory_object_pager_ops_t	pager_ops;

	<span class="enscript-keyword">if</span> (!entry-&gt;is_sub_map) {

		<span class="enscript-comment">/*
		 * The last object in the shadow chain has the
		 * relevant pager information.
		 */</span>

		top_object = VME_OBJECT(entry);

		<span class="enscript-keyword">if</span> (top_object) {
			vm_object_lock(top_object);

			<span class="enscript-keyword">for</span> (object = top_object; object-&gt;shadow != VM_OBJECT_NULL; object = object-&gt;shadow) {
				vm_object_lock(object-&gt;shadow);
				vm_object_unlock(object);
			}

			<span class="enscript-keyword">if</span> (object &amp;&amp; !object-&gt;internal &amp;&amp; object-&gt;pager_ready &amp;&amp; !object-&gt;terminating &amp;&amp;
			    object-&gt;alive) {
				memory_object = object-&gt;pager;
				pager_ops = memory_object-&gt;mo_pager_ops;

				<span class="enscript-comment">/*
				 * If this object points to the vnode_pager_ops, then we found what we're
				 * looking for.  Otherwise, this vm_map_entry doesn't have an underlying
				 * vnode and so we fall through to the bottom and return NULL.
				 */</span>

				<span class="enscript-keyword">if</span> (pager_ops == &amp;vnode_pager_ops) 
					<span class="enscript-keyword">return</span> object;		<span class="enscript-comment">/* we return with the object locked */</span>
			}

			vm_object_unlock(object);
		}

	}

	<span class="enscript-keyword">return</span>(VM_OBJECT_NULL);
}
</pre>
<hr />
</body></html>