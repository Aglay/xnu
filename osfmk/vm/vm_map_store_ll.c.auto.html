<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_map_store_ll.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_map_store_ll.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map_store_ll.h&gt;</span>

boolean_t
<span class="enscript-function-name">first_free_is_valid_ll</span>( vm_map_t map )
{
	vm_map_entry_t	entry, next;
	entry = vm_map_to_entry(map);
	next = entry-&gt;vme_next;
	<span class="enscript-keyword">while</span> (vm_map_trunc_page(next-&gt;vme_start,
				 VM_MAP_PAGE_MASK(map)) ==
	       vm_map_trunc_page(entry-&gt;vme_end,
				 VM_MAP_PAGE_MASK(map)) ||
	       (vm_map_trunc_page(next-&gt;vme_start,
				  VM_MAP_PAGE_MASK(map)) ==
		vm_map_trunc_page(entry-&gt;vme_start,
				  VM_MAP_PAGE_MASK(map)) &amp;&amp;
		next != vm_map_to_entry(map))) {
		entry = next;
		next = entry-&gt;vme_next;
		<span class="enscript-keyword">if</span> (entry == vm_map_to_entry(map))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (map-&gt;first_free != entry) {
		printf(<span class="enscript-string">&quot;Bad first_free for map %p: %p should be %p\n&quot;</span>,
		       map, map-&gt;first_free, entry);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 *	UPDATE_FIRST_FREE:
 *
 *	Updates the map-&gt;first_free pointer to the
 *	entry immediately before the first hole in the map.
 * 	The map should be locked.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UPDATE_FIRST_FREE_LL</span>(map, new_first_free)			\
	MACRO_BEGIN							\
	<span class="enscript-keyword">if</span>( map-&gt;disable_vmentry_reuse == FALSE){			\
		vm_map_t	UFF_map;				\
		vm_map_entry_t	UFF_first_free;				\
		vm_map_entry_t	UFF_next_entry;				\
		UFF_map = (map);					\
		UFF_first_free = (new_first_free);			\
		UFF_next_entry = UFF_first_free-&gt;vme_next;		\
		<span class="enscript-keyword">while</span> (vm_map_trunc_page(UFF_next_entry-&gt;vme_start,	\
					 VM_MAP_PAGE_MASK(UFF_map)) ==	\
		       vm_map_trunc_page(UFF_first_free-&gt;vme_end,	\
					 VM_MAP_PAGE_MASK(UFF_map)) ||	\
		       (vm_map_trunc_page(UFF_next_entry-&gt;vme_start,	\
					  VM_MAP_PAGE_MASK(UFF_map)) ==	\
			vm_map_trunc_page(UFF_first_free-&gt;vme_start,	\
					  VM_MAP_PAGE_MASK(UFF_map)) &amp;&amp;	\
			UFF_next_entry != vm_map_to_entry(UFF_map))) {	\
			UFF_first_free = UFF_next_entry;		\
			UFF_next_entry = UFF_first_free-&gt;vme_next;	\
			<span class="enscript-keyword">if</span> (UFF_first_free == vm_map_to_entry(UFF_map))	\
				<span class="enscript-keyword">break</span>;					\
		}							\
		UFF_map-&gt;first_free = UFF_first_free;			\
		assert(first_free_is_valid(UFF_map));			\
	}								\
	MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">_vm_map_entry_link_ll</span>(hdr, after_where, entry)			\
	MACRO_BEGIN							\
	<span class="enscript-keyword">if</span> (entry-&gt;map_aligned) {					\
		assert(VM_MAP_PAGE_ALIGNED((entry-&gt;vme_start),		\
					   VM_MAP_HDR_PAGE_MASK((hdr))));\
		assert(VM_MAP_PAGE_ALIGNED((entry-&gt;vme_end),		\
					   VM_MAP_HDR_PAGE_MASK((hdr))));\
	}								\
	(hdr)-&gt;nentries++;						\
	(entry)-&gt;vme_prev = (after_where);				\
	(entry)-&gt;vme_next = (after_where)-&gt;vme_next;			\
	(entry)-&gt;vme_prev-&gt;vme_next = (entry)-&gt;vme_next-&gt;vme_prev = (entry); \
	MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">_vm_map_entry_unlink_ll</span>(hdr, entry)				\
	MACRO_BEGIN							\
	(hdr)-&gt;nentries--;						\
	(entry)-&gt;vme_next-&gt;vme_prev = (entry)-&gt;vme_prev; 		\
	(entry)-&gt;vme_prev-&gt;vme_next = (entry)-&gt;vme_next; 		\
	MACRO_END
<span class="enscript-comment">/*
 *	Macro:		vm_map_copy_insert
 *	
 *	Description:
 *		Link a copy chain (&quot;copy&quot;) into a map at the
 *		specified location (after &quot;where&quot;).
 *	Side effects:
 *		The copy chain is destroyed.
 *	Warning:
 *		The arguments are evaluated multiple times.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_vm_map_copy_insert_ll</span>(map, where, copy)				\
MACRO_BEGIN								\
	vm_map_t VMCI_map;						\
	vm_map_entry_t VMCI_where;					\
	vm_map_copy_t VMCI_copy;					\
	VMCI_map = (map);						\
	VMCI_where = (where);						\
	VMCI_copy = (copy);						\
	((VMCI_where-&gt;vme_next)-&gt;vme_prev = vm_map_copy_last_entry(VMCI_copy))\
		-&gt;vme_next = (VMCI_where-&gt;vme_next);			\
	((VMCI_where)-&gt;vme_next = vm_map_copy_first_entry(VMCI_copy))	\
		-&gt;vme_prev = VMCI_where;				\
	VMCI_map-&gt;hdr.nentries += VMCI_copy-&gt;cpy_hdr.nentries;		\
	update_first_free_ll(VMCI_map, VMCI_map-&gt;first_free);		\
MACRO_END



<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_init_ll</span>( __unused <span class="enscript-type">struct</span> vm_map_header *hdr)
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *	vm_map_lookup_entry_ll:	[ internal use only ]
 *	Use the linked list to find the map entry containing (or
 *	immediately preceding) the specified address
 *	in the given map; the entry is returned
 *	in the &quot;entry&quot; parameter.  The boolean
 *	result indicates whether the address is
 *	actually contained in the map.
 */</span>
boolean_t
<span class="enscript-function-name">vm_map_store_lookup_entry_ll</span>(
	<span class="enscript-type">register</span> vm_map_t		map,
	<span class="enscript-type">register</span> vm_map_offset_t	address,
	vm_map_entry_t		*entry)		<span class="enscript-comment">/* OUT */</span>
{
	<span class="enscript-type">register</span> vm_map_entry_t		cur;
	<span class="enscript-type">register</span> vm_map_entry_t		last;

	<span class="enscript-comment">/*
	 *	Start looking either from the head of the
	 *	list, or from the hint.
	 */</span>
	cur = map-&gt;hint;

	<span class="enscript-keyword">if</span> (cur == vm_map_to_entry(map))
		cur = cur-&gt;vme_next;

	<span class="enscript-keyword">if</span> (address &gt;= cur-&gt;vme_start) {
		<span class="enscript-comment">/*
		 *	Go from hint to end of list.
		 *
		 *	But first, make a quick check to see if
		 *	we are already looking at the entry we
		 *	want (which is usually the case).
		 *	Note also that we don't need to save the hint
		 *	here... it is the same hint (unless we are
		 *	at the header, in which case the hint didn't
		 *	buy us anything anyway).
		 */</span>
		last = vm_map_to_entry(map);
		<span class="enscript-keyword">if</span> ((cur != last) &amp;&amp; (cur-&gt;vme_end &gt; address)) {
			*entry = cur;
			<span class="enscript-keyword">return</span>(TRUE);
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 *	Go from start to hint, *inclusively*
		 */</span>
		last = cur-&gt;vme_next;
		cur = vm_map_first_entry(map);
	}

	<span class="enscript-comment">/*
	 *	Search linearly
	 */</span>

	<span class="enscript-keyword">while</span> (cur != last) {
		<span class="enscript-keyword">if</span> (cur-&gt;vme_end &gt; address) {
			<span class="enscript-keyword">if</span> (address &gt;= cur-&gt;vme_start) {
				<span class="enscript-comment">/*
				 *	Save this lookup for future
				 *	hints, and return
				 */</span>

				*entry = cur;
				SAVE_HINT_MAP_READ(map, cur);

				<span class="enscript-keyword">return</span>(TRUE);
			}
			<span class="enscript-keyword">break</span>;
		}
		cur = cur-&gt;vme_next;
	}
	*entry = cur-&gt;vme_prev;
	SAVE_HINT_MAP_READ(map, *entry);

	<span class="enscript-keyword">return</span>(FALSE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_entry_link_ll</span>( <span class="enscript-type">struct</span> vm_map_header *mapHdr, vm_map_entry_t after_where, vm_map_entry_t entry)
{
	_vm_map_entry_link_ll( mapHdr, after_where, entry);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_entry_unlink_ll</span>( <span class="enscript-type">struct</span> vm_map_header *mapHdr, vm_map_entry_t entry)
{
	_vm_map_entry_unlink_ll( mapHdr, entry);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_copy_insert_ll</span>( vm_map_t map, vm_map_entry_t after_where, vm_map_copy_t copy)
{
	_vm_map_copy_insert_ll( map, after_where, copy);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_copy_reset_ll</span>( vm_map_copy_t copy, __unused vm_map_entry_t entry, __unused <span class="enscript-type">int</span> nentries)
{
	copy-&gt;cpy_hdr.nentries = 0;
	vm_map_copy_first_entry(copy) =
		vm_map_copy_last_entry(copy) =
			vm_map_copy_to_entry(copy);

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">update_first_free_ll</span>( vm_map_t map, vm_map_entry_t new_first_free)
{
	<span class="enscript-keyword">if</span> (map-&gt;holelistenabled)
		<span class="enscript-keyword">return</span>;

	UPDATE_FIRST_FREE_LL( map, new_first_free);
}

</pre>
<hr />
</body></html>