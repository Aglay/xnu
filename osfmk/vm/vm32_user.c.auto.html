<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm32_user.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm32_user.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm/vm32_user.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 * 
 *	User-exported virtual memory functions.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>	<span class="enscript-comment">/* to get vm_address_t */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/std_types.h&gt;</span>	<span class="enscript-comment">/* to get pointer_t */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_attributes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_syscalls.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm32_map_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM32_SUPPORT</span>

<span class="enscript-comment">/*
 * See vm_user.c for the real implementation of all of these functions.
 * We call through to the mach_ &quot;wide&quot; versions of the routines, and trust
 * that the VM system verifies the arguments and only returns address that
 * are appropriate for the task's address space size.
 *
 * New VM call implementations should not be added here, because they would
 * be available only to 32-bit userspace clients. Add them to vm_user.c
 * and the corresponding prototype to mach_vm.defs (subsystem 4800).
 */</span>

kern_return_t
<span class="enscript-function-name">vm32_allocate</span>(
	vm_map_t	map,
	vm32_offset_t	*addr,
	vm32_size_t	size,
	<span class="enscript-type">int</span>		flags)
{
	mach_vm_offset_t	maddr;
	kern_return_t		result;

	maddr = *addr;
	result = mach_vm_allocate(map, &amp;maddr, size, flags);
	*addr = CAST_DOWN_EXPLICIT(vm32_offset_t, maddr);
	
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_deallocate</span>(
	vm_map_t	map,
	vm32_offset_t		start,
	vm32_size_t		size)
{
	<span class="enscript-keyword">if</span> ((map == VM_MAP_NULL) || (start + size &lt; start))
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">return</span> mach_vm_deallocate(map, start, size);
}

kern_return_t
<span class="enscript-function-name">vm32_inherit</span>(
	vm_map_t	map,
	vm32_offset_t		start,
	vm32_size_t		size,
	vm_inherit_t		new_inheritance)
{
	<span class="enscript-keyword">if</span> ((map == VM_MAP_NULL) || (start + size &lt; start))
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">return</span> mach_vm_inherit(map, start, size, new_inheritance);
}

kern_return_t
<span class="enscript-function-name">vm32_protect</span>(
	vm_map_t		map,
	vm32_offset_t		start,
	vm32_size_t		size,
	boolean_t		set_maximum,
	vm_prot_t		new_protection)
{
	<span class="enscript-keyword">if</span> ((map == VM_MAP_NULL) || (start + size &lt; start))
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">return</span> mach_vm_protect(map, start, size, set_maximum, new_protection);
}

kern_return_t
<span class="enscript-function-name">vm32_machine_attribute</span>(
	vm_map_t	map,
	vm32_address_t	addr,
	vm32_size_t	size,
	vm_machine_attribute_t	attribute,
	vm_machine_attribute_val_t* value)		<span class="enscript-comment">/* IN/OUT */</span>
{
	<span class="enscript-keyword">if</span> ((map == VM_MAP_NULL) || (addr + size &lt; addr))
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">return</span> mach_vm_machine_attribute(map, addr, size, attribute, value);
}

kern_return_t
<span class="enscript-function-name">vm32_read</span>(
	vm_map_t		map,
	vm32_address_t		addr,
	vm32_size_t		size,
	pointer_t		*data,
	mach_msg_type_number_t	*data_size)
{
	<span class="enscript-keyword">return</span> mach_vm_read(map, addr, size, data, data_size);
}

kern_return_t
<span class="enscript-function-name">vm32_read_list</span>(
	vm_map_t		map,
	vm32_read_entry_t	data_list,
	natural_t		count)
{
	mach_vm_read_entry_t	mdata_list;
	mach_msg_type_number_t	i;
	kern_return_t			result;

	<span class="enscript-keyword">for</span> (i=0; i &lt; VM_MAP_ENTRY_MAX; i++) {
		mdata_list[i].address = data_list[i].address;
		mdata_list[i].size = data_list[i].size;
	}
	
	result = mach_vm_read_list(map, mdata_list, count);

	<span class="enscript-keyword">for</span> (i=0; i &lt; VM_MAP_ENTRY_MAX; i++) {
		data_list[i].address = CAST_DOWN_EXPLICIT(vm32_address_t, mdata_list[i].address);
		data_list[i].size = CAST_DOWN_EXPLICIT(vm32_size_t, mdata_list[i].size);
	}

	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_read_overwrite</span>(
	vm_map_t	map,
	vm32_address_t	address,
	vm32_size_t	size,
	vm32_address_t	data,
	vm32_size_t	*data_size)
{
	kern_return_t	result;
	mach_vm_size_t	mdata_size;

	mdata_size = *data_size;
	result = mach_vm_read_overwrite(map, address, size, data, &amp;mdata_size);	
	*data_size = CAST_DOWN_EXPLICIT(vm32_size_t, mdata_size);
	
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_write</span>(
	vm_map_t			map,
	vm32_address_t			address,
	pointer_t			data,
	mach_msg_type_number_t	size)
{
	<span class="enscript-keyword">return</span> mach_vm_write(map, address, data, size);
}

kern_return_t
<span class="enscript-function-name">vm32_copy</span>(
	vm_map_t	map,
	vm32_address_t	source_address,
	vm32_size_t	size,
	vm32_address_t	dest_address)
{
	<span class="enscript-keyword">return</span> mach_vm_copy(map, source_address, size, dest_address);
}

kern_return_t
<span class="enscript-function-name">vm32_map_64</span>(
	vm_map_t		target_map,
	vm32_offset_t		*address,
	vm32_size_t		size,
	vm32_offset_t		mask,
	<span class="enscript-type">int</span>			flags,
	ipc_port_t		port,
	vm_object_offset_t	offset,
	boolean_t		copy,
	vm_prot_t		cur_protection,
	vm_prot_t		max_protection,
	vm_inherit_t		inheritance)
{
	mach_vm_offset_t	maddress;
	kern_return_t		result;

	maddress = *address;
	result = mach_vm_map(target_map, &amp;maddress, size, mask,
						 flags, port, offset, copy,
						 cur_protection, max_protection, inheritance);
	*address = CAST_DOWN_EXPLICIT(vm32_offset_t, maddress);
	
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_map</span>(
	vm_map_t		target_map,
	vm32_offset_t		*address,
	vm32_size_t		size,
	vm32_offset_t		mask,
	<span class="enscript-type">int</span>			flags,
	ipc_port_t		port,
	vm32_offset_t		offset,
	boolean_t		copy,
	vm_prot_t		cur_protection,
	vm_prot_t		max_protection,
	vm_inherit_t		inheritance)
{
	<span class="enscript-keyword">return</span> vm32_map_64(target_map, address, size, mask,
						  flags, port, offset, copy,
						  cur_protection, max_protection, inheritance);
}

kern_return_t
<span class="enscript-function-name">vm32_remap</span>(
	vm_map_t		target_map,
	vm32_offset_t		*address,
	vm32_size_t		size,
	vm32_offset_t		mask,
	boolean_t		anywhere,
	vm_map_t		src_map,
	vm32_offset_t		memory_address,
	boolean_t		copy,
	vm_prot_t		*cur_protection,
	vm_prot_t		*max_protection,
	vm_inherit_t		inheritance)
{
	mach_vm_offset_t	maddress;
	kern_return_t		result;
	
	maddress = *address;
	result = mach_vm_remap(target_map, &amp;maddress, size, mask,
						 anywhere, src_map, memory_address, copy,
						 cur_protection, max_protection, inheritance);
	*address = CAST_DOWN_EXPLICIT(vm32_offset_t, maddress);
	
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_msync</span>(
	vm_map_t	map,
	vm32_address_t	address,
	vm32_size_t	size,
	vm_sync_t	sync_flags)
{
	<span class="enscript-keyword">return</span> mach_vm_msync(map, address, size, sync_flags);
}

kern_return_t 
<span class="enscript-function-name">vm32_behavior_set</span>(
	vm_map_t		map,
	vm32_offset_t		start,
	vm32_size_t		size,
	vm_behavior_t		new_behavior)
{
	<span class="enscript-keyword">if</span> ((map == VM_MAP_NULL) || (start + size &lt; start))
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">return</span> mach_vm_behavior_set(map, start, size, new_behavior);
}

kern_return_t
<span class="enscript-function-name">vm32_region_64</span>(
	vm_map_t		 map,
	vm32_offset_t	        *address,		<span class="enscript-comment">/* IN/OUT */</span>
	vm32_size_t		*size,			<span class="enscript-comment">/* OUT */</span>
	vm_region_flavor_t	 flavor,		<span class="enscript-comment">/* IN */</span>
	vm_region_info_t	 info,			<span class="enscript-comment">/* OUT */</span>
	mach_msg_type_number_t	*count,			<span class="enscript-comment">/* IN/OUT */</span>
	mach_port_t		*object_name)		<span class="enscript-comment">/* OUT */</span>
{
	mach_vm_offset_t	maddress;
	mach_vm_size_t		msize;
	kern_return_t		result;

	maddress = *address;
	msize = *size;
	result = mach_vm_region(map, &amp;maddress, &amp;msize, flavor, info, count, object_name);
	*size = CAST_DOWN_EXPLICIT(vm32_size_t, msize);
	*address = CAST_DOWN_EXPLICIT(vm32_offset_t, maddress);
	
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_region</span>(
	vm_map_t			map,
	vm32_address_t	      		*address,	<span class="enscript-comment">/* IN/OUT */</span>
	vm32_size_t			*size,		<span class="enscript-comment">/* OUT */</span>
	vm_region_flavor_t	 	flavor,	<span class="enscript-comment">/* IN */</span>
	vm_region_info_t	 	info,		<span class="enscript-comment">/* OUT */</span>
	mach_msg_type_number_t	*count,	<span class="enscript-comment">/* IN/OUT */</span>
	mach_port_t			*object_name)	<span class="enscript-comment">/* OUT */</span>
{
	vm_map_address_t 	map_addr;
	vm_map_size_t 		map_size;
	kern_return_t		kr;

	<span class="enscript-keyword">if</span> (VM_MAP_NULL == map)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	map_addr = (vm_map_address_t)*address;
	map_size = (vm_map_size_t)*size;

	kr = vm_map_region(map,
			   &amp;map_addr, &amp;map_size,
			   flavor, info, count,
			   object_name);

	*address = CAST_DOWN_EXPLICIT(vm32_address_t, map_addr);
	*size = CAST_DOWN_EXPLICIT(vm32_size_t, map_size);

	<span class="enscript-keyword">if</span> (KERN_SUCCESS == kr &amp;&amp; map_addr + map_size &gt; VM32_MAX_ADDRESS)
		<span class="enscript-keyword">return</span> KERN_INVALID_ADDRESS;
	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">vm32_region_recurse_64</span>(
	vm_map_t			map,
	vm32_address_t			*address,
	vm32_size_t			*size,
	uint32_t			*depth,
	vm_region_recurse_info_64_t	info,
	mach_msg_type_number_t 	*infoCnt)
{
	mach_vm_address_t	maddress;
	mach_vm_size_t		msize;
	kern_return_t		result;

	maddress = *address;
	msize = *size;
	result = mach_vm_region_recurse(map, &amp;maddress, &amp;msize, depth, info, infoCnt);
	*address = CAST_DOWN_EXPLICIT(vm32_address_t, maddress);
	*size = CAST_DOWN_EXPLICIT(vm32_size_t, msize);
	
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">vm32_region_recurse</span>(
	vm_map_t			map,
	vm32_offset_t	       	*address,	<span class="enscript-comment">/* IN/OUT */</span>
	vm32_size_t			*size,		<span class="enscript-comment">/* OUT */</span>
	natural_t	 		*depth,	<span class="enscript-comment">/* IN/OUT */</span>
	vm_region_recurse_info_t	info32,	<span class="enscript-comment">/* IN/OUT */</span>
	mach_msg_type_number_t	*infoCnt)	<span class="enscript-comment">/* IN/OUT */</span>
{
	vm_region_submap_info_data_64_t info64;
	vm_region_submap_info_t info;
	vm_map_address_t	map_addr;
	vm_map_size_t		map_size;
	kern_return_t		kr;

	<span class="enscript-keyword">if</span> (VM_MAP_NULL == map || *infoCnt &lt; VM_REGION_SUBMAP_INFO_COUNT)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	
	map_addr = (vm_map_address_t)*address;
	map_size = (vm_map_size_t)*size;
	info = (vm_region_submap_info_t)info32;
	*infoCnt = VM_REGION_SUBMAP_INFO_COUNT_64;

	kr = vm_map_region_recurse_64(map, &amp;map_addr,&amp;map_size,
				      depth, &amp;info64, infoCnt);

	info-&gt;protection = info64.protection;
	info-&gt;max_protection = info64.max_protection;
	info-&gt;inheritance = info64.inheritance;
	info-&gt;offset = (uint32_t)info64.offset; <span class="enscript-comment">/* trouble-maker */</span>
        info-&gt;user_tag = info64.user_tag;
        info-&gt;pages_resident = info64.pages_resident;
        info-&gt;pages_shared_now_private = info64.pages_shared_now_private;
        info-&gt;pages_swapped_out = info64.pages_swapped_out;
        info-&gt;pages_dirtied = info64.pages_dirtied;
        info-&gt;ref_count = info64.ref_count;
        info-&gt;shadow_depth = info64.shadow_depth;
        info-&gt;external_pager = info64.external_pager;
        info-&gt;share_mode = info64.share_mode;
	info-&gt;is_submap = info64.is_submap;
	info-&gt;behavior = info64.behavior;
	info-&gt;object_id = info64.object_id;
	info-&gt;user_wired_count = info64.user_wired_count; 

	*address = CAST_DOWN_EXPLICIT(vm32_address_t, map_addr);
	*size = CAST_DOWN_EXPLICIT(vm32_size_t, map_size);
	*infoCnt = VM_REGION_SUBMAP_INFO_COUNT;

	<span class="enscript-keyword">if</span> (KERN_SUCCESS == kr &amp;&amp; map_addr + map_size &gt; VM32_MAX_ADDRESS)
		<span class="enscript-keyword">return</span> KERN_INVALID_ADDRESS;
	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">vm32_purgable_control</span>(
	vm_map_t		map,
	vm32_offset_t		address,
	vm_purgable_t		control,
	<span class="enscript-type">int</span>			*state)
{
	<span class="enscript-keyword">if</span> (VM_MAP_NULL == map)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">return</span> vm_map_purgable_control(map,
				       vm_map_trunc_page(address, PAGE_MASK),
				       control,
				       state);
}
					
kern_return_t
<span class="enscript-function-name">vm32_map_page_query</span>(
	vm_map_t		map,
	vm32_offset_t		offset,
	<span class="enscript-type">int</span>			*disposition,
	<span class="enscript-type">int</span>			*ref_count)
{
	<span class="enscript-keyword">if</span> (VM_MAP_NULL == map)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">return</span> vm_map_page_query_internal(
		map,
		vm_map_trunc_page(offset, PAGE_MASK),
		disposition,
		ref_count);
}

kern_return_t
<span class="enscript-function-name">vm32_make_memory_entry_64</span>(
	vm_map_t		target_map,
	memory_object_size_t	*size,
	memory_object_offset_t offset,
	vm_prot_t		permission,
	ipc_port_t		*object_handle,
	ipc_port_t		parent_handle)
{
	<span class="enscript-comment">// use the existing entrypoint
</span>	<span class="enscript-keyword">return</span> _mach_make_memory_entry(target_map, size, offset, permission, object_handle, parent_handle);
}

kern_return_t
<span class="enscript-function-name">vm32_make_memory_entry</span>(
	vm_map_t		target_map,
	vm32_size_t		*size,
	vm32_offset_t		offset,
	vm_prot_t		permission,
	ipc_port_t		*object_handle,
	ipc_port_t		parent_entry)
{	
	memory_object_size_t 	mo_size;
	kern_return_t		kr;
	
	mo_size = (memory_object_size_t)*size;
	kr = _mach_make_memory_entry(target_map, &amp;mo_size, 
			(memory_object_offset_t)offset, permission, object_handle,
			parent_entry);
	*size = CAST_DOWN_EXPLICIT(vm32_size_t, mo_size);
	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">vm32__task_wire</span>(
	vm_map_t	map,
	boolean_t	must_wire)
{
	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (must_wire)
		map-&gt;wiring_required = TRUE;
	<span class="enscript-keyword">else</span>
		map-&gt;wiring_required = FALSE;

	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM32_SUPPORT */</span>
</pre>
<hr />
</body></html>