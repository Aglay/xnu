<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_compressor_backing_store.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_compressor_backing_store.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;vm_compressor_backing_store.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>


boolean_t	compressor_store_stop_compaction = FALSE;
boolean_t	vm_swap_up = FALSE;
boolean_t	vm_swapfile_create_needed = FALSE;
boolean_t	vm_swapfile_gc_needed = FALSE;

<span class="enscript-type">int</span>		swapper_throttle = -1;
boolean_t	swapper_throttle_inited = FALSE;
uint64_t	vm_swapout_thread_id;

uint64_t	vm_swap_put_failures = 0;
uint64_t	vm_swap_get_failures = 0;
<span class="enscript-type">int</span>		vm_num_swap_files = 0;
<span class="enscript-type">int</span>		vm_swapout_thread_processed_segments = 0;
<span class="enscript-type">int</span>		vm_swapout_thread_awakened = 0;
<span class="enscript-type">int</span>		vm_swapfile_create_thread_awakened = 0;
<span class="enscript-type">int</span>		vm_swapfile_create_thread_running = 0;
<span class="enscript-type">int</span>		vm_swapfile_gc_thread_awakened = 0;
<span class="enscript-type">int</span>		vm_swapfile_gc_thread_running = 0;

int64_t		vm_swappin_avail = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_swapfile_total_segs_alloced = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_swapfile_total_segs_used = 0;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SWAP_READY</span>	0x1	<span class="enscript-comment">/* Swap file is ready to be used */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SWAP_RECLAIM</span>	0x2	<span class="enscript-comment">/* Swap file is marked to be reclaimed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SWAP_WANTED</span>	0x4	<span class="enscript-comment">/* Swap file has waiters */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SWAP_REUSE</span>	0x8	<span class="enscript-comment">/* Swap file is on the Q and has a name. Reuse after init-ing.*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SWAP_PINNED</span>	0x10	<span class="enscript-comment">/* Swap file is pinned (FusionDrive) */</span>


<span class="enscript-type">struct</span> swapfile{
	queue_head_t		swp_queue;	<span class="enscript-comment">/* list of swap files */</span>
	<span class="enscript-type">char</span>			*swp_path;	<span class="enscript-comment">/* saved pathname of swap file */</span>
	<span class="enscript-type">struct</span> vnode		*swp_vp;	<span class="enscript-comment">/* backing vnode */</span>
	uint64_t		swp_size;	<span class="enscript-comment">/* size of this swap file */</span>
	uint8_t			*swp_bitmap;	<span class="enscript-comment">/* bitmap showing the alloced/freed slots in the swap file */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_pathlen;	<span class="enscript-comment">/* length of pathname */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_nsegs;	<span class="enscript-comment">/* #segments we can use */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_nseginuse;	<span class="enscript-comment">/* #segments in use */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_index;	<span class="enscript-comment">/* index of this swap file */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_flags;	<span class="enscript-comment">/* state of swap file */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_free_hint;	<span class="enscript-comment">/* offset of 1st free chunk */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_io_count;	<span class="enscript-comment">/* count of outstanding I/Os */</span>
	c_segment_t		*swp_csegs;	<span class="enscript-comment">/* back pointers to the c_segments. Used during swap reclaim. */</span>

	<span class="enscript-type">struct</span> trim_list	*swp_delayed_trim_list_head;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swp_delayed_trim_count;
};

queue_head_t	swf_global_queue;
boolean_t	swp_trim_supported = FALSE;

<span class="enscript-type">extern</span> clock_sec_t	dont_trim_until_ts;
clock_sec_t		vm_swapfile_last_failed_to_create_ts = 0;
clock_sec_t		vm_swapfile_last_successful_create_ts = 0;
<span class="enscript-type">int</span>			vm_swapfile_can_be_created = FALSE;
boolean_t		delayed_trim_handling_in_progress = FALSE;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swapout_thread_throttle_adjust</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swap_free_now</span>(<span class="enscript-type">struct</span> swapfile *swf, uint64_t f_offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swapout_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swapfile_create_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swapfile_gc_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swap_defragment</span>();
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swap_handle_delayed_trims</span>(boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swap_do_delayed_trim</span>();
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_swap_wait_on_trim_handling_in_progress</span>(<span class="enscript-type">void</span>);



#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAX_SWAP_FILE_NUM</span>		100
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_SWAPFILE_DELAYED_TRIM_MAX</span>	128

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_SWAP_SHOULD_DEFRAGMENT</span>()	(c_swappedout_sparse_count &gt; (vm_swapfile_total_segs_used / 4) ? 1 : 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_SWAP_SHOULD_RECLAIM</span>()	(((vm_swapfile_total_segs_alloced - vm_swapfile_total_segs_used) &gt;= SWAPFILE_RECLAIM_THRESHOLD_SEGS) ? 1 : 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_SWAP_SHOULD_ABORT_RECLAIM</span>()	(((vm_swapfile_total_segs_alloced - vm_swapfile_total_segs_used) &lt;= SWAPFILE_RECLAIM_MINIMUM_SEGS) ? 1 : 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_SWAP_SHOULD_PIN</span>(_size)	(vm_swappin_avail &gt; 0 &amp;&amp; vm_swappin_avail &gt;= (int64_t)(_size))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_SWAP_SHOULD_CREATE</span>(cur_ts)	((vm_num_swap_files &lt; VM_MAX_SWAP_FILE_NUM) &amp;&amp; ((vm_swapfile_total_segs_alloced - vm_swapfile_total_segs_used) &lt; (unsigned int)VM_SWAPFILE_HIWATER_SEGS) &amp;&amp; \
					 ((cur_ts - vm_swapfile_last_failed_to_create_ts) &gt; VM_SWAPFILE_DELAYED_CREATE) ? 1 : 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_SWAP_SHOULD_TRIM</span>(swf)	((swf-&gt;swp_delayed_trim_count &gt;= VM_SWAPFILE_DELAYED_TRIM_MAX) ? 1 : 0)


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_SWAPFILE_DELAYED_CREATE</span>	15

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_SWAP_BUSY</span>()	((c_swapout_count &amp;&amp; (swapper_throttle == THROTTLE_LEVEL_COMPRESSOR_TIER1 || swapper_throttle == THROTTLE_LEVEL_COMPRESSOR_TIER0)) ? 1 : 0)


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_SWAP</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hash_string</span>(<span class="enscript-type">char</span> *cp, <span class="enscript-type">int</span> len);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>
boolean_t	c_compressed_record_init_done = FALSE;
<span class="enscript-type">int</span>		c_compressed_record_write_error = 0;
<span class="enscript-type">struct</span> vnode	*c_compressed_record_vp = NULL;
uint64_t	c_compressed_record_file_offset = 0;
<span class="enscript-type">void</span>	c_compressed_record_init(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	c_compressed_record_write(<span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
<span class="enscript-type">extern</span> boolean_t		swap_crypt_ctx_initialized;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> 			swap_crypt_ctx_initialize(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	swap_crypt_null_iv[AES_BLOCK_SIZE];
<span class="enscript-type">extern</span> aes_ctx			swap_crypt_ctx;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> 		vm_page_encrypt_counter;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> 		vm_page_decrypt_counter;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			vm_pageout_io_throttle(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			vm_pageout_reinit_tuneables(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			vm_swap_file_set_tuneables(<span class="enscript-type">void</span>);

<span class="enscript-type">struct</span> swapfile *<span class="enscript-function-name">vm_swapfile_for_handle</span>(uint64_t);

<span class="enscript-comment">/*
 * Called with the vm_swap_data_lock held.
 */</span> 

<span class="enscript-type">struct</span> swapfile *
<span class="enscript-function-name">vm_swapfile_for_handle</span>(uint64_t f_offset) 
{
	
	uint64_t		file_offset = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		swapfile_index = 0;
	<span class="enscript-type">struct</span> swapfile*	swf = NULL;

	file_offset = (f_offset &amp; SWAP_SLOT_MASK);	
	swapfile_index = (f_offset &gt;&gt; SWAP_DEVICE_SHIFT);

	swf = (<span class="enscript-type">struct</span> swapfile*) queue_first(&amp;swf_global_queue);

	<span class="enscript-keyword">while</span>(queue_end(&amp;swf_global_queue, (queue_entry_t)swf) == FALSE) {

		<span class="enscript-keyword">if</span> (swapfile_index == swf-&gt;swp_index) {
			<span class="enscript-keyword">break</span>;
		}

		swf = (<span class="enscript-type">struct</span> swapfile*) queue_next(&amp;swf-&gt;swp_queue);
	}

	<span class="enscript-keyword">if</span> (queue_end(&amp;swf_global_queue, (queue_entry_t) swf)) {
		swf = NULL;
	}

	<span class="enscript-keyword">return</span> swf;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_compressor_swap_init</span>()
{
	thread_t	thread = NULL;

	lck_grp_attr_setdefault(&amp;vm_swap_data_lock_grp_attr);
	lck_grp_init(&amp;vm_swap_data_lock_grp,
		     <span class="enscript-string">&quot;vm_swap_data&quot;</span>,
		     &amp;vm_swap_data_lock_grp_attr);
	lck_attr_setdefault(&amp;vm_swap_data_lock_attr);
	lck_mtx_init_ext(&amp;vm_swap_data_lock,
			 &amp;vm_swap_data_lock_ext,
			 &amp;vm_swap_data_lock_grp,
			 &amp;vm_swap_data_lock_attr);

	queue_init(&amp;swf_global_queue);

	
	<span class="enscript-keyword">if</span> (kernel_thread_start_priority((thread_continue_t)vm_swapout_thread, NULL,
					 BASEPRI_PREEMPT - 1, &amp;thread) != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_swapout_thread: create failed&quot;</span>);
	}
	vm_swapout_thread_id = thread-&gt;thread_id;

	thread_deallocate(thread);

	<span class="enscript-keyword">if</span> (kernel_thread_start_priority((thread_continue_t)vm_swapfile_create_thread, NULL,
				 BASEPRI_PREEMPT - 1, &amp;thread) != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_swapfile_create_thread: create failed&quot;</span>);
	}

	thread_deallocate(thread);

	<span class="enscript-keyword">if</span> (kernel_thread_start_priority((thread_continue_t)vm_swapfile_gc_thread, NULL,
				 BASEPRI_PREEMPT - 1, &amp;thread) != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_swapfile_gc_thread: create failed&quot;</span>);
	}
	thread_deallocate(thread);

	proc_set_task_policy_thread(kernel_task, thread-&gt;thread_id,
				    TASK_POLICY_INTERNAL, TASK_POLICY_IO, THROTTLE_LEVEL_COMPRESSOR_TIER2);
	proc_set_task_policy_thread(kernel_task, thread-&gt;thread_id,
				    TASK_POLICY_INTERNAL, TASK_POLICY_PASSIVE_IO, TASK_POLICY_ENABLE);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
	<span class="enscript-keyword">if</span> (swap_crypt_ctx_initialized == FALSE) {
		swap_crypt_ctx_initialize();
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>
		
	memset(swapfilename, 0, MAX_SWAPFILENAME_LEN + 1);

	vm_swap_up = TRUE;

	printf(<span class="enscript-string">&quot;VM Swap Subsystem is %s\n&quot;</span>, (vm_swap_up == TRUE) ? <span class="enscript-string">&quot;ON&quot;</span> : <span class="enscript-string">&quot;OFF&quot;</span>); 
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECORD_THE_COMPRESSED_DATA</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">c_compressed_record_init</span>()
{
	<span class="enscript-keyword">if</span> (c_compressed_record_init_done == FALSE) {
		vm_swapfile_open(<span class="enscript-string">&quot;/tmp/compressed_data&quot;</span>, &amp;c_compressed_record_vp);
		c_compressed_record_init_done = TRUE;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">c_compressed_record_write</span>(<span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> size)
{
	<span class="enscript-keyword">if</span> (c_compressed_record_write_error == 0) {
		c_compressed_record_write_error = vm_record_file_write(c_compressed_record_vp, c_compressed_record_file_offset, buf, size);
		c_compressed_record_file_offset += size;
	}
}
#<span class="enscript-reference">endif</span>



<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_file_set_tuneables</span>()
{
	<span class="enscript-type">struct</span>	vnode *vp;
	<span class="enscript-type">char</span>	*pathname;
	<span class="enscript-type">int</span>	namelen;

	<span class="enscript-keyword">if</span> (strlen(swapfilename) == 0) {
		<span class="enscript-comment">/*
		 * If no swapfile name has been set, we'll
		 * use the default name.
		 *
		 * Also, this function is only called from the vm_pageout_scan thread
		 * via vm_consider_waking_compactor_swapper, 
		 * so we don't need to worry about a race in checking/setting the name here.
		 */</span>
		strlcpy(swapfilename, SWAP_FILE_NAME, MAX_SWAPFILENAME_LEN);
	}
	namelen = (<span class="enscript-type">int</span>)strlen(swapfilename) + SWAPFILENAME_INDEX_LEN + 1;
	pathname = (<span class="enscript-type">char</span>*)kalloc(namelen);
	memset(pathname, 0, namelen);
	snprintf(pathname, namelen, <span class="enscript-string">&quot;%s%d&quot;</span>, swapfilename, 0);

	vm_swapfile_open(pathname, &amp;vp);

	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

        <span class="enscript-keyword">if</span> (vnode_pager_isSSD(vp) == FALSE)
		vm_pageout_reinit_tuneables();
	vnode_setswapmount(vp);
	vm_swappin_avail = vnode_getswappin_avail(vp);
	vm_swapfile_close((uint64_t)pathname, vp);
<span class="enscript-reference">done</span>:
	kfree(pathname, namelen);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_encrypt</span>(c_segment_t c_seg)
{
	vm_offset_t	kernel_vaddr = 0;
	uint64_t	size = 0;

	<span class="enscript-type">union</span> {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	aes_iv[AES_BLOCK_SIZE];
		<span class="enscript-type">void</span>		*c_seg;
	} encrypt_iv;
	
	assert(swap_crypt_ctx_initialized);
	
	bzero(&amp;encrypt_iv.aes_iv[0], <span class="enscript-keyword">sizeof</span> (encrypt_iv.aes_iv));

	encrypt_iv.c_seg = (<span class="enscript-type">void</span>*)c_seg;

	<span class="enscript-comment">/* encrypt the &quot;initial vector&quot; */</span>
	aes_encrypt_cbc((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) &amp;encrypt_iv.aes_iv[0],
			swap_crypt_null_iv,
			1,
			&amp;encrypt_iv.aes_iv[0],
			&amp;swap_crypt_ctx.encrypt);

	kernel_vaddr = (vm_offset_t) c_seg-&gt;c_store.c_buffer;
	size = round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset));

	<span class="enscript-comment">/*
	 * Encrypt the c_segment.
	 */</span>
	aes_encrypt_cbc((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kernel_vaddr,
			&amp;encrypt_iv.aes_iv[0],
			(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(size / AES_BLOCK_SIZE),
			(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kernel_vaddr,
			&amp;swap_crypt_ctx.encrypt);

	vm_page_encrypt_counter += (size/PAGE_SIZE_64);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_decrypt</span>(c_segment_t c_seg)
{

	vm_offset_t	kernel_vaddr = 0;
	uint64_t	size = 0;

	<span class="enscript-type">union</span> {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	aes_iv[AES_BLOCK_SIZE];
		<span class="enscript-type">void</span>		*c_seg;
	} decrypt_iv;
	
	
	assert(swap_crypt_ctx_initialized);

	<span class="enscript-comment">/*
	 * Prepare an &quot;initial vector&quot; for the decryption.
	 * It has to be the same as the &quot;initial vector&quot; we
	 * used to encrypt that page.
	 */</span>
	bzero(&amp;decrypt_iv.aes_iv[0], <span class="enscript-keyword">sizeof</span> (decrypt_iv.aes_iv));

	decrypt_iv.c_seg = (<span class="enscript-type">void</span>*)c_seg;

	<span class="enscript-comment">/* encrypt the &quot;initial vector&quot; */</span>
	aes_encrypt_cbc((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) &amp;decrypt_iv.aes_iv[0],
			swap_crypt_null_iv,
			1,
			&amp;decrypt_iv.aes_iv[0],
			&amp;swap_crypt_ctx.encrypt);
	
	kernel_vaddr = (vm_offset_t) c_seg-&gt;c_store.c_buffer;
	size = round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset));

	<span class="enscript-comment">/*
	 * Decrypt the c_segment.
	 */</span>
	aes_decrypt_cbc((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kernel_vaddr,
			&amp;decrypt_iv.aes_iv[0],
			(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size / AES_BLOCK_SIZE),
			(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kernel_vaddr,
			&amp;swap_crypt_ctx.decrypt);

	vm_page_decrypt_counter += (size/PAGE_SIZE_64);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_consider_defragmenting</span>()
{
	<span class="enscript-keyword">if</span> (compressor_store_stop_compaction == FALSE &amp;&amp; !VM_SWAP_BUSY() &amp;&amp;
	    (VM_SWAP_SHOULD_DEFRAGMENT() || VM_SWAP_SHOULD_RECLAIM())) {

		<span class="enscript-keyword">if</span> (!vm_swapfile_gc_thread_running) {
			lck_mtx_lock(&amp;vm_swap_data_lock);

			<span class="enscript-keyword">if</span> (!vm_swapfile_gc_thread_running)
				thread_wakeup((event_t) &amp;vm_swapfile_gc_needed);

			lck_mtx_unlock(&amp;vm_swap_data_lock);
		}
	}
}


<span class="enscript-type">int</span> vm_swap_defragment_yielded = 0;
<span class="enscript-type">int</span> vm_swap_defragment_swapin = 0;
<span class="enscript-type">int</span> vm_swap_defragment_free = 0;
<span class="enscript-type">int</span> vm_swap_defragment_busy = 0;


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_defragment</span>()
{
	c_segment_t	c_seg;

	<span class="enscript-comment">/*
	 * have to grab the master lock w/o holding
	 * any locks in spin mode
	 */</span>
	PAGE_REPLACEMENT_DISALLOWED(TRUE);

	lck_mtx_lock_spin_always(c_list_lock);
	
	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_swappedout_sparse_list_head)) {
		
		<span class="enscript-keyword">if</span> (compressor_store_stop_compaction == TRUE || VM_SWAP_BUSY()) {
			vm_swap_defragment_yielded++;
			<span class="enscript-keyword">break</span>;
		}
		c_seg = (c_segment_t)queue_first(&amp;c_swappedout_sparse_list_head);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		assert(c_seg-&gt;c_state == C_ON_SWAPPEDOUTSPARSE_Q);

		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {
			lck_mtx_unlock_always(c_list_lock);

			PAGE_REPLACEMENT_DISALLOWED(FALSE);
			<span class="enscript-comment">/*
			 * c_seg_wait_on_busy consumes c_seg-&gt;c_lock
			 */</span>
			c_seg_wait_on_busy(c_seg);

			PAGE_REPLACEMENT_DISALLOWED(TRUE);

			lck_mtx_lock_spin_always(c_list_lock);

			vm_swap_defragment_busy++;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used == 0) {
			<span class="enscript-comment">/*
			 * c_seg_free_locked consumes the c_list_lock
			 * and c_seg-&gt;c_lock
			 */</span>
			C_SEG_BUSY(c_seg);
			c_seg_free_locked(c_seg);

			vm_swap_defragment_free++;
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock_always(c_list_lock);

			c_seg_swapin(c_seg, TRUE);
			lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

			vm_swap_defragment_swapin++;
		}
		PAGE_REPLACEMENT_DISALLOWED(FALSE);
		
		vm_pageout_io_throttle();

		<span class="enscript-comment">/*
		 * because write waiters have privilege over readers,
		 * dropping and immediately retaking the master lock will 
		 * still allow any thread waiting to acquire the
		 * master lock exclusively an opportunity to take it
		 */</span>
		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		lck_mtx_lock_spin_always(c_list_lock);
	}
	lck_mtx_unlock_always(c_list_lock);

	PAGE_REPLACEMENT_DISALLOWED(FALSE);
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swapfile_create_thread</span>(<span class="enscript-type">void</span>)
{
	clock_sec_t	sec;
	clock_nsec_t	nsec;

	current_thread()-&gt;options |= TH_OPT_VMPRIV;

	vm_swapfile_create_thread_awakened++;
	vm_swapfile_create_thread_running = 1;

	<span class="enscript-keyword">while</span> (TRUE) {
		<span class="enscript-comment">/*
		 * walk through the list of swap files
		 * and do the delayed frees/trims for
		 * any swap file whose count of delayed
		 * frees is above the batch limit
		 */</span>
		vm_swap_handle_delayed_trims(FALSE);

		lck_mtx_lock(&amp;vm_swap_data_lock);

		clock_get_system_nanotime(&amp;sec, &amp;nsec);

		<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_CREATE(sec) == 0)
			<span class="enscript-keyword">break</span>;

		lck_mtx_unlock(&amp;vm_swap_data_lock);

		<span class="enscript-keyword">if</span> (vm_swap_create_file() == FALSE) {
			vm_swapfile_last_failed_to_create_ts = sec;
			HIBLOG(<span class="enscript-string">&quot;vm_swap_create_file failed @ %lu secs\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)sec);

		} <span class="enscript-keyword">else</span>
			vm_swapfile_last_successful_create_ts = sec;
	}
	vm_swapfile_create_thread_running = 0;

	assert_wait((event_t)&amp;vm_swapfile_create_needed, THREAD_UNINT);

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	thread_block((thread_continue_t)vm_swapfile_create_thread);
	
	<span class="enscript-comment">/* NOTREACHED */</span>
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swapfile_gc_thread</span>(<span class="enscript-type">void</span>)
{
	boolean_t	need_defragment;
	boolean_t	need_reclaim;

	vm_swapfile_gc_thread_awakened++;
	vm_swapfile_gc_thread_running = 1;

	<span class="enscript-keyword">while</span> (TRUE) {

		lck_mtx_lock(&amp;vm_swap_data_lock);
		
		<span class="enscript-keyword">if</span> (VM_SWAP_BUSY() || compressor_store_stop_compaction == TRUE)
			<span class="enscript-keyword">break</span>;

		need_defragment = FALSE;
		need_reclaim = FALSE;

		<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_DEFRAGMENT())
			need_defragment = TRUE;

		<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_RECLAIM()) {
			need_defragment = TRUE;
			need_reclaim = TRUE;
		}
		<span class="enscript-keyword">if</span> (need_defragment == FALSE &amp;&amp; need_reclaim == FALSE)
			<span class="enscript-keyword">break</span>;

		lck_mtx_unlock(&amp;vm_swap_data_lock);

		<span class="enscript-keyword">if</span> (need_defragment == TRUE)
			vm_swap_defragment();
		<span class="enscript-keyword">if</span> (need_reclaim == TRUE)
			vm_swap_reclaim();
	}
	vm_swapfile_gc_thread_running = 0;

	assert_wait((event_t)&amp;vm_swapfile_gc_needed, THREAD_UNINT);

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	thread_block((thread_continue_t)vm_swapfile_gc_thread);
	
	<span class="enscript-comment">/* NOTREACHED */</span>
}



<span class="enscript-type">int</span>	  swapper_entered_T0 = 0;
<span class="enscript-type">int</span>	  swapper_entered_T1 = 0;
<span class="enscript-type">int</span>	  swapper_entered_T2 = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swapout_thread_throttle_adjust</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> swapper_throttle_new;

	<span class="enscript-keyword">if</span> (swapper_throttle_inited == FALSE) {
		<span class="enscript-comment">/*
		 * force this thread to be set to the correct
		 * throttling tier
		 */</span>
		swapper_throttle_new = THROTTLE_LEVEL_COMPRESSOR_TIER2;
		swapper_throttle = THROTTLE_LEVEL_COMPRESSOR_TIER1;
		swapper_throttle_inited = TRUE;
		swapper_entered_T2++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	swapper_throttle_new = swapper_throttle;


	<span class="enscript-keyword">switch</span>(swapper_throttle) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_COMPRESSOR_TIER2</span>:

		<span class="enscript-keyword">if</span> (SWAPPER_NEEDS_TO_UNTHROTTLE() || swapout_target_age || hibernate_flushing == TRUE) {
			swapper_throttle_new = THROTTLE_LEVEL_COMPRESSOR_TIER1;
			swapper_entered_T1++;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_COMPRESSOR_TIER1</span>:

		<span class="enscript-keyword">if</span> (VM_PAGEOUT_SCAN_NEEDS_TO_THROTTLE()) {
			swapper_throttle_new = THROTTLE_LEVEL_COMPRESSOR_TIER0;
			swapper_entered_T0++;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (COMPRESSOR_NEEDS_TO_SWAP() == 0 &amp;&amp; swapout_target_age == 0 &amp;&amp; hibernate_flushing == FALSE) {
			swapper_throttle_new = THROTTLE_LEVEL_COMPRESSOR_TIER2;
			swapper_entered_T2++;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_COMPRESSOR_TIER0</span>:

		<span class="enscript-keyword">if</span> (COMPRESSOR_NEEDS_TO_SWAP() == 0) {
			swapper_throttle_new = THROTTLE_LEVEL_COMPRESSOR_TIER2;
			swapper_entered_T2++;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (SWAPPER_NEEDS_TO_UNTHROTTLE() == 0) {
			swapper_throttle_new = THROTTLE_LEVEL_COMPRESSOR_TIER1;
			swapper_entered_T1++;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (swapper_throttle != swapper_throttle_new) {
		proc_set_task_policy_thread(kernel_task, vm_swapout_thread_id,
					    TASK_POLICY_INTERNAL, TASK_POLICY_IO, swapper_throttle_new);
		proc_set_task_policy_thread(kernel_task, vm_swapout_thread_id,
					    TASK_POLICY_INTERNAL, TASK_POLICY_PASSIVE_IO, TASK_POLICY_ENABLE);

		swapper_throttle = swapper_throttle_new;
	}
}


<span class="enscript-type">int</span> vm_swapout_found_empty = 0;


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swapout_thread</span>(<span class="enscript-type">void</span>)
{
	uint64_t	f_offset = 0;
	uint32_t	size = 0;
	c_segment_t 	c_seg = NULL;
	kern_return_t	kr = KERN_SUCCESS;
	vm_offset_t	addr = 0;

	current_thread()-&gt;options |= TH_OPT_VMPRIV;

	vm_swapout_thread_awakened++;

	lck_mtx_lock_spin_always(c_list_lock);

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;c_swapout_list_head)) {
		
		c_seg = (c_segment_t)queue_first(&amp;c_swapout_list_head);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		assert(c_seg-&gt;c_state == C_ON_SWAPOUT_Q);

		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {
			lck_mtx_unlock_always(c_list_lock);

			c_seg_wait_on_busy(c_seg);

			lck_mtx_lock_spin_always(c_list_lock);

			<span class="enscript-keyword">continue</span>;
		}
		vm_swapout_thread_processed_segments++;

		size = round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset));
		
		<span class="enscript-keyword">if</span> (size == 0) {
			assert(c_seg-&gt;c_on_minorcompact_q);
			assert(c_seg-&gt;c_bytes_used == 0);

			c_seg_switch_state(c_seg, C_IS_EMPTY, FALSE);
			lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
			lck_mtx_unlock_always(c_list_lock);

			vm_swapout_found_empty++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">c_seg_is_empty</span>;
		}
		C_SEG_BUSY(c_seg);
		c_seg-&gt;c_busy_swapping = 1;

		lck_mtx_unlock_always(c_list_lock);

		addr = (vm_offset_t) c_seg-&gt;c_store.c_buffer;

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECKSUM_THE_SWAP</span>	
		c_seg-&gt;cseg_hash = hash_string((<span class="enscript-type">char</span>*)addr, (<span class="enscript-type">int</span>)size);
		c_seg-&gt;cseg_swap_size = size;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CHECKSUM_THE_SWAP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
		vm_swap_encrypt(c_seg);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>

		vm_swapout_thread_throttle_adjust();

		kr = vm_swap_put((vm_offset_t) addr, &amp;f_offset, size, c_seg);

		PAGE_REPLACEMENT_DISALLOWED(TRUE);

		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
			kernel_memory_depopulate(kernel_map, (vm_offset_t) addr, size, KMA_COMPRESSOR);
		}
		lck_mtx_lock_spin_always(c_list_lock);
		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

	       	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
			<span class="enscript-type">int</span>		new_state = C_ON_SWAPPEDOUT_Q;
			boolean_t	insert_head = FALSE;

			<span class="enscript-keyword">if</span> (hibernate_flushing == TRUE) {
				<span class="enscript-keyword">if</span> (c_seg-&gt;c_generation_id &gt;= first_c_segment_to_warm_generation_id &amp;&amp;
				    c_seg-&gt;c_generation_id &lt;= last_c_segment_to_warm_generation_id)
					insert_head = TRUE;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (C_SEG_ONDISK_IS_SPARSE(c_seg))
				new_state = C_ON_SWAPPEDOUTSPARSE_Q;

			c_seg_switch_state(c_seg, new_state, insert_head);

			c_seg-&gt;c_store.c_swap_handle = f_offset;

			VM_STAT_INCR_BY(swapouts, size &gt;&gt; PAGE_SHIFT);
			
			<span class="enscript-keyword">if</span> (c_seg-&gt;c_bytes_used)
				OSAddAtomic64(-c_seg-&gt;c_bytes_used, &amp;compressor_bytes_used);
		} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
			vm_swap_decrypt(c_seg);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>
			<span class="enscript-keyword">if</span> (c_seg-&gt;c_overage_swap == TRUE) {
				c_seg-&gt;c_overage_swap = FALSE;
				c_overage_swapped_count--;
			}
			c_seg_switch_state(c_seg, C_ON_AGE_Q, FALSE);
		}
		lck_mtx_unlock_always(c_list_lock);

		c_seg-&gt;c_busy_swapping = 0;
		C_SEG_WAKEUP_DONE(c_seg);
		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		PAGE_REPLACEMENT_DISALLOWED(FALSE);

		vm_pageout_io_throttle();
<span class="enscript-reference">c_seg_is_empty</span>:
		<span class="enscript-keyword">if</span> (c_swapout_count == 0)
			vm_swap_consider_defragmenting();

		lck_mtx_lock_spin_always(c_list_lock);
	}

	assert_wait((event_t)&amp;c_swapout_list_head, THREAD_UNINT);

	lck_mtx_unlock_always(c_list_lock);

	thread_block((thread_continue_t)vm_swapout_thread);
	
	<span class="enscript-comment">/* NOTREACHED */</span>
}

boolean_t
<span class="enscript-function-name">vm_swap_create_file</span>()
{
	uint64_t	size = 0;
	<span class="enscript-type">int</span>		namelen = 0;
	boolean_t	swap_file_created = FALSE;
	boolean_t	swap_file_reuse = FALSE;
	boolean_t	swap_file_pin = FALSE;
	<span class="enscript-type">struct</span> swapfile *swf = NULL;

	<span class="enscript-comment">/*
  	 * Any swapfile structure ready for re-use?
	 */</span>	 
	
	lck_mtx_lock(&amp;vm_swap_data_lock);

	swf = (<span class="enscript-type">struct</span> swapfile*) queue_first(&amp;swf_global_queue);

	<span class="enscript-keyword">while</span> (queue_end(&amp;swf_global_queue, (queue_entry_t)swf) == FALSE) {
		<span class="enscript-keyword">if</span> (swf-&gt;swp_flags == SWAP_REUSE) {
			swap_file_reuse = TRUE;
			<span class="enscript-keyword">break</span>;
		}			
		swf = (<span class="enscript-type">struct</span> swapfile*) queue_next(&amp;swf-&gt;swp_queue);
	}

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	<span class="enscript-keyword">if</span> (swap_file_reuse == FALSE) {

		<span class="enscript-keyword">if</span> (strlen(swapfilename) == 0) {
			<span class="enscript-comment">/*
			 * If no swapfile name has been set, we'll
			 * use the default name.
			 *
			 * Also, this function is only called from the swapfile management thread.
			 * So we don't need to worry about a race in checking/setting the name here.
			 */</span>

			strlcpy(swapfilename, SWAP_FILE_NAME, MAX_SWAPFILENAME_LEN);
		}

		namelen = (<span class="enscript-type">int</span>)strlen(swapfilename) + SWAPFILENAME_INDEX_LEN + 1;
			
		swf = (<span class="enscript-type">struct</span> swapfile*) kalloc(<span class="enscript-keyword">sizeof</span> *swf);
		memset(swf, 0, <span class="enscript-keyword">sizeof</span>(*swf));

		swf-&gt;swp_index = vm_num_swap_files + 1;
		swf-&gt;swp_pathlen = namelen;
		swf-&gt;swp_path = (<span class="enscript-type">char</span>*)kalloc(swf-&gt;swp_pathlen);

		memset(swf-&gt;swp_path, 0, namelen);

		snprintf(swf-&gt;swp_path, namelen, <span class="enscript-string">&quot;%s%d&quot;</span>, swapfilename, vm_num_swap_files);
	}

	vm_swapfile_open(swf-&gt;swp_path, &amp;swf-&gt;swp_vp);

	<span class="enscript-keyword">if</span> (swf-&gt;swp_vp == NULL) {
		<span class="enscript-keyword">if</span> (swap_file_reuse == FALSE) {
			kfree(swf-&gt;swp_path, swf-&gt;swp_pathlen); 
			kfree(swf, <span class="enscript-keyword">sizeof</span> *swf);
		}
		<span class="enscript-keyword">return</span> FALSE;
	}
	vm_swapfile_can_be_created = TRUE;

	size = MAX_SWAP_FILE_SIZE;

	<span class="enscript-keyword">while</span> (size &gt;= MIN_SWAP_FILE_SIZE) {

		swap_file_pin = VM_SWAP_SHOULD_PIN(size);

		<span class="enscript-keyword">if</span> (vm_swapfile_preallocate(swf-&gt;swp_vp, &amp;size, &amp;swap_file_pin) == 0) {

			<span class="enscript-type">int</span> num_bytes_for_bitmap = 0;

			swap_file_created = TRUE;

			swf-&gt;swp_size = size;
			swf-&gt;swp_nsegs = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size / COMPRESSED_SWAP_CHUNK_SIZE);
			swf-&gt;swp_nseginuse = 0;
			swf-&gt;swp_free_hint = 0;

			num_bytes_for_bitmap = MAX((swf-&gt;swp_nsegs &gt;&gt; 3) , 1);
			<span class="enscript-comment">/*
			 * Allocate a bitmap that describes the
			 * number of segments held by this swapfile.
			 */</span>
			swf-&gt;swp_bitmap = (uint8_t*)kalloc(num_bytes_for_bitmap);
			memset(swf-&gt;swp_bitmap, 0, num_bytes_for_bitmap);

			swf-&gt;swp_csegs = (c_segment_t *) kalloc(swf-&gt;swp_nsegs * <span class="enscript-keyword">sizeof</span>(c_segment_t));
			memset(swf-&gt;swp_csegs, 0, (swf-&gt;swp_nsegs * <span class="enscript-keyword">sizeof</span>(c_segment_t)));

			<span class="enscript-comment">/*
			 * passing a NULL trim_list into vnode_trim_list
			 * will return ENOTSUP if trim isn't supported
			 * and 0 if it is
			 */</span>
			<span class="enscript-keyword">if</span> (vnode_trim_list(swf-&gt;swp_vp, NULL, FALSE) == 0)
				swp_trim_supported = TRUE;

			lck_mtx_lock(&amp;vm_swap_data_lock);

			swf-&gt;swp_flags = SWAP_READY;

			<span class="enscript-keyword">if</span> (swap_file_reuse == FALSE) {
				queue_enter(&amp;swf_global_queue, swf, <span class="enscript-type">struct</span> swapfile*, swp_queue);
			}
			
			vm_num_swap_files++;

			vm_swapfile_total_segs_alloced += swf-&gt;swp_nsegs;

			<span class="enscript-keyword">if</span> (swap_file_pin == TRUE) {
				swf-&gt;swp_flags |= SWAP_PINNED;
				vm_swappin_avail -= swf-&gt;swp_size;
			}

			lck_mtx_unlock(&amp;vm_swap_data_lock);

			thread_wakeup((event_t) &amp;vm_num_swap_files);
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {

			size = size / 2;
		}
	}
	<span class="enscript-keyword">if</span> (swap_file_created == FALSE) {

		vm_swapfile_close((uint64_t)(swf-&gt;swp_path), swf-&gt;swp_vp);

		swf-&gt;swp_vp = NULL;

		<span class="enscript-keyword">if</span> (swap_file_reuse == FALSE) {
			kfree(swf-&gt;swp_path, swf-&gt;swp_pathlen); 
			kfree(swf, <span class="enscript-keyword">sizeof</span> *swf);
		}
	}
	<span class="enscript-keyword">return</span> swap_file_created;
}


kern_return_t
<span class="enscript-function-name">vm_swap_get</span>(vm_offset_t addr, uint64_t f_offset, uint64_t size)
{
	<span class="enscript-type">struct</span> swapfile *swf = NULL;
	uint64_t	file_offset = 0;
	<span class="enscript-type">int</span>		retval = 0;

	<span class="enscript-keyword">if</span> (addr == 0) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	lck_mtx_lock(&amp;vm_swap_data_lock);

	swf = vm_swapfile_for_handle(f_offset);

	<span class="enscript-keyword">if</span> (swf == NULL || ( !(swf-&gt;swp_flags &amp; SWAP_READY) &amp;&amp; !(swf-&gt;swp_flags &amp; SWAP_RECLAIM))) {
		retval = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	swf-&gt;swp_io_count++;

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	file_offset = (f_offset &amp; SWAP_SLOT_MASK);
	retval = vm_swapfile_io(swf-&gt;swp_vp, file_offset, addr, (<span class="enscript-type">int</span>)(size / PAGE_SIZE_64), SWAP_READ);

	<span class="enscript-keyword">if</span> (retval == 0)
		VM_STAT_INCR_BY(swapins, size &gt;&gt; PAGE_SHIFT);
	<span class="enscript-keyword">else</span>
		vm_swap_get_failures++;

	<span class="enscript-comment">/*
	 * Free this slot in the swap structure.
	 */</span>
	vm_swap_free(f_offset);

	lck_mtx_lock(&amp;vm_swap_data_lock);
	swf-&gt;swp_io_count--;

	<span class="enscript-keyword">if</span> ((swf-&gt;swp_flags &amp; SWAP_WANTED) &amp;&amp; swf-&gt;swp_io_count == 0) {
	
		swf-&gt;swp_flags &amp;= ~SWAP_WANTED;
		thread_wakeup((event_t) &amp;swf-&gt;swp_flags);
	}
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(&amp;vm_swap_data_lock);

	<span class="enscript-keyword">if</span> (retval == 0)
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">vm_swap_put</span>(vm_offset_t addr, uint64_t *f_offset, uint64_t size, c_segment_t c_seg)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	segidx = 0;
	<span class="enscript-type">struct</span> swapfile *swf = NULL;
	uint64_t	file_offset = 0;
	uint64_t	swapfile_index = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	byte_for_segidx = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	offset_within_byte = 0;
	boolean_t	swf_eligible = FALSE;
	boolean_t	waiting = FALSE;
	boolean_t	retried = FALSE;
	<span class="enscript-type">int</span>		error = 0;
	clock_sec_t	sec;
	clock_nsec_t	nsec;

	<span class="enscript-keyword">if</span> (addr == 0 || f_offset == NULL) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
<span class="enscript-reference">retry</span>:
	lck_mtx_lock(&amp;vm_swap_data_lock);

	swf = (<span class="enscript-type">struct</span> swapfile*) queue_first(&amp;swf_global_queue);

	<span class="enscript-keyword">while</span>(queue_end(&amp;swf_global_queue, (queue_entry_t)swf) == FALSE) {
	
		segidx = swf-&gt;swp_free_hint;

		swf_eligible = 	(swf-&gt;swp_flags &amp; SWAP_READY) &amp;&amp; (swf-&gt;swp_nseginuse &lt; swf-&gt;swp_nsegs);

		<span class="enscript-keyword">if</span> (swf_eligible) {

			<span class="enscript-keyword">while</span>(segidx &lt; swf-&gt;swp_nsegs) {
				
				byte_for_segidx = segidx &gt;&gt; 3;
				offset_within_byte = segidx % 8;
			
				<span class="enscript-keyword">if</span> ((swf-&gt;swp_bitmap)[byte_for_segidx] &amp; (1 &lt;&lt; offset_within_byte)) {
					segidx++;
					<span class="enscript-keyword">continue</span>;
				}
		
				(swf-&gt;swp_bitmap)[byte_for_segidx] |= (1 &lt;&lt; offset_within_byte);

				file_offset = segidx * COMPRESSED_SWAP_CHUNK_SIZE;
				swf-&gt;swp_nseginuse++;
				swf-&gt;swp_io_count++;
				swapfile_index = swf-&gt;swp_index;

				vm_swapfile_total_segs_used++;

				clock_get_system_nanotime(&amp;sec, &amp;nsec);

				<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_CREATE(sec) &amp;&amp; !vm_swapfile_create_thread_running)
					thread_wakeup((event_t) &amp;vm_swapfile_create_needed);

				lck_mtx_unlock(&amp;vm_swap_data_lock);
		
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
		swf = (<span class="enscript-type">struct</span> swapfile*) queue_next(&amp;swf-&gt;swp_queue);
	}
	assert(queue_end(&amp;swf_global_queue, (queue_entry_t) swf));
	
	<span class="enscript-comment">/*
	 * we've run out of swap segments, but may not
	 * be in a position to immediately create a new swap
	 * file if we've recently failed to create due to a lack
	 * of free space in the root filesystem... we'll try
	 * to kick that create off, but in any event we're going
	 * to take a breather (up to 1 second) so that we're not caught in a tight
	 * loop back in &quot;vm_compressor_compact_and_swap&quot; trying to stuff
	 * segments into swap files only to have them immediately put back
	 * on the c_age queue due to vm_swap_put failing.
	 *
	 * if we're doing these puts due to a hibernation flush,
	 * no need to block... setting hibernate_no_swapspace to TRUE,
	 * will cause &quot;vm_compressor_compact_and_swap&quot; to immediately abort
	 */</span>
	clock_get_system_nanotime(&amp;sec, &amp;nsec);

	<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_CREATE(sec) &amp;&amp; !vm_swapfile_create_thread_running)
		thread_wakeup((event_t) &amp;vm_swapfile_create_needed);

	<span class="enscript-keyword">if</span> (hibernate_flushing == FALSE || VM_SWAP_SHOULD_CREATE(sec)) {
		waiting = TRUE;
		assert_wait_timeout((event_t) &amp;vm_num_swap_files, THREAD_INTERRUPTIBLE, 1000, 1000*NSEC_PER_USEC);
	} <span class="enscript-keyword">else</span>
		hibernate_no_swapspace = TRUE;

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	<span class="enscript-keyword">if</span> (waiting == TRUE) {
		thread_block(THREAD_CONTINUE_NULL);

		<span class="enscript-keyword">if</span> (retried == FALSE &amp;&amp; hibernate_flushing == TRUE) {
			retried = TRUE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
	}
	vm_swap_put_failures++;

	<span class="enscript-keyword">return</span> KERN_FAILURE;

<span class="enscript-reference">done</span>:	
	error = vm_swapfile_io(swf-&gt;swp_vp, file_offset, addr, (<span class="enscript-type">int</span>) (size / PAGE_SIZE_64), SWAP_WRITE);

	lck_mtx_lock(&amp;vm_swap_data_lock);

	swf-&gt;swp_csegs[segidx] = c_seg;

	swf-&gt;swp_io_count--;

	*f_offset = (swapfile_index &lt;&lt; SWAP_DEVICE_SHIFT) | file_offset;

	<span class="enscript-keyword">if</span> ((swf-&gt;swp_flags &amp; SWAP_WANTED) &amp;&amp; swf-&gt;swp_io_count == 0) {
	
		swf-&gt;swp_flags &amp;= ~SWAP_WANTED;
		thread_wakeup((event_t) &amp;swf-&gt;swp_flags);
	}

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	<span class="enscript-keyword">if</span> (error) {
		vm_swap_free(*f_offset);

		vm_swap_put_failures++;

		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_free_now</span>(<span class="enscript-type">struct</span> swapfile *swf, uint64_t f_offset)
{
	uint64_t	file_offset = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	segidx = 0;


	<span class="enscript-keyword">if</span> ((swf-&gt;swp_flags &amp; SWAP_READY) || (swf-&gt;swp_flags &amp; SWAP_RECLAIM)) {

		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> byte_for_segidx = 0;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> offset_within_byte = 0;

		file_offset = (f_offset &amp; SWAP_SLOT_MASK);
		segidx = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (file_offset / COMPRESSED_SWAP_CHUNK_SIZE);
			
		byte_for_segidx = segidx &gt;&gt; 3;
		offset_within_byte = segidx % 8;

		<span class="enscript-keyword">if</span> ((swf-&gt;swp_bitmap)[byte_for_segidx] &amp; (1 &lt;&lt; offset_within_byte)) {
				
			(swf-&gt;swp_bitmap)[byte_for_segidx] &amp;= ~(1 &lt;&lt; offset_within_byte);

			swf-&gt;swp_csegs[segidx] = NULL;

			swf-&gt;swp_nseginuse--;
			vm_swapfile_total_segs_used--;

			<span class="enscript-keyword">if</span> (segidx &lt; swf-&gt;swp_free_hint) {
				swf-&gt;swp_free_hint = segidx;
			}
		}
		<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_RECLAIM() &amp;&amp; !vm_swapfile_gc_thread_running)
			thread_wakeup((event_t) &amp;vm_swapfile_gc_needed);
	}
}


uint32_t vm_swap_free_now_count = 0;
uint32_t vm_swap_free_delayed_count = 0;


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_free</span>(uint64_t f_offset)
{
	<span class="enscript-type">struct</span> swapfile *swf = NULL;
	<span class="enscript-type">struct</span> trim_list *tl = NULL;
        clock_sec_t     sec;
        clock_nsec_t    nsec;

	<span class="enscript-keyword">if</span> (swp_trim_supported == TRUE)
		tl = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> trim_list));

	lck_mtx_lock(&amp;vm_swap_data_lock);

	swf = vm_swapfile_for_handle(f_offset);

	<span class="enscript-keyword">if</span> (swf &amp;&amp; (swf-&gt;swp_flags &amp; (SWAP_READY | SWAP_RECLAIM))) {

		<span class="enscript-keyword">if</span> (swp_trim_supported == FALSE || (swf-&gt;swp_flags &amp; SWAP_RECLAIM)) {
			<span class="enscript-comment">/*
			 * don't delay the free if the underlying disk doesn't support
			 * trim, or we're in the midst of reclaiming this swap file since
			 * we don't want to move segments that are technically free
			 * but not yet handled by the delayed free mechanism
			 */</span>
			vm_swap_free_now(swf, f_offset);

			vm_swap_free_now_count++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		tl-&gt;tl_offset = f_offset &amp; SWAP_SLOT_MASK;
		tl-&gt;tl_length = COMPRESSED_SWAP_CHUNK_SIZE;

		tl-&gt;tl_next = swf-&gt;swp_delayed_trim_list_head;
		swf-&gt;swp_delayed_trim_list_head = tl;
		swf-&gt;swp_delayed_trim_count++;
		tl = NULL;

		<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_TRIM(swf) &amp;&amp; !vm_swapfile_create_thread_running) {
			clock_get_system_nanotime(&amp;sec, &amp;nsec);

			<span class="enscript-keyword">if</span> (sec &gt; dont_trim_until_ts)
				thread_wakeup((event_t) &amp;vm_swapfile_create_needed);
		}
		vm_swap_free_delayed_count++;
	}
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(&amp;vm_swap_data_lock);

	<span class="enscript-keyword">if</span> (tl != NULL)
		kfree(tl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> trim_list));
}	


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_wait_on_trim_handling_in_progress</span>()
{
	<span class="enscript-keyword">while</span> (delayed_trim_handling_in_progress == TRUE) {

		assert_wait((event_t) &amp;delayed_trim_handling_in_progress, THREAD_UNINT);
		lck_mtx_unlock(&amp;vm_swap_data_lock);
		
		thread_block(THREAD_CONTINUE_NULL);
		
		lck_mtx_lock(&amp;vm_swap_data_lock);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_handle_delayed_trims</span>(boolean_t force_now)
{
	<span class="enscript-type">struct</span> swapfile *swf = NULL;

	<span class="enscript-comment">/*
	 * serialize the race between us and vm_swap_reclaim...
	 * if vm_swap_reclaim wins it will turn off SWAP_READY
	 * on the victim it has chosen... we can just skip over
	 * that file since vm_swap_reclaim will first process
	 * all of the delayed trims associated with it
	 */</span>
	lck_mtx_lock(&amp;vm_swap_data_lock);

	delayed_trim_handling_in_progress = TRUE;

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	<span class="enscript-comment">/*
	 * no need to hold the lock to walk the swf list since
	 * vm_swap_create (the only place where we add to this list)
	 * is run on the same thread as this function
	 * and vm_swap_reclaim doesn't remove items from this list
	 * instead marking them with SWAP_REUSE for future re-use
	 */</span>
	swf = (<span class="enscript-type">struct</span> swapfile*) queue_first(&amp;swf_global_queue);

	<span class="enscript-keyword">while</span> (queue_end(&amp;swf_global_queue, (queue_entry_t)swf) == FALSE) {

		<span class="enscript-keyword">if</span> ((swf-&gt;swp_flags &amp; SWAP_READY) &amp;&amp; (force_now == TRUE || VM_SWAP_SHOULD_TRIM(swf))) {

			assert(!(swf-&gt;swp_flags &amp; SWAP_RECLAIM));
			vm_swap_do_delayed_trim(swf);
		}
		swf = (<span class="enscript-type">struct</span> swapfile*) queue_next(&amp;swf-&gt;swp_queue);
	}
	lck_mtx_lock(&amp;vm_swap_data_lock);

	delayed_trim_handling_in_progress = FALSE;
	thread_wakeup((event_t) &amp;delayed_trim_handling_in_progress);

	<span class="enscript-keyword">if</span> (VM_SWAP_SHOULD_RECLAIM() &amp;&amp; !vm_swapfile_gc_thread_running)
		thread_wakeup((event_t) &amp;vm_swapfile_gc_needed);

	lck_mtx_unlock(&amp;vm_swap_data_lock);

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_do_delayed_trim</span>(<span class="enscript-type">struct</span> swapfile *swf)
{
	<span class="enscript-type">struct</span> trim_list *tl, *tl_head;

	lck_mtx_lock(&amp;vm_swap_data_lock);

	tl_head = swf-&gt;swp_delayed_trim_list_head;
	swf-&gt;swp_delayed_trim_list_head = NULL;
	swf-&gt;swp_delayed_trim_count = 0;

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	vnode_trim_list(swf-&gt;swp_vp, tl_head, TRUE);
	
	<span class="enscript-keyword">while</span> ((tl = tl_head) != NULL) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	segidx = 0;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	byte_for_segidx = 0;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	offset_within_byte = 0;

		lck_mtx_lock(&amp;vm_swap_data_lock);

		segidx = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (tl-&gt;tl_offset / COMPRESSED_SWAP_CHUNK_SIZE);
			
		byte_for_segidx = segidx &gt;&gt; 3;
		offset_within_byte = segidx % 8;

		<span class="enscript-keyword">if</span> ((swf-&gt;swp_bitmap)[byte_for_segidx] &amp; (1 &lt;&lt; offset_within_byte)) {
				
			(swf-&gt;swp_bitmap)[byte_for_segidx] &amp;= ~(1 &lt;&lt; offset_within_byte);
			
			swf-&gt;swp_csegs[segidx] = NULL;

			swf-&gt;swp_nseginuse--;
			vm_swapfile_total_segs_used--;

			<span class="enscript-keyword">if</span> (segidx &lt; swf-&gt;swp_free_hint) {
				swf-&gt;swp_free_hint = segidx;
			}
		}
		lck_mtx_unlock(&amp;vm_swap_data_lock);

		tl_head = tl-&gt;tl_next;

		kfree(tl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> trim_list));
	}		
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_flush</span>()
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span>	vm_swap_reclaim_yielded = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swap_reclaim</span>(<span class="enscript-type">void</span>)
{
	vm_offset_t	addr = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	segidx = 0;
	uint64_t	f_offset = 0;
	<span class="enscript-type">struct</span> swapfile *swf = NULL;
	<span class="enscript-type">struct</span> swapfile *smallest_swf = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	min_nsegs = 0;	
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	byte_for_segidx = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	offset_within_byte = 0;
	uint32_t	c_size = 0;

	c_segment_t	c_seg = NULL;
	
	<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, (vm_offset_t *)(&amp;addr), C_SEG_BUFSIZE, 0, KMA_KOBJECT, VM_KERN_MEMORY_COMPRESSOR) != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_swap_reclaim: kernel_memory_allocate failed\n&quot;</span>);
	}

	lck_mtx_lock(&amp;vm_swap_data_lock);

	<span class="enscript-comment">/*
	 * if we're running the swapfile list looking for
	 * candidates with delayed trims, we need to
	 * wait before making our decision concerning
	 * the swapfile we want to reclaim
	 */</span>
	vm_swap_wait_on_trim_handling_in_progress();

	<span class="enscript-comment">/*
	 * from here until we knock down the SWAP_READY bit,
	 * we need to remain behind the vm_swap_data_lock...
	 * once that bit has been turned off, &quot;vm_swap_handle_delayed_trims&quot;
	 * will not consider this swapfile for processing
	 */</span>
	swf = (<span class="enscript-type">struct</span> swapfile*) queue_first(&amp;swf_global_queue);
	min_nsegs = MAX_SWAP_FILE_SIZE / COMPRESSED_SWAP_CHUNK_SIZE;
	smallest_swf = NULL;

	<span class="enscript-keyword">while</span> (queue_end(&amp;swf_global_queue, (queue_entry_t)swf) == FALSE) {

		<span class="enscript-keyword">if</span> ((swf-&gt;swp_flags &amp; SWAP_READY) &amp;&amp; (swf-&gt;swp_nseginuse &lt;= min_nsegs)) {

			smallest_swf = swf;
			min_nsegs = swf-&gt;swp_nseginuse;
		}			
		swf = (<span class="enscript-type">struct</span> swapfile*) queue_next(&amp;swf-&gt;swp_queue);
	}
	
	<span class="enscript-keyword">if</span> (smallest_swf == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	swf = smallest_swf;


	swf-&gt;swp_flags &amp;= ~SWAP_READY;
	swf-&gt;swp_flags |= SWAP_RECLAIM;

	<span class="enscript-keyword">if</span> (swf-&gt;swp_delayed_trim_count) {

		lck_mtx_unlock(&amp;vm_swap_data_lock);

		vm_swap_do_delayed_trim(swf);

		lck_mtx_lock(&amp;vm_swap_data_lock);
	}
	segidx = 0;

	<span class="enscript-keyword">while</span> (segidx &lt; swf-&gt;swp_nsegs) {

<span class="enscript-reference">ReTry_for_cseg</span>:	
		<span class="enscript-comment">/*
		 * Wait for outgoing I/Os.
		 */</span>
		<span class="enscript-keyword">while</span> (swf-&gt;swp_io_count) {

			swf-&gt;swp_flags |= SWAP_WANTED;

			assert_wait((event_t) &amp;swf-&gt;swp_flags, THREAD_UNINT);
			lck_mtx_unlock(&amp;vm_swap_data_lock);
		
			thread_block(THREAD_CONTINUE_NULL);
		
			lck_mtx_lock(&amp;vm_swap_data_lock);
		}
	        <span class="enscript-keyword">if</span> (compressor_store_stop_compaction == TRUE || VM_SWAP_SHOULD_ABORT_RECLAIM() || VM_SWAP_BUSY()) {
			vm_swap_reclaim_yielded++;
			<span class="enscript-keyword">break</span>;
		}

		byte_for_segidx = segidx &gt;&gt; 3;
		offset_within_byte = segidx % 8;

		<span class="enscript-keyword">if</span> (((swf-&gt;swp_bitmap)[byte_for_segidx] &amp; (1 &lt;&lt; offset_within_byte)) == 0) {

			segidx++;
			<span class="enscript-keyword">continue</span>;
		}

		c_seg = swf-&gt;swp_csegs[segidx];
		assert(c_seg);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">if</span> (c_seg-&gt;c_busy) {
			<span class="enscript-comment">/*
			 * a swapped out c_segment in the process of being freed will remain in the
			 * busy state until after the vm_swap_free is called on it... vm_swap_free
			 * takes the vm_swap_data_lock, so can't change the swap state until after
			 * we drop the vm_swap_data_lock... once we do, vm_swap_free will complete
			 * which will allow c_seg_free_locked to clear busy and wake up this thread...
			 * at that point, we re-look up the swap state which will now indicate that
			 * this c_segment no longer exists.
			 */</span>
			c_seg-&gt;c_wanted = 1;
			
			assert_wait((event_t) (c_seg), THREAD_UNINT);
			lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
			
			lck_mtx_unlock(&amp;vm_swap_data_lock);
			
			thread_block(THREAD_CONTINUE_NULL);

			lck_mtx_lock(&amp;vm_swap_data_lock);
			
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ReTry_for_cseg</span>;
		}
		(swf-&gt;swp_bitmap)[byte_for_segidx] &amp;= ~(1 &lt;&lt; offset_within_byte);

		f_offset = segidx * COMPRESSED_SWAP_CHUNK_SIZE;

		assert(c_seg == swf-&gt;swp_csegs[segidx]);
		swf-&gt;swp_csegs[segidx] = NULL;
		swf-&gt;swp_nseginuse--;

		vm_swapfile_total_segs_used--;
			
		lck_mtx_unlock(&amp;vm_swap_data_lock);

		assert(C_SEG_IS_ONDISK(c_seg));	

		C_SEG_BUSY(c_seg);
		c_seg-&gt;c_busy_swapping = 1;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CHECKSUM_THE_SWAP</span>
		c_seg_trim_tail(c_seg);
#<span class="enscript-reference">endif</span>
		c_size = round_page_32(C_SEG_OFFSET_TO_BYTES(c_seg-&gt;c_populated_offset));
		
		assert(c_size &lt;= C_SEG_BUFSIZE &amp;&amp; c_size);

		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);

		<span class="enscript-keyword">if</span> (vm_swapfile_io(swf-&gt;swp_vp, f_offset, addr, (<span class="enscript-type">int</span>)(c_size / PAGE_SIZE_64), SWAP_READ)) {

			<span class="enscript-comment">/*
			 * reading the data back in failed, so convert c_seg
			 * to a swapped in c_segment that contains no data
			 */</span>
			c_seg_swapin_requeue(c_seg, FALSE);
			<span class="enscript-comment">/*
			 * returns with c_busy_swapping cleared
			 */</span>

			vm_swap_get_failures++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">swap_io_failed</span>;
		}
		VM_STAT_INCR_BY(swapins, c_size &gt;&gt; PAGE_SHIFT);

		<span class="enscript-keyword">if</span> (vm_swap_put(addr, &amp;f_offset, c_size, c_seg)) {
			vm_offset_t	c_buffer;

			<span class="enscript-comment">/*
			 * the put failed, so convert c_seg to a fully swapped in c_segment
			 * with valid data
			 */</span>
			c_buffer = (vm_offset_t)C_SEG_BUFFER_ADDRESS(c_seg-&gt;c_mysegno);

			kernel_memory_populate(kernel_map, c_buffer, c_size, KMA_COMPRESSOR, VM_KERN_MEMORY_COMPRESSOR);

			memcpy((<span class="enscript-type">char</span> *)c_buffer, (<span class="enscript-type">char</span> *)addr, c_size);

			c_seg-&gt;c_store.c_buffer = (int32_t *)c_buffer;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
			vm_swap_decrypt(c_seg);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENCRYPTED_SWAP */</span>
			c_seg_swapin_requeue(c_seg, TRUE);
			<span class="enscript-comment">/*
			 * returns with c_busy_swapping cleared
			 */</span>
			OSAddAtomic64(c_seg-&gt;c_bytes_used, &amp;compressor_bytes_used);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">swap_io_failed</span>;
		}
		VM_STAT_INCR_BY(swapouts, c_size &gt;&gt; PAGE_SHIFT);

		lck_mtx_lock_spin_always(&amp;c_seg-&gt;c_lock);
				
		assert(C_SEG_IS_ONDISK(c_seg));
		<span class="enscript-comment">/*
		 * The c_seg will now know about the new location on disk.
		 */</span>
		c_seg-&gt;c_store.c_swap_handle = f_offset;
		c_seg-&gt;c_busy_swapping = 0;
<span class="enscript-reference">swap_io_failed</span>:
		C_SEG_WAKEUP_DONE(c_seg);
				
		lck_mtx_unlock_always(&amp;c_seg-&gt;c_lock);
		lck_mtx_lock(&amp;vm_swap_data_lock);
	}

	<span class="enscript-keyword">if</span> (swf-&gt;swp_nseginuse) {

		swf-&gt;swp_flags &amp;= ~SWAP_RECLAIM;
		swf-&gt;swp_flags |= SWAP_READY;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
  	 * We don't remove this inactive swf from the queue.
	 * That way, we can re-use it when needed again and
	 * preserve the namespace. The delayed_trim processing
	 * is also dependent on us not removing swfs from the queue.
	 */</span>	 
	<span class="enscript-comment">//queue_remove(&amp;swf_global_queue, swf, struct swapfile*, swp_queue);
</span>
	vm_num_swap_files--;

	vm_swapfile_total_segs_alloced -= swf-&gt;swp_nsegs;

	lck_mtx_unlock(&amp;vm_swap_data_lock);

	vm_swapfile_close((uint64_t)(swf-&gt;swp_path), swf-&gt;swp_vp);

	kfree(swf-&gt;swp_csegs, swf-&gt;swp_nsegs * <span class="enscript-keyword">sizeof</span>(c_segment_t));
	kfree(swf-&gt;swp_bitmap, MAX((swf-&gt;swp_nsegs &gt;&gt; 3), 1));
	
	lck_mtx_lock(&amp;vm_swap_data_lock);

	<span class="enscript-keyword">if</span> (swf-&gt;swp_flags &amp; SWAP_PINNED) {
		vm_swappin_avail += swf-&gt;swp_size;
	}

	swf-&gt;swp_vp = NULL;	
	swf-&gt;swp_size = 0;
	swf-&gt;swp_free_hint = 0;
	swf-&gt;swp_nsegs = 0;
	swf-&gt;swp_flags = SWAP_REUSE;

<span class="enscript-reference">done</span>:
	thread_wakeup((event_t) &amp;swf-&gt;swp_flags);
	lck_mtx_unlock(&amp;vm_swap_data_lock);

	kmem_free(kernel_map, (vm_offset_t) addr, C_SEG_BUFSIZE);
}


uint64_t
<span class="enscript-function-name">vm_swap_get_total_space</span>(<span class="enscript-type">void</span>)
{
	uint64_t total_space = 0;

	total_space = (uint64_t)vm_swapfile_total_segs_alloced * COMPRESSED_SWAP_CHUNK_SIZE;

	<span class="enscript-keyword">return</span> total_space;
}

uint64_t
<span class="enscript-function-name">vm_swap_get_used_space</span>(<span class="enscript-type">void</span>)
{
	uint64_t used_space = 0;

	used_space = (uint64_t)vm_swapfile_total_segs_used * COMPRESSED_SWAP_CHUNK_SIZE;

	<span class="enscript-keyword">return</span> used_space;
}

uint64_t
<span class="enscript-function-name">vm_swap_get_free_space</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (vm_swap_get_total_space() - vm_swap_get_used_space());
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_swap_low_on_space</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-keyword">if</span> (vm_num_swap_files == 0 &amp;&amp; vm_swapfile_can_be_created == FALSE)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (((vm_swapfile_total_segs_alloced - vm_swapfile_total_segs_used) &lt; ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)VM_SWAPFILE_HIWATER_SEGS) / 8)) {

		<span class="enscript-keyword">if</span> (vm_num_swap_files == 0 &amp;&amp; !SWAPPER_NEEDS_TO_UNTHROTTLE())
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (vm_swapfile_last_failed_to_create_ts &gt;= vm_swapfile_last_successful_create_ts)
			<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>