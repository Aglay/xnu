<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_external.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_external.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>

<span class="enscript-comment">/*
 *	This module maintains information about the presence of
 *	pages not in memory.  Since an external memory object
 *	must maintain a complete knowledge of its contents, this
 *	information takes the form of hints.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>	<span class="enscript-comment">/* for memcpy()/memset() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_external.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

<span class="enscript-comment">/*
 *	The implementation uses bit arrays to record whether
 *	a page has been written to external storage.  For
 *	convenience, these bit arrays come in various sizes.
 *	For example, a map N bytes long can record:
 *
 *	  16 bytes =   128 pages = (@ 4KB/page)    512KB
 *	1024 bytes =  8192 pages = (@ 4KB/page)  32MB
 *	4096 bytes = 32768 pages = (@ 4KB/page) 128MB
 *
 *	For a 32-bit machine with 4KB pages, the largest size
 *	would be 128KB = 32 pages. Machines with a larger page
 *	size are more efficient.
 *
 *	This subsystem must be very careful about memory allocation,
 *	since vm_external_create() is almost always called with
 *	vm_privilege set. The largest map to be allocated must be less
 *	than or equal to a single page, and the kalloc subsystem must
 *	never allocate more than a single page in response to a kalloc()
 *	request. Also, vm_external_destroy() must not take any blocking
 *	locks, since it is called with a vm_object lock held. This
 *	implies that kfree() MUST be implemented in terms of zfree()
 *	NOT kmem_free() for all request sizes that this subsystem uses.
 *
 *	For efficiency, this subsystem knows that the kalloc() subsystem
 *	is implemented in terms of power-of-2 allocation, and that the
 *	minimum allocation unit is KALLOC_MINSIZE
 * 
 *	XXXO
 *	Should consider using existence_map to hold bits directly
 *	when existence_size &lt;= 4 bytes (i.e., 32 pages).
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SMALL_SIZE</span>	KALLOC_MINSIZE
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LARGE_SIZE</span>	PAGE_SIZE

<span class="enscript-type">static</span> vm_object_size_t <span class="enscript-function-name">power_of_2</span>(vm_object_size_t size);

<span class="enscript-type">static</span> vm_object_size_t
<span class="enscript-function-name">power_of_2</span>(vm_object_size_t size)
{
	vm_object_size_t power;

	power = 2 * SMALL_SIZE;
	<span class="enscript-keyword">while</span> (power &lt; size) {
		power &lt;&lt;= 1;
	}
	<span class="enscript-keyword">return</span>(power);
}

vm_external_map_t
<span class="enscript-function-name">vm_external_create</span>(
	vm_object_offset_t	size)
{
	vm_object_size_t	bytes;
	vm_external_map_t	result = VM_EXTERNAL_NULL;

	bytes = stob(size);
	<span class="enscript-keyword">if</span> (bytes &lt;= SMALL_SIZE) {
		result = (vm_external_map_t)kalloc(SMALL_SIZE);
		<span class="enscript-keyword">if</span> (result != NULL) {
			memset(result, 0, SMALL_SIZE);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bytes &lt;= LARGE_SIZE) {
		bytes = power_of_2(bytes);

		assert((vm_size_t) bytes == bytes);
		result = (vm_external_map_t)kalloc((vm_size_t)bytes);
		<span class="enscript-keyword">if</span> (result != NULL) {
			assert((size_t) bytes == bytes);
			memset(result, 0, (size_t) bytes);
		}
	}
	<span class="enscript-keyword">return</span>(result);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_external_destroy</span>(
	vm_external_map_t	map,
	vm_object_size_t	size)
{
	vm_object_size_t bytes;

	<span class="enscript-keyword">if</span> (map == VM_EXTERNAL_NULL)
		<span class="enscript-keyword">return</span>;

	bytes = stob(size);
	<span class="enscript-keyword">if</span> (bytes &lt;= SMALL_SIZE) {
		bytes = SMALL_SIZE;
	} <span class="enscript-keyword">else</span> {
		bytes = power_of_2(bytes);
	}
	assert((vm_size_t) bytes == bytes);
	kfree(map, (vm_size_t) bytes);
}

<span class="enscript-comment">/*
 * Return the number of bytes needed for a vm_external_map given the
 * size of the object to be mapped, i.e. the size of the map that was
 * created by vm_external_create.
 */</span>
vm_object_size_t
<span class="enscript-function-name">vm_external_map_size</span>(
	vm_object_size_t	size)
{
	vm_object_size_t	bytes;

	bytes = stob(size);
	<span class="enscript-keyword">if</span> (bytes != 0) {
	        <span class="enscript-keyword">if</span> (bytes &lt;= SMALL_SIZE) {
			bytes = SMALL_SIZE;
		} <span class="enscript-keyword">else</span> {
			bytes = power_of_2(bytes);
		}
	}
	<span class="enscript-keyword">return</span> bytes;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_external_copy</span>(
	vm_external_map_t	old_map,
	vm_object_size_t	old_size,
	vm_external_map_t	new_map)
{
	vm_object_size_t	bytes;

	<span class="enscript-comment">/*
	 * Cannot copy non-existent maps
	 */</span>
	<span class="enscript-keyword">if</span> ((old_map == VM_EXTERNAL_NULL) || (new_map == VM_EXTERNAL_NULL))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Copy old map to new
	 */</span>
	bytes = stob(old_size);
	assert((size_t) bytes == bytes);
	memcpy(new_map, old_map, (size_t) bytes);
}

boolean_t
<span class="enscript-function-name">vm_external_within</span>(
	vm_object_size_t	new_size,
	vm_object_size_t	old_size)
{
	vm_object_size_t 	new_bytes;
	vm_object_size_t 	old_bytes;

	assert(new_size &gt;= old_size);

	<span class="enscript-comment">/*
	 * &quot;old_bytes&quot; is calculated to be the actual amount of space
	 * allocated for a map of size &quot;old_size&quot;.
	 */</span>
	old_bytes = stob(old_size);
	<span class="enscript-keyword">if</span> (old_bytes &lt;= SMALL_SIZE) old_bytes = SMALL_SIZE;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_bytes &lt;= LARGE_SIZE) old_bytes = power_of_2(old_bytes);

	<span class="enscript-comment">/*
	 * &quot;new_bytes&quot; is the map size required to map the &quot;new_size&quot; object.
	 * Since the rounding algorithms are the same, we needn't actually
	 * round up new_bytes to get the correct answer
	 */</span>
	new_bytes = stob(new_size);

	<span class="enscript-keyword">return</span>(new_bytes &lt;= old_bytes);
}

vm_external_state_t
<span class="enscript-function-name">_vm_external_state_get</span>(
	vm_external_map_t	map,
	vm_object_offset_t	offset)
{
	uint64_t		bit, byte;

	assert (map != VM_EXTERNAL_NULL);

	bit = atop_64(offset);
	byte = bit &gt;&gt; 3;
	<span class="enscript-keyword">if</span> (map[byte] &amp; (1 &lt;&lt; (bit &amp; 07))) {
		<span class="enscript-keyword">return</span> VM_EXTERNAL_STATE_EXISTS;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> VM_EXTERNAL_STATE_ABSENT;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_external_state_set</span>(
	vm_external_map_t	map,
	vm_object_offset_t	offset)
{
	uint64_t		bit, byte;

	<span class="enscript-keyword">if</span> (map == VM_EXTERNAL_NULL)
		<span class="enscript-keyword">return</span>;

	bit = atop_64(offset);
	byte = bit &gt;&gt; 3;
	map[byte] |= (1 &lt;&lt; (bit &amp; 07));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_external_state_clr</span>(
	vm_external_map_t	map,
	vm_object_offset_t	offset)
{
	uint64_t		bit, byte;

	<span class="enscript-keyword">if</span> (map == VM_EXTERNAL_NULL)
		<span class="enscript-keyword">return</span>;

	bit = atop_64(offset);
	byte = bit &gt;&gt; 3;
	map[byte] &amp;= ~(1 &lt;&lt; (bit &amp; 07));
}

<span class="enscript-type">void</span>	
<span class="enscript-function-name">vm_external_module_initialize</span>(<span class="enscript-type">void</span>)
{
}
</pre>
<hr />
</body></html>