<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_map_store.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_map_store.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map_store.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span> <span class="enscript-comment">/* for vm_debug_events */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
boolean_t
<span class="enscript-function-name">first_free_is_valid_store</span>( vm_map_t map )
{
	<span class="enscript-keyword">return</span>(first_free_is_valid_ll( map ));
}
#<span class="enscript-reference">endif</span>

boolean_t
<span class="enscript-function-name">vm_map_store_has_RB_support</span>( <span class="enscript-type">struct</span> vm_map_header *hdr )
{
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">void</span>*)hdr-&gt;rb_head_store.rbh_root == (<span class="enscript-type">void</span>*)(<span class="enscript-type">int</span>)SKIP_RB_TREE) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_init</span>( <span class="enscript-type">struct</span> vm_map_header *hdr )
{
	vm_map_store_init_ll( hdr );
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( hdr )) {
		vm_map_store_init_rb( hdr );
	}
#<span class="enscript-reference">endif</span>
}

boolean_t
<span class="enscript-function-name">vm_map_store_lookup_entry</span>(
	<span class="enscript-type">register</span> vm_map_t		map,
	<span class="enscript-type">register</span> vm_map_offset_t	address,
	vm_map_entry_t		*entry)		<span class="enscript-comment">/* OUT */</span>
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_LL</span>
	<span class="enscript-keyword">return</span> (vm_map_store_lookup_entry_ll( map, address, entry ));
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( &amp;map-&gt;hdr )) {
		<span class="enscript-keyword">return</span> (vm_map_store_lookup_entry_rb( map, address, entry ));
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;VM map lookups need RB tree support.\n&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* For compiler warning.*/</span>
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_update</span>( vm_map_t map, vm_map_entry_t entry, <span class="enscript-type">int</span> update_type )
{
	<span class="enscript-keyword">switch</span> (update_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_MAP_ENTRY_CREATE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_MAP_ENTRY_DELETE</span>:
			<span class="enscript-keyword">if</span>((map-&gt;holelistenabled == FALSE) &amp;&amp; ((entry) == (map)-&gt;first_free)) {
				(map)-&gt;first_free = vm_map_to_entry(map);
			}
			<span class="enscript-keyword">if</span>((entry) == (map)-&gt;hint) {
				(map)-&gt;hint = vm_map_to_entry(map);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">void</span>	vm_map_store_copy_insert( vm_map_t map, vm_map_entry_t after_where, vm_map_copy_t copy)
{
	<span class="enscript-keyword">if</span> (__improbable(vm_debug_events)) {
		vm_map_entry_t entry;
		<span class="enscript-keyword">for</span> (entry = vm_map_copy_first_entry(copy); entry != vm_map_copy_to_entry(copy); entry = entry-&gt;vme_next) {
			DTRACE_VM4(map_entry_link_copy, vm_map_t, map, vm_map_entry_t, entry, vm_address_t, entry-&gt;links.start, vm_address_t, entry-&gt;links.end);
		}
	}

	<span class="enscript-keyword">if</span> (map-&gt;holelistenabled) {
		vm_map_entry_t entry = NULL;

		entry = vm_map_copy_first_entry(copy);
		<span class="enscript-keyword">while</span> (entry != vm_map_copy_to_entry(copy)) {
			vm_map_store_update_first_free(map, entry, TRUE);
			entry = entry-&gt;vme_next;
		}
	}

	vm_map_store_copy_insert_ll(map, after_where, copy);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( &amp;map-&gt;hdr )) {
		vm_map_store_copy_insert_rb(map, after_where, copy);
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 *	vm_map_entry_{un,}link:
 *
 *	Insert/remove entries from maps (or map copies).
 *	The _vm_map_store_entry_{un,}link variants are used at
 *	some places where updating first_free is not needed &amp;
 *	copy maps are being modified. Also note the first argument
 *	is the map header.
 *	Modifying the vm_map_store_entry_{un,}link functions to 
 *	deal with these call sites made the interface confusing
 *	and clunky.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">_vm_map_store_entry_link</span>( <span class="enscript-type">struct</span> vm_map_header * mapHdr, vm_map_entry_t after_where, vm_map_entry_t entry)
{
	assert(entry-&gt;vme_start &lt; entry-&gt;vme_end);
	<span class="enscript-keyword">if</span> (__improbable(vm_debug_events))
		DTRACE_VM4(map_entry_link, vm_map_t, (<span class="enscript-type">char</span> *)mapHdr - <span class="enscript-keyword">sizeof</span> (lck_rw_t), vm_map_entry_t, entry, vm_address_t, entry-&gt;links.start, vm_address_t, entry-&gt;links.end);

	vm_map_store_entry_link_ll(mapHdr, after_where, entry);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( mapHdr )) {
		vm_map_store_entry_link_rb(mapHdr, after_where, entry);
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MAP_ENTRY_INSERTION_DEBUG</span>
	fastbacktrace(&amp;entry-&gt;vme_insertion_bt[0],
		      (<span class="enscript-keyword">sizeof</span> (entry-&gt;vme_insertion_bt) / <span class="enscript-keyword">sizeof</span> (uintptr_t)));
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_entry_link</span>( vm_map_t map, vm_map_entry_t after_where, vm_map_entry_t entry)
{
	vm_map_t VMEL_map;
	vm_map_entry_t VMEL_entry;
	VMEL_map = (map);
	VMEL_entry = (entry);
	
	_vm_map_store_entry_link(&amp;VMEL_map-&gt;hdr, after_where, VMEL_entry);
	<span class="enscript-keyword">if</span>( VMEL_map-&gt;disable_vmentry_reuse == TRUE ) {
		UPDATE_HIGHEST_ENTRY_END( VMEL_map, VMEL_entry);
	} <span class="enscript-keyword">else</span> {
		update_first_free_ll(VMEL_map, VMEL_map-&gt;first_free);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
		<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( &amp;VMEL_map-&gt;hdr )) {
			update_first_free_rb(VMEL_map, entry, TRUE);
		}
#<span class="enscript-reference">endif</span>
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">_vm_map_store_entry_unlink</span>( <span class="enscript-type">struct</span> vm_map_header * mapHdr, vm_map_entry_t entry)
{
	<span class="enscript-keyword">if</span> (__improbable(vm_debug_events))
		DTRACE_VM4(map_entry_unlink, vm_map_t, (<span class="enscript-type">char</span> *)mapHdr - <span class="enscript-keyword">sizeof</span> (lck_rw_t), vm_map_entry_t, entry, vm_address_t, entry-&gt;links.start, vm_address_t, entry-&gt;links.end);

	vm_map_store_entry_unlink_ll(mapHdr, entry);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( mapHdr )) {
		vm_map_store_entry_unlink_rb(mapHdr, entry);
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_entry_unlink</span>( vm_map_t map, vm_map_entry_t entry)
{
	vm_map_t VMEU_map;
	vm_map_entry_t VMEU_entry = NULL;
	vm_map_entry_t VMEU_first_free = NULL;
	VMEU_map = (map);
	VMEU_entry = (entry);

	<span class="enscript-keyword">if</span> (map-&gt;holelistenabled == FALSE) {
		<span class="enscript-keyword">if</span> (VMEU_entry-&gt;vme_start &lt;= VMEU_map-&gt;first_free-&gt;vme_start){
			VMEU_first_free = VMEU_entry-&gt;vme_prev;
		} <span class="enscript-keyword">else</span>	{
			VMEU_first_free = VMEU_map-&gt;first_free;
		}
	}
	_vm_map_store_entry_unlink(&amp;VMEU_map-&gt;hdr, VMEU_entry);
	vm_map_store_update( map, entry, VM_MAP_ENTRY_DELETE);
	update_first_free_ll(VMEU_map, VMEU_first_free);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( &amp;VMEU_map-&gt;hdr )) {
		update_first_free_rb(VMEU_map, entry, FALSE);
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_copy_reset</span>( vm_map_copy_t copy,vm_map_entry_t entry)
{
	<span class="enscript-type">int</span> nentries = copy-&gt;cpy_hdr.nentries;
	vm_map_store_copy_reset_ll(copy, entry, nentries);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( &amp;copy-&gt;c_u.hdr )) {
		vm_map_store_copy_reset_rb(copy, entry, nentries);
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_update_first_free</span>( vm_map_t map, vm_map_entry_t first_free_entry, boolean_t new_entry_creation)
{
	update_first_free_ll(map, first_free_entry);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-keyword">if</span> (vm_map_store_has_RB_support( &amp;map-&gt;hdr )) {
		update_first_free_rb(map, first_free_entry, new_entry_creation);
	}
#<span class="enscript-reference">endif</span>
}
</pre>
<hr />
</body></html>