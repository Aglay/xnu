<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_fault.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_fault.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm_fault.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Page fault handling module.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_cluster_stats.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_pagemap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>	<span class="enscript-comment">/* for error codes */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_behavior.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object.h&gt;</span>
				<span class="enscript-comment">/* For memory_object_data_{request,unlock} */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/xpr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/macro_help.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor_pager.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_external.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_purgeable_internal.h&gt;</span>	<span class="enscript-comment">/* Needed by some vm_page.h macros */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_shared_region.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libsa/sys/timers.h&gt;</span>	<span class="enscript-comment">/* for struct timespec */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_FAULT_CLASSIFY</span>	0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span> 0 <span class="enscript-comment">/* (TEST/DEBUG) */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_object_pagein_throttle = 16;

<span class="enscript-comment">/*
 * We apply a hard throttle to the demand zero rate of tasks that we believe are running out of control which 
 * kicks in when swap space runs out.  64-bit programs have massive address spaces and can leak enormous amounts
 * of memory if they're buggy and can run the system completely out of swap space.  If this happens, we
 * impose a hard throttle on them to prevent them from taking the last bit of memory left.  This helps
 * keep the UI active so that the user has a chance to kill the offending task before the system 
 * completely hangs.
 *
 * The hard throttle is only applied when the system is nearly completely out of swap space and is only applied
 * to tasks that appear to be bloated.  When swap runs out, any task using more than vm_hard_throttle_threshold
 * will be throttled.  The throttling is done by giving the thread that's trying to demand zero a page a
 * delay of HARD_THROTTLE_DELAY microseconds before being allowed to try the page fault again.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">throttle_lowpri_io</span>(<span class="enscript-type">int</span>);

uint64_t vm_hard_throttle_threshold;



#<span class="enscript-reference">define</span> <span class="enscript-function-name">NEED_TO_HARD_THROTTLE_THIS_TASK</span>()	(vm_wants_task_throttled(current_task()) ||	\
						 (vm_page_free_count &lt; vm_page_throttle_limit &amp;&amp; \
						  proc_get_effective_thread_policy(current_thread(), TASK_POLICY_IO) &gt; THROTTLE_LEVEL_THROTTLED))


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HARD_THROTTLE_DELAY</span>	5000	<span class="enscript-comment">/* 5000 us == 5 ms */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SOFT_THROTTLE_DELAY</span>	200	<span class="enscript-comment">/* 200 us == .2 ms */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_PAGE_CREATION_THROTTLE_PERIOD_SECS</span>	6
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_PAGE_CREATION_THROTTLE_RATE_PER_SEC</span>	20000


boolean_t <span class="enscript-function-name">current_thread_aborted</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* Forward declarations of internal routines. */</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">vm_fault_wire_fast</span>(
				vm_map_t	map,
				vm_map_offset_t	va,
				vm_prot_t       prot,
				vm_map_entry_t	entry,
				pmap_t		pmap,
				vm_map_offset_t	pmap_addr,
				ppnum_t		*physpage_p);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">vm_fault_internal</span>(
		vm_map_t	map,
		vm_map_offset_t	vaddr,
		vm_prot_t	caller_prot,
		boolean_t	change_wiring,
		<span class="enscript-type">int</span>             interruptible,
		pmap_t		pmap,
		vm_map_offset_t	pmap_addr,
		ppnum_t		*physpage_p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_fault_copy_cleanup</span>(
				vm_page_t	page,
				vm_page_t	top_page);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_fault_copy_dst_cleanup</span>(
				vm_page_t	page);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">VM_FAULT_CLASSIFY</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_fault_classify</span>(vm_object_t	object,
			  vm_object_offset_t	offset,
			  vm_prot_t		fault_type);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_fault_classify_init</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_pmap_enter_blocked = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_pmap_enter_retried = 0;

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_cs_validates = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_cs_revalidates = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_cs_query_modified = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_cs_validated_dirtied = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_cs_bitmap_validated = 0;

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_pre_fault</span>(vm_map_offset_t);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> not_in_kdp;
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *kdp_compressor_decompressed_page;
<span class="enscript-type">extern</span> addr64_t	kdp_compressor_decompressed_page_paddr;
<span class="enscript-type">extern</span> ppnum_t	kdp_compressor_decompressed_page_ppnum;

<span class="enscript-comment">/*
 *	Routine:	vm_fault_init
 *	Purpose:
 *		Initialize our private data structures.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i, vm_compressor_temp;
	boolean_t need_default_val = TRUE;
	<span class="enscript-comment">/*
	 * Choose a value for the hard throttle threshold based on the amount of ram.  The threshold is
	 * computed as a percentage of available memory, and the percentage used is scaled inversely with
	 * the amount of memory.  The percentage runs between 10% and 35%.  We use 35% for small memory systems
	 * and reduce the value down to 10% for very large memory configurations.  This helps give us a
	 * definition of a memory hog that makes more sense relative to the amount of ram in the machine.
	 * The formula here simply uses the number of gigabytes of ram to adjust the percentage.
	 */</span>

	vm_hard_throttle_threshold = sane_size * (35 - MIN((<span class="enscript-type">int</span>)(sane_size / (1024*1024*1024)), 25)) / 100;

	<span class="enscript-comment">/*
	 * Configure compressed pager behavior. A boot arg takes precedence over a device tree entry.
	 */</span>

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;vm_compressor&quot;</span>, &amp;vm_compressor_temp, <span class="enscript-keyword">sizeof</span> (vm_compressor_temp))) {
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; VM_PAGER_MAX_MODES; i++) {
			<span class="enscript-keyword">if</span> (vm_compressor_temp &gt; 0 &amp;&amp; 
			    ((vm_compressor_temp &amp; ( 1 &lt;&lt; i)) == vm_compressor_temp)) {
				need_default_val = FALSE;
				vm_compressor_mode = vm_compressor_temp;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (need_default_val)
			printf(<span class="enscript-string">&quot;Ignoring \&quot;vm_compressor\&quot; boot arg %d\n&quot;</span>, vm_compressor_temp);
	} 
	<span class="enscript-keyword">if</span> (need_default_val) {
		<span class="enscript-comment">/* If no boot arg or incorrect boot arg, try device tree. */</span>
		PE_get_default(<span class="enscript-string">&quot;kern.vm_compressor&quot;</span>, &amp;vm_compressor_mode, <span class="enscript-keyword">sizeof</span>(vm_compressor_mode));
	}
	PE_parse_boot_argn(<span class="enscript-string">&quot;vm_compressor_threads&quot;</span>, &amp;vm_compressor_thread_count, <span class="enscript-keyword">sizeof</span> (vm_compressor_thread_count));

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;vm_compressor_immediate&quot;</span>, &amp;vm_compressor_temp, <span class="enscript-keyword">sizeof</span> (vm_compressor_temp)))
		vm_compressor_immediate_preferred_override = TRUE;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (PE_get_default(<span class="enscript-string">&quot;kern.vm_compressor_immediate&quot;</span>, &amp;vm_compressor_temp, <span class="enscript-keyword">sizeof</span>(vm_compressor_temp)))
			vm_compressor_immediate_preferred_override = TRUE;
	}
	<span class="enscript-keyword">if</span> (vm_compressor_immediate_preferred_override == TRUE) {
		<span class="enscript-keyword">if</span> (vm_compressor_temp)
			vm_compressor_immediate_preferred = TRUE;
		<span class="enscript-keyword">else</span>
			vm_compressor_immediate_preferred = FALSE;
	}
	printf(<span class="enscript-string">&quot;\&quot;vm_compressor_mode\&quot; is %d\n&quot;</span>, vm_compressor_mode);
}

<span class="enscript-comment">/*
 *	Routine:	vm_fault_cleanup
 *	Purpose:
 *		Clean up the result of vm_fault_page.
 *	Results:
 *		The paging reference for &quot;object&quot; is released.
 *		&quot;object&quot; is unlocked.
 *		If &quot;top_page&quot; is not null,  &quot;top_page&quot; is
 *		freed and the paging reference for the object
 *		containing it is released.
 *
 *	In/out conditions:
 *		&quot;object&quot; must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_cleanup</span>(
	<span class="enscript-type">register</span> vm_object_t	object,
	<span class="enscript-type">register</span> vm_page_t	top_page)
{
	vm_object_paging_end(object);
 	vm_object_unlock(object);

	<span class="enscript-keyword">if</span> (top_page != VM_PAGE_NULL) {
	        object = top_page-&gt;object;

		vm_object_lock(object);
		VM_PAGE_FREE(top_page);
		vm_object_paging_end(object);
		vm_object_unlock(object);
	}
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_CLUSTER_STATS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXCLUSTERPAGES</span> 16
<span class="enscript-type">struct</span> {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> pages_in_cluster;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> pages_at_higher_offsets;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> pages_at_lower_offsets;
} cluster_stats_in[MAXCLUSTERPAGES];
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CLUSTER_STAT</span>(clause)	clause
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CLUSTER_STAT_HIGHER</span>(x)	\
	((cluster_stats_in[(x)].pages_at_higher_offsets)++)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CLUSTER_STAT_LOWER</span>(x)	\
	 ((cluster_stats_in[(x)].pages_at_lower_offsets)++)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CLUSTER_STAT_CLUSTER</span>(x)	\
	((cluster_stats_in[(x)].pages_in_cluster)++)
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* MACH_CLUSTER_STATS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CLUSTER_STAT</span>(clause)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_CLUSTER_STATS */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ALIGNED</span>(x) (((x) &amp; (PAGE_SIZE_64 - 1)) == 0)


boolean_t	vm_page_deactivate_behind = TRUE;
<span class="enscript-comment">/* 
 * default sizes given VM_BEHAVIOR_DEFAULT reference behavior 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_DEFAULT_DEACTIVATE_BEHIND_WINDOW</span>	128
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_DEFAULT_DEACTIVATE_BEHIND_CLUSTER</span>	16		<span class="enscript-comment">/* don't make this too big... */</span>
                                                                <span class="enscript-comment">/* we use it to size an array on the stack */</span>

<span class="enscript-type">int</span> vm_default_behind = VM_DEFAULT_DEACTIVATE_BEHIND_WINDOW;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SEQUENTIAL_RUN</span>	(1024 * 1024 * 1024)

<span class="enscript-comment">/*
 * vm_page_is_sequential
 *
 * Determine if sequential access is in progress
 * in accordance with the behavior specified.
 * Update state to indicate current access pattern.
 *
 * object must have at least the shared lock held
 */</span>
<span class="enscript-type">static</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_is_sequential</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_behavior_t		behavior)
{
        vm_object_offset_t	last_alloc;
	<span class="enscript-type">int</span>			sequential;
	<span class="enscript-type">int</span>			orig_sequential;

        last_alloc = object-&gt;last_alloc;
	sequential = object-&gt;sequential;
	orig_sequential = sequential;

	<span class="enscript-keyword">switch</span> (behavior) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_RANDOM</span>:
	        <span class="enscript-comment">/*
		 * reset indicator of sequential behavior
		 */</span>
	        sequential = 0;
	        <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_SEQUENTIAL</span>:
	        <span class="enscript-keyword">if</span> (offset &amp;&amp; last_alloc == offset - PAGE_SIZE_64) {
		        <span class="enscript-comment">/*
			 * advance indicator of sequential behavior
			 */</span>
		        <span class="enscript-keyword">if</span> (sequential &lt; MAX_SEQUENTIAL_RUN)
			        sequential += PAGE_SIZE;
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * reset indicator of sequential behavior
			 */</span>
		        sequential = 0;
		}
	        <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_RSEQNTL</span>:
	        <span class="enscript-keyword">if</span> (last_alloc &amp;&amp; last_alloc == offset + PAGE_SIZE_64) {
		        <span class="enscript-comment">/*
			 * advance indicator of sequential behavior
			 */</span>
		        <span class="enscript-keyword">if</span> (sequential &gt; -MAX_SEQUENTIAL_RUN)
			        sequential -= PAGE_SIZE;
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * reset indicator of sequential behavior
			 */</span>
		        sequential = 0;
		}
	        <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_DEFAULT</span>:
	<span class="enscript-reference">default</span>:
	        <span class="enscript-keyword">if</span> (offset &amp;&amp; last_alloc == (offset - PAGE_SIZE_64)) {
		        <span class="enscript-comment">/*
			 * advance indicator of sequential behavior
			 */</span>
		        <span class="enscript-keyword">if</span> (sequential &lt; 0)
			        sequential = 0;
		        <span class="enscript-keyword">if</span> (sequential &lt; MAX_SEQUENTIAL_RUN)
			        sequential += PAGE_SIZE;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (last_alloc &amp;&amp; last_alloc == (offset + PAGE_SIZE_64)) {
		        <span class="enscript-comment">/*
			 * advance indicator of sequential behavior
			 */</span>
		        <span class="enscript-keyword">if</span> (sequential &gt; 0)
			        sequential = 0;
		        <span class="enscript-keyword">if</span> (sequential &gt; -MAX_SEQUENTIAL_RUN)
			        sequential -= PAGE_SIZE;
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * reset indicator of sequential behavior
			 */</span>
		        sequential = 0;
		}
	        <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (sequential != orig_sequential) {
	        <span class="enscript-keyword">if</span> (!OSCompareAndSwap(orig_sequential, sequential, (UInt32 *)&amp;object-&gt;sequential)) {
		        <span class="enscript-comment">/*
			 * if someone else has already updated object-&gt;sequential
			 * don't bother trying to update it or object-&gt;last_alloc
			 */</span>
		        <span class="enscript-keyword">return</span>;
		}
	}
	<span class="enscript-comment">/*
	 * I'd like to do this with a OSCompareAndSwap64, but that
	 * doesn't exist for PPC...  however, it shouldn't matter
	 * that much... last_alloc is maintained so that we can determine
	 * if a sequential access pattern is taking place... if only
	 * one thread is banging on this object, no problem with the unprotected
	 * update... if 2 or more threads are banging away, we run the risk of
	 * someone seeing a mangled update... however, in the face of multiple
	 * accesses, no sequential access pattern can develop anyway, so we
	 * haven't lost any real info.
	 */</span>
	object-&gt;last_alloc = offset;
}


<span class="enscript-type">int</span> vm_page_deactivate_behind_count = 0;

<span class="enscript-comment">/*
 * vm_page_deactivate_behind
 *
 * Determine if sequential access is in progress
 * in accordance with the behavior specified.  If
 * so, compute a potential page to deactivate and
 * deactivate it.
 *
 * object must be locked.
 *
 * return TRUE if we actually deactivate a page
 */</span>
<span class="enscript-type">static</span>
boolean_t
<span class="enscript-function-name">vm_fault_deactivate_behind</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_behavior_t		behavior)
{
	<span class="enscript-type">int</span>		n;
	<span class="enscript-type">int</span>		pages_in_run = 0;
	<span class="enscript-type">int</span>		max_pages_in_run = 0;
	<span class="enscript-type">int</span>		sequential_run;
	<span class="enscript-type">int</span>		sequential_behavior = VM_BEHAVIOR_SEQUENTIAL;
	vm_object_offset_t	run_offset = 0;
	vm_object_offset_t	pg_offset = 0;
	vm_page_t	m;
	vm_page_t	page_run[VM_DEFAULT_DEACTIVATE_BEHIND_CLUSTER];

	pages_in_run = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
	dbgTrace(0xBEEF0018, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) vm_fault_deactivate_behind);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (object == kernel_object || vm_page_deactivate_behind == FALSE) {
		<span class="enscript-comment">/*
		 * Do not deactivate pages from the kernel object: they
		 * are not intended to become pageable.
		 * or we've disabled the deactivate behind mechanism
		 */</span>
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">if</span> ((sequential_run = object-&gt;sequential)) {
		  <span class="enscript-keyword">if</span> (sequential_run &lt; 0) {
		          sequential_behavior = VM_BEHAVIOR_RSEQNTL;
			  sequential_run = 0 - sequential_run;
		  } <span class="enscript-keyword">else</span> {
		          sequential_behavior = VM_BEHAVIOR_SEQUENTIAL;
		  }
	}
	<span class="enscript-keyword">switch</span> (behavior) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_RANDOM</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_SEQUENTIAL</span>:
	        <span class="enscript-keyword">if</span> (sequential_run &gt;= (<span class="enscript-type">int</span>)PAGE_SIZE) {
			run_offset = 0 - PAGE_SIZE_64;
			max_pages_in_run = 1;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_RSEQNTL</span>:
	        <span class="enscript-keyword">if</span> (sequential_run &gt;= (<span class="enscript-type">int</span>)PAGE_SIZE) {
			run_offset = PAGE_SIZE_64;
			max_pages_in_run = 1;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_BEHAVIOR_DEFAULT</span>:
	<span class="enscript-reference">default</span>:
	{	vm_object_offset_t behind = vm_default_behind * PAGE_SIZE_64;

	        <span class="enscript-comment">/*
		 * determine if the run of sequential accesss has been
		 * long enough on an object with default access behavior
		 * to consider it for deactivation
		 */</span>
		<span class="enscript-keyword">if</span> ((uint64_t)sequential_run &gt;= behind &amp;&amp; (sequential_run % (VM_DEFAULT_DEACTIVATE_BEHIND_CLUSTER * PAGE_SIZE)) == 0) {
			<span class="enscript-comment">/*
			 * the comparisons between offset and behind are done
			 * in this kind of odd fashion in order to prevent wrap around
			 * at the end points
			 */</span>
		        <span class="enscript-keyword">if</span> (sequential_behavior == VM_BEHAVIOR_SEQUENTIAL) {
			        <span class="enscript-keyword">if</span> (offset &gt;= behind) {
					run_offset = 0 - behind;
					pg_offset = PAGE_SIZE_64;
					max_pages_in_run = VM_DEFAULT_DEACTIVATE_BEHIND_CLUSTER;
				}
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-keyword">if</span> (offset &lt; -behind) {
					run_offset = behind;
					pg_offset = 0 - PAGE_SIZE_64;
					max_pages_in_run = VM_DEFAULT_DEACTIVATE_BEHIND_CLUSTER;
				}
			}
		}
		<span class="enscript-keyword">break</span>;
	}
	}
        <span class="enscript-keyword">for</span> (n = 0; n &lt; max_pages_in_run; n++) {
		m = vm_page_lookup(object, offset + run_offset + (n * pg_offset));

		<span class="enscript-keyword">if</span> (m &amp;&amp; !m-&gt;laundry &amp;&amp; !m-&gt;busy &amp;&amp; !m-&gt;no_cache &amp;&amp; !m-&gt;throttled &amp;&amp; !m-&gt;fictitious &amp;&amp; !m-&gt;absent) {
			page_run[pages_in_run++] = m;

			<span class="enscript-comment">/*
			 * by not passing in a pmap_flush_context we will forgo any TLB flushing, local or otherwise...
			 *
			 * a TLB flush isn't really needed here since at worst we'll miss the reference bit being
			 * updated in the PTE if a remote processor still has this mapping cached in its TLB when the
			 * new reference happens. If no futher references happen on the page after that remote TLB flushes
			 * we'll see a clean, non-referenced page when it eventually gets pulled out of the inactive queue
			 * by pageout_scan, which is just fine since the last reference would have happened quite far
			 * in the past (TLB caches don't hang around for very long), and of course could just as easily
			 * have happened before we did the deactivate_behind.
			 */</span>
			pmap_clear_refmod_options(m-&gt;phys_page, VM_MEM_REFERENCED, PMAP_OPTIONS_NOFLUSH, (<span class="enscript-type">void</span> *)NULL);
		}
	}
	<span class="enscript-keyword">if</span> (pages_in_run) {
		vm_page_lockspin_queues();

		<span class="enscript-keyword">for</span> (n = 0; n &lt; pages_in_run; n++) {

			m = page_run[n];

			vm_page_deactivate_internal(m, FALSE);

			vm_page_deactivate_behind_count++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
			dbgTrace(0xBEEF0019, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
		}
		vm_page_unlock_queues();

		<span class="enscript-keyword">return</span> TRUE;
	}
	<span class="enscript-keyword">return</span> FALSE;
}


#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
uint32_t	vm_page_creation_throttled_hard = 0;
uint32_t	vm_page_creation_throttled_soft = 0;
uint64_t	vm_page_creation_throttle_avoided = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_page_throttled</span>(boolean_t page_kept)
{
        clock_sec_t     elapsed_sec;
        clock_sec_t     tv_sec;
        clock_usec_t    tv_usec;
	
	thread_t thread = current_thread();
	
	<span class="enscript-keyword">if</span> (thread-&gt;options &amp; TH_OPT_VMPRIV)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (thread-&gt;t_page_creation_throttled) {
		thread-&gt;t_page_creation_throttled = 0;
		
		<span class="enscript-keyword">if</span> (page_kept == FALSE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_throttle</span>;
	}
	<span class="enscript-keyword">if</span> (NEED_TO_HARD_THROTTLE_THIS_TASK()) {
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
		thread-&gt;t_page_creation_throttled_hard++;
		OSAddAtomic(1, &amp;vm_page_creation_throttled_hard);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		<span class="enscript-keyword">return</span> (HARD_THROTTLE_DELAY);
	}

	<span class="enscript-keyword">if</span> ((vm_page_free_count &lt; vm_page_throttle_limit || ((COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) &amp;&amp; SWAPPER_NEEDS_TO_UNTHROTTLE())) &amp;&amp;
	    thread-&gt;t_page_creation_count &gt; (VM_PAGE_CREATION_THROTTLE_PERIOD_SECS * VM_PAGE_CREATION_THROTTLE_RATE_PER_SEC)) {
		
		<span class="enscript-keyword">if</span> (vm_page_free_wanted == 0 &amp;&amp; vm_page_free_wanted_privileged == 0) {
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
			OSAddAtomic64(1, &amp;vm_page_creation_throttle_avoided);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_throttle</span>;
		}
		clock_get_system_microtime(&amp;tv_sec, &amp;tv_usec);

		elapsed_sec = tv_sec - thread-&gt;t_page_creation_time;

		<span class="enscript-keyword">if</span> (elapsed_sec &lt;= VM_PAGE_CREATION_THROTTLE_PERIOD_SECS ||
		    (thread-&gt;t_page_creation_count / elapsed_sec) &gt;= VM_PAGE_CREATION_THROTTLE_RATE_PER_SEC) {

			<span class="enscript-keyword">if</span> (elapsed_sec &gt;= (3 * VM_PAGE_CREATION_THROTTLE_PERIOD_SECS)) {
				<span class="enscript-comment">/*
				 * we'll reset our stats to give a well behaved app
				 * that was unlucky enough to accumulate a bunch of pages
				 * over a long period of time a chance to get out of
				 * the throttled state... we reset the counter and timestamp
				 * so that if it stays under the rate limit for the next second
				 * it will be back in our good graces... if it exceeds it, it 
				 * will remain in the throttled state
				 */</span>
				thread-&gt;t_page_creation_time = tv_sec;
				thread-&gt;t_page_creation_count = VM_PAGE_CREATION_THROTTLE_RATE_PER_SEC * (VM_PAGE_CREATION_THROTTLE_PERIOD_SECS - 1);
			}
			++vm_page_throttle_count;

			thread-&gt;t_page_creation_throttled = 1;

			<span class="enscript-keyword">if</span> ((COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) &amp;&amp; HARD_THROTTLE_LIMIT_REACHED()) {
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
				thread-&gt;t_page_creation_throttled_hard++;
				OSAddAtomic(1, &amp;vm_page_creation_throttled_hard);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
				<span class="enscript-keyword">return</span> (HARD_THROTTLE_DELAY);
			} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
				thread-&gt;t_page_creation_throttled_soft++;
				OSAddAtomic(1, &amp;vm_page_creation_throttled_soft);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
				<span class="enscript-keyword">return</span> (SOFT_THROTTLE_DELAY);
			}
		}
		thread-&gt;t_page_creation_time = tv_sec;
		thread-&gt;t_page_creation_count = 0;
	}
<span class="enscript-reference">no_throttle</span>:
	thread-&gt;t_page_creation_count++;

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * check for various conditions that would
 * prevent us from creating a ZF page...
 * cleanup is based on being called from vm_fault_page
 *
 * object must be locked
 * object == m-&gt;object
 */</span>
<span class="enscript-type">static</span> vm_fault_return_t
<span class="enscript-function-name">vm_fault_check</span>(vm_object_t object, vm_page_t m, vm_page_t first_m, boolean_t interruptible_state, boolean_t page_throttle)
{
	<span class="enscript-type">int</span> throttle_delay;

        <span class="enscript-keyword">if</span> (object-&gt;shadow_severed ||
	    VM_OBJECT_PURGEABLE_FAULT_ERROR(object)) {
	        <span class="enscript-comment">/*
		 * Either:
		 * 1. the shadow chain was severed,
		 * 2. the purgeable object is volatile or empty and is marked
		 *    to fault on access while volatile.
		 * Just have to return an error at this point
		 */</span>
	        <span class="enscript-keyword">if</span> (m != VM_PAGE_NULL)
		        VM_PAGE_FREE(m);
		vm_fault_cleanup(object, first_m);

		thread_interrupt_level(interruptible_state);

		<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_ERROR);
	}
	<span class="enscript-keyword">if</span> (vm_backing_store_low) {
	        <span class="enscript-comment">/*
		 * are we protecting the system from
		 * backing store exhaustion.  If so
		 * sleep unless we are privileged.
		 */</span>
	        <span class="enscript-keyword">if</span> (!(current_task()-&gt;priv_flags &amp; VM_BACKING_STORE_PRIV)) {

			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL)
			        VM_PAGE_FREE(m);
			vm_fault_cleanup(object, first_m);

		        assert_wait((event_t)&amp;vm_backing_store_low, THREAD_UNINT);

			thread_block(THREAD_CONTINUE_NULL);
			thread_interrupt_level(interruptible_state);

			<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
		}
	}
	<span class="enscript-keyword">if</span> (page_throttle == TRUE) {
		<span class="enscript-keyword">if</span> ((throttle_delay = vm_page_throttled(FALSE))) {
			<span class="enscript-comment">/*
			 * we're throttling zero-fills...
			 * treat this as if we couldn't grab a page
			 */</span>
			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL)
				VM_PAGE_FREE(m);
			vm_fault_cleanup(object, first_m);

			VM_DEBUG_EVENT(vmf_check_zfdelay, VMF_CHECK_ZFDELAY, DBG_FUNC_NONE, throttle_delay, 0, 0, 0);

			delay(throttle_delay);

			<span class="enscript-keyword">if</span> (current_thread_aborted()) {
				thread_interrupt_level(interruptible_state);
				<span class="enscript-keyword">return</span> VM_FAULT_INTERRUPTED;
			}
			thread_interrupt_level(interruptible_state);

			<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_SHORTAGE);
		}
	}
	<span class="enscript-keyword">return</span> (VM_FAULT_SUCCESS);
}


<span class="enscript-comment">/*
 * do the work to zero fill a page and
 * inject it into the correct paging queue
 *
 * m-&gt;object must be locked
 * page queue lock must NOT be held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_fault_zero_page</span>(vm_page_t m, boolean_t no_zero_fill)
{
        <span class="enscript-type">int</span> my_fault = DBG_ZERO_FILL_FAULT;

	<span class="enscript-comment">/*
	 * This is is a zero-fill page fault...
	 *
	 * Checking the page lock is a waste of
	 * time;  this page was absent, so
	 * it can't be page locked by a pager.
	 *
	 * we also consider it undefined
	 * with respect to instruction
	 * execution.  i.e. it is the responsibility
	 * of higher layers to call for an instruction
	 * sync after changing the contents and before
	 * sending a program into this area.  We 
	 * choose this approach for performance
	 */</span>
	m-&gt;pmapped = TRUE;

	m-&gt;cs_validated = FALSE;
	m-&gt;cs_tainted = FALSE;
	m-&gt;cs_nx = FALSE;

	<span class="enscript-keyword">if</span> (no_zero_fill == TRUE) {
		my_fault = DBG_NZF_PAGE_FAULT;

		<span class="enscript-keyword">if</span> (m-&gt;absent &amp;&amp; m-&gt;busy)
			<span class="enscript-keyword">return</span> (my_fault);
	} <span class="enscript-keyword">else</span> {
		vm_page_zero_fill(m);

		VM_STAT_INCR(zero_fill_count);
		DTRACE_VM2(zfod, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
	}
	assert(!m-&gt;laundry);
	assert(m-&gt;object != kernel_object);
	<span class="enscript-comment">//assert(m-&gt;pageq.next == NULL &amp;&amp; m-&gt;pageq.prev == NULL);
</span>
	<span class="enscript-keyword">if</span> (!VM_DYNAMIC_PAGING_ENABLED(memory_manager_default) &amp;&amp;
		(m-&gt;object-&gt;purgable == VM_PURGABLE_DENY ||
		 m-&gt;object-&gt;purgable == VM_PURGABLE_NONVOLATILE ||
		 m-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE )) {

		vm_page_lockspin_queues();

		<span class="enscript-keyword">if</span> (!VM_DYNAMIC_PAGING_ENABLED(memory_manager_default)) {
			assert(!VM_PAGE_WIRED(m));

			<span class="enscript-comment">/*
			 * can't be on the pageout queue since we don't
			 * have a pager to try and clean to
			 */</span>
			assert(!m-&gt;pageout_queue);

			vm_page_queues_remove(m);
			vm_page_check_pageable_safe(m);
			queue_enter(&amp;vm_page_queue_throttled, m, vm_page_t, pageq);
			m-&gt;throttled = TRUE;
			vm_page_throttled_count++;
		}
		vm_page_unlock_queues();
	}
	<span class="enscript-keyword">return</span> (my_fault);
}


<span class="enscript-comment">/*
 *	Routine:	vm_fault_page
 *	Purpose:
 *		Find the resident page for the virtual memory
 *		specified by the given virtual memory object
 *		and offset.
 *	Additional arguments:
 *		The required permissions for the page is given
 *		in &quot;fault_type&quot;.  Desired permissions are included
 *		in &quot;protection&quot;.
 *		fault_info is passed along to determine pagein cluster 
 *		limits... it contains the expected reference pattern,
 *		cluster size if available, etc...
 *
 *		If the desired page is known to be resident (for
 *		example, because it was previously wired down), asserting
 *		the &quot;unwiring&quot; parameter will speed the search.
 *
 *		If the operation can be interrupted (by thread_abort
 *		or thread_terminate), then the &quot;interruptible&quot;
 *		parameter should be asserted.
 *
 *	Results:
 *		The page containing the proper data is returned
 *		in &quot;result_page&quot;.
 *
 *	In/out conditions:
 *		The source object must be locked and referenced,
 *		and must donate one paging reference.  The reference
 *		is not affected.  The paging reference and lock are
 *		consumed.
 *
 *		If the call succeeds, the object in which &quot;result_page&quot;
 *		resides is left locked and holding a paging reference.
 *		If this is not the original object, a busy page in the
 *		original object is returned in &quot;top_page&quot;, to prevent other
 *		callers from pursuing this same data, along with a paging
 *		reference for the original object.  The &quot;top_page&quot; should
 *		be destroyed when this guarantee is no longer required.
 *		The &quot;result_page&quot; is also left busy.  It is not removed
 *		from the pageout queues.
 *	Special Case:
 *		A return value of VM_FAULT_SUCCESS_NO_PAGE means that the 
 *		fault succeeded but there's no VM page (i.e. the VM object
 * 		does not actually hold VM pages, but device memory or
 *		large pages).  The object is still locked and we still hold a
 *		paging_in_progress reference.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_fault_page_blocked_access = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_fault_page_forced_retry = 0;

vm_fault_return_t
<span class="enscript-function-name">vm_fault_page</span>(
	<span class="enscript-comment">/* Arguments: */</span>
	vm_object_t	first_object,	<span class="enscript-comment">/* Object to begin search */</span>
	vm_object_offset_t first_offset,	<span class="enscript-comment">/* Offset into object */</span>
	vm_prot_t	fault_type,	<span class="enscript-comment">/* What access is requested */</span>
	boolean_t	must_be_resident,<span class="enscript-comment">/* Must page be resident? */</span>
	boolean_t	caller_lookup,	<span class="enscript-comment">/* caller looked up page */</span>
	<span class="enscript-comment">/* Modifies in place: */</span>
	vm_prot_t	*protection,	<span class="enscript-comment">/* Protection for mapping */</span>
	vm_page_t	*result_page,	<span class="enscript-comment">/* Page found, if successful */</span>
	<span class="enscript-comment">/* Returns: */</span>
	vm_page_t	*top_page,	<span class="enscript-comment">/* Page in top object, if
					 * not result_page.  */</span>
	<span class="enscript-type">int</span>             *type_of_fault, <span class="enscript-comment">/* if non-null, fill in with type of fault
					 * COW, zero-fill, etc... returned in trace point */</span>
	<span class="enscript-comment">/* More arguments: */</span>
	kern_return_t	*error_code,	<span class="enscript-comment">/* code if page is in error */</span>
	boolean_t	no_zero_fill,	<span class="enscript-comment">/* don't zero fill absent pages */</span>
	boolean_t	data_supply,	<span class="enscript-comment">/* treat as data_supply if 
					 * it is a write fault and a full
					 * page is provided */</span>
	vm_object_fault_info_t fault_info)
{
	vm_page_t		m;
	vm_object_t		object;
	vm_object_offset_t	offset;
	vm_page_t		first_m;
	vm_object_t		next_object;
	vm_object_t		copy_object;
	boolean_t		look_for_page;
	boolean_t		force_fault_retry = FALSE;
	vm_prot_t		access_required = fault_type;
	vm_prot_t		wants_copy_flag;
	CLUSTER_STAT(<span class="enscript-type">int</span> pages_at_higher_offsets;)
	CLUSTER_STAT(<span class="enscript-type">int</span> pages_at_lower_offsets;)
	kern_return_t		wait_result;
	boolean_t		interruptible_state;
	boolean_t		data_already_requested = FALSE;
	vm_behavior_t		orig_behavior;
	vm_size_t		orig_cluster_size;
	vm_fault_return_t	error;
	<span class="enscript-type">int</span>			my_fault;
	uint32_t		try_failed_count;
	<span class="enscript-type">int</span>			interruptible; <span class="enscript-comment">/* how may fault be interrupted? */</span>
	<span class="enscript-type">int</span>			external_state = VM_EXTERNAL_STATE_UNKNOWN;
	memory_object_t		pager;
	vm_fault_return_t	retval;

<span class="enscript-comment">/*
 * MACH page map - an optional optimization where a bit map is maintained
 * by the VM subsystem for internal objects to indicate which pages of
 * the object currently reside on backing store.  This existence map
 * duplicates information maintained by the vnode pager.  It is 
 * created at the time of the first pageout against the object, i.e. 
 * at the same time pager for the object is created.  The optimization
 * is designed to eliminate pager interaction overhead, if it is 
 * 'known' that the page does not exist on backing store.
 *
 * MUST_ASK_PAGER() evaluates to TRUE if the page specified by object/offset is 
 * either marked as paged out in the existence map for the object or no 
 * existence map exists for the object.  MUST_ASK_PAGER() is one of the
 * criteria in the decision to invoke the pager.   It is also used as one
 * of the criteria to terminate the scan for adjacent pages in a clustered
 * pagein operation.  Note that MUST_ASK_PAGER() always evaluates to TRUE for
 * permanent objects.  Note also that if the pager for an internal object 
 * has not been created, the pager is not invoked regardless of the value 
 * of MUST_ASK_PAGER() and that clustered pagein scans are only done on an object
 * for which a pager has been created.
 *
 * PAGED_OUT() evaluates to TRUE if the page specified by the object/offset
 * is marked as paged out in the existence map for the object.  PAGED_OUT()
 * PAGED_OUT() is used to determine if a page has already been pushed
 * into a copy object in order to avoid a redundant page out operation.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MUST_ASK_PAGER</span>(o, f, s)					\
	((vm_external_state_get((o)-&gt;existence_map, (f))	\
	  != VM_EXTERNAL_STATE_ABSENT) &amp;&amp;			\
	 (s = (VM_COMPRESSOR_PAGER_STATE_GET((o), (f))))	\
	 != VM_EXTERNAL_STATE_ABSENT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGED_OUT</span>(o, f)						\
	((vm_external_state_get((o)-&gt;existence_map, (f))	\
	  == VM_EXTERNAL_STATE_EXISTS) ||			\
	 (VM_COMPRESSOR_PAGER_STATE_GET((o), (f))		\
	  == VM_EXTERNAL_STATE_EXISTS))
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* MACH_PAGEMAP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MUST_ASK_PAGER</span>(o, f, s)					\
	((s = VM_COMPRESSOR_PAGER_STATE_GET((o), (f))) != VM_EXTERNAL_STATE_ABSENT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGED_OUT</span>(o, f) \
	(VM_COMPRESSOR_PAGER_STATE_GET((o), (f)) == VM_EXTERNAL_STATE_EXISTS)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGEMAP */</span>

<span class="enscript-comment">/*
 *	Recovery actions
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RELEASE_PAGE</span>(m)					\
	MACRO_BEGIN					\
	PAGE_WAKEUP_DONE(m);				\
	<span class="enscript-keyword">if</span> (!m-&gt;active &amp;&amp; !m-&gt;inactive &amp;&amp; !m-&gt;throttled) {		\
		vm_page_lockspin_queues();				\
		<span class="enscript-keyword">if</span> (!m-&gt;active &amp;&amp; !m-&gt;inactive &amp;&amp; !m-&gt;throttled) {	\
			<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE)	\
                                vm_page_deactivate(m);                  \
                        <span class="enscript-keyword">else</span>						\
				vm_page_activate(m);			\
		}							\
		vm_page_unlock_queues();				\
	}								\
	MACRO_END

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
	dbgTrace(0xBEEF0002, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) first_object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) first_offset);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>

	interruptible = fault_info-&gt;interruptible;
	interruptible_state = thread_interrupt_level(interruptible);
 
	<span class="enscript-comment">/*
	 *	INVARIANTS (through entire routine):
	 *
	 *	1)	At all times, we must either have the object
	 *		lock or a busy page in some object to prevent
	 *		some other thread from trying to bring in
	 *		the same page.
	 *
	 *		Note that we cannot hold any locks during the
	 *		pager access or when waiting for memory, so
	 *		we use a busy page then.
	 *
	 *	2)	To prevent another thread from racing us down the
	 *		shadow chain and entering a new page in the top
	 *		object before we do, we must keep a busy page in
	 *		the top object while following the shadow chain.
	 *
	 *	3)	We must increment paging_in_progress on any object
	 *		for which we have a busy page before dropping
	 *		the object lock
	 *
	 *	4)	We leave busy pages on the pageout queues.
	 *		If the pageout daemon comes across a busy page,
	 *		it will remove the page from the pageout queues.
	 */</span>

	object = first_object;
	offset = first_offset;
	first_m = VM_PAGE_NULL;
	access_required = fault_type;


	XPR(XPR_VM_FAULT,
		<span class="enscript-string">&quot;vm_f_page: obj 0x%X, offset 0x%X, type %d, prot %d\n&quot;</span>,
		object, offset, fault_type, *protection, 0);

	<span class="enscript-comment">/*
	 * default type of fault
	 */</span>
	my_fault = DBG_CACHE_HIT_FAULT;

	<span class="enscript-keyword">while</span> (TRUE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
		dbgTrace(0xBEEF0003, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (!object-&gt;alive) {
		        <span class="enscript-comment">/*
			 * object is no longer valid
			 * clean up and return error
			 */</span>
			vm_fault_cleanup(object, first_m);
			thread_interrupt_level(interruptible_state);

			<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_ERROR);
		}

		<span class="enscript-keyword">if</span> (!object-&gt;pager_created &amp;&amp; object-&gt;phys_contiguous) {
			<span class="enscript-comment">/*
			 * A physically-contiguous object without a pager:
			 * must be a &quot;large page&quot; object.  We do not deal
			 * with VM pages for this object.
			 */</span>
			caller_lookup = FALSE;
			m = VM_PAGE_NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">phys_contig_object</span>;
		}

		<span class="enscript-keyword">if</span> (object-&gt;blocked_access) {
			<span class="enscript-comment">/*
			 * Access to this VM object has been blocked.
			 * Replace our &quot;paging_in_progress&quot; reference with
			 * a &quot;activity_in_progress&quot; reference and wait for
			 * access to be unblocked.
			 */</span>
			caller_lookup = FALSE; <span class="enscript-comment">/* no longer valid after sleep */</span>
			vm_object_activity_begin(object);
			vm_object_paging_end(object);
			<span class="enscript-keyword">while</span> (object-&gt;blocked_access) {
				vm_object_sleep(object,
						VM_OBJECT_EVENT_UNBLOCKED,
						THREAD_UNINT);
			}
			vm_fault_page_blocked_access++;
			vm_object_paging_begin(object);
			vm_object_activity_end(object);
		}

		<span class="enscript-comment">/*
		 * See whether the page at 'offset' is resident
		 */</span>
		<span class="enscript-keyword">if</span> (caller_lookup == TRUE) {
			<span class="enscript-comment">/*
			 * The caller has already looked up the page
			 * and gave us the result in &quot;result_page&quot;.
			 * We can use this for the first lookup but
			 * it loses its validity as soon as we unlock
			 * the object.
			 */</span>
			m = *result_page;
			caller_lookup = FALSE; <span class="enscript-comment">/* no longer valid after that */</span>
		} <span class="enscript-keyword">else</span> {
			m = vm_page_lookup(object, offset);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
		dbgTrace(0xBEEF0004, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {

			<span class="enscript-keyword">if</span> (m-&gt;busy) {
			        <span class="enscript-comment">/*
				 * The page is being brought in,
				 * wait for it and then retry.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF0005, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				wait_result = PAGE_SLEEP(object, m, interruptible);

				XPR(XPR_VM_FAULT,
				    <span class="enscript-string">&quot;vm_f_page: block busy obj 0x%X, offset 0x%X, page 0x%X\n&quot;</span>,
				    object, offset,
				    m, 0, 0);
				counter(c_vm_fault_page_block_busy_kernel++);

				<span class="enscript-keyword">if</span> (wait_result != THREAD_AWAKENED) {
					vm_fault_cleanup(object, first_m);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">if</span> (wait_result == THREAD_RESTART)
						<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
					<span class="enscript-keyword">else</span>
						<span class="enscript-keyword">return</span> (VM_FAULT_INTERRUPTED);
				}
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (m-&gt;laundry) {
				m-&gt;pageout = FALSE;

				<span class="enscript-keyword">if</span> (!m-&gt;cleaning) 
					vm_pageout_steal_laundry(m, FALSE);
			}
			<span class="enscript-keyword">if</span> (m-&gt;phys_page == vm_page_guard_addr) {
				<span class="enscript-comment">/*
				 * Guard page: off limits !
				 */</span>
				<span class="enscript-keyword">if</span> (fault_type == VM_PROT_NONE) {
					<span class="enscript-comment">/*
					 * The fault is not requesting any
					 * access to the guard page, so it must
					 * be just to wire or unwire it.
					 * Let's pretend it succeeded...
					 */</span>
					m-&gt;busy = TRUE;
					*result_page = m;
					assert(first_m == VM_PAGE_NULL);
					*top_page = first_m;
					<span class="enscript-keyword">if</span> (type_of_fault)
						*type_of_fault = DBG_GUARD_FAULT;
					thread_interrupt_level(interruptible_state);
					<span class="enscript-keyword">return</span> VM_FAULT_SUCCESS;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * The fault requests access to the
					 * guard page: let's deny that !
					 */</span>
					vm_fault_cleanup(object, first_m);
					thread_interrupt_level(interruptible_state);
					<span class="enscript-keyword">return</span> VM_FAULT_MEMORY_ERROR;
				}
			}

			<span class="enscript-keyword">if</span> (m-&gt;error) {
			        <span class="enscript-comment">/*
				 * The page is in error, give up now.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF0006, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) error_code);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">if</span> (error_code)
				        *error_code = KERN_MEMORY_ERROR;
				VM_PAGE_FREE(m);

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_ERROR);
			}
			<span class="enscript-keyword">if</span> (m-&gt;restart) {
			        <span class="enscript-comment">/*
				 * The pager wants us to restart
				 * at the top of the chain,
				 * typically because it has moved the
				 * page to another pager, then do so.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF0007, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				VM_PAGE_FREE(m);

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
			}
			<span class="enscript-keyword">if</span> (m-&gt;absent) {
			        <span class="enscript-comment">/*
				 * The page isn't busy, but is absent,
				 * therefore it's deemed &quot;unavailable&quot;.
				 *
				 * Remove the non-existent page (unless it's
				 * in the top object) and move on down to the
				 * next object (if there is one).
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF0008, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object-&gt;shadow);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				next_object = object-&gt;shadow;

				<span class="enscript-keyword">if</span> (next_object == VM_OBJECT_NULL) {
					<span class="enscript-comment">/*
					 * Absent page at bottom of shadow
					 * chain; zero fill the page we left
					 * busy in the first object, and free
					 * the absent page.
					 */</span>
					assert(!must_be_resident);

					<span class="enscript-comment">/*
					 * check for any conditions that prevent
					 * us from creating a new zero-fill page
					 * vm_fault_check will do all of the 
					 * fault cleanup in the case of an error condition
					 * including resetting the thread_interrupt_level
					 */</span>
					error = vm_fault_check(object, m, first_m, interruptible_state, (type_of_fault == NULL) ? TRUE : FALSE);

					<span class="enscript-keyword">if</span> (error != VM_FAULT_SUCCESS)
					        <span class="enscript-keyword">return</span> (error);

					XPR(XPR_VM_FAULT,
					    <span class="enscript-string">&quot;vm_f_page: zero obj 0x%X, off 0x%X, page 0x%X, first_obj 0x%X\n&quot;</span>,
						object, offset,
						m,
						first_object, 0);

					<span class="enscript-keyword">if</span> (object != first_object) {
					        <span class="enscript-comment">/*
						 * free the absent page we just found
						 */</span>
						VM_PAGE_FREE(m);

						<span class="enscript-comment">/*
						 * drop reference and lock on current object
						 */</span>
						vm_object_paging_end(object);
						vm_object_unlock(object);

						<span class="enscript-comment">/*
						 * grab the original page we 
						 * 'soldered' in place and
						 * retake lock on 'first_object'
						 */</span>
						m = first_m;
						first_m = VM_PAGE_NULL;

						object = first_object;
						offset = first_offset;

						vm_object_lock(object);
					} <span class="enscript-keyword">else</span> {
					        <span class="enscript-comment">/*
						 * we're going to use the absent page we just found
						 * so convert it to a 'busy' page
						 */</span>
					        m-&gt;absent = FALSE;
						m-&gt;busy = TRUE;
					}
					<span class="enscript-keyword">if</span> (fault_info-&gt;mark_zf_absent &amp;&amp; no_zero_fill == TRUE)
						m-&gt;absent = TRUE;
					<span class="enscript-comment">/*
					 * zero-fill the page and put it on
					 * the correct paging queue
					 */</span>
					my_fault = vm_fault_zero_page(m, no_zero_fill);

					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (must_be_resident)
						vm_object_paging_end(object);
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object != first_object) {
						vm_object_paging_end(object);
						VM_PAGE_FREE(m);
					} <span class="enscript-keyword">else</span> {
						first_m = m;
						m-&gt;absent = FALSE;
						m-&gt;busy = TRUE;

						vm_page_lockspin_queues();

						assert(!m-&gt;pageout_queue);
						vm_page_queues_remove(m);

						vm_page_unlock_queues();
					}
					XPR(XPR_VM_FAULT,
					    <span class="enscript-string">&quot;vm_f_page: unavail obj 0x%X, off 0x%X, next_obj 0x%X, newoff 0x%X\n&quot;</span>,
						object, offset,
						next_object,
						offset+object-&gt;vo_shadow_offset,0);

					offset += object-&gt;vo_shadow_offset;
					fault_info-&gt;lo_offset += object-&gt;vo_shadow_offset;
					fault_info-&gt;hi_offset += object-&gt;vo_shadow_offset;
					access_required = VM_PROT_READ;

					vm_object_lock(next_object);
					vm_object_unlock(object);
					object = next_object;
					vm_object_paging_begin(object);
					
					<span class="enscript-comment">/*
					 * reset to default type of fault
					 */</span>
					my_fault = DBG_CACHE_HIT_FAULT;

					<span class="enscript-keyword">continue</span>;
				}
			}
			<span class="enscript-keyword">if</span> ((m-&gt;cleaning)
			    &amp;&amp; ((object != first_object) || (object-&gt;copy != VM_OBJECT_NULL))
			    &amp;&amp; (fault_type &amp; VM_PROT_WRITE)) {
				<span class="enscript-comment">/*
				 * This is a copy-on-write fault that will
				 * cause us to revoke access to this page, but
				 * this page is in the process of being cleaned
				 * in a clustered pageout. We must wait until
				 * the cleaning operation completes before
				 * revoking access to the original page,
				 * otherwise we might attempt to remove a
				 * wired mapping.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF0009, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) offset);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				XPR(XPR_VM_FAULT,
				    <span class="enscript-string">&quot;vm_f_page: cleaning obj 0x%X, offset 0x%X, page 0x%X\n&quot;</span>,
					object, offset,
					m, 0, 0);
				<span class="enscript-comment">/*
				 * take an extra ref so that object won't die
				 */</span>
				vm_object_reference_locked(object);

				vm_fault_cleanup(object, first_m);
				
				counter(c_vm_fault_page_block_backoff_kernel++);
				vm_object_lock(object);
				assert(object-&gt;ref_count &gt; 0);

				m = vm_page_lookup(object, offset);

				<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL &amp;&amp; m-&gt;cleaning) {
					PAGE_ASSERT_WAIT(m, interruptible);

					vm_object_unlock(object);
					wait_result = thread_block(THREAD_CONTINUE_NULL);
					vm_object_deallocate(object);

					<span class="enscript-keyword">goto</span> <span class="enscript-reference">backoff</span>;
				} <span class="enscript-keyword">else</span> {
					vm_object_unlock(object);

					vm_object_deallocate(object);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
				}
			}
			<span class="enscript-keyword">if</span> (type_of_fault == NULL &amp;&amp; m-&gt;speculative &amp;&amp;
			    !(fault_info != NULL &amp;&amp; fault_info-&gt;stealth)) {
			        <span class="enscript-comment">/*
				 * If we were passed a non-NULL pointer for
				 * &quot;type_of_fault&quot;, than we came from
				 * vm_fault... we'll let it deal with
				 * this condition, since it
				 * needs to see m-&gt;speculative to correctly
				 * account the pageins, otherwise...
				 * take it off the speculative queue, we'll
				 * let the caller of vm_fault_page deal
				 * with getting it onto the correct queue
				 *
				 * If the caller specified in fault_info that
				 * it wants a &quot;stealth&quot; fault, we also leave
				 * the page in the speculative queue.
				 */</span>
			        vm_page_lockspin_queues();
				<span class="enscript-keyword">if</span> (m-&gt;speculative)
					vm_page_queues_remove(m);
			        vm_page_unlock_queues();
			}

			<span class="enscript-keyword">if</span> (m-&gt;encrypted) {
				<span class="enscript-comment">/*
				 * ENCRYPTED SWAP:
				 * the user needs access to a page that we
				 * encrypted before paging it out.
				 * Decrypt the page now.
				 * Keep it busy to prevent anyone from
				 * accessing it during the decryption.
				 */</span>
				m-&gt;busy = TRUE;
				vm_page_decrypt(m, 0);
				assert(object == m-&gt;object);
				assert(m-&gt;busy);
				PAGE_WAKEUP_DONE(m);

				<span class="enscript-comment">/*
				 * Retry from the top, in case
				 * something changed while we were
				 * decrypting.
				 */</span>
				<span class="enscript-keyword">continue</span>;
			}
			ASSERT_PAGE_DECRYPTED(m);

			<span class="enscript-keyword">if</span> (m-&gt;object-&gt;code_signed) {
				<span class="enscript-comment">/*
				 * CODE SIGNING:
				 * We just paged in a page from a signed
				 * memory object but we don't need to
				 * validate it now.  We'll validate it if
				 * when it gets mapped into a user address
				 * space for the first time or when the page
				 * gets copied to another object as a result
				 * of a copy-on-write.
				 */</span>
			}

			<span class="enscript-comment">/*
			 * We mark the page busy and leave it on
			 * the pageout queues.  If the pageout
			 * deamon comes across it, then it will
			 * remove the page from the queue, but not the object
			 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
			dbgTrace(0xBEEF000B, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
			XPR(XPR_VM_FAULT,
			    <span class="enscript-string">&quot;vm_f_page: found page obj 0x%X, offset 0x%X, page 0x%X\n&quot;</span>,
				object, offset, m, 0, 0);
			assert(!m-&gt;busy);
			assert(!m-&gt;absent);

			m-&gt;busy = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		

		<span class="enscript-comment">/*
		 * we get here when there is no page present in the object at
		 * the offset we're interested in... we'll allocate a page
		 * at this point if the pager associated with
		 * this object can provide the data or we're the top object...
		 * object is locked;  m == NULL
		 */</span>
		<span class="enscript-keyword">if</span> (must_be_resident) {
			<span class="enscript-keyword">if</span> (fault_type == VM_PROT_NONE &amp;&amp;
			    object == kernel_object) {
				<span class="enscript-comment">/*
				 * We've been called from vm_fault_unwire()
				 * while removing a map entry that was allocated
				 * with KMA_KOBJECT and KMA_VAONLY.  This page
				 * is not present and there's nothing more to
				 * do here (nothing to unwire).
				 */</span>
				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> VM_FAULT_MEMORY_ERROR;
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dont_look_for_page</span>;
		}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_PAGEMAP</span>
		data_supply = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MACH_PAGEMAP */</span>

		look_for_page =	(object-&gt;pager_created &amp;&amp; (MUST_ASK_PAGER(object, offset, external_state) == TRUE) &amp;&amp; !data_supply);
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
		dbgTrace(0xBEEF000C, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) look_for_page, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (!look_for_page &amp;&amp; object == first_object &amp;&amp; !object-&gt;phys_contiguous) {
			<span class="enscript-comment">/*
			 * Allocate a new page for this object/offset pair as a placeholder
			 */</span>
			m = vm_page_grab();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
			dbgTrace(0xBEEF000D, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_SHORTAGE);
			}

			<span class="enscript-keyword">if</span> (fault_info &amp;&amp; fault_info-&gt;batch_pmap_op == TRUE) {
				vm_page_insert_internal(m, object, offset, VM_KERN_MEMORY_NONE, FALSE, TRUE, TRUE, FALSE, NULL);
			} <span class="enscript-keyword">else</span> {
				vm_page_insert(m, object, offset);
			}
		}
		<span class="enscript-keyword">if</span> (look_for_page) {
			kern_return_t	rc;
			<span class="enscript-type">int</span>		my_fault_type;

			<span class="enscript-comment">/*
			 *	If the memory manager is not ready, we
			 *	cannot make requests.
			 */</span>
			<span class="enscript-keyword">if</span> (!object-&gt;pager_ready) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF000E, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL)
				        VM_PAGE_FREE(m);

				XPR(XPR_VM_FAULT,
				<span class="enscript-string">&quot;vm_f_page: ready wait obj 0x%X, offset 0x%X\n&quot;</span>,
					object, offset, 0, 0, 0);

				<span class="enscript-comment">/*
				 * take an extra ref so object won't die
				 */</span>
				vm_object_reference_locked(object);
				vm_fault_cleanup(object, first_m);
				counter(c_vm_fault_page_block_backoff_kernel++);

				vm_object_lock(object);
				assert(object-&gt;ref_count &gt; 0);

				<span class="enscript-keyword">if</span> (!object-&gt;pager_ready) {
					wait_result = vm_object_assert_wait(object, VM_OBJECT_EVENT_PAGER_READY, interruptible);

					vm_object_unlock(object);
					<span class="enscript-keyword">if</span> (wait_result == THREAD_WAITING)
						wait_result = thread_block(THREAD_CONTINUE_NULL);
					vm_object_deallocate(object);

					<span class="enscript-keyword">goto</span> <span class="enscript-reference">backoff</span>;
				} <span class="enscript-keyword">else</span> {
					vm_object_unlock(object);
					vm_object_deallocate(object);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
				}
			}
			<span class="enscript-keyword">if</span> (!object-&gt;internal &amp;&amp; !object-&gt;phys_contiguous &amp;&amp; object-&gt;paging_in_progress &gt; vm_object_pagein_throttle) {
				<span class="enscript-comment">/*
				 * If there are too many outstanding page
				 * requests pending on this external object, we
				 * wait for them to be resolved now.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
				dbgTrace(0xBEEF0010, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL)
					VM_PAGE_FREE(m);
				<span class="enscript-comment">/*
				 * take an extra ref so object won't die
				 */</span>
				vm_object_reference_locked(object);

				vm_fault_cleanup(object, first_m);

				counter(c_vm_fault_page_block_backoff_kernel++);

				vm_object_lock(object);
				assert(object-&gt;ref_count &gt; 0);

				<span class="enscript-keyword">if</span> (object-&gt;paging_in_progress &gt;= vm_object_pagein_throttle) {
				        vm_object_assert_wait(object, VM_OBJECT_EVENT_PAGING_ONLY_IN_PROGRESS, interruptible);

					vm_object_unlock(object);
					wait_result = thread_block(THREAD_CONTINUE_NULL);
					vm_object_deallocate(object);

					<span class="enscript-keyword">goto</span> <span class="enscript-reference">backoff</span>;
				} <span class="enscript-keyword">else</span> {
					vm_object_unlock(object);
					vm_object_deallocate(object);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
				}
			}
			<span class="enscript-keyword">if</span> (object-&gt;internal &amp;&amp;
			    (COMPRESSED_PAGER_IS_ACTIVE
			     || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE)) {
				<span class="enscript-type">int</span> compressed_count_delta;

				<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {
					<span class="enscript-comment">/*
					 * Allocate a new page for this object/offset pair as a placeholder
					 */</span>
					m = vm_page_grab();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
					dbgTrace(0xBEEF000D, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
					<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {

						vm_fault_cleanup(object, first_m);
						thread_interrupt_level(interruptible_state);

						<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_SHORTAGE);
					}

					m-&gt;absent = TRUE;
					<span class="enscript-keyword">if</span> (fault_info &amp;&amp; fault_info-&gt;batch_pmap_op == TRUE) {
						vm_page_insert_internal(m, object, offset, VM_KERN_MEMORY_NONE, FALSE, TRUE, TRUE, FALSE, NULL);
					} <span class="enscript-keyword">else</span> {
						vm_page_insert(m, object, offset);
					}
				}
				assert(m-&gt;busy);
					
				m-&gt;absent = TRUE;
				pager = object-&gt;pager;

				assert(object-&gt;paging_in_progress &gt; 0);
				vm_object_unlock(object);

				rc = vm_compressor_pager_get(
					pager,
					offset + object-&gt;paging_offset,
					m-&gt;phys_page,
					&amp;my_fault_type,
					0,
					&amp;compressed_count_delta);

				<span class="enscript-keyword">if</span> (type_of_fault == NULL) {
					<span class="enscript-type">int</span>	throttle_delay;

					<span class="enscript-comment">/*
					 * we weren't called from vm_fault, so we
					 * need to apply page creation throttling
					 * do it before we re-acquire any locks
					 */</span>
					<span class="enscript-keyword">if</span> (my_fault_type == DBG_COMPRESSOR_FAULT) {
						<span class="enscript-keyword">if</span> ((throttle_delay = vm_page_throttled(TRUE))) {
							VM_DEBUG_EVENT(vmf_compressordelay, VMF_COMPRESSORDELAY, DBG_FUNC_NONE, throttle_delay, 0, 1, 0);
							delay(throttle_delay);
						}
					}
				}
				vm_object_lock(object);
				assert(object-&gt;paging_in_progress &gt; 0);

				vm_compressor_pager_count(
					pager,
					compressed_count_delta,
					FALSE, <span class="enscript-comment">/* shared_lock */</span>
					object);

				<span class="enscript-keyword">switch</span> (rc) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
					m-&gt;absent = FALSE;
					m-&gt;dirty = TRUE;
					<span class="enscript-keyword">if</span> ((m-&gt;object-&gt;wimg_bits &amp;
					     VM_WIMG_MASK) !=
					    VM_WIMG_USE_DEFAULT) {
						<span class="enscript-comment">/*
						 * If the page is not cacheable,
						 * we can't let its contents
						 * linger in the data cache
						 * after the decompression.
						 */</span>
						pmap_sync_page_attributes_phys(
							m-&gt;phys_page);
					} <span class="enscript-keyword">else</span> {
						m-&gt;written_by_kernel = TRUE;
					}

					<span class="enscript-comment">/*
					 * If the object is purgeable, its
					 * owner's purgeable ledgers have been
					 * updated in vm_page_insert() but the
					 * page was also accounted for in a
					 * &quot;compressed purgeable&quot; ledger, so
					 * update that now.
					 */</span>
					<span class="enscript-keyword">if</span> ((object-&gt;purgable !=
					     VM_PURGABLE_DENY) &amp;&amp;
					    (object-&gt;vo_purgeable_owner !=
					     NULL)) {
						<span class="enscript-comment">/*
						 * One less compressed
						 * purgeable page.
						 */</span>
						vm_purgeable_compressed_update(
							object,
							-1);
					}

					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MEMORY_FAILURE</span>:
					m-&gt;unusual = TRUE;
					m-&gt;error = TRUE;
					m-&gt;absent = FALSE;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MEMORY_ERROR</span>:
					assert(m-&gt;absent);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					panic(<span class="enscript-string">&quot;vm_fault_page(): unexpected &quot;</span>
					      <span class="enscript-string">&quot;error %d from &quot;</span>
					      <span class="enscript-string">&quot;vm_compressor_pager_get()\n&quot;</span>,
					      rc);
				}
				PAGE_WAKEUP_DONE(m);

				rc = KERN_SUCCESS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">data_requested</span>;
			}
			my_fault_type = DBG_PAGEIN_FAULT;
		
			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
				VM_PAGE_FREE(m);
				m = VM_PAGE_NULL;
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
			dbgTrace(0xBEEF0012, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>

			<span class="enscript-comment">/*
			 * It's possible someone called vm_object_destroy while we weren't
			 * holding the object lock.  If that has happened, then bail out 
			 * here.
			 */</span>

			pager = object-&gt;pager;

			<span class="enscript-keyword">if</span> (pager == MEMORY_OBJECT_NULL) {
				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);
				<span class="enscript-keyword">return</span> VM_FAULT_MEMORY_ERROR;
			}

			<span class="enscript-comment">/*
			 * We have an absent page in place for the faulting offset,
			 * so we can release the object lock.
			 */</span>

			vm_object_unlock(object);

			<span class="enscript-comment">/*
			 * If this object uses a copy_call strategy,
			 * and we are interested in a copy of this object
			 * (having gotten here only by following a
			 * shadow chain), then tell the memory manager
			 * via a flag added to the desired_access
			 * parameter, so that it can detect a race
			 * between our walking down the shadow chain
			 * and its pushing pages up into a copy of
			 * the object that it manages.
			 */</span>
			<span class="enscript-keyword">if</span> (object-&gt;copy_strategy == MEMORY_OBJECT_COPY_CALL &amp;&amp; object != first_object)
				wants_copy_flag = VM_PROT_WANTS_COPY;
			<span class="enscript-keyword">else</span>
				wants_copy_flag = VM_PROT_NONE;

			XPR(XPR_VM_FAULT,
			    <span class="enscript-string">&quot;vm_f_page: data_req obj 0x%X, offset 0x%X, page 0x%X, acc %d\n&quot;</span>,
				object, offset, m,
				access_required | wants_copy_flag, 0);

			<span class="enscript-keyword">if</span> (object-&gt;copy == first_object) {
				<span class="enscript-comment">/*
				 * if we issue the memory_object_data_request in
				 * this state, we are subject to a deadlock with
				 * the underlying filesystem if it is trying to
				 * shrink the file resulting in a push of pages
				 * into the copy object...  that push will stall
				 * on the placeholder page, and if the pushing thread
				 * is holding a lock that is required on the pagein
				 * path (such as a truncate lock), we'll deadlock...
				 * to avoid this potential deadlock, we throw away
				 * our placeholder page before calling memory_object_data_request
				 * and force this thread to retry the vm_fault_page after
				 * we have issued the I/O.  the second time through this path
				 * we will find the page already in the cache (presumably still
				 * busy waiting for the I/O to complete) and then complete
				 * the fault w/o having to go through memory_object_data_request again
				 */</span>
				assert(first_m != VM_PAGE_NULL);
				assert(first_m-&gt;object == first_object);
					
				vm_object_lock(first_object);
				VM_PAGE_FREE(first_m);
				vm_object_paging_end(first_object);
				vm_object_unlock(first_object);

				first_m = VM_PAGE_NULL;
				force_fault_retry = TRUE;

				vm_fault_page_forced_retry++;
			}

			<span class="enscript-keyword">if</span> (data_already_requested == TRUE) {
				orig_behavior = fault_info-&gt;behavior;
				orig_cluster_size = fault_info-&gt;cluster_size;

				fault_info-&gt;behavior = VM_BEHAVIOR_RANDOM;
				fault_info-&gt;cluster_size = PAGE_SIZE;
			}
			<span class="enscript-comment">/*
			 * Call the memory manager to retrieve the data.
			 */</span>
			rc = memory_object_data_request(
				pager,
				offset + object-&gt;paging_offset,
				PAGE_SIZE,
				access_required | wants_copy_flag,
				(memory_object_fault_info_t)fault_info);

			<span class="enscript-keyword">if</span> (data_already_requested == TRUE) {
				fault_info-&gt;behavior = orig_behavior;
				fault_info-&gt;cluster_size = orig_cluster_size;
			} <span class="enscript-keyword">else</span>
				data_already_requested = TRUE;

			DTRACE_VM2(maj_fault, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
			dbgTrace(0xBEEF0013, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) rc);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
			vm_object_lock(object);

		<span class="enscript-reference">data_requested</span>:
			<span class="enscript-keyword">if</span> (rc != KERN_SUCCESS) {

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> ((rc == MACH_SEND_INTERRUPTED) ?
					VM_FAULT_INTERRUPTED :
					VM_FAULT_MEMORY_ERROR);
			} <span class="enscript-keyword">else</span> {
				clock_sec_t     tv_sec;
				clock_usec_t    tv_usec;

				<span class="enscript-keyword">if</span> (my_fault_type == DBG_PAGEIN_FAULT) {
					clock_get_system_microtime(&amp;tv_sec, &amp;tv_usec);
					current_thread()-&gt;t_page_creation_time = tv_sec;
					current_thread()-&gt;t_page_creation_count = 0;
				}
			}
			<span class="enscript-keyword">if</span> ((interruptible != THREAD_UNINT) &amp;&amp; (current_thread()-&gt;sched_flags &amp; TH_SFLAG_ABORT)) {

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_INTERRUPTED);
			}
			<span class="enscript-keyword">if</span> (force_fault_retry == TRUE) {

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
			}
			<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL &amp;&amp; object-&gt;phys_contiguous) {
				<span class="enscript-comment">/*
				 * No page here means that the object we
				 * initially looked up was &quot;physically 
				 * contiguous&quot; (i.e. device memory).  However,
				 * with Virtual VRAM, the object might not
				 * be backed by that device memory anymore,
				 * so we're done here only if the object is
				 * still &quot;phys_contiguous&quot;.
				 * Otherwise, if the object is no longer
				 * &quot;phys_contiguous&quot;, we need to retry the
				 * page fault against the object's new backing
				 * store (different memory object).
				 */</span>
			<span class="enscript-reference">phys_contig_object</span>:
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-comment">/*
			 * potentially a pagein fault
			 * if we make it through the state checks
			 * above, than we'll count it as such
			 */</span>
			my_fault = my_fault_type;

			<span class="enscript-comment">/*
			 * Retry with same object/offset, since new data may
			 * be in a different page (i.e., m is meaningless at
			 * this point).
			 */</span>
			<span class="enscript-keyword">continue</span>;
		}
<span class="enscript-reference">dont_look_for_page</span>:
		<span class="enscript-comment">/*
		 * We get here if the object has no pager, or an existence map 
		 * exists and indicates the page isn't present on the pager
		 * or we're unwiring a page.  If a pager exists, but there
		 * is no existence map, then the m-&gt;absent case above handles
		 * the ZF case when the pager can't provide the page
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
		dbgTrace(0xBEEF0014, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (object == first_object)
			first_m = m;
		<span class="enscript-keyword">else</span>
			assert(m == VM_PAGE_NULL);

		XPR(XPR_VM_FAULT,
		    <span class="enscript-string">&quot;vm_f_page: no pager obj 0x%X, offset 0x%X, page 0x%X, next_obj 0x%X\n&quot;</span>,
			object, offset, m,
			object-&gt;shadow, 0);

		next_object = object-&gt;shadow;

		<span class="enscript-keyword">if</span> (next_object == VM_OBJECT_NULL) {
			<span class="enscript-comment">/*
			 * we've hit the bottom of the shadown chain,
			 * fill the page in the top object with zeros.
			 */</span>
			assert(!must_be_resident);

			<span class="enscript-keyword">if</span> (object != first_object) {
				vm_object_paging_end(object);
				vm_object_unlock(object);

				object = first_object;
				offset = first_offset;
				vm_object_lock(object);
			}
			m = first_m;
			assert(m-&gt;object == object);
			first_m = VM_PAGE_NULL;

			<span class="enscript-comment">/*
			 * check for any conditions that prevent
			 * us from creating a new zero-fill page
			 * vm_fault_check will do all of the 
			 * fault cleanup in the case of an error condition
			 * including resetting the thread_interrupt_level
			 */</span>
			error = vm_fault_check(object, m, first_m, interruptible_state, (type_of_fault == NULL) ? TRUE : FALSE);

			<span class="enscript-keyword">if</span> (error != VM_FAULT_SUCCESS)
			        <span class="enscript-keyword">return</span> (error);

			<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {
				m = vm_page_grab();

				<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {
					vm_fault_cleanup(object, VM_PAGE_NULL);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_SHORTAGE);
				}
				vm_page_insert(m, object, offset);
			}
			<span class="enscript-keyword">if</span> (fault_info-&gt;mark_zf_absent &amp;&amp; no_zero_fill == TRUE)
				m-&gt;absent = TRUE;

			my_fault = vm_fault_zero_page(m, no_zero_fill);

			<span class="enscript-keyword">break</span>;

		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * Move on to the next object.  Lock the next
			 * object before unlocking the current one.
			 */</span>
			<span class="enscript-keyword">if</span> ((object != first_object) || must_be_resident)
				vm_object_paging_end(object);

			offset += object-&gt;vo_shadow_offset;
			fault_info-&gt;lo_offset += object-&gt;vo_shadow_offset;
			fault_info-&gt;hi_offset += object-&gt;vo_shadow_offset;
			access_required = VM_PROT_READ;

			vm_object_lock(next_object);
			vm_object_unlock(object);

			object = next_object;
			vm_object_paging_begin(object);
		}
	}

	<span class="enscript-comment">/*
	 *	PAGE HAS BEEN FOUND.
	 *
	 *	This page (m) is:
	 *		busy, so that we can play with it;
	 *		not absent, so that nobody else will fill it;
	 *		possibly eligible for pageout;
	 *
	 *	The top-level page (first_m) is:
	 *		VM_PAGE_NULL if the page was found in the
	 *		 top-level object;
	 *		busy, not absent, and ineligible for pageout.
	 *
	 *	The current object (object) is locked.  A paging
	 *	reference is held for the current and top-level
	 *	objects.
	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
	dbgTrace(0xBEEF0015, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) m);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">EXTRA_ASSERTIONS</span>
	assert(m-&gt;busy &amp;&amp; !m-&gt;absent);
	assert((first_m == VM_PAGE_NULL) ||
	       (first_m-&gt;busy &amp;&amp; !first_m-&gt;absent &amp;&amp;
		!first_m-&gt;active &amp;&amp; !first_m-&gt;inactive));
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* EXTRA_ASSERTIONS */</span>

	<span class="enscript-comment">/*
	 * ENCRYPTED SWAP:
	 * If we found a page, we must have decrypted it before we
	 * get here...
	 */</span>
	ASSERT_PAGE_DECRYPTED(m);

	XPR(XPR_VM_FAULT,
	    <span class="enscript-string">&quot;vm_f_page: FOUND obj 0x%X, off 0x%X, page 0x%X, 1_obj 0x%X, 1_m 0x%X\n&quot;</span>,
		object, offset, m,
		first_object, first_m);

	<span class="enscript-comment">/*
	 * If the page is being written, but isn't
	 * already owned by the top-level object,
	 * we have to copy it into a new page owned
	 * by the top-level object.
	 */</span>
	<span class="enscript-keyword">if</span> (object != first_object) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
		dbgTrace(0xBEEF0016, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) fault_type);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
	    	<span class="enscript-keyword">if</span> (fault_type &amp; VM_PROT_WRITE) {
			vm_page_t copy_m;

			<span class="enscript-comment">/*
			 * We only really need to copy if we
			 * want to write it.
			 */</span>
			assert(!must_be_resident);

			<span class="enscript-comment">/*
			 * are we protecting the system from
			 * backing store exhaustion.  If so
			 * sleep unless we are privileged.
			 */</span>
			<span class="enscript-keyword">if</span> (vm_backing_store_low) {
				<span class="enscript-keyword">if</span> (!(current_task()-&gt;priv_flags &amp; VM_BACKING_STORE_PRIV)) {

					RELEASE_PAGE(m);
					vm_fault_cleanup(object, first_m);

					assert_wait((event_t)&amp;vm_backing_store_low, THREAD_UNINT);

					thread_block(THREAD_CONTINUE_NULL);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
				}
			}
			<span class="enscript-comment">/*
			 * If we try to collapse first_object at this
			 * point, we may deadlock when we try to get
			 * the lock on an intermediate object (since we
			 * have the bottom object locked).  We can't
			 * unlock the bottom object, because the page
			 * we found may move (by collapse) if we do.
			 *
			 * Instead, we first copy the page.  Then, when
			 * we have no more use for the bottom object,
			 * we unlock it and try to collapse.
			 *
			 * Note that we copy the page even if we didn't
			 * need to... that's the breaks.
			 */</span>

			<span class="enscript-comment">/*
			 * Allocate a page for the copy
			 */</span>
			copy_m = vm_page_grab();

			<span class="enscript-keyword">if</span> (copy_m == VM_PAGE_NULL) {
				RELEASE_PAGE(m);

				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_SHORTAGE);
			}
			XPR(XPR_VM_FAULT,
			    <span class="enscript-string">&quot;vm_f_page: page_copy obj 0x%X, offset 0x%X, m 0x%X, copy_m 0x%X\n&quot;</span>,
				object, offset,
				m, copy_m, 0);

			vm_page_copy(m, copy_m);

			<span class="enscript-comment">/*
			 * If another map is truly sharing this
			 * page with us, we have to flush all
			 * uses of the original page, since we
			 * can't distinguish those which want the
			 * original from those which need the
			 * new copy.
			 *
			 * XXXO If we know that only one map has
			 * access to this page, then we could
			 * avoid the pmap_disconnect() call.
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;pmapped)
			        pmap_disconnect(m-&gt;phys_page);

			<span class="enscript-keyword">if</span> (m-&gt;clustered) {
				VM_PAGE_COUNT_AS_PAGEIN(m);
				VM_PAGE_CONSUME_CLUSTERED(m);
			}
			assert(!m-&gt;cleaning);

			<span class="enscript-comment">/*
			 * We no longer need the old page or object.
			 */</span>
			RELEASE_PAGE(m);

			vm_object_paging_end(object);
			vm_object_unlock(object);

			my_fault = DBG_COW_FAULT;
			VM_STAT_INCR(cow_faults);
			DTRACE_VM2(cow_fault, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
			current_task()-&gt;cow_faults++;

			object = first_object;
			offset = first_offset;

			vm_object_lock(object);
			<span class="enscript-comment">/*
			 * get rid of the place holder
			 * page that we soldered in earlier
			 */</span>
			VM_PAGE_FREE(first_m);
			first_m = VM_PAGE_NULL;
			
			<span class="enscript-comment">/*
			 * and replace it with the
			 * page we just copied into
			 */</span>
			assert(copy_m-&gt;busy);
			vm_page_insert(copy_m, object, offset);
			SET_PAGE_DIRTY(copy_m, TRUE);

			m = copy_m;
			<span class="enscript-comment">/*
			 * Now that we've gotten the copy out of the
			 * way, let's try to collapse the top object.
			 * But we have to play ugly games with
			 * paging_in_progress to do that...
			 */</span>     
			vm_object_paging_end(object); 
			vm_object_collapse(object, offset, TRUE);
			vm_object_paging_begin(object);

		} <span class="enscript-keyword">else</span>
		    	*protection &amp;= (~VM_PROT_WRITE);
	}
	<span class="enscript-comment">/*
	 * Now check whether the page needs to be pushed into the
	 * copy object.  The use of asymmetric copy on write for
	 * shared temporary objects means that we may do two copies to
	 * satisfy the fault; one above to get the page from a
	 * shadowed object, and one here to push it into the copy.
	 */</span>
	try_failed_count = 0;

	<span class="enscript-keyword">while</span> ((copy_object = first_object-&gt;copy) != VM_OBJECT_NULL) {
		vm_object_offset_t	copy_offset;
		vm_page_t		copy_m;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
		dbgTrace(0xBEEF0017, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) copy_object, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) fault_type);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * If the page is being written, but hasn't been
		 * copied to the copy-object, we have to copy it there.
		 */</span>
		<span class="enscript-keyword">if</span> ((fault_type &amp; VM_PROT_WRITE) == 0) {
			*protection &amp;= ~VM_PROT_WRITE;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * If the page was guaranteed to be resident,
		 * we must have already performed the copy.
		 */</span>
		<span class="enscript-keyword">if</span> (must_be_resident)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Try to get the lock on the copy_object.
		 */</span>
		<span class="enscript-keyword">if</span> (!vm_object_lock_try(copy_object)) {

			vm_object_unlock(object);
			try_failed_count++;

			mutex_pause(try_failed_count);	<span class="enscript-comment">/* wait a bit */</span>
			vm_object_lock(object);

			<span class="enscript-keyword">continue</span>;
		}
		try_failed_count = 0;

		<span class="enscript-comment">/*
		 * Make another reference to the copy-object,
		 * to keep it from disappearing during the
		 * copy.
		 */</span>
		vm_object_reference_locked(copy_object);

		<span class="enscript-comment">/*
		 * Does the page exist in the copy?
		 */</span>
		copy_offset = first_offset - copy_object-&gt;vo_shadow_offset;

		<span class="enscript-keyword">if</span> (copy_object-&gt;vo_size &lt;= copy_offset)
			<span class="enscript-comment">/*
			 * Copy object doesn't cover this page -- do nothing.
			 */</span>
			;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((copy_m = vm_page_lookup(copy_object, copy_offset)) != VM_PAGE_NULL) {
			<span class="enscript-comment">/*
			 * Page currently exists in the copy object
			 */</span>
			<span class="enscript-keyword">if</span> (copy_m-&gt;busy) {
				<span class="enscript-comment">/*
				 * If the page is being brought
				 * in, wait for it and then retry.
				 */</span>
				RELEASE_PAGE(m);

				<span class="enscript-comment">/*
				 * take an extra ref so object won't die
				 */</span>
				vm_object_reference_locked(copy_object);
				vm_object_unlock(copy_object);
				vm_fault_cleanup(object, first_m);
				counter(c_vm_fault_page_block_backoff_kernel++);

				vm_object_lock(copy_object);
				assert(copy_object-&gt;ref_count &gt; 0);
				VM_OBJ_RES_DECR(copy_object);
				vm_object_lock_assert_exclusive(copy_object);
				copy_object-&gt;ref_count--;
				assert(copy_object-&gt;ref_count &gt; 0);
				copy_m = vm_page_lookup(copy_object, copy_offset);
				<span class="enscript-comment">/*
				 * ENCRYPTED SWAP:
				 * it's OK if the &quot;copy_m&quot; page is encrypted,
				 * because we're not moving it nor handling its
				 * contents.
				 */</span>
				<span class="enscript-keyword">if</span> (copy_m != VM_PAGE_NULL &amp;&amp; copy_m-&gt;busy) {
					PAGE_ASSERT_WAIT(copy_m, interruptible);

					vm_object_unlock(copy_object);
					wait_result = thread_block(THREAD_CONTINUE_NULL);
					vm_object_deallocate(copy_object);

					<span class="enscript-keyword">goto</span> <span class="enscript-reference">backoff</span>;
				} <span class="enscript-keyword">else</span> {
					vm_object_unlock(copy_object);
					vm_object_deallocate(copy_object);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
				}
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!PAGED_OUT(copy_object, copy_offset)) {
			<span class="enscript-comment">/*
			 * If PAGED_OUT is TRUE, then the page used to exist
			 * in the copy-object, and has already been paged out.
			 * We don't need to repeat this. If PAGED_OUT is
			 * FALSE, then either we don't know (!pager_created,
			 * for example) or it hasn't been paged out.
			 * (VM_EXTERNAL_STATE_UNKNOWN||VM_EXTERNAL_STATE_ABSENT)
			 * We must copy the page to the copy object.
			 */</span>

			<span class="enscript-keyword">if</span> (vm_backing_store_low) {
			        <span class="enscript-comment">/*
				 * we are protecting the system from
				 * backing store exhaustion.  If so
				 * sleep unless we are privileged.
				 */</span>
				<span class="enscript-keyword">if</span> (!(current_task()-&gt;priv_flags &amp; VM_BACKING_STORE_PRIV)) {
					assert_wait((event_t)&amp;vm_backing_store_low, THREAD_UNINT);

					RELEASE_PAGE(m);
					VM_OBJ_RES_DECR(copy_object);
					vm_object_lock_assert_exclusive(copy_object);
					copy_object-&gt;ref_count--;
					assert(copy_object-&gt;ref_count &gt; 0);

					vm_object_unlock(copy_object);
					vm_fault_cleanup(object, first_m);
					thread_block(THREAD_CONTINUE_NULL);
					thread_interrupt_level(interruptible_state);

					<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);
				}
			}
			<span class="enscript-comment">/*
			 * Allocate a page for the copy
			 */</span>
			copy_m = vm_page_alloc(copy_object, copy_offset);

			<span class="enscript-keyword">if</span> (copy_m == VM_PAGE_NULL) {
				RELEASE_PAGE(m);

				VM_OBJ_RES_DECR(copy_object);
				vm_object_lock_assert_exclusive(copy_object);
				copy_object-&gt;ref_count--;
				assert(copy_object-&gt;ref_count &gt; 0);

				vm_object_unlock(copy_object);
				vm_fault_cleanup(object, first_m);
				thread_interrupt_level(interruptible_state);

				<span class="enscript-keyword">return</span> (VM_FAULT_MEMORY_SHORTAGE);
			}
			<span class="enscript-comment">/*
			 * Must copy page into copy-object.
			 */</span>
			vm_page_copy(m, copy_m);
			
			<span class="enscript-comment">/*
			 * If the old page was in use by any users
			 * of the copy-object, it must be removed
			 * from all pmaps.  (We can't know which
			 * pmaps use it.)
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;pmapped)
			        pmap_disconnect(m-&gt;phys_page);

			<span class="enscript-keyword">if</span> (m-&gt;clustered) {
				VM_PAGE_COUNT_AS_PAGEIN(m);
				VM_PAGE_CONSUME_CLUSTERED(m);
			}
			<span class="enscript-comment">/*
			 * If there's a pager, then immediately
			 * page out this page, using the &quot;initialize&quot;
			 * option.  Else, we use the copy.
			 */</span>
		 	<span class="enscript-keyword">if</span> ((!copy_object-&gt;pager_ready)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_PAGEMAP</span>
			    || vm_external_state_get(copy_object-&gt;existence_map, copy_offset) == VM_EXTERNAL_STATE_ABSENT
#<span class="enscript-reference">endif</span>
			    || VM_COMPRESSOR_PAGER_STATE_GET(copy_object, copy_offset) == VM_EXTERNAL_STATE_ABSENT
			    ) {

				vm_page_lockspin_queues();
				assert(!m-&gt;cleaning);
				vm_page_activate(copy_m);
				vm_page_unlock_queues();

				SET_PAGE_DIRTY(copy_m, TRUE);
				PAGE_WAKEUP_DONE(copy_m);

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (copy_object-&gt;internal &amp;&amp;
				   (DEFAULT_PAGER_IS_ACTIVE || DEFAULT_FREEZER_IS_ACTIVE)) {
				<span class="enscript-comment">/*
				 * For internal objects check with the pager to see
				 * if the page already exists in the backing store.
				 * If yes, then we can drop the copy page. If not,
				 * then we'll activate it, mark it dirty and keep it
				 * around.
				 */</span>
				
				kern_return_t kr = KERN_SUCCESS;

				memory_object_t	copy_pager = copy_object-&gt;pager;
				assert(copy_pager != MEMORY_OBJECT_NULL);
				vm_object_paging_begin(copy_object);

				vm_object_unlock(copy_object);

				kr = memory_object_data_request(
					copy_pager,
					copy_offset + copy_object-&gt;paging_offset,
					0, <span class="enscript-comment">/* Only query the pager. */</span>
					VM_PROT_READ,
					NULL);
				
				vm_object_lock(copy_object);

				vm_object_paging_end(copy_object);

				<span class="enscript-comment">/*
				 * Since we dropped the copy_object's lock,
				 * check whether we'll have to deallocate 
				 * the hard way.
				 */</span>
				<span class="enscript-keyword">if</span> ((copy_object-&gt;shadow != object) || (copy_object-&gt;ref_count == 1)) {
					vm_object_unlock(copy_object);
					vm_object_deallocate(copy_object);
					vm_object_lock(object);

					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
					<span class="enscript-comment">/*
					 * The pager has the page. We don't want to overwrite
					 * that page by sending this one out to the backing store.
					 * So we drop the copy page.
					 */</span>
					VM_PAGE_FREE(copy_m);

				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * The pager doesn't have the page. We'll keep this one
					 * around in the copy object. It might get sent out to 
					 * the backing store under memory pressure.	 
					 */</span>
					vm_page_lockspin_queues();
					assert(!m-&gt;cleaning);
					vm_page_activate(copy_m);
					vm_page_unlock_queues();

					SET_PAGE_DIRTY(copy_m, TRUE);
					PAGE_WAKEUP_DONE(copy_m);
				} 
			} <span class="enscript-keyword">else</span> {
				
				assert(copy_m-&gt;busy == TRUE);
				assert(!m-&gt;cleaning);

				<span class="enscript-comment">/*
				 * dirty is protected by the object lock
				 */</span>
				SET_PAGE_DIRTY(copy_m, TRUE);

				<span class="enscript-comment">/*
				 * The page is already ready for pageout:
				 * not on pageout queues and busy.
				 * Unlock everything except the
				 * copy_object itself.
				 */</span>
				vm_object_unlock(object);

				<span class="enscript-comment">/*
				 * Write the page to the copy-object,
				 * flushing it from the kernel.
				 */</span>
				vm_pageout_initialize_page(copy_m);

				<span class="enscript-comment">/*
				 * Since the pageout may have
				 * temporarily dropped the
				 * copy_object's lock, we
				 * check whether we'll have
				 * to deallocate the hard way.
				 */</span>
				<span class="enscript-keyword">if</span> ((copy_object-&gt;shadow != object) || (copy_object-&gt;ref_count == 1)) {
					vm_object_unlock(copy_object);
					vm_object_deallocate(copy_object);
					vm_object_lock(object);

					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/*
				 * Pick back up the old object's
				 * lock.  [It is safe to do so,
				 * since it must be deeper in the
				 * object tree.]
				 */</span>
				vm_object_lock(object);
			}

			<span class="enscript-comment">/*
			 * Because we're pushing a page upward
			 * in the object tree, we must restart
			 * any faults that are waiting here.
			 * [Note that this is an expansion of
			 * PAGE_WAKEUP that uses the THREAD_RESTART
			 * wait result].  Can't turn off the page's
			 * busy bit because we're not done with it.
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;wanted) {
				m-&gt;wanted = FALSE;
				thread_wakeup_with_result((event_t) m, THREAD_RESTART);
			}
		}
		<span class="enscript-comment">/*
		 * The reference count on copy_object must be
		 * at least 2: one for our extra reference,
		 * and at least one from the outside world
		 * (we checked that when we last locked
		 * copy_object).
		 */</span>
		vm_object_lock_assert_exclusive(copy_object);
		copy_object-&gt;ref_count--;
		assert(copy_object-&gt;ref_count &gt; 0);

		VM_OBJ_RES_DECR(copy_object);	
		vm_object_unlock(copy_object);

		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	*result_page = m;
	*top_page = first_m;

	XPR(XPR_VM_FAULT,
		<span class="enscript-string">&quot;vm_f_page: DONE obj 0x%X, offset 0x%X, m 0x%X, first_m 0x%X\n&quot;</span>,
		object, offset, m, first_m, 0);

	<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
		retval = VM_FAULT_SUCCESS;

		<span class="enscript-keyword">if</span> (my_fault == DBG_PAGEIN_FAULT) {

			VM_PAGE_COUNT_AS_PAGEIN(m);

			<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal)
				my_fault = DBG_PAGEIND_FAULT;
			<span class="enscript-keyword">else</span>
				my_fault = DBG_PAGEINV_FAULT;

		        <span class="enscript-comment">/*
			 * evaluate access pattern and update state
			 * vm_fault_deactivate_behind depends on the
			 * state being up to date
			 */</span>
		        vm_fault_is_sequential(object, offset, fault_info-&gt;behavior);

			vm_fault_deactivate_behind(object, offset, fault_info-&gt;behavior);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (my_fault == DBG_COMPRESSOR_FAULT || my_fault == DBG_COMPRESSOR_SWAPIN_FAULT) {

			VM_STAT_INCR(decompressions);
		}
		<span class="enscript-keyword">if</span> (type_of_fault)
		        *type_of_fault = my_fault;
	} <span class="enscript-keyword">else</span> {
		retval = VM_FAULT_SUCCESS_NO_VM_PAGE;
		assert(first_m == VM_PAGE_NULL);
		assert(object == first_object);
	}

	thread_interrupt_level(interruptible_state);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRACEFAULTPAGE</span>
	dbgTrace(0xBEEF001A, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) VM_FAULT_SUCCESS, 0);	<span class="enscript-comment">/* (TEST/DEBUG) */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> retval;

<span class="enscript-reference">backoff</span>:
	thread_interrupt_level(interruptible_state);

	<span class="enscript-keyword">if</span> (wait_result == THREAD_INTERRUPTED)
		<span class="enscript-keyword">return</span> (VM_FAULT_INTERRUPTED);
	<span class="enscript-keyword">return</span> (VM_FAULT_RETRY);

#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">RELEASE_PAGE</span>
}



<span class="enscript-comment">/*
 * CODE SIGNING:
 * When soft faulting a page, we have to validate the page if:
 * 1. the page is being mapped in user space
 * 2. the page hasn't already been found to be &quot;tainted&quot;
 * 3. the page belongs to a code-signed object
 * 4. the page has not been validated yet or has been mapped for write.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_FAULT_NEED_CS_VALIDATION</span>(pmap, page)				\
	((pmap) != kernel_pmap <span class="enscript-comment">/*1*/</span> &amp;&amp;					\
	 !(page)-&gt;cs_tainted <span class="enscript-comment">/*2*/</span> &amp;&amp;					\
	 (page)-&gt;object-&gt;code_signed <span class="enscript-comment">/*3*/</span> &amp;&amp;				\
	 (!(page)-&gt;cs_validated || (page)-&gt;wpmapped <span class="enscript-comment">/*4*/</span>))


<span class="enscript-comment">/*
 * page queue lock must NOT be held
 * m-&gt;object must be locked
 *
 * NOTE: m-&gt;object could be locked &quot;shared&quot; only if we are called
 * from vm_fault() as part of a soft fault.  If so, we must be
 * careful not to modify the VM object in any way that is not
 * legal under a shared lock...
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_selfpid</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *p);
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> cs_enter_tainted_rejected = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> cs_enter_tainted_accepted = 0;
kern_return_t
<span class="enscript-function-name">vm_fault_enter</span>(vm_page_t m,
	       pmap_t pmap,
	       vm_map_offset_t vaddr,
	       vm_prot_t prot,
	       vm_prot_t caller_prot,
	       boolean_t wired,
	       boolean_t change_wiring,
	       boolean_t no_cache,
	       boolean_t cs_bypass,
	       __unused <span class="enscript-type">int</span>	 user_tag,
	       <span class="enscript-type">int</span>	 pmap_options,
	       boolean_t *need_retry,
	       <span class="enscript-type">int</span> *type_of_fault)
{
	kern_return_t	kr, pe_result;
	boolean_t	previously_pmapped = m-&gt;pmapped;
	boolean_t	must_disconnect = 0;
	boolean_t	map_is_switched, map_is_switch_protected;
	<span class="enscript-type">int</span>		cs_enforcement_enabled;
	vm_prot_t       fault_type;
	
	fault_type = change_wiring ? VM_PROT_NONE : caller_prot;

	vm_object_lock_assert_held(m-&gt;object);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_NOTOWNED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">if</span> (m-&gt;phys_page == vm_page_guard_addr) {
		assert(m-&gt;fictitious);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">if</span> (*type_of_fault == DBG_ZERO_FILL_FAULT) {

		vm_object_lock_assert_exclusive(m-&gt;object);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((fault_type &amp; VM_PROT_WRITE) == 0) {
		<span class="enscript-comment">/*
		 * This is not a &quot;write&quot; fault, so we
		 * might not have taken the object lock
		 * exclusively and we might not be able
		 * to update the &quot;wpmapped&quot; bit in
		 * vm_fault_enter().
		 * Let's just grant read access to
		 * the page for now and we'll
		 * soft-fault again if we need write
		 * access later...
		 */</span>
		prot &amp;= ~VM_PROT_WRITE;
	}
	<span class="enscript-keyword">if</span> (m-&gt;pmapped == FALSE) {

		<span class="enscript-keyword">if</span> (m-&gt;clustered) {
			<span class="enscript-keyword">if</span> (*type_of_fault == DBG_CACHE_HIT_FAULT) {
				<span class="enscript-comment">/*
				 * found it in the cache, but this
				 * is the first fault-in of the page (m-&gt;pmapped == FALSE)
				 * so it must have come in as part of
				 * a cluster... account 1 pagein against it
				 */</span>
				<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal)
					*type_of_fault = DBG_PAGEIND_FAULT;
				<span class="enscript-keyword">else</span>
					*type_of_fault = DBG_PAGEINV_FAULT;
				
				VM_PAGE_COUNT_AS_PAGEIN(m);
			}
			VM_PAGE_CONSUME_CLUSTERED(m);
		}
	}

	<span class="enscript-keyword">if</span> (*type_of_fault != DBG_COW_FAULT) {
		DTRACE_VM2(as_fault, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);

		<span class="enscript-keyword">if</span> (pmap == kernel_pmap) {
			DTRACE_VM2(kernel_asflt, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
		}
	}

	<span class="enscript-comment">/* Validate code signature if necessary. */</span>
	<span class="enscript-keyword">if</span> (VM_FAULT_NEED_CS_VALIDATION(pmap, m)) {
		vm_object_lock_assert_exclusive(m-&gt;object);

		<span class="enscript-keyword">if</span> (m-&gt;cs_validated) {
			vm_cs_revalidates++;
		}

		<span class="enscript-comment">/* VM map is locked, so 1 ref will remain on VM object - 
		 * so no harm if vm_page_validate_cs drops the object lock */</span>
		vm_page_validate_cs(m);
	}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">page_immutable</span>(m,prot) ((m)-&gt;cs_validated <span class="enscript-comment">/*&amp;&amp; ((prot) &amp; VM_PROT_EXECUTE)*/</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">page_nx</span>(m) ((m)-&gt;cs_nx)

	map_is_switched = ((pmap != vm_map_pmap(current_task()-&gt;map)) &amp;&amp;
			   (pmap == vm_map_pmap(current_thread()-&gt;map)));
	map_is_switch_protected = current_thread()-&gt;map-&gt;switch_protect;
	
	<span class="enscript-comment">/* If the map is switched, and is switch-protected, we must protect
	 * some pages from being write-faulted: immutable pages because by 
	 * definition they may not be written, and executable pages because that
	 * would provide a way to inject unsigned code.
	 * If the page is immutable, we can simply return. However, we can't
	 * immediately determine whether a page is executable anywhere. But,
	 * we can disconnect it everywhere and remove the executable protection
	 * from the current map. We do that below right before we do the 
	 * PMAP_ENTER.
	 */</span>
	cs_enforcement_enabled = cs_enforcement(NULL);

	<span class="enscript-keyword">if</span>(cs_enforcement_enabled &amp;&amp; map_is_switched &amp;&amp; 
	   map_is_switch_protected &amp;&amp; page_immutable(m, prot) &amp;&amp; 
	   (prot &amp; VM_PROT_WRITE))
	{
		<span class="enscript-keyword">return</span> KERN_CODESIGN_ERROR;
	}

	<span class="enscript-keyword">if</span> (cs_enforcement_enabled &amp;&amp; page_nx(m) &amp;&amp; (prot &amp; VM_PROT_EXECUTE)) {
		<span class="enscript-keyword">if</span> (cs_debug)
			printf(<span class="enscript-string">&quot;page marked to be NX, not letting it be mapped EXEC\n&quot;</span>);
		<span class="enscript-keyword">return</span> KERN_CODESIGN_ERROR;
	}

	<span class="enscript-comment">/* A page could be tainted, or pose a risk of being tainted later.
	 * Check whether the receiving process wants it, and make it feel
	 * the consequences (that hapens in cs_invalid_page()).
	 * For CS Enforcement, two other conditions will 
	 * cause that page to be tainted as well: 
	 * - pmapping an unsigned page executable - this means unsigned code;
	 * - writeable mapping of a validated page - the content of that page
	 *   can be changed without the kernel noticing, therefore unsigned
	 *   code can be created
	 */</span>
	<span class="enscript-keyword">if</span> (!cs_bypass &amp;&amp;
	    (m-&gt;cs_tainted ||
	     (cs_enforcement_enabled &amp;&amp;
	      (<span class="enscript-comment">/* The page is unsigned and wants to be executable */</span>
	       (!m-&gt;cs_validated &amp;&amp; (prot &amp; VM_PROT_EXECUTE))  ||
	       <span class="enscript-comment">/* The page should be immutable, but is in danger of being modified
		* This is the case where we want policy from the code directory -
		* is the page immutable or not? For now we have to assume that 
		* code pages will be immutable, data pages not.
		* We'll assume a page is a code page if it has a code directory 
		* and we fault for execution.
		* That is good enough since if we faulted the code page for
		* writing in another map before, it is wpmapped; if we fault
		* it for writing in this map later it will also be faulted for executing 
		* at the same time; and if we fault for writing in another map
		* later, we will disconnect it from this pmap so we'll notice
		* the change.
		*/</span>
	      (page_immutable(m, prot) &amp;&amp; ((prot &amp; VM_PROT_WRITE) || m-&gt;wpmapped))
	      ))
		    )) 
	{
		<span class="enscript-comment">/* We will have a tainted page. Have to handle the special case
		 * of a switched map now. If the map is not switched, standard
		 * procedure applies - call cs_invalid_page().
		 * If the map is switched, the real owner is invalid already.
		 * There is no point in invalidating the switching process since
		 * it will not be executing from the map. So we don't call
		 * cs_invalid_page() in that case. */</span>
		boolean_t reject_page;
		<span class="enscript-keyword">if</span>(map_is_switched) { 
			assert(pmap==vm_map_pmap(current_thread()-&gt;map));
			assert(!(prot &amp; VM_PROT_WRITE) || (map_is_switch_protected == FALSE));
			reject_page = FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (cs_debug &gt; 5)
				printf(<span class="enscript-string">&quot;vm_fault: signed: %s validate: %s tainted: %s wpmapped: %s slid: %s prot: 0x%x\n&quot;</span>, 
				       m-&gt;object-&gt;code_signed ? <span class="enscript-string">&quot;yes&quot;</span> : <span class="enscript-string">&quot;no&quot;</span>,
				       m-&gt;cs_validated ? <span class="enscript-string">&quot;yes&quot;</span> : <span class="enscript-string">&quot;no&quot;</span>,
				       m-&gt;cs_tainted ? <span class="enscript-string">&quot;yes&quot;</span> : <span class="enscript-string">&quot;no&quot;</span>,
				       m-&gt;wpmapped ? <span class="enscript-string">&quot;yes&quot;</span> : <span class="enscript-string">&quot;no&quot;</span>,
				       m-&gt;slid ? <span class="enscript-string">&quot;yes&quot;</span> : <span class="enscript-string">&quot;no&quot;</span>,
				       (<span class="enscript-type">int</span>)prot);
			reject_page = cs_invalid_page((addr64_t) vaddr);
		}
		
		<span class="enscript-keyword">if</span> (reject_page) {
			<span class="enscript-comment">/* reject the invalid page: abort the page fault */</span>
			<span class="enscript-type">int</span>			pid;
			<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*procname;
			task_t			task;
			vm_object_t		file_object, shadow;
			vm_object_offset_t	file_offset;
			<span class="enscript-type">char</span>			*pathname, *filename;
			vm_size_t		pathname_len, filename_len;
			boolean_t		truncated_path;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__PATH_MAX</span> 1024
			<span class="enscript-type">struct</span> timespec		mtime, cs_mtime;

			kr = KERN_CODESIGN_ERROR;
			cs_enter_tainted_rejected++;

			<span class="enscript-comment">/* get process name and pid */</span>
			procname = <span class="enscript-string">&quot;?&quot;</span>;
			task = current_task();
			pid = proc_selfpid();
			<span class="enscript-keyword">if</span> (task-&gt;bsd_info != NULL)
				procname = proc_name_address(task-&gt;bsd_info);

			<span class="enscript-comment">/* get file's VM object */</span>
			file_object = m-&gt;object;
			file_offset = m-&gt;offset;
			<span class="enscript-keyword">for</span> (shadow = file_object-&gt;shadow;
			     shadow != VM_OBJECT_NULL;
			     shadow = file_object-&gt;shadow) {
				vm_object_lock_shared(shadow);
				<span class="enscript-keyword">if</span> (file_object != m-&gt;object) {
					vm_object_unlock(file_object);
				}
				file_offset += file_object-&gt;vo_shadow_offset;
				file_object = shadow;
			}

			mtime.tv_sec = 0;
			mtime.tv_nsec = 0;
			cs_mtime.tv_sec = 0;
			cs_mtime.tv_nsec = 0;

			<span class="enscript-comment">/* get file's pathname and/or filename */</span>
			pathname = NULL;
			filename = NULL;
			pathname_len = 0;
			filename_len = 0;
			truncated_path = FALSE;
			<span class="enscript-comment">/* no pager -&gt; no file -&gt; no pathname, use &quot;&lt;nil&gt;&quot; in that case */</span>
			<span class="enscript-keyword">if</span> (file_object-&gt;pager != NULL) {
				pathname = (<span class="enscript-type">char</span> *)kalloc(__PATH_MAX * 2);
				<span class="enscript-keyword">if</span> (pathname) {
					pathname[0] = <span class="enscript-string">'\0'</span>;
					pathname_len = __PATH_MAX;
					filename = pathname + pathname_len;
					filename_len = __PATH_MAX;
				}
				vnode_pager_get_object_name(file_object-&gt;pager,
							    pathname,
							    pathname_len,
							    filename,
							    filename_len,
							    &amp;truncated_path);
				<span class="enscript-keyword">if</span> (pathname) {
					<span class="enscript-comment">/* safety first... */</span>
					pathname[__PATH_MAX-1] = <span class="enscript-string">'\0'</span>;
					filename[__PATH_MAX-1] = <span class="enscript-string">'\0'</span>;
				}
				vnode_pager_get_object_mtime(file_object-&gt;pager,
							     &amp;mtime,
							     &amp;cs_mtime);
			}
			printf(<span class="enscript-string">&quot;CODE SIGNING: process %d[%s]: &quot;</span>
			       <span class="enscript-string">&quot;rejecting invalid page at address 0x%llx &quot;</span>
			       <span class="enscript-string">&quot;from offset 0x%llx in file \&quot;%s%s%s\&quot; &quot;</span>
			       <span class="enscript-string">&quot;(cs_mtime:%lu.%ld %s mtime:%lu.%ld) &quot;</span>
			       <span class="enscript-string">&quot;(signed:%d validated:%d tainted:%d &quot;</span>
			       <span class="enscript-string">&quot;wpmapped:%d slid:%d)\n&quot;</span>,
			       pid, procname, (addr64_t) vaddr,
			       file_offset,
			       (pathname ? pathname : <span class="enscript-string">&quot;&lt;nil&gt;&quot;</span>),
			       (truncated_path ? <span class="enscript-string">&quot;/.../&quot;</span> : <span class="enscript-string">&quot;&quot;</span>),
			       (truncated_path ? filename : <span class="enscript-string">&quot;&quot;</span>),
			       cs_mtime.tv_sec, cs_mtime.tv_nsec,
			       ((cs_mtime.tv_sec == mtime.tv_sec &amp;&amp;
				 cs_mtime.tv_nsec == mtime.tv_nsec)
				? <span class="enscript-string">&quot;==&quot;</span>
				: <span class="enscript-string">&quot;!=&quot;</span>),
			       mtime.tv_sec, mtime.tv_nsec,
			       m-&gt;object-&gt;code_signed,
			       m-&gt;cs_validated,
			       m-&gt;cs_tainted,
			       m-&gt;wpmapped,
			       m-&gt;slid);
			<span class="enscript-keyword">if</span> (file_object != m-&gt;object) {
				vm_object_unlock(file_object);
			}
			<span class="enscript-keyword">if</span> (pathname_len != 0) {
				kfree(pathname, __PATH_MAX * 2);
				pathname = NULL;
				filename = NULL;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* proceed with the invalid page */</span>
			kr = KERN_SUCCESS;
			<span class="enscript-keyword">if</span> (!m-&gt;cs_validated) {
				<span class="enscript-comment">/*
				 * This page has not been validated, so it
				 * must not belong to a code-signed object
				 * and should not be forcefully considered
				 * as tainted.
				 * We're just concerned about it here because
				 * we've been asked to &quot;execute&quot; it but that
				 * does not mean that it should cause other
				 * accesses to fail.
				 * This happens when a debugger sets a
				 * breakpoint and we then execute code in
				 * that page.  Marking the page as &quot;tainted&quot;
				 * would cause any inspection tool (&quot;leaks&quot;,
				 * &quot;vmmap&quot;, &quot;CrashReporter&quot;, ...) to get killed
				 * due to code-signing violation on that page,
				 * even though they're just reading it and not
				 * executing from it.
				 */</span>
				assert(!m-&gt;object-&gt;code_signed);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Page might have been tainted before or not;
				 * now it definitively is. If the page wasn't
				 * tainted, we must disconnect it from all
				 * pmaps later, to force existing mappings
				 * through that code path for re-consideration
				 * of the validity of that page.
				 */</span>
				must_disconnect = !m-&gt;cs_tainted;
				m-&gt;cs_tainted = TRUE;
			}
			cs_enter_tainted_accepted++;
		}
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-keyword">if</span> (cs_debug) {
				printf(<span class="enscript-string">&quot;CODESIGNING: vm_fault_enter(0x%llx): &quot;</span>
				       <span class="enscript-string">&quot;*** INVALID PAGE ***\n&quot;</span>,
				       (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)vaddr);
			}
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
			<span class="enscript-keyword">if</span> (cs_enforcement_panic) {
				panic(<span class="enscript-string">&quot;CODESIGNING: panicking on invalid page\n&quot;</span>);
			}
#<span class="enscript-reference">endif</span>
		}
		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* proceed with the valid page */</span>
		kr = KERN_SUCCESS;
	}

	boolean_t	page_queues_locked = FALSE;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__VM_PAGE_LOCKSPIN_QUEUES_IF_NEEDED</span>()	\
MACRO_BEGIN			    		\
	<span class="enscript-keyword">if</span> (! page_queues_locked) {		\
		page_queues_locked = TRUE;	\
		vm_page_lockspin_queues();	\
	}					\
MACRO_END
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__VM_PAGE_UNLOCK_QUEUES_IF_NEEDED</span>()	\
MACRO_BEGIN			    		\
	<span class="enscript-keyword">if</span> (page_queues_locked) {		\
		page_queues_locked = FALSE;	\
		vm_page_unlock_queues();	\
	}					\
MACRO_END

	<span class="enscript-comment">/*
	 * Hold queues lock to manipulate
	 * the page queues.  Change wiring
	 * case is obvious.
	 */</span>
	assert(m-&gt;compressor || m-&gt;object != compressor_object);
	<span class="enscript-keyword">if</span> (m-&gt;compressor) {
		<span class="enscript-comment">/*
		 * Compressor pages are neither wired
		 * nor pageable and should never change.
		 */</span>
		assert(m-&gt;object == compressor_object);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (change_wiring) {
	        __VM_PAGE_LOCKSPIN_QUEUES_IF_NEEDED();

		<span class="enscript-keyword">if</span> (wired) {
			<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
				vm_page_wire(m, VM_PROT_MEMORY_TAG(caller_prot), TRUE);
			}
		} <span class="enscript-keyword">else</span> {
		        vm_page_unwire(m, TRUE);
		}
		<span class="enscript-comment">/* we keep the page queues lock, if we need it later */</span>

	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		        __VM_PAGE_LOCKSPIN_QUEUES_IF_NEEDED();
		        vm_page_deactivate(m);
			<span class="enscript-comment">/* we keep the page queues lock, if we need it later */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((!m-&gt;active &amp;&amp; !m-&gt;inactive) ||
			    m-&gt;clean_queue ||
			    no_cache) &amp;&amp;
			   !VM_PAGE_WIRED(m) &amp;&amp; !m-&gt;throttled) {

			<span class="enscript-keyword">if</span> (vm_page_local_q &amp;&amp;
			    !no_cache &amp;&amp;
			    (*type_of_fault == DBG_COW_FAULT ||
			     *type_of_fault == DBG_ZERO_FILL_FAULT) ) {
				<span class="enscript-type">struct</span> vpl	*lq;
				uint32_t	lid;

				__VM_PAGE_UNLOCK_QUEUES_IF_NEEDED();
				vm_object_lock_assert_exclusive(m-&gt;object);

				<span class="enscript-comment">/*
				 * we got a local queue to stuff this
				 * new page on...
				 * its safe to manipulate local and
				 * local_id at this point since we're
				 * behind an exclusive object lock and
				 * the page is not on any global queue.
				 *
				 * we'll use the current cpu number to
				 * select the queue note that we don't
				 * need to disable preemption... we're
				 * going to behind the local queue's
				 * lock to do the real work
				 */</span>
				lid = cpu_number();

				lq = &amp;vm_page_local_q[lid].vpl_un.vpl;

				VPL_LOCK(&amp;lq-&gt;vpl_lock);

				vm_page_check_pageable_safe(m);
				queue_enter(&amp;lq-&gt;vpl_queue, m,
					    vm_page_t, pageq);
				m-&gt;local = TRUE;
				m-&gt;local_id = lid;
				lq-&gt;vpl_count++;
					
				<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal)
					lq-&gt;vpl_internal_count++;
				<span class="enscript-keyword">else</span>
					lq-&gt;vpl_external_count++;

				VPL_UNLOCK(&amp;lq-&gt;vpl_lock);

				<span class="enscript-keyword">if</span> (lq-&gt;vpl_count &gt; vm_page_local_q_soft_limit)
				{
					<span class="enscript-comment">/*
					 * we're beyond the soft limit
					 * for the local queue
					 * vm_page_reactivate_local will
					 * 'try' to take the global page
					 * queue lock... if it can't
					 * that's ok... we'll let the
					 * queue continue to grow up
					 * to the hard limit... at that
					 * point we'll wait for the
					 * lock... once we've got the
					 * lock, we'll transfer all of
					 * the pages from the local
					 * queue to the global active
					 * queue
					 */</span>
					vm_page_reactivate_local(lid, FALSE, FALSE);
				}
			} <span class="enscript-keyword">else</span> {

				__VM_PAGE_LOCKSPIN_QUEUES_IF_NEEDED();

				<span class="enscript-comment">/*
				 * test again now that we hold the
				 * page queue lock
				 */</span>
				<span class="enscript-keyword">if</span> (!VM_PAGE_WIRED(m)) {
					<span class="enscript-keyword">if</span> (m-&gt;clean_queue) {
						vm_page_queues_remove(m);

						vm_pageout_cleaned_reactivated++;
						vm_pageout_cleaned_fault_reactivated++;
					}

					<span class="enscript-keyword">if</span> ((!m-&gt;active &amp;&amp;
					     !m-&gt;inactive) ||
					    no_cache) {
						<span class="enscript-comment">/*
						 * If this is a no_cache mapping
						 * and the page has never been
						 * mapped before or was
						 * previously a no_cache page,
						 * then we want to leave pages
						 * in the speculative state so
						 * that they can be readily
						 * recycled if free memory runs
						 * low.  Otherwise the page is
						 * activated as normal. 
						 */</span>

						<span class="enscript-keyword">if</span> (no_cache &amp;&amp;
						    (!previously_pmapped ||
						     m-&gt;no_cache)) {
							m-&gt;no_cache = TRUE;

							<span class="enscript-keyword">if</span> (!m-&gt;speculative) 
								vm_page_speculate(m, FALSE);

						} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!m-&gt;active &amp;&amp;
							   !m-&gt;inactive) {

							vm_page_activate(m);
						}
					}
				}
				<span class="enscript-comment">/* we keep the page queues lock, if we need it later */</span>
			}
		}
	}
	<span class="enscript-comment">/* we're done with the page queues lock, if we ever took it */</span>
	__VM_PAGE_UNLOCK_QUEUES_IF_NEEDED();


	<span class="enscript-comment">/* If we have a KERN_SUCCESS from the previous checks, we either have
	 * a good page, or a tainted page that has been accepted by the process.
	 * In both cases the page will be entered into the pmap.
	 * If the page is writeable, we need to disconnect it from other pmaps
	 * now so those processes can take note.
	 */</span>
	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {

	        <span class="enscript-comment">/*
		 * NOTE: we may only hold the vm_object lock SHARED
		 * at this point, so we need the phys_page lock to 
		 * properly serialize updating the pmapped and
		 * xpmapped bits
		 */</span>
		<span class="enscript-keyword">if</span> ((prot &amp; VM_PROT_EXECUTE) &amp;&amp; !m-&gt;xpmapped) {

			pmap_lock_phys_page(m-&gt;phys_page);
			<span class="enscript-comment">/*
			 * go ahead and take the opportunity
			 * to set 'pmapped' here so that we don't
			 * need to grab this lock a 2nd time
			 * just below
			 */</span>
			m-&gt;pmapped = TRUE;
			
			<span class="enscript-keyword">if</span> (!m-&gt;xpmapped) {

				m-&gt;xpmapped = TRUE;

				pmap_unlock_phys_page(m-&gt;phys_page);

				<span class="enscript-keyword">if</span> (!m-&gt;object-&gt;internal)
					OSAddAtomic(1, &amp;vm_page_xpmapped_external_count);

				<span class="enscript-keyword">if</span> ((COMPRESSED_PAGER_IS_ACTIVE) &amp;&amp;
				    m-&gt;object-&gt;internal &amp;&amp;
				    m-&gt;object-&gt;pager != NULL) {
					<span class="enscript-comment">/*
					 * This page could have been
					 * uncompressed by the
					 * compressor pager and its
					 * contents might be only in
					 * the data cache.
					 * Since it's being mapped for
					 * &quot;execute&quot; for the fist time,
					 * make sure the icache is in
					 * sync.
					 */</span>
					pmap_sync_page_data_phys(m-&gt;phys_page);
				}
			} <span class="enscript-keyword">else</span>
				pmap_unlock_phys_page(m-&gt;phys_page);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (m-&gt;pmapped == FALSE) {
				pmap_lock_phys_page(m-&gt;phys_page);
				m-&gt;pmapped = TRUE;
				pmap_unlock_phys_page(m-&gt;phys_page);
			}
		}
		<span class="enscript-keyword">if</span> (vm_page_is_slideable(m)) {
			boolean_t was_busy = m-&gt;busy;

			vm_object_lock_assert_exclusive(m-&gt;object);

			m-&gt;busy = TRUE;
			kr = vm_page_slide(m, 0);
			assert(m-&gt;busy);
			<span class="enscript-keyword">if</span>(!was_busy) {
				PAGE_WAKEUP_DONE(m);
			}
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
				<span class="enscript-comment">/*
				 * This page has not been slid correctly,
				 * do not do the pmap_enter() !
				 * Let vm_fault_enter() return the error
				 * so the caller can fail the fault.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">after_the_pmap_enter</span>;
			}
		}

		<span class="enscript-keyword">if</span> (fault_type &amp; VM_PROT_WRITE) {

			<span class="enscript-keyword">if</span> (m-&gt;wpmapped == FALSE) {
				vm_object_lock_assert_exclusive(m-&gt;object);

				m-&gt;wpmapped = TRUE;
			}
			<span class="enscript-keyword">if</span> (must_disconnect) {
				<span class="enscript-comment">/*
				 * We can only get here 
				 * because of the CSE logic
				 */</span>
				assert(cs_enforcement_enabled);
				pmap_disconnect(m-&gt;phys_page);
				<span class="enscript-comment">/* 
				 * If we are faulting for a write, we can clear
				 * the execute bit - that will ensure the page is
				 * checked again before being executable, which
				 * protects against a map switch.
				 * This only happens the first time the page
				 * gets tainted, so we won't get stuck here 
				 * to make an already writeable page executable.
				 */</span>
				<span class="enscript-keyword">if</span> (!cs_bypass){
					prot &amp;= ~VM_PROT_EXECUTE;
				}
			}
		}

		<span class="enscript-comment">/* Prevent a deadlock by not
		 * holding the object lock if we need to wait for a page in
		 * pmap_enter() - &lt;rdar://problem/7138958&gt; */</span>
		PMAP_ENTER_OPTIONS(pmap, vaddr, m, prot, fault_type, 0,
				   wired,
				   pmap_options | PMAP_OPTIONS_NOWAIT,
				   pe_result);

		<span class="enscript-keyword">if</span>(pe_result == KERN_RESOURCE_SHORTAGE) {

			<span class="enscript-keyword">if</span> (need_retry) {
				<span class="enscript-comment">/*
				 * this will be non-null in the case where we hold the lock
				 * on the top-object in this chain... we can't just drop
				 * the lock on the object we're inserting the page into
				 * and recall the PMAP_ENTER since we can still cause
				 * a deadlock if one of the critical paths tries to 
				 * acquire the lock on the top-object and we're blocked
				 * in PMAP_ENTER waiting for memory... our only recourse
				 * is to deal with it at a higher level where we can 
				 * drop both locks.
				 */</span>
				*need_retry = TRUE;
				vm_pmap_enter_retried++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">after_the_pmap_enter</span>;
			}
			<span class="enscript-comment">/* The nonblocking version of pmap_enter did not succeed.
			 * and we don't need to drop other locks and retry
			 * at the level above us, so 
			 * use the blocking version instead. Requires marking
			 * the page busy and unlocking the object */</span>
			boolean_t was_busy = m-&gt;busy;

			vm_object_lock_assert_exclusive(m-&gt;object);

			m-&gt;busy = TRUE;
			vm_object_unlock(m-&gt;object);
			
			PMAP_ENTER_OPTIONS(pmap, vaddr, m, prot, fault_type,
					   0, wired,
			                   pmap_options, pe_result);
				
			<span class="enscript-comment">/* Take the object lock again. */</span>
			vm_object_lock(m-&gt;object);
			
			<span class="enscript-comment">/* If the page was busy, someone else will wake it up.
			 * Otherwise, we have to do it now. */</span>
			assert(m-&gt;busy);
			<span class="enscript-keyword">if</span>(!was_busy) {
				PAGE_WAKEUP_DONE(m);
			}
			vm_pmap_enter_blocked++;
		}
	}

<span class="enscript-reference">after_the_pmap_enter</span>:
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_pre_fault</span>(vm_map_offset_t vaddr)
{
	<span class="enscript-keyword">if</span> (pmap_find_phys(current_map()-&gt;pmap, vaddr) == 0) {

		vm_fault(current_map(), <span class="enscript-comment">/* map */</span>
			vaddr,		<span class="enscript-comment">/* vaddr */</span>
			VM_PROT_READ, <span class="enscript-comment">/* fault_type */</span>
			FALSE, <span class="enscript-comment">/* change_wiring */</span>
			THREAD_UNINT, <span class="enscript-comment">/* interruptible */</span>
			NULL, <span class="enscript-comment">/* caller_pmap */</span>
			0 <span class="enscript-comment">/* caller_pmap_addr */</span>);
	}
}


<span class="enscript-comment">/*
 *	Routine:	vm_fault
 *	Purpose:
 *		Handle page faults, including pseudo-faults
 *		used to change the wiring status of pages.
 *	Returns:
 *		Explicit continuations have been removed.
 *	Implementation:
 *		vm_fault and vm_fault_page save mucho state
 *		in the moral equivalent of a closure.  The state
 *		structure is allocated when first entering vm_fault
 *		and deallocated when leaving vm_fault.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> _map_enter_debug;

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_fault_collapse_total = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> vm_fault_collapse_skipped = 0;


kern_return_t
<span class="enscript-function-name">vm_fault</span>(
	vm_map_t	map,
	vm_map_offset_t	vaddr,
	vm_prot_t	fault_type,
	boolean_t	change_wiring,
	<span class="enscript-type">int</span>		interruptible,
	pmap_t		caller_pmap,
	vm_map_offset_t	caller_pmap_addr)
{
	<span class="enscript-keyword">return</span> vm_fault_internal(map, vaddr, fault_type, change_wiring,
				 interruptible, caller_pmap, caller_pmap_addr,
				 NULL);
}


kern_return_t
<span class="enscript-function-name">vm_fault_internal</span>(
	vm_map_t	map,
	vm_map_offset_t	vaddr,
	vm_prot_t	caller_prot,
	boolean_t	change_wiring,
	<span class="enscript-type">int</span>		interruptible,
	pmap_t		caller_pmap,
	vm_map_offset_t	caller_pmap_addr,
	ppnum_t		*physpage_p)
{
	vm_map_version_t	version;	<span class="enscript-comment">/* Map version for verificiation */</span>
	boolean_t		wired;		<span class="enscript-comment">/* Should mapping be wired down? */</span>
	vm_object_t		object;		<span class="enscript-comment">/* Top-level object */</span>
	vm_object_offset_t	offset;		<span class="enscript-comment">/* Top-level offset */</span>
	vm_prot_t		prot;		<span class="enscript-comment">/* Protection for mapping */</span>
	vm_object_t		old_copy_object; <span class="enscript-comment">/* Saved copy object */</span>
	vm_page_t		result_page;	<span class="enscript-comment">/* Result of vm_fault_page */</span>
	vm_page_t		top_page;	<span class="enscript-comment">/* Placeholder page */</span>
	kern_return_t		kr;

	vm_page_t		m;	<span class="enscript-comment">/* Fast access to result_page */</span>
	kern_return_t		error_code;
	vm_object_t		cur_object;
	vm_object_offset_t	cur_offset;
	vm_page_t		cur_m;
	vm_object_t		new_object;
	<span class="enscript-type">int</span>                     type_of_fault;
	pmap_t			pmap;
	boolean_t		interruptible_state;
	vm_map_t		real_map = map;
	vm_map_t		original_map = map;
	vm_prot_t		fault_type;
	vm_prot_t		original_fault_type;
	<span class="enscript-type">struct</span> vm_object_fault_info fault_info;
	boolean_t		need_collapse = FALSE;
	boolean_t		need_retry = FALSE;
	boolean_t		*need_retry_ptr = NULL;
	<span class="enscript-type">int</span>			object_lock_type = 0;
	<span class="enscript-type">int</span>			cur_object_lock_type;
	vm_object_t		top_object = VM_OBJECT_NULL;
	<span class="enscript-type">int</span>			throttle_delay;
	<span class="enscript-type">int</span>			compressed_count_delta;


	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
	              (MACHDBG_CODE(DBG_MACH_VM, 2)) | DBG_FUNC_START,
			      ((uint64_t)vaddr &gt;&gt; 32),
			      vaddr,
			      (map == kernel_map),
			      0,
			      0);

	<span class="enscript-keyword">if</span> (get_preemption_level() != 0) {
	        KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
				      (MACHDBG_CODE(DBG_MACH_VM, 2)) | DBG_FUNC_END,
				      ((uint64_t)vaddr &gt;&gt; 32),
				      vaddr,
				      KERN_FAILURE,
				      0,
				      0);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}
	
	interruptible_state = thread_interrupt_level(interruptible);

	fault_type = (change_wiring ? VM_PROT_NONE : caller_prot);

	VM_STAT_INCR(faults);
	current_task()-&gt;faults++;
	original_fault_type = fault_type;

	<span class="enscript-keyword">if</span> (fault_type &amp; VM_PROT_WRITE)
	        object_lock_type = OBJECT_LOCK_EXCLUSIVE;
	<span class="enscript-keyword">else</span>
	        object_lock_type = OBJECT_LOCK_SHARED;

	cur_object_lock_type = OBJECT_LOCK_SHARED;

<span class="enscript-reference">RetryFault</span>:
	<span class="enscript-comment">/*
	 * assume we will hit a page in the cache
	 * otherwise, explicitly override with
	 * the real fault type once we determine it
	 */</span>
	type_of_fault = DBG_CACHE_HIT_FAULT;

	<span class="enscript-comment">/*
	 *	Find the backing store object and offset into
	 *	it to begin the search.
	 */</span>
	fault_type = original_fault_type;
	map = original_map;
	vm_map_lock_read(map);

	kr = vm_map_lookup_locked(&amp;map, vaddr, fault_type,
				  object_lock_type, &amp;version,
				  &amp;object, &amp;offset, &amp;prot, &amp;wired,
				  &amp;fault_info,
				  &amp;real_map);


	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		vm_map_unlock_read(map);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	pmap = real_map-&gt;pmap;
	fault_info.interruptible = interruptible;
	fault_info.stealth = FALSE;
	fault_info.io_sync = FALSE;
	fault_info.mark_zf_absent = FALSE;
	fault_info.batch_pmap_op = FALSE;

	<span class="enscript-comment">/*
	 * If the page is wired, we must fault for the current protection
	 * value, to avoid further faults.
	 */</span>
	<span class="enscript-keyword">if</span> (wired) {
		fault_type = prot | VM_PROT_WRITE;
		<span class="enscript-comment">/*
		 * since we're treating this fault as a 'write'
		 * we must hold the top object lock exclusively
		 */</span>
		<span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

		        object_lock_type = OBJECT_LOCK_EXCLUSIVE;

			<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
			        <span class="enscript-comment">/*
				 * couldn't upgrade, so explictly
				 * take the lock exclusively
				 */</span>
			        vm_object_lock(object);
			}
		}
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">VM_FAULT_CLASSIFY</span>
	<span class="enscript-comment">/*
	 *	Temporary data gathering code
	 */</span>
	vm_fault_classify(object, offset, fault_type);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 *	Fast fault code.  The basic idea is to do as much as
	 *	possible while holding the map lock and object locks.
	 *      Busy pages are not used until the object lock has to
	 *	be dropped to do something (copy, zero fill, pmap enter).
	 *	Similarly, paging references aren't acquired until that
	 *	point, and object references aren't used.
	 *
	 *	If we can figure out what to do
	 *	(zero fill, copy on write, pmap enter) while holding
	 *	the locks, then it gets done.  Otherwise, we give up,
	 *	and use the original fault path (which doesn't hold
	 *	the map lock, and relies on busy pages).
	 *	The give up cases include:
	 * 		- Have to talk to pager.
	 *		- Page is busy, absent or in error.
	 *		- Pager has locked out desired access.
	 *		- Fault needs to be restarted.
	 *		- Have to push page into copy object.
	 *
	 *	The code is an infinite loop that moves one level down
	 *	the shadow chain each time.  cur_object and cur_offset
	 * 	refer to the current object being examined. object and offset
	 *	are the original object from the map.  The loop is at the
	 *	top level if and only if object and cur_object are the same.
	 *
	 *	Invariants:  Map lock is held throughout.  Lock is held on
	 *		original object and cur_object (if different) when
	 *		continuing or exiting loop.
	 *
	 */</span>


	<span class="enscript-comment">/*
	 * If this page is to be inserted in a copy delay object
	 * for writing, and if the object has a copy, then the
	 * copy delay strategy is implemented in the slow fault page.
	 */</span>
	<span class="enscript-keyword">if</span> (object-&gt;copy_strategy == MEMORY_OBJECT_COPY_DELAY &amp;&amp;
	    object-&gt;copy != VM_OBJECT_NULL &amp;&amp; (fault_type &amp; VM_PROT_WRITE))
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_copy_delay</span>;

	cur_object = object;
	cur_offset = offset;

	<span class="enscript-keyword">while</span> (TRUE) {
		<span class="enscript-keyword">if</span> (!cur_object-&gt;pager_created &amp;&amp;
		    cur_object-&gt;phys_contiguous) <span class="enscript-comment">/* superpage */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (cur_object-&gt;blocked_access) {
			<span class="enscript-comment">/*
			 * Access to this VM object has been blocked.
			 * Let the slow path handle it.
			 */</span>
			<span class="enscript-keyword">break</span>;
		}

		m = vm_page_lookup(cur_object, cur_offset);

		<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
			<span class="enscript-keyword">if</span> (m-&gt;busy) {
			        wait_result_t	result;

				<span class="enscript-comment">/*
				 * in order to do the PAGE_ASSERT_WAIT, we must
				 * have object that 'm' belongs to locked exclusively
				 */</span>
				<span class="enscript-keyword">if</span> (object != cur_object) {

					<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED) {

					        cur_object_lock_type = OBJECT_LOCK_EXCLUSIVE;

						<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(cur_object) == FALSE) {
						        <span class="enscript-comment">/*
							 * couldn't upgrade so go do a full retry
							 * immediately since we can no longer be
							 * certain about cur_object (since we
							 * don't hold a reference on it)...
							 * first drop the top object lock
							 */</span>
							vm_object_unlock(object);

						        vm_map_unlock_read(map);
							<span class="enscript-keyword">if</span> (real_map != map)
							        vm_map_unlock(real_map);

							<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
						}
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

				        object_lock_type = OBJECT_LOCK_EXCLUSIVE;

					<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
					        <span class="enscript-comment">/*
						 * couldn't upgrade, so explictly take the lock
						 * exclusively and go relookup the page since we
						 * will have dropped the object lock and
						 * a different thread could have inserted
						 * a page at this offset
						 * no need for a full retry since we're
						 * at the top level of the object chain
						 */</span>
					        vm_object_lock(object);

						<span class="enscript-keyword">continue</span>;
					}
				}
				<span class="enscript-keyword">if</span> (m-&gt;pageout_queue &amp;&amp; m-&gt;object-&gt;internal &amp;&amp; COMPRESSED_PAGER_IS_ACTIVE) {
					<span class="enscript-comment">/*
					 * m-&gt;busy == TRUE and the object is locked exclusively
					 * if m-&gt;pageout_queue == TRUE after we acquire the
					 * queues lock, we are guaranteed that it is stable on
					 * the pageout queue and therefore reclaimable
					 *
					 * NOTE: this is only true for the internal pageout queue
					 * in the compressor world
					 */</span>
					vm_page_lock_queues();

					<span class="enscript-keyword">if</span> (m-&gt;pageout_queue) {
						vm_pageout_throttle_up(m);
						vm_page_unlock_queues();

						PAGE_WAKEUP_DONE(m);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">reclaimed_from_pageout</span>;
					}
					vm_page_unlock_queues();
				}
				<span class="enscript-keyword">if</span> (object != cur_object)
					vm_object_unlock(object);

				vm_map_unlock_read(map);
				<span class="enscript-keyword">if</span> (real_map != map)
				        vm_map_unlock(real_map);

				result = PAGE_ASSERT_WAIT(m, interruptible);

				vm_object_unlock(cur_object);

				<span class="enscript-keyword">if</span> (result == THREAD_WAITING) {
				        result = thread_block(THREAD_CONTINUE_NULL);

					counter(c_vm_fault_page_block_busy_kernel++);
				}
				<span class="enscript-keyword">if</span> (result == THREAD_AWAKENED || result == THREAD_RESTART)
				        <span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;

				kr = KERN_ABORTED;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
<span class="enscript-reference">reclaimed_from_pageout</span>:
			<span class="enscript-keyword">if</span> (m-&gt;laundry) {
				<span class="enscript-keyword">if</span> (object != cur_object) {
					<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED) {
						cur_object_lock_type = OBJECT_LOCK_EXCLUSIVE;

						vm_object_unlock(object);
						vm_object_unlock(cur_object);

						vm_map_unlock_read(map);
						<span class="enscript-keyword">if</span> (real_map != map)
							vm_map_unlock(real_map);

						<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
					}

				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

					object_lock_type = OBJECT_LOCK_EXCLUSIVE;

					<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
						<span class="enscript-comment">/*
						 * couldn't upgrade, so explictly take the lock
						 * exclusively and go relookup the page since we
						 * will have dropped the object lock and
						 * a different thread could have inserted
						 * a page at this offset
						 * no need for a full retry since we're
						 * at the top level of the object chain
						 */</span>
						vm_object_lock(object);

						<span class="enscript-keyword">continue</span>;
					}
				}
				m-&gt;pageout = FALSE;
				
				vm_pageout_steal_laundry(m, FALSE);
			}

			<span class="enscript-keyword">if</span> (m-&gt;phys_page == vm_page_guard_addr) {
				<span class="enscript-comment">/*
				 * Guard page: let the slow path deal with it
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (m-&gt;unusual &amp;&amp; (m-&gt;error || m-&gt;restart || m-&gt;private || m-&gt;absent)) {
			        <span class="enscript-comment">/*
				 * Unusual case... let the slow path deal with it
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (VM_OBJECT_PURGEABLE_FAULT_ERROR(m-&gt;object)) {
				<span class="enscript-keyword">if</span> (object != cur_object)
					vm_object_unlock(object);
				vm_map_unlock_read(map);
				<span class="enscript-keyword">if</span> (real_map != map)
				        vm_map_unlock(real_map);
				vm_object_unlock(cur_object);
				kr = KERN_MEMORY_ERROR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (m-&gt;encrypted) {
				<span class="enscript-comment">/*
				 * ENCRYPTED SWAP:
				 * We've soft-faulted (because it's not in the page
				 * table) on an encrypted page.
				 * Keep the page &quot;busy&quot; so that no one messes with
				 * it during the decryption.
				 * Release the extra locks we're holding, keep only
				 * the page's VM object lock.
				 *
				 * in order to set 'busy' on 'm', we must
				 * have object that 'm' belongs to locked exclusively
				 */</span>
			        <span class="enscript-keyword">if</span> (object != cur_object) {
					vm_object_unlock(object);

					<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED) {

					        cur_object_lock_type = OBJECT_LOCK_EXCLUSIVE;

						<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(cur_object) == FALSE) {
						        <span class="enscript-comment">/*
							 * couldn't upgrade so go do a full retry
							 * immediately since we've already dropped
							 * the top object lock associated with this page
							 * and the current one got dropped due to the
							 * failed upgrade... the state is no longer valid
							 */</span>
						        vm_map_unlock_read(map);
							<span class="enscript-keyword">if</span> (real_map != map)
							        vm_map_unlock(real_map);

							<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
						}
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

				        object_lock_type = OBJECT_LOCK_EXCLUSIVE;

					<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
					        <span class="enscript-comment">/*
						 * couldn't upgrade, so explictly take the lock
						 * exclusively and go relookup the page since we
						 * will have dropped the object lock and
						 * a different thread could have inserted
						 * a page at this offset
						 * no need for a full retry since we're
						 * at the top level of the object chain
						 */</span>
					        vm_object_lock(object);

						<span class="enscript-keyword">continue</span>;
					}
				}
				m-&gt;busy = TRUE;

				vm_map_unlock_read(map);
				<span class="enscript-keyword">if</span> (real_map != map) 
					vm_map_unlock(real_map);

				vm_page_decrypt(m, 0);

				assert(m-&gt;busy);
				PAGE_WAKEUP_DONE(m);

				vm_object_unlock(cur_object);
				<span class="enscript-comment">/*
				 * Retry from the top, in case anything
				 * changed while we were decrypting...
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
			}
			ASSERT_PAGE_DECRYPTED(m);

			<span class="enscript-keyword">if</span>(vm_page_is_slideable(m)) {
				<span class="enscript-comment">/*
				 * We might need to slide this page, and so,
				 * we want to hold the VM object exclusively.
				 */</span>
			        <span class="enscript-keyword">if</span> (object != cur_object) {
					<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED) {
						vm_object_unlock(object);
						vm_object_unlock(cur_object);

					        cur_object_lock_type = OBJECT_LOCK_EXCLUSIVE;

						vm_map_unlock_read(map);
						<span class="enscript-keyword">if</span> (real_map != map)
							vm_map_unlock(real_map);

						<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

					vm_object_unlock(object);
				        object_lock_type = OBJECT_LOCK_EXCLUSIVE;
					vm_map_unlock_read(map);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
				}
			}

			<span class="enscript-keyword">if</span> (VM_FAULT_NEED_CS_VALIDATION(map-&gt;pmap, m) ||
			    (physpage_p != NULL &amp;&amp; (prot &amp; VM_PROT_WRITE))) {
<span class="enscript-reference">upgrade_for_validation</span>:
				<span class="enscript-comment">/*
				 * We might need to validate this page
				 * against its code signature, so we
				 * want to hold the VM object exclusively.
				 */</span>
			        <span class="enscript-keyword">if</span> (object != cur_object) {
					<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED) {
						vm_object_unlock(object);
						vm_object_unlock(cur_object);

					        cur_object_lock_type = OBJECT_LOCK_EXCLUSIVE;

						vm_map_unlock_read(map);
						<span class="enscript-keyword">if</span> (real_map != map)
							vm_map_unlock(real_map);

						<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
					}

				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

				        object_lock_type = OBJECT_LOCK_EXCLUSIVE;

					<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
					        <span class="enscript-comment">/*
						 * couldn't upgrade, so explictly take the lock
						 * exclusively and go relookup the page since we
						 * will have dropped the object lock and
						 * a different thread could have inserted
						 * a page at this offset
						 * no need for a full retry since we're
						 * at the top level of the object chain
						 */</span>
					        vm_object_lock(object);

						<span class="enscript-keyword">continue</span>;
					}
				}
			}
			<span class="enscript-comment">/*
			 *	Two cases of map in faults:
			 *	    - At top level w/o copy object.
			 *	    - Read fault anywhere.
			 *		--&gt; must disallow write.
			 */</span>

			<span class="enscript-keyword">if</span> (object == cur_object &amp;&amp; object-&gt;copy == VM_OBJECT_NULL) {

				<span class="enscript-keyword">goto</span> <span class="enscript-reference">FastPmapEnter</span>;
			}

			<span class="enscript-keyword">if</span> ((fault_type &amp; VM_PROT_WRITE) == 0) {

			  	<span class="enscript-keyword">if</span> (object != cur_object) {
				        <span class="enscript-comment">/*
					 * We still need to hold the top object
					 * lock here to prevent a race between
					 * a read fault (taking only &quot;shared&quot;
					 * locks) and a write fault (taking
					 * an &quot;exclusive&quot; lock on the top
					 * object.
					 * Otherwise, as soon as we release the
					 * top lock, the write fault could
					 * proceed and actually complete before
					 * the read fault, and the copied page's
					 * translation could then be overwritten
					 * by the read fault's translation for
					 * the original page.
					 *
					 * Let's just record what the top object
					 * is and we'll release it later.
					 */</span>
					top_object = object;

					<span class="enscript-comment">/*
					 * switch to the object that has the new page
					 */</span>
					object = cur_object;
					object_lock_type = cur_object_lock_type;
				}
<span class="enscript-reference">FastPmapEnter</span>:
				<span class="enscript-comment">/*
				 * prepare for the pmap_enter...
				 * object and map are both locked
				 * m contains valid data
				 * object == m-&gt;object
				 * cur_object == NULL or it's been unlocked
				 * no paging references on either object or cur_object
				 */</span>
				<span class="enscript-keyword">if</span> (top_object != VM_OBJECT_NULL || object_lock_type != OBJECT_LOCK_EXCLUSIVE)
					need_retry_ptr = &amp;need_retry;
				<span class="enscript-keyword">else</span>
					need_retry_ptr = NULL;

				<span class="enscript-keyword">if</span> (caller_pmap) {
				        kr = vm_fault_enter(m,
							    caller_pmap,
							    caller_pmap_addr,
							    prot,
							    caller_prot,
							    wired,
							    change_wiring,
							    fault_info.no_cache,
							    fault_info.cs_bypass,
							    fault_info.user_tag,
							    fault_info.pmap_options,
							    need_retry_ptr,
							    &amp;type_of_fault);
				} <span class="enscript-keyword">else</span> {
				        kr = vm_fault_enter(m,
							    pmap,
							    vaddr,
							    prot,
							    caller_prot,
							    wired,
							    change_wiring,
							    fault_info.no_cache,
							    fault_info.cs_bypass,
							    fault_info.user_tag,
							    fault_info.pmap_options,
							    need_retry_ptr,
							    &amp;type_of_fault);
				}

				<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS &amp;&amp;
				    physpage_p != NULL) {
					<span class="enscript-comment">/* for vm_map_wire_and_extract() */</span>
					*physpage_p = m-&gt;phys_page;
					<span class="enscript-keyword">if</span> (prot &amp; VM_PROT_WRITE) {
						vm_object_lock_assert_exclusive(
							m-&gt;object);
						m-&gt;dirty = TRUE;
					}
				}

				<span class="enscript-keyword">if</span> (top_object != VM_OBJECT_NULL) {
					<span class="enscript-comment">/*
					 * It's safe to drop the top object
					 * now that we've done our
					 * vm_fault_enter().  Any other fault
					 * in progress for that virtual
					 * address will either find our page
					 * and translation or put in a new page
					 * and translation.
					 */</span>
					vm_object_unlock(top_object);
					top_object = VM_OBJECT_NULL;
				}

				<span class="enscript-keyword">if</span> (need_collapse == TRUE)
				        vm_object_collapse(object, offset, TRUE);
				
				<span class="enscript-keyword">if</span> (need_retry == FALSE &amp;&amp;
				    (type_of_fault == DBG_PAGEIND_FAULT || type_of_fault == DBG_PAGEINV_FAULT || type_of_fault == DBG_CACHE_HIT_FAULT)) {
				        <span class="enscript-comment">/*
					 * evaluate access pattern and update state
					 * vm_fault_deactivate_behind depends on the
					 * state being up to date
					 */</span>
				        vm_fault_is_sequential(object, cur_offset, fault_info.behavior);

					vm_fault_deactivate_behind(object, cur_offset, fault_info.behavior);
				}
				<span class="enscript-comment">/*
				 * That's it, clean up and return.
				 */</span>
				<span class="enscript-keyword">if</span> (m-&gt;busy)
				        PAGE_WAKEUP_DONE(m);

				vm_object_unlock(object);

				vm_map_unlock_read(map);
				<span class="enscript-keyword">if</span> (real_map != map)
					vm_map_unlock(real_map);

				<span class="enscript-keyword">if</span> (need_retry == TRUE) {
					<span class="enscript-comment">/*
					 * vm_fault_enter couldn't complete the PMAP_ENTER...
					 * at this point we don't hold any locks so it's safe
					 * to ask the pmap layer to expand the page table to
					 * accommodate this mapping... once expanded, we'll
					 * re-drive the fault which should result in vm_fault_enter
					 * being able to successfully enter the mapping this time around
					 */</span>
					(<span class="enscript-type">void</span>)pmap_enter_options(
						pmap, vaddr, 0, 0, 0, 0, 0,
						PMAP_OPTIONS_NOENTER, NULL);
					
					need_retry = FALSE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-comment">/*
			 * COPY ON WRITE FAULT
			 */</span>
			assert(object_lock_type == OBJECT_LOCK_EXCLUSIVE);

                        <span class="enscript-comment">/*
			 * If objects match, then
			 * object-&gt;copy must not be NULL (else control
			 * would be in previous code block), and we
			 * have a potential push into the copy object
			 * with which we can't cope with here.
			 */</span>
			<span class="enscript-keyword">if</span> (cur_object == object) {
			        <span class="enscript-comment">/*
				 * must take the slow path to
				 * deal with the copy push
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-comment">/*
			 * This is now a shadow based copy on write
			 * fault -- it requires a copy up the shadow
			 * chain.
			 */</span>
			
			<span class="enscript-keyword">if</span> ((cur_object_lock_type == OBJECT_LOCK_SHARED) &amp;&amp;
			    VM_FAULT_NEED_CS_VALIDATION(NULL, m)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">upgrade_for_validation</span>;
			}

			<span class="enscript-comment">/*
			 * Allocate a page in the original top level
			 * object. Give up if allocate fails.  Also
			 * need to remember current page, as it's the
			 * source of the copy.
			 *
			 * at this point we hold locks on both 
			 * object and cur_object... no need to take
			 * paging refs or mark pages BUSY since
			 * we don't drop either object lock until
			 * the page has been copied and inserted
			 */</span>
			cur_m = m;
			m = vm_page_grab();

			<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {
			        <span class="enscript-comment">/*
				 * no free page currently available...
				 * must take the slow path
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * Now do the copy.  Mark the source page busy...
			 *
			 *	NOTE: This code holds the map lock across
			 *	the page copy.
			 */</span>
			vm_page_copy(cur_m, m);
			vm_page_insert(m, object, offset);
			SET_PAGE_DIRTY(m, FALSE);

			<span class="enscript-comment">/*
			 * Now cope with the source page and object
			 */</span>
			<span class="enscript-keyword">if</span> (object-&gt;ref_count &gt; 1 &amp;&amp; cur_m-&gt;pmapped)
			        pmap_disconnect(cur_m-&gt;phys_page);
			
			<span class="enscript-keyword">if</span> (cur_m-&gt;clustered) {
				VM_PAGE_COUNT_AS_PAGEIN(cur_m);
				VM_PAGE_CONSUME_CLUSTERED(cur_m);
			}
			need_collapse = TRUE;

			<span class="enscript-keyword">if</span> (!cur_object-&gt;internal &amp;&amp;
			    cur_object-&gt;copy_strategy == MEMORY_OBJECT_COPY_DELAY) {
			        <span class="enscript-comment">/*
				 * The object from which we've just
				 * copied a page is most probably backed
				 * by a vnode.  We don't want to waste too
				 * much time trying to collapse the VM objects
				 * and create a bottleneck when several tasks
				 * map the same file.
				 */</span>
			        <span class="enscript-keyword">if</span> (cur_object-&gt;copy == object) {
				        <span class="enscript-comment">/*
					 * Shared mapping or no COW yet.
					 * We can never collapse a copy
					 * object into its backing object.
					 */</span>
				        need_collapse = FALSE;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cur_object-&gt;copy == object-&gt;shadow &amp;&amp;
					   object-&gt;shadow-&gt;resident_page_count == 0) {
				        <span class="enscript-comment">/*
					 * Shared mapping after a COW occurred.
					 */</span>
				        need_collapse = FALSE;
				}
			}
			vm_object_unlock(cur_object);

			<span class="enscript-keyword">if</span> (need_collapse == FALSE)
			        vm_fault_collapse_skipped++;
			vm_fault_collapse_total++;

			type_of_fault = DBG_COW_FAULT;
			VM_STAT_INCR(cow_faults);
			DTRACE_VM2(cow_fault, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
			current_task()-&gt;cow_faults++;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">FastPmapEnter</span>;

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * No page at cur_object, cur_offset... m == NULL
			 */</span>
			<span class="enscript-keyword">if</span> (cur_object-&gt;pager_created) {
				<span class="enscript-type">int</span>	compressor_external_state = VM_EXTERNAL_STATE_UNKNOWN;

			        <span class="enscript-keyword">if</span> (MUST_ASK_PAGER(cur_object, cur_offset, compressor_external_state) == TRUE) {
					<span class="enscript-type">int</span>		my_fault_type;
					<span class="enscript-type">int</span>		c_flags = C_DONT_BLOCK;
					boolean_t	insert_cur_object = FALSE;

				        <span class="enscript-comment">/*
					 * May have to talk to a pager...
					 * if so, take the slow path by
					 * doing a 'break' from the while (TRUE) loop
					 *
					 * external_state will only be set to VM_EXTERNAL_STATE_EXISTS
					 * if the compressor is active and the page exists there
					 */</span>
					<span class="enscript-keyword">if</span> (compressor_external_state != VM_EXTERNAL_STATE_EXISTS)
						<span class="enscript-keyword">break</span>;

					<span class="enscript-keyword">if</span> (map == kernel_map || real_map == kernel_map) {
						<span class="enscript-comment">/*
						 * can't call into the compressor with the kernel_map
						 * lock held, since the compressor may try to operate
						 * on the kernel map in order to return an empty c_segment
						 */</span>
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">if</span> (object != cur_object) {
						<span class="enscript-keyword">if</span> (fault_type &amp; VM_PROT_WRITE)
							c_flags |= C_KEEP;
						<span class="enscript-keyword">else</span>
							insert_cur_object = TRUE;
					}
					<span class="enscript-keyword">if</span> (insert_cur_object == TRUE) {

						<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED) {

							cur_object_lock_type = OBJECT_LOCK_EXCLUSIVE;

							<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(cur_object) == FALSE) {
								<span class="enscript-comment">/*
								 * couldn't upgrade so go do a full retry
								 * immediately since we can no longer be
								 * certain about cur_object (since we
								 * don't hold a reference on it)...
								 * first drop the top object lock
								 */</span>
								vm_object_unlock(object);

								vm_map_unlock_read(map);
								<span class="enscript-keyword">if</span> (real_map != map)
									vm_map_unlock(real_map);

								<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
							}
						}
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

						object_lock_type = OBJECT_LOCK_EXCLUSIVE;

						<span class="enscript-keyword">if</span> (object != cur_object) {
							<span class="enscript-comment">/*
							 * we can't go for the upgrade on the top
							 * lock since the upgrade may block waiting
							 * for readers to drain... since we hold
							 * cur_object locked at this point, waiting
							 * for the readers to drain would represent
							 * a lock order inversion since the lock order
							 * for objects is the reference order in the
							 * shadown chain
							 */</span>
							vm_object_unlock(object);
							vm_object_unlock(cur_object);

							vm_map_unlock_read(map);
							<span class="enscript-keyword">if</span> (real_map != map)
								vm_map_unlock(real_map);

							<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
						}
						<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
							<span class="enscript-comment">/*
							 * couldn't upgrade, so explictly take the lock
							 * exclusively and go relookup the page since we
							 * will have dropped the object lock and
							 * a different thread could have inserted
							 * a page at this offset
							 * no need for a full retry since we're
							 * at the top level of the object chain
							 */</span>
							vm_object_lock(object);
							
							<span class="enscript-keyword">continue</span>;
						}
					}
					m = vm_page_grab();

					<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {
						<span class="enscript-comment">/*
						 * no free page currently available...
						 * must take the slow path
						 */</span>
						<span class="enscript-keyword">break</span>;
					}

					<span class="enscript-comment">/*
					 * The object is and remains locked
					 * so no need to take a
					 * &quot;paging_in_progress&quot; reference.
					 */</span>
					boolean_t shared_lock;
					<span class="enscript-keyword">if</span> ((object == cur_object &amp;&amp;
					     object_lock_type == OBJECT_LOCK_EXCLUSIVE) ||
					    (object != cur_object &amp;&amp;
					     cur_object_lock_type == OBJECT_LOCK_EXCLUSIVE)) {
						shared_lock = FALSE;
					} <span class="enscript-keyword">else</span> {
						shared_lock = TRUE;
					}

					kr = vm_compressor_pager_get(
						cur_object-&gt;pager,
						(cur_offset +
						 cur_object-&gt;paging_offset),
						m-&gt;phys_page,
						&amp;my_fault_type,
						c_flags,
						&amp;compressed_count_delta);

					vm_compressor_pager_count(
						cur_object-&gt;pager,
						compressed_count_delta,
						shared_lock,
						cur_object);

					<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
						vm_page_release(m);
						<span class="enscript-keyword">break</span>;
					}
					m-&gt;dirty = TRUE;

					<span class="enscript-comment">/*
					 * If the object is purgeable, its
					 * owner's purgeable ledgers will be
					 * updated in vm_page_insert() but the
					 * page was also accounted for in a
					 * &quot;compressed purgeable&quot; ledger, so
					 * update that now.
					 */</span>
					<span class="enscript-keyword">if</span> (object != cur_object &amp;&amp;
					    !insert_cur_object) {
						<span class="enscript-comment">/*
						 * We're not going to insert
						 * the decompressed page into
						 * the object it came from.
						 *
						 * We're dealing with a
						 * copy-on-write fault on
						 * &quot;object&quot;.
						 * We're going to decompress
						 * the page directly into the
						 * target &quot;object&quot; while
						 * keepin the compressed
						 * page for &quot;cur_object&quot;, so
						 * no ledger update in that
						 * case.
						 */</span>
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((cur_object-&gt;purgable ==
						    VM_PURGABLE_DENY) ||
						   (cur_object-&gt;vo_purgeable_owner ==
						    NULL)) {
						<span class="enscript-comment">/*
						 * &quot;cur_object&quot; is not purgeable
						 * or is not owned, so no
						 * purgeable ledgers to update.
						 */</span>
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/*
						 * One less compressed
						 * purgeable page for
						 * cur_object's owner.
						 */</span>
						vm_purgeable_compressed_update(
							cur_object,
							-1);
					}

					<span class="enscript-keyword">if</span> (insert_cur_object) {
						vm_page_insert(m, cur_object, cur_offset);
					} <span class="enscript-keyword">else</span> {
						vm_page_insert(m, object, offset);
					}

					<span class="enscript-keyword">if</span> ((m-&gt;object-&gt;wimg_bits &amp; VM_WIMG_MASK) != VM_WIMG_USE_DEFAULT) {
                                                <span class="enscript-comment">/*
						 * If the page is not cacheable,
						 * we can't let its contents
						 * linger in the data cache
						 * after the decompression.
						 */</span>
						pmap_sync_page_attributes_phys(m-&gt;phys_page);
					}

					type_of_fault = my_fault_type;

					VM_STAT_INCR(decompressions);

					<span class="enscript-keyword">if</span> (cur_object != object) {
						<span class="enscript-keyword">if</span> (insert_cur_object) {
							top_object = object;
							<span class="enscript-comment">/*
							 * switch to the object that has the new page
							 */</span>
							object = cur_object;
							object_lock_type = cur_object_lock_type;
						} <span class="enscript-keyword">else</span> {
							vm_object_unlock(cur_object);
							cur_object = object;
						}
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">FastPmapEnter</span>;
				}
				<span class="enscript-comment">/*
				 * existence map present and indicates
				 * that the pager doesn't have this page
				 */</span>
			}
			<span class="enscript-keyword">if</span> (cur_object-&gt;shadow == VM_OBJECT_NULL) {
				<span class="enscript-comment">/*
				 * Zero fill fault.  Page gets
				 * inserted into the original object.
				 */</span>
				<span class="enscript-keyword">if</span> (cur_object-&gt;shadow_severed ||
				    VM_OBJECT_PURGEABLE_FAULT_ERROR(cur_object))
				{
					<span class="enscript-keyword">if</span> (object != cur_object)
					        vm_object_unlock(cur_object);
					vm_object_unlock(object);

					vm_map_unlock_read(map);
					<span class="enscript-keyword">if</span> (real_map != map)
						vm_map_unlock(real_map);

					kr = KERN_MEMORY_ERROR;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				<span class="enscript-keyword">if</span> (vm_backing_store_low) {
				        <span class="enscript-comment">/*
					 * we are protecting the system from
					 * backing store exhaustion... 
					 * must take the slow path if we're
					 * not privileged
					 */</span>
					<span class="enscript-keyword">if</span> (!(current_task()-&gt;priv_flags &amp; VM_BACKING_STORE_PRIV))
					        <span class="enscript-keyword">break</span>;
				}
			  	<span class="enscript-keyword">if</span> (cur_object != object) {
					vm_object_unlock(cur_object);

					cur_object = object;
				}
				<span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {

				        object_lock_type = OBJECT_LOCK_EXCLUSIVE;

					<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
					        <span class="enscript-comment">/*
						 * couldn't upgrade so do a full retry on the fault
						 * since we dropped the object lock which
						 * could allow another thread to insert
						 * a page at this offset
						 */</span>
					        vm_map_unlock_read(map);
						<span class="enscript-keyword">if</span> (real_map != map)
						        vm_map_unlock(real_map);

						<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
					}
				}
				m = vm_page_alloc(object, offset);

				<span class="enscript-keyword">if</span> (m == VM_PAGE_NULL) {
				        <span class="enscript-comment">/*
					 * no free page currently available...
					 * must take the slow path
					 */</span>
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/*
				 * Now zero fill page...
				 * the page is probably going to 
				 * be written soon, so don't bother
				 * to clear the modified bit
				 *
				 *   NOTE: This code holds the map
				 *   lock across the zero fill.
				 */</span>
				type_of_fault = vm_fault_zero_page(m, map-&gt;no_zero_fill);

				<span class="enscript-keyword">goto</span> <span class="enscript-reference">FastPmapEnter</span>;
		        }
			<span class="enscript-comment">/*
			 * On to the next level in the shadow chain
			 */</span>
			cur_offset += cur_object-&gt;vo_shadow_offset;
			new_object = cur_object-&gt;shadow;

			<span class="enscript-comment">/*
			 * take the new_object's lock with the indicated state
			 */</span>
			<span class="enscript-keyword">if</span> (cur_object_lock_type == OBJECT_LOCK_SHARED)
			        vm_object_lock_shared(new_object);
			<span class="enscript-keyword">else</span>
			        vm_object_lock(new_object);

			<span class="enscript-keyword">if</span> (cur_object != object)
				vm_object_unlock(cur_object);

			cur_object = new_object;

			<span class="enscript-keyword">continue</span>;
		}
	}
	<span class="enscript-comment">/*
	 * Cleanup from fast fault failure.  Drop any object
	 * lock other than original and drop map lock.
	 */</span>
	<span class="enscript-keyword">if</span> (object != cur_object)
		vm_object_unlock(cur_object);

	<span class="enscript-comment">/*
	 * must own the object lock exclusively at this point
	 */</span>
	<span class="enscript-keyword">if</span> (object_lock_type == OBJECT_LOCK_SHARED) {
	        object_lock_type = OBJECT_LOCK_EXCLUSIVE;

		<span class="enscript-keyword">if</span> (vm_object_lock_upgrade(object) == FALSE) {
		        <span class="enscript-comment">/*
			 * couldn't upgrade, so explictly
			 * take the lock exclusively
			 * no need to retry the fault at this
			 * point since &quot;vm_fault_page&quot; will
			 * completely re-evaluate the state
			 */</span>
		        vm_object_lock(object);
		}
	}

<span class="enscript-reference">handle_copy_delay</span>:
	vm_map_unlock_read(map);
	<span class="enscript-keyword">if</span> (real_map != map)
		vm_map_unlock(real_map);

   	<span class="enscript-comment">/*
	 * Make a reference to this object to
	 * prevent its disposal while we are messing with
	 * it.  Once we have the reference, the map is free
	 * to be diddled.  Since objects reference their
	 * shadows (and copies), they will stay around as well.
	 */</span>
	vm_object_reference_locked(object);
	vm_object_paging_begin(object);

	XPR(XPR_VM_FAULT,<span class="enscript-string">&quot;vm_fault -&gt; vm_fault_page\n&quot;</span>,0,0,0,0,0);

	error_code = 0;

	result_page = VM_PAGE_NULL;
	kr = vm_fault_page(object, offset, fault_type,
			   (change_wiring &amp;&amp; !wired),
			   FALSE, <span class="enscript-comment">/* page not looked up */</span>
			   &amp;prot, &amp;result_page, &amp;top_page,
			   &amp;type_of_fault,
			   &amp;error_code, map-&gt;no_zero_fill,
			   FALSE, &amp;fault_info);

	<span class="enscript-comment">/*
	 * if kr != VM_FAULT_SUCCESS, then the paging reference
	 * has been dropped and the object unlocked... the ref_count
	 * is still held
	 *
	 * if kr == VM_FAULT_SUCCESS, then the paging reference
	 * is still held along with the ref_count on the original object
	 *
	 *	the object is returned locked with a paging reference
	 *
	 *	if top_page != NULL, then it's BUSY and the 
	 *	object it belongs to has a paging reference
	 *	but is returned unlocked
	 */</span>
	<span class="enscript-keyword">if</span> (kr != VM_FAULT_SUCCESS &amp;&amp;
	    kr != VM_FAULT_SUCCESS_NO_VM_PAGE) {
	        <span class="enscript-comment">/*
		 * we didn't succeed, lose the object reference immediately.
		 */</span>
		vm_object_deallocate(object);

		<span class="enscript-comment">/*
		 * See why we failed, and take corrective action.
		 */</span>
		<span class="enscript-keyword">switch</span> (kr) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_SHORTAGE</span>:
			<span class="enscript-keyword">if</span> (vm_page_wait((change_wiring) ? 
					 THREAD_UNINT :
					 THREAD_ABORTSAFE))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
			<span class="enscript-comment">/*
			 * fall thru
			 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_INTERRUPTED</span>:
			kr = KERN_ABORTED;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_RETRY</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_ERROR</span>:
			<span class="enscript-keyword">if</span> (error_code)
				kr = error_code;
			<span class="enscript-keyword">else</span>
				kr = KERN_MEMORY_ERROR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;vm_fault: unexpected error 0x%x from &quot;</span>
			      <span class="enscript-string">&quot;vm_fault_page()\n&quot;</span>, kr);
		}
	}
	m = result_page;

	<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
		assert((change_wiring &amp;&amp; !wired) ?
	   	    (top_page == VM_PAGE_NULL) :
	   	    ((top_page == VM_PAGE_NULL) == (m-&gt;object == object)));
	}

	<span class="enscript-comment">/*
	 * What to do with the resulting page from vm_fault_page
	 * if it doesn't get entered into the physical map:
	 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RELEASE_PAGE</span>(m)					\
	MACRO_BEGIN					\
	PAGE_WAKEUP_DONE(m);				\
	<span class="enscript-keyword">if</span> (!m-&gt;active &amp;&amp; !m-&gt;inactive &amp;&amp; !m-&gt;throttled) {		\
		vm_page_lockspin_queues();				\
		<span class="enscript-keyword">if</span> (!m-&gt;active &amp;&amp; !m-&gt;inactive &amp;&amp; !m-&gt;throttled)	\
			vm_page_activate(m);				\
		vm_page_unlock_queues();				\
	}								\
	MACRO_END

	<span class="enscript-comment">/*
	 * We must verify that the maps have not changed
	 * since our last lookup.
	 */</span>
	<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
		old_copy_object = m-&gt;object-&gt;copy;
		vm_object_unlock(m-&gt;object);
	} <span class="enscript-keyword">else</span> {
		old_copy_object = VM_OBJECT_NULL;
		vm_object_unlock(object);
	}

	<span class="enscript-comment">/*
	 * no object locks are held at this point
	 */</span>
	<span class="enscript-keyword">if</span> ((map != original_map) || !vm_map_verify(map, &amp;version)) {
		vm_object_t		retry_object;
		vm_object_offset_t	retry_offset;
		vm_prot_t		retry_prot;

		<span class="enscript-comment">/*
		 * To avoid trying to write_lock the map while another
		 * thread has it read_locked (in vm_map_pageable), we
		 * do not try for write permission.  If the page is
		 * still writable, we will get write permission.  If it
		 * is not, or has been marked needs_copy, we enter the
		 * mapping without write permission, and will merely
		 * take another fault.
		 */</span>
		map = original_map;
		vm_map_lock_read(map);

		kr = vm_map_lookup_locked(&amp;map, vaddr,
					  fault_type &amp; ~VM_PROT_WRITE,
					  OBJECT_LOCK_EXCLUSIVE, &amp;version,
					  &amp;retry_object, &amp;retry_offset, &amp;retry_prot,
					  &amp;wired,
					  &amp;fault_info,
					  &amp;real_map);
		pmap = real_map-&gt;pmap;

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			vm_map_unlock_read(map);

			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
			        <span class="enscript-comment">/*
				 * retake the lock so that
				 * we can drop the paging reference
				 * in vm_fault_cleanup and do the
				 * PAGE_WAKEUP_DONE in RELEASE_PAGE
				 */</span>
				vm_object_lock(m-&gt;object);

				RELEASE_PAGE(m);

				vm_fault_cleanup(m-&gt;object, top_page);
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-comment">/*
				 * retake the lock so that
				 * we can drop the paging reference
				 * in vm_fault_cleanup
				 */</span>
			        vm_object_lock(object);

			        vm_fault_cleanup(object, top_page);
			}
			vm_object_deallocate(object);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		vm_object_unlock(retry_object);

		<span class="enscript-keyword">if</span> ((retry_object != object) || (retry_offset != offset)) {

			vm_map_unlock_read(map);
			<span class="enscript-keyword">if</span> (real_map != map)
				vm_map_unlock(real_map);

			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
			        <span class="enscript-comment">/*
				 * retake the lock so that
				 * we can drop the paging reference
				 * in vm_fault_cleanup and do the
				 * PAGE_WAKEUP_DONE in RELEASE_PAGE
				 */</span>
			        vm_object_lock(m-&gt;object);

				RELEASE_PAGE(m);

				vm_fault_cleanup(m-&gt;object, top_page);
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-comment">/*
				 * retake the lock so that
				 * we can drop the paging reference
				 * in vm_fault_cleanup
				 */</span>
			        vm_object_lock(object);

			        vm_fault_cleanup(object, top_page);
			}
			vm_object_deallocate(object);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
		}
		<span class="enscript-comment">/*
		 * Check whether the protection has changed or the object
		 * has been copied while we left the map unlocked.
		 */</span>
		prot &amp;= retry_prot;
	}
	<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
		vm_object_lock(m-&gt;object);

		<span class="enscript-keyword">if</span> (m-&gt;object-&gt;copy != old_copy_object) {
		        <span class="enscript-comment">/*
			 * The copy object changed while the top-level object
			 * was unlocked, so take away write permission.
			 */</span>
			prot &amp;= ~VM_PROT_WRITE;
		}
	} <span class="enscript-keyword">else</span>
		vm_object_lock(object);

	<span class="enscript-comment">/*
	 * If we want to wire down this page, but no longer have
	 * adequate permissions, we must start all over.
	 */</span>
	<span class="enscript-keyword">if</span> (wired &amp;&amp; (fault_type != (prot | VM_PROT_WRITE))) {

		vm_map_verify_done(map, &amp;version);
		<span class="enscript-keyword">if</span> (real_map != map)
			vm_map_unlock(real_map);

		<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
			RELEASE_PAGE(m);

			vm_fault_cleanup(m-&gt;object, top_page);
		} <span class="enscript-keyword">else</span>
		        vm_fault_cleanup(object, top_page);

		vm_object_deallocate(object);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryFault</span>;
	}
	<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
		<span class="enscript-comment">/*
		 * Put this page into the physical map.
		 * We had to do the unlock above because pmap_enter
		 * may cause other faults.  The page may be on
		 * the pageout queues.  If the pageout daemon comes
		 * across the page, it will remove it from the queues.
		 */</span>
		<span class="enscript-keyword">if</span> (caller_pmap) {
			kr = vm_fault_enter(m,
					    caller_pmap,
					    caller_pmap_addr,
					    prot,
					    caller_prot,
					    wired,
					    change_wiring,
					    fault_info.no_cache,
					    fault_info.cs_bypass,
					    fault_info.user_tag,
					    fault_info.pmap_options,
					    NULL,
					    &amp;type_of_fault);
		} <span class="enscript-keyword">else</span> {
			kr = vm_fault_enter(m,
					    pmap,
					    vaddr,
					    prot,
					    caller_prot,
					    wired,
					    change_wiring,
					    fault_info.no_cache,
					    fault_info.cs_bypass,
					    fault_info.user_tag,
					    fault_info.pmap_options,
					    NULL,
					    &amp;type_of_fault);
		}
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-comment">/* abort this page fault */</span>
			vm_map_verify_done(map, &amp;version);
			<span class="enscript-keyword">if</span> (real_map != map)
				vm_map_unlock(real_map);
			PAGE_WAKEUP_DONE(m);
			vm_fault_cleanup(m-&gt;object, top_page);
			vm_object_deallocate(object);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (physpage_p != NULL) {
			<span class="enscript-comment">/* for vm_map_wire_and_extract() */</span>
			*physpage_p = m-&gt;phys_page;
			<span class="enscript-keyword">if</span> (prot &amp; VM_PROT_WRITE) {
				vm_object_lock_assert_exclusive(m-&gt;object);
				m-&gt;dirty = TRUE;
			}
		}
	} <span class="enscript-keyword">else</span> {

		vm_map_entry_t		entry;
		vm_map_offset_t		laddr;
		vm_map_offset_t		ldelta, hdelta;

		<span class="enscript-comment">/* 
		 * do a pmap block mapping from the physical address
		 * in the object 
		 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ppc</span>
		<span class="enscript-comment">/* While we do not worry about execution protection in   */</span>
		<span class="enscript-comment">/* general, certian pages may have instruction execution */</span>
		<span class="enscript-comment">/* disallowed.  We will check here, and if not allowed   */</span>
		<span class="enscript-comment">/* to execute, we return with a protection failure.      */</span>

		<span class="enscript-keyword">if</span> ((fault_type &amp; VM_PROT_EXECUTE) &amp;&amp;
			(!pmap_eligible_for_execute((ppnum_t)(object-&gt;vo_shadow_offset &gt;&gt; 12)))) {

			vm_map_verify_done(map, &amp;version);

			<span class="enscript-keyword">if</span> (real_map != map)
				vm_map_unlock(real_map);

			vm_fault_cleanup(object, top_page);
			vm_object_deallocate(object);

			kr = KERN_PROTECTION_FAILURE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ppc */</span>

		<span class="enscript-keyword">if</span> (real_map != map)
			vm_map_unlock(real_map);

		<span class="enscript-keyword">if</span> (original_map != map) {
			vm_map_unlock_read(map);
			vm_map_lock_read(original_map);
			map = original_map;
		}
		real_map = map;

		laddr = vaddr;
		hdelta = 0xFFFFF000;
		ldelta = 0xFFFFF000;

		<span class="enscript-keyword">while</span> (vm_map_lookup_entry(map, laddr, &amp;entry)) {
			<span class="enscript-keyword">if</span> (ldelta &gt; (laddr - entry-&gt;vme_start))
				ldelta = laddr - entry-&gt;vme_start;
			<span class="enscript-keyword">if</span> (hdelta &gt; (entry-&gt;vme_end - laddr))
				hdelta = entry-&gt;vme_end - laddr;
			<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map) {
				
				laddr = ((laddr - entry-&gt;vme_start) 
					 + VME_OFFSET(entry));
				vm_map_lock_read(VME_SUBMAP(entry));

				<span class="enscript-keyword">if</span> (map != real_map)
					vm_map_unlock_read(map);
				<span class="enscript-keyword">if</span> (entry-&gt;use_pmap) {
					vm_map_unlock_read(real_map);
					real_map = VME_SUBMAP(entry);
				}
				map = VME_SUBMAP(entry);
				
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (vm_map_lookup_entry(map, laddr, &amp;entry) &amp;&amp; 
		    (VME_OBJECT(entry) != NULL) &amp;&amp;
		    (VME_OBJECT(entry) == object)) {
			<span class="enscript-type">int</span> superpage;

			<span class="enscript-keyword">if</span> (!object-&gt;pager_created &amp;&amp;
			    object-&gt;phys_contiguous) {
				superpage = VM_MEM_SUPERPAGE;
			} <span class="enscript-keyword">else</span> {
				superpage = 0;
			}

			<span class="enscript-keyword">if</span> (superpage &amp;&amp; physpage_p) {
				<span class="enscript-comment">/* for vm_map_wire_and_extract() */</span>
				*physpage_p = (ppnum_t)
					((((vm_map_offset_t)
					   object-&gt;vo_shadow_offset)
					  + VME_OFFSET(entry)
					  + (laddr - entry-&gt;vme_start))
					 &gt;&gt; PAGE_SHIFT);
			}

			<span class="enscript-keyword">if</span> (caller_pmap) {
				<span class="enscript-comment">/*
				 * Set up a block mapped area
				 */</span>
				assert((uint32_t)((ldelta + hdelta) &gt;&gt; PAGE_SHIFT) == ((ldelta + hdelta) &gt;&gt; PAGE_SHIFT));
				pmap_map_block(caller_pmap, 
					       (addr64_t)(caller_pmap_addr - ldelta), 
					       (ppnum_t)((((vm_map_offset_t) (VME_OBJECT(entry)-&gt;vo_shadow_offset)) +
							  VME_OFFSET(entry) + (laddr - entry-&gt;vme_start) - ldelta) &gt;&gt; PAGE_SHIFT),
					       (uint32_t)((ldelta + hdelta) &gt;&gt; PAGE_SHIFT), prot, 
					       (VM_WIMG_MASK &amp; (<span class="enscript-type">int</span>)object-&gt;wimg_bits) | superpage, 0);
			} <span class="enscript-keyword">else</span> { 
				<span class="enscript-comment">/*
				 * Set up a block mapped area
				 */</span>
				assert((uint32_t)((ldelta + hdelta) &gt;&gt; PAGE_SHIFT) == ((ldelta + hdelta) &gt;&gt; PAGE_SHIFT));
				pmap_map_block(real_map-&gt;pmap, 
					       (addr64_t)(vaddr - ldelta), 
					       (ppnum_t)((((vm_map_offset_t)(VME_OBJECT(entry)-&gt;vo_shadow_offset)) +
							  VME_OFFSET(entry) + (laddr - entry-&gt;vme_start) - ldelta) &gt;&gt; PAGE_SHIFT),
					       (uint32_t)((ldelta + hdelta) &gt;&gt; PAGE_SHIFT), prot, 
					       (VM_WIMG_MASK &amp; (<span class="enscript-type">int</span>)object-&gt;wimg_bits) | superpage, 0);
			}
		}
	}

	<span class="enscript-comment">/*
	 * Unlock everything, and return
	 */</span>
	vm_map_verify_done(map, &amp;version);
	<span class="enscript-keyword">if</span> (real_map != map)
		vm_map_unlock(real_map);

	<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
		PAGE_WAKEUP_DONE(m);

		vm_fault_cleanup(m-&gt;object, top_page);
	} <span class="enscript-keyword">else</span>
	        vm_fault_cleanup(object, top_page);

	vm_object_deallocate(object);

#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">RELEASE_PAGE</span>

	kr = KERN_SUCCESS;
<span class="enscript-reference">done</span>:
	thread_interrupt_level(interruptible_state);

	<span class="enscript-comment">/*
	 * Only I/O throttle on faults which cause a pagein/swapin.
	 */</span>
	<span class="enscript-keyword">if</span> ((type_of_fault == DBG_PAGEIND_FAULT) || (type_of_fault == DBG_PAGEINV_FAULT) || (type_of_fault == DBG_COMPRESSOR_SWAPIN_FAULT)) {
		throttle_lowpri_io(1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS &amp;&amp; type_of_fault != DBG_CACHE_HIT_FAULT &amp;&amp; type_of_fault != DBG_GUARD_FAULT) {

			<span class="enscript-keyword">if</span> ((throttle_delay = vm_page_throttled(TRUE))) {

				<span class="enscript-keyword">if</span> (vm_debug_events) {
					<span class="enscript-keyword">if</span> (type_of_fault == DBG_COMPRESSOR_FAULT)
						VM_DEBUG_EVENT(vmf_compressordelay, VMF_COMPRESSORDELAY, DBG_FUNC_NONE, throttle_delay, 0, 0, 0);
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (type_of_fault == DBG_COW_FAULT)
						VM_DEBUG_EVENT(vmf_cowdelay, VMF_COWDELAY, DBG_FUNC_NONE, throttle_delay, 0, 0, 0);
					<span class="enscript-keyword">else</span>
						VM_DEBUG_EVENT(vmf_zfdelay, VMF_ZFDELAY, DBG_FUNC_NONE, throttle_delay, 0, 0, 0);
				}
				delay(throttle_delay);
			}
		}
	}
	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
			      (MACHDBG_CODE(DBG_MACH_VM, 2)) | DBG_FUNC_END,
			      ((uint64_t)vaddr &gt;&gt; 32),
			      vaddr,
			      kr,
			      type_of_fault,
			      0);

	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	vm_fault_wire:
 *
 *	Wire down a range of virtual addresses in a map.
 */</span>
kern_return_t
<span class="enscript-function-name">vm_fault_wire</span>(
	vm_map_t	map,
	vm_map_entry_t	entry,
	vm_prot_t       prot,
	pmap_t		pmap,
	vm_map_offset_t	pmap_addr,
	ppnum_t		*physpage_p)
{

	<span class="enscript-type">register</span> vm_map_offset_t	va;
	<span class="enscript-type">register</span> vm_map_offset_t	end_addr = entry-&gt;vme_end;
	<span class="enscript-type">register</span> kern_return_t	rc;

	assert(entry-&gt;in_transition);

	<span class="enscript-keyword">if</span> ((VME_OBJECT(entry) != NULL) &amp;&amp; 
	    !entry-&gt;is_sub_map &amp;&amp; 
	    VME_OBJECT(entry)-&gt;phys_contiguous) {
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-comment">/*
	 *	Inform the physical mapping system that the
	 *	range of addresses may not fault, so that
	 *	page tables and such can be locked down as well.
	 */</span>

	pmap_pageable(pmap, pmap_addr, 
		pmap_addr + (end_addr - entry-&gt;vme_start), FALSE);

	<span class="enscript-comment">/*
	 *	We simulate a fault to get the page and enter it
	 *	in the physical map.
	 */</span>

	<span class="enscript-keyword">for</span> (va = entry-&gt;vme_start; va &lt; end_addr; va += PAGE_SIZE) {
		rc = vm_fault_wire_fast(map, va, prot, entry, pmap, 
					pmap_addr + (va - entry-&gt;vme_start),
					physpage_p);
		<span class="enscript-keyword">if</span> (rc != KERN_SUCCESS) {
			rc = vm_fault_internal(map, va, prot, TRUE, 
					       ((pmap == kernel_pmap)
						? THREAD_UNINT
						: THREAD_ABORTSAFE), 
					       pmap,
					       (pmap_addr +
						(va - entry-&gt;vme_start)),
					       physpage_p);
			DTRACE_VM2(softlock, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
		}

		<span class="enscript-keyword">if</span> (rc != KERN_SUCCESS) {
			<span class="enscript-type">struct</span> vm_map_entry	tmp_entry = *entry;

			<span class="enscript-comment">/* unwire wired pages */</span>
			tmp_entry.vme_end = va;
			vm_fault_unwire(map, 
				&amp;tmp_entry, FALSE, pmap, pmap_addr);

			<span class="enscript-keyword">return</span> rc;
		}
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	vm_fault_unwire:
 *
 *	Unwire a range of virtual addresses in a map.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_unwire</span>(
	vm_map_t	map,
	vm_map_entry_t	entry,
	boolean_t	deallocate,
	pmap_t		pmap,
	vm_map_offset_t	pmap_addr)
{
	<span class="enscript-type">register</span> vm_map_offset_t	va;
	<span class="enscript-type">register</span> vm_map_offset_t	end_addr = entry-&gt;vme_end;
	vm_object_t		object;
	<span class="enscript-type">struct</span> vm_object_fault_info fault_info;

	object = (entry-&gt;is_sub_map) ? VM_OBJECT_NULL : VME_OBJECT(entry);

	<span class="enscript-comment">/*
	 * If it's marked phys_contiguous, then vm_fault_wire() didn't actually
	 * do anything since such memory is wired by default.  So we don't have
	 * anything to undo here.
	 */</span>

	<span class="enscript-keyword">if</span> (object != VM_OBJECT_NULL &amp;&amp; object-&gt;phys_contiguous)
		<span class="enscript-keyword">return</span>;

	fault_info.interruptible = THREAD_UNINT;
	fault_info.behavior = entry-&gt;behavior;
	fault_info.user_tag = VME_ALIAS(entry);
	fault_info.pmap_options = 0;
	<span class="enscript-keyword">if</span> (entry-&gt;iokit_acct ||
	    (!entry-&gt;is_sub_map &amp;&amp; !entry-&gt;use_pmap)) {
		fault_info.pmap_options |= PMAP_OPTIONS_ALT_ACCT;
	}
	fault_info.lo_offset = VME_OFFSET(entry);
	fault_info.hi_offset = (entry-&gt;vme_end - entry-&gt;vme_start) + VME_OFFSET(entry);
	fault_info.no_cache = entry-&gt;no_cache;
	fault_info.stealth = TRUE;
	fault_info.io_sync = FALSE;
	fault_info.cs_bypass = FALSE;
	fault_info.mark_zf_absent = FALSE;
	fault_info.batch_pmap_op = FALSE;

	<span class="enscript-comment">/*
	 *	Since the pages are wired down, we must be able to
	 *	get their mappings from the physical map system.
	 */</span>

	<span class="enscript-keyword">for</span> (va = entry-&gt;vme_start; va &lt; end_addr; va += PAGE_SIZE) {

		<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
			<span class="enscript-keyword">if</span> (pmap) {
				pmap_change_wiring(pmap, 
						   pmap_addr + (va - entry-&gt;vme_start), FALSE);
			}
			(<span class="enscript-type">void</span>) vm_fault(map, va, VM_PROT_NONE, 
					TRUE, THREAD_UNINT, pmap, pmap_addr);
		} <span class="enscript-keyword">else</span> {
		 	vm_prot_t	prot;
			vm_page_t	result_page;
			vm_page_t	top_page;
			vm_object_t	result_object;
			vm_fault_return_t result;

			<span class="enscript-keyword">if</span> (end_addr - va &gt; (vm_size_t) -1) {
				<span class="enscript-comment">/* 32-bit overflow */</span>
				fault_info.cluster_size = (vm_size_t) (0 - PAGE_SIZE);
			} <span class="enscript-keyword">else</span> {
				fault_info.cluster_size = (vm_size_t) (end_addr - va);
				assert(fault_info.cluster_size == end_addr - va);
			}

			<span class="enscript-keyword">do</span> {
				prot = VM_PROT_NONE;

				vm_object_lock(object);
				vm_object_paging_begin(object);
				XPR(XPR_VM_FAULT,
					<span class="enscript-string">&quot;vm_fault_unwire -&gt; vm_fault_page\n&quot;</span>,
					0,0,0,0,0);
				result_page = VM_PAGE_NULL;
			 	result = vm_fault_page(
					object,
					(VME_OFFSET(entry) +
					 (va - entry-&gt;vme_start)),
					VM_PROT_NONE, TRUE,
					FALSE, <span class="enscript-comment">/* page not looked up */</span>
					&amp;prot, &amp;result_page, &amp;top_page,
					(<span class="enscript-type">int</span> *)0,
					NULL, map-&gt;no_zero_fill, 
					FALSE, &amp;fault_info);
			} <span class="enscript-keyword">while</span> (result == VM_FAULT_RETRY);

			<span class="enscript-comment">/*
			 * If this was a mapping to a file on a device that has been forcibly
			 * unmounted, then we won't get a page back from vm_fault_page().  Just
			 * move on to the next one in case the remaining pages are mapped from
			 * different objects.  During a forced unmount, the object is terminated
			 * so the alive flag will be false if this happens.  A forced unmount will
			 * will occur when an external disk is unplugged before the user does an 
			 * eject, so we don't want to panic in that situation.
			 */</span>

			<span class="enscript-keyword">if</span> (result == VM_FAULT_MEMORY_ERROR &amp;&amp; !object-&gt;alive)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (result == VM_FAULT_MEMORY_ERROR &amp;&amp;
			    object == kernel_object) {
				<span class="enscript-comment">/*
				 * This must have been allocated with
				 * KMA_KOBJECT and KMA_VAONLY and there's
				 * no physical page at this offset.
				 * We're done (no page to free).
				 */</span>
				assert(deallocate);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (result != VM_FAULT_SUCCESS)
				panic(<span class="enscript-string">&quot;vm_fault_unwire: failure&quot;</span>);

			result_object = result_page-&gt;object;

			<span class="enscript-keyword">if</span> (deallocate) {
				assert(result_page-&gt;phys_page !=
				       vm_page_fictitious_addr);
				pmap_disconnect(result_page-&gt;phys_page);
				VM_PAGE_FREE(result_page);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> ((pmap) &amp;&amp; (result_page-&gt;phys_page != vm_page_guard_addr))
					pmap_change_wiring(pmap, 
					    pmap_addr + (va - entry-&gt;vme_start), FALSE);


				<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(result_page)) {
					vm_page_lockspin_queues();
					vm_page_unwire(result_page, TRUE);
					vm_page_unlock_queues();
				}
				<span class="enscript-keyword">if</span>(entry-&gt;zero_wired_pages) {
					pmap_zero_page(result_page-&gt;phys_page);
					entry-&gt;zero_wired_pages = FALSE;
				}

				PAGE_WAKEUP_DONE(result_page);
			}
			vm_fault_cleanup(result_object, top_page);
		}
	}

	<span class="enscript-comment">/*
	 *	Inform the physical mapping system that the range
	 *	of addresses may fault, so that page tables and
	 *	such may be unwired themselves.
	 */</span>

	pmap_pageable(pmap, pmap_addr, 
		pmap_addr + (end_addr - entry-&gt;vme_start), TRUE);

}

<span class="enscript-comment">/*
 *	vm_fault_wire_fast:
 *
 *	Handle common case of a wire down page fault at the given address.
 *	If successful, the page is inserted into the associated physical map.
 *	The map entry is passed in to avoid the overhead of a map lookup.
 *
 *	NOTE: the given address should be truncated to the
 *	proper page address.
 *
 *	KERN_SUCCESS is returned if the page fault is handled; otherwise,
 *	a standard error specifying why the fault is fatal is returned.
 *
 *	The map in question must be referenced, and remains so.
 *	Caller has a read lock on the map.
 *
 *	This is a stripped version of vm_fault() for wiring pages.  Anything
 *	other than the common case will return KERN_FAILURE, and the caller
 *	is expected to call vm_fault().
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vm_fault_wire_fast</span>(
	__unused vm_map_t	map,
	vm_map_offset_t	va,
	vm_prot_t       caller_prot,
	vm_map_entry_t	entry,
	pmap_t		pmap,
	vm_map_offset_t	pmap_addr,
	ppnum_t		*physpage_p)
{
	vm_object_t		object;
	vm_object_offset_t	offset;
	<span class="enscript-type">register</span> vm_page_t	m;
	vm_prot_t		prot;
	thread_t           	thread = current_thread();
	<span class="enscript-type">int</span>			type_of_fault;
	kern_return_t		kr;

	VM_STAT_INCR(faults);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL &amp;&amp; thread-&gt;task != TASK_NULL)
	  thread-&gt;task-&gt;faults++;

<span class="enscript-comment">/*
 *	Recovery actions
 */</span>

#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">RELEASE_PAGE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RELEASE_PAGE</span>(m)	{				\
	PAGE_WAKEUP_DONE(m);				\
	vm_page_lockspin_queues();			\
	vm_page_unwire(m, TRUE);			\
	vm_page_unlock_queues();			\
}


#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">UNLOCK_THINGS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UNLOCK_THINGS</span>	{				\
	vm_object_paging_end(object);			   \
	vm_object_unlock(object);			   \
}

#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">UNLOCK_AND_DEALLOCATE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UNLOCK_AND_DEALLOCATE</span>	{			\
	UNLOCK_THINGS;					\
	vm_object_deallocate(object);			\
}
<span class="enscript-comment">/*
 *	Give up and have caller do things the hard way.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GIVE_UP</span> {					\
	UNLOCK_AND_DEALLOCATE;				\
	<span class="enscript-keyword">return</span>(KERN_FAILURE);				\
}


	<span class="enscript-comment">/*
	 *	If this entry is not directly to a vm_object, bail out.
	 */</span>
	<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map) {
		assert(physpage_p == NULL);
		<span class="enscript-keyword">return</span>(KERN_FAILURE);
	}

	<span class="enscript-comment">/*
	 *	Find the backing store object and offset into it.
	 */</span>

	object = VME_OBJECT(entry);
	offset = (va - entry-&gt;vme_start) + VME_OFFSET(entry);
	prot = entry-&gt;protection;

   	<span class="enscript-comment">/*
	 *	Make a reference to this object to prevent its
	 *	disposal while we are messing with it.
	 */</span>

	vm_object_lock(object);
	vm_object_reference_locked(object);
	vm_object_paging_begin(object);

	<span class="enscript-comment">/*
	 *	INVARIANTS (through entire routine):
	 *
	 *	1)	At all times, we must either have the object
	 *		lock or a busy page in some object to prevent
	 *		some other thread from trying to bring in
	 *		the same page.
	 *
	 *	2)	Once we have a busy page, we must remove it from
	 *		the pageout queues, so that the pageout daemon
	 *		will not grab it away.
	 *
	 */</span>

	<span class="enscript-comment">/*
	 *	Look for page in top-level object.  If it's not there or
	 *	there's something going on, give up.
	 * ENCRYPTED SWAP: use the slow fault path, since we'll need to
	 * decrypt the page before wiring it down.
	 */</span>
	m = vm_page_lookup(object, offset);
	<span class="enscript-keyword">if</span> ((m == VM_PAGE_NULL) || (m-&gt;busy) || (m-&gt;encrypted) ||
	    (m-&gt;unusual &amp;&amp; ( m-&gt;error || m-&gt;restart || m-&gt;absent))) {

		GIVE_UP;
	}
	ASSERT_PAGE_DECRYPTED(m);

	<span class="enscript-keyword">if</span> (m-&gt;fictitious &amp;&amp;
	    m-&gt;phys_page == vm_page_guard_addr) {
		<span class="enscript-comment">/*
		 * Guard pages are fictitious pages and are never
		 * entered into a pmap, so let's say it's been wired...
		 */</span>
		kr = KERN_SUCCESS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 *	Wire the page down now.  All bail outs beyond this
	 *	point must unwire the page.  
	 */</span>

	vm_page_lockspin_queues();
	vm_page_wire(m, VM_PROT_MEMORY_TAG(caller_prot), TRUE);
	vm_page_unlock_queues();

	<span class="enscript-comment">/*
	 *	Mark page busy for other threads.
	 */</span>
	assert(!m-&gt;busy);
	m-&gt;busy = TRUE;
	assert(!m-&gt;absent);

	<span class="enscript-comment">/*
	 *	Give up if the page is being written and there's a copy object
	 */</span>
	<span class="enscript-keyword">if</span> ((object-&gt;copy != VM_OBJECT_NULL) &amp;&amp; (prot &amp; VM_PROT_WRITE)) {
		RELEASE_PAGE(m);
		GIVE_UP;
	}

	<span class="enscript-comment">/*
	 *	Put this page into the physical map.
	 */</span>
	type_of_fault = DBG_CACHE_HIT_FAULT;
	kr = vm_fault_enter(m,
			    pmap,
			    pmap_addr,
			    prot,
			    prot,
			    TRUE,
			    FALSE,
			    FALSE,
			    FALSE,
			    VME_ALIAS(entry),
			    ((entry-&gt;iokit_acct ||
			      (!entry-&gt;is_sub_map &amp;&amp; !entry-&gt;use_pmap))
			     ? PMAP_OPTIONS_ALT_ACCT
			     : 0),
			    NULL,
			    &amp;type_of_fault);

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 *	Unlock everything, and return
	 */</span>

	<span class="enscript-keyword">if</span> (physpage_p) {
		<span class="enscript-comment">/* for vm_map_wire_and_extract() */</span>
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
			*physpage_p = m-&gt;phys_page;
			<span class="enscript-keyword">if</span> (prot &amp; VM_PROT_WRITE) {
				vm_object_lock_assert_exclusive(m-&gt;object);
				m-&gt;dirty = TRUE;
			}
		} <span class="enscript-keyword">else</span> {
			*physpage_p = 0;
		}
	}

	PAGE_WAKEUP_DONE(m);
	UNLOCK_AND_DEALLOCATE;

	<span class="enscript-keyword">return</span> kr;

}

<span class="enscript-comment">/*
 *	Routine:	vm_fault_copy_cleanup
 *	Purpose:
 *		Release a page used by vm_fault_copy.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_copy_cleanup</span>(
	vm_page_t	page,
	vm_page_t	top_page)
{
	vm_object_t	object = page-&gt;object;

	vm_object_lock(object);
	PAGE_WAKEUP_DONE(page);
	<span class="enscript-keyword">if</span> (!page-&gt;active &amp;&amp; !page-&gt;inactive &amp;&amp; !page-&gt;throttled) {
		vm_page_lockspin_queues();
		<span class="enscript-keyword">if</span> (!page-&gt;active &amp;&amp; !page-&gt;inactive &amp;&amp; !page-&gt;throttled)
			vm_page_activate(page);
		vm_page_unlock_queues();
	}
	vm_fault_cleanup(object, top_page);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_copy_dst_cleanup</span>(
	vm_page_t	page)
{
	vm_object_t	object;

	<span class="enscript-keyword">if</span> (page != VM_PAGE_NULL) {
		object = page-&gt;object;
		vm_object_lock(object);
		vm_page_lockspin_queues();
		vm_page_unwire(page, TRUE);
		vm_page_unlock_queues();
		vm_object_paging_end(object);	
		vm_object_unlock(object);
	}
}

<span class="enscript-comment">/*
 *	Routine:	vm_fault_copy
 *
 *	Purpose:
 *		Copy pages from one virtual memory object to another --
 *		neither the source nor destination pages need be resident.
 *
 *		Before actually copying a page, the version associated with
 *		the destination address map wil be verified.
 *
 *	In/out conditions:
 *		The caller must hold a reference, but not a lock, to
 *		each of the source and destination objects and to the
 *		destination map.
 *
 *	Results:
 *		Returns KERN_SUCCESS if no errors were encountered in
 *		reading or writing the data.  Returns KERN_INTERRUPTED if
 *		the operation was interrupted (only possible if the
 *		&quot;interruptible&quot; argument is asserted).  Other return values
 *		indicate a permanent error in copying the data.
 *
 *		The actual amount of data copied will be returned in the
 *		&quot;copy_size&quot; argument.  In the event that the destination map
 *		verification failed, this amount may be less than the amount
 *		requested.
 */</span>
kern_return_t
<span class="enscript-function-name">vm_fault_copy</span>(
	vm_object_t		src_object,
	vm_object_offset_t	src_offset,
	vm_map_size_t		*copy_size,		<span class="enscript-comment">/* INOUT */</span>
	vm_object_t		dst_object,
	vm_object_offset_t	dst_offset,
	vm_map_t		dst_map,
	vm_map_version_t	 *dst_version,
	<span class="enscript-type">int</span>			interruptible)
{
	vm_page_t		result_page;
	
	vm_page_t		src_page;
	vm_page_t		src_top_page;
	vm_prot_t		src_prot;

	vm_page_t		dst_page;
	vm_page_t		dst_top_page;
	vm_prot_t		dst_prot;

	vm_map_size_t		amount_left;
	vm_object_t		old_copy_object;
	kern_return_t		error = 0;
	vm_fault_return_t	result;

	vm_map_size_t		part_size;
	<span class="enscript-type">struct</span> vm_object_fault_info fault_info_src;
	<span class="enscript-type">struct</span> vm_object_fault_info fault_info_dst;

	<span class="enscript-comment">/*
	 * In order not to confuse the clustered pageins, align
	 * the different offsets on a page boundary.
	 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">RETURN</span>(x)					\
	MACRO_BEGIN					\
	*copy_size -= amount_left;			\
	MACRO_RETURN(x);				\
	MACRO_END

	amount_left = *copy_size;

	fault_info_src.interruptible = interruptible;
	fault_info_src.behavior = VM_BEHAVIOR_SEQUENTIAL;
	fault_info_src.user_tag  = 0;
	fault_info_src.pmap_options = 0;
	fault_info_src.lo_offset = vm_object_trunc_page(src_offset);
	fault_info_src.hi_offset = fault_info_src.lo_offset + amount_left;
	fault_info_src.no_cache   = FALSE;
	fault_info_src.stealth = TRUE;
	fault_info_src.io_sync = FALSE;
	fault_info_src.cs_bypass = FALSE;
	fault_info_src.mark_zf_absent = FALSE;
	fault_info_src.batch_pmap_op = FALSE;

	fault_info_dst.interruptible = interruptible;
	fault_info_dst.behavior = VM_BEHAVIOR_SEQUENTIAL;
	fault_info_dst.user_tag  = 0;
	fault_info_dst.pmap_options = 0;
	fault_info_dst.lo_offset = vm_object_trunc_page(dst_offset);
	fault_info_dst.hi_offset = fault_info_dst.lo_offset + amount_left;
	fault_info_dst.no_cache   = FALSE;
	fault_info_dst.stealth = TRUE;
	fault_info_dst.io_sync = FALSE;
	fault_info_dst.cs_bypass = FALSE;
	fault_info_dst.mark_zf_absent = FALSE;
	fault_info_dst.batch_pmap_op = FALSE;

	<span class="enscript-keyword">do</span> { <span class="enscript-comment">/* while (amount_left &gt; 0) */</span>
		<span class="enscript-comment">/*
		 * There may be a deadlock if both source and destination
		 * pages are the same. To avoid this deadlock, the copy must
		 * start by getting the destination page in order to apply
		 * COW semantics if any.
		 */</span>

	<span class="enscript-reference">RetryDestinationFault</span>: ;

		dst_prot = VM_PROT_WRITE|VM_PROT_READ;

		vm_object_lock(dst_object);
		vm_object_paging_begin(dst_object);

		<span class="enscript-keyword">if</span> (amount_left &gt; (vm_size_t) -1) {
			<span class="enscript-comment">/* 32-bit overflow */</span>
			fault_info_dst.cluster_size = (vm_size_t) (0 - PAGE_SIZE);
		} <span class="enscript-keyword">else</span> {
			fault_info_dst.cluster_size = (vm_size_t) amount_left;
			assert(fault_info_dst.cluster_size == amount_left);
		}

		XPR(XPR_VM_FAULT,<span class="enscript-string">&quot;vm_fault_copy -&gt; vm_fault_page\n&quot;</span>,0,0,0,0,0);
		dst_page = VM_PAGE_NULL;
		result = vm_fault_page(dst_object,
				       vm_object_trunc_page(dst_offset),
				       VM_PROT_WRITE|VM_PROT_READ,
				       FALSE,
				       FALSE, <span class="enscript-comment">/* page not looked up */</span>
				       &amp;dst_prot, &amp;dst_page, &amp;dst_top_page,
				       (<span class="enscript-type">int</span> *)0,
				       &amp;error,
				       dst_map-&gt;no_zero_fill,
				       FALSE, &amp;fault_info_dst);
		<span class="enscript-keyword">switch</span> (result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_SUCCESS</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_RETRY</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryDestinationFault</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_SHORTAGE</span>:
			<span class="enscript-keyword">if</span> (vm_page_wait(interruptible))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetryDestinationFault</span>;
			<span class="enscript-comment">/* fall thru */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_INTERRUPTED</span>:
			RETURN(MACH_SEND_INTERRUPTED);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_SUCCESS_NO_VM_PAGE</span>:
			<span class="enscript-comment">/* success but no VM page: fail the copy */</span>
			vm_object_paging_end(dst_object);
			vm_object_unlock(dst_object);
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_ERROR</span>:
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span>(KERN_MEMORY_ERROR);
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;vm_fault_copy: unexpected error 0x%x from &quot;</span>
			      <span class="enscript-string">&quot;vm_fault_page()\n&quot;</span>, result);
		}
		assert ((dst_prot &amp; VM_PROT_WRITE) != VM_PROT_NONE);

		old_copy_object = dst_page-&gt;object-&gt;copy;

		<span class="enscript-comment">/*
		 * There exists the possiblity that the source and
		 * destination page are the same.  But we can't
		 * easily determine that now.  If they are the
		 * same, the call to vm_fault_page() for the
		 * destination page will deadlock.  To prevent this we
		 * wire the page so we can drop busy without having
		 * the page daemon steal the page.  We clean up the 
		 * top page  but keep the paging reference on the object
		 * holding the dest page so it doesn't go away.
		 */</span>

		vm_page_lockspin_queues();
		vm_page_wire(dst_page, VM_KERN_MEMORY_OSFMK, TRUE);
		vm_page_unlock_queues();
		PAGE_WAKEUP_DONE(dst_page);
		vm_object_unlock(dst_page-&gt;object);

		<span class="enscript-keyword">if</span> (dst_top_page != VM_PAGE_NULL) {
			vm_object_lock(dst_object);
			VM_PAGE_FREE(dst_top_page);
			vm_object_paging_end(dst_object);
			vm_object_unlock(dst_object);
		}

	<span class="enscript-reference">RetrySourceFault</span>: ;

		<span class="enscript-keyword">if</span> (src_object == VM_OBJECT_NULL) {
			<span class="enscript-comment">/*
			 *	No source object.  We will just
			 *	zero-fill the page in dst_object.
			 */</span>
			src_page = VM_PAGE_NULL;
			result_page = VM_PAGE_NULL;
		} <span class="enscript-keyword">else</span> {
			vm_object_lock(src_object);
			src_page = vm_page_lookup(src_object,
						  vm_object_trunc_page(src_offset));
			<span class="enscript-keyword">if</span> (src_page == dst_page) {
				src_prot = dst_prot;
				result_page = VM_PAGE_NULL;
			} <span class="enscript-keyword">else</span> {
				src_prot = VM_PROT_READ;
				vm_object_paging_begin(src_object);

				<span class="enscript-keyword">if</span> (amount_left &gt; (vm_size_t) -1) {
					<span class="enscript-comment">/* 32-bit overflow */</span>
					fault_info_src.cluster_size = (vm_size_t) (0 - PAGE_SIZE);
				} <span class="enscript-keyword">else</span> {
					fault_info_src.cluster_size = (vm_size_t) amount_left;
					assert(fault_info_src.cluster_size == amount_left);
				}

				XPR(XPR_VM_FAULT,
					<span class="enscript-string">&quot;vm_fault_copy(2) -&gt; vm_fault_page\n&quot;</span>,
					0,0,0,0,0);
				result_page = VM_PAGE_NULL;
				result = vm_fault_page(
					src_object, 
					vm_object_trunc_page(src_offset),
					VM_PROT_READ, FALSE,
					FALSE, <span class="enscript-comment">/* page not looked up */</span>
					&amp;src_prot, 
					&amp;result_page, &amp;src_top_page,
					(<span class="enscript-type">int</span> *)0, &amp;error, FALSE,
					FALSE, &amp;fault_info_src);

				<span class="enscript-keyword">switch</span> (result) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_SUCCESS</span>:
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_RETRY</span>:
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetrySourceFault</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_SHORTAGE</span>:
					<span class="enscript-keyword">if</span> (vm_page_wait(interruptible))
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">RetrySourceFault</span>;
					<span class="enscript-comment">/* fall thru */</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_INTERRUPTED</span>:
					vm_fault_copy_dst_cleanup(dst_page);
					RETURN(MACH_SEND_INTERRUPTED);
				<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_SUCCESS_NO_VM_PAGE</span>:
					<span class="enscript-comment">/* success but no VM page: fail */</span>
					vm_object_paging_end(src_object);
					vm_object_unlock(src_object);
					<span class="enscript-comment">/*FALLTHROUGH*/</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_FAULT_MEMORY_ERROR</span>:
					vm_fault_copy_dst_cleanup(dst_page);
					<span class="enscript-keyword">if</span> (error)
						<span class="enscript-keyword">return</span> (error);
					<span class="enscript-keyword">else</span>
						<span class="enscript-keyword">return</span>(KERN_MEMORY_ERROR);
				<span class="enscript-reference">default</span>:
					panic(<span class="enscript-string">&quot;vm_fault_copy(2): unexpected &quot;</span>
					      <span class="enscript-string">&quot;error 0x%x from &quot;</span>
					      <span class="enscript-string">&quot;vm_fault_page()\n&quot;</span>, result);
				}


				assert((src_top_page == VM_PAGE_NULL) ==
				       (result_page-&gt;object == src_object));
			}
			assert ((src_prot &amp; VM_PROT_READ) != VM_PROT_NONE);
			vm_object_unlock(result_page-&gt;object);
		}

		<span class="enscript-keyword">if</span> (!vm_map_verify(dst_map, dst_version)) {
			<span class="enscript-keyword">if</span> (result_page != VM_PAGE_NULL &amp;&amp; src_page != dst_page)
				vm_fault_copy_cleanup(result_page, src_top_page);
			vm_fault_copy_dst_cleanup(dst_page);
			<span class="enscript-keyword">break</span>;
		}

		vm_object_lock(dst_page-&gt;object);

		<span class="enscript-keyword">if</span> (dst_page-&gt;object-&gt;copy != old_copy_object) {
			vm_object_unlock(dst_page-&gt;object);
			vm_map_verify_done(dst_map, dst_version);
			<span class="enscript-keyword">if</span> (result_page != VM_PAGE_NULL &amp;&amp; src_page != dst_page)
				vm_fault_copy_cleanup(result_page, src_top_page);
			vm_fault_copy_dst_cleanup(dst_page);
			<span class="enscript-keyword">break</span>;
		}
		vm_object_unlock(dst_page-&gt;object);

		<span class="enscript-comment">/*
		 *	Copy the page, and note that it is dirty
		 *	immediately.
		 */</span>

		<span class="enscript-keyword">if</span> (!page_aligned(src_offset) ||
			!page_aligned(dst_offset) ||
			!page_aligned(amount_left)) {

			vm_object_offset_t	src_po,
						dst_po;

			src_po = src_offset - vm_object_trunc_page(src_offset);
			dst_po = dst_offset - vm_object_trunc_page(dst_offset);

			<span class="enscript-keyword">if</span> (dst_po &gt; src_po) {
				part_size = PAGE_SIZE - dst_po;
			} <span class="enscript-keyword">else</span> {
				part_size = PAGE_SIZE - src_po;
			}
			<span class="enscript-keyword">if</span> (part_size &gt; (amount_left)){
				part_size = amount_left;
			}

			<span class="enscript-keyword">if</span> (result_page == VM_PAGE_NULL) {
				assert((vm_offset_t) dst_po == dst_po);
				assert((vm_size_t) part_size == part_size);
				vm_page_part_zero_fill(dst_page,
						       (vm_offset_t) dst_po,
						       (vm_size_t) part_size);
			} <span class="enscript-keyword">else</span> {
				assert((vm_offset_t) src_po == src_po);
				assert((vm_offset_t) dst_po == dst_po);
				assert((vm_size_t) part_size == part_size);
				vm_page_part_copy(result_page,
						  (vm_offset_t) src_po,
						  dst_page,
						  (vm_offset_t) dst_po,
						  (vm_size_t)part_size);
				<span class="enscript-keyword">if</span>(!dst_page-&gt;dirty){
					vm_object_lock(dst_object);
					SET_PAGE_DIRTY(dst_page, TRUE);
					vm_object_unlock(dst_page-&gt;object);
				}

			}
		} <span class="enscript-keyword">else</span> {
			part_size = PAGE_SIZE;

			<span class="enscript-keyword">if</span> (result_page == VM_PAGE_NULL)
				vm_page_zero_fill(dst_page);
			<span class="enscript-keyword">else</span>{
				vm_object_lock(result_page-&gt;object);
				vm_page_copy(result_page, dst_page);
				vm_object_unlock(result_page-&gt;object);

				<span class="enscript-keyword">if</span>(!dst_page-&gt;dirty){
					vm_object_lock(dst_object);
					SET_PAGE_DIRTY(dst_page, TRUE);
					vm_object_unlock(dst_page-&gt;object);
				}
			}

		}

		<span class="enscript-comment">/*
		 *	Unlock everything, and return
		 */</span>

		vm_map_verify_done(dst_map, dst_version);

		<span class="enscript-keyword">if</span> (result_page != VM_PAGE_NULL &amp;&amp; src_page != dst_page)
			vm_fault_copy_cleanup(result_page, src_top_page);
		vm_fault_copy_dst_cleanup(dst_page);

		amount_left -= part_size;
		src_offset += part_size;
		dst_offset += part_size;
	} <span class="enscript-keyword">while</span> (amount_left &gt; 0);

	RETURN(KERN_SUCCESS);
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">RETURN</span>

	<span class="enscript-comment">/*NOTREACHED*/</span>	
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">VM_FAULT_CLASSIFY</span>
<span class="enscript-comment">/*
 *	Temporary statistics gathering support.
 */</span>

<span class="enscript-comment">/*
 *	Statistics arrays:
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_FAULT_TYPES_MAX</span>	5
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_FAULT_LEVEL_MAX</span>	8

<span class="enscript-type">int</span>	vm_fault_stats[VM_FAULT_TYPES_MAX][VM_FAULT_LEVEL_MAX];

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_FAULT_TYPE_ZERO_FILL</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_FAULT_TYPE_MAP_IN</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_FAULT_TYPE_PAGER</span>	2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_FAULT_TYPE_COPY</span>	3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_FAULT_TYPE_OTHER</span>	4


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_classify</span>(vm_object_t		object,
		  vm_object_offset_t	offset,
		  vm_prot_t		fault_type)
{
	<span class="enscript-type">int</span>		type, level = 0;
	vm_page_t	m;

	<span class="enscript-keyword">while</span> (TRUE) {
		m = vm_page_lookup(object, offset);
		<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {		
		        <span class="enscript-keyword">if</span> (m-&gt;busy || m-&gt;error || m-&gt;restart || m-&gt;absent) {
				type = VM_FAULT_TYPE_OTHER;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (((fault_type &amp; VM_PROT_WRITE) == 0) ||
			    ((level == 0) &amp;&amp; object-&gt;copy == VM_OBJECT_NULL)) {
				type = VM_FAULT_TYPE_MAP_IN;
				<span class="enscript-keyword">break</span>;	
			}
			type = VM_FAULT_TYPE_COPY;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (object-&gt;pager_created) {
				type = VM_FAULT_TYPE_PAGER;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (object-&gt;shadow == VM_OBJECT_NULL) {
				type = VM_FAULT_TYPE_ZERO_FILL;
				<span class="enscript-keyword">break</span>;
		        }

			offset += object-&gt;vo_shadow_offset;
			object = object-&gt;shadow;
			level++;
			<span class="enscript-keyword">continue</span>;
		}
	}

	<span class="enscript-keyword">if</span> (level &gt; VM_FAULT_LEVEL_MAX)
		level = VM_FAULT_LEVEL_MAX;

	vm_fault_stats[type][level] += 1;

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* cleanup routine to call from debugger */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_fault_classify_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> type, level;

	<span class="enscript-keyword">for</span> (type = 0; type &lt; VM_FAULT_TYPES_MAX; type++) {
		<span class="enscript-keyword">for</span> (level = 0; level &lt; VM_FAULT_LEVEL_MAX; level++) {
			vm_fault_stats[type][level] = 0;
		}
	}

	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VM_FAULT_CLASSIFY */</span>

vm_offset_t
<span class="enscript-function-name">kdp_lightweight_fault</span>(vm_map_t map, vm_offset_t cur_target_addr, uint32_t *fault_results)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">map</span>, <span class="enscript-variable-name">cur_target_addr</span>, <span class="enscript-variable-name">fault_results</span>)

	<span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">if</span> 0
	vm_map_entry_t	entry;
	vm_object_t	object;
	vm_offset_t	object_offset;
	vm_page_t	m;
	<span class="enscript-type">int</span>		compressor_external_state, compressed_count_delta;
	<span class="enscript-type">int</span>		compressor_flags = (C_DONT_BLOCK | C_KEEP | C_KDP);
	<span class="enscript-type">int</span>		my_fault_type = VM_PROT_READ;
	kern_return_t	kr;


	<span class="enscript-keyword">if</span> (not_in_kdp) {
		panic(<span class="enscript-string">&quot;kdp_lightweight_fault called from outside of debugger context&quot;</span>);
	}

	assert(map != VM_MAP_NULL);

	assert((cur_target_addr &amp; PAGE_MASK) == 0);
	<span class="enscript-keyword">if</span> ((cur_target_addr &amp; PAGE_MASK) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (kdp_lck_rw_lock_is_acquired_exclusive(&amp;map-&gt;lock)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (!vm_map_lookup_entry(map, cur_target_addr, &amp;entry)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map) {
		<span class="enscript-keyword">return</span> 0;
	}

	object = VME_OBJECT(entry);
	<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	object_offset = cur_target_addr - entry-&gt;vme_start + VME_OFFSET(entry);

	<span class="enscript-keyword">while</span> (TRUE) {
		<span class="enscript-keyword">if</span> (kdp_lck_rw_lock_is_acquired_exclusive(&amp;object-&gt;Lock)) {
			<span class="enscript-keyword">return</span> 0;
		}

		<span class="enscript-keyword">if</span> (object-&gt;pager_created &amp;&amp; (object-&gt;paging_in_progress ||
			object-&gt;activity_in_progress)) {
			<span class="enscript-keyword">return</span> 0;
		}

		m = kdp_vm_page_lookup(object, object_offset);

		<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {

			<span class="enscript-keyword">if</span> ((object-&gt;wimg_bits &amp; VM_WIMG_MASK) != VM_WIMG_DEFAULT) {
				<span class="enscript-keyword">return</span> 0;
			}

			<span class="enscript-keyword">if</span> (m-&gt;laundry || m-&gt;busy || m-&gt;pageout || m-&gt;absent || m-&gt;error || m-&gt;cleaning ||
				m-&gt;overwriting || m-&gt;restart || m-&gt;unusual) {
				<span class="enscript-keyword">return</span> 0;
			}

			assert(!m-&gt;private);
			<span class="enscript-keyword">if</span> (m-&gt;private) {
				<span class="enscript-keyword">return</span> 0;
			}

			assert(!m-&gt;fictitious);
			<span class="enscript-keyword">if</span> (m-&gt;fictitious) {
				<span class="enscript-keyword">return</span> 0;
			}

			assert(!m-&gt;encrypted);
			<span class="enscript-keyword">if</span> (m-&gt;encrypted) {
				<span class="enscript-keyword">return</span> 0;
			}

			assert(!m-&gt;encrypted_cleaning);
			<span class="enscript-keyword">if</span> (m-&gt;encrypted_cleaning) {
				<span class="enscript-keyword">return</span> 0;
			}

			assert(!m-&gt;compressor);
			<span class="enscript-keyword">if</span> (m-&gt;compressor) {
				<span class="enscript-keyword">return</span> 0;
			}

			<span class="enscript-keyword">if</span> (fault_results) {
				*fault_results |= kThreadFaultedBT;
			}
			<span class="enscript-keyword">return</span> ptoa(m-&gt;phys_page);
		}

		compressor_external_state = VM_EXTERNAL_STATE_UNKNOWN;

		<span class="enscript-keyword">if</span> (object-&gt;pager_created &amp;&amp; MUST_ASK_PAGER(object, object_offset, compressor_external_state)) {
			<span class="enscript-keyword">if</span> (compressor_external_state == VM_EXTERNAL_STATE_EXISTS) {
				kr = vm_compressor_pager_get(object-&gt;pager, (object_offset + object-&gt;paging_offset),
								kdp_compressor_decompressed_page_ppnum, &amp;my_fault_type,
								compressor_flags, &amp;compressed_count_delta);
				<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
					<span class="enscript-keyword">if</span> (fault_results) {
						*fault_results |= kThreadDecompressedBT;
					}
					<span class="enscript-keyword">return</span> kdp_compressor_decompressed_page_paddr;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">return</span> 0;
				}
			}
		}

		<span class="enscript-keyword">if</span> (object-&gt;shadow == VM_OBJECT_NULL) {
			<span class="enscript-keyword">return</span> 0;
		}

		object_offset += object-&gt;vo_shadow_offset;
		object = object-&gt;shadow;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CODE_SIGNING_CHUNK_SIZE</span> 4096
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_validate_cs_mapped</span>(
	vm_page_t	page,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span> 	*kaddr)
{
	vm_object_t		object;
	vm_object_offset_t	offset, offset_in_page;
	kern_return_t		kr;
	memory_object_t		pager;
	<span class="enscript-type">void</span>			*blobs;
	boolean_t		validated;
	<span class="enscript-type">unsigned</span>		tainted;
	<span class="enscript-type">int</span>			num_chunks, num_chunks_validated;

	assert(page-&gt;busy);
	vm_object_lock_assert_exclusive(page-&gt;object);

	<span class="enscript-keyword">if</span> (!cs_validation) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (page-&gt;wpmapped &amp;&amp; !page-&gt;cs_tainted) {
		<span class="enscript-comment">/*
		 * This page was mapped for &quot;write&quot; access sometime in the
		 * past and could still be modifiable in the future.
		 * Consider it tainted.
		 * [ If the page was already found to be &quot;tainted&quot;, no
		 * need to re-validate. ]
		 */</span>
		page-&gt;cs_validated = TRUE;
		page-&gt;cs_tainted = TRUE;
		<span class="enscript-keyword">if</span> (cs_debug) {
			printf(<span class="enscript-string">&quot;CODESIGNING: vm_page_validate_cs: &quot;</span>
			       <span class="enscript-string">&quot;page %p obj %p off 0x%llx &quot;</span>
			       <span class="enscript-string">&quot;was modified\n&quot;</span>,
			       page, page-&gt;object, page-&gt;offset);
		}
		vm_cs_validated_dirtied++;
	}

	<span class="enscript-keyword">if</span> (page-&gt;cs_validated || page-&gt;cs_tainted) {
		<span class="enscript-keyword">return</span>;
	}

	vm_cs_validates++;

	object = page-&gt;object;
	assert(object-&gt;code_signed);
	offset = page-&gt;offset;

	<span class="enscript-keyword">if</span> (!object-&gt;alive || object-&gt;terminating || object-&gt;pager == NULL) {
		<span class="enscript-comment">/*
		 * The object is terminating and we don't have its pager
		 * so we can't validate the data...
		 */</span>
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/*
	 * Since we get here to validate a page that was brought in by
	 * the pager, we know that this pager is all setup and ready
	 * by now.
	 */</span>
	assert(!object-&gt;internal);
	assert(object-&gt;pager != NULL);
	assert(object-&gt;pager_ready);

	pager = object-&gt;pager;
	assert(object-&gt;paging_in_progress);
	kr = vnode_pager_get_object_cs_blobs(pager, &amp;blobs);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		blobs = NULL;
	}

	<span class="enscript-comment">/* verify the SHA1 hash for this page */</span>
	num_chunks_validated = 0;
	<span class="enscript-keyword">for</span> (offset_in_page = 0, num_chunks = 0;
	     offset_in_page &lt; PAGE_SIZE_64;
	     offset_in_page += CODE_SIGNING_CHUNK_SIZE, num_chunks++) {
		tainted = 0;
		validated = cs_validate_page(blobs,
					     pager,
					     (object-&gt;paging_offset +
					      offset +
					      offset_in_page),
					     (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)kaddr
							    + offset_in_page),
					     &amp;tainted);
		<span class="enscript-keyword">if</span> (validated) {
			num_chunks_validated++;
		}
		<span class="enscript-keyword">if</span> (tainted &amp; CS_VALIDATE_TAINTED) {
			page-&gt;cs_tainted = TRUE;
		} 
		<span class="enscript-keyword">if</span> (tainted &amp; CS_VALIDATE_NX) {
			page-&gt;cs_nx = TRUE;
		}
	}
	<span class="enscript-comment">/* page is validated only if all its chunks are */</span>
	<span class="enscript-keyword">if</span> (num_chunks_validated == num_chunks) {
		page-&gt;cs_validated = TRUE;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_validate_cs</span>(
	vm_page_t	page)
{
	vm_object_t		object;
	vm_object_offset_t	offset;
	vm_map_offset_t		koffset;
	vm_map_size_t		ksize;
	vm_offset_t		kaddr;
	kern_return_t		kr;
	boolean_t		busy_page;
	boolean_t		need_unmap;

	vm_object_lock_assert_held(page-&gt;object);

	<span class="enscript-keyword">if</span> (!cs_validation) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (page-&gt;wpmapped &amp;&amp; !page-&gt;cs_tainted) {
		vm_object_lock_assert_exclusive(page-&gt;object);

		<span class="enscript-comment">/*
		 * This page was mapped for &quot;write&quot; access sometime in the
		 * past and could still be modifiable in the future.
		 * Consider it tainted.
		 * [ If the page was already found to be &quot;tainted&quot;, no
		 * need to re-validate. ]
		 */</span>
		page-&gt;cs_validated = TRUE;
		page-&gt;cs_tainted = TRUE;
		<span class="enscript-keyword">if</span> (cs_debug) {
			printf(<span class="enscript-string">&quot;CODESIGNING: vm_page_validate_cs: &quot;</span>
			       <span class="enscript-string">&quot;page %p obj %p off 0x%llx &quot;</span>
			       <span class="enscript-string">&quot;was modified\n&quot;</span>,
			       page, page-&gt;object, page-&gt;offset);
		}
		vm_cs_validated_dirtied++;
	}

	<span class="enscript-keyword">if</span> (page-&gt;cs_validated || page-&gt;cs_tainted) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (page-&gt;slid) {
		panic(<span class="enscript-string">&quot;vm_page_validate_cs(%p): page is slid\n&quot;</span>, page);
	}
	assert(!page-&gt;slid);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECK_CS_VALIDATION_BITMAP</span>	
	<span class="enscript-keyword">if</span> ( vnode_pager_cs_check_validation_bitmap( page-&gt;object-&gt;pager, trunc_page(page-&gt;offset + page-&gt;object-&gt;paging_offset), CS_BITMAP_CHECK ) == KERN_SUCCESS) {
		page-&gt;cs_validated = TRUE;
		page-&gt;cs_tainted = FALSE;
		vm_cs_bitmap_validated++;
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span>
	vm_object_lock_assert_exclusive(page-&gt;object);

	object = page-&gt;object;
	assert(object-&gt;code_signed);
	offset = page-&gt;offset;

	busy_page = page-&gt;busy;
	<span class="enscript-keyword">if</span> (!busy_page) {
		<span class="enscript-comment">/* keep page busy while we map (and unlock) the VM object */</span>
		page-&gt;busy = TRUE;
	}
	
	<span class="enscript-comment">/*
	 * Take a paging reference on the VM object
	 * to protect it from collapse or bypass,
	 * and keep it from disappearing too.
	 */</span>
	vm_object_paging_begin(object);

	<span class="enscript-comment">/* map the page in the kernel address space */</span>
	ksize = PAGE_SIZE_64;
	koffset = 0;
	need_unmap = FALSE;
	kr = vm_paging_map_object(page,
				  object,
				  offset,
				  VM_PROT_READ,
				  FALSE, <span class="enscript-comment">/* can't unlock object ! */</span>
				  &amp;ksize,
				  &amp;koffset,
				  &amp;need_unmap);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;vm_page_validate_cs: could not map page: 0x%x\n&quot;</span>, kr);
	}
	kaddr = CAST_DOWN(vm_offset_t, koffset);

	<span class="enscript-comment">/* validate the mapped page */</span>
	vm_page_validate_cs_mapped(page, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *) kaddr);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECK_CS_VALIDATION_BITMAP</span>	
	<span class="enscript-keyword">if</span> ( page-&gt;cs_validated == TRUE &amp;&amp; page-&gt;cs_tainted == FALSE ) {
		vnode_pager_cs_check_validation_bitmap( object-&gt;pager, trunc_page( offset + object-&gt;paging_offset), CS_BITMAP_SET );
	}
#<span class="enscript-reference">endif</span>
	assert(page-&gt;busy);
	assert(object == page-&gt;object);
	vm_object_lock_assert_exclusive(object);

	<span class="enscript-keyword">if</span> (!busy_page) {
		PAGE_WAKEUP_DONE(page);
	}
	<span class="enscript-keyword">if</span> (need_unmap) {
		<span class="enscript-comment">/* unmap the map from the kernel address space */</span>
		vm_paging_unmap_object(object, koffset, koffset + ksize);
		koffset = 0;
		ksize = 0;
		kaddr = 0;
	}
	vm_object_paging_end(object);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_validate_cs_mapped_chunk</span>(
	vm_page_t	page,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span> 	*kaddr,
	vm_offset_t	chunk_offset,
	boolean_t	*validated_p,
	<span class="enscript-type">unsigned</span>	*tainted_p)
{
	vm_object_t		object;
	vm_object_offset_t	offset, offset_in_page;
	kern_return_t		kr;
	memory_object_t		pager;
	<span class="enscript-type">void</span>			*blobs;
	boolean_t		validated;
	<span class="enscript-type">unsigned</span>		tainted;

	*validated_p = FALSE;
	*tainted_p = 0;

	assert(page-&gt;busy);
	vm_object_lock_assert_exclusive(page-&gt;object);

	<span class="enscript-keyword">if</span> (!cs_validation) {
		<span class="enscript-keyword">return</span>;
	}

	object = page-&gt;object;
	assert(object-&gt;code_signed);
	offset = page-&gt;offset;

	<span class="enscript-keyword">if</span> (!object-&gt;alive || object-&gt;terminating || object-&gt;pager == NULL) {
		<span class="enscript-comment">/*
		 * The object is terminating and we don't have its pager
		 * so we can't validate the data...
		 */</span>
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/*
	 * Since we get here to validate a page that was brought in by
	 * the pager, we know that this pager is all setup and ready
	 * by now.
	 */</span>
	assert(!object-&gt;internal);
	assert(object-&gt;pager != NULL);
	assert(object-&gt;pager_ready);

	pager = object-&gt;pager;
	assert(object-&gt;paging_in_progress);
	kr = vnode_pager_get_object_cs_blobs(pager, &amp;blobs);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		blobs = NULL;
	}

	<span class="enscript-comment">/* verify the signature for this chunk */</span>
	offset_in_page = chunk_offset;
	assert(offset_in_page &lt; PAGE_SIZE);
	assert((offset_in_page &amp; (CODE_SIGNING_CHUNK_SIZE-1)) == 0);

	tainted = 0;
	validated = cs_validate_page(blobs,
				     pager,
				     (object-&gt;paging_offset +
				      offset +
				      offset_in_page),
				     (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)kaddr
						    + offset_in_page),
				     &amp;tainted);
	<span class="enscript-keyword">if</span> (validated) {
		*validated_p = TRUE;
	}
	<span class="enscript-keyword">if</span> (tainted) {
		*tainted_p = tainted;
	}
}
</pre>
<hr />
</body></html>