<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_resident.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_resident.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm/vm_page.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Resident memory management module.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/clock_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/xpr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_init.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>			<span class="enscript-comment">/* kernel_memory_allocate() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/zone_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/cpm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/memory_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_purgeable_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_compressor.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_phantom_cache.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

boolean_t	hibernate_cleaning_in_progress = FALSE;
boolean_t	vm_page_free_verify = TRUE;

uint32_t	vm_lopage_free_count = 0;
uint32_t	vm_lopage_free_limit = 0;
uint32_t	vm_lopage_lowater    = 0;
boolean_t	vm_lopage_refill = FALSE;
boolean_t	vm_lopage_needed = FALSE;

lck_mtx_ext_t	vm_page_queue_lock_ext;
lck_mtx_ext_t	vm_page_queue_free_lock_ext;
lck_mtx_ext_t	vm_purgeable_queue_lock_ext;

<span class="enscript-type">int</span>		speculative_age_index = 0;
<span class="enscript-type">int</span>		speculative_steal_index = 0;
<span class="enscript-type">struct</span> vm_speculative_age_q vm_page_queue_speculative[VM_PAGE_MAX_SPECULATIVE_AGE_Q + 1];


__private_extern__ <span class="enscript-type">void</span>		vm_page_init_lck_grp(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		vm_page_free_prepare(vm_page_t	page);
<span class="enscript-type">static</span> vm_page_t	vm_page_grab_fictitious_common(ppnum_t phys_addr);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_tag_init</span>(<span class="enscript-type">void</span>);

uint64_t	vm_min_kernel_and_kext_address = VM_MIN_KERNEL_AND_KEXT_ADDRESS;

<span class="enscript-comment">/*
 *	Associated with page of user-allocatable memory is a
 *	page structure.
 */</span>

<span class="enscript-comment">/*
 *	These variables record the values returned by vm_page_bootstrap,
 *	for debugging purposes.  The implementation of pmap_steal_memory
 *	and pmap_startup here also uses them internally.
 */</span>

vm_offset_t virtual_space_start;
vm_offset_t virtual_space_end;
uint32_t	vm_page_pages;

<span class="enscript-comment">/*
 *	The vm_page_lookup() routine, which provides for fast
 *	(virtual memory object, offset) to page lookup, employs
 *	the following hash table.  The vm_page_{insert,remove}
 *	routines install and remove associations in the table.
 *	[This table is often called the virtual-to-physical,
 *	or VP, table.]
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	vm_page_packed_t page_list;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGE_HASH_STATS</span>
	<span class="enscript-type">int</span>		cur_count;		<span class="enscript-comment">/* current count */</span>
	<span class="enscript-type">int</span>		hi_count;		<span class="enscript-comment">/* high water mark */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGE_HASH_STATS */</span>
} vm_page_bucket_t;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BUCKETS_PER_LOCK</span>	16

vm_page_bucket_t *vm_page_buckets;		<span class="enscript-comment">/* Array of buckets */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_bucket_count = 0;	<span class="enscript-comment">/* How big is array? */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_hash_mask;		<span class="enscript-comment">/* Mask for hash function */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_hash_shift;		<span class="enscript-comment">/* Shift for hash function */</span>
uint32_t	vm_page_bucket_hash;		<span class="enscript-comment">/* Basic bucket hash */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_bucket_lock_count = 0;		<span class="enscript-comment">/* How big is array of locks? */</span>

lck_spin_t	*vm_page_bucket_locks;
lck_spin_t	vm_objects_wired_lock;
lck_spin_t	vm_allocation_sites_lock;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_BUCKETS_CHECK</span>
boolean_t vm_page_buckets_check_ready = FALSE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_FAKE_BUCKETS</span>
vm_page_bucket_t *vm_page_fake_buckets;	<span class="enscript-comment">/* decoy buckets */</span>
vm_map_offset_t vm_page_fake_buckets_start, vm_page_fake_buckets_end;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_FAKE_BUCKETS */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_BUCKETS_CHECK */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> not_in_kdp;


#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGE_HASH_STATS</span>
<span class="enscript-comment">/* This routine is only for debug.  It is intended to be called by
 * hand by a developer using a kernel debugger.  This routine prints
 * out vm_page_hash table statistics to the kernel debug console.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hash_debug</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>	i;
	<span class="enscript-type">int</span>	numbuckets = 0;
	<span class="enscript-type">int</span>	highsum = 0;
	<span class="enscript-type">int</span>	maxdepth = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_bucket_count; i++) {
		<span class="enscript-keyword">if</span> (vm_page_buckets[i].hi_count) {
			numbuckets++;
			highsum += vm_page_buckets[i].hi_count;
			<span class="enscript-keyword">if</span> (vm_page_buckets[i].hi_count &gt; maxdepth)
				maxdepth = vm_page_buckets[i].hi_count;
		}
	}
	printf(<span class="enscript-string">&quot;Total number of buckets: %d\n&quot;</span>, vm_page_bucket_count);
	printf(<span class="enscript-string">&quot;Number used buckets:     %d = %d%%\n&quot;</span>,
		numbuckets, 100*numbuckets/vm_page_bucket_count);
	printf(<span class="enscript-string">&quot;Number unused buckets:   %d = %d%%\n&quot;</span>,
		vm_page_bucket_count - numbuckets,
		100*(vm_page_bucket_count-numbuckets)/vm_page_bucket_count);
	printf(<span class="enscript-string">&quot;Sum of bucket max depth: %d\n&quot;</span>, highsum);
	printf(<span class="enscript-string">&quot;Average bucket depth:    %d.%2d\n&quot;</span>,
		highsum/vm_page_bucket_count,
		highsum%vm_page_bucket_count);
	printf(<span class="enscript-string">&quot;Maximum bucket depth:    %d\n&quot;</span>, maxdepth);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGE_HASH_STATS */</span>

<span class="enscript-comment">/*
 *	The virtual page size is currently implemented as a runtime
 *	variable, but is constant once initialized using vm_set_page_size.
 *	This initialization must be done in the machine-dependent
 *	bootstrap sequence, before calling other machine-independent
 *	initializations.
 *
 *	All references to the virtual page size outside this
 *	module must use the PAGE_SIZE, PAGE_MASK and PAGE_SHIFT
 *	constants.
 */</span>
vm_size_t	page_size  = PAGE_SIZE;
vm_size_t	page_mask  = PAGE_MASK;
<span class="enscript-type">int</span>		page_shift = PAGE_SHIFT;

<span class="enscript-comment">/*
 *	Resident page structures are initialized from
 *	a template (see vm_page_alloc).
 *
 *	When adding a new field to the virtual memory
 *	object structure, be sure to add initialization
 *	(see vm_page_bootstrap).
 */</span>
<span class="enscript-type">struct</span> vm_page	vm_page_template;

vm_page_t	vm_pages = VM_PAGE_NULL;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_pages_count = 0;
ppnum_t		vm_page_lowest = 0;

<span class="enscript-comment">/*
 *	Resident pages that represent real memory
 *	are allocated from a set of free lists,
 *	one per color.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_colors;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_color_mask;			<span class="enscript-comment">/* mask is == (vm_colors-1) */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_cache_geometry_colors = 0;	<span class="enscript-comment">/* set by hw dependent code during startup */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_free_magazine_refill_limit = 0;
queue_head_t	vm_page_queue_free[MAX_COLORS];
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_wanted;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_wanted_privileged;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_fictitious_count;

<span class="enscript-comment">/*
 *	Occasionally, the virtual memory system uses
 *	resident page structures that do not refer to
 *	real pages, for example to leave a page with
 *	important state information in the VP table.
 *
 *	These page structures are allocated the way
 *	most other kernel structures are.
 */</span>
zone_t	vm_page_zone;
vm_locks_array_t vm_page_locks;
<span class="enscript-function-name">decl_lck_mtx_data</span>(,vm_page_alloc_lock)
lck_mtx_ext_t vm_page_alloc_lock_ext;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> io_throttle_zero_fill;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_local_q_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_local_q_soft_limit = 250;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_local_q_hard_limit = 500;
<span class="enscript-type">struct</span> vplq     *vm_page_local_q = NULL;

<span class="enscript-comment">/* N.B. Guard and fictitious pages must not
 * be assigned a zero phys_page value.
 */</span>
<span class="enscript-comment">/*
 *	Fictitious pages don't have a physical address,
 *	but we must initialize phys_page to something.
 *	For debugging, this should be a strange value
 *	that the pmap module can recognize in assertions.
 */</span>
ppnum_t vm_page_fictitious_addr = (ppnum_t) -1;

<span class="enscript-comment">/*
 *	Guard pages are not accessible so they don't
 * 	need a physical address, but we need to enter
 *	one in the pmap.
 *	Let's make it recognizable and make sure that
 *	we don't use a real physical page with that
 *	physical address.
 */</span>
ppnum_t vm_page_guard_addr = (ppnum_t) -2;

<span class="enscript-comment">/*
 *	Resident page structures are also chained on
 *	queues that are used by the page replacement
 *	system (pageout daemon).  These queues are
 *	defined here, but are shared by the pageout
 *	module.  The inactive queue is broken into 
 *	file backed and anonymous for convenience as the 
 *	pageout daemon often assignes a higher 
 *	importance to anonymous pages (less likely to pick)
 */</span>
queue_head_t	vm_page_queue_active;
queue_head_t	vm_page_queue_inactive;
queue_head_t	vm_page_queue_anonymous;	<span class="enscript-comment">/* inactive memory queue for anonymous pages */</span>
queue_head_t	vm_page_queue_throttled;

queue_head_t	vm_objects_wired;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_active_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_inactive_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_anonymous_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_throttled_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_speculative_count;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_wire_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_stolen_count;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_wire_count_initial;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_pages_initial;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_gobble_count = 0;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_PAGE_WIRE_COUNT_WARNING</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_GOBBLE_COUNT_WARNING</span>	0

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_purgeable_count = 0; <span class="enscript-comment">/* # of pages purgeable now */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_purgeable_wired_count = 0; <span class="enscript-comment">/* # of purgeable pages that are wired now */</span>
uint64_t	vm_page_purged_count = 0;    <span class="enscript-comment">/* total count of purged pages */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_xpmapped_external_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_external_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_internal_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_pageable_external_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_pageable_internal_count = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_speculative_recreated = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_speculative_created = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_speculative_used = 0;
#<span class="enscript-reference">endif</span>

queue_head_t    vm_page_queue_cleaned;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_cleaned_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_pageout_enqueued_cleaned = 0;

uint64_t	max_valid_dma_address = 0xffffffffffffffffULL;
ppnum_t		max_valid_low_ppnum = 0xffffffff;


<span class="enscript-comment">/*
 *	Several page replacement parameters are also
 *	shared with this module, so that page allocation
 *	(done here in vm_page_alloc) can trigger the
 *	pageout daemon.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_target = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_min = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_throttle_limit = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_inactive_target = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_anonymous_min = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_inactive_min = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_reserved = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_throttle_count = 0;


<span class="enscript-comment">/*
 *	The VM system has a couple of heuristics for deciding
 *	that pages are &quot;uninteresting&quot; and should be placed
 *	on the inactive queue as likely candidates for replacement.
 *	These variables let the heuristics be controlled at run-time
 *	to make experimentation easier.
 */</span>

boolean_t vm_page_deactivate_hint = TRUE;

<span class="enscript-type">struct</span> vm_page_stats_reusable vm_page_stats_reusable;
	
<span class="enscript-comment">/*
 *	vm_set_page_size:
 *
 *	Sets the page size, perhaps based upon the memory
 *	size.  Must be called before any use of page-size
 *	dependent functions.
 *
 *	Sets page_shift and page_mask from page_size.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_set_page_size</span>(<span class="enscript-type">void</span>)
{
	page_size  = PAGE_SIZE;
	page_mask  = PAGE_MASK;
	page_shift = PAGE_SHIFT;

	<span class="enscript-keyword">if</span> ((page_mask &amp; page_size) != 0)
		panic(<span class="enscript-string">&quot;vm_set_page_size: page size not a power of two&quot;</span>);

	<span class="enscript-keyword">for</span> (page_shift = 0; ; page_shift++)
		<span class="enscript-keyword">if</span> ((1U &lt;&lt; page_shift) == page_size)
			<span class="enscript-keyword">break</span>;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COLOR_GROUPS_TO_STEAL</span>	4


<span class="enscript-comment">/* Called once during statup, once the cache geometry is known.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_set_colors</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	n, override;
	
	<span class="enscript-keyword">if</span> ( PE_parse_boot_argn(<span class="enscript-string">&quot;colors&quot;</span>, &amp;override, <span class="enscript-keyword">sizeof</span> (override)) )		<span class="enscript-comment">/* colors specified as a boot-arg? */</span>
		n = override;	
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( vm_cache_geometry_colors )			<span class="enscript-comment">/* do we know what the cache geometry is? */</span>
		n = vm_cache_geometry_colors;
	<span class="enscript-keyword">else</span>	n = DEFAULT_COLORS;				<span class="enscript-comment">/* use default if all else fails */</span>

	<span class="enscript-keyword">if</span> ( n == 0 )
		n = 1;
	<span class="enscript-keyword">if</span> ( n &gt; MAX_COLORS )
		n = MAX_COLORS;
		
	<span class="enscript-comment">/* the count must be a power of 2  */</span>
	<span class="enscript-keyword">if</span> ( ( n &amp; (n - 1)) != 0  )
		panic(<span class="enscript-string">&quot;vm_page_set_colors&quot;</span>);
	
	vm_colors = n;
	vm_color_mask = n - 1;

	vm_free_magazine_refill_limit = vm_colors * COLOR_GROUPS_TO_STEAL;
}


lck_grp_t		vm_page_lck_grp_free;
lck_grp_t		vm_page_lck_grp_queue;
lck_grp_t		vm_page_lck_grp_local;
lck_grp_t		vm_page_lck_grp_purge;
lck_grp_t		vm_page_lck_grp_alloc;
lck_grp_t		vm_page_lck_grp_bucket;
lck_grp_attr_t		vm_page_lck_grp_attr;
lck_attr_t		vm_page_lck_attr;


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_init_lck_grp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * initialze the vm_page lock world
	 */</span>
	lck_grp_attr_setdefault(&amp;vm_page_lck_grp_attr);
	lck_grp_init(&amp;vm_page_lck_grp_free, <span class="enscript-string">&quot;vm_page_free&quot;</span>, &amp;vm_page_lck_grp_attr);
	lck_grp_init(&amp;vm_page_lck_grp_queue, <span class="enscript-string">&quot;vm_page_queue&quot;</span>, &amp;vm_page_lck_grp_attr);
	lck_grp_init(&amp;vm_page_lck_grp_local, <span class="enscript-string">&quot;vm_page_queue_local&quot;</span>, &amp;vm_page_lck_grp_attr);
	lck_grp_init(&amp;vm_page_lck_grp_purge, <span class="enscript-string">&quot;vm_page_purge&quot;</span>, &amp;vm_page_lck_grp_attr);
	lck_grp_init(&amp;vm_page_lck_grp_alloc, <span class="enscript-string">&quot;vm_page_alloc&quot;</span>, &amp;vm_page_lck_grp_attr);
	lck_grp_init(&amp;vm_page_lck_grp_bucket, <span class="enscript-string">&quot;vm_page_bucket&quot;</span>, &amp;vm_page_lck_grp_attr);
	lck_attr_setdefault(&amp;vm_page_lck_attr);
	lck_mtx_init_ext(&amp;vm_page_alloc_lock, &amp;vm_page_alloc_lock_ext, &amp;vm_page_lck_grp_alloc, &amp;vm_page_lck_attr);

	vm_compressor_init_locks();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_init_local_q</span>()
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		num_cpus;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		i;
	<span class="enscript-type">struct</span> vplq     	*t_local_q;

	num_cpus = ml_get_max_cpus();

	<span class="enscript-comment">/*
	 * no point in this for a uni-processor system
	 */</span>
	<span class="enscript-keyword">if</span> (num_cpus &gt;= 2) {
		t_local_q = (<span class="enscript-type">struct</span> vplq *)kalloc(num_cpus * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vplq));

		<span class="enscript-keyword">for</span> (i = 0; i &lt; num_cpus; i++) {
			<span class="enscript-type">struct</span> vpl	*lq;

			lq = &amp;t_local_q[i].vpl_un.vpl;
			VPL_LOCK_INIT(lq, &amp;vm_page_lck_grp_local, &amp;vm_page_lck_attr);
			queue_init(&amp;lq-&gt;vpl_queue);
			lq-&gt;vpl_count = 0;
			lq-&gt;vpl_internal_count = 0;
			lq-&gt;vpl_external_count = 0;
		}
		vm_page_local_q_count = num_cpus;

		vm_page_local_q = (<span class="enscript-type">struct</span> vplq *)t_local_q;
	}
}


<span class="enscript-comment">/*
 *	vm_page_bootstrap:
 *
 *	Initializes the resident memory module.
 *
 *	Allocates memory for the page cells, and
 *	for the object/offset-to-page hash table headers.
 *	Each page cell is initialized and placed on the free list.
 *	Returns the range of available kernel virtual memory.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_bootstrap</span>(
	vm_offset_t		*startp,
	vm_offset_t		*endp)
{
	<span class="enscript-type">register</span> vm_page_t	m;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		log1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		log2;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size;

	<span class="enscript-comment">/*
	 *	Initialize the vm_page template.
	 */</span>

	m = &amp;vm_page_template;
	bzero(m, <span class="enscript-keyword">sizeof</span> (*m));

	m-&gt;pageq.next = NULL;
	m-&gt;pageq.prev = NULL;
	m-&gt;listq.next = NULL;
	m-&gt;listq.prev = NULL;
	m-&gt;next_m = VM_PAGE_PACK_PTR(VM_PAGE_NULL);

	m-&gt;object = VM_OBJECT_NULL;		<span class="enscript-comment">/* reset later */</span>
	m-&gt;offset = (vm_object_offset_t) -1;	<span class="enscript-comment">/* reset later */</span>

	m-&gt;wire_count = 0;
	m-&gt;local = FALSE;
	m-&gt;inactive = FALSE;
	m-&gt;active = FALSE;
	m-&gt;pageout_queue = FALSE;
	m-&gt;speculative = FALSE;
	m-&gt;laundry = FALSE;
	m-&gt;free = FALSE;
	m-&gt;reference = FALSE;
	m-&gt;gobbled = FALSE;
	m-&gt;private = FALSE;
	m-&gt;throttled = FALSE;
	m-&gt;__unused_pageq_bits = 0;

	m-&gt;phys_page = 0;		<span class="enscript-comment">/* reset later */</span>

	m-&gt;busy = TRUE;
	m-&gt;wanted = FALSE;
	m-&gt;tabled = FALSE;
	m-&gt;hashed = FALSE;
	m-&gt;fictitious = FALSE;
	m-&gt;pmapped = FALSE;
	m-&gt;wpmapped = FALSE;
	m-&gt;pageout = FALSE;
	m-&gt;absent = FALSE;
	m-&gt;error = FALSE;
	m-&gt;dirty = FALSE;
	m-&gt;cleaning = FALSE;
	m-&gt;precious = FALSE;
	m-&gt;clustered = FALSE;
	m-&gt;overwriting = FALSE;
	m-&gt;restart = FALSE;
	m-&gt;unusual = FALSE;
	m-&gt;encrypted = FALSE;
	m-&gt;encrypted_cleaning = FALSE;
	m-&gt;cs_validated = FALSE;
	m-&gt;cs_tainted = FALSE;
	m-&gt;cs_nx = FALSE;
	m-&gt;no_cache = FALSE;
	m-&gt;reusable = FALSE;
	m-&gt;slid = FALSE;
	m-&gt;xpmapped = FALSE;
	m-&gt;compressor = FALSE;
	m-&gt;written_by_kernel = FALSE;
	m-&gt;__unused_object_bits = 0;

	<span class="enscript-comment">/*
	 *	Initialize the page queues.
	 */</span>
	vm_page_init_lck_grp();
	
	lck_mtx_init_ext(&amp;vm_page_queue_free_lock, &amp;vm_page_queue_free_lock_ext, &amp;vm_page_lck_grp_free, &amp;vm_page_lck_attr);
	lck_mtx_init_ext(&amp;vm_page_queue_lock, &amp;vm_page_queue_lock_ext, &amp;vm_page_lck_grp_queue, &amp;vm_page_lck_attr);
	lck_mtx_init_ext(&amp;vm_purgeable_queue_lock, &amp;vm_purgeable_queue_lock_ext, &amp;vm_page_lck_grp_purge, &amp;vm_page_lck_attr);
    
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PURGEABLE_Q_TYPE_MAX; i++) {
		<span class="enscript-type">int</span> group;

		purgeable_queues[i].token_q_head = 0;
		purgeable_queues[i].token_q_tail = 0;
		<span class="enscript-keyword">for</span> (group = 0; group &lt; NUM_VOLATILE_GROUPS; group++)
		        queue_init(&amp;purgeable_queues[i].objq[group]);

		purgeable_queues[i].type = i;
		purgeable_queues[i].new_pages = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
		purgeable_queues[i].debug_count_tokens = 0;
		purgeable_queues[i].debug_count_objects = 0;
#<span class="enscript-reference">endif</span>
	};
	purgeable_nonvolatile_count = 0;
	queue_init(&amp;purgeable_nonvolatile_queue);
    
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_COLORS; i++ )
		queue_init(&amp;vm_page_queue_free[i]);

	queue_init(&amp;vm_lopage_queue_free);
	queue_init(&amp;vm_page_queue_active);
	queue_init(&amp;vm_page_queue_inactive);
	queue_init(&amp;vm_page_queue_cleaned);
	queue_init(&amp;vm_page_queue_throttled);
	queue_init(&amp;vm_page_queue_anonymous);
	queue_init(&amp;vm_objects_wired);

	<span class="enscript-keyword">for</span> ( i = 0; i &lt;= VM_PAGE_MAX_SPECULATIVE_AGE_Q; i++ ) {
	        queue_init(&amp;vm_page_queue_speculative[i].age_q);

		vm_page_queue_speculative[i].age_ts.tv_sec = 0;
		vm_page_queue_speculative[i].age_ts.tv_nsec = 0;
	}
	vm_page_free_wanted = 0;
	vm_page_free_wanted_privileged = 0;
	
	vm_page_set_colors();


	<span class="enscript-comment">/*
	 *	Steal memory for the map and zone subsystems.
	 */</span>
	kernel_debug_string_simple(<span class="enscript-string">&quot;zone_steal_memory&quot;</span>);
	zone_steal_memory();
	kernel_debug_string_simple(<span class="enscript-string">&quot;vm_map_steal_memory&quot;</span>);
	vm_map_steal_memory();

	<span class="enscript-comment">/*
	 *	Allocate (and initialize) the virtual-to-physical
	 *	table hash buckets.
	 *
	 *	The number of buckets should be a power of two to
	 *	get a good hash function.  The following computation
	 *	chooses the first power of two that is greater
	 *	than the number of physical pages in the system.
	 */</span>

	<span class="enscript-keyword">if</span> (vm_page_bucket_count == 0) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> npages = pmap_free_pages();

		vm_page_bucket_count = 1;
		<span class="enscript-keyword">while</span> (vm_page_bucket_count &lt; npages)
			vm_page_bucket_count &lt;&lt;= 1;
	}
	vm_page_bucket_lock_count = (vm_page_bucket_count + BUCKETS_PER_LOCK - 1) / BUCKETS_PER_LOCK;

	vm_page_hash_mask = vm_page_bucket_count - 1;

	<span class="enscript-comment">/*
	 *	Calculate object shift value for hashing algorithm:
	 *		O = log2(sizeof(struct vm_object))
	 *		B = log2(vm_page_bucket_count)
	 *	        hash shifts the object left by
	 *		B/2 - O
	 */</span>
	size = vm_page_bucket_count;
	<span class="enscript-keyword">for</span> (log1 = 0; size &gt; 1; log1++) 
		size /= 2;
	size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vm_object);
	<span class="enscript-keyword">for</span> (log2 = 0; size &gt; 1; log2++) 
		size /= 2;
	vm_page_hash_shift = log1/2 - log2 + 1;
	
	vm_page_bucket_hash = 1 &lt;&lt; ((log1 + 1) &gt;&gt; 1);		<span class="enscript-comment">/* Get (ceiling of sqrt of table size) */</span>
	vm_page_bucket_hash |= 1 &lt;&lt; ((log1 + 1) &gt;&gt; 2);		<span class="enscript-comment">/* Get (ceiling of quadroot of table size) */</span>
	vm_page_bucket_hash |= 1;							<span class="enscript-comment">/* Set bit and add 1 - always must be 1 to insure unique series */</span>

	<span class="enscript-keyword">if</span> (vm_page_hash_mask &amp; vm_page_bucket_count)
		printf(<span class="enscript-string">&quot;vm_page_bootstrap: WARNING -- strange page hash\n&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_BUCKETS_CHECK</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_FAKE_BUCKETS</span>
	<span class="enscript-comment">/*
	 * Allocate a decoy set of page buckets, to detect
	 * any stomping there.
	 */</span>
	vm_page_fake_buckets = (vm_page_bucket_t *)
		pmap_steal_memory(vm_page_bucket_count *
				  <span class="enscript-keyword">sizeof</span>(vm_page_bucket_t));
	vm_page_fake_buckets_start = (vm_map_offset_t) vm_page_fake_buckets;
	vm_page_fake_buckets_end =
		vm_map_round_page((vm_page_fake_buckets_start +
				   (vm_page_bucket_count *
				    <span class="enscript-keyword">sizeof</span> (vm_page_bucket_t))),
				  PAGE_MASK);
	<span class="enscript-type">char</span> *cp;
	<span class="enscript-keyword">for</span> (cp = (<span class="enscript-type">char</span> *)vm_page_fake_buckets_start;
	     cp &lt; (<span class="enscript-type">char</span> *)vm_page_fake_buckets_end;
	     cp++) {
		*cp = 0x5a;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_FAKE_BUCKETS */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_BUCKETS_CHECK */</span>

	kernel_debug_string_simple(<span class="enscript-string">&quot;vm_page_buckets&quot;</span>);
	vm_page_buckets = (vm_page_bucket_t *)
		pmap_steal_memory(vm_page_bucket_count *
				  <span class="enscript-keyword">sizeof</span>(vm_page_bucket_t));

	kernel_debug_string_simple(<span class="enscript-string">&quot;vm_page_bucket_locks&quot;</span>);
	vm_page_bucket_locks = (lck_spin_t *)
		pmap_steal_memory(vm_page_bucket_lock_count *
				  <span class="enscript-keyword">sizeof</span>(lck_spin_t));

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_bucket_count; i++) {
		<span class="enscript-type">register</span> vm_page_bucket_t *bucket = &amp;vm_page_buckets[i];

		bucket-&gt;page_list = VM_PAGE_PACK_PTR(VM_PAGE_NULL);
#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_PAGE_HASH_STATS</span>
		bucket-&gt;cur_count = 0;
		bucket-&gt;hi_count = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGE_HASH_STATS */</span>
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_bucket_lock_count; i++)
	        lck_spin_init(&amp;vm_page_bucket_locks[i], &amp;vm_page_lck_grp_bucket, &amp;vm_page_lck_attr);

	lck_spin_init(&amp;vm_objects_wired_lock, &amp;vm_page_lck_grp_bucket, &amp;vm_page_lck_attr);
	lck_spin_init(&amp;vm_allocation_sites_lock, &amp;vm_page_lck_grp_bucket, &amp;vm_page_lck_attr);
	vm_tag_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_BUCKETS_CHECK</span>
	vm_page_buckets_check_ready = TRUE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_BUCKETS_CHECK */</span>

	<span class="enscript-comment">/*
	 *	Machine-dependent code allocates the resident page table.
	 *	It uses vm_page_init to initialize the page frames.
	 *	The code also returns to us the virtual space available
	 *	to the kernel.  We don't trust the pmap module
	 *	to get the alignment right.
	 */</span>

	kernel_debug_string_simple(<span class="enscript-string">&quot;pmap_startup&quot;</span>);
	pmap_startup(&amp;virtual_space_start, &amp;virtual_space_end);
	virtual_space_start = round_page(virtual_space_start);
	virtual_space_end = trunc_page(virtual_space_end);

	*startp = virtual_space_start;
	*endp = virtual_space_end;

	<span class="enscript-comment">/*
	 *	Compute the initial &quot;wire&quot; count.
	 *	Up until now, the pages which have been set aside are not under 
	 *	the VM system's control, so although they aren't explicitly
	 *	wired, they nonetheless can't be moved. At this moment,
	 *	all VM managed pages are &quot;free&quot;, courtesy of pmap_startup.
	 */</span>
	assert((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) atop_64(max_mem) == atop_64(max_mem));
	vm_page_wire_count = ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) atop_64(max_mem)) - vm_page_free_count - vm_lopage_free_count;	<span class="enscript-comment">/* initial value */</span>
	vm_page_wire_count_initial = vm_page_wire_count;
	vm_page_pages_initial = vm_page_pages;

	printf(<span class="enscript-string">&quot;vm_page_bootstrap: %d free pages and %d wired pages\n&quot;</span>,
	       vm_page_free_count, vm_page_wire_count);

	kernel_debug_string_simple(<span class="enscript-string">&quot;vm_page_bootstrap complete&quot;</span>);
	simple_lock_init(&amp;vm_paging_lock, 0);
}

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">MACHINE_PAGES</span>
<span class="enscript-comment">/*
 *	We implement pmap_steal_memory and pmap_startup with the help
 *	of two simpler functions, pmap_virtual_space and pmap_next_page.
 */</span>

<span class="enscript-type">void</span> *
<span class="enscript-function-name">pmap_steal_memory</span>(
	vm_size_t size)
{
	vm_offset_t addr, vaddr;
	ppnum_t	phys_page;

	<span class="enscript-comment">/*
	 *	We round the size to a round multiple.
	 */</span>

	size = (size + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) - 1) &amp;~ (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) - 1);

	<span class="enscript-comment">/*
	 *	If this is the first call to pmap_steal_memory,
	 *	we have to initialize ourself.
	 */</span>

	<span class="enscript-keyword">if</span> (virtual_space_start == virtual_space_end) {
		pmap_virtual_space(&amp;virtual_space_start, &amp;virtual_space_end);

		<span class="enscript-comment">/*
		 *	The initial values must be aligned properly, and
		 *	we don't trust the pmap module to do it right.
		 */</span>

		virtual_space_start = round_page(virtual_space_start);
		virtual_space_end = trunc_page(virtual_space_end);
	}

	<span class="enscript-comment">/*
	 *	Allocate virtual memory for this request.
	 */</span>

	addr = virtual_space_start;
	virtual_space_start += size;

	<span class="enscript-comment">//kprintf(&quot;pmap_steal_memory: %08lX - %08lX; size=%08lX\n&quot;, (long)addr, (long)virtual_space_start, (long)size);	/* (TEST/DEBUG) */
</span>
	<span class="enscript-comment">/*
	 *	Allocate and map physical pages to back new virtual pages.
	 */</span>

	<span class="enscript-keyword">for</span> (vaddr = round_page(addr);
	     vaddr &lt; addr + size;
	     vaddr += PAGE_SIZE) {

		<span class="enscript-keyword">if</span> (!pmap_next_page_hi(&amp;phys_page))
			panic(<span class="enscript-string">&quot;pmap_steal_memory&quot;</span>);

		<span class="enscript-comment">/*
		 *	XXX Logically, these mappings should be wired,
		 *	but some pmap modules barf if they are.
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
		pmap_pre_expand(kernel_pmap, vaddr);
#<span class="enscript-reference">endif</span>

		pmap_enter(kernel_pmap, vaddr, phys_page,
			   VM_PROT_READ|VM_PROT_WRITE, VM_PROT_NONE,
				VM_WIMG_USE_DEFAULT, FALSE);
		<span class="enscript-comment">/*
		 * Account for newly stolen memory
		 */</span>
		vm_page_wire_count++;
		vm_page_stolen_count++;
	}

	<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) addr;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_release_startup</span>(vm_page_t mem);
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_startup</span>(
	vm_offset_t *startp,
	vm_offset_t *endp)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, npages, pages_initialized, fill, fillval;
	ppnum_t		phys_page;
	addr64_t	tmpaddr;


#<span class="enscript-reference">if</span>    <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-comment">/*
	 * struct vm_page must be of size 64 due to VM_PAGE_PACK_PTR use
	 */</span>
	assert(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vm_page) == 64);

	<span class="enscript-comment">/*
	 * make sure we are aligned on a 64 byte boundary
	 * for VM_PAGE_PACK_PTR (it clips off the low-order
	 * 6 bits of the pointer)
	 */</span>
	<span class="enscript-keyword">if</span> (virtual_space_start != virtual_space_end)
		virtual_space_start = round_page(virtual_space_start);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 *	We calculate how many page frames we will have
	 *	and then allocate the page structures in one chunk.
	 */</span>

	tmpaddr = (addr64_t)pmap_free_pages() * (addr64_t)PAGE_SIZE;	<span class="enscript-comment">/* Get the amount of memory left */</span>
	tmpaddr = tmpaddr + (addr64_t)(round_page(virtual_space_start) - virtual_space_start);	<span class="enscript-comment">/* Account for any slop */</span>
	npages = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(tmpaddr / (addr64_t)(PAGE_SIZE + <span class="enscript-keyword">sizeof</span>(*vm_pages)));	<span class="enscript-comment">/* Figure size of all vm_page_ts, including enough to hold the vm_page_ts */</span>

	vm_pages = (vm_page_t) pmap_steal_memory(npages * <span class="enscript-keyword">sizeof</span> *vm_pages);

	<span class="enscript-comment">/*
	 *	Initialize the page frames.
	 */</span>
	kernel_debug_string_simple(<span class="enscript-string">&quot;Initialize the page frames&quot;</span>);
	<span class="enscript-keyword">for</span> (i = 0, pages_initialized = 0; i &lt; npages; i++) {
		<span class="enscript-keyword">if</span> (!pmap_next_page(&amp;phys_page))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (pages_initialized == 0 || phys_page &lt; vm_page_lowest)
			vm_page_lowest = phys_page;

		vm_page_init(&amp;vm_pages[i], phys_page, FALSE);
		vm_page_pages++;
		pages_initialized++;
	}
	vm_pages_count = pages_initialized;

#<span class="enscript-reference">if</span>    <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)

	<span class="enscript-keyword">if</span> (VM_PAGE_UNPACK_PTR(VM_PAGE_PACK_PTR(&amp;vm_pages[0])) != &amp;vm_pages[0])
		panic(<span class="enscript-string">&quot;VM_PAGE_PACK_PTR failed on &amp;vm_pages[0] - %p&quot;</span>, (<span class="enscript-type">void</span> *)&amp;vm_pages[0]);

	<span class="enscript-keyword">if</span> (VM_PAGE_UNPACK_PTR(VM_PAGE_PACK_PTR(&amp;vm_pages[vm_pages_count-1])) != &amp;vm_pages[vm_pages_count-1])
		panic(<span class="enscript-string">&quot;VM_PAGE_PACK_PTR failed on &amp;vm_pages[vm_pages_count-1] - %p&quot;</span>, (<span class="enscript-type">void</span> *)&amp;vm_pages[vm_pages_count-1]);
#<span class="enscript-reference">endif</span>
	kernel_debug_string_simple(<span class="enscript-string">&quot;page fill/release&quot;</span>);
	<span class="enscript-comment">/*
	 * Check if we want to initialize pages to a known value
	 */</span>
	fill = 0;								<span class="enscript-comment">/* Assume no fill */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;fill&quot;</span>, &amp;fillval, <span class="enscript-keyword">sizeof</span> (fillval))) fill = 1;			<span class="enscript-comment">/* Set fill */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/* This slows down booting the DEBUG kernel, particularly on
	 * large memory systems, but is worthwhile in deterministically
	 * trapping uninitialized memory usage.
	 */</span>
	<span class="enscript-keyword">if</span> (fill == 0) {
		fill = 1;
		fillval = 0xDEB8F177;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (fill)
		kprintf(<span class="enscript-string">&quot;Filling vm_pages with pattern: 0x%x\n&quot;</span>, fillval);
	<span class="enscript-comment">// -debug code remove
</span>	<span class="enscript-keyword">if</span> (2 == vm_himemory_mode) {
		<span class="enscript-comment">// free low -&gt; high so high is preferred
</span>		<span class="enscript-keyword">for</span> (i = 1; i &lt;= pages_initialized; i++) {
			<span class="enscript-keyword">if</span>(fill) fillPage(vm_pages[i - 1].phys_page, fillval);		<span class="enscript-comment">/* Fill the page with a know value if requested at boot */</span>			
			vm_page_release_startup(&amp;vm_pages[i - 1]);
		}
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-comment">// debug code remove-
</span>
	<span class="enscript-comment">/*
	 * Release pages in reverse order so that physical pages
	 * initially get allocated in ascending addresses. This keeps
	 * the devices (which must address physical memory) happy if
	 * they require several consecutive pages.
	 */</span>
	<span class="enscript-keyword">for</span> (i = pages_initialized; i &gt; 0; i--) {
		<span class="enscript-keyword">if</span>(fill) fillPage(vm_pages[i - 1].phys_page, fillval);		<span class="enscript-comment">/* Fill the page with a know value if requested at boot */</span>			
		vm_page_release_startup(&amp;vm_pages[i - 1]);
	}

	VM_CHECK_MEMORYSTATUS;
	
#<span class="enscript-reference">if</span> 0
	{
		vm_page_t xx, xxo, xxl;
		<span class="enscript-type">int</span> i, j, k, l;
	
		j = 0;													<span class="enscript-comment">/* (BRINGUP) */</span>
		xxl = 0;
		
		<span class="enscript-keyword">for</span>( i = 0; i &lt; vm_colors; i++ ) {
			queue_iterate(&amp;vm_page_queue_free[i],
				      xx,
				      vm_page_t,
				      pageq) {	<span class="enscript-comment">/* BRINGUP */</span>
				j++;												<span class="enscript-comment">/* (BRINGUP) */</span>
				<span class="enscript-keyword">if</span>(j &gt; vm_page_free_count) {						<span class="enscript-comment">/* (BRINGUP) */</span>
					panic(<span class="enscript-string">&quot;pmap_startup: too many pages, xx = %08X, xxl = %08X\n&quot;</span>, xx, xxl);
				}
				
				l = vm_page_free_count - j;							<span class="enscript-comment">/* (BRINGUP) */</span>
				k = 0;												<span class="enscript-comment">/* (BRINGUP) */</span>
				
				<span class="enscript-keyword">if</span>(((j - 1) &amp; 0xFFFF) == 0) kprintf(<span class="enscript-string">&quot;checking number %d of %d\n&quot;</span>, j, vm_page_free_count);

				<span class="enscript-keyword">for</span>(xxo = xx-&gt;pageq.next; xxo != &amp;vm_page_queue_free[i]; xxo = xxo-&gt;pageq.next) {	<span class="enscript-comment">/* (BRINGUP) */</span>
					k++;
					<span class="enscript-keyword">if</span>(k &gt; l) panic(<span class="enscript-string">&quot;pmap_startup: too many in secondary check %d %d\n&quot;</span>, k, l);
					<span class="enscript-keyword">if</span>((xx-&gt;phys_page &amp; 0xFFFFFFFF) == (xxo-&gt;phys_page &amp; 0xFFFFFFFF)) {	<span class="enscript-comment">/* (BRINGUP) */</span>
						panic(<span class="enscript-string">&quot;pmap_startup: duplicate physaddr, xx = %08X, xxo = %08X\n&quot;</span>, xx, xxo);
					}
				}

				xxl = xx;
			}
		}
		
		<span class="enscript-keyword">if</span>(j != vm_page_free_count) {						<span class="enscript-comment">/* (BRINGUP) */</span>
			panic(<span class="enscript-string">&quot;pmap_startup: vm_page_free_count does not match, calc =  %d, vm_page_free_count = %08X\n&quot;</span>, j, vm_page_free_count);
		}
	}
#<span class="enscript-reference">endif</span>


	<span class="enscript-comment">/*
	 *	We have to re-align virtual_space_start,
	 *	because pmap_steal_memory has been using it.
	 */</span>

	virtual_space_start = round_page(virtual_space_start);

	*startp = virtual_space_start;
	*endp = virtual_space_end;
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACHINE_PAGES */</span>

<span class="enscript-comment">/*
 *	Routine:	vm_page_module_init
 *	Purpose:
 *		Second initialization pass, to be done after
 *		the basic VM system is ready.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_module_init</span>(<span class="enscript-type">void</span>)
{
	uint64_t vm_page_zone_pages, vm_page_zone_data_size;
	vm_page_zone = zinit((vm_size_t) <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vm_page),
			     0, PAGE_SIZE, <span class="enscript-string">&quot;vm pages&quot;</span>);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>
	zone_debug_disable(vm_page_zone);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ZONE_DEBUG */</span>

	zone_change(vm_page_zone, Z_CALLERACCT, FALSE);
	zone_change(vm_page_zone, Z_EXPAND, FALSE);
	zone_change(vm_page_zone, Z_EXHAUST, TRUE);
	zone_change(vm_page_zone, Z_FOREIGN, TRUE);
	zone_change(vm_page_zone, Z_GZALLOC_EXEMPT, TRUE);
	<span class="enscript-comment">/*
	 * Adjust zone statistics to account for the real pages allocated
	 * in vm_page_create(). [Q: is this really what we want?]
	 */</span>
	vm_page_zone-&gt;count += vm_page_pages;
	vm_page_zone-&gt;sum_count += vm_page_pages;
	vm_page_zone_data_size = vm_page_pages * vm_page_zone-&gt;elem_size;
	vm_page_zone-&gt;cur_size += vm_page_zone_data_size;
	vm_page_zone_pages = ((round_page(vm_page_zone_data_size)) / PAGE_SIZE);
	OSAddAtomic64(vm_page_zone_pages, &amp;(vm_page_zone-&gt;page_count));
	<span class="enscript-comment">/* since zone accounts for these, take them out of stolen */</span>
	VM_PAGE_MOVE_STOLEN(vm_page_zone_pages);
}

<span class="enscript-comment">/*
 *	Routine:	vm_page_create
 *	Purpose:
 *		After the VM system is up, machine-dependent code
 *		may stumble across more physical memory.  For example,
 *		memory that it was reserving for a frame buffer.
 *		vm_page_create turns this memory into available pages.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_create</span>(
	ppnum_t start,
	ppnum_t end)
{
	ppnum_t		phys_page;
	vm_page_t 	m;

	<span class="enscript-keyword">for</span> (phys_page = start;
	     phys_page &lt; end;
	     phys_page++) {
		<span class="enscript-keyword">while</span> ((m = (vm_page_t) vm_page_grab_fictitious_common(phys_page))
			== VM_PAGE_NULL)
			vm_page_more_fictitious();

		m-&gt;fictitious = FALSE;
		pmap_clear_noencrypt(phys_page);

		vm_page_pages++;
		vm_page_release(m);
	}
}

<span class="enscript-comment">/*
 *	vm_page_hash:
 *
 *	Distributes the object/offset key pair among hash buckets.
 *
 *	NOTE:	The bucket count must be a power of 2
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_page_hash</span>(object, offset) (\
	( (natural_t)((uintptr_t)object * vm_page_bucket_hash) + ((uint32_t)atop_64(offset) ^ vm_page_bucket_hash))\
	 &amp; vm_page_hash_mask)


<span class="enscript-comment">/*
 *	vm_page_insert:		[ internal use only ]
 *
 *	Inserts the given mem entry into the object/object-page
 *	table and object list.
 *
 *	The object must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_insert</span>(
	vm_page_t		mem,
	vm_object_t		object,
	vm_object_offset_t	offset)
{
	vm_page_insert_internal(mem, object, offset, VM_KERN_MEMORY_NONE, FALSE, TRUE, FALSE, FALSE, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_insert_wired</span>(
	vm_page_t		mem,
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_tag_t                tag)
{
	vm_page_insert_internal(mem, object, offset, tag, FALSE, TRUE, FALSE, FALSE, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_insert_internal</span>(
	vm_page_t		mem,
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_tag_t                tag,
	boolean_t		queues_lock_held,
	boolean_t		insert_in_hash,
	boolean_t		batch_pmap_op,
        boolean_t               batch_accounting,
	uint64_t		*delayed_ledger_update)
{
	vm_page_bucket_t	*bucket;
	lck_spin_t		*bucket_lock;
	<span class="enscript-type">int</span>			hash_id;
	task_t			owner;

        XPR(XPR_VM_PAGE,
                <span class="enscript-string">&quot;vm_page_insert, object 0x%X offset 0x%X page 0x%X\n&quot;</span>,
                object, offset, mem, 0,0);
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we may not hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(mem);
#<span class="enscript-reference">endif</span>

	assert(page_aligned(offset));

	assert(!VM_PAGE_WIRED(mem) || mem-&gt;private || mem-&gt;fictitious || (tag != VM_KERN_MEMORY_NONE));

	<span class="enscript-comment">/* the vm_submap_object is only a placeholder for submaps */</span>
	assert(object != vm_submap_object);

	vm_object_lock_assert_exclusive(object);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock,
		       queues_lock_held ? LCK_MTX_ASSERT_OWNED
		       			: LCK_MTX_ASSERT_NOTOWNED);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">if</span> (insert_in_hash == TRUE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">VM_PAGE_CHECK_BUCKETS</span>
		<span class="enscript-keyword">if</span> (mem-&gt;tabled || mem-&gt;object != VM_OBJECT_NULL)
			panic(<span class="enscript-string">&quot;vm_page_insert: page %p for (obj=%p,off=0x%llx) &quot;</span>
			      <span class="enscript-string">&quot;already in (obj=%p,off=0x%llx)&quot;</span>,
			      mem, object, offset, mem-&gt;object, mem-&gt;offset);
#<span class="enscript-reference">endif</span>
		assert(!object-&gt;internal || offset &lt; object-&gt;vo_size);

		<span class="enscript-comment">/* only insert &quot;pageout&quot; pages into &quot;pageout&quot; objects,
		 * and normal pages into normal objects */</span>
#<span class="enscript-reference">if</span> 00
		<span class="enscript-comment">/*
		 * For some reason, this assertion gets tripped
		 * but it's mostly harmless, so let's disable it
		 * for now.
		 */</span>
		assert(object-&gt;pageout == mem-&gt;pageout);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 00 */</span>

		assert(vm_page_lookup(object, offset) == VM_PAGE_NULL);
		
		<span class="enscript-comment">/*
		 *	Record the object/offset pair in this page
		 */</span>

		mem-&gt;object = object;
		mem-&gt;offset = offset;

		<span class="enscript-comment">/*
		 *	Insert it into the object_object/offset hash table
		 */</span>
		hash_id = vm_page_hash(object, offset);
		bucket = &amp;vm_page_buckets[hash_id];
		bucket_lock = &amp;vm_page_bucket_locks[hash_id / BUCKETS_PER_LOCK];
	
		lck_spin_lock(bucket_lock);

		mem-&gt;next_m = bucket-&gt;page_list;
		bucket-&gt;page_list = VM_PAGE_PACK_PTR(mem);
		assert(mem == VM_PAGE_UNPACK_PTR(bucket-&gt;page_list));

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_PAGE_HASH_STATS</span>
		<span class="enscript-keyword">if</span> (++bucket-&gt;cur_count &gt; bucket-&gt;hi_count)
			bucket-&gt;hi_count = bucket-&gt;cur_count;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGE_HASH_STATS */</span>
		mem-&gt;hashed = TRUE;
		lck_spin_unlock(bucket_lock);
	}

	{	
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    cache_attr;

		cache_attr = object-&gt;wimg_bits &amp; VM_WIMG_MASK;

		<span class="enscript-keyword">if</span> (cache_attr != VM_WIMG_USE_DEFAULT) {
			PMAP_SET_CACHE_ATTR(mem, object, cache_attr, batch_pmap_op);
		}
	}
	<span class="enscript-comment">/*
	 *	Now link into the object's list of backed pages.
	 */</span>
	queue_enter(&amp;object-&gt;memq, mem, vm_page_t, listq);
	object-&gt;memq_hint = mem;
	mem-&gt;tabled = TRUE;

	<span class="enscript-comment">/*
	 *	Show that the object has one more resident page.
	 */</span>

	object-&gt;resident_page_count++;
	<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(mem)) {
	    <span class="enscript-keyword">if</span> (!mem-&gt;private &amp;&amp; !mem-&gt;fictitious) 
	    {
		<span class="enscript-keyword">if</span> (!object-&gt;wired_page_count)
		{
		    assert(VM_KERN_MEMORY_NONE != tag);
		    object-&gt;wire_tag = tag;
		    VM_OBJECT_WIRED(object);
		}
	    }
	    object-&gt;wired_page_count++;
	}
	assert(object-&gt;resident_page_count &gt;= object-&gt;wired_page_count);

        <span class="enscript-keyword">if</span> (batch_accounting == FALSE) {
		<span class="enscript-keyword">if</span> (object-&gt;internal) {
			OSAddAtomic(1, &amp;vm_page_internal_count);
		} <span class="enscript-keyword">else</span> {
			OSAddAtomic(1, &amp;vm_page_external_count);
		}
	}

	<span class="enscript-comment">/*
	 * It wouldn't make sense to insert a &quot;reusable&quot; page in
	 * an object (the page would have been marked &quot;reusable&quot; only
	 * at the time of a madvise(MADV_FREE_REUSABLE) if it was already
	 * in the object at that time).
	 * But a page could be inserted in a &quot;all_reusable&quot; object, if
	 * something faults it in (a vm_read() from another task or a
	 * &quot;use-after-free&quot; issue in user space, for example).  It can
	 * also happen if we're relocating a page from that object to
	 * a different physical page during a physically-contiguous
	 * allocation.
	 */</span>
	assert(!mem-&gt;reusable);
	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;all_reusable) {
		OSAddAtomic(+1, &amp;vm_page_stats_reusable.reusable_count);
	}

	<span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_DENY) {
		owner = TASK_NULL;
	} <span class="enscript-keyword">else</span> {
		owner = object-&gt;vo_purgeable_owner;
	}
	<span class="enscript-keyword">if</span> (owner &amp;&amp;
	    (object-&gt;purgable == VM_PURGABLE_NONVOLATILE ||
	     VM_PAGE_WIRED(mem))) {

		<span class="enscript-keyword">if</span> (delayed_ledger_update)
			*delayed_ledger_update += PAGE_SIZE;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* more non-volatile bytes */</span>
			ledger_credit(owner-&gt;ledger,
				      task_ledgers.purgeable_nonvolatile,
				      PAGE_SIZE);
			<span class="enscript-comment">/* more footprint */</span>
			ledger_credit(owner-&gt;ledger,
				      task_ledgers.phys_footprint,
				      PAGE_SIZE);
		}

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (owner &amp;&amp;
		   (object-&gt;purgable == VM_PURGABLE_VOLATILE ||
		    object-&gt;purgable == VM_PURGABLE_EMPTY)) {
		assert(! VM_PAGE_WIRED(mem));
		<span class="enscript-comment">/* more volatile bytes */</span>
		ledger_credit(owner-&gt;ledger,
			      task_ledgers.purgeable_volatile,
			      PAGE_SIZE);
	}

	<span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_VOLATILE) {
		<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(mem)) {
			OSAddAtomic(+1, &amp;vm_page_purgeable_wired_count);
		} <span class="enscript-keyword">else</span> {
			OSAddAtomic(+1, &amp;vm_page_purgeable_count);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object-&gt;purgable == VM_PURGABLE_EMPTY &amp;&amp;
		   mem-&gt;throttled) {
		<span class="enscript-comment">/*
		 * This page belongs to a purged VM object but hasn't
		 * been purged (because it was &quot;busy&quot;).
		 * It's in the &quot;throttled&quot; queue and hence not
		 * visible to vm_pageout_scan().  Move it to a pageable
		 * queue, so that it can eventually be reclaimed, instead
		 * of lingering in the &quot;empty&quot; object.
		 */</span>
		<span class="enscript-keyword">if</span> (queues_lock_held == FALSE)
			vm_page_lockspin_queues();
		vm_page_deactivate(mem);
		<span class="enscript-keyword">if</span> (queues_lock_held == FALSE)
			vm_page_unlock_queues();
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING_OP_MODIFIED</span>
	<span class="enscript-keyword">if</span> (vm_object_tracking_inited &amp;&amp;
	    object-&gt;internal &amp;&amp;
	    object-&gt;resident_page_count == 0 &amp;&amp;
	    object-&gt;pager == NULL &amp;&amp;
	    object-&gt;shadow != NULL &amp;&amp;
	    object-&gt;shadow-&gt;copy == object) {
		<span class="enscript-type">void</span> *bt[VM_OBJECT_TRACKING_BTDEPTH];
		<span class="enscript-type">int</span> numsaved = 0;

		numsaved =OSBacktrace(bt, VM_OBJECT_TRACKING_BTDEPTH);
		btlog_add_entry(vm_object_tracking_btlog,
				object,
				VM_OBJECT_TRACKING_OP_MODIFIED,
				bt,
				numsaved);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJECT_TRACKING_OP_MODIFIED */</span>
}

<span class="enscript-comment">/*
 *	vm_page_replace:
 *
 *	Exactly like vm_page_insert, except that we first
 *	remove any existing page at the given offset in object.
 *
 *	The object must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_replace</span>(
	<span class="enscript-type">register</span> vm_page_t		mem,
	<span class="enscript-type">register</span> vm_object_t		object,
	<span class="enscript-type">register</span> vm_object_offset_t	offset)
{
	vm_page_bucket_t *bucket;
	vm_page_t	 found_m = VM_PAGE_NULL;
	lck_spin_t	*bucket_lock;
	<span class="enscript-type">int</span>		hash_id;

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we don't hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(mem);
#<span class="enscript-reference">endif</span>
	vm_object_lock_assert_exclusive(object);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">VM_PAGE_CHECK_BUCKETS</span>
	<span class="enscript-keyword">if</span> (mem-&gt;tabled || mem-&gt;object != VM_OBJECT_NULL)
		panic(<span class="enscript-string">&quot;vm_page_replace: page %p for (obj=%p,off=0x%llx) &quot;</span>
		      <span class="enscript-string">&quot;already in (obj=%p,off=0x%llx)&quot;</span>,
		      mem, object, offset, mem-&gt;object, mem-&gt;offset);
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_NOTOWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 *	Record the object/offset pair in this page
	 */</span>

	mem-&gt;object = object;
	mem-&gt;offset = offset;

	<span class="enscript-comment">/*
	 *	Insert it into the object_object/offset hash table,
	 *	replacing any page that might have been there.
	 */</span>

	hash_id = vm_page_hash(object, offset);
	bucket = &amp;vm_page_buckets[hash_id];
	bucket_lock = &amp;vm_page_bucket_locks[hash_id / BUCKETS_PER_LOCK];

	lck_spin_lock(bucket_lock);

	<span class="enscript-keyword">if</span> (bucket-&gt;page_list) {
		vm_page_packed_t *mp = &amp;bucket-&gt;page_list;
		vm_page_t m = VM_PAGE_UNPACK_PTR(*mp);

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (m-&gt;object == object &amp;&amp; m-&gt;offset == offset) {
				<span class="enscript-comment">/*
				 * Remove old page from hash list
				 */</span>
				*mp = m-&gt;next_m;
				m-&gt;hashed = FALSE;

				found_m = m;
				<span class="enscript-keyword">break</span>;
			}
			mp = &amp;m-&gt;next_m;
		} <span class="enscript-keyword">while</span> ((m = VM_PAGE_UNPACK_PTR(*mp)));

		mem-&gt;next_m = bucket-&gt;page_list;
	} <span class="enscript-keyword">else</span> {
		mem-&gt;next_m = VM_PAGE_PACK_PTR(VM_PAGE_NULL);
	}
	<span class="enscript-comment">/*
	 * insert new page at head of hash list
	 */</span>
	bucket-&gt;page_list = VM_PAGE_PACK_PTR(mem);
	mem-&gt;hashed = TRUE;

	lck_spin_unlock(bucket_lock);

	<span class="enscript-keyword">if</span> (found_m) {
	        <span class="enscript-comment">/*
		 * there was already a page at the specified
		 * offset for this object... remove it from
		 * the object and free it back to the free list
		 */</span>
		vm_page_free_unlocked(found_m, FALSE);
	}
	vm_page_insert_internal(mem, object, offset, VM_KERN_MEMORY_NONE, FALSE, FALSE, FALSE, FALSE, NULL);
}

<span class="enscript-comment">/*
 *	vm_page_remove:		[ internal use only ]
 *
 *	Removes the given mem entry from the object/offset-page
 *	table and the object page list.
 *
 *	The object must be locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_remove</span>(
	vm_page_t	mem,
	boolean_t	remove_from_hash)
{
	vm_page_bucket_t *bucket;
	vm_page_t	this;
	lck_spin_t	*bucket_lock;
	<span class="enscript-type">int</span>		hash_id;
	task_t		owner;

        XPR(XPR_VM_PAGE,
                <span class="enscript-string">&quot;vm_page_remove, object 0x%X offset 0x%X page 0x%X\n&quot;</span>,
                mem-&gt;object, mem-&gt;offset, 
		mem, 0,0);

	vm_object_lock_assert_exclusive(mem-&gt;object);
	assert(mem-&gt;tabled);
	assert(!mem-&gt;cleaning);
	assert(!mem-&gt;laundry);
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we don't hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(mem);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (remove_from_hash == TRUE) {
		<span class="enscript-comment">/*
		 *	Remove from the object_object/offset hash table
		 */</span>
		hash_id = vm_page_hash(mem-&gt;object, mem-&gt;offset);
		bucket = &amp;vm_page_buckets[hash_id];
		bucket_lock = &amp;vm_page_bucket_locks[hash_id / BUCKETS_PER_LOCK];

		lck_spin_lock(bucket_lock);

		<span class="enscript-keyword">if</span> ((this = VM_PAGE_UNPACK_PTR(bucket-&gt;page_list)) == mem) {
			<span class="enscript-comment">/* optimize for common case */</span>

			bucket-&gt;page_list = mem-&gt;next_m;
		} <span class="enscript-keyword">else</span> {
			vm_page_packed_t	*prev;

			<span class="enscript-keyword">for</span> (prev = &amp;this-&gt;next_m;
			     (this = VM_PAGE_UNPACK_PTR(*prev)) != mem;
			     prev = &amp;this-&gt;next_m)
				<span class="enscript-keyword">continue</span>;
			*prev = this-&gt;next_m;
		}
#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_PAGE_HASH_STATS</span>
		bucket-&gt;cur_count--;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_PAGE_HASH_STATS */</span>
		mem-&gt;hashed = FALSE;
		lck_spin_unlock(bucket_lock);
	}
	<span class="enscript-comment">/*
	 *	Now remove from the object's list of backed pages.
	 */</span>

	vm_page_remove_internal(mem);

	<span class="enscript-comment">/*
	 *	And show that the object has one fewer resident
	 *	page.
	 */</span>

	assert(mem-&gt;object-&gt;resident_page_count &gt; 0);
	mem-&gt;object-&gt;resident_page_count--;

	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		assert(vm_page_internal_count);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

		OSAddAtomic(-1, &amp;vm_page_internal_count);
	} <span class="enscript-keyword">else</span> {
		assert(vm_page_external_count);
		OSAddAtomic(-1, &amp;vm_page_external_count);

		<span class="enscript-keyword">if</span> (mem-&gt;xpmapped) {
			assert(vm_page_xpmapped_external_count);
			OSAddAtomic(-1, &amp;vm_page_xpmapped_external_count);
		}
	}
	<span class="enscript-keyword">if</span> (!mem-&gt;object-&gt;internal &amp;&amp; (mem-&gt;object-&gt;objq.next || mem-&gt;object-&gt;objq.prev)) {
		<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;resident_page_count == 0)
			vm_object_cache_remove(mem-&gt;object);
	}

	<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(mem)) {
		assert(mem-&gt;object-&gt;wired_page_count &gt; 0);
		mem-&gt;object-&gt;wired_page_count--;
		<span class="enscript-keyword">if</span> (!mem-&gt;object-&gt;wired_page_count) {
		    VM_OBJECT_UNWIRED(mem-&gt;object);
		}
	}
	assert(mem-&gt;object-&gt;resident_page_count &gt;=
	       mem-&gt;object-&gt;wired_page_count);
	<span class="enscript-keyword">if</span> (mem-&gt;reusable) {
		assert(mem-&gt;object-&gt;reusable_page_count &gt; 0);
		mem-&gt;object-&gt;reusable_page_count--;
		assert(mem-&gt;object-&gt;reusable_page_count &lt;=
		       mem-&gt;object-&gt;resident_page_count);
		mem-&gt;reusable = FALSE;
		OSAddAtomic(-1, &amp;vm_page_stats_reusable.reusable_count);
		vm_page_stats_reusable.reused_remove++;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;object-&gt;all_reusable) {
		OSAddAtomic(-1, &amp;vm_page_stats_reusable.reusable_count);
		vm_page_stats_reusable.reused_remove++;
	}

	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;purgable == VM_PURGABLE_DENY) {
		owner = TASK_NULL;
	} <span class="enscript-keyword">else</span> {
		owner = mem-&gt;object-&gt;vo_purgeable_owner;
	}
	<span class="enscript-keyword">if</span> (owner &amp;&amp;
	    (mem-&gt;object-&gt;purgable == VM_PURGABLE_NONVOLATILE ||
	     VM_PAGE_WIRED(mem))) {
		<span class="enscript-comment">/* less non-volatile bytes */</span>
		ledger_debit(owner-&gt;ledger,
			     task_ledgers.purgeable_nonvolatile,
			     PAGE_SIZE);
		<span class="enscript-comment">/* less footprint */</span>
		ledger_debit(owner-&gt;ledger,
			     task_ledgers.phys_footprint,
			     PAGE_SIZE);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (owner &amp;&amp;
		   (mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE ||
		    mem-&gt;object-&gt;purgable == VM_PURGABLE_EMPTY)) {
		assert(! VM_PAGE_WIRED(mem));
		<span class="enscript-comment">/* less volatile bytes */</span>
		ledger_debit(owner-&gt;ledger,
			     task_ledgers.purgeable_volatile,
			     PAGE_SIZE);
	}
	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE) {
		<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(mem)) {
			assert(vm_page_purgeable_wired_count &gt; 0);
			OSAddAtomic(-1, &amp;vm_page_purgeable_wired_count);
		} <span class="enscript-keyword">else</span> {
			assert(vm_page_purgeable_count &gt; 0);
			OSAddAtomic(-1, &amp;vm_page_purgeable_count);
		}
	}
	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;set_cache_attr == TRUE)
		pmap_set_cache_attributes(mem-&gt;phys_page, 0);

	mem-&gt;tabled = FALSE;
	mem-&gt;object = VM_OBJECT_NULL;
	mem-&gt;offset = (vm_object_offset_t) -1;
}


<span class="enscript-comment">/*
 *	vm_page_lookup:
 *
 *	Returns the page associated with the object/offset
 *	pair specified; if none is found, VM_PAGE_NULL is returned.
 *
 *	The object must be locked.  No side effects.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_PAGE_HASH_LOOKUP_THRESHOLD</span>	10

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>

<span class="enscript-type">struct</span> {
	uint64_t	vpl_total;
	uint64_t	vpl_empty_obj;
	uint64_t	vpl_bucket_NULL;
	uint64_t	vpl_hit_hint;
	uint64_t	vpl_hit_hint_next;
	uint64_t	vpl_hit_hint_prev;
	uint64_t	vpl_fast;
	uint64_t	vpl_slow;
	uint64_t	vpl_hit;
	uint64_t	vpl_miss;

	uint64_t	vpl_fast_elapsed;
	uint64_t	vpl_slow_elapsed;
} vm_page_lookup_stats __attribute__((aligned(8)));

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KDP_VM_PAGE_WALK_MAX</span>	1000

vm_page_t
<span class="enscript-function-name">kdp_vm_page_lookup</span>(
	vm_object_t		object,
	vm_object_offset_t	offset)
{
	vm_page_t cur_page;
	<span class="enscript-type">int</span> num_traversed = 0;

	<span class="enscript-keyword">if</span> (not_in_kdp) {
		panic(<span class="enscript-string">&quot;panic: kdp_vm_page_lookup done outside of kernel debugger&quot;</span>);
	}

	queue_iterate(&amp;object-&gt;memq, cur_page, vm_page_t, listq) {
		<span class="enscript-keyword">if</span> (cur_page-&gt;offset == offset) {
			<span class="enscript-keyword">return</span> cur_page;
		}
		num_traversed++;

		<span class="enscript-keyword">if</span> (num_traversed &gt;= KDP_VM_PAGE_WALK_MAX) {
			<span class="enscript-keyword">return</span> VM_PAGE_NULL;
		}
	}

	<span class="enscript-keyword">return</span> VM_PAGE_NULL;
}

vm_page_t
<span class="enscript-function-name">vm_page_lookup</span>(
	vm_object_t		object,
	vm_object_offset_t	offset)
{
	vm_page_t	mem;
	vm_page_bucket_t *bucket;
	queue_entry_t	qe;
	lck_spin_t	*bucket_lock = NULL;
	<span class="enscript-type">int</span>		hash_id;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
	uint64_t	start, elapsed;

	OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_total);
#<span class="enscript-reference">endif</span>
	vm_object_lock_assert_held(object);

	<span class="enscript-keyword">if</span> (object-&gt;resident_page_count == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
		OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_empty_obj);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (VM_PAGE_NULL);
	}

	mem = object-&gt;memq_hint;

	<span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL) {
		assert(mem-&gt;object == object);

		<span class="enscript-keyword">if</span> (mem-&gt;offset == offset) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
			OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_hit_hint);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span> (mem);
		}
		qe = queue_next(&amp;mem-&gt;listq);

		<span class="enscript-keyword">if</span> (! queue_end(&amp;object-&gt;memq, qe)) {
			vm_page_t	next_page;

			next_page = (vm_page_t) qe;
			assert(next_page-&gt;object == object);

			<span class="enscript-keyword">if</span> (next_page-&gt;offset == offset) {
				object-&gt;memq_hint = next_page; <span class="enscript-comment">/* new hint */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
				OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_hit_hint_next);
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">return</span> (next_page);
			}
		}
		qe = queue_prev(&amp;mem-&gt;listq);

		<span class="enscript-keyword">if</span> (! queue_end(&amp;object-&gt;memq, qe)) {
			vm_page_t prev_page;

			prev_page = (vm_page_t) qe;
			assert(prev_page-&gt;object == object);

			<span class="enscript-keyword">if</span> (prev_page-&gt;offset == offset) {
				object-&gt;memq_hint = prev_page; <span class="enscript-comment">/* new hint */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
				OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_hit_hint_prev);
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">return</span> (prev_page);
			}
		}
	}
	<span class="enscript-comment">/*
	 * Search the hash table for this object/offset pair
	 */</span>
	hash_id = vm_page_hash(object, offset);
	bucket = &amp;vm_page_buckets[hash_id];

	<span class="enscript-comment">/*
	 * since we hold the object lock, we are guaranteed that no
	 * new pages can be inserted into this object... this in turn
	 * guarantess that the page we're looking for can't exist
	 * if the bucket it hashes to is currently NULL even when looked
	 * at outside the scope of the hash bucket lock... this is a 
	 * really cheap optimiztion to avoid taking the lock
	 */</span>
	<span class="enscript-keyword">if</span> (!bucket-&gt;page_list) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
		OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_bucket_NULL);
#<span class="enscript-reference">endif</span>
	        <span class="enscript-keyword">return</span> (VM_PAGE_NULL);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
	start = mach_absolute_time();
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (object-&gt;resident_page_count &lt;= VM_PAGE_HASH_LOOKUP_THRESHOLD) {
		<span class="enscript-comment">/*
		 * on average, it's roughly 3 times faster to run a short memq list
		 * than to take the spin lock and go through the hash list
		 */</span>
		mem = (vm_page_t)queue_first(&amp;object-&gt;memq);

		<span class="enscript-keyword">while</span> (!queue_end(&amp;object-&gt;memq, (queue_entry_t)mem)) {

			<span class="enscript-keyword">if</span> (mem-&gt;offset == offset)
				<span class="enscript-keyword">break</span>;

			mem = (vm_page_t)queue_next(&amp;mem-&gt;listq);
		}
		<span class="enscript-keyword">if</span> (queue_end(&amp;object-&gt;memq, (queue_entry_t)mem))
			mem = NULL;
	} <span class="enscript-keyword">else</span> {

		bucket_lock = &amp;vm_page_bucket_locks[hash_id / BUCKETS_PER_LOCK];

		lck_spin_lock(bucket_lock);

		<span class="enscript-keyword">for</span> (mem = VM_PAGE_UNPACK_PTR(bucket-&gt;page_list); mem != VM_PAGE_NULL; mem = VM_PAGE_UNPACK_PTR(mem-&gt;next_m)) {
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/*
			 * we don't hold the page queue lock
			 * so this check isn't safe to make
			 */</span>
			VM_PAGE_CHECK(mem);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> ((mem-&gt;object == object) &amp;&amp; (mem-&gt;offset == offset))
				<span class="enscript-keyword">break</span>;
		}
		lck_spin_unlock(bucket_lock);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_VM_PAGE_LOOKUP</span>
	elapsed = mach_absolute_time() - start;

	<span class="enscript-keyword">if</span> (bucket_lock) {
		OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_slow);
		OSAddAtomic64(elapsed, &amp;vm_page_lookup_stats.vpl_slow_elapsed);
	} <span class="enscript-keyword">else</span> {
		OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_fast);
		OSAddAtomic64(elapsed, &amp;vm_page_lookup_stats.vpl_fast_elapsed);
	}
	<span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL)
		OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_hit);
	<span class="enscript-keyword">else</span>
	        OSAddAtomic64(1, &amp;vm_page_lookup_stats.vpl_miss);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (mem != VM_PAGE_NULL) {
		assert(mem-&gt;object == object);

		object-&gt;memq_hint = mem;
	}
	<span class="enscript-keyword">return</span> (mem);
}


<span class="enscript-comment">/*
 *	vm_page_rename:
 *
 *	Move the given memory entry from its
 *	current object to the specified target object/offset.
 *
 *	The object must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_rename</span>(
	<span class="enscript-type">register</span> vm_page_t		mem,
	<span class="enscript-type">register</span> vm_object_t		new_object,
	vm_object_offset_t		new_offset,
	boolean_t			encrypted_ok)
{
	boolean_t internal_to_external, external_to_internal;
	vm_tag_t  tag;

	assert(mem-&gt;object != new_object);

        assert(mem-&gt;object);

	<span class="enscript-comment">/*
	 * ENCRYPTED SWAP:
	 * The encryption key is based on the page's memory object
	 * (aka &quot;pager&quot;) and paging offset.  Moving the page to
	 * another VM object changes its &quot;pager&quot; and &quot;paging_offset&quot;
	 * so it has to be decrypted first, or we would lose the key.
	 *
	 * One exception is VM object collapsing, where we transfer pages
	 * from one backing object to its parent object.  This operation also
	 * transfers the paging information, so the &lt;pager,paging_offset&gt; info
	 * should remain consistent.  The caller (vm_object_do_collapse())
	 * sets &quot;encrypted_ok&quot; in this case.
	 */</span>
	<span class="enscript-keyword">if</span> (!encrypted_ok &amp;&amp; mem-&gt;encrypted) {
		panic(<span class="enscript-string">&quot;vm_page_rename: page %p is encrypted\n&quot;</span>, mem);
	}

        XPR(XPR_VM_PAGE,
                <span class="enscript-string">&quot;vm_page_rename, new object 0x%X, offset 0x%X page 0x%X\n&quot;</span>,
                new_object, new_offset, 
		mem, 0,0);

	<span class="enscript-comment">/*
	 *	Changes to mem-&gt;object require the page lock because
	 *	the pageout daemon uses that lock to get the object.
	 */</span>
	vm_page_lockspin_queues();

	internal_to_external = FALSE;
	external_to_internal = FALSE;

	<span class="enscript-keyword">if</span> (mem-&gt;local) {
		<span class="enscript-comment">/*
		 * it's much easier to get the vm_page_pageable_xxx accounting correct
		 * if we first move the page to the active queue... it's going to end
		 * up there anyway, and we don't do vm_page_rename's frequently enough
		 * for this to matter.
		 */</span>
		vm_page_queues_remove(mem);
		vm_page_activate(mem);
	}
	<span class="enscript-keyword">if</span> (mem-&gt;active || mem-&gt;inactive || mem-&gt;speculative) {
		<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal &amp;&amp; !new_object-&gt;internal) {
			internal_to_external = TRUE;
		}
		<span class="enscript-keyword">if</span> (!mem-&gt;object-&gt;internal &amp;&amp; new_object-&gt;internal) {
			external_to_internal = TRUE;
		}
	}

	tag = mem-&gt;object-&gt;wire_tag;
    	vm_page_remove(mem, TRUE);
	vm_page_insert_internal(mem, new_object, new_offset, tag, TRUE, TRUE, FALSE, FALSE, NULL);

	<span class="enscript-keyword">if</span> (internal_to_external) {
		vm_page_pageable_internal_count--;
		vm_page_pageable_external_count++;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (external_to_internal) {
		vm_page_pageable_external_count--;
		vm_page_pageable_internal_count++;
	}

	vm_page_unlock_queues();
}

<span class="enscript-comment">/*
 *	vm_page_init:
 *
 *	Initialize the fields in a new page.
 *	This takes a structure with random values and initializes it
 *	so that it can be given to vm_page_release or vm_page_insert.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_init</span>(
	vm_page_t	mem,
	ppnum_t		phys_page,
	boolean_t	lopage)
{
	assert(phys_page);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> ((phys_page != vm_page_fictitious_addr) &amp;&amp; (phys_page != vm_page_guard_addr)) {
		<span class="enscript-keyword">if</span> (!(pmap_valid_page(phys_page))) {
			panic(<span class="enscript-string">&quot;vm_page_init: non-DRAM phys_page 0x%x\n&quot;</span>, phys_page);
		}
	}
#<span class="enscript-reference">endif</span>
	*mem = vm_page_template;
	mem-&gt;phys_page = phys_page;
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we're leaving this turned off for now... currently pages
	 * come off the free list and are either immediately dirtied/referenced
	 * due to zero-fill or COW faults, or are used to read or write files...
	 * in the file I/O case, the UPL mechanism takes care of clearing
	 * the state of the HW ref/mod bits in a somewhat fragile way.
	 * Since we may change the way this works in the future (to toughen it up),
	 * I'm leaving this as a reminder of where these bits could get cleared
	 */</span>

	<span class="enscript-comment">/*
	 * make sure both the h/w referenced and modified bits are
	 * clear at this point... we are especially dependent on 
	 * not finding a 'stale' h/w modified in a number of spots
	 * once this page goes back into use
	 */</span>
	pmap_clear_refmod(phys_page, VM_MEM_MODIFIED | VM_MEM_REFERENCED);
#<span class="enscript-reference">endif</span>
	mem-&gt;lopage = lopage;
}

<span class="enscript-comment">/*
 *	vm_page_grab_fictitious:
 *
 *	Remove a fictitious page from the free list.
 *	Returns VM_PAGE_NULL if there are no free pages.
 */</span>
<span class="enscript-type">int</span>	c_vm_page_grab_fictitious = 0;
<span class="enscript-type">int</span>	c_vm_page_grab_fictitious_failed = 0;
<span class="enscript-type">int</span>	c_vm_page_release_fictitious = 0;
<span class="enscript-type">int</span>	c_vm_page_more_fictitious = 0;

vm_page_t
<span class="enscript-function-name">vm_page_grab_fictitious_common</span>(
	ppnum_t phys_addr)
{
	vm_page_t	m;

	<span class="enscript-keyword">if</span> ((m = (vm_page_t)zget(vm_page_zone))) {

		vm_page_init(m, phys_addr, FALSE);
		m-&gt;fictitious = TRUE;

		c_vm_page_grab_fictitious++;
	} <span class="enscript-keyword">else</span>
		c_vm_page_grab_fictitious_failed++;

	<span class="enscript-keyword">return</span> m;
}

vm_page_t
<span class="enscript-function-name">vm_page_grab_fictitious</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> vm_page_grab_fictitious_common(vm_page_fictitious_addr);
}

vm_page_t
<span class="enscript-function-name">vm_page_grab_guard</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> vm_page_grab_fictitious_common(vm_page_guard_addr);
}


<span class="enscript-comment">/*
 *	vm_page_release_fictitious:
 *
 *	Release a fictitious page to the zone pool
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_release_fictitious</span>(
	vm_page_t m)
{
	assert(!m-&gt;free);
	assert(m-&gt;fictitious);
	assert(m-&gt;phys_page == vm_page_fictitious_addr ||
	       m-&gt;phys_page == vm_page_guard_addr);

	c_vm_page_release_fictitious++;

	zfree(vm_page_zone, m);
}

<span class="enscript-comment">/*
 *	vm_page_more_fictitious:
 *
 *	Add more fictitious pages to the zone.
 *	Allowed to block. This routine is way intimate
 *	with the zones code, for several reasons:
 *	1. we need to carve some page structures out of physical
 *	   memory before zones work, so they _cannot_ come from
 *	   the zone_map.
 *	2. the zone needs to be collectable in order to prevent
 *	   growth without bound. These structures are used by
 *	   the device pager (by the hundreds and thousands), as
 *	   private pages for pageout, and as blocking pages for
 *	   pagein. Temporary bursts in demand should not result in
 *	   permanent allocation of a resource.
 *	3. To smooth allocation humps, we allocate single pages
 *	   with kernel_memory_allocate(), and cram them into the
 *	   zone.
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_more_fictitious</span>(<span class="enscript-type">void</span>)
{
	vm_offset_t	addr;
	kern_return_t	retval;

	c_vm_page_more_fictitious++;

	<span class="enscript-comment">/*
	 * Allocate a single page from the zone_map. Do not wait if no physical
	 * pages are immediately available, and do not zero the space. We need
	 * our own blocking lock here to prevent having multiple,
	 * simultaneous requests from piling up on the zone_map lock. Exactly
	 * one (of our) threads should be potentially waiting on the map lock.
	 * If winner is not vm-privileged, then the page allocation will fail,
	 * and it will temporarily block here in the vm_page_wait().
	 */</span>
	lck_mtx_lock(&amp;vm_page_alloc_lock);
	<span class="enscript-comment">/*
	 * If another thread allocated space, just bail out now.
	 */</span>
	<span class="enscript-keyword">if</span> (zone_free_count(vm_page_zone) &gt; 5) {
		<span class="enscript-comment">/*
		 * The number &quot;5&quot; is a small number that is larger than the
		 * number of fictitious pages that any single caller will
		 * attempt to allocate. Otherwise, a thread will attempt to
		 * acquire a fictitious page (vm_page_grab_fictitious), fail,
		 * release all of the resources and locks already acquired,
		 * and then call this routine. This routine finds the pages
		 * that the caller released, so fails to allocate new space.
		 * The process repeats infinitely. The largest known number
		 * of fictitious pages required in this manner is 2. 5 is
		 * simply a somewhat larger number.
		 */</span>
		lck_mtx_unlock(&amp;vm_page_alloc_lock);
		<span class="enscript-keyword">return</span>;
	}

	retval = kernel_memory_allocate(zone_map,
					&amp;addr, PAGE_SIZE, VM_PROT_ALL,
					KMA_KOBJECT|KMA_NOPAGEWAIT, VM_KERN_MEMORY_ZONE);
	<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS) { 
		<span class="enscript-comment">/*
		 * No page was available. Drop the
		 * lock to give another thread a chance at it, and
		 * wait for the pageout daemon to make progress.
		 */</span>
		lck_mtx_unlock(&amp;vm_page_alloc_lock);
		vm_page_wait(THREAD_UNINT);
		<span class="enscript-keyword">return</span>;
	}

	zcram(vm_page_zone, addr, PAGE_SIZE);

	lck_mtx_unlock(&amp;vm_page_alloc_lock);
}


<span class="enscript-comment">/*
 *	vm_pool_low():
 *
 *	Return true if it is not likely that a non-vm_privileged thread
 *	can get memory without blocking.  Advisory only, since the
 *	situation may change under us.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_pool_low</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* No locking, at worst we will fib. */</span>
	<span class="enscript-keyword">return</span>( vm_page_free_count &lt;= vm_page_free_reserved );
}



<span class="enscript-comment">/*
 * this is an interface to support bring-up of drivers
 * on platforms with physical memory &gt; 4G...
 */</span>
<span class="enscript-type">int</span>		vm_himemory_mode = 2;


<span class="enscript-comment">/*
 * this interface exists to support hardware controllers
 * incapable of generating DMAs with more than 32 bits
 * of address on platforms with physical memory &gt; 4G...
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_lopages_allocated_q = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_lopages_allocated_cpm_success = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_lopages_allocated_cpm_failed = 0;
queue_head_t	vm_lopage_queue_free;

vm_page_t
<span class="enscript-function-name">vm_page_grablo</span>(<span class="enscript-type">void</span>)
{
	vm_page_t	mem;

	<span class="enscript-keyword">if</span> (vm_lopage_needed == FALSE)
	        <span class="enscript-keyword">return</span> (vm_page_grab());

	lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);

        <span class="enscript-keyword">if</span> ( !queue_empty(&amp;vm_lopage_queue_free)) {
                queue_remove_first(&amp;vm_lopage_queue_free,
                                   mem,
                                   vm_page_t,
                                   pageq);
		assert(vm_lopage_free_count);

                vm_lopage_free_count--;
		vm_lopages_allocated_q++;

		<span class="enscript-keyword">if</span> (vm_lopage_free_count &lt; vm_lopage_lowater)
			vm_lopage_refill = TRUE;

		lck_mtx_unlock(&amp;vm_page_queue_free_lock);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);

		<span class="enscript-keyword">if</span> (cpm_allocate(PAGE_SIZE, &amp;mem, atop(0xffffffff), 0, FALSE, KMA_LOMEM) != KERN_SUCCESS) {

			lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);
			vm_lopages_allocated_cpm_failed++;
			lck_mtx_unlock(&amp;vm_page_queue_free_lock);

			<span class="enscript-keyword">return</span> (VM_PAGE_NULL);
		}
		mem-&gt;busy = TRUE;

		vm_page_lockspin_queues();
		
		mem-&gt;gobbled = FALSE;
		vm_page_gobble_count--;
		vm_page_wire_count--;

		vm_lopages_allocated_cpm_success++;
		vm_page_unlock_queues();
	}
	assert(mem-&gt;busy);
	assert(!mem-&gt;free);
	assert(!mem-&gt;pmapped);
	assert(!mem-&gt;wpmapped);
	assert(!pmap_is_noencrypt(mem-&gt;phys_page));

	mem-&gt;pageq.next = NULL;
	mem-&gt;pageq.prev = NULL;

	<span class="enscript-keyword">return</span> (mem);
}


<span class="enscript-comment">/*
 *	vm_page_grab:
 *
 *	first try to grab a page from the per-cpu free list...
 *	this must be done while pre-emption is disabled... if
 * 	a page is available, we're done... 
 *	if no page is available, grab the vm_page_queue_free_lock
 *	and see if current number of free pages would allow us
 * 	to grab at least 1... if not, return VM_PAGE_NULL as before... 
 *	if there are pages available, disable preemption and
 * 	recheck the state of the per-cpu free list... we could
 *	have been preempted and moved to a different cpu, or
 * 	some other thread could have re-filled it... if still
 *	empty, figure out how many pages we can steal from the
 *	global free queue and move to the per-cpu queue...
 *	return 1 of these pages when done... only wakeup the
 * 	pageout_scan thread if we moved pages from the global
 *	list... no need for the wakeup if we've satisfied the
 *	request from the per-cpu queue.
 */</span>


vm_page_t
<span class="enscript-function-name">vm_page_grab</span>( <span class="enscript-type">void</span> )
{
	vm_page_t	mem;


	disable_preemption();

	<span class="enscript-keyword">if</span> ((mem = PROCESSOR_DATA(current_processor(), free_pages))) {
<span class="enscript-reference">return_page_from_cpu_list</span>:
	        PROCESSOR_DATA(current_processor(), page_grab_count) += 1;
	        PROCESSOR_DATA(current_processor(), free_pages) = mem-&gt;pageq.next;

	        enable_preemption();
		mem-&gt;pageq.next = NULL;

		assert(mem-&gt;listq.next == NULL &amp;&amp; mem-&gt;listq.prev == NULL);
		assert(mem-&gt;tabled == FALSE);
		assert(mem-&gt;object == VM_OBJECT_NULL);
		assert(!mem-&gt;laundry);
		assert(!mem-&gt;free);
		assert(pmap_verify_free(mem-&gt;phys_page));
		assert(mem-&gt;busy);
		assert(!mem-&gt;encrypted);
		assert(!mem-&gt;pmapped);
		assert(!mem-&gt;wpmapped);
		assert(!mem-&gt;active);
		assert(!mem-&gt;inactive);
		assert(!mem-&gt;throttled);
		assert(!mem-&gt;speculative);
		assert(!pmap_is_noencrypt(mem-&gt;phys_page));

		<span class="enscript-keyword">return</span> mem;
	}
	enable_preemption();


	<span class="enscript-comment">/*
	 *	Optionally produce warnings if the wire or gobble
	 *	counts exceed some threshold.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_WIRE_COUNT_WARNING</span>
	<span class="enscript-keyword">if</span> (vm_page_wire_count &gt;= VM_PAGE_WIRE_COUNT_WARNING) {
		printf(<span class="enscript-string">&quot;mk: vm_page_grab(): high wired page count of %d\n&quot;</span>,
			vm_page_wire_count);
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_GOBBLE_COUNT_WARNING</span>
	<span class="enscript-keyword">if</span> (vm_page_gobble_count &gt;= VM_PAGE_GOBBLE_COUNT_WARNING) {
		printf(<span class="enscript-string">&quot;mk: vm_page_grab(): high gobbled page count of %d\n&quot;</span>,
			vm_page_gobble_count);
	}
#<span class="enscript-reference">endif</span>
	lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);

	<span class="enscript-comment">/*
	 *	Only let privileged threads (involved in pageout)
	 *	dip into the reserved pool.
	 */</span>
	<span class="enscript-keyword">if</span> ((vm_page_free_count &lt; vm_page_free_reserved) &amp;&amp;
	    !(current_thread()-&gt;options &amp; TH_OPT_VMPRIV)) {
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);
		mem = VM_PAGE_NULL;
	}
	<span class="enscript-keyword">else</span> {
	       vm_page_t	head;
	       vm_page_t	tail;
	       <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	pages_to_steal;
	       <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	color;

	       <span class="enscript-keyword">while</span> ( vm_page_free_count == 0 ) {

			lck_mtx_unlock(&amp;vm_page_queue_free_lock);
			<span class="enscript-comment">/*
			 * must be a privileged thread to be
			 * in this state since a non-privileged 
			 * thread would have bailed if we were
			 * under the vm_page_free_reserved mark
			 */</span>
			VM_PAGE_WAIT();
			lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);
		}

		disable_preemption();

		<span class="enscript-keyword">if</span> ((mem = PROCESSOR_DATA(current_processor(), free_pages))) {
			lck_mtx_unlock(&amp;vm_page_queue_free_lock);

		        <span class="enscript-comment">/*
			 * we got preempted and moved to another processor
			 * or we got preempted and someone else ran and filled the cache
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">return_page_from_cpu_list</span>;
		}
		<span class="enscript-keyword">if</span> (vm_page_free_count &lt;= vm_page_free_reserved)
		        pages_to_steal = 1;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (vm_free_magazine_refill_limit &lt;= (vm_page_free_count - vm_page_free_reserved))
				pages_to_steal = vm_free_magazine_refill_limit;
			<span class="enscript-keyword">else</span>
			        pages_to_steal = (vm_page_free_count - vm_page_free_reserved);
		}
		color = PROCESSOR_DATA(current_processor(), start_color);
		head = tail = NULL;

		vm_page_free_count -= pages_to_steal;

		<span class="enscript-keyword">while</span> (pages_to_steal--) {

			<span class="enscript-keyword">while</span> (queue_empty(&amp;vm_page_queue_free[color]))
			        color = (color + 1) &amp; vm_color_mask;
		
			queue_remove_first(&amp;vm_page_queue_free[color],
					   mem,
					   vm_page_t,
					   pageq);
			mem-&gt;pageq.next = NULL;
			mem-&gt;pageq.prev = NULL;

			assert(!mem-&gt;active);
			assert(!mem-&gt;inactive);
			assert(!mem-&gt;throttled);
			assert(!mem-&gt;speculative);			

			color = (color + 1) &amp; vm_color_mask;

			<span class="enscript-keyword">if</span> (head == NULL)
				head = mem;
			<span class="enscript-keyword">else</span>
			        tail-&gt;pageq.next = (queue_t)mem;
		        tail = mem;

			assert(mem-&gt;listq.next == NULL &amp;&amp; mem-&gt;listq.prev == NULL);
			assert(mem-&gt;tabled == FALSE);
			assert(mem-&gt;object == VM_OBJECT_NULL);
			assert(!mem-&gt;laundry);
			assert(mem-&gt;free);
			mem-&gt;free = FALSE;

			assert(pmap_verify_free(mem-&gt;phys_page));
			assert(mem-&gt;busy);
			assert(!mem-&gt;free);
			assert(!mem-&gt;encrypted);
			assert(!mem-&gt;pmapped);
			assert(!mem-&gt;wpmapped);
			assert(!pmap_is_noencrypt(mem-&gt;phys_page));
		}
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);

		PROCESSOR_DATA(current_processor(), free_pages) = head-&gt;pageq.next;
		PROCESSOR_DATA(current_processor(), start_color) = color;

		<span class="enscript-comment">/*
		 * satisfy this request
		 */</span>
	        PROCESSOR_DATA(current_processor(), page_grab_count) += 1;
		mem = head;
		mem-&gt;pageq.next = NULL;

		enable_preemption();
	}
	<span class="enscript-comment">/*
	 *	Decide if we should poke the pageout daemon.
	 *	We do this if the free count is less than the low
	 *	water mark, or if the free count is less than the high
	 *	water mark (but above the low water mark) and the inactive
	 *	count is less than its target.
	 *
	 *	We don't have the counts locked ... if they change a little,
	 *	it doesn't really matter.
	 */</span>
	<span class="enscript-keyword">if</span> ((vm_page_free_count &lt; vm_page_free_min) ||
	     ((vm_page_free_count &lt; vm_page_free_target) &amp;&amp;
	      ((vm_page_inactive_count + vm_page_speculative_count) &lt; vm_page_inactive_min)))
	         thread_wakeup((event_t) &amp;vm_page_free_wanted);

	VM_CHECK_MEMORYSTATUS;
	
<span class="enscript-comment">//	dbgLog(mem-&gt;phys_page, vm_page_free_count, vm_page_wire_count, 4);	/* (TEST/DEBUG) */
</span>
	<span class="enscript-keyword">return</span> mem;
}

<span class="enscript-comment">/*
 *	vm_page_release:
 *
 *	Return a page to the free list.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_release</span>(
	<span class="enscript-type">register</span> vm_page_t	mem)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	color;
	<span class="enscript-type">int</span>	need_wakeup = 0;
	<span class="enscript-type">int</span>	need_priv_wakeup = 0;


	assert(!mem-&gt;private &amp;&amp; !mem-&gt;fictitious);
	<span class="enscript-keyword">if</span> (vm_page_free_verify) {
		assert(pmap_verify_free(mem-&gt;phys_page));
	}
<span class="enscript-comment">//	dbgLog(mem-&gt;phys_page, vm_page_free_count, vm_page_wire_count, 5);	/* (TEST/DEBUG) */
</span>
	pmap_clear_noencrypt(mem-&gt;phys_page);

	lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (mem-&gt;free)
		panic(<span class="enscript-string">&quot;vm_page_release&quot;</span>);
#<span class="enscript-reference">endif</span>

	assert(mem-&gt;busy);
	assert(!mem-&gt;laundry);
	assert(mem-&gt;object == VM_OBJECT_NULL);
	assert(mem-&gt;pageq.next == NULL &amp;&amp;
	       mem-&gt;pageq.prev == NULL);
	assert(mem-&gt;listq.next == NULL &amp;&amp;
	       mem-&gt;listq.prev == NULL);
	
	<span class="enscript-keyword">if</span> ((mem-&gt;lopage == TRUE || vm_lopage_refill == TRUE) &amp;&amp;
	    vm_lopage_free_count &lt; vm_lopage_free_limit &amp;&amp;
	    mem-&gt;phys_page &lt; max_valid_low_ppnum) {
	        <span class="enscript-comment">/*
		 * this exists to support hardware controllers
		 * incapable of generating DMAs with more than 32 bits
		 * of address on platforms with physical memory &gt; 4G...
		 */</span>
		queue_enter_first(&amp;vm_lopage_queue_free,
				  mem,
				  vm_page_t,
				  pageq);
		vm_lopage_free_count++;

		<span class="enscript-keyword">if</span> (vm_lopage_free_count &gt;= vm_lopage_free_limit)
			vm_lopage_refill = FALSE;

		mem-&gt;lopage = TRUE;
	} <span class="enscript-keyword">else</span> {	  
		mem-&gt;lopage = FALSE;
		mem-&gt;free = TRUE;

	        color = mem-&gt;phys_page &amp; vm_color_mask;
		queue_enter_first(&amp;vm_page_queue_free[color],
				  mem,
				  vm_page_t,
				  pageq);
		vm_page_free_count++;
		<span class="enscript-comment">/*
		 *	Check if we should wake up someone waiting for page.
		 *	But don't bother waking them unless they can allocate.
		 *
		 *	We wakeup only one thread, to prevent starvation.
		 *	Because the scheduling system handles wait queues FIFO,
		 *	if we wakeup all waiting threads, one greedy thread
		 *	can starve multiple niceguy threads.  When the threads
		 *	all wakeup, the greedy threads runs first, grabs the page,
		 *	and waits for another page.  It will be the first to run
		 *	when the next page is freed.
		 *
		 *	However, there is a slight danger here.
		 *	The thread we wake might not use the free page.
		 *	Then the other threads could wait indefinitely
		 *	while the page goes unused.  To forestall this,
		 *	the pageout daemon will keep making free pages
		 *	as long as vm_page_free_wanted is non-zero.
		 */</span>

		assert(vm_page_free_count &gt; 0);
		<span class="enscript-keyword">if</span> (vm_page_free_wanted_privileged &gt; 0) {
		        vm_page_free_wanted_privileged--;
			need_priv_wakeup = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vm_page_free_wanted &gt; 0 &amp;&amp;
			   vm_page_free_count &gt; vm_page_free_reserved) {
		        vm_page_free_wanted--;
			need_wakeup = 1;
		}
	}
	lck_mtx_unlock(&amp;vm_page_queue_free_lock);

	<span class="enscript-keyword">if</span> (need_priv_wakeup)
		thread_wakeup_one((event_t) &amp;vm_page_free_wanted_privileged);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (need_wakeup)
		thread_wakeup_one((event_t) &amp;vm_page_free_count);

	VM_CHECK_MEMORYSTATUS;
}

<span class="enscript-comment">/*
 * This version of vm_page_release() is used only at startup
 * when we are single-threaded and pages are being released 
 * for the first time. Hence, no locking or unnecessary checks are made.
 * Note: VM_CHECK_MEMORYSTATUS invoked by the caller.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_release_startup</span>(
	<span class="enscript-type">register</span> vm_page_t	mem)
{
	queue_t	queue_free;

	<span class="enscript-keyword">if</span> (vm_lopage_free_count &lt; vm_lopage_free_limit &amp;&amp;
	    mem-&gt;phys_page &lt; max_valid_low_ppnum) {
		mem-&gt;lopage = TRUE;
		vm_lopage_free_count++;
		queue_free = &amp;vm_lopage_queue_free;
	} <span class="enscript-keyword">else</span> {	  
		mem-&gt;lopage = FALSE;
		mem-&gt;free = TRUE;
		vm_page_free_count++;
		queue_free = &amp;vm_page_queue_free[mem-&gt;phys_page &amp; vm_color_mask];
	}
	queue_enter_first(queue_free, mem, vm_page_t, pageq);
}

<span class="enscript-comment">/*
 *	vm_page_wait:
 *
 *	Wait for a page to become available.
 *	If there are plenty of free pages, then we don't sleep.
 *
 *	Returns:
 *		TRUE:  There may be another page, try again
 *		FALSE: We were interrupted out of our wait, don't try again
 */</span>

boolean_t
<span class="enscript-function-name">vm_page_wait</span>(
	<span class="enscript-type">int</span>	interruptible )
{
	<span class="enscript-comment">/*
	 *	We can't use vm_page_free_reserved to make this
	 *	determination.  Consider: some thread might
	 *	need to allocate two pages.  The first allocation
	 *	succeeds, the second fails.  After the first page is freed,
	 *	a call to vm_page_wait must really block.
	 */</span>
	kern_return_t	wait_result;
	<span class="enscript-type">int</span>          	need_wakeup = 0;
	<span class="enscript-type">int</span>		is_privileged = current_thread()-&gt;options &amp; TH_OPT_VMPRIV;

	lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);

	<span class="enscript-keyword">if</span> (is_privileged &amp;&amp; vm_page_free_count) {
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);
		<span class="enscript-keyword">return</span> TRUE;
	}
	<span class="enscript-keyword">if</span> (vm_page_free_count &lt; vm_page_free_target) {

	        <span class="enscript-keyword">if</span> (is_privileged) {
		        <span class="enscript-keyword">if</span> (vm_page_free_wanted_privileged++ == 0)
			        need_wakeup = 1;
			wait_result = assert_wait((event_t)&amp;vm_page_free_wanted_privileged, interruptible);
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-keyword">if</span> (vm_page_free_wanted++ == 0)
			        need_wakeup = 1;
			wait_result = assert_wait((event_t)&amp;vm_page_free_count, interruptible);
		}
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);
		counter(c_vm_page_wait_block++);

		<span class="enscript-keyword">if</span> (need_wakeup)
			thread_wakeup((event_t)&amp;vm_page_free_wanted);

		<span class="enscript-keyword">if</span> (wait_result == THREAD_WAITING) {
			VM_DEBUG_EVENT(vm_page_wait_block, VM_PAGE_WAIT_BLOCK, DBG_FUNC_START,
				       vm_page_free_wanted_privileged, vm_page_free_wanted, 0, 0);
			wait_result = thread_block(THREAD_CONTINUE_NULL);
			VM_DEBUG_EVENT(vm_page_wait_block, VM_PAGE_WAIT_BLOCK, DBG_FUNC_END, 0, 0, 0, 0);
		}

		<span class="enscript-keyword">return</span>(wait_result == THREAD_AWAKENED);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);
		<span class="enscript-keyword">return</span> TRUE;
	}
}

<span class="enscript-comment">/*
 *	vm_page_alloc:
 *
 *	Allocate and return a memory cell associated
 *	with this VM object/offset pair.
 *
 *	Object must be locked.
 */</span>

vm_page_t
<span class="enscript-function-name">vm_page_alloc</span>(
	vm_object_t		object,
	vm_object_offset_t	offset)
{
	<span class="enscript-type">register</span> vm_page_t	mem;

	vm_object_lock_assert_exclusive(object);
	mem = vm_page_grab();
	<span class="enscript-keyword">if</span> (mem == VM_PAGE_NULL)
		<span class="enscript-keyword">return</span> VM_PAGE_NULL;

	vm_page_insert(mem, object, offset);

	<span class="enscript-keyword">return</span>(mem);
}

<span class="enscript-comment">/*
 *	vm_page_alloc_guard:
 *	
 * 	Allocate a fictitious page which will be used
 *	as a guard page.  The page will be inserted into
 *	the object and returned to the caller.
 */</span>

vm_page_t
<span class="enscript-function-name">vm_page_alloc_guard</span>(
	vm_object_t		object,
	vm_object_offset_t	offset)
{
	<span class="enscript-type">register</span> vm_page_t	mem;

	vm_object_lock_assert_exclusive(object);
	mem = vm_page_grab_guard();
	<span class="enscript-keyword">if</span> (mem == VM_PAGE_NULL)
		<span class="enscript-keyword">return</span> VM_PAGE_NULL;

	vm_page_insert(mem, object, offset);

	<span class="enscript-keyword">return</span>(mem);
}


<span class="enscript-function-name">counter</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> c_laundry_pages_freed = 0;)

<span class="enscript-comment">/*
 *	vm_page_free_prepare:
 *
 *	Removes page from any queue it may be on
 *	and disassociates it from its VM object.
 *
 *	Object and page queues must be locked prior to entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_free_prepare</span>(
	vm_page_t	mem)
{
	vm_page_free_prepare_queues(mem);
	vm_page_free_prepare_object(mem, TRUE);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_free_prepare_queues</span>(
	vm_page_t	mem)
{
	VM_PAGE_CHECK(mem);
	assert(!mem-&gt;free);
	assert(!mem-&gt;cleaning);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-keyword">if</span> (mem-&gt;free)
		panic(<span class="enscript-string">&quot;vm_page_free: freeing page on free list\n&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>
	<span class="enscript-keyword">if</span> (mem-&gt;object) {
		vm_object_lock_assert_exclusive(mem-&gt;object);
	}
	<span class="enscript-keyword">if</span> (mem-&gt;laundry) {
		<span class="enscript-comment">/*
		 * We may have to free a page while it's being laundered
		 * if we lost its pager (due to a forced unmount, for example).
		 * We need to call vm_pageout_steal_laundry() before removing
		 * the page from its VM object, so that we can remove it
		 * from its pageout queue and adjust the laundry accounting
		 */</span>
		vm_pageout_steal_laundry(mem, TRUE);
		counter(++c_laundry_pages_freed);
	}
	
	vm_page_queues_remove(mem);	<span class="enscript-comment">/* clears local/active/inactive/throttled/speculative */</span>

	<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(mem)) {
		<span class="enscript-keyword">if</span> (mem-&gt;object) {
			assert(mem-&gt;object-&gt;wired_page_count &gt; 0);
			mem-&gt;object-&gt;wired_page_count--;
			<span class="enscript-keyword">if</span> (!mem-&gt;object-&gt;wired_page_count) {
			    VM_OBJECT_UNWIRED(mem-&gt;object);
			}

			assert(mem-&gt;object-&gt;resident_page_count &gt;=
			       mem-&gt;object-&gt;wired_page_count);

			<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE) {
				OSAddAtomic(+1, &amp;vm_page_purgeable_count);
				assert(vm_page_purgeable_wired_count &gt; 0);
				OSAddAtomic(-1, &amp;vm_page_purgeable_wired_count);
			}
			<span class="enscript-keyword">if</span> ((mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE ||
			     mem-&gt;object-&gt;purgable == VM_PURGABLE_EMPTY) &amp;&amp;
			    mem-&gt;object-&gt;vo_purgeable_owner != TASK_NULL) {
				task_t owner;

				owner = mem-&gt;object-&gt;vo_purgeable_owner;
				<span class="enscript-comment">/*
				 * While wired, this page was accounted
				 * as &quot;non-volatile&quot; but it should now
				 * be accounted as &quot;volatile&quot;.
				 */</span>
				<span class="enscript-comment">/* one less &quot;non-volatile&quot;... */</span>
				ledger_debit(owner-&gt;ledger,
					     task_ledgers.purgeable_nonvolatile,
					     PAGE_SIZE);
				<span class="enscript-comment">/* ... and &quot;phys_footprint&quot; */</span>
				ledger_debit(owner-&gt;ledger,
					     task_ledgers.phys_footprint,
					     PAGE_SIZE);
				<span class="enscript-comment">/* one more &quot;volatile&quot; */</span>
				ledger_credit(owner-&gt;ledger,
					      task_ledgers.purgeable_volatile,
					      PAGE_SIZE);
			}
		}
		<span class="enscript-keyword">if</span> (!mem-&gt;private &amp;&amp; !mem-&gt;fictitious)
			vm_page_wire_count--;
		mem-&gt;wire_count = 0;
		assert(!mem-&gt;gobbled);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;gobbled) {
		<span class="enscript-keyword">if</span> (!mem-&gt;private &amp;&amp; !mem-&gt;fictitious)
			vm_page_wire_count--;
		vm_page_gobble_count--;
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_free_prepare_object</span>(
	vm_page_t	mem,
	boolean_t	remove_from_hash)
{
	<span class="enscript-keyword">if</span> (mem-&gt;tabled)
		vm_page_remove(mem, remove_from_hash);	<span class="enscript-comment">/* clears tabled, object, offset */</span>

	PAGE_WAKEUP(mem);		<span class="enscript-comment">/* clears wanted */</span>

	<span class="enscript-keyword">if</span> (mem-&gt;private) {
		mem-&gt;private = FALSE;
		mem-&gt;fictitious = TRUE;
		mem-&gt;phys_page = vm_page_fictitious_addr;
	}
	<span class="enscript-keyword">if</span> ( !mem-&gt;fictitious) {
		vm_page_init(mem, mem-&gt;phys_page, mem-&gt;lopage);
	}
}


<span class="enscript-comment">/*
 *	vm_page_free:
 *
 *	Returns the given page to the free list,
 *	disassociating it with any VM object.
 *
 *	Object and page queues must be locked prior to entry.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_free</span>(
	vm_page_t	mem)
{
	vm_page_free_prepare(mem);

	<span class="enscript-keyword">if</span> (mem-&gt;fictitious) {
		vm_page_release_fictitious(mem);
	} <span class="enscript-keyword">else</span> {
		vm_page_release(mem);
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_free_unlocked</span>(
	vm_page_t	mem,
	boolean_t	remove_from_hash)
{
	vm_page_lockspin_queues();
	vm_page_free_prepare_queues(mem);
	vm_page_unlock_queues();

	vm_page_free_prepare_object(mem, remove_from_hash);

	<span class="enscript-keyword">if</span> (mem-&gt;fictitious) {
		vm_page_release_fictitious(mem);
	} <span class="enscript-keyword">else</span> {
		vm_page_release(mem);
	}
}


<span class="enscript-comment">/*
 * Free a list of pages.  The list can be up to several hundred pages,
 * as blocked up by vm_pageout_scan().
 * The big win is not having to take the free list lock once
 * per page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_free_list</span>(
	vm_page_t	freeq,
	boolean_t	prepare_object)
{
        vm_page_t	mem;
        vm_page_t	nxt;
	vm_page_t	local_freeq;
	<span class="enscript-type">int</span>		pg_count;

	<span class="enscript-keyword">while</span> (freeq) {

		pg_count = 0;
		local_freeq = VM_PAGE_NULL;
		mem = freeq;

		<span class="enscript-comment">/*
		 * break up the processing into smaller chunks so
		 * that we can 'pipeline' the pages onto the
		 * free list w/o introducing too much
		 * contention on the global free queue lock
		 */</span>
		<span class="enscript-keyword">while</span> (mem &amp;&amp; pg_count &lt; 64) {

			assert(!mem-&gt;inactive);
			assert(!mem-&gt;active);
			assert(!mem-&gt;throttled);
			assert(!mem-&gt;free);
			assert(!mem-&gt;speculative);
			assert(!VM_PAGE_WIRED(mem));
			assert(mem-&gt;pageq.prev == NULL);

			nxt = (vm_page_t)(mem-&gt;pageq.next);
		
			<span class="enscript-keyword">if</span> (vm_page_free_verify &amp;&amp; !mem-&gt;fictitious &amp;&amp; !mem-&gt;private) {
				assert(pmap_verify_free(mem-&gt;phys_page));
			}
			<span class="enscript-keyword">if</span> (prepare_object == TRUE)
				vm_page_free_prepare_object(mem, TRUE);

			<span class="enscript-keyword">if</span> (!mem-&gt;fictitious) {
				assert(mem-&gt;busy);

				<span class="enscript-keyword">if</span> ((mem-&gt;lopage == TRUE || vm_lopage_refill == TRUE) &amp;&amp;
				    vm_lopage_free_count &lt; vm_lopage_free_limit &amp;&amp;
				    mem-&gt;phys_page &lt; max_valid_low_ppnum) {
					mem-&gt;pageq.next = NULL;
					vm_page_release(mem);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * IMPORTANT: we can't set the page &quot;free&quot; here
					 * because that would make the page eligible for
					 * a physically-contiguous allocation (see
					 * vm_page_find_contiguous()) right away (we don't
					 * hold the vm_page_queue_free lock).  That would
					 * cause trouble because the page is not actually
					 * in the free queue yet...
					 */</span>
					mem-&gt;pageq.next = (queue_entry_t)local_freeq;
					local_freeq = mem;
					pg_count++;

					pmap_clear_noencrypt(mem-&gt;phys_page);
				}
			} <span class="enscript-keyword">else</span> {
				assert(mem-&gt;phys_page == vm_page_fictitious_addr ||
				       mem-&gt;phys_page == vm_page_guard_addr);
				vm_page_release_fictitious(mem);
			}
			mem = nxt;
		}
		freeq = mem;

		<span class="enscript-keyword">if</span> ( (mem = local_freeq) ) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	avail_free_count;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	need_wakeup = 0;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	need_priv_wakeup = 0;
	  
			lck_mtx_lock_spin(&amp;vm_page_queue_free_lock);

			<span class="enscript-keyword">while</span> (mem) {
				<span class="enscript-type">int</span>	color;

				nxt = (vm_page_t)(mem-&gt;pageq.next);

				assert(!mem-&gt;free);
				assert(mem-&gt;busy);
				mem-&gt;free = TRUE;

				color = mem-&gt;phys_page &amp; vm_color_mask;
				queue_enter_first(&amp;vm_page_queue_free[color],
						  mem,
						  vm_page_t,
						  pageq);
				mem = nxt;
			}
			vm_page_free_count += pg_count;
			avail_free_count = vm_page_free_count;

			<span class="enscript-keyword">if</span> (vm_page_free_wanted_privileged &gt; 0 &amp;&amp; avail_free_count &gt; 0) {

				<span class="enscript-keyword">if</span> (avail_free_count &lt; vm_page_free_wanted_privileged) {
					need_priv_wakeup = avail_free_count;
					vm_page_free_wanted_privileged -= avail_free_count;
					avail_free_count = 0;
				} <span class="enscript-keyword">else</span> {
					need_priv_wakeup = vm_page_free_wanted_privileged;
					vm_page_free_wanted_privileged = 0;
					avail_free_count -= vm_page_free_wanted_privileged;
				}
			}
			<span class="enscript-keyword">if</span> (vm_page_free_wanted &gt; 0 &amp;&amp; avail_free_count &gt; vm_page_free_reserved) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  available_pages;

				available_pages = avail_free_count - vm_page_free_reserved;

				<span class="enscript-keyword">if</span> (available_pages &gt;= vm_page_free_wanted) {
					need_wakeup = vm_page_free_wanted;
					vm_page_free_wanted = 0;
				} <span class="enscript-keyword">else</span> {
					need_wakeup = available_pages;
					vm_page_free_wanted -= available_pages;
				}
			}
			lck_mtx_unlock(&amp;vm_page_queue_free_lock);

			<span class="enscript-keyword">if</span> (need_priv_wakeup != 0) {
				<span class="enscript-comment">/*
				 * There shouldn't be that many VM-privileged threads,
				 * so let's wake them all up, even if we don't quite
				 * have enough pages to satisfy them all.
				 */</span>
				thread_wakeup((event_t)&amp;vm_page_free_wanted_privileged);
			}
			<span class="enscript-keyword">if</span> (need_wakeup != 0 &amp;&amp; vm_page_free_wanted == 0) {
				<span class="enscript-comment">/*
				 * We don't expect to have any more waiters
				 * after this, so let's wake them all up at
				 * once.
				 */</span>
				thread_wakeup((event_t) &amp;vm_page_free_count);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (; need_wakeup != 0; need_wakeup--) {
				<span class="enscript-comment">/*
				 * Wake up one waiter per page we just released.
				 */</span>
				thread_wakeup_one((event_t) &amp;vm_page_free_count);
			}

			VM_CHECK_MEMORYSTATUS;
		}
	}
}


<span class="enscript-comment">/*
 *	vm_page_wire:
 *
 *	Mark this page as wired down by yet
 *	another map, removing it from paging queues
 *	as necessary.
 *
 *	The page's object and the page queues must be locked.
 */</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_wire</span>(
	<span class="enscript-type">register</span> vm_page_t mem,
	vm_tag_t           tag,
	boolean_t	   check_memorystatus)
{

<span class="enscript-comment">//	dbgLog(current_thread(), mem-&gt;offset, mem-&gt;object, 1);	/* (TEST/DEBUG) */
</span>
	VM_PAGE_CHECK(mem);
	<span class="enscript-keyword">if</span> (mem-&gt;object) {
		vm_object_lock_assert_exclusive(mem-&gt;object);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * In theory, the page should be in an object before it
		 * gets wired, since we need to hold the object lock
		 * to update some fields in the page structure.
		 * However, some code (i386 pmap, for example) might want
		 * to wire a page before it gets inserted into an object.
		 * That's somewhat OK, as long as nobody else can get to
		 * that page and update it at the same time.
		 */</span>
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ( !VM_PAGE_WIRED(mem)) {

		<span class="enscript-keyword">if</span> (mem-&gt;pageout_queue) {
			mem-&gt;pageout = FALSE;
			vm_pageout_throttle_up(mem);
		}
		vm_page_queues_remove(mem);

		<span class="enscript-keyword">if</span> (mem-&gt;object) {

			<span class="enscript-keyword">if</span> (!mem-&gt;private &amp;&amp; !mem-&gt;fictitious) 
			{
			    <span class="enscript-keyword">if</span> (!mem-&gt;object-&gt;wired_page_count)
			    {
				assert(VM_KERN_MEMORY_NONE != tag);
				mem-&gt;object-&gt;wire_tag = tag;
				VM_OBJECT_WIRED(mem-&gt;object);
			    }
			}
			mem-&gt;object-&gt;wired_page_count++;

			assert(mem-&gt;object-&gt;resident_page_count &gt;=
			       mem-&gt;object-&gt;wired_page_count);
			<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE) {
				assert(vm_page_purgeable_count &gt; 0);
				OSAddAtomic(-1, &amp;vm_page_purgeable_count);
				OSAddAtomic(1, &amp;vm_page_purgeable_wired_count);
			}
			<span class="enscript-keyword">if</span> ((mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE ||
			     mem-&gt;object-&gt;purgable == VM_PURGABLE_EMPTY) &amp;&amp;
			    mem-&gt;object-&gt;vo_purgeable_owner != TASK_NULL) {
				task_t owner;

				owner = mem-&gt;object-&gt;vo_purgeable_owner;
				<span class="enscript-comment">/* less volatile bytes */</span>
				ledger_debit(owner-&gt;ledger,
					     task_ledgers.purgeable_volatile,
					     PAGE_SIZE);
				<span class="enscript-comment">/* more not-quite-volatile bytes */</span>
				ledger_credit(owner-&gt;ledger,
					      task_ledgers.purgeable_nonvolatile,
					      PAGE_SIZE);
				<span class="enscript-comment">/* more footprint */</span>
				ledger_credit(owner-&gt;ledger,
					      task_ledgers.phys_footprint,
					      PAGE_SIZE);
			}
			<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;all_reusable) {
				<span class="enscript-comment">/*
				 * Wired pages are not counted as &quot;re-usable&quot;
				 * in &quot;all_reusable&quot; VM objects, so nothing
				 * to do here.
				 */</span>
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;reusable) {
				<span class="enscript-comment">/*
				 * This page is not &quot;re-usable&quot; when it's
				 * wired, so adjust its state and the
				 * accounting.
				 */</span>
				vm_object_reuse_pages(mem-&gt;object,
						      mem-&gt;offset,
						      mem-&gt;offset+PAGE_SIZE_64,
						      FALSE);
			}
		}
		assert(!mem-&gt;reusable);

		<span class="enscript-keyword">if</span> (!mem-&gt;private &amp;&amp; !mem-&gt;fictitious &amp;&amp; !mem-&gt;gobbled)
			vm_page_wire_count++;
		<span class="enscript-keyword">if</span> (mem-&gt;gobbled)
			vm_page_gobble_count--;
		mem-&gt;gobbled = FALSE;

		<span class="enscript-keyword">if</span> (check_memorystatus == TRUE) {
			VM_CHECK_MEMORYSTATUS;
		}
		<span class="enscript-comment">/* 
		 * ENCRYPTED SWAP:
		 * The page could be encrypted, but
		 * We don't have to decrypt it here
		 * because we don't guarantee that the
		 * data is actually valid at this point.
		 * The page will get decrypted in
		 * vm_fault_wire() if needed.
		 */</span>
	}
	assert(!mem-&gt;gobbled);
	mem-&gt;wire_count++;
	VM_PAGE_CHECK(mem);
}

<span class="enscript-comment">/*
 *	vm_page_unwire:
 *
 *	Release one wiring of this page, potentially
 *	enabling it to be paged again.
 *
 *	The page's object and the page queues must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_unwire</span>(
	vm_page_t	mem,
	boolean_t	queueit)
{

<span class="enscript-comment">//	dbgLog(current_thread(), mem-&gt;offset, mem-&gt;object, 0);	/* (TEST/DEBUG) */
</span>
	VM_PAGE_CHECK(mem);
	assert(VM_PAGE_WIRED(mem));
	assert(mem-&gt;object != VM_OBJECT_NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	vm_object_lock_assert_exclusive(mem-&gt;object);
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (--mem-&gt;wire_count == 0) {
		assert(!mem-&gt;private &amp;&amp; !mem-&gt;fictitious);
		vm_page_wire_count--;
		assert(mem-&gt;object-&gt;wired_page_count &gt; 0);
		mem-&gt;object-&gt;wired_page_count--;
		<span class="enscript-keyword">if</span> (!mem-&gt;object-&gt;wired_page_count) {
		    VM_OBJECT_UNWIRED(mem-&gt;object);
		}
		assert(mem-&gt;object-&gt;resident_page_count &gt;=
		       mem-&gt;object-&gt;wired_page_count);
		<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE) {
			OSAddAtomic(+1, &amp;vm_page_purgeable_count);
			assert(vm_page_purgeable_wired_count &gt; 0);
			OSAddAtomic(-1, &amp;vm_page_purgeable_wired_count);
		}
		<span class="enscript-keyword">if</span> ((mem-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE ||
		     mem-&gt;object-&gt;purgable == VM_PURGABLE_EMPTY) &amp;&amp;
		    mem-&gt;object-&gt;vo_purgeable_owner != TASK_NULL) {
			task_t owner;

			owner = mem-&gt;object-&gt;vo_purgeable_owner;
			<span class="enscript-comment">/* more volatile bytes */</span>
			ledger_credit(owner-&gt;ledger,
				      task_ledgers.purgeable_volatile,
				      PAGE_SIZE);
			<span class="enscript-comment">/* less not-quite-volatile bytes */</span>
			ledger_debit(owner-&gt;ledger,
				     task_ledgers.purgeable_nonvolatile,
				     PAGE_SIZE);
			<span class="enscript-comment">/* less footprint */</span>
			ledger_debit(owner-&gt;ledger,
				     task_ledgers.phys_footprint,
				     PAGE_SIZE);
		}
		assert(mem-&gt;object != kernel_object);
		assert(mem-&gt;pageq.next == NULL &amp;&amp; mem-&gt;pageq.prev == NULL);

		<span class="enscript-keyword">if</span> (queueit == TRUE) {
			<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;purgable == VM_PURGABLE_EMPTY) {
				vm_page_deactivate(mem);
			} <span class="enscript-keyword">else</span> {
				vm_page_activate(mem);
			}
		}

		VM_CHECK_MEMORYSTATUS;
		
	}
	VM_PAGE_CHECK(mem);
}

<span class="enscript-comment">/*
 *	vm_page_deactivate:
 *
 *	Returns the given page to the inactive list,
 *	indicating that no physical maps have access
 *	to this page.  [Used by the physical mapping system.]
 *
 *	The page queues must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_deactivate</span>(
	vm_page_t	m)
{
	vm_page_deactivate_internal(m, TRUE);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_deactivate_internal</span>(
	vm_page_t	m,
	boolean_t	clear_hw_reference)
{

	VM_PAGE_CHECK(m);
	assert(m-&gt;object != kernel_object);
	assert(m-&gt;phys_page != vm_page_guard_addr);

<span class="enscript-comment">//	dbgLog(m-&gt;phys_page, vm_page_free_count, vm_page_wire_count, 6);	/* (TEST/DEBUG) */
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 *	This page is no longer very interesting.  If it was
	 *	interesting (active or inactive/referenced), then we
	 *	clear the reference bit and (re)enter it in the
	 *	inactive queue.  Note wired pages should not have
	 *	their reference bit cleared.
	 */</span>
	assert ( !(m-&gt;absent &amp;&amp; !m-&gt;unusual));

	<span class="enscript-keyword">if</span> (m-&gt;gobbled) {		<span class="enscript-comment">/* can this happen? */</span>
		assert( !VM_PAGE_WIRED(m));

		<span class="enscript-keyword">if</span> (!m-&gt;private &amp;&amp; !m-&gt;fictitious)
			vm_page_wire_count--;
		vm_page_gobble_count--;
		m-&gt;gobbled = FALSE;
	}
	<span class="enscript-comment">/*
	 * if this page is currently on the pageout queue, we can't do the
	 * vm_page_queues_remove (which doesn't handle the pageout queue case)
	 * and we can't remove it manually since we would need the object lock
	 * (which is not required here) to decrement the activity_in_progress
	 * reference which is held on the object while the page is in the pageout queue...
	 * just let the normal laundry processing proceed
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;laundry || m-&gt;pageout_queue || m-&gt;private || m-&gt;fictitious || m-&gt;compressor || (VM_PAGE_WIRED(m)))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!m-&gt;absent &amp;&amp; clear_hw_reference == TRUE)
		pmap_clear_reference(m-&gt;phys_page);

	m-&gt;reference = FALSE;
	m-&gt;no_cache = FALSE;

	<span class="enscript-keyword">if</span> (!m-&gt;inactive) {
		vm_page_queues_remove(m);

		<span class="enscript-keyword">if</span> (!VM_DYNAMIC_PAGING_ENABLED(memory_manager_default) &amp;&amp;
		    m-&gt;dirty &amp;&amp; m-&gt;object-&gt;internal &amp;&amp;
		    (m-&gt;object-&gt;purgable == VM_PURGABLE_DENY ||
		     m-&gt;object-&gt;purgable == VM_PURGABLE_NONVOLATILE ||
		     m-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE)) {
			vm_page_check_pageable_safe(m);
			queue_enter(&amp;vm_page_queue_throttled, m, vm_page_t, pageq);
			m-&gt;throttled = TRUE;
			vm_page_throttled_count++;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (m-&gt;object-&gt;named &amp;&amp; m-&gt;object-&gt;ref_count == 1) {
			        vm_page_speculate(m, FALSE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
				vm_page_speculative_recreated++;
#<span class="enscript-reference">endif</span>
			} <span class="enscript-keyword">else</span> {
				vm_page_enqueue_inactive(m, FALSE);
			}
		}
	}
}

<span class="enscript-comment">/*
 * vm_page_enqueue_cleaned
 *
 * Put the page on the cleaned queue, mark it cleaned, etc.
 * Being on the cleaned queue (and having m-&gt;clean_queue set)
 * does ** NOT ** guarantee that the page is clean!
 *
 * Call with the queues lock held.
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_enqueue_cleaned</span>(vm_page_t m)
{
	assert(m-&gt;phys_page != vm_page_guard_addr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	assert( !(m-&gt;absent &amp;&amp; !m-&gt;unusual));

	<span class="enscript-keyword">if</span> (m-&gt;gobbled) {
		assert( !VM_PAGE_WIRED(m));
		<span class="enscript-keyword">if</span> (!m-&gt;private &amp;&amp; !m-&gt;fictitious)
			vm_page_wire_count--;
		vm_page_gobble_count--;
		m-&gt;gobbled = FALSE;
	}
	<span class="enscript-comment">/*
	 * if this page is currently on the pageout queue, we can't do the
	 * vm_page_queues_remove (which doesn't handle the pageout queue case)
	 * and we can't remove it manually since we would need the object lock
	 * (which is not required here) to decrement the activity_in_progress
	 * reference which is held on the object while the page is in the pageout queue...
	 * just let the normal laundry processing proceed
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;laundry || m-&gt;clean_queue || m-&gt;pageout_queue || m-&gt;private || m-&gt;fictitious)
		<span class="enscript-keyword">return</span>;

	vm_page_queues_remove(m);

	vm_page_check_pageable_safe(m);
	queue_enter(&amp;vm_page_queue_cleaned, m, vm_page_t, pageq);
	m-&gt;clean_queue = TRUE;
	vm_page_cleaned_count++;

	m-&gt;inactive = TRUE;
	vm_page_inactive_count++;
	<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal) {
		vm_page_pageable_internal_count++;
	} <span class="enscript-keyword">else</span> {
		vm_page_pageable_external_count++;
	}

	vm_pageout_enqueued_cleaned++;
}

<span class="enscript-comment">/*
 *	vm_page_activate:
 *
 *	Put the specified page on the active list (if appropriate).
 *
 *	The page queues must be locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_activate</span>(
	<span class="enscript-type">register</span> vm_page_t	m)
{
	VM_PAGE_CHECK(m);
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">FIXME_4778297</span>
	assert(m-&gt;object != kernel_object);
#<span class="enscript-reference">endif</span>
	assert(m-&gt;phys_page != vm_page_guard_addr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	assert( !(m-&gt;absent &amp;&amp; !m-&gt;unusual));

	<span class="enscript-keyword">if</span> (m-&gt;gobbled) {
		assert( !VM_PAGE_WIRED(m));
		<span class="enscript-keyword">if</span> (!m-&gt;private &amp;&amp; !m-&gt;fictitious)
			vm_page_wire_count--;
		vm_page_gobble_count--;
		m-&gt;gobbled = FALSE;
	}
	<span class="enscript-comment">/*
	 * if this page is currently on the pageout queue, we can't do the
	 * vm_page_queues_remove (which doesn't handle the pageout queue case)
	 * and we can't remove it manually since we would need the object lock
	 * (which is not required here) to decrement the activity_in_progress
	 * reference which is held on the object while the page is in the pageout queue...
	 * just let the normal laundry processing proceed
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;laundry || m-&gt;pageout_queue || m-&gt;private || m-&gt;fictitious || m-&gt;compressor)
		<span class="enscript-keyword">return</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (m-&gt;active)
	        panic(<span class="enscript-string">&quot;vm_page_activate: already active&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;speculative) {
		DTRACE_VM2(pgrec, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
		DTRACE_VM2(pgfrec, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);
	}
	
	vm_page_queues_remove(m);

	<span class="enscript-keyword">if</span> ( !VM_PAGE_WIRED(m)) {
		vm_page_check_pageable_safe(m);
		<span class="enscript-keyword">if</span> (!VM_DYNAMIC_PAGING_ENABLED(memory_manager_default) &amp;&amp; 
		    m-&gt;dirty &amp;&amp; m-&gt;object-&gt;internal &amp;&amp; 
		    (m-&gt;object-&gt;purgable == VM_PURGABLE_DENY ||
		     m-&gt;object-&gt;purgable == VM_PURGABLE_NONVOLATILE ||
		     m-&gt;object-&gt;purgable == VM_PURGABLE_VOLATILE)) {
			queue_enter(&amp;vm_page_queue_throttled, m, vm_page_t, pageq);
			m-&gt;throttled = TRUE;
			vm_page_throttled_count++;
		} <span class="enscript-keyword">else</span> {
			queue_enter(&amp;vm_page_queue_active, m, vm_page_t, pageq);
			m-&gt;active = TRUE;
			vm_page_active_count++;
			<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal) {
				vm_page_pageable_internal_count++;
			} <span class="enscript-keyword">else</span> {
				vm_page_pageable_external_count++;
			}
		}
		m-&gt;reference = TRUE;
		m-&gt;no_cache = FALSE;
	}
	VM_PAGE_CHECK(m);
}


<span class="enscript-comment">/*
 *      vm_page_speculate:
 *
 *      Put the specified page on the speculative list (if appropriate).
 *
 *      The page queues must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_speculate</span>(
	vm_page_t	m,
	boolean_t	new)
{
        <span class="enscript-type">struct</span> vm_speculative_age_q	*aq;

	VM_PAGE_CHECK(m);
	vm_page_check_pageable_safe(m);

	assert(m-&gt;phys_page != vm_page_guard_addr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	assert( !(m-&gt;absent &amp;&amp; !m-&gt;unusual));

	<span class="enscript-comment">/*
	 * if this page is currently on the pageout queue, we can't do the
	 * vm_page_queues_remove (which doesn't handle the pageout queue case)
	 * and we can't remove it manually since we would need the object lock
	 * (which is not required here) to decrement the activity_in_progress
	 * reference which is held on the object while the page is in the pageout queue...
	 * just let the normal laundry processing proceed
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;laundry || m-&gt;pageout_queue || m-&gt;private || m-&gt;fictitious || m-&gt;compressor)
		<span class="enscript-keyword">return</span>;

	vm_page_queues_remove(m);

	<span class="enscript-keyword">if</span> ( !VM_PAGE_WIRED(m)) {
	        mach_timespec_t		ts;
		clock_sec_t sec;
		clock_nsec_t nsec;

	        clock_get_system_nanotime(&amp;sec, &amp;nsec);
		ts.tv_sec = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) sec;
		ts.tv_nsec = nsec;

		<span class="enscript-keyword">if</span> (vm_page_speculative_count == 0) {

			speculative_age_index = VM_PAGE_MIN_SPECULATIVE_AGE_Q;
			speculative_steal_index = VM_PAGE_MIN_SPECULATIVE_AGE_Q;

			aq = &amp;vm_page_queue_speculative[speculative_age_index];

		        <span class="enscript-comment">/*
			 * set the timer to begin a new group
			 */</span>
			aq-&gt;age_ts.tv_sec = vm_page_speculative_q_age_ms / 1000;
			aq-&gt;age_ts.tv_nsec = (vm_page_speculative_q_age_ms % 1000) * 1000 * NSEC_PER_USEC;

			ADD_MACH_TIMESPEC(&amp;aq-&gt;age_ts, &amp;ts);
		} <span class="enscript-keyword">else</span> {
			aq = &amp;vm_page_queue_speculative[speculative_age_index];

			<span class="enscript-keyword">if</span> (CMP_MACH_TIMESPEC(&amp;ts, &amp;aq-&gt;age_ts) &gt;= 0) {

			        speculative_age_index++;

				<span class="enscript-keyword">if</span> (speculative_age_index &gt; VM_PAGE_MAX_SPECULATIVE_AGE_Q)
				        speculative_age_index = VM_PAGE_MIN_SPECULATIVE_AGE_Q;
				<span class="enscript-keyword">if</span> (speculative_age_index == speculative_steal_index) {
				        speculative_steal_index = speculative_age_index + 1;

					<span class="enscript-keyword">if</span> (speculative_steal_index &gt; VM_PAGE_MAX_SPECULATIVE_AGE_Q)
					        speculative_steal_index = VM_PAGE_MIN_SPECULATIVE_AGE_Q;
				}
				aq = &amp;vm_page_queue_speculative[speculative_age_index];

				<span class="enscript-keyword">if</span> (!queue_empty(&amp;aq-&gt;age_q))
				        vm_page_speculate_ageit(aq);

				aq-&gt;age_ts.tv_sec = vm_page_speculative_q_age_ms / 1000;
				aq-&gt;age_ts.tv_nsec = (vm_page_speculative_q_age_ms % 1000) * 1000 * NSEC_PER_USEC;

				ADD_MACH_TIMESPEC(&amp;aq-&gt;age_ts, &amp;ts);
			}
		}
		enqueue_tail(&amp;aq-&gt;age_q, &amp;m-&gt;pageq);
		m-&gt;speculative = TRUE;
		vm_page_speculative_count++;
		<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal) {
			vm_page_pageable_internal_count++;
		} <span class="enscript-keyword">else</span> {
			vm_page_pageable_external_count++;
		}

		<span class="enscript-keyword">if</span> (new == TRUE) {
			vm_object_lock_assert_exclusive(m-&gt;object);

		        m-&gt;object-&gt;pages_created++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
			vm_page_speculative_created++;
#<span class="enscript-reference">endif</span>
		}
	}
	VM_PAGE_CHECK(m);
}


<span class="enscript-comment">/*
 * move pages from the specified aging bin to
 * the speculative bin that pageout_scan claims from
 *
 *      The page queues must be locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_speculate_ageit</span>(<span class="enscript-type">struct</span> vm_speculative_age_q *aq)
{
        <span class="enscript-type">struct</span> vm_speculative_age_q	*sq;
	vm_page_t	t;

	sq = &amp;vm_page_queue_speculative[VM_PAGE_SPECULATIVE_AGED_Q];

	<span class="enscript-keyword">if</span> (queue_empty(&amp;sq-&gt;age_q)) {
	        sq-&gt;age_q.next = aq-&gt;age_q.next;
		sq-&gt;age_q.prev = aq-&gt;age_q.prev;
		
		t = (vm_page_t)sq-&gt;age_q.next;
		t-&gt;pageq.prev = &amp;sq-&gt;age_q;

		t = (vm_page_t)sq-&gt;age_q.prev;
		t-&gt;pageq.next = &amp;sq-&gt;age_q;
	} <span class="enscript-keyword">else</span> {
	        t = (vm_page_t)sq-&gt;age_q.prev;
		t-&gt;pageq.next = aq-&gt;age_q.next;
						
		t = (vm_page_t)aq-&gt;age_q.next;
		t-&gt;pageq.prev = sq-&gt;age_q.prev;

		t = (vm_page_t)aq-&gt;age_q.prev;
		t-&gt;pageq.next = &amp;sq-&gt;age_q;

		sq-&gt;age_q.prev = aq-&gt;age_q.prev;
	}
	queue_init(&amp;aq-&gt;age_q);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_lru</span>(
	vm_page_t	m)
{
	VM_PAGE_CHECK(m);
	assert(m-&gt;object != kernel_object);
	assert(m-&gt;phys_page != vm_page_guard_addr);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * if this page is currently on the pageout queue, we can't do the
	 * vm_page_queues_remove (which doesn't handle the pageout queue case)
	 * and we can't remove it manually since we would need the object lock
	 * (which is not required here) to decrement the activity_in_progress
	 * reference which is held on the object while the page is in the pageout queue...
	 * just let the normal laundry processing proceed
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;laundry || m-&gt;pageout_queue || m-&gt;private || m-&gt;compressor || (VM_PAGE_WIRED(m)))
		<span class="enscript-keyword">return</span>;

	m-&gt;no_cache = FALSE;

	vm_page_queues_remove(m);

	vm_page_enqueue_inactive(m, FALSE);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_reactivate_all_throttled</span>(<span class="enscript-type">void</span>)
{
	vm_page_t	first_throttled, last_throttled;
	vm_page_t	first_active;
	vm_page_t	m;
	<span class="enscript-type">int</span>		extra_active_count;
	<span class="enscript-type">int</span>		extra_internal_count, extra_external_count;

	<span class="enscript-keyword">if</span> (!VM_DYNAMIC_PAGING_ENABLED(memory_manager_default))
		<span class="enscript-keyword">return</span>;

	extra_active_count = 0;
	extra_internal_count = 0;
	extra_external_count = 0;
	vm_page_lock_queues();
	<span class="enscript-keyword">if</span> (! queue_empty(&amp;vm_page_queue_throttled)) {
		<span class="enscript-comment">/*
		 * Switch &quot;throttled&quot; pages to &quot;active&quot;.
		 */</span>
		queue_iterate(&amp;vm_page_queue_throttled, m, vm_page_t, pageq) {
			VM_PAGE_CHECK(m);
			assert(m-&gt;throttled);
			assert(!m-&gt;active);
			assert(!m-&gt;inactive);
			assert(!m-&gt;speculative);
			assert(!VM_PAGE_WIRED(m));

			extra_active_count++;
			<span class="enscript-keyword">if</span> (m-&gt;object-&gt;internal) {
				extra_internal_count++;
			} <span class="enscript-keyword">else</span> {
				extra_external_count++;
			}

			m-&gt;throttled = FALSE;
			m-&gt;active = TRUE;
			VM_PAGE_CHECK(m);
		}

		<span class="enscript-comment">/*
		 * Transfer the entire throttled queue to a regular LRU page queues.
		 * We insert it at the head of the active queue, so that these pages
		 * get re-evaluated by the LRU algorithm first, since they've been
		 * completely out of it until now.
		 */</span>
		first_throttled = (vm_page_t) queue_first(&amp;vm_page_queue_throttled);
		last_throttled = (vm_page_t) queue_last(&amp;vm_page_queue_throttled);
		first_active = (vm_page_t) queue_first(&amp;vm_page_queue_active);
		<span class="enscript-keyword">if</span> (queue_empty(&amp;vm_page_queue_active)) {
			queue_last(&amp;vm_page_queue_active) = (queue_entry_t) last_throttled;
		} <span class="enscript-keyword">else</span> {
			queue_prev(&amp;first_active-&gt;pageq) = (queue_entry_t) last_throttled;
		}
		queue_first(&amp;vm_page_queue_active) = (queue_entry_t) first_throttled;
		queue_prev(&amp;first_throttled-&gt;pageq) = (queue_entry_t) &amp;vm_page_queue_active;
		queue_next(&amp;last_throttled-&gt;pageq) = (queue_entry_t) first_active;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		printf(<span class="enscript-string">&quot;reactivated %d throttled pages\n&quot;</span>, vm_page_throttled_count);
#<span class="enscript-reference">endif</span>
		queue_init(&amp;vm_page_queue_throttled);
		<span class="enscript-comment">/*
		 * Adjust the global page counts.
		 */</span>
		vm_page_active_count += extra_active_count;
		vm_page_pageable_internal_count += extra_internal_count;
		vm_page_pageable_external_count += extra_external_count;
		vm_page_throttled_count = 0;
	}
	assert(vm_page_throttled_count == 0);
	assert(queue_empty(&amp;vm_page_queue_throttled));
	vm_page_unlock_queues();
}


<span class="enscript-comment">/*
 * move pages from the indicated local queue to the global active queue
 * its ok to fail if we're below the hard limit and force == FALSE
 * the nolocks == TRUE case is to allow this function to be run on
 * the hibernate path
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_reactivate_local</span>(uint32_t lid, boolean_t force, boolean_t nolocks)
{
	<span class="enscript-type">struct</span> vpl	*lq;
	vm_page_t	first_local, last_local;
	vm_page_t	first_active;
	vm_page_t	m;
	uint32_t	count = 0;

	<span class="enscript-keyword">if</span> (vm_page_local_q == NULL)
		<span class="enscript-keyword">return</span>;

	lq = &amp;vm_page_local_q[lid].vpl_un.vpl;

	<span class="enscript-keyword">if</span> (nolocks == FALSE) {
		<span class="enscript-keyword">if</span> (lq-&gt;vpl_count &lt; vm_page_local_q_hard_limit &amp;&amp; force == FALSE) {
			<span class="enscript-keyword">if</span> ( !vm_page_trylockspin_queues())
				<span class="enscript-keyword">return</span>;
		} <span class="enscript-keyword">else</span>
			vm_page_lockspin_queues();

		VPL_LOCK(&amp;lq-&gt;vpl_lock);
	}
	<span class="enscript-keyword">if</span> (lq-&gt;vpl_count) {
		<span class="enscript-comment">/*
		 * Switch &quot;local&quot; pages to &quot;active&quot;.
		 */</span>
		assert(!queue_empty(&amp;lq-&gt;vpl_queue));

		queue_iterate(&amp;lq-&gt;vpl_queue, m, vm_page_t, pageq) {
			VM_PAGE_CHECK(m);
			vm_page_check_pageable_safe(m);
			assert(m-&gt;local);
			assert(!m-&gt;active);
			assert(!m-&gt;inactive);
			assert(!m-&gt;speculative);
			assert(!VM_PAGE_WIRED(m));
			assert(!m-&gt;throttled);
			assert(!m-&gt;fictitious);

			<span class="enscript-keyword">if</span> (m-&gt;local_id != lid)
				panic(<span class="enscript-string">&quot;vm_page_reactivate_local: found vm_page_t(%p) with wrong cpuid&quot;</span>, m);
			
			m-&gt;local_id = 0;
			m-&gt;local = FALSE;
			m-&gt;active = TRUE;
			VM_PAGE_CHECK(m);

			count++;
		}
		<span class="enscript-keyword">if</span> (count != lq-&gt;vpl_count)
			panic(<span class="enscript-string">&quot;vm_page_reactivate_local: count = %d, vm_page_local_count = %d\n&quot;</span>, count, lq-&gt;vpl_count);

		<span class="enscript-comment">/*
		 * Transfer the entire local queue to a regular LRU page queues.
		 */</span>
		first_local = (vm_page_t) queue_first(&amp;lq-&gt;vpl_queue);
		last_local = (vm_page_t) queue_last(&amp;lq-&gt;vpl_queue);
		first_active = (vm_page_t) queue_first(&amp;vm_page_queue_active);

		<span class="enscript-keyword">if</span> (queue_empty(&amp;vm_page_queue_active)) {
			queue_last(&amp;vm_page_queue_active) = (queue_entry_t) last_local;
		} <span class="enscript-keyword">else</span> {
			queue_prev(&amp;first_active-&gt;pageq) = (queue_entry_t) last_local;
		}
		queue_first(&amp;vm_page_queue_active) = (queue_entry_t) first_local;
		queue_prev(&amp;first_local-&gt;pageq) = (queue_entry_t) &amp;vm_page_queue_active;
		queue_next(&amp;last_local-&gt;pageq) = (queue_entry_t) first_active;

		queue_init(&amp;lq-&gt;vpl_queue);
		<span class="enscript-comment">/*
		 * Adjust the global page counts.
		 */</span>
		vm_page_active_count += lq-&gt;vpl_count;
		vm_page_pageable_internal_count += lq-&gt;vpl_internal_count;
		vm_page_pageable_external_count += lq-&gt;vpl_external_count;
		lq-&gt;vpl_count = 0;
		lq-&gt;vpl_internal_count = 0;
		lq-&gt;vpl_external_count = 0;
	}
	assert(queue_empty(&amp;lq-&gt;vpl_queue));

	<span class="enscript-keyword">if</span> (nolocks == FALSE) {
		VPL_UNLOCK(&amp;lq-&gt;vpl_lock);
		vm_page_unlock_queues();
	}
}

<span class="enscript-comment">/*
 *	vm_page_part_zero_fill:
 *
 *	Zero-fill a part of the page.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_ZERO_PART_PAGE_IMPLEMENTED</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_part_zero_fill</span>(
	vm_page_t	m,
	vm_offset_t	m_pa,
	vm_size_t	len)
{

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we don't hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(m);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PMAP_ZERO_PART_PAGE_IMPLEMENTED</span>
	pmap_zero_part_page(m-&gt;phys_page, m_pa, len);
#<span class="enscript-reference">else</span>
	vm_page_t	tmp;
	<span class="enscript-keyword">while</span> (1) {
       		tmp = vm_page_grab();
		<span class="enscript-keyword">if</span> (tmp == VM_PAGE_NULL) {
			vm_page_wait(THREAD_UNINT);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">break</span>;  
	}
	vm_page_zero_fill(tmp);
	<span class="enscript-keyword">if</span>(m_pa != 0) {
		vm_page_part_copy(m, 0, tmp, 0, m_pa);
	}
	<span class="enscript-keyword">if</span>((m_pa + len) &lt;  PAGE_SIZE) {
		vm_page_part_copy(m, m_pa + len, tmp, 
				m_pa + len, PAGE_SIZE - (m_pa + len));
	}
	vm_page_copy(tmp,m);
	VM_PAGE_FREE(tmp); 
#<span class="enscript-reference">endif</span>

}

<span class="enscript-comment">/*
 *	vm_page_zero_fill:
 *
 *	Zero-fill the specified page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_zero_fill</span>(
	vm_page_t	m)
{
        XPR(XPR_VM_PAGE,
                <span class="enscript-string">&quot;vm_page_zero_fill, object 0x%X offset 0x%X page 0x%X\n&quot;</span>,
                m-&gt;object, m-&gt;offset, m, 0,0);
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we don't hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(m);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//	dbgTrace(0xAEAEAEAE, m-&gt;phys_page, 0);		/* (BRINGUP) */
</span>	pmap_zero_page(m-&gt;phys_page);
}

<span class="enscript-comment">/*
 *	vm_page_part_copy:
 *
 *	copy part of one page to another
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_part_copy</span>(
	vm_page_t	src_m,
	vm_offset_t	src_pa,
	vm_page_t	dst_m,
	vm_offset_t	dst_pa,
	vm_size_t	len)
{
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we don't hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(src_m);
	VM_PAGE_CHECK(dst_m);
#<span class="enscript-reference">endif</span>
	pmap_copy_part_page(src_m-&gt;phys_page, src_pa,
			dst_m-&gt;phys_page, dst_pa, len);
}

<span class="enscript-comment">/*
 *	vm_page_copy:
 *
 *	Copy one page to another
 *
 * ENCRYPTED SWAP:
 * The source page should not be encrypted.  The caller should
 * make sure the page is decrypted first, if necessary.
 */</span>

<span class="enscript-type">int</span> vm_page_copy_cs_validations = 0;
<span class="enscript-type">int</span> vm_page_copy_cs_tainted = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_copy</span>(
	vm_page_t	src_m,
	vm_page_t	dest_m)
{
        XPR(XPR_VM_PAGE,
        <span class="enscript-string">&quot;vm_page_copy, object 0x%X offset 0x%X to object 0x%X offset 0x%X\n&quot;</span>,
        src_m-&gt;object, src_m-&gt;offset, 
	dest_m-&gt;object, dest_m-&gt;offset,
	0);
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * we don't hold the page queue lock
	 * so this check isn't safe to make
	 */</span>
	VM_PAGE_CHECK(src_m);
	VM_PAGE_CHECK(dest_m);
#<span class="enscript-reference">endif</span>
	vm_object_lock_assert_held(src_m-&gt;object);

	<span class="enscript-comment">/*
	 * ENCRYPTED SWAP:
	 * The source page should not be encrypted at this point.
	 * The destination page will therefore not contain encrypted
	 * data after the copy.
	 */</span>
	<span class="enscript-keyword">if</span> (src_m-&gt;encrypted) {
		panic(<span class="enscript-string">&quot;vm_page_copy: source page %p is encrypted\n&quot;</span>, src_m);
	}
	dest_m-&gt;encrypted = FALSE;

	<span class="enscript-keyword">if</span> (src_m-&gt;object != VM_OBJECT_NULL &amp;&amp;
	    src_m-&gt;object-&gt;code_signed) {
		<span class="enscript-comment">/*
		 * We're copying a page from a code-signed object.
		 * Whoever ends up mapping the copy page might care about
		 * the original page's integrity, so let's validate the
		 * source page now.
		 */</span>
		vm_page_copy_cs_validations++;
		vm_page_validate_cs(src_m);
	}

	<span class="enscript-keyword">if</span> (vm_page_is_slideable(src_m)) {
		boolean_t was_busy = src_m-&gt;busy;
		src_m-&gt;busy = TRUE;
		(<span class="enscript-type">void</span>) vm_page_slide(src_m, 0);
		assert(src_m-&gt;busy);
		<span class="enscript-keyword">if</span> (!was_busy) {
			PAGE_WAKEUP_DONE(src_m);
		}
	}

	<span class="enscript-comment">/*
	 * Propagate the cs_tainted bit to the copy page. Do not propagate
	 * the cs_validated bit.
	 */</span>
	dest_m-&gt;cs_tainted = src_m-&gt;cs_tainted;
	<span class="enscript-keyword">if</span> (dest_m-&gt;cs_tainted) {
		vm_page_copy_cs_tainted++;
	}
	dest_m-&gt;slid = src_m-&gt;slid;
	dest_m-&gt;error = src_m-&gt;error; <span class="enscript-comment">/* sliding src_m might have failed... */</span>
	pmap_copy_page(src_m-&gt;phys_page, dest_m-&gt;phys_page);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_vm_page_print</span>(
	vm_page_t	p)
{
	printf(<span class="enscript-string">&quot;vm_page %p: \n&quot;</span>, p);
	printf(<span class="enscript-string">&quot;  pageq: next=%p prev=%p\n&quot;</span>, p-&gt;pageq.next, p-&gt;pageq.prev);
	printf(<span class="enscript-string">&quot;  listq: next=%p prev=%p\n&quot;</span>, p-&gt;listq.next, p-&gt;listq.prev);
	printf(<span class="enscript-string">&quot;  next=%p\n&quot;</span>, VM_PAGE_UNPACK_PTR(p-&gt;next_m));
	printf(<span class="enscript-string">&quot;  object=%p offset=0x%llx\n&quot;</span>, p-&gt;object, p-&gt;offset);
	printf(<span class="enscript-string">&quot;  wire_count=%u\n&quot;</span>, p-&gt;wire_count);

	printf(<span class="enscript-string">&quot;  %slocal, %sinactive, %sactive, %spageout_queue, %sspeculative, %slaundry\n&quot;</span>,
	       (p-&gt;local ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;inactive ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;active ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;pageout_queue ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;speculative ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;laundry ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>));
	printf(<span class="enscript-string">&quot;  %sfree, %sref, %sgobbled, %sprivate, %sthrottled\n&quot;</span>,
	       (p-&gt;free ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;reference ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;gobbled ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;private ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;throttled ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>));
	printf(<span class="enscript-string">&quot;  %sbusy, %swanted, %stabled, %sfictitious, %spmapped, %swpmapped\n&quot;</span>,
		(p-&gt;busy ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
		(p-&gt;wanted ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
		(p-&gt;tabled ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
		(p-&gt;fictitious ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
		(p-&gt;pmapped ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
		(p-&gt;wpmapped ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>));
	printf(<span class="enscript-string">&quot;  %spageout, %sabsent, %serror, %sdirty, %scleaning, %sprecious, %sclustered\n&quot;</span>,
	       (p-&gt;pageout ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;absent ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;error ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;dirty ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;cleaning ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;precious ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;clustered ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>));
	printf(<span class="enscript-string">&quot;  %soverwriting, %srestart, %sunusual, %sencrypted, %sencrypted_cleaning\n&quot;</span>,
	       (p-&gt;overwriting ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;restart ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;unusual ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;encrypted ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;encrypted_cleaning ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>));
	printf(<span class="enscript-string">&quot;  %scs_validated, %scs_tainted, %scs_nx, %sno_cache\n&quot;</span>,
	       (p-&gt;cs_validated ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;cs_tainted ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;cs_nx ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>),
	       (p-&gt;no_cache ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;!&quot;</span>));

	printf(<span class="enscript-string">&quot;phys_page=0x%x\n&quot;</span>, p-&gt;phys_page);
}

<span class="enscript-comment">/*
 *	Check that the list of pages is ordered by
 *	ascending physical address and has no holes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_page_verify_contiguous</span>(
	vm_page_t	pages,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	npages)
{
	<span class="enscript-type">register</span> vm_page_t	m;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		page_count;
	vm_offset_t		prev_addr;

	prev_addr = pages-&gt;phys_page;
	page_count = 1;
	<span class="enscript-keyword">for</span> (m = NEXT_PAGE(pages); m != VM_PAGE_NULL; m = NEXT_PAGE(m)) {
		<span class="enscript-keyword">if</span> (m-&gt;phys_page != prev_addr + 1) {
			printf(<span class="enscript-string">&quot;m %p prev_addr 0x%lx, current addr 0x%x\n&quot;</span>,
			       m, (<span class="enscript-type">long</span>)prev_addr, m-&gt;phys_page);
			printf(<span class="enscript-string">&quot;pages %p page_count %d npages %d\n&quot;</span>, pages, page_count, npages);
			panic(<span class="enscript-string">&quot;vm_page_verify_contiguous:  not contiguous!&quot;</span>);
		}
		prev_addr = m-&gt;phys_page;
		++page_count;
	}
	<span class="enscript-keyword">if</span> (page_count != npages) {
		printf(<span class="enscript-string">&quot;pages %p actual count 0x%x but requested 0x%x\n&quot;</span>,
		       pages, page_count, npages);
		panic(<span class="enscript-string">&quot;vm_page_verify_contiguous:  count error&quot;</span>);
	}
	<span class="enscript-keyword">return</span> 1;
}


<span class="enscript-comment">/*
 *	Check the free lists for proper length etc.
 */</span>
<span class="enscript-type">static</span> boolean_t vm_page_verify_this_free_list_enabled = FALSE;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_page_verify_free_list</span>(
	queue_head_t	*vm_page_queue,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	color,
	vm_page_t	look_for_page,
	boolean_t	expect_page)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	npages;
	vm_page_t	m;
	vm_page_t	prev_m;
	boolean_t	found_page;

	<span class="enscript-keyword">if</span> (! vm_page_verify_this_free_list_enabled)
		<span class="enscript-keyword">return</span> 0;

	found_page = FALSE;
	npages = 0;
	prev_m = (vm_page_t) vm_page_queue;
	queue_iterate(vm_page_queue,
		      m,
		      vm_page_t,
		      pageq) {

		<span class="enscript-keyword">if</span> (m == look_for_page) {
			found_page = TRUE;
		}
		<span class="enscript-keyword">if</span> ((vm_page_t) m-&gt;pageq.prev != prev_m)
			panic(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u, npages=%u): page %p corrupted prev ptr %p instead of %p\n&quot;</span>,
			      color, npages, m, m-&gt;pageq.prev, prev_m);
		<span class="enscript-keyword">if</span> ( ! m-&gt;busy )
			panic(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u, npages=%u): page %p not busy\n&quot;</span>,
			      color, npages, m);
		<span class="enscript-keyword">if</span> (color != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1) {
			<span class="enscript-keyword">if</span> ((m-&gt;phys_page &amp; vm_color_mask) != color)
				panic(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u, npages=%u): page %p wrong color %u instead of %u\n&quot;</span>,
				      color, npages, m, m-&gt;phys_page &amp; vm_color_mask, color);
			<span class="enscript-keyword">if</span> ( ! m-&gt;free )
				panic(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u, npages=%u): page %p not free\n&quot;</span>,
				      color, npages, m);
		}
		++npages;
		prev_m = m;
	}
	<span class="enscript-keyword">if</span> (look_for_page != VM_PAGE_NULL) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> other_color;

		<span class="enscript-keyword">if</span> (expect_page &amp;&amp; !found_page) {
			printf(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u, npages=%u): page %p not found phys=%u\n&quot;</span>,
			       color, npages, look_for_page, look_for_page-&gt;phys_page);
			_vm_page_print(look_for_page);
			<span class="enscript-keyword">for</span> (other_color = 0;
			     other_color &lt; vm_colors;
			     other_color++) {
				<span class="enscript-keyword">if</span> (other_color == color)
					<span class="enscript-keyword">continue</span>;
				vm_page_verify_free_list(&amp;vm_page_queue_free[other_color],
							 other_color, look_for_page, FALSE);
			}
			<span class="enscript-keyword">if</span> (color == (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1) {
				vm_page_verify_free_list(&amp;vm_lopage_queue_free,
							 (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1, look_for_page, FALSE);
			}
			panic(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u)\n&quot;</span>, color);
		}
		<span class="enscript-keyword">if</span> (!expect_page &amp;&amp; found_page) {
			printf(<span class="enscript-string">&quot;vm_page_verify_free_list(color=%u, npages=%u): page %p found phys=%u\n&quot;</span>,
			       color, npages, look_for_page, look_for_page-&gt;phys_page);
		}
	}
	<span class="enscript-keyword">return</span> npages;
}

<span class="enscript-type">static</span> boolean_t vm_page_verify_all_free_lists_enabled = FALSE;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_verify_free_lists</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	color, npages, nlopages;
	boolean_t	toggle = TRUE;

	<span class="enscript-keyword">if</span> (! vm_page_verify_all_free_lists_enabled)
		<span class="enscript-keyword">return</span>;

	npages = 0;

	lck_mtx_lock(&amp;vm_page_queue_free_lock);
	
	<span class="enscript-keyword">if</span> (vm_page_verify_this_free_list_enabled == TRUE) {
		<span class="enscript-comment">/*
		 * This variable has been set globally for extra checking of
		 * each free list Q. Since we didn't set it, we don't own it
		 * and we shouldn't toggle it.
		 */</span>
		toggle = FALSE;
	}

	<span class="enscript-keyword">if</span> (toggle == TRUE) {
		vm_page_verify_this_free_list_enabled = TRUE;
	}

	<span class="enscript-keyword">for</span>( color = 0; color &lt; vm_colors; color++ ) {
		npages += vm_page_verify_free_list(&amp;vm_page_queue_free[color],
						   color, VM_PAGE_NULL, FALSE);
	}
	nlopages = vm_page_verify_free_list(&amp;vm_lopage_queue_free,
					    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1,
					    VM_PAGE_NULL, FALSE);
	<span class="enscript-keyword">if</span> (npages != vm_page_free_count || nlopages != vm_lopage_free_count)
		panic(<span class="enscript-string">&quot;vm_page_verify_free_lists:  &quot;</span>
		      <span class="enscript-string">&quot;npages %u free_count %d nlopages %u lo_free_count %u&quot;</span>,
		      npages, vm_page_free_count, nlopages, vm_lopage_free_count);

	<span class="enscript-keyword">if</span> (toggle == TRUE) {
		vm_page_verify_this_free_list_enabled = FALSE;
	}

	lck_mtx_unlock(&amp;vm_page_queue_free_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_queues_assert</span>(
	vm_page_t	mem,
	<span class="enscript-type">int</span>		val)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(&amp;vm_page_queue_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (mem-&gt;free + mem-&gt;active + mem-&gt;inactive + mem-&gt;speculative +
	    mem-&gt;throttled + mem-&gt;pageout_queue &gt; (val)) {
		_vm_page_print(mem);
		panic(<span class="enscript-string">&quot;vm_page_queues_assert(%p, %d)\n&quot;</span>, mem, val);
	}
	<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(mem)) {
		assert(!mem-&gt;active);
		assert(!mem-&gt;inactive);
		assert(!mem-&gt;speculative);
		assert(!mem-&gt;throttled);
		assert(!mem-&gt;pageout_queue);
	}
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>





<span class="enscript-type">extern</span> <span class="enscript-function-name">boolean_t</span> (* <span class="enscript-type">volatile</span> consider_buffer_cache_collect)(<span class="enscript-type">int</span>);

<span class="enscript-comment">/*
 *	CONTIGUOUS PAGE ALLOCATION
 *
 *	Find a region large enough to contain at least n pages
 *	of contiguous physical memory.
 *
 *	This is done by traversing the vm_page_t array in a linear fashion
 *	we assume that the vm_page_t array has the avaiable physical pages in an
 *	ordered, ascending list... this is currently true of all our implementations
 * 	and must remain so... there can be 'holes' in the array...  we also can
 *	no longer tolerate the vm_page_t's in the list being 'freed' and reclaimed
 * 	which use to happen via 'vm_page_convert'... that function was no longer
 * 	being called and was removed...
 *	
 *	The basic flow consists of stabilizing some of the interesting state of 
 *	a vm_page_t behind the vm_page_queue and vm_page_free locks... we start our
 *	sweep at the beginning of the array looking for pages that meet our criterea
 *	for a 'stealable' page... currently we are pretty conservative... if the page
 *	meets this criterea and is physically contiguous to the previous page in the 'run'
 * 	we keep developing it.  If we hit a page that doesn't fit, we reset our state
 *	and start to develop a new run... if at this point we've already considered
 * 	at least MAX_CONSIDERED_BEFORE_YIELD pages, we'll drop the 2 locks we hold,
 *	and mutex_pause (which will yield the processor), to keep the latency low w/r 
 *	to other threads trying to acquire free pages (or move pages from q to q),
 *	and then continue from the spot we left off... we only make 1 pass through the
 *	array.  Once we have a 'run' that is long enough, we'll go into the loop which
 * 	which steals the pages from the queues they're currently on... pages on the free
 *	queue can be stolen directly... pages that are on any of the other queues
 *	must be removed from the object they are tabled on... this requires taking the
 * 	object lock... we do this as a 'try' to prevent deadlocks... if the 'try' fails
 *	or if the state of the page behind the vm_object lock is no longer viable, we'll
 *	dump the pages we've currently stolen back to the free list, and pick up our
 *	scan from the point where we aborted the 'current' run.
 *
 *
 *	Requirements:
 *		- neither vm_page_queue nor vm_free_list lock can be held on entry
 *
 *	Returns a pointer to a list of gobbled/wired pages or VM_PAGE_NULL.
 *
 * Algorithm:
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_CONSIDERED_BEFORE_YIELD</span>	1000


#<span class="enscript-reference">define</span> <span class="enscript-function-name">RESET_STATE_OF_RUN</span>()	\
	MACRO_BEGIN		\
	prevcontaddr = -2;	\
	start_pnum = -1;	\
	free_considered = 0;	\
	substitute_needed = 0;	\
	npages = 0;		\
	MACRO_END			

<span class="enscript-comment">/*
 * Can we steal in-use (i.e. not free) pages when searching for
 * physically-contiguous pages ?
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_FIND_CONTIGUOUS_CAN_STEAL</span> 1

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_find_contiguous_last_idx = 0,  vm_page_lomem_find_contiguous_last_idx = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">int</span> vm_page_find_contig_debug = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> vm_page_t
<span class="enscript-function-name">vm_page_find_contiguous</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	contig_pages,
	ppnum_t		max_pnum,
	ppnum_t     pnum_mask,
	boolean_t	wire,
	<span class="enscript-type">int</span>		flags)
{
	vm_page_t	m = NULL;
	ppnum_t		prevcontaddr;
	ppnum_t		start_pnum;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	npages, considered, scanned;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	page_idx, start_idx, last_idx, orig_last_idx;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	idx_last_contig_page_found = 0;
	<span class="enscript-type">int</span>		free_considered, free_available;
	<span class="enscript-type">int</span>		substitute_needed;
	boolean_t	wrapped, zone_gc_called = FALSE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	clock_sec_t	tv_start_sec, tv_end_sec;
	clock_usec_t	tv_start_usec, tv_end_usec;
#<span class="enscript-reference">endif</span>

	<span class="enscript-type">int</span>		yielded = 0;
	<span class="enscript-type">int</span>		dumped_run = 0;
	<span class="enscript-type">int</span>		stolen_pages = 0;
	<span class="enscript-type">int</span>		compressed_pages = 0;


	<span class="enscript-keyword">if</span> (contig_pages == 0)
		<span class="enscript-keyword">return</span> VM_PAGE_NULL;

<span class="enscript-reference">full_scan_again</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	vm_page_verify_free_lists();
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	clock_get_system_microtime(&amp;tv_start_sec, &amp;tv_start_usec);
#<span class="enscript-reference">endif</span>
	PAGE_REPLACEMENT_ALLOWED(TRUE);

	vm_page_lock_queues();


	lck_mtx_lock(&amp;vm_page_queue_free_lock);

	RESET_STATE_OF_RUN();

	scanned = 0;
	considered = 0;
	free_available = vm_page_free_count - vm_page_free_reserved;

	wrapped = FALSE;
	
	<span class="enscript-keyword">if</span>(flags &amp; KMA_LOMEM) 
		idx_last_contig_page_found = vm_page_lomem_find_contiguous_last_idx;
	<span class="enscript-keyword">else</span>
		idx_last_contig_page_found =  vm_page_find_contiguous_last_idx;

	orig_last_idx = idx_last_contig_page_found;
	last_idx = orig_last_idx;

	<span class="enscript-keyword">for</span> (page_idx = last_idx, start_idx = last_idx;
	     npages &lt; contig_pages &amp;&amp; page_idx &lt; vm_pages_count;
	     page_idx++) {
<span class="enscript-reference">retry</span>:
		<span class="enscript-keyword">if</span> (wrapped &amp;&amp;
		    npages == 0 &amp;&amp;
		    page_idx &gt;= orig_last_idx) {
			<span class="enscript-comment">/*
			 * We're back where we started and we haven't
			 * found any suitable contiguous range.  Let's
			 * give up.
			 */</span>
			<span class="enscript-keyword">break</span>;
		}
		scanned++;
		m = &amp;vm_pages[page_idx];

		assert(!m-&gt;fictitious);
		assert(!m-&gt;private);

		<span class="enscript-keyword">if</span> (max_pnum &amp;&amp; m-&gt;phys_page &gt; max_pnum) {
			<span class="enscript-comment">/* no more low pages... */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (!npages &amp; ((m-&gt;phys_page &amp; pnum_mask) != 0)) {
			<span class="enscript-comment">/*
			 * not aligned
			 */</span>
			RESET_STATE_OF_RUN();

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VM_PAGE_WIRED(m) || m-&gt;gobbled ||
			   m-&gt;encrypted_cleaning ||
			   m-&gt;pageout_queue || m-&gt;laundry || m-&gt;wanted ||
			   m-&gt;cleaning || m-&gt;overwriting || m-&gt;pageout) {
			<span class="enscript-comment">/*
			 * page is in a transient state
			 * or a state we don't want to deal
			 * with, so don't consider it which
			 * means starting a new run
			 */</span>
			RESET_STATE_OF_RUN();

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!m-&gt;free &amp;&amp; !m-&gt;active &amp;&amp; !m-&gt;inactive &amp;&amp; !m-&gt;speculative &amp;&amp; !m-&gt;throttled &amp;&amp; !m-&gt;compressor) {
			<span class="enscript-comment">/*
			 * page needs to be on one of our queues
			 * or it needs to belong to the compressor pool
			 * in order for it to be stable behind the
			 * locks we hold at this point...
			 * if not, don't consider it which
			 * means starting a new run
			 */</span>
			RESET_STATE_OF_RUN();

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!m-&gt;free &amp;&amp; (!m-&gt;tabled || m-&gt;busy)) {
			<span class="enscript-comment">/*
			 * pages on the free list are always 'busy'
			 * so we couldn't test for 'busy' in the check
			 * for the transient states... pages that are
			 * 'free' are never 'tabled', so we also couldn't
			 * test for 'tabled'.  So we check here to make
			 * sure that a non-free page is not busy and is
			 * tabled on an object... 
			 * if not, don't consider it which
			 * means starting a new run
			 */</span>
			RESET_STATE_OF_RUN();

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (m-&gt;phys_page != prevcontaddr + 1) {
				<span class="enscript-keyword">if</span> ((m-&gt;phys_page &amp; pnum_mask) != 0) {
					RESET_STATE_OF_RUN();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">did_consider</span>;
				} <span class="enscript-keyword">else</span> {
					npages = 1;
					start_idx = page_idx;
					start_pnum = m-&gt;phys_page;
				}
			} <span class="enscript-keyword">else</span> {
				npages++;
			}
			prevcontaddr = m-&gt;phys_page;
			
			VM_PAGE_CHECK(m);
			<span class="enscript-keyword">if</span> (m-&gt;free) {
				free_considered++;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * This page is not free.
				 * If we can't steal used pages,
				 * we have to give up this run
				 * and keep looking.
				 * Otherwise, we might need to
				 * move the contents of this page
				 * into a substitute page.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_FIND_CONTIGUOUS_CAN_STEAL</span>
				<span class="enscript-keyword">if</span> (m-&gt;pmapped || m-&gt;dirty || m-&gt;precious) {
					substitute_needed++;
				}
#<span class="enscript-reference">else</span>
				RESET_STATE_OF_RUN();
#<span class="enscript-reference">endif</span>
			}

			<span class="enscript-keyword">if</span> ((free_considered + substitute_needed) &gt; free_available) {	
				<span class="enscript-comment">/*
				 * if we let this run continue
				 * we will end up dropping the vm_page_free_count
				 * below the reserve limit... we need to abort
				 * this run, but we can at least re-consider this
				 * page... thus the jump back to 'retry'
				 */</span>
				RESET_STATE_OF_RUN();

				<span class="enscript-keyword">if</span> (free_available &amp;&amp; considered &lt;= MAX_CONSIDERED_BEFORE_YIELD) {
					considered++;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
				}
				<span class="enscript-comment">/*
				 * free_available == 0
				 * so can't consider any free pages... if
				 * we went to retry in this case, we'd
				 * get stuck looking at the same page
				 * w/o making any forward progress
				 * we also want to take this path if we've already
				 * reached our limit that controls the lock latency
				 */</span>
			}
		}
<span class="enscript-reference">did_consider</span>:
		<span class="enscript-keyword">if</span> (considered &gt; MAX_CONSIDERED_BEFORE_YIELD &amp;&amp; npages &lt;= 1) {

			PAGE_REPLACEMENT_ALLOWED(FALSE);

			lck_mtx_unlock(&amp;vm_page_queue_free_lock);
			vm_page_unlock_queues();

			mutex_pause(0);

			PAGE_REPLACEMENT_ALLOWED(TRUE);

			vm_page_lock_queues();
			lck_mtx_lock(&amp;vm_page_queue_free_lock);

			RESET_STATE_OF_RUN();
			<span class="enscript-comment">/*
			 * reset our free page limit since we
			 * dropped the lock protecting the vm_page_free_queue
			 */</span>
			free_available = vm_page_free_count - vm_page_free_reserved;
			considered = 0;

			yielded++;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
		considered++;
	}
	m = VM_PAGE_NULL;

	<span class="enscript-keyword">if</span> (npages != contig_pages) {
		<span class="enscript-keyword">if</span> (!wrapped) {
			<span class="enscript-comment">/*
			 * We didn't find a contiguous range but we didn't
			 * start from the very first page.
			 * Start again from the very first page.
			 */</span>
			RESET_STATE_OF_RUN();
			<span class="enscript-keyword">if</span>( flags &amp; KMA_LOMEM)
				idx_last_contig_page_found  = vm_page_lomem_find_contiguous_last_idx = 0;
			<span class="enscript-keyword">else</span>
				idx_last_contig_page_found = vm_page_find_contiguous_last_idx = 0;
			last_idx = 0;
			page_idx = last_idx;
			wrapped = TRUE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);
	} <span class="enscript-keyword">else</span> {
		vm_page_t	m1;
		vm_page_t	m2;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	cur_idx;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	tmp_start_idx;
		vm_object_t	locked_object = VM_OBJECT_NULL;
		boolean_t	abort_run = FALSE;
		
		assert(page_idx - start_idx == contig_pages);

		tmp_start_idx = start_idx;

		<span class="enscript-comment">/*
		 * first pass through to pull the free pages
		 * off of the free queue so that in case we
		 * need substitute pages, we won't grab any 
		 * of the free pages in the run... we'll clear
		 * the 'free' bit in the 2nd pass, and even in
		 * an abort_run case, we'll collect all of the
		 * free pages in this run and return them to the free list
		 */</span>
		<span class="enscript-keyword">while</span> (start_idx &lt; page_idx) {

			m1 = &amp;vm_pages[start_idx++];

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">VM_PAGE_FIND_CONTIGUOUS_CAN_STEAL</span>
			assert(m1-&gt;free);
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> (m1-&gt;free) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> color;

				color = m1-&gt;phys_page &amp; vm_color_mask;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
				vm_page_verify_free_list(&amp;vm_page_queue_free[color], color, m1, TRUE);
#<span class="enscript-reference">endif</span>
				queue_remove(&amp;vm_page_queue_free[color],
					     m1,
					     vm_page_t,
					     pageq);
				m1-&gt;pageq.next = NULL;
				m1-&gt;pageq.prev = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
				vm_page_verify_free_list(&amp;vm_page_queue_free[color], color, VM_PAGE_NULL, FALSE);
#<span class="enscript-reference">endif</span>
				<span class="enscript-comment">/*
				 * Clear the &quot;free&quot; bit so that this page
				 * does not get considered for another
				 * concurrent physically-contiguous allocation.
				 */</span>
				m1-&gt;free = FALSE; 
				assert(m1-&gt;busy);

				vm_page_free_count--;
			}
		}
		<span class="enscript-keyword">if</span>( flags &amp; KMA_LOMEM)
			vm_page_lomem_find_contiguous_last_idx = page_idx;
		<span class="enscript-keyword">else</span> 
			vm_page_find_contiguous_last_idx = page_idx;
		
		<span class="enscript-comment">/*
		 * we can drop the free queue lock at this point since
		 * we've pulled any 'free' candidates off of the list
		 * we need it dropped so that we can do a vm_page_grab
		 * when substituing for pmapped/dirty pages
		 */</span>
		lck_mtx_unlock(&amp;vm_page_queue_free_lock);

		start_idx = tmp_start_idx;
		cur_idx = page_idx - 1;

		<span class="enscript-keyword">while</span> (start_idx++ &lt; page_idx) {
			<span class="enscript-comment">/*
			 * must go through the list from back to front
			 * so that the page list is created in the
			 * correct order - low -&gt; high phys addresses
			 */</span>
			m1 = &amp;vm_pages[cur_idx--];

			assert(!m1-&gt;free);

			<span class="enscript-keyword">if</span> (m1-&gt;object == VM_OBJECT_NULL) {
				<span class="enscript-comment">/*
				 * page has already been removed from
				 * the free list in the 1st pass
				 */</span>
				assert(m1-&gt;offset == (vm_object_offset_t) -1);
				assert(m1-&gt;busy);
				assert(!m1-&gt;wanted);
				assert(!m1-&gt;laundry);
			} <span class="enscript-keyword">else</span> {
				vm_object_t object;
				<span class="enscript-type">int</span> refmod;
				boolean_t disconnected, reusable;

				<span class="enscript-keyword">if</span> (abort_run == TRUE)
					<span class="enscript-keyword">continue</span>;

				object = m1-&gt;object;

				<span class="enscript-keyword">if</span> (object != locked_object) {
					<span class="enscript-keyword">if</span> (locked_object) {
						vm_object_unlock(locked_object);
						locked_object = VM_OBJECT_NULL;
					}
					<span class="enscript-keyword">if</span> (vm_object_lock_try(object))
						locked_object = object;
				}
				<span class="enscript-keyword">if</span> (locked_object == VM_OBJECT_NULL || 
				    (VM_PAGE_WIRED(m1) || m1-&gt;gobbled ||
				     m1-&gt;encrypted_cleaning ||
				     m1-&gt;pageout_queue || m1-&gt;laundry || m1-&gt;wanted ||
				     m1-&gt;cleaning || m1-&gt;overwriting || m1-&gt;pageout || m1-&gt;busy)) {

					<span class="enscript-keyword">if</span> (locked_object) {
						vm_object_unlock(locked_object);
						locked_object = VM_OBJECT_NULL;
					}
					tmp_start_idx = cur_idx;
					abort_run = TRUE;
					<span class="enscript-keyword">continue</span>;
				}

				disconnected = FALSE;
				reusable = FALSE;

				<span class="enscript-keyword">if</span> ((m1-&gt;reusable ||
				     m1-&gt;object-&gt;all_reusable) &amp;&amp;
				    m1-&gt;inactive &amp;&amp;
				    !m1-&gt;dirty &amp;&amp;
				    !m1-&gt;reference) {
					<span class="enscript-comment">/* reusable page... */</span>
					refmod = pmap_disconnect(m1-&gt;phys_page);
					disconnected = TRUE;
					<span class="enscript-keyword">if</span> (refmod == 0) {
						<span class="enscript-comment">/*
						 * ... not reused: can steal
						 * without relocating contents.
						 */</span>
						reusable = TRUE;
					}
				}

				<span class="enscript-keyword">if</span> ((m1-&gt;pmapped &amp;&amp;
				     ! reusable) ||
				    m1-&gt;dirty ||
				    m1-&gt;precious) {
					vm_object_offset_t offset;

					m2 = vm_page_grab();

					<span class="enscript-keyword">if</span> (m2 == VM_PAGE_NULL) {
						<span class="enscript-keyword">if</span> (locked_object) {
							vm_object_unlock(locked_object);
							locked_object = VM_OBJECT_NULL;
						}
						tmp_start_idx = cur_idx;
						abort_run = TRUE;
						<span class="enscript-keyword">continue</span>;
					}
					<span class="enscript-keyword">if</span> (! disconnected) {
						<span class="enscript-keyword">if</span> (m1-&gt;pmapped)
							refmod = pmap_disconnect(m1-&gt;phys_page);
						<span class="enscript-keyword">else</span>
							refmod = 0;
					}

					<span class="enscript-comment">/* copy the page's contents */</span>
					pmap_copy_page(m1-&gt;phys_page, m2-&gt;phys_page);
					<span class="enscript-comment">/* copy the page's state */</span>
					assert(!VM_PAGE_WIRED(m1));
					assert(!m1-&gt;free);
					assert(!m1-&gt;pageout_queue);
					assert(!m1-&gt;laundry);
					m2-&gt;reference	= m1-&gt;reference;
					assert(!m1-&gt;gobbled);
					assert(!m1-&gt;private);
					m2-&gt;no_cache	= m1-&gt;no_cache;
					m2-&gt;xpmapped	= 0;
					assert(!m1-&gt;busy);
					assert(!m1-&gt;wanted);
					assert(!m1-&gt;fictitious);
					m2-&gt;pmapped	= m1-&gt;pmapped; <span class="enscript-comment">/* should flush cache ? */</span>
					m2-&gt;wpmapped	= m1-&gt;wpmapped;
					assert(!m1-&gt;pageout);
					m2-&gt;absent	= m1-&gt;absent;
					m2-&gt;error	= m1-&gt;error;
					m2-&gt;dirty	= m1-&gt;dirty;
					assert(!m1-&gt;cleaning);
					m2-&gt;precious	= m1-&gt;precious;
					m2-&gt;clustered	= m1-&gt;clustered;
					assert(!m1-&gt;overwriting);
					m2-&gt;restart	= m1-&gt;restart;
					m2-&gt;unusual	= m1-&gt;unusual;
					m2-&gt;encrypted	= m1-&gt;encrypted;
					assert(!m1-&gt;encrypted_cleaning);
					m2-&gt;cs_validated = m1-&gt;cs_validated;
					m2-&gt;cs_tainted	= m1-&gt;cs_tainted;
					m2-&gt;cs_nx	= m1-&gt;cs_nx;

					<span class="enscript-comment">/*
					 * If m1 had really been reusable,
					 * we would have just stolen it, so
					 * let's not propagate it's &quot;reusable&quot;
					 * bit and assert that m2 is not
					 * marked as &quot;reusable&quot;.
					 */</span>
					<span class="enscript-comment">// m2-&gt;reusable	= m1-&gt;reusable;
</span>					assert(!m2-&gt;reusable);

					assert(!m1-&gt;lopage);
					m2-&gt;slid	= m1-&gt;slid;
					m2-&gt;compressor	= m1-&gt;compressor;

					<span class="enscript-comment">/*
					 * page may need to be flushed if
					 * it is marshalled into a UPL
					 * that is going to be used by a device
					 * that doesn't support coherency
					 */</span>
					m2-&gt;written_by_kernel = TRUE;

					<span class="enscript-comment">/*
					 * make sure we clear the ref/mod state
					 * from the pmap layer... else we risk
					 * inheriting state from the last time
					 * this page was used...
					 */</span>
					pmap_clear_refmod(m2-&gt;phys_page, VM_MEM_MODIFIED | VM_MEM_REFERENCED);

					<span class="enscript-keyword">if</span> (refmod &amp; VM_MEM_REFERENCED)
						m2-&gt;reference = TRUE;
					<span class="enscript-keyword">if</span> (refmod &amp; VM_MEM_MODIFIED) {
						SET_PAGE_DIRTY(m2, TRUE);
					}
					offset = m1-&gt;offset;

					<span class="enscript-comment">/*
					 * completely cleans up the state
					 * of the page so that it is ready
					 * to be put onto the free list, or
					 * for this purpose it looks like it
					 * just came off of the free list
					 */</span>
					vm_page_free_prepare(m1);

					<span class="enscript-comment">/*
					 * now put the substitute page
					 * on the object
					 */</span>
					vm_page_insert_internal(m2, locked_object, offset, VM_KERN_MEMORY_NONE, TRUE, TRUE, FALSE, FALSE, NULL);

					<span class="enscript-keyword">if</span> (m2-&gt;compressor) {
						m2-&gt;pmapped = TRUE;
						m2-&gt;wpmapped = TRUE;

						PMAP_ENTER(kernel_pmap, m2-&gt;offset, m2,
							   VM_PROT_READ | VM_PROT_WRITE, VM_PROT_NONE, 0, TRUE);

						compressed_pages++;

					} <span class="enscript-keyword">else</span> {
						<span class="enscript-keyword">if</span> (m2-&gt;reference)
							vm_page_activate(m2);
						<span class="enscript-keyword">else</span>
							vm_page_deactivate(m2);
					}
					PAGE_WAKEUP_DONE(m2);

				} <span class="enscript-keyword">else</span> {
					assert(!m1-&gt;compressor);

					<span class="enscript-comment">/*
					 * completely cleans up the state
					 * of the page so that it is ready
					 * to be put onto the free list, or
					 * for this purpose it looks like it
					 * just came off of the free list
					 */</span>
					vm_page_free_prepare(m1);
				}

				stolen_pages++;

			}
			m1-&gt;pageq.next = (queue_entry_t) m;
			m1-&gt;pageq.prev = NULL;
			m = m1;
		}
		<span class="enscript-keyword">if</span> (locked_object) {
			vm_object_unlock(locked_object);
			locked_object = VM_OBJECT_NULL;
		}

		<span class="enscript-keyword">if</span> (abort_run == TRUE) {
			<span class="enscript-keyword">if</span> (m != VM_PAGE_NULL) {
				vm_page_free_list(m, FALSE);
			}

			dumped_run++;

			<span class="enscript-comment">/*
			 * want the index of the last
			 * page in this run that was
			 * successfully 'stolen', so back
			 * it up 1 for the auto-decrement on use
			 * and 1 more to bump back over this page
			 */</span>
			page_idx = tmp_start_idx + 2;
			<span class="enscript-keyword">if</span> (page_idx &gt;= vm_pages_count) {
				<span class="enscript-keyword">if</span> (wrapped)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done_scanning</span>;
				page_idx = last_idx = 0;
				wrapped = TRUE;
			}
			abort_run = FALSE;
		
			<span class="enscript-comment">/*
			 * We didn't find a contiguous range but we didn't
			 * start from the very first page.
			 * Start again from the very first page.
			 */</span>
			RESET_STATE_OF_RUN();
			
			<span class="enscript-keyword">if</span>( flags &amp; KMA_LOMEM)
				idx_last_contig_page_found  = vm_page_lomem_find_contiguous_last_idx = page_idx;
			<span class="enscript-keyword">else</span>
				idx_last_contig_page_found = vm_page_find_contiguous_last_idx = page_idx;
			
			last_idx = page_idx;
			
			lck_mtx_lock(&amp;vm_page_queue_free_lock);
			<span class="enscript-comment">/*
			* reset our free page limit since we
			* dropped the lock protecting the vm_page_free_queue
			*/</span>
			free_available = vm_page_free_count - vm_page_free_reserved;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		<span class="enscript-keyword">for</span> (m1 = m; m1 != VM_PAGE_NULL; m1 = NEXT_PAGE(m1)) {

			<span class="enscript-keyword">if</span> (wire == TRUE)
				m1-&gt;wire_count++;
			<span class="enscript-keyword">else</span>
				m1-&gt;gobbled = TRUE;
		}
		<span class="enscript-keyword">if</span> (wire == FALSE)
			vm_page_gobble_count += npages;

		<span class="enscript-comment">/*
		 * gobbled pages are also counted as wired pages
		 */</span>
		vm_page_wire_count += npages;

 		assert(vm_page_verify_contiguous(m, npages));
	}
<span class="enscript-reference">done_scanning</span>:
	PAGE_REPLACEMENT_ALLOWED(FALSE);

	vm_page_unlock_queues();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	clock_get_system_microtime(&amp;tv_end_sec, &amp;tv_end_usec);

	tv_end_sec -= tv_start_sec;
	<span class="enscript-keyword">if</span> (tv_end_usec &lt; tv_start_usec) {
		tv_end_sec--;
		tv_end_usec += 1000000;
	}
	tv_end_usec -= tv_start_usec;
	<span class="enscript-keyword">if</span> (tv_end_usec &gt;= 1000000) {
		tv_end_sec++;
		tv_end_sec -= 1000000;
	}
	<span class="enscript-keyword">if</span> (vm_page_find_contig_debug) {
		printf(<span class="enscript-string">&quot;%s(num=%d,low=%d): found %d pages at 0x%llx in %ld.%06ds...  started at %d...  scanned %d pages...  yielded %d times...  dumped run %d times... stole %d pages... stole %d compressed pages\n&quot;</span>,
		       __func__, contig_pages, max_pnum, npages, (vm_object_offset_t)start_pnum &lt;&lt; PAGE_SHIFT,
		       (<span class="enscript-type">long</span>)tv_end_sec, tv_end_usec, orig_last_idx,
		       scanned, yielded, dumped_run, stolen_pages, compressed_pages);
	}

#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	vm_page_verify_free_lists();
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (m == NULL &amp;&amp; zone_gc_called == FALSE) {
		printf(<span class="enscript-string">&quot;%s(num=%d,low=%d): found %d pages at 0x%llx...scanned %d pages...  yielded %d times...  dumped run %d times... stole %d pages... stole %d compressed pages... wired count is %d\n&quot;</span>,
		       __func__, contig_pages, max_pnum, npages, (vm_object_offset_t)start_pnum &lt;&lt; PAGE_SHIFT,
		       scanned, yielded, dumped_run, stolen_pages, compressed_pages, vm_page_wire_count);

		<span class="enscript-keyword">if</span> (consider_buffer_cache_collect != NULL) {
			(<span class="enscript-type">void</span>)(*consider_buffer_cache_collect)(1);
		}

		consider_zone_gc(TRUE);

		zone_gc_called = TRUE;

		printf(<span class="enscript-string">&quot;vm_page_find_contiguous: zone_gc called... wired count is %d\n&quot;</span>, vm_page_wire_count);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">full_scan_again</span>;
	}

	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 *	Allocate a list of contiguous, wired pages.
 */</span>
kern_return_t
<span class="enscript-function-name">cpm_allocate</span>(
	vm_size_t	size,
	vm_page_t	*list,
	ppnum_t		max_pnum,
	ppnum_t		pnum_mask,
	boolean_t	wire,
	<span class="enscript-type">int</span>		flags)
{
	vm_page_t		pages;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		npages;

	<span class="enscript-keyword">if</span> (size % PAGE_SIZE != 0)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	npages = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size / PAGE_SIZE);
	<span class="enscript-keyword">if</span> (npages != size / PAGE_SIZE) {
		<span class="enscript-comment">/* 32-bit overflow */</span>
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/*
	 *	Obtain a pointer to a subset of the free
	 *	list large enough to satisfy the request;
	 *	the region will be physically contiguous.
	 */</span>
	pages = vm_page_find_contiguous(npages, max_pnum, pnum_mask, wire, flags);

	<span class="enscript-keyword">if</span> (pages == VM_PAGE_NULL)
		<span class="enscript-keyword">return</span> KERN_NO_SPACE;
	<span class="enscript-comment">/*
	 * determine need for wakeups
	 */</span>
	<span class="enscript-keyword">if</span> ((vm_page_free_count &lt; vm_page_free_min) ||
	     ((vm_page_free_count &lt; vm_page_free_target) &amp;&amp;
	      ((vm_page_inactive_count + vm_page_speculative_count) &lt; vm_page_inactive_min)))
	         thread_wakeup((event_t) &amp;vm_page_free_wanted);
		
	VM_CHECK_MEMORYSTATUS;
	
	<span class="enscript-comment">/*
	 *	The CPM pages should now be available and
	 *	ordered by ascending physical address.
	 */</span>
	assert(vm_page_verify_contiguous(pages, npages));

	*list = pages;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_max_delayed_work_limit = DEFAULT_DELAYED_WORK_LIMIT;

<span class="enscript-comment">/*
 * when working on a 'run' of pages, it is necessary to hold 
 * the vm_page_queue_lock (a hot global lock) for certain operations
 * on the page... however, the majority of the work can be done
 * while merely holding the object lock... in fact there are certain
 * collections of pages that don't require any work brokered by the
 * vm_page_queue_lock... to mitigate the time spent behind the global
 * lock, go to a 2 pass algorithm... collect pages up to DELAYED_WORK_LIMIT
 * while doing all of the work that doesn't require the vm_page_queue_lock...
 * then call vm_page_do_delayed_work to acquire the vm_page_queue_lock and do the
 * necessary work for each page... we will grab the busy bit on the page
 * if it's not already held so that vm_page_do_delayed_work can drop the object lock
 * if it can't immediately take the vm_page_queue_lock in order to compete
 * for the locks in the same order that vm_pageout_scan takes them.
 * the operation names are modeled after the names of the routines that
 * need to be called in order to make the changes very obvious in the
 * original loop
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_do_delayed_work</span>(
	vm_object_t 	object,
	vm_tag_t        tag,
	<span class="enscript-type">struct</span> vm_page_delayed_work *dwp,
	<span class="enscript-type">int</span>		dw_count)
{
	<span class="enscript-type">int</span>		j;
	vm_page_t	m;
        vm_page_t       local_free_q = VM_PAGE_NULL;

	<span class="enscript-comment">/*
	 * pageout_scan takes the vm_page_lock_queues first
	 * then tries for the object lock... to avoid what
	 * is effectively a lock inversion, we'll go to the
	 * trouble of taking them in that same order... otherwise
	 * if this object contains the majority of the pages resident
	 * in the UBC (or a small set of large objects actively being
	 * worked on contain the majority of the pages), we could
	 * cause the pageout_scan thread to 'starve' in its attempt
	 * to find pages to move to the free queue, since it has to
	 * successfully acquire the object lock of any candidate page
	 * before it can steal/clean it.
	 */</span>
	<span class="enscript-keyword">if</span> (!vm_page_trylockspin_queues()) {
		vm_object_unlock(object);

		vm_page_lockspin_queues();

		<span class="enscript-keyword">for</span> (j = 0; ; j++) {
			<span class="enscript-keyword">if</span> (!vm_object_lock_avoid(object) &amp;&amp;
			    _vm_object_lock_try(object))
				<span class="enscript-keyword">break</span>;
			vm_page_unlock_queues();
			mutex_pause(j);
			vm_page_lockspin_queues();
		}
	}
	<span class="enscript-keyword">for</span> (j = 0; j &lt; dw_count; j++, dwp++) {

		m = dwp-&gt;dw_m;

		<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_pageout_throttle_up)
			vm_pageout_throttle_up(m);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
		<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_phantom_cache_update)
			vm_phantom_cache_update(m);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_wire)
			vm_page_wire(m, tag, FALSE);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_unwire) {
			boolean_t	queueit;

			queueit = (dwp-&gt;dw_mask &amp; (DW_vm_page_free | DW_vm_page_deactivate_internal)) ? FALSE : TRUE;

			vm_page_unwire(m, queueit);
		}
		<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_free) {
			vm_page_free_prepare_queues(m);

			assert(m-&gt;pageq.next == NULL &amp;&amp; m-&gt;pageq.prev == NULL);
			<span class="enscript-comment">/*
			 * Add this page to our list of reclaimed pages,
			 * to be freed later.
			 */</span>
			m-&gt;pageq.next = (queue_entry_t) local_free_q;
			local_free_q = m;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_deactivate_internal)
				vm_page_deactivate_internal(m, FALSE);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_activate) {
				<span class="enscript-keyword">if</span> (m-&gt;active == FALSE) {
					vm_page_activate(m);
				}
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_speculate)
				vm_page_speculate(m, TRUE);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_enqueue_cleaned) {
				<span class="enscript-comment">/*
				 * if we didn't hold the object lock and did this,
				 * we might disconnect the page, then someone might
				 * soft fault it back in, then we would put it on the
				 * cleaned queue, and so we would have a referenced (maybe even dirty)
				 * page on that queue, which we don't want
				 */</span>
				<span class="enscript-type">int</span> refmod_state = pmap_disconnect(m-&gt;phys_page);

				<span class="enscript-keyword">if</span> ((refmod_state &amp; VM_MEM_REFERENCED)) {
					<span class="enscript-comment">/*
					 * this page has been touched since it got cleaned; let's activate it
					 * if it hasn't already been
					 */</span>
					vm_pageout_enqueued_cleaned++;
					vm_pageout_cleaned_reactivated++;
					vm_pageout_cleaned_commit_reactivated++;

					<span class="enscript-keyword">if</span> (m-&gt;active == FALSE)
						vm_page_activate(m);
				} <span class="enscript-keyword">else</span> {
					m-&gt;reference = FALSE;
					vm_page_enqueue_cleaned(m);
				}
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_vm_page_lru)
				vm_page_lru(m);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_VM_PAGE_QUEUES_REMOVE) {
				<span class="enscript-keyword">if</span> ( !m-&gt;pageout_queue)
					vm_page_queues_remove(m);
			}
			<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_set_reference)
				m-&gt;reference = TRUE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_clear_reference)
				m-&gt;reference = FALSE;

			<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_move_page) {
				<span class="enscript-keyword">if</span> ( !m-&gt;pageout_queue) {
					vm_page_queues_remove(m);

					assert(m-&gt;object != kernel_object);

					vm_page_enqueue_inactive(m, FALSE);
				}
			}
			<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_clear_busy)
				m-&gt;busy = FALSE;

			<span class="enscript-keyword">if</span> (dwp-&gt;dw_mask &amp; DW_PAGE_WAKEUP)
				PAGE_WAKEUP(m);
		}
	}
	vm_page_unlock_queues();

	<span class="enscript-keyword">if</span> (local_free_q)
		vm_page_free_list(local_free_q, TRUE);
	
	VM_CHECK_MEMORYSTATUS;

}

kern_return_t
<span class="enscript-function-name">vm_page_alloc_list</span>(
	<span class="enscript-type">int</span>	page_count,
	<span class="enscript-type">int</span>	flags,
	vm_page_t *list)
{
	vm_page_t	lo_page_list = VM_PAGE_NULL;
	vm_page_t	mem;
	<span class="enscript-type">int</span>		i;

	<span class="enscript-keyword">if</span> ( !(flags &amp; KMA_LOMEM))
		panic(<span class="enscript-string">&quot;vm_page_alloc_list: called w/o KMA_LOMEM&quot;</span>);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; page_count; i++) {

		mem = vm_page_grablo();

		<span class="enscript-keyword">if</span> (mem == VM_PAGE_NULL) {
			<span class="enscript-keyword">if</span> (lo_page_list)
				vm_page_free_list(lo_page_list, FALSE);

			*list = VM_PAGE_NULL;

			<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
		}
		mem-&gt;pageq.next = (queue_entry_t) lo_page_list;
		lo_page_list = mem;
	}
	*list = lo_page_list;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_set_offset</span>(vm_page_t page, vm_object_offset_t offset)
{
	page-&gt;offset = offset;
}

vm_page_t
<span class="enscript-function-name">vm_page_get_next</span>(vm_page_t page)
{
	<span class="enscript-keyword">return</span> ((vm_page_t) page-&gt;pageq.next);
}

vm_object_offset_t
<span class="enscript-function-name">vm_page_get_offset</span>(vm_page_t page)
{
	<span class="enscript-keyword">return</span> (page-&gt;offset);
}

ppnum_t
<span class="enscript-function-name">vm_page_get_phys_page</span>(vm_page_t page)
{
	<span class="enscript-keyword">return</span> (page-&gt;phys_page);
}
	
	
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>

<span class="enscript-type">static</span> vm_page_t hibernate_gobble_queue;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hibernate_drain_pageout_queue</span>(<span class="enscript-type">struct</span> vm_pageout_queue *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hibernate_flush_dirty_pages</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hibernate_flush_queue</span>(queue_head_t *, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">hibernate_flush_wait</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">hibernate_mark_in_progress</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">hibernate_clear_in_progress</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>		hibernate_free_range(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>		hibernate_hash_insert_page(vm_page_t);
uint32_t	hibernate_mark_as_unneeded(addr64_t, addr64_t, hibernate_page_list_t *, hibernate_page_list_t *);
<span class="enscript-type">void</span>		hibernate_rebuild_vm_structs(<span class="enscript-type">void</span>);
uint32_t	hibernate_teardown_vm_structs(hibernate_page_list_t *, hibernate_page_list_t *);
ppnum_t		hibernate_lookup_paddr(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);

<span class="enscript-type">struct</span> hibernate_statistics {
	<span class="enscript-type">int</span> hibernate_considered;
	<span class="enscript-type">int</span> hibernate_reentered_on_q;
	<span class="enscript-type">int</span> hibernate_found_dirty;
	<span class="enscript-type">int</span> hibernate_skipped_cleaning;
	<span class="enscript-type">int</span> hibernate_skipped_transient;
	<span class="enscript-type">int</span> hibernate_skipped_precious;
	<span class="enscript-type">int</span> hibernate_skipped_external;
	<span class="enscript-type">int</span> hibernate_queue_nolock;
	<span class="enscript-type">int</span> hibernate_queue_paused;
	<span class="enscript-type">int</span> hibernate_throttled;
	<span class="enscript-type">int</span> hibernate_throttle_timeout;
	<span class="enscript-type">int</span> hibernate_drained;
	<span class="enscript-type">int</span> hibernate_drain_timeout;
	<span class="enscript-type">int</span> cd_lock_failed;
	<span class="enscript-type">int</span> cd_found_precious;
	<span class="enscript-type">int</span> cd_found_wired;
	<span class="enscript-type">int</span> cd_found_busy;
	<span class="enscript-type">int</span> cd_found_unusual;
	<span class="enscript-type">int</span> cd_found_cleaning;
	<span class="enscript-type">int</span> cd_found_laundry;
	<span class="enscript-type">int</span> cd_found_dirty;
	<span class="enscript-type">int</span> cd_found_xpmapped;
	<span class="enscript-type">int</span> cd_skipped_xpmapped;
	<span class="enscript-type">int</span> cd_local_free;
	<span class="enscript-type">int</span> cd_total_free;
	<span class="enscript-type">int</span> cd_vm_page_wire_count;
	<span class="enscript-type">int</span> cd_vm_struct_pages_unneeded;
	<span class="enscript-type">int</span> cd_pages;
	<span class="enscript-type">int</span> cd_discarded;
	<span class="enscript-type">int</span> cd_count_wire;
} hibernate_stats;


<span class="enscript-comment">/*
 * clamp the number of 'xpmapped' pages we'll sweep into the hibernation image
 * so that we don't overrun the estimated image size, which would
 * result in a hibernation failure.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HIBERNATE_XPMAPPED_LIMIT</span>	40000


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hibernate_drain_pageout_queue</span>(<span class="enscript-type">struct</span> vm_pageout_queue *q)
{
	wait_result_t	wait_result;

	vm_page_lock_queues();

	<span class="enscript-keyword">while</span> ( !queue_empty(&amp;q-&gt;pgo_pending) ) {

		q-&gt;pgo_draining = TRUE;

		assert_wait_timeout((event_t) (&amp;q-&gt;pgo_laundry+1), THREAD_INTERRUPTIBLE, 5000, 1000*NSEC_PER_USEC);

		vm_page_unlock_queues();

		wait_result = thread_block(THREAD_CONTINUE_NULL);

		<span class="enscript-keyword">if</span> (wait_result == THREAD_TIMED_OUT &amp;&amp; !queue_empty(&amp;q-&gt;pgo_pending)) {
			hibernate_stats.hibernate_drain_timeout++;
			
			<span class="enscript-keyword">if</span> (q == &amp;vm_pageout_queue_external)
				<span class="enscript-keyword">return</span> (0);
			
			<span class="enscript-keyword">return</span> (1);
		}
		vm_page_lock_queues();

		hibernate_stats.hibernate_drained++;
	}
	vm_page_unlock_queues();

	<span class="enscript-keyword">return</span> (0);
}


boolean_t hibernate_skip_external = FALSE;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hibernate_flush_queue</span>(queue_head_t *q, <span class="enscript-type">int</span> qcount)
{
	vm_page_t	m;
	vm_object_t	l_object = NULL;
	vm_object_t	m_object = NULL;
	<span class="enscript-type">int</span>		refmod_state = 0;
	<span class="enscript-type">int</span>		try_failed_count = 0;
	<span class="enscript-type">int</span>		retval = 0;
	<span class="enscript-type">int</span>		current_run = 0;
	<span class="enscript-type">struct</span>	vm_pageout_queue *iq;
	<span class="enscript-type">struct</span>	vm_pageout_queue *eq;
	<span class="enscript-type">struct</span>	vm_pageout_queue *tq;


	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 4) | DBG_FUNC_START, q, qcount, 0, 0, 0);
	
	iq = &amp;vm_pageout_queue_internal;
	eq = &amp;vm_pageout_queue_external;

	vm_page_lock_queues();

	<span class="enscript-keyword">while</span> (qcount &amp;&amp; !queue_empty(q)) {

		<span class="enscript-keyword">if</span> (current_run++ == 1000) {
			<span class="enscript-keyword">if</span> (hibernate_should_abort()) {
				retval = 1;
				<span class="enscript-keyword">break</span>;
			}
			current_run = 0;
		}

		m = (vm_page_t) queue_first(q);
		m_object = m-&gt;object;

		<span class="enscript-comment">/*
		 * check to see if we currently are working
		 * with the same object... if so, we've
		 * already got the lock
		 */</span>
		<span class="enscript-keyword">if</span> (m_object != l_object) {
		        <span class="enscript-comment">/*
			 * the object associated with candidate page is 
			 * different from the one we were just working
			 * with... dump the lock if we still own it
			 */</span>
		        <span class="enscript-keyword">if</span> (l_object != NULL) {
			        vm_object_unlock(l_object);
				l_object = NULL;
			}
			<span class="enscript-comment">/*
			 * Try to lock object; since we've alread got the
			 * page queues lock, we can only 'try' for this one.
			 * if the 'try' fails, we need to do a mutex_pause
			 * to allow the owner of the object lock a chance to
			 * run... 
			 */</span>
			<span class="enscript-keyword">if</span> ( !vm_object_lock_try_scan(m_object)) {

				<span class="enscript-keyword">if</span> (try_failed_count &gt; 20) {
					hibernate_stats.hibernate_queue_nolock++;

					<span class="enscript-keyword">goto</span> <span class="enscript-reference">reenter_pg_on_q</span>;
				}

				vm_page_unlock_queues();
				mutex_pause(try_failed_count++);
				vm_page_lock_queues();

				hibernate_stats.hibernate_queue_paused++;
				<span class="enscript-keyword">continue</span>;
			} <span class="enscript-keyword">else</span> {
				l_object = m_object;
			}
		}
		<span class="enscript-keyword">if</span> ( !m_object-&gt;alive || m-&gt;encrypted_cleaning || m-&gt;cleaning || m-&gt;laundry || m-&gt;busy || m-&gt;absent || m-&gt;error) {
			<span class="enscript-comment">/*
			 * page is not to be cleaned
			 * put it back on the head of its queue
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;cleaning)
				hibernate_stats.hibernate_skipped_cleaning++;
			<span class="enscript-keyword">else</span>
				hibernate_stats.hibernate_skipped_transient++;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reenter_pg_on_q</span>;
		}
		<span class="enscript-keyword">if</span> (m_object-&gt;copy == VM_OBJECT_NULL) {
			<span class="enscript-keyword">if</span> (m_object-&gt;purgable == VM_PURGABLE_VOLATILE || m_object-&gt;purgable == VM_PURGABLE_EMPTY) {
				<span class="enscript-comment">/*
				 * let the normal hibernate image path
				 * deal with these
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">reenter_pg_on_q</span>;
			}
		}
		<span class="enscript-keyword">if</span> ( !m-&gt;dirty &amp;&amp; m-&gt;pmapped) {
		        refmod_state = pmap_get_refmod(m-&gt;phys_page);

			<span class="enscript-keyword">if</span> ((refmod_state &amp; VM_MEM_MODIFIED)) {
				SET_PAGE_DIRTY(m, FALSE);
			}
		} <span class="enscript-keyword">else</span>
			refmod_state = 0;

		<span class="enscript-keyword">if</span> ( !m-&gt;dirty) {
			<span class="enscript-comment">/*
			 * page is not to be cleaned
			 * put it back on the head of its queue
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;precious)
				hibernate_stats.hibernate_skipped_precious++;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reenter_pg_on_q</span>;
		}

		<span class="enscript-keyword">if</span> (hibernate_skip_external == TRUE &amp;&amp; !m_object-&gt;internal) {

			hibernate_stats.hibernate_skipped_external++;
			
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reenter_pg_on_q</span>;
		}
		tq = NULL;

		<span class="enscript-keyword">if</span> (m_object-&gt;internal) {
			<span class="enscript-keyword">if</span> (VM_PAGE_Q_THROTTLED(iq))
				tq = iq;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VM_PAGE_Q_THROTTLED(eq))
			tq = eq;

		<span class="enscript-keyword">if</span> (tq != NULL) {
			wait_result_t	wait_result;
			<span class="enscript-type">int</span>		wait_count = 5;

		        <span class="enscript-keyword">if</span> (l_object != NULL) {
			        vm_object_unlock(l_object);
				l_object = NULL;
			}

			<span class="enscript-keyword">while</span> (retval == 0) {

				tq-&gt;pgo_throttled = TRUE;

				assert_wait_timeout((event_t) &amp;tq-&gt;pgo_laundry, THREAD_INTERRUPTIBLE, 1000, 1000*NSEC_PER_USEC);

				vm_page_unlock_queues();

				wait_result = thread_block(THREAD_CONTINUE_NULL);

				vm_page_lock_queues();

				<span class="enscript-keyword">if</span> (wait_result != THREAD_TIMED_OUT)
					<span class="enscript-keyword">break</span>;
                                <span class="enscript-keyword">if</span> (!VM_PAGE_Q_THROTTLED(tq))
                                        <span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">if</span> (hibernate_should_abort())
					retval = 1;

				<span class="enscript-keyword">if</span> (--wait_count == 0) {

					hibernate_stats.hibernate_throttle_timeout++;

					<span class="enscript-keyword">if</span> (tq == eq) {
						hibernate_skip_external = TRUE;
						<span class="enscript-keyword">break</span>;
					}
					retval = 1;
				}
			}
			<span class="enscript-keyword">if</span> (retval)
				<span class="enscript-keyword">break</span>;

			hibernate_stats.hibernate_throttled++;

			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * we've already factored out pages in the laundry which
		 * means this page can't be on the pageout queue so it's
		 * safe to do the vm_page_queues_remove
		 */</span>
                assert(!m-&gt;pageout_queue);

		vm_page_queues_remove(m);

		<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE &amp;&amp; m_object-&gt;internal == TRUE)
			pmap_disconnect_options(m-&gt;phys_page, PMAP_OPTIONS_COMPRESSOR, NULL);

		(<span class="enscript-type">void</span>)vm_pageout_cluster(m, FALSE, FALSE, FALSE);

		hibernate_stats.hibernate_found_dirty++;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_pg</span>;

<span class="enscript-reference">reenter_pg_on_q</span>:
		queue_remove(q, m, vm_page_t, pageq);
		queue_enter(q, m, vm_page_t, pageq);

		hibernate_stats.hibernate_reentered_on_q++;
<span class="enscript-reference">next_pg</span>:
		hibernate_stats.hibernate_considered++;

		qcount--;
		try_failed_count = 0;
	}
	<span class="enscript-keyword">if</span> (l_object != NULL) {
		vm_object_unlock(l_object);
		l_object = NULL;
	}

	vm_page_unlock_queues();

	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 4) | DBG_FUNC_END, hibernate_stats.hibernate_found_dirty, retval, 0, 0, 0);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hibernate_flush_dirty_pages</span>(<span class="enscript-type">int</span> pass)
{
	<span class="enscript-type">struct</span> vm_speculative_age_q	*aq;
	uint32_t	i;

	<span class="enscript-keyword">if</span> (vm_page_local_q) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++)
			vm_page_reactivate_local(i, TRUE, FALSE);
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt;= VM_PAGE_MAX_SPECULATIVE_AGE_Q; i++) {
		<span class="enscript-type">int</span>		qcount;
		vm_page_t	m;

		aq = &amp;vm_page_queue_speculative[i];

		<span class="enscript-keyword">if</span> (queue_empty(&amp;aq-&gt;age_q))
			<span class="enscript-keyword">continue</span>;
		qcount = 0;

		vm_page_lockspin_queues();

		queue_iterate(&amp;aq-&gt;age_q,
			      m,
			      vm_page_t,
			      pageq)
		{
			qcount++;
		}
		vm_page_unlock_queues();

		<span class="enscript-keyword">if</span> (qcount) {
			<span class="enscript-keyword">if</span> (hibernate_flush_queue(&amp;aq-&gt;age_q, qcount))
				<span class="enscript-keyword">return</span> (1);
		}
	}
	<span class="enscript-keyword">if</span> (hibernate_flush_queue(&amp;vm_page_queue_inactive, vm_page_inactive_count - vm_page_anonymous_count - vm_page_cleaned_count))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (hibernate_flush_queue(&amp;vm_page_queue_anonymous, vm_page_anonymous_count))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (hibernate_flush_queue(&amp;vm_page_queue_cleaned, vm_page_cleaned_count))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (hibernate_drain_pageout_queue(&amp;vm_pageout_queue_internal))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE &amp;&amp; pass == 1)
		vm_compressor_record_warmup_start();

	<span class="enscript-keyword">if</span> (hibernate_flush_queue(&amp;vm_page_queue_active, vm_page_active_count)) {
		<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE &amp;&amp; pass == 1)
			vm_compressor_record_warmup_end();
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">if</span> (hibernate_drain_pageout_queue(&amp;vm_pageout_queue_internal)) {
		<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE &amp;&amp; pass == 1)
			vm_compressor_record_warmup_end();
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE &amp;&amp; pass == 1)
		vm_compressor_record_warmup_end();

	<span class="enscript-keyword">if</span> (hibernate_skip_external == FALSE &amp;&amp; hibernate_drain_pageout_queue(&amp;vm_pageout_queue_external))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_reset_stats</span>()
{
	bzero(&amp;hibernate_stats, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hibernate_statistics));
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">hibernate_flush_memory</span>()
{
	<span class="enscript-type">int</span>	retval;

	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 3) | DBG_FUNC_START, vm_page_free_count, 0, 0, 0, 0);

	hibernate_cleaning_in_progress = TRUE;
	hibernate_skip_external = FALSE;

	<span class="enscript-keyword">if</span> ((retval = hibernate_flush_dirty_pages(1)) == 0) {

		<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE) {

				KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 10) | DBG_FUNC_START, VM_PAGE_COMPRESSOR_COUNT, 0, 0, 0, 0);

				vm_compressor_flush();

				KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 10) | DBG_FUNC_END, VM_PAGE_COMPRESSOR_COUNT, 0, 0, 0, 0);
		}
		<span class="enscript-keyword">if</span> (consider_buffer_cache_collect != NULL) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> orig_wire_count;

			KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 7) | DBG_FUNC_START, 0, 0, 0, 0, 0);
			orig_wire_count = vm_page_wire_count;
			
			(<span class="enscript-type">void</span>)(*consider_buffer_cache_collect)(1);
			consider_zone_gc(TRUE);

			HIBLOG(<span class="enscript-string">&quot;hibernate_flush_memory: buffer_cache_gc freed up %d wired pages\n&quot;</span>, orig_wire_count - vm_page_wire_count);

			KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 7) | DBG_FUNC_END, orig_wire_count - vm_page_wire_count, 0, 0, 0, 0);
		}
	}
	hibernate_cleaning_in_progress = FALSE;

	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 3) | DBG_FUNC_END, vm_page_free_count, hibernate_stats.hibernate_found_dirty, retval, 0, 0);

	<span class="enscript-keyword">if</span> (retval &amp;&amp; COMPRESSED_PAGER_IS_ACTIVE)
		HIBLOG(<span class="enscript-string">&quot;hibernate_flush_memory() failed to finish - vm_page_compressor_count(%d)\n&quot;</span>, VM_PAGE_COMPRESSOR_COUNT);


    HIBPRINT(<span class="enscript-string">&quot;hibernate_flush_memory() considered(%d) reentered_on_q(%d) found_dirty(%d)\n&quot;</span>,
                hibernate_stats.hibernate_considered,
                hibernate_stats.hibernate_reentered_on_q,
                hibernate_stats.hibernate_found_dirty);
    HIBPRINT(<span class="enscript-string">&quot;   skipped_cleaning(%d) skipped_transient(%d) skipped_precious(%d) skipped_external(%d) queue_nolock(%d)\n&quot;</span>,
                hibernate_stats.hibernate_skipped_cleaning,
                hibernate_stats.hibernate_skipped_transient,
                hibernate_stats.hibernate_skipped_precious,
                hibernate_stats.hibernate_skipped_external,
                hibernate_stats.hibernate_queue_nolock);
    HIBPRINT(<span class="enscript-string">&quot;   queue_paused(%d) throttled(%d) throttle_timeout(%d) drained(%d) drain_timeout(%d)\n&quot;</span>,
                hibernate_stats.hibernate_queue_paused,
                hibernate_stats.hibernate_throttled,
                hibernate_stats.hibernate_throttle_timeout,
                hibernate_stats.hibernate_drained,
                hibernate_stats.hibernate_drain_timeout);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_page_list_zero</span>(hibernate_page_list_t *list)
{
    uint32_t             bank;
    hibernate_bitmap_t * bitmap;

    bitmap = &amp;list-&gt;bank_bitmap[0];
    <span class="enscript-keyword">for</span> (bank = 0; bank &lt; list-&gt;bank_count; bank++)
    {
        uint32_t last_bit;

	bzero((<span class="enscript-type">void</span> *) &amp;bitmap-&gt;bitmap[0], bitmap-&gt;bitmapwords &lt;&lt; 2); 
        <span class="enscript-comment">// set out-of-bound bits at end of bitmap.
</span>        last_bit = ((bitmap-&gt;last_page - bitmap-&gt;first_page + 1) &amp; 31);
	<span class="enscript-keyword">if</span> (last_bit)
	    bitmap-&gt;bitmap[bitmap-&gt;bitmapwords - 1] = (0xFFFFFFFF &gt;&gt; last_bit);

	bitmap = (hibernate_bitmap_t *) &amp;bitmap-&gt;bitmap[bitmap-&gt;bitmapwords];
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_free_gobble_pages</span>(<span class="enscript-type">void</span>)
{
    vm_page_t m, next;
    uint32_t  count = 0;

    m = (vm_page_t) hibernate_gobble_queue;
    <span class="enscript-keyword">while</span>(m)
    {
        next = (vm_page_t) m-&gt;pageq.next;
        vm_page_free(m);
        count++;
        m = next;
    }
    hibernate_gobble_queue = VM_PAGE_NULL;
    
    <span class="enscript-keyword">if</span> (count)
        HIBLOG(<span class="enscript-string">&quot;Freed %d pages\n&quot;</span>, count);
}

<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">hibernate_consider_discard</span>(vm_page_t m, boolean_t preflight)
{
    vm_object_t object = NULL;
    <span class="enscript-type">int</span>                  refmod_state;
    boolean_t            discard = FALSE;

    <span class="enscript-keyword">do</span>
    {
        <span class="enscript-keyword">if</span> (m-&gt;private)
            panic(<span class="enscript-string">&quot;hibernate_consider_discard: private&quot;</span>);

        <span class="enscript-keyword">if</span> (!vm_object_lock_try(m-&gt;object)) {
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_lock_failed++;
            <span class="enscript-keyword">break</span>;
	}
        object = m-&gt;object;

	<span class="enscript-keyword">if</span> (VM_PAGE_WIRED(m)) {
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_found_wired++;
            <span class="enscript-keyword">break</span>;
	}
        <span class="enscript-keyword">if</span> (m-&gt;precious) {
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_found_precious++;
            <span class="enscript-keyword">break</span>;
	}
        <span class="enscript-keyword">if</span> (m-&gt;busy || !object-&gt;alive) {
           <span class="enscript-comment">/*
            *	Somebody is playing with this page.
            */</span>
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_found_busy++;
            <span class="enscript-keyword">break</span>;
	}
        <span class="enscript-keyword">if</span> (m-&gt;absent || m-&gt;unusual || m-&gt;error) {
           <span class="enscript-comment">/*
            * If it's unusual in anyway, ignore it
            */</span>
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_found_unusual++;
            <span class="enscript-keyword">break</span>;
	}
        <span class="enscript-keyword">if</span> (m-&gt;cleaning) {
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_found_cleaning++;
            <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (m-&gt;laundry) {
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_stats.cd_found_laundry++;
            <span class="enscript-keyword">break</span>;
	}
        <span class="enscript-keyword">if</span> (!m-&gt;dirty)
        {
            refmod_state = pmap_get_refmod(m-&gt;phys_page);
        
            <span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_REFERENCED)
                m-&gt;reference = TRUE;
            <span class="enscript-keyword">if</span> (refmod_state &amp; VM_MEM_MODIFIED) {
              	SET_PAGE_DIRTY(m, FALSE);
	    }
        }
   
        <span class="enscript-comment">/*
         * If it's clean or purgeable we can discard the page on wakeup.
         */</span>
        discard = (!m-&gt;dirty) 
		    || (VM_PURGABLE_VOLATILE == object-&gt;purgable)
		    || (VM_PURGABLE_EMPTY    == object-&gt;purgable);


        <span class="enscript-keyword">if</span> (discard == FALSE) {
		<span class="enscript-keyword">if</span> (!preflight)
			hibernate_stats.cd_found_dirty++;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;xpmapped &amp;&amp; m-&gt;reference &amp;&amp; !object-&gt;internal) {
		<span class="enscript-keyword">if</span> (hibernate_stats.cd_found_xpmapped &lt; HIBERNATE_XPMAPPED_LIMIT) {
			<span class="enscript-keyword">if</span> (!preflight)
				hibernate_stats.cd_found_xpmapped++;
			discard = FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (!preflight)
				hibernate_stats.cd_skipped_xpmapped++;
		}
        }
    }
    <span class="enscript-keyword">while</span> (FALSE);

    <span class="enscript-keyword">if</span> (object)
        vm_object_unlock(object);

    <span class="enscript-keyword">return</span> (discard);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_discard_page</span>(vm_page_t m)
{
    <span class="enscript-keyword">if</span> (m-&gt;absent || m-&gt;unusual || m-&gt;error)
       <span class="enscript-comment">/*
        * If it's unusual in anyway, ignore
        */</span>
        <span class="enscript-keyword">return</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
    vm_object_t object = m-&gt;object;
    <span class="enscript-keyword">if</span> (!vm_object_lock_try(m-&gt;object))
	panic(<span class="enscript-string">&quot;hibernate_discard_page(%p) !vm_object_lock_try&quot;</span>, m);
#<span class="enscript-reference">else</span>
    <span class="enscript-comment">/* No need to lock page queue for token delete, hibernate_vm_unlock() 
       makes sure these locks are uncontended before sleep */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>

    <span class="enscript-keyword">if</span> (m-&gt;pmapped == TRUE) 
    {
        __unused <span class="enscript-type">int</span> refmod_state = pmap_disconnect(m-&gt;phys_page);
    }

    <span class="enscript-keyword">if</span> (m-&gt;laundry)
        panic(<span class="enscript-string">&quot;hibernate_discard_page(%p) laundry&quot;</span>, m);
    <span class="enscript-keyword">if</span> (m-&gt;private)
        panic(<span class="enscript-string">&quot;hibernate_discard_page(%p) private&quot;</span>, m);
    <span class="enscript-keyword">if</span> (m-&gt;fictitious)
        panic(<span class="enscript-string">&quot;hibernate_discard_page(%p) fictitious&quot;</span>, m);

    <span class="enscript-keyword">if</span> (VM_PURGABLE_VOLATILE == m-&gt;object-&gt;purgable)
    {
	<span class="enscript-comment">/* object should be on a queue */</span>
        assert((m-&gt;object-&gt;objq.next != NULL) &amp;&amp; (m-&gt;object-&gt;objq.prev != NULL));
        purgeable_q_t old_queue = vm_purgeable_object_remove(m-&gt;object);
        assert(old_queue);
	<span class="enscript-keyword">if</span> (m-&gt;object-&gt;purgeable_when_ripe) {
		vm_purgeable_token_delete_first(old_queue);
	}
        m-&gt;object-&gt;purgable = VM_PURGABLE_EMPTY;

	<span class="enscript-comment">/*
	 * Purgeable ledgers:  pages of VOLATILE and EMPTY objects are
	 * accounted in the &quot;volatile&quot; ledger, so no change here.
	 * We have to update vm_page_purgeable_count, though, since we're
	 * effectively purging this object.
	 */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> delta;
	assert(m-&gt;object-&gt;resident_page_count &gt;= m-&gt;object-&gt;wired_page_count);
	delta = (m-&gt;object-&gt;resident_page_count - m-&gt;object-&gt;wired_page_count);
	assert(vm_page_purgeable_count &gt;= delta);
	assert(delta &gt; 0);
	OSAddAtomic(-delta, (SInt32 *)&amp;vm_page_purgeable_count);
    }
	
    vm_page_free(m);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
    vm_object_unlock(object);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>
}

<span class="enscript-comment">/*
 Grab locks for hibernate_page_list_setall()
*/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_vm_lock_queues</span>(<span class="enscript-type">void</span>)
{
    vm_object_lock(compressor_object);
    vm_page_lock_queues();
    lck_mtx_lock(&amp;vm_page_queue_free_lock);

    <span class="enscript-keyword">if</span> (vm_page_local_q) {
	uint32_t  i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++) {
	    <span class="enscript-type">struct</span> vpl	*lq;
	    lq = &amp;vm_page_local_q[i].vpl_un.vpl;
	    VPL_LOCK(&amp;lq-&gt;vpl_lock);
	}
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_vm_unlock_queues</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (vm_page_local_q) {
	uint32_t  i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++) {
	    <span class="enscript-type">struct</span> vpl	*lq;
	    lq = &amp;vm_page_local_q[i].vpl_un.vpl;
	    VPL_UNLOCK(&amp;lq-&gt;vpl_lock);
	}
    }
    lck_mtx_unlock(&amp;vm_page_queue_free_lock);
    vm_page_unlock_queues();
    vm_object_unlock(compressor_object);
}

<span class="enscript-comment">/*
 Bits zero in the bitmaps =&gt; page needs to be saved. All pages default to be saved,
 pages known to VM to not need saving are subtracted.
 Wired pages to be saved are present in page_list_wired, pageable in page_list.
*/</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_page_list_setall</span>(hibernate_page_list_t * page_list,
			   hibernate_page_list_t * page_list_wired,
			   hibernate_page_list_t * page_list_pal,
			   boolean_t preflight, 
			   boolean_t will_discard,
			   uint32_t * pagesOut)
{
    uint64_t start, end, nsec;
    vm_page_t m;
    vm_page_t next;
    uint32_t pages = page_list-&gt;page_count;
    uint32_t count_anonymous = 0, count_throttled = 0, count_compressor = 0;
    uint32_t count_inactive = 0, count_active = 0, count_speculative = 0, count_cleaned = 0;
    uint32_t count_wire = pages;
    uint32_t count_discard_active    = 0;
    uint32_t count_discard_inactive  = 0;
    uint32_t count_discard_cleaned   = 0;
    uint32_t count_discard_purgeable = 0;
    uint32_t count_discard_speculative = 0;
    uint32_t count_discard_vm_struct_pages = 0;
    uint32_t i;
    uint32_t             bank;
    hibernate_bitmap_t * bitmap;
    hibernate_bitmap_t * bitmap_wired;
    boolean_t			 discard_all;
    boolean_t            discard;

    HIBLOG(<span class="enscript-string">&quot;hibernate_page_list_setall(preflight %d) start\n&quot;</span>, preflight);

    <span class="enscript-keyword">if</span> (preflight) {
        page_list       = NULL;
        page_list_wired = NULL;
        page_list_pal   = NULL;
		discard_all     = FALSE;
    } <span class="enscript-keyword">else</span> {
		discard_all     = will_discard;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-keyword">if</span> (!preflight)
    {
        vm_page_lock_queues();
	<span class="enscript-keyword">if</span> (vm_page_local_q) {
	    <span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++) {
		<span class="enscript-type">struct</span> vpl	*lq;
		lq = &amp;vm_page_local_q[i].vpl_un.vpl;
		VPL_LOCK(&amp;lq-&gt;vpl_lock);
	    }
	}
    }
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>


    KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 8) | DBG_FUNC_START, count_wire, 0, 0, 0, 0);

    clock_get_uptime(&amp;start);

    <span class="enscript-keyword">if</span> (!preflight) {
	hibernate_page_list_zero(page_list);
	hibernate_page_list_zero(page_list_wired);
	hibernate_page_list_zero(page_list_pal);
    
	hibernate_stats.cd_vm_page_wire_count = vm_page_wire_count;
	hibernate_stats.cd_pages = pages;
    }

    <span class="enscript-keyword">if</span> (vm_page_local_q) {
	    <span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++)
		    vm_page_reactivate_local(i, TRUE, !preflight);
    }

    <span class="enscript-keyword">if</span> (preflight) {
	vm_object_lock(compressor_object);
	vm_page_lock_queues();
	lck_mtx_lock(&amp;vm_page_queue_free_lock);
    }

    m = (vm_page_t) hibernate_gobble_queue;
    <span class="enscript-keyword">while</span> (m)
    {
	pages--;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) {
	    hibernate_page_bitset(page_list,       TRUE, m-&gt;phys_page);
	    hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
	}
	m = (vm_page_t) m-&gt;pageq.next;
    }

    <span class="enscript-keyword">if</span> (!preflight) <span class="enscript-keyword">for</span>( i = 0; i &lt; real_ncpus; i++ )
    {
	<span class="enscript-keyword">if</span> (cpu_data_ptr[i] &amp;&amp; cpu_data_ptr[i]-&gt;cpu_processor)
	{
	    <span class="enscript-keyword">for</span> (m = PROCESSOR_DATA(cpu_data_ptr[i]-&gt;cpu_processor, free_pages); m; m = (vm_page_t)m-&gt;pageq.next)
	    {
		pages--;
		count_wire--;
		hibernate_page_bitset(page_list,       TRUE, m-&gt;phys_page);
		hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);

		hibernate_stats.cd_local_free++;
		hibernate_stats.cd_total_free++;
	    }
	}
    }

    <span class="enscript-keyword">for</span>( i = 0; i &lt; vm_colors; i++ )
    {
	queue_iterate(&amp;vm_page_queue_free[i],
		      m,
		      vm_page_t,
		      pageq)
	{
	    pages--;
	    count_wire--;
	    <span class="enscript-keyword">if</span> (!preflight) {
		hibernate_page_bitset(page_list,       TRUE, m-&gt;phys_page);
		hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
    
		hibernate_stats.cd_total_free++;
	    }
	}
    }

    queue_iterate(&amp;vm_lopage_queue_free,
		  m,
		  vm_page_t,
		  pageq)
    {
	pages--;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) {
	    hibernate_page_bitset(page_list,       TRUE, m-&gt;phys_page);
	    hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
    
	    hibernate_stats.cd_total_free++;
	}
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_throttled);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_throttled, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
	discard = FALSE;
        <span class="enscript-keyword">if</span> ((kIOHibernateModeDiscardCleanInactive &amp; gIOHibernateMode) 
         &amp;&amp; hibernate_consider_discard(m, preflight))
        {
            <span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list, TRUE, m-&gt;phys_page);
            count_discard_inactive++;
            discard = discard_all;
        }
        <span class="enscript-keyword">else</span>
            count_throttled++;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);

        <span class="enscript-keyword">if</span> (discard) hibernate_discard_page(m);
	m = next;
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_anonymous);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_anonymous, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
	discard = FALSE;
        <span class="enscript-keyword">if</span> ((kIOHibernateModeDiscardCleanInactive &amp; gIOHibernateMode) 
         &amp;&amp; hibernate_consider_discard(m, preflight))
        {
            <span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list, TRUE, m-&gt;phys_page);
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_inactive++;
            discard = discard_all;
        }
        <span class="enscript-keyword">else</span>
            count_anonymous++;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
        <span class="enscript-keyword">if</span> (discard)    hibernate_discard_page(m);
	m = next;
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_cleaned);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_cleaned, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
	discard = FALSE;
        <span class="enscript-keyword">if</span> ((kIOHibernateModeDiscardCleanInactive &amp; gIOHibernateMode) 
         &amp;&amp; hibernate_consider_discard(m, preflight))
        {
            <span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list, TRUE, m-&gt;phys_page);
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_cleaned++;
            discard = discard_all;
        }
        <span class="enscript-keyword">else</span>
            count_cleaned++;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
        <span class="enscript-keyword">if</span> (discard)    hibernate_discard_page(m);
	m = next;
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_active);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_active, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
	discard = FALSE;
        <span class="enscript-keyword">if</span> ((kIOHibernateModeDiscardCleanActive &amp; gIOHibernateMode) 
         &amp;&amp; hibernate_consider_discard(m, preflight))
        {
            <span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list, TRUE, m-&gt;phys_page);
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_active++;
            discard = discard_all;
        }
        <span class="enscript-keyword">else</span>
            count_active++;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
        <span class="enscript-keyword">if</span> (discard)    hibernate_discard_page(m);
	m = next;
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_inactive);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_inactive, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
	discard = FALSE;
        <span class="enscript-keyword">if</span> ((kIOHibernateModeDiscardCleanInactive &amp; gIOHibernateMode) 
         &amp;&amp; hibernate_consider_discard(m, preflight))
        {
            <span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list, TRUE, m-&gt;phys_page);
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_inactive++;
            discard = discard_all;
        }
        <span class="enscript-keyword">else</span>
            count_inactive++;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
        <span class="enscript-keyword">if</span> (discard)    hibernate_discard_page(m);
	m = next;
    }

    <span class="enscript-keyword">for</span>( i = 0; i &lt;= VM_PAGE_MAX_SPECULATIVE_AGE_Q; i++ )
    {
	m = (vm_page_t) queue_first(&amp;vm_page_queue_speculative[i].age_q);
	<span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_speculative[i].age_q, (queue_entry_t)m))
	{
	    next = (vm_page_t) m-&gt;pageq.next;
	    discard = FALSE;
	    <span class="enscript-keyword">if</span> ((kIOHibernateModeDiscardCleanInactive &amp; gIOHibernateMode) 
	     &amp;&amp; hibernate_consider_discard(m, preflight))
	    {
		<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list, TRUE, m-&gt;phys_page);
		count_discard_speculative++;
		discard = discard_all;
	    }
	    <span class="enscript-keyword">else</span>
		count_speculative++;
	    count_wire--;
	    <span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
	    <span class="enscript-keyword">if</span> (discard)    hibernate_discard_page(m);
	    m = next;
	}
    }

    queue_iterate(&amp;compressor_object-&gt;memq, m, vm_page_t, listq)
    {
        count_compressor++;
	count_wire--;
	<span class="enscript-keyword">if</span> (!preflight) hibernate_page_bitset(page_list_wired, TRUE, m-&gt;phys_page);
    }

    <span class="enscript-keyword">if</span> (preflight == FALSE &amp;&amp; discard_all == TRUE) {
	    KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 12) | DBG_FUNC_START, 0, 0, 0, 0, 0);

	    HIBLOG(<span class="enscript-string">&quot;hibernate_teardown started\n&quot;</span>);
	    count_discard_vm_struct_pages = hibernate_teardown_vm_structs(page_list, page_list_wired);
	    HIBLOG(<span class="enscript-string">&quot;hibernate_teardown completed - discarded %d\n&quot;</span>, count_discard_vm_struct_pages);

	    pages -= count_discard_vm_struct_pages;
	    count_wire -= count_discard_vm_struct_pages;

	    hibernate_stats.cd_vm_struct_pages_unneeded = count_discard_vm_struct_pages;

	    KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 13) | DBG_FUNC_END, 0, 0, 0, 0, 0);
    }

    <span class="enscript-keyword">if</span> (!preflight) {
	<span class="enscript-comment">// pull wired from hibernate_bitmap
</span>	bitmap = &amp;page_list-&gt;bank_bitmap[0];
	bitmap_wired = &amp;page_list_wired-&gt;bank_bitmap[0];
	<span class="enscript-keyword">for</span> (bank = 0; bank &lt; page_list-&gt;bank_count; bank++)
	{
	    <span class="enscript-keyword">for</span> (i = 0; i &lt; bitmap-&gt;bitmapwords; i++)
		bitmap-&gt;bitmap[i] = bitmap-&gt;bitmap[i] | ~bitmap_wired-&gt;bitmap[i];
	    bitmap       = (hibernate_bitmap_t *) &amp;bitmap-&gt;bitmap      [bitmap-&gt;bitmapwords];
	    bitmap_wired = (hibernate_bitmap_t *) &amp;bitmap_wired-&gt;bitmap[bitmap_wired-&gt;bitmapwords];
	}
    }

    <span class="enscript-comment">// machine dependent adjustments
</span>    hibernate_page_list_setall_machine(page_list, page_list_wired, preflight, &amp;pages);

    <span class="enscript-keyword">if</span> (!preflight) {
	hibernate_stats.cd_count_wire = count_wire;
	hibernate_stats.cd_discarded = count_discard_active + count_discard_inactive + count_discard_purgeable +
		count_discard_speculative + count_discard_cleaned + count_discard_vm_struct_pages;
    }

    clock_get_uptime(&amp;end);
    absolutetime_to_nanoseconds(end - start, &amp;nsec);
    HIBLOG(<span class="enscript-string">&quot;hibernate_page_list_setall time: %qd ms\n&quot;</span>, nsec / 1000000ULL);

    HIBLOG(<span class="enscript-string">&quot;pages %d, wire %d, act %d, inact %d, cleaned %d spec %d, zf %d, throt %d, compr %d, xpmapped %d\n  %s discard act %d inact %d purgeable %d spec %d cleaned %d\n&quot;</span>, 
	   pages, count_wire, count_active, count_inactive, count_cleaned, count_speculative, count_anonymous, count_throttled, count_compressor, hibernate_stats.cd_found_xpmapped,
	        discard_all ? <span class="enscript-string">&quot;did&quot;</span> : <span class="enscript-string">&quot;could&quot;</span>,
	        count_discard_active, count_discard_inactive, count_discard_purgeable, count_discard_speculative, count_discard_cleaned);

    <span class="enscript-keyword">if</span> (hibernate_stats.cd_skipped_xpmapped)
	    HIBLOG(<span class="enscript-string">&quot;WARNING: hibernate_page_list_setall skipped %d xpmapped pages\n&quot;</span>, hibernate_stats.cd_skipped_xpmapped);

    *pagesOut = pages - count_discard_active - count_discard_inactive - count_discard_purgeable - count_discard_speculative - count_discard_cleaned;

    <span class="enscript-keyword">if</span> (preflight &amp;&amp; will_discard) *pagesOut -= count_compressor + count_throttled + count_anonymous + count_inactive + count_cleaned + count_speculative + count_active;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-keyword">if</span> (!preflight)
    {
	<span class="enscript-keyword">if</span> (vm_page_local_q) {
	    <span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++) {
		<span class="enscript-type">struct</span> vpl	*lq;
		lq = &amp;vm_page_local_q[i].vpl_un.vpl;
		VPL_UNLOCK(&amp;lq-&gt;vpl_lock);
	    }
	}
        vm_page_unlock_queues();
    }
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>

    <span class="enscript-keyword">if</span> (preflight) {
	lck_mtx_unlock(&amp;vm_page_queue_free_lock);
	vm_page_unlock_queues();
	vm_object_unlock(compressor_object);
    }

    KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 8) | DBG_FUNC_END, count_wire, *pagesOut, 0, 0, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_page_list_discard</span>(hibernate_page_list_t * page_list)
{
    uint64_t  start, end, nsec;
    vm_page_t m;
    vm_page_t next;
    uint32_t  i;
    uint32_t  count_discard_active    = 0;
    uint32_t  count_discard_inactive  = 0;
    uint32_t  count_discard_purgeable = 0;
    uint32_t  count_discard_cleaned   = 0;
    uint32_t  count_discard_speculative = 0;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
        vm_page_lock_queues();
	<span class="enscript-keyword">if</span> (vm_page_local_q) {
	    <span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++) {
		<span class="enscript-type">struct</span> vpl	*lq;
		lq = &amp;vm_page_local_q[i].vpl_un.vpl;
		VPL_LOCK(&amp;lq-&gt;vpl_lock);
	    }
	}
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>

    clock_get_uptime(&amp;start);

    m = (vm_page_t) queue_first(&amp;vm_page_queue_anonymous);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_anonymous, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
        <span class="enscript-keyword">if</span> (hibernate_page_bittst(page_list, m-&gt;phys_page))
        {
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_inactive++;
            hibernate_discard_page(m);
        }
        m = next;
    }

    <span class="enscript-keyword">for</span>( i = 0; i &lt;= VM_PAGE_MAX_SPECULATIVE_AGE_Q; i++ )
    {
       m = (vm_page_t) queue_first(&amp;vm_page_queue_speculative[i].age_q);
       <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_speculative[i].age_q, (queue_entry_t)m))
       {
           next = (vm_page_t) m-&gt;pageq.next;
           <span class="enscript-keyword">if</span> (hibernate_page_bittst(page_list, m-&gt;phys_page))
           {
               count_discard_speculative++;
               hibernate_discard_page(m);
           }
           m = next;
       }
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_inactive);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_inactive, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
        <span class="enscript-keyword">if</span> (hibernate_page_bittst(page_list, m-&gt;phys_page))
        {
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_inactive++;
            hibernate_discard_page(m);
        }
        m = next;
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_active);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_active, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
        <span class="enscript-keyword">if</span> (hibernate_page_bittst(page_list, m-&gt;phys_page))
        {
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_active++;
            hibernate_discard_page(m);
        }
        m = next;
    }

    m = (vm_page_t) queue_first(&amp;vm_page_queue_cleaned);
    <span class="enscript-keyword">while</span> (m &amp;&amp; !queue_end(&amp;vm_page_queue_cleaned, (queue_entry_t)m))
    {
        next = (vm_page_t) m-&gt;pageq.next;
        <span class="enscript-keyword">if</span> (hibernate_page_bittst(page_list, m-&gt;phys_page))
        {
	    <span class="enscript-keyword">if</span> (m-&gt;dirty)
		count_discard_purgeable++;
	    <span class="enscript-keyword">else</span>
		count_discard_cleaned++;
            hibernate_discard_page(m);
        }
        m = next;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (vm_page_local_q) {
	    <span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_local_q_count; i++) {
		<span class="enscript-type">struct</span> vpl	*lq;
		lq = &amp;vm_page_local_q[i].vpl_un.vpl;
		VPL_UNLOCK(&amp;lq-&gt;vpl_lock);
	    }
	}
        vm_page_unlock_queues();
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>

    clock_get_uptime(&amp;end);
    absolutetime_to_nanoseconds(end - start, &amp;nsec);
    HIBLOG(<span class="enscript-string">&quot;hibernate_page_list_discard time: %qd ms, discarded act %d inact %d purgeable %d spec %d cleaned %d\n&quot;</span>,
                nsec / 1000000ULL,
	        count_discard_active, count_discard_inactive, count_discard_purgeable, count_discard_speculative, count_discard_cleaned);
}

boolean_t       hibernate_paddr_map_inited = FALSE;
boolean_t       hibernate_rebuild_needed = FALSE;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hibernate_teardown_last_valid_compact_indx = -1;
vm_page_t	hibernate_rebuild_hash_list = NULL;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hibernate_teardown_found_tabled_pages = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hibernate_teardown_found_created_pages = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hibernate_teardown_found_free_pages = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hibernate_teardown_vm_page_free_count;


<span class="enscript-type">struct</span> ppnum_mapping {
	<span class="enscript-type">struct</span> ppnum_mapping	*ppnm_next;
	ppnum_t			ppnm_base_paddr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		ppnm_sindx;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		ppnm_eindx;
};

<span class="enscript-type">struct</span> ppnum_mapping	*ppnm_head;
<span class="enscript-type">struct</span> ppnum_mapping	*ppnm_last_found = NULL;


<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_create_paddr_map</span>() 
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
	ppnum_t		next_ppnum_in_run = 0;
	<span class="enscript-type">struct</span> ppnum_mapping *ppnm = NULL;

	<span class="enscript-keyword">if</span> (hibernate_paddr_map_inited == FALSE) {

		<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_pages_count; i++) {

			<span class="enscript-keyword">if</span> (ppnm)
				ppnm-&gt;ppnm_eindx = i;

			<span class="enscript-keyword">if</span> (ppnm == NULL || vm_pages[i].phys_page != next_ppnum_in_run) {

				ppnm = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ppnum_mapping));

				ppnm-&gt;ppnm_next = ppnm_head;
				ppnm_head = ppnm;

				ppnm-&gt;ppnm_sindx = i;
				ppnm-&gt;ppnm_base_paddr = vm_pages[i].phys_page;
			}
			next_ppnum_in_run = vm_pages[i].phys_page + 1;
		}
		ppnm-&gt;ppnm_eindx++;

		hibernate_paddr_map_inited = TRUE;
	}
}

ppnum_t
<span class="enscript-function-name">hibernate_lookup_paddr</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> indx)
{
	<span class="enscript-type">struct</span> ppnum_mapping *ppnm = NULL;
	
	ppnm = ppnm_last_found;

	<span class="enscript-keyword">if</span> (ppnm) {
		<span class="enscript-keyword">if</span> (indx &gt;= ppnm-&gt;ppnm_sindx &amp;&amp; indx &lt; ppnm-&gt;ppnm_eindx)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">for</span> (ppnm = ppnm_head; ppnm; ppnm = ppnm-&gt;ppnm_next) {

		<span class="enscript-keyword">if</span> (indx &gt;= ppnm-&gt;ppnm_sindx &amp;&amp; indx &lt; ppnm-&gt;ppnm_eindx) {
			ppnm_last_found = ppnm;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (ppnm == NULL)
		panic(<span class="enscript-string">&quot;hibernate_lookup_paddr of %d failed\n&quot;</span>, indx);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (ppnm-&gt;ppnm_base_paddr + (indx - ppnm-&gt;ppnm_sindx));
}


uint32_t
<span class="enscript-function-name">hibernate_mark_as_unneeded</span>(addr64_t saddr, addr64_t eaddr, hibernate_page_list_t *page_list, hibernate_page_list_t *page_list_wired)
{
	addr64_t	saddr_aligned;
	addr64_t	eaddr_aligned;
	addr64_t	addr;
	ppnum_t		paddr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mark_as_unneeded_pages = 0;

	saddr_aligned = (saddr + PAGE_MASK_64) &amp; ~PAGE_MASK_64;
	eaddr_aligned = eaddr &amp; ~PAGE_MASK_64;

	<span class="enscript-keyword">for</span> (addr = saddr_aligned; addr &lt; eaddr_aligned; addr += PAGE_SIZE_64) {

		paddr = pmap_find_phys(kernel_pmap, addr);

		assert(paddr);

		hibernate_page_bitset(page_list,       TRUE, paddr);
		hibernate_page_bitset(page_list_wired, TRUE, paddr);

		mark_as_unneeded_pages++;
	}
	<span class="enscript-keyword">return</span> (mark_as_unneeded_pages);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_hash_insert_page</span>(vm_page_t mem)
{
	vm_page_bucket_t *bucket;
	<span class="enscript-type">int</span>		hash_id;

	assert(mem-&gt;hashed);
	assert(mem-&gt;object);
	assert(mem-&gt;offset != (vm_object_offset_t) -1);

	<span class="enscript-comment">/*
	 *	Insert it into the object_object/offset hash table
	 */</span>
	hash_id = vm_page_hash(mem-&gt;object, mem-&gt;offset);
	bucket = &amp;vm_page_buckets[hash_id];

	mem-&gt;next_m = bucket-&gt;page_list;
	bucket-&gt;page_list = VM_PAGE_PACK_PTR(mem);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_free_range</span>(<span class="enscript-type">int</span> sindx, <span class="enscript-type">int</span> eindx)
{
	vm_page_t	mem;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	color;

	<span class="enscript-keyword">while</span> (sindx &lt; eindx) {
		mem = &amp;vm_pages[sindx];

		vm_page_init(mem, hibernate_lookup_paddr(sindx), FALSE);

		mem-&gt;lopage = FALSE;
		mem-&gt;free = TRUE;

	        color = mem-&gt;phys_page &amp; vm_color_mask;
		queue_enter_first(&amp;vm_page_queue_free[color],
				  mem,
				  vm_page_t,
				  pageq);
		vm_page_free_count++;

		sindx++;
	}
}


<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hibernate_rebuild_pmap_structs</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_rebuild_vm_structs</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>		cindx, sindx, eindx;
	vm_page_t	mem, tmem, mem_next;
	AbsoluteTime	startTime, endTime;
	uint64_t	nsec;

	<span class="enscript-keyword">if</span> (hibernate_rebuild_needed == FALSE)
		<span class="enscript-keyword">return</span>;

	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 13) | DBG_FUNC_START, 0, 0, 0, 0, 0);
	HIBLOG(<span class="enscript-string">&quot;hibernate_rebuild started\n&quot;</span>);

	clock_get_uptime(&amp;startTime);

	hibernate_rebuild_pmap_structs();

	bzero(&amp;vm_page_buckets[0], vm_page_bucket_count * <span class="enscript-keyword">sizeof</span>(vm_page_bucket_t));
	eindx = vm_pages_count;

	<span class="enscript-keyword">for</span> (cindx = hibernate_teardown_last_valid_compact_indx; cindx &gt;= 0; cindx--) {
		
		mem = &amp;vm_pages[cindx];
		<span class="enscript-comment">/*
		 * hibernate_teardown_vm_structs leaves the location where
		 * this vm_page_t must be located in &quot;next&quot;.
		 */</span>
		tmem = VM_PAGE_UNPACK_PTR(mem-&gt;next_m);
		mem-&gt;next_m = VM_PAGE_PACK_PTR(NULL);

		sindx = (<span class="enscript-type">int</span>)(tmem - &amp;vm_pages[0]);

		<span class="enscript-keyword">if</span> (mem != tmem) {
			<span class="enscript-comment">/*
			 * this vm_page_t was moved by hibernate_teardown_vm_structs,
			 * so move it back to its real location
			 */</span>
			*tmem = *mem;
			mem = tmem;
		}
		<span class="enscript-keyword">if</span> (mem-&gt;hashed)
			hibernate_hash_insert_page(mem);
		<span class="enscript-comment">/*
		 * the 'hole' between this vm_page_t and the previous
		 * vm_page_t we moved needs to be initialized as 
		 * a range of free vm_page_t's
		 */</span>
		hibernate_free_range(sindx + 1, eindx);

		eindx = sindx;
	}
	<span class="enscript-keyword">if</span> (sindx)
		hibernate_free_range(0, sindx);

	assert(vm_page_free_count == hibernate_teardown_vm_page_free_count);

	<span class="enscript-comment">/*
	 * process the list of vm_page_t's that were entered in the hash,
	 * but were not located in the vm_pages arrary... these are 
	 * vm_page_t's that were created on the fly (i.e. fictitious)
	 */</span>
	<span class="enscript-keyword">for</span> (mem = hibernate_rebuild_hash_list; mem; mem = mem_next) {
		mem_next = VM_PAGE_UNPACK_PTR(mem-&gt;next_m);

		mem-&gt;next_m = VM_PAGE_PACK_PTR(NULL);
		hibernate_hash_insert_page(mem);
	}
	hibernate_rebuild_hash_list = NULL;

        clock_get_uptime(&amp;endTime);
        SUB_ABSOLUTETIME(&amp;endTime, &amp;startTime);
        absolutetime_to_nanoseconds(endTime, &amp;nsec);

	HIBLOG(<span class="enscript-string">&quot;hibernate_rebuild completed - took %qd msecs\n&quot;</span>, nsec / 1000000ULL);

	hibernate_rebuild_needed = FALSE;

	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 13) | DBG_FUNC_END, 0, 0, 0, 0, 0);
}


<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hibernate_teardown_pmap_structs</span>(addr64_t *, addr64_t *);

uint32_t
<span class="enscript-function-name">hibernate_teardown_vm_structs</span>(hibernate_page_list_t *page_list, hibernate_page_list_t *page_list_wired)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	compact_target_indx;
	vm_page_t	mem, mem_next;
	vm_page_bucket_t *bucket;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mark_as_unneeded_pages = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	unneeded_vm_page_bucket_pages = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	unneeded_vm_pages_pages = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	unneeded_pmap_pages = 0;
	addr64_t	start_of_unneeded = 0;
	addr64_t	end_of_unneeded = 0;

	
	<span class="enscript-keyword">if</span> (hibernate_should_abort())
		<span class="enscript-keyword">return</span> (0);

	HIBLOG(<span class="enscript-string">&quot;hibernate_teardown: wired_pages %d, free_pages %d, active_pages %d, inactive_pages %d, speculative_pages %d, cleaned_pages %d, compressor_pages %d\n&quot;</span>,
	       vm_page_wire_count, vm_page_free_count, vm_page_active_count, vm_page_inactive_count, vm_page_speculative_count,
	       vm_page_cleaned_count, compressor_object-&gt;resident_page_count);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_bucket_count; i++) {

		bucket = &amp;vm_page_buckets[i];

		<span class="enscript-keyword">for</span> (mem = VM_PAGE_UNPACK_PTR(bucket-&gt;page_list); mem != VM_PAGE_NULL; mem = mem_next) {
			assert(mem-&gt;hashed);

			mem_next = VM_PAGE_UNPACK_PTR(mem-&gt;next_m);

			<span class="enscript-keyword">if</span> (mem &lt; &amp;vm_pages[0] || mem &gt;= &amp;vm_pages[vm_pages_count]) {
				mem-&gt;next_m = VM_PAGE_PACK_PTR(hibernate_rebuild_hash_list);
				hibernate_rebuild_hash_list = mem;
			}
		}
	}
	unneeded_vm_page_bucket_pages = hibernate_mark_as_unneeded((addr64_t)&amp;vm_page_buckets[0], (addr64_t)&amp;vm_page_buckets[vm_page_bucket_count], page_list, page_list_wired);
	mark_as_unneeded_pages += unneeded_vm_page_bucket_pages;

	hibernate_teardown_vm_page_free_count = vm_page_free_count;

	compact_target_indx = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_pages_count; i++) {

		mem = &amp;vm_pages[i];

		<span class="enscript-keyword">if</span> (mem-&gt;free) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> color;

			assert(mem-&gt;busy);
			assert(!mem-&gt;lopage);

			color = mem-&gt;phys_page &amp; vm_color_mask;

			queue_remove(&amp;vm_page_queue_free[color],
				     mem,
				     vm_page_t,
				     pageq);
			mem-&gt;pageq.next = NULL;
			mem-&gt;pageq.prev = NULL;

			vm_page_free_count--;

			hibernate_teardown_found_free_pages++;

			<span class="enscript-keyword">if</span> ( !vm_pages[compact_target_indx].free)
				compact_target_indx = i;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * record this vm_page_t's original location
			 * we need this even if it doesn't get moved
			 * as an indicator to the rebuild function that
			 * we don't have to move it
			 */</span>
			mem-&gt;next_m = VM_PAGE_PACK_PTR(mem);

			<span class="enscript-keyword">if</span> (vm_pages[compact_target_indx].free) {
				<span class="enscript-comment">/*
				 * we've got a hole to fill, so
				 * move this vm_page_t to it's new home
				 */</span>
				vm_pages[compact_target_indx] = *mem;
				mem-&gt;free = TRUE;

				hibernate_teardown_last_valid_compact_indx = compact_target_indx;
				compact_target_indx++;
			} <span class="enscript-keyword">else</span>
				hibernate_teardown_last_valid_compact_indx = i;
		}
	}
	unneeded_vm_pages_pages = hibernate_mark_as_unneeded((addr64_t)&amp;vm_pages[hibernate_teardown_last_valid_compact_indx+1],
							     (addr64_t)&amp;vm_pages[vm_pages_count-1], page_list, page_list_wired);
	mark_as_unneeded_pages += unneeded_vm_pages_pages;

	hibernate_teardown_pmap_structs(&amp;start_of_unneeded, &amp;end_of_unneeded);

	<span class="enscript-keyword">if</span> (start_of_unneeded) {
		unneeded_pmap_pages = hibernate_mark_as_unneeded(start_of_unneeded, end_of_unneeded, page_list, page_list_wired);
		mark_as_unneeded_pages += unneeded_pmap_pages;
	}
	HIBLOG(<span class="enscript-string">&quot;hibernate_teardown: mark_as_unneeded_pages %d, %d, %d\n&quot;</span>, unneeded_vm_page_bucket_pages, unneeded_vm_pages_pages, unneeded_pmap_pages);

	hibernate_rebuild_needed = TRUE;

	<span class="enscript-keyword">return</span> (mark_as_unneeded_pages);
}


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_vm_debug.h&gt;</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_VM_DEBUG</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/hash_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_debug.h&gt;</span>

<span class="enscript-comment">/*
 *	Routine:	vm_page_info
 *	Purpose:
 *		Return information about the global VP table.
 *		Fills the buffer with as much information as possible
 *		and returns the desired size of the buffer.
 *	Conditions:
 *		Nothing locked.  The caller should provide
 *		possibly-pageable memory.
 */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vm_page_info</span>(
	hash_info_bucket_t *info,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	lck_spin_t	*bucket_lock;

	<span class="enscript-keyword">if</span> (vm_page_bucket_count &lt; count)
		count = vm_page_bucket_count;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		vm_page_bucket_t *bucket = &amp;vm_page_buckets[i];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_count = 0;
		vm_page_t m;

		bucket_lock = &amp;vm_page_bucket_locks[i / BUCKETS_PER_LOCK];
		lck_spin_lock(bucket_lock);

		<span class="enscript-keyword">for</span> (m = VM_PAGE_UNPACK_PTR(bucket-&gt;page_list); m != VM_PAGE_NULL; m = VM_PAGE_UNPACK_PTR(m-&gt;next_m))
			bucket_count++;

		lck_spin_unlock(bucket_lock);

		<span class="enscript-comment">/* don't touch pageable memory while holding locks */</span>
		info[i].hib_count = bucket_count;
	}

	<span class="enscript-keyword">return</span> vm_page_bucket_count;
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_VM_DEBUG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_BUCKETS_CHECK</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_buckets_check</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	vm_page_t p;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_hash;
	vm_page_bucket_t *bucket;
	lck_spin_t	*bucket_lock;

	<span class="enscript-keyword">if</span> (!vm_page_buckets_check_ready) {
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	<span class="enscript-keyword">if</span> (hibernate_rebuild_needed ||
	    hibernate_rebuild_hash_list) {
		panic(<span class="enscript-string">&quot;BUCKET_CHECK: hibernation in progress: &quot;</span>
		      <span class="enscript-string">&quot;rebuild_needed=%d rebuild_hash_list=%p\n&quot;</span>,
		      hibernate_rebuild_needed,
		      hibernate_rebuild_hash_list);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_FAKE_BUCKETS</span>
	<span class="enscript-type">char</span> *cp;
	<span class="enscript-keyword">for</span> (cp = (<span class="enscript-type">char</span> *) vm_page_fake_buckets_start;
	     cp &lt; (<span class="enscript-type">char</span> *) vm_page_fake_buckets_end;
	     cp++) {
		<span class="enscript-keyword">if</span> (*cp != 0x5a) {
			panic(<span class="enscript-string">&quot;BUCKET_CHECK: corruption at %p in fake buckets &quot;</span>
			      <span class="enscript-string">&quot;[0x%llx:0x%llx]\n&quot;</span>,
			      cp,
			      (uint64_t) vm_page_fake_buckets_start,
			      (uint64_t) vm_page_fake_buckets_end);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_FAKE_BUCKETS */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vm_page_bucket_count; i++) {
		bucket = &amp;vm_page_buckets[i];
		<span class="enscript-keyword">if</span> (!bucket-&gt;page_list) {
			<span class="enscript-keyword">continue</span>;
		}

		bucket_lock = &amp;vm_page_bucket_locks[i / BUCKETS_PER_LOCK];
		lck_spin_lock(bucket_lock);
		p = VM_PAGE_UNPACK_PTR(bucket-&gt;page_list);
		<span class="enscript-keyword">while</span> (p != VM_PAGE_NULL) {
			<span class="enscript-keyword">if</span> (!p-&gt;hashed) {
				panic(<span class="enscript-string">&quot;BUCKET_CHECK: page %p (%p,0x%llx) &quot;</span>
				      <span class="enscript-string">&quot;hash %d in bucket %d at %p &quot;</span>
				      <span class="enscript-string">&quot;is not hashed\n&quot;</span>,
				      p, p-&gt;object, p-&gt;offset,
				      p_hash, i, bucket);
			}
			p_hash = vm_page_hash(p-&gt;object, p-&gt;offset);
			<span class="enscript-keyword">if</span> (p_hash != i) {
				panic(<span class="enscript-string">&quot;BUCKET_CHECK: corruption in bucket %d &quot;</span>
				      <span class="enscript-string">&quot;at %p: page %p object %p offset 0x%llx &quot;</span>
				      <span class="enscript-string">&quot;hash %d\n&quot;</span>,
				      i, bucket, p, p-&gt;object, p-&gt;offset,
				      p_hash);
			}
			p = VM_PAGE_UNPACK_PTR(p-&gt;next_m);
		}
		lck_spin_unlock(bucket_lock);
	}

<span class="enscript-comment">//	printf(&quot;BUCKET_CHECK: checked buckets\n&quot;);
</span>}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_BUCKETS_CHECK */</span>

<span class="enscript-comment">/*
 * 'vm_fault_enter' will place newly created pages (zero-fill and COW) onto the
 * local queues if they exist... its the only spot in the system where we add pages
 * to those queues...  once on those queues, those pages can only move to one of the
 * global page queues or the free queues... they NEVER move from local q to local q.
 * the 'local' state is stable when vm_page_queues_remove is called since we're behind
 * the global vm_page_queue_lock at this point...  we still need to take the local lock
 * in case this operation is being run on a different CPU then the local queue's identity,
 * but we don't have to worry about the page moving to a global queue or becoming wired
 * while we're grabbing the local lock since those operations would require the global
 * vm_page_queue_lock to be held, and we already own it.
 *
 * this is why its safe to utilze the wire_count field in the vm_page_t as the local_id...
 * 'wired' and local are ALWAYS mutually exclusive conditions.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_queues_remove</span>(vm_page_t mem)
{
	boolean_t	was_pageable;

	VM_PAGE_QUEUES_ASSERT(mem, 1);
	assert(!mem-&gt;pageout_queue);
	<span class="enscript-comment">/*
	 *	if (mem-&gt;pageout_queue)
	 * 		NOTE: vm_page_queues_remove does not deal with removing pages from the pageout queue...
	 * 		the caller is responsible for determing if the page is on that queue, and if so, must
	 * 		either first remove it (it needs both the page queues lock and the object lock to do
	 * 		this via vm_pageout_steal_laundry), or avoid the call to vm_page_queues_remove
	 */</span>
	<span class="enscript-keyword">if</span> (mem-&gt;local) {
		<span class="enscript-type">struct</span> vpl	*lq;
		assert(mem-&gt;object != kernel_object);
		assert(mem-&gt;object != compressor_object);
		assert(!mem-&gt;inactive &amp;&amp; !mem-&gt;speculative);
		assert(!mem-&gt;active &amp;&amp; !mem-&gt;throttled);
		assert(!mem-&gt;clean_queue);
		assert(!mem-&gt;fictitious);
		lq = &amp;vm_page_local_q[mem-&gt;local_id].vpl_un.vpl;
		VPL_LOCK(&amp;lq-&gt;vpl_lock);
		queue_remove(&amp;lq-&gt;vpl_queue,
			     mem, vm_page_t, pageq);
		mem-&gt;local = FALSE;
		mem-&gt;local_id = 0;
		lq-&gt;vpl_count--;
		<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal) {
			lq-&gt;vpl_internal_count--;
		} <span class="enscript-keyword">else</span> {
			lq-&gt;vpl_external_count--;
		}
		VPL_UNLOCK(&amp;lq-&gt;vpl_lock);
		was_pageable = FALSE;
	}

	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;active) {
		assert(mem-&gt;object != kernel_object);
		assert(mem-&gt;object != compressor_object);
		assert(!mem-&gt;inactive &amp;&amp; !mem-&gt;speculative);
		assert(!mem-&gt;clean_queue);
		assert(!mem-&gt;throttled);
		assert(!mem-&gt;fictitious);
		queue_remove(&amp;vm_page_queue_active,
			mem, vm_page_t, pageq);
		mem-&gt;active = FALSE;
		vm_page_active_count--;
		was_pageable = TRUE;
	}

	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;inactive) {
		assert(mem-&gt;object != kernel_object);
		assert(mem-&gt;object != compressor_object);
		assert(!mem-&gt;active &amp;&amp; !mem-&gt;speculative);
		assert(!mem-&gt;throttled);
		assert(!mem-&gt;fictitious);
		vm_page_inactive_count--;
		<span class="enscript-keyword">if</span> (mem-&gt;clean_queue) {
			queue_remove(&amp;vm_page_queue_cleaned,
                        mem, vm_page_t, pageq);
			mem-&gt;clean_queue = FALSE;
			vm_page_cleaned_count--;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal) {
				queue_remove(&amp;vm_page_queue_anonymous,
				mem, vm_page_t, pageq);
				vm_page_anonymous_count--;
			} <span class="enscript-keyword">else</span> {
				queue_remove(&amp;vm_page_queue_inactive,
				mem, vm_page_t, pageq);
			}
			vm_purgeable_q_advance_all();
		}
		mem-&gt;inactive = FALSE;
		was_pageable = TRUE;
	}

	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;throttled) {
		assert(mem-&gt;object != compressor_object);
		assert(!mem-&gt;active &amp;&amp; !mem-&gt;inactive);
		assert(!mem-&gt;speculative);
		assert(!mem-&gt;fictitious);
		queue_remove(&amp;vm_page_queue_throttled,
			     mem, vm_page_t, pageq);
		mem-&gt;throttled = FALSE;
		vm_page_throttled_count--;
		was_pageable = FALSE;
	}

	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;speculative) {
		assert(mem-&gt;object != compressor_object);
		assert(!mem-&gt;active &amp;&amp; !mem-&gt;inactive);
		assert(!mem-&gt;throttled);
		assert(!mem-&gt;fictitious);
                remque(&amp;mem-&gt;pageq);
		mem-&gt;speculative = FALSE;
		vm_page_speculative_count--;
		was_pageable = TRUE;
	}

	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mem-&gt;pageq.next || mem-&gt;pageq.prev) {
		was_pageable = FALSE;
		panic(<span class="enscript-string">&quot;vm_page_queues_remove: unmarked page on Q&quot;</span>);
	} <span class="enscript-keyword">else</span> {
		was_pageable = FALSE;
	}

	mem-&gt;pageq.next = NULL;
	mem-&gt;pageq.prev = NULL;
	VM_PAGE_QUEUES_ASSERT(mem, 0);
	<span class="enscript-keyword">if</span> (was_pageable) {
		<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal) {
			vm_page_pageable_internal_count--;
		} <span class="enscript-keyword">else</span> {
			vm_page_pageable_external_count--;
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_remove_internal</span>(vm_page_t page)
{
	vm_object_t __object = page-&gt;object;
	<span class="enscript-keyword">if</span> (page == __object-&gt;memq_hint) {
		vm_page_t	__new_hint;
		queue_entry_t	__qe;
		__qe = queue_next(&amp;page-&gt;listq);
		<span class="enscript-keyword">if</span> (queue_end(&amp;__object-&gt;memq, __qe)) {
			__qe = queue_prev(&amp;page-&gt;listq);
			<span class="enscript-keyword">if</span> (queue_end(&amp;__object-&gt;memq, __qe)) {
				__qe = NULL;
			}
		}
		__new_hint = (vm_page_t) __qe;
		__object-&gt;memq_hint = __new_hint;
	}
	queue_remove(&amp;__object-&gt;memq, page, vm_page_t, listq);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_enqueue_inactive</span>(vm_page_t mem, boolean_t first)
{
	VM_PAGE_QUEUES_ASSERT(mem, 0);
	assert(!mem-&gt;fictitious);
	assert(!mem-&gt;laundry);
	assert(!mem-&gt;pageout_queue);
	vm_page_check_pageable_safe(mem);
	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal) {
		<span class="enscript-keyword">if</span> (first == TRUE)
			queue_enter_first(&amp;vm_page_queue_anonymous, mem, vm_page_t, pageq);
		<span class="enscript-keyword">else</span>
			queue_enter(&amp;vm_page_queue_anonymous, mem, vm_page_t, pageq);
		vm_page_anonymous_count++;
		vm_page_pageable_internal_count++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (first == TRUE)
			queue_enter_first(&amp;vm_page_queue_inactive, mem, vm_page_t, pageq);
		<span class="enscript-keyword">else</span>
			queue_enter(&amp;vm_page_queue_inactive, mem, vm_page_t, pageq);
		vm_page_pageable_external_count++;
	}
	mem-&gt;inactive = TRUE;
	vm_page_inactive_count++;
	token_new_pagecount++;
}

<span class="enscript-comment">/*
 * Pages from special kernel objects shouldn't
 * be placed on pageable queues.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_page_check_pageable_safe</span>(vm_page_t page)
{
	<span class="enscript-keyword">if</span> (page-&gt;object == kernel_object) {
		panic(<span class="enscript-string">&quot;vm_page_check_pageable_safe: trying to add page&quot;</span> \
			 <span class="enscript-string">&quot;from kernel object (%p) to pageable queue&quot;</span>, kernel_object);
	}

	<span class="enscript-keyword">if</span> (page-&gt;object == compressor_object) {
		panic(<span class="enscript-string">&quot;vm_page_check_pageable_safe: trying to add page&quot;</span> \
			 <span class="enscript-string">&quot;from compressor object (%p) to pageable queue&quot;</span>, compressor_object);
	}

	<span class="enscript-keyword">if</span> (page-&gt;object == vm_submap_object) {
		panic(<span class="enscript-string">&quot;vm_page_check_pageable_safe: trying to add page&quot;</span> \
			<span class="enscript-string">&quot;from submap object (%p) to pageable queue&quot;</span>, vm_submap_object);
	}
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * wired page diagnose
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSKextLibPrivate.h&gt;</span>

vm_allocation_site_t * 
vm_allocation_sites[VM_KERN_MEMORY_COUNT];

vm_tag_t 
<span class="enscript-function-name">vm_tag_bt</span>(<span class="enscript-type">void</span>)
{
    uintptr_t* frameptr;
    uintptr_t* frameptr_next;
    uintptr_t retaddr;
    uintptr_t kstackb, kstackt;
    <span class="enscript-type">const</span> vm_allocation_site_t * site;
    thread_t cthread;
    
    cthread = current_thread();
    <span class="enscript-keyword">if</span> (__improbable(cthread == NULL)) <span class="enscript-keyword">return</span> VM_KERN_MEMORY_OSFMK;

    kstackb = cthread-&gt;kernel_stack;
    kstackt = kstackb + kernel_stack_size;

    <span class="enscript-comment">/* Load stack frame pointer (EBP on x86) into frameptr */</span>
    frameptr = __builtin_frame_address(0);
    site = NULL;
    <span class="enscript-keyword">while</span> (frameptr != NULL) 
    {
	<span class="enscript-comment">/* Verify thread stack bounds */</span>
	<span class="enscript-keyword">if</span> (((uintptr_t)(frameptr + 2) &gt; kstackt) || ((uintptr_t)frameptr &lt; kstackb)) <span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/* Next frame pointer is pointed to by the previous one */</span>
	frameptr_next = (uintptr_t*) *frameptr;

	<span class="enscript-comment">/* Pull return address from one spot above the frame pointer */</span>
	retaddr = *(frameptr + 1);

	<span class="enscript-keyword">if</span> ((retaddr &lt; vm_kernel_stext) || (retaddr &gt; vm_kernel_top))
	{
	    site = OSKextGetAllocationSiteForCaller(retaddr);
	    <span class="enscript-keyword">break</span>;
	}

	frameptr = frameptr_next;
    }
    <span class="enscript-keyword">return</span> (site ? site-&gt;tag : VM_KERN_MEMORY_NONE);
}

<span class="enscript-type">static</span> uint64_t free_tag_bits[256/64];

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_tag_alloc_locked</span>(vm_allocation_site_t * site)
{
    vm_tag_t tag;
    uint64_t avail;
    uint64_t idx;

    <span class="enscript-keyword">if</span> (site-&gt;tag) <span class="enscript-keyword">return</span>;

    idx = 0;
    <span class="enscript-keyword">while</span> (TRUE)
    {
	avail = free_tag_bits[idx];
	<span class="enscript-keyword">if</span> (avail)
	{
	    tag = __builtin_clzll(avail);
	    avail &amp;= ~(1ULL &lt;&lt; (63 - tag));
	    free_tag_bits[idx] = avail;
	    tag += (idx &lt;&lt; 6);
	    <span class="enscript-keyword">break</span>;
	}
	idx++;
	<span class="enscript-keyword">if</span> (idx &gt;= (<span class="enscript-keyword">sizeof</span>(free_tag_bits) / <span class="enscript-keyword">sizeof</span>(free_tag_bits[0])))
	{
	     tag = VM_KERN_MEMORY_ANY;
	     <span class="enscript-keyword">break</span>;
	}
    }
    site-&gt;tag = tag;
    <span class="enscript-keyword">if</span> (VM_KERN_MEMORY_ANY != tag)
    {
	assert(!vm_allocation_sites[tag]);
	vm_allocation_sites[tag] = site;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_tag_free_locked</span>(vm_tag_t tag)
{
    uint64_t avail;
    uint32_t idx;
    uint64_t bit;

    <span class="enscript-keyword">if</span> (VM_KERN_MEMORY_ANY == tag) <span class="enscript-keyword">return</span>;

    idx = (tag &gt;&gt; 6);
    avail = free_tag_bits[idx];
    tag &amp;= 63;
    bit = (1ULL &lt;&lt; (63 - tag));
    assert(!(avail &amp; bit));
    free_tag_bits[idx] = (avail | bit);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_tag_init</span>(<span class="enscript-type">void</span>)
{
    vm_tag_t tag;
    <span class="enscript-keyword">for</span> (tag = VM_KERN_MEMORY_FIRST_DYNAMIC; tag &lt; VM_KERN_MEMORY_ANY; tag++)
    {
        vm_tag_free_locked(tag);
    }
}

vm_tag_t
<span class="enscript-function-name">vm_tag_alloc</span>(vm_allocation_site_t * site)
{
    vm_tag_t tag;

    <span class="enscript-keyword">if</span> (VM_TAG_BT &amp; site-&gt;flags)
    {
	tag = vm_tag_bt();
	<span class="enscript-keyword">if</span> (VM_KERN_MEMORY_NONE != tag) <span class="enscript-keyword">return</span> (tag);
    }

    <span class="enscript-keyword">if</span> (!site-&gt;tag) 
    {
	lck_spin_lock(&amp;vm_allocation_sites_lock);
	vm_tag_alloc_locked(site);
	lck_spin_unlock(&amp;vm_allocation_sites_lock);
    }

    <span class="enscript-keyword">return</span> (site-&gt;tag);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vm_page_count_object</span>(mach_memory_info_t * sites, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> __unused num_sites, vm_object_t object)
{
    <span class="enscript-keyword">if</span> (!object-&gt;wired_page_count) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (object != kernel_object)
    {
	assert(object-&gt;wire_tag &lt; num_sites);
	sites[object-&gt;wire_tag].size += ptoa_64(object-&gt;wired_page_count);
    }
}

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*vm_page_iterate_proc)(mach_memory_info_t * sites, 
				     <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_sites, vm_object_t object);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vm_page_iterate_purgeable_objects</span>(mach_memory_info_t * sites, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_sites,
				  vm_page_iterate_proc proc, purgeable_q_t queue, 
				  <span class="enscript-type">int</span> group)
{
    vm_object_t object;

    <span class="enscript-keyword">for</span> (object = (vm_object_t) queue_first(&amp;queue-&gt;objq[group]);
	!queue_end(&amp;queue-&gt;objq[group], (queue_entry_t) object);
	object = (vm_object_t) queue_next(&amp;object-&gt;objq))
    {
	proc(sites, num_sites, object);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vm_page_iterate_objects</span>(mach_memory_info_t * sites, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_sites,
			vm_page_iterate_proc proc)
{
    purgeable_q_t   volatile_q;
    queue_head_t  * nonvolatile_q;
    vm_object_t     object;
    <span class="enscript-type">int</span>             group;

    lck_spin_lock(&amp;vm_objects_wired_lock);
    queue_iterate(&amp;vm_objects_wired,
		  object,
		  vm_object_t,
		  objq)
    {
	proc(sites, num_sites, object);
    }
    lck_spin_unlock(&amp;vm_objects_wired_lock);

    lck_mtx_lock(&amp;vm_purgeable_queue_lock);
    nonvolatile_q = &amp;purgeable_nonvolatile_queue;
    <span class="enscript-keyword">for</span> (object = (vm_object_t) queue_first(nonvolatile_q);
	 !queue_end(nonvolatile_q, (queue_entry_t) object);
	 object = (vm_object_t) queue_next(&amp;object-&gt;objq))
    {
	proc(sites, num_sites, object);
    }

    volatile_q = &amp;purgeable_queues[PURGEABLE_Q_TYPE_OBSOLETE];
    vm_page_iterate_purgeable_objects(sites, num_sites, proc, volatile_q, 0);

    volatile_q = &amp;purgeable_queues[PURGEABLE_Q_TYPE_FIFO];
    <span class="enscript-keyword">for</span> (group = 0; group &lt; NUM_VOLATILE_GROUPS; group++)
    {
	vm_page_iterate_purgeable_objects(sites, num_sites, proc, volatile_q, group);
    }

    volatile_q = &amp;purgeable_queues[PURGEABLE_Q_TYPE_LIFO];
    <span class="enscript-keyword">for</span> (group = 0; group &lt; NUM_VOLATILE_GROUPS; group++)
    {
	vm_page_iterate_purgeable_objects(sites, num_sites, proc, volatile_q, group);
    }
    lck_mtx_unlock(&amp;vm_purgeable_queue_lock);
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">process_account</span>(mach_memory_info_t * sites, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> __unused num_sites)
{
    uint64_t found;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx;
    vm_allocation_site_t * site;

    assert(num_sites &gt;= VM_KERN_MEMORY_COUNT);
    found = 0;
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; VM_KERN_MEMORY_COUNT; idx++) 
    {
	found += sites[idx].size;
	<span class="enscript-keyword">if</span> (idx &lt; VM_KERN_MEMORY_FIRST_DYNAMIC)
	{
	    sites[idx].site   = idx;
	    sites[idx].flags |= VM_KERN_SITE_TAG;
	    <span class="enscript-keyword">if</span> (VM_KERN_MEMORY_ZONE == idx) sites[idx].flags |= VM_KERN_SITE_HIDE;
	    <span class="enscript-keyword">else</span>                            sites[idx].flags |= VM_KERN_SITE_WIRED;
	    <span class="enscript-keyword">continue</span>;
	}
	lck_spin_lock(&amp;vm_allocation_sites_lock);
	<span class="enscript-keyword">if</span> ((site = vm_allocation_sites[idx]))
	{
	    <span class="enscript-keyword">if</span> (sites[idx].size)
	    {
		sites[idx].flags |= VM_KERN_SITE_WIRED;
		<span class="enscript-keyword">if</span> (VM_TAG_KMOD == (VM_KERN_SITE_TYPE &amp; site-&gt;flags))
		{
		    sites[idx].site   = OSKextGetKmodIDForSite(site);
		    sites[idx].flags |= VM_KERN_SITE_KMOD;
		}
		<span class="enscript-keyword">else</span>
		{
		    sites[idx].site   = VM_KERNEL_UNSLIDE(site);
		    sites[idx].flags |= VM_KERN_SITE_KERNEL;
		}
		site = NULL;
	    }
	    <span class="enscript-keyword">else</span>
	    {
		vm_tag_free_locked(site-&gt;tag);
	        site-&gt;tag = VM_KERN_MEMORY_NONE;
	        vm_allocation_sites[idx] = NULL;
		<span class="enscript-keyword">if</span> (!(VM_TAG_UNLOAD &amp; site-&gt;flags)) site = NULL;
	    }
	}
	lck_spin_unlock(&amp;vm_allocation_sites_lock);
        <span class="enscript-keyword">if</span> (site) OSKextFreeSite(site);
    }
    <span class="enscript-keyword">return</span> (found);
}

kern_return_t 
<span class="enscript-function-name">vm_page_diagnose</span>(mach_memory_info_t * sites, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_sites)
{
    <span class="enscript-type">enum</span>             	   { kMaxKernelDepth = 1 };
    vm_map_t           	     maps   [kMaxKernelDepth];
    vm_map_entry_t     	     entries[kMaxKernelDepth];
    vm_map_t           	     map;
    vm_map_entry_t     	     entry;
    vm_object_offset_t 	     offset;
    vm_page_t          	     page;
    <span class="enscript-type">int</span>                	     stackIdx, count;
    uint64_t	       	     wired_size;
    uint64_t	       	     wired_managed_size;
    uint64_t	       	     wired_reserved_size;
    mach_memory_info_t     * counts;

    bzero(sites, num_sites * <span class="enscript-keyword">sizeof</span>(mach_memory_info_t));

    vm_page_iterate_objects(sites, num_sites, &amp;vm_page_count_object);

    wired_size          = ptoa_64(vm_page_wire_count + vm_lopage_free_count + vm_page_throttled_count);
    wired_reserved_size = ptoa_64(vm_page_wire_count_initial - vm_page_stolen_count + vm_page_throttled_count);
    wired_managed_size  = ptoa_64(vm_page_wire_count - vm_page_wire_count_initial);

    assert(num_sites &gt;= (VM_KERN_MEMORY_COUNT + VM_KERN_COUNTER_COUNT));
    counts = &amp;sites[VM_KERN_MEMORY_COUNT];

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SET_COUNT</span>(xcount, xsize, xflags)			\
    counts[xcount].site  = (xcount);			\
    counts[xcount].size  = (xsize);			\
    counts[xcount].flags = VM_KERN_SITE_COUNTER | xflags;

    SET_COUNT(VM_KERN_COUNT_MANAGED,		  ptoa_64(vm_page_pages),        0);
    SET_COUNT(VM_KERN_COUNT_WIRED,		  wired_size,                    0);
    SET_COUNT(VM_KERN_COUNT_WIRED_MANAGED,	  wired_managed_size,            0);
    SET_COUNT(VM_KERN_COUNT_RESERVED,	  	  wired_reserved_size, 		 VM_KERN_SITE_WIRED);
    SET_COUNT(VM_KERN_COUNT_STOLEN,	          ptoa_64(vm_page_stolen_count), VM_KERN_SITE_WIRED);
    SET_COUNT(VM_KERN_COUNT_LOPAGE,	          ptoa_64(vm_lopage_free_count), VM_KERN_SITE_WIRED);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SET_MAP</span>(xcount, xsize, xfree, xlargest)		\
    counts[xcount].site    = (xcount);			\
    counts[xcount].size    = (xsize);			\
    counts[xcount].free    = (xfree);			\
    counts[xcount].largest = (xlargest);		\
    counts[xcount].flags   = VM_KERN_SITE_COUNTER;

    vm_map_size_t map_size, map_free, map_largest;

    vm_map_sizes(kernel_map, &amp;map_size, &amp;map_free, &amp;map_largest);
    SET_MAP(VM_KERN_COUNT_MAP_KERNEL, map_size, map_free, map_largest);

    vm_map_sizes(zone_map, &amp;map_size, &amp;map_free, &amp;map_largest);
    SET_MAP(VM_KERN_COUNT_MAP_ZONE, map_size, map_free, map_largest);

    vm_map_sizes(kalloc_map, &amp;map_size, &amp;map_free, &amp;map_largest);
    SET_MAP(VM_KERN_COUNT_MAP_KALLOC, map_size, map_free, map_largest);

    map = kernel_map;
    stackIdx = 0;
    <span class="enscript-keyword">while</span> (map)
    {
	vm_map_lock(map);
	<span class="enscript-keyword">for</span> (entry = map-&gt;hdr.links.next; map; entry = entry-&gt;links.next)
	{
	    <span class="enscript-keyword">if</span> (entry-&gt;is_sub_map)
	    {
	    	assert(stackIdx &lt; kMaxKernelDepth);
		maps[stackIdx] = map;
		entries[stackIdx] = entry;
		stackIdx++;
		map = VME_SUBMAP(entry);
		entry = NULL;
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">if</span> (VME_OBJECT(entry) == kernel_object)
	    {
		count = 0;
		vm_object_lock(VME_OBJECT(entry));
		<span class="enscript-keyword">for</span> (offset = entry-&gt;links.start; offset &lt; entry-&gt;links.end; offset += page_size)
		{
			page = vm_page_lookup(VME_OBJECT(entry), offset);
			<span class="enscript-keyword">if</span> (page &amp;&amp; VM_PAGE_WIRED(page)) count++;
		}
		vm_object_unlock(VME_OBJECT(entry));

		<span class="enscript-keyword">if</span> (count)
		{
		    assert(VME_ALIAS(entry) &lt; num_sites);
		    sites[VME_ALIAS(entry)].size += ptoa_64(count);
		}
	    }
	    <span class="enscript-keyword">if</span> (entry == vm_map_last_entry(map))
	    {
		vm_map_unlock(map);
		<span class="enscript-keyword">if</span> (!stackIdx) map = NULL;
		<span class="enscript-keyword">else</span>
		{
		    --stackIdx;
		    map = maps[stackIdx];
		    entry = entries[stackIdx];
		}
	    }
	}
    }

    process_account(sites, num_sites);
    
    <span class="enscript-keyword">return</span> (KERN_SUCCESS);
}
</pre>
<hr />
</body></html>