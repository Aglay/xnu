<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_debug.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_debug.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm/vm_debug.c.
 *	Author:	Rich Draves
 *	Date:	March, 1990
 *
 *	Exported kernel calls.  See mach_debug/mach_debug.defs.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_vm_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/vm_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/page_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/hash_info.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_VM_DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_inherit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_debug.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_VM_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__DEBUG_ONLY</span> __unused
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !MACH_VM_DEBUG */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__DEBUG_ONLY</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MACH_VM_DEBUG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM32_SUPPORT</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm32_map_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>

<span class="enscript-comment">/*
 *	Routine:	mach_vm_region_info [kernel call]
 *	Purpose:
 *		Retrieve information about a VM region,
 *		including info about the object chain.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Retrieve region/object info.
 *		KERN_INVALID_TASK	The map is null.
 *		KERN_NO_SPACE		There is no entry at/after the address.
 *		KERN_RESOURCE_SHORTAGE	Can't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">vm32_region_info</span>(
	__DEBUG_ONLY vm_map_t			map,
	__DEBUG_ONLY vm32_offset_t		address,
	__DEBUG_ONLY vm_info_region_t		*regionp,
	__DEBUG_ONLY vm_info_object_array_t	*objectsp,
	__DEBUG_ONLY mach_msg_type_number_t	*objectsCntp)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_VM_DEBUG</span>
        <span class="enscript-keyword">return</span> KERN_FAILURE;
#<span class="enscript-reference">else</span>
	vm_map_copy_t copy;
	vm_offset_t addr;	<span class="enscript-comment">/* memory for OOL data */</span>
	vm_size_t size;		<span class="enscript-comment">/* size of the memory */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> room;	<span class="enscript-comment">/* room for this many objects */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> used;	<span class="enscript-comment">/* actually this many objects */</span>
	vm_info_region_t region;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	size = 0;		<span class="enscript-comment">/* no memory allocated yet */</span>

	<span class="enscript-keyword">for</span> (;;) {
		vm_map_t cmap;	<span class="enscript-comment">/* current map in traversal */</span>
		vm_map_t nmap;	<span class="enscript-comment">/* next map to look at */</span>
		vm_map_entry_t entry;
		vm_object_t object, cobject, nobject;

		<span class="enscript-comment">/* nothing is locked */</span>

		vm_map_lock_read(map);
		<span class="enscript-keyword">for</span> (cmap = map;; cmap = nmap) {
			<span class="enscript-comment">/* cmap is read-locked */</span>

			<span class="enscript-keyword">if</span> (!vm_map_lookup_entry(cmap, 
				(vm_map_address_t)address, &amp;entry)) {

				entry = entry-&gt;vme_next;
				<span class="enscript-keyword">if</span> (entry == vm_map_to_entry(cmap)) {
					vm_map_unlock_read(cmap);
					<span class="enscript-keyword">if</span> (size != 0)
						kmem_free(ipc_kernel_map,
							  addr, size);
					<span class="enscript-keyword">return</span> KERN_NO_SPACE;
				}
			}

			<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map)
				nmap = VME_SUBMAP(entry);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/* move down to the lower map */</span>

			vm_map_lock_read(nmap);
			vm_map_unlock_read(cmap);
		}

		<span class="enscript-comment">/* cmap is read-locked; we have a real entry */</span>

		object = VME_OBJECT(entry);
		region.vir_start = (natural_t) entry-&gt;vme_start;
		region.vir_end = (natural_t) entry-&gt;vme_end;
		region.vir_object = (natural_t)(uintptr_t) object;
		region.vir_offset = (natural_t) VME_OFFSET(entry);
		region.vir_needs_copy = entry-&gt;needs_copy;
		region.vir_protection = entry-&gt;protection;
		region.vir_max_protection = entry-&gt;max_protection;
		region.vir_inheritance = entry-&gt;inheritance;
		region.vir_wired_count = entry-&gt;wired_count;
		region.vir_user_wired_count = entry-&gt;user_wired_count;

		used = 0;
		room = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size / <span class="enscript-keyword">sizeof</span>(vm_info_object_t));

		<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
			vm_map_unlock_read(cmap);
			<span class="enscript-comment">/* no memory needed */</span>
			<span class="enscript-keyword">break</span>;
		}

		vm_object_lock(object);
		vm_map_unlock_read(cmap);

		<span class="enscript-keyword">for</span> (cobject = object;; cobject = nobject) {
			<span class="enscript-comment">/* cobject is locked */</span>

			<span class="enscript-keyword">if</span> (used &lt; room) {
				vm_info_object_t *vio =
					&amp;((vm_info_object_t *) addr)[used];

				vio-&gt;vio_object =
					(natural_t)(uintptr_t) cobject;
				vio-&gt;vio_size =
					(natural_t) cobject-&gt;vo_size;
				vio-&gt;vio_ref_count =
					cobject-&gt;ref_count;
				vio-&gt;vio_resident_page_count =
					cobject-&gt;resident_page_count;
				vio-&gt;vio_copy =
					(natural_t)(uintptr_t) cobject-&gt;copy;
				vio-&gt;vio_shadow =
					(natural_t)(uintptr_t) cobject-&gt;shadow;
				vio-&gt;vio_shadow_offset =
					(natural_t) cobject-&gt;vo_shadow_offset;
				vio-&gt;vio_paging_offset =
					(natural_t) cobject-&gt;paging_offset;
				vio-&gt;vio_copy_strategy =
					cobject-&gt;copy_strategy;
				vio-&gt;vio_last_alloc =
					(vm_offset_t) cobject-&gt;last_alloc;
				vio-&gt;vio_paging_in_progress =
					cobject-&gt;paging_in_progress +
					cobject-&gt;activity_in_progress;
				vio-&gt;vio_pager_created =
					cobject-&gt;pager_created;
				vio-&gt;vio_pager_initialized =
					cobject-&gt;pager_initialized;
				vio-&gt;vio_pager_ready =
					cobject-&gt;pager_ready;
				vio-&gt;vio_can_persist =
					cobject-&gt;can_persist;
				vio-&gt;vio_internal =
					cobject-&gt;internal;
				vio-&gt;vio_temporary =
					cobject-&gt;temporary;
				vio-&gt;vio_alive =
					cobject-&gt;alive;
				vio-&gt;vio_purgable =
					(cobject-&gt;purgable != VM_PURGABLE_DENY);
				vio-&gt;vio_purgable_volatile =
					(cobject-&gt;purgable == VM_PURGABLE_VOLATILE ||
					 cobject-&gt;purgable == VM_PURGABLE_EMPTY);
			}

			used++;
			nobject = cobject-&gt;shadow;
			<span class="enscript-keyword">if</span> (nobject == VM_OBJECT_NULL) {
				vm_object_unlock(cobject);
				<span class="enscript-keyword">break</span>;
			}

			vm_object_lock(nobject);
			vm_object_unlock(cobject);
		}

		<span class="enscript-comment">/* nothing locked */</span>

		<span class="enscript-keyword">if</span> (used &lt;= room)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* must allocate more memory */</span>

		<span class="enscript-keyword">if</span> (size != 0)
			kmem_free(ipc_kernel_map, addr, size);
		size = vm_map_round_page(2 * used * <span class="enscript-keyword">sizeof</span>(vm_info_object_t),
					 VM_MAP_PAGE_MASK(ipc_kernel_map));

		kr = vm_allocate(ipc_kernel_map, &amp;addr, size, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IPC));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

		kr = vm_map_wire(
			ipc_kernel_map,
			vm_map_trunc_page(addr,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr + size,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			VM_PROT_READ|VM_PROT_WRITE,
			FALSE);
		assert(kr == KERN_SUCCESS);
	}

	<span class="enscript-comment">/* free excess memory; make remaining memory pageable */</span>

	<span class="enscript-keyword">if</span> (used == 0) {
		copy = VM_MAP_COPY_NULL;

		<span class="enscript-keyword">if</span> (size != 0)
			kmem_free(ipc_kernel_map, addr, size);
	} <span class="enscript-keyword">else</span> {
		vm_size_t size_used =
			vm_map_round_page(used * <span class="enscript-keyword">sizeof</span>(vm_info_object_t),
					  VM_MAP_PAGE_MASK(ipc_kernel_map));

		kr = vm_map_unwire(
			ipc_kernel_map,
			vm_map_trunc_page(addr,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr + size_used,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			FALSE);
		assert(kr == KERN_SUCCESS);

		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)addr,
				   (vm_map_size_t)size_used, TRUE, &amp;copy);
		assert(kr == KERN_SUCCESS);

		<span class="enscript-keyword">if</span> (size != size_used)
			kmem_free(ipc_kernel_map,
				  addr + size_used, size - size_used);
	}

	*regionp = region;
	*objectsp = (vm_info_object_array_t) copy;
	*objectsCntp = used;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_VM_DEBUG */</span>
}

<span class="enscript-comment">/*
 *  Temporary call for 64 bit data path interface transiotion
 */</span>

kern_return_t
<span class="enscript-function-name">vm32_region_info_64</span>(
	__DEBUG_ONLY vm_map_t			map,
	__DEBUG_ONLY vm32_offset_t		address,
	__DEBUG_ONLY vm_info_region_64_t	*regionp,
	__DEBUG_ONLY vm_info_object_array_t	*objectsp,
	__DEBUG_ONLY mach_msg_type_number_t	*objectsCntp)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_VM_DEBUG</span>
        <span class="enscript-keyword">return</span> KERN_FAILURE;
#<span class="enscript-reference">else</span>
	vm_map_copy_t copy;
	vm_offset_t addr;	<span class="enscript-comment">/* memory for OOL data */</span>
	vm_size_t size;		<span class="enscript-comment">/* size of the memory */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> room;	<span class="enscript-comment">/* room for this many objects */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> used;	<span class="enscript-comment">/* actually this many objects */</span>
	vm_info_region_64_t region;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	size = 0;		<span class="enscript-comment">/* no memory allocated yet */</span>

	<span class="enscript-keyword">for</span> (;;) {
		vm_map_t cmap;	<span class="enscript-comment">/* current map in traversal */</span>
		vm_map_t nmap;	<span class="enscript-comment">/* next map to look at */</span>
		vm_map_entry_t entry;
		vm_object_t object, cobject, nobject;

		<span class="enscript-comment">/* nothing is locked */</span>

		vm_map_lock_read(map);
		<span class="enscript-keyword">for</span> (cmap = map;; cmap = nmap) {
			<span class="enscript-comment">/* cmap is read-locked */</span>

			<span class="enscript-keyword">if</span> (!vm_map_lookup_entry(cmap, address, &amp;entry)) {
				entry = entry-&gt;vme_next;
				<span class="enscript-keyword">if</span> (entry == vm_map_to_entry(cmap)) {
					vm_map_unlock_read(cmap);
					<span class="enscript-keyword">if</span> (size != 0)
						kmem_free(ipc_kernel_map,
							  addr, size);
					<span class="enscript-keyword">return</span> KERN_NO_SPACE;
				}
			}

			<span class="enscript-keyword">if</span> (entry-&gt;is_sub_map)
				nmap = VME_SUBMAP(entry);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/* move down to the lower map */</span>

			vm_map_lock_read(nmap);
			vm_map_unlock_read(cmap);
		}

		<span class="enscript-comment">/* cmap is read-locked; we have a real entry */</span>

		object = VME_OBJECT(entry);
		region.vir_start = (natural_t) entry-&gt;vme_start;
		region.vir_end = (natural_t) entry-&gt;vme_end;
		region.vir_object = (natural_t)(uintptr_t) object;
		region.vir_offset = VME_OFFSET(entry);
		region.vir_needs_copy = entry-&gt;needs_copy;
		region.vir_protection = entry-&gt;protection;
		region.vir_max_protection = entry-&gt;max_protection;
		region.vir_inheritance = entry-&gt;inheritance;
		region.vir_wired_count = entry-&gt;wired_count;
		region.vir_user_wired_count = entry-&gt;user_wired_count;

		used = 0;
		room = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size / <span class="enscript-keyword">sizeof</span>(vm_info_object_t));

		<span class="enscript-keyword">if</span> (object == VM_OBJECT_NULL) {
			vm_map_unlock_read(cmap);
			<span class="enscript-comment">/* no memory needed */</span>
			<span class="enscript-keyword">break</span>;
		}

		vm_object_lock(object);
		vm_map_unlock_read(cmap);

		<span class="enscript-keyword">for</span> (cobject = object;; cobject = nobject) {
			<span class="enscript-comment">/* cobject is locked */</span>

			<span class="enscript-keyword">if</span> (used &lt; room) {
				vm_info_object_t *vio =
					&amp;((vm_info_object_t *) addr)[used];

				vio-&gt;vio_object =
					(natural_t)(uintptr_t) cobject;
				vio-&gt;vio_size =
					(natural_t) cobject-&gt;vo_size;
				vio-&gt;vio_ref_count =
					cobject-&gt;ref_count;
				vio-&gt;vio_resident_page_count =
					cobject-&gt;resident_page_count;
				vio-&gt;vio_copy =
					(natural_t)(uintptr_t) cobject-&gt;copy;
				vio-&gt;vio_shadow =
					(natural_t)(uintptr_t) cobject-&gt;shadow;
				vio-&gt;vio_shadow_offset =
					(natural_t) cobject-&gt;vo_shadow_offset;
				vio-&gt;vio_paging_offset =
					(natural_t) cobject-&gt;paging_offset;
				vio-&gt;vio_copy_strategy =
					cobject-&gt;copy_strategy;
				vio-&gt;vio_last_alloc =
					(vm_offset_t) cobject-&gt;last_alloc;
				vio-&gt;vio_paging_in_progress =
					cobject-&gt;paging_in_progress +
					cobject-&gt;activity_in_progress;
				vio-&gt;vio_pager_created =
					cobject-&gt;pager_created;
				vio-&gt;vio_pager_initialized =
					cobject-&gt;pager_initialized;
				vio-&gt;vio_pager_ready =
					cobject-&gt;pager_ready;
				vio-&gt;vio_can_persist =
					cobject-&gt;can_persist;
				vio-&gt;vio_internal =
					cobject-&gt;internal;
				vio-&gt;vio_temporary =
					cobject-&gt;temporary;
				vio-&gt;vio_alive =
					cobject-&gt;alive;
				vio-&gt;vio_purgable =
					(cobject-&gt;purgable != VM_PURGABLE_DENY);
				vio-&gt;vio_purgable_volatile =
					(cobject-&gt;purgable == VM_PURGABLE_VOLATILE ||
					 cobject-&gt;purgable == VM_PURGABLE_EMPTY);
			}

			used++;
			nobject = cobject-&gt;shadow;
			<span class="enscript-keyword">if</span> (nobject == VM_OBJECT_NULL) {
				vm_object_unlock(cobject);
				<span class="enscript-keyword">break</span>;
			}

			vm_object_lock(nobject);
			vm_object_unlock(cobject);
		}

		<span class="enscript-comment">/* nothing locked */</span>

		<span class="enscript-keyword">if</span> (used &lt;= room)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* must allocate more memory */</span>

		<span class="enscript-keyword">if</span> (size != 0)
			kmem_free(ipc_kernel_map, addr, size);
		size = vm_map_round_page(2 * used * <span class="enscript-keyword">sizeof</span>(vm_info_object_t),
					 VM_MAP_PAGE_MASK(ipc_kernel_map));

		kr = vm_allocate(ipc_kernel_map, &amp;addr, size, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IPC));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

		kr = vm_map_wire(
			ipc_kernel_map,
			vm_map_trunc_page(addr,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr + size,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			VM_PROT_READ|VM_PROT_WRITE,
			FALSE);
		assert(kr == KERN_SUCCESS);
	}

	<span class="enscript-comment">/* free excess memory; make remaining memory pageable */</span>

	<span class="enscript-keyword">if</span> (used == 0) {
		copy = VM_MAP_COPY_NULL;

		<span class="enscript-keyword">if</span> (size != 0)
			kmem_free(ipc_kernel_map, addr, size);
	} <span class="enscript-keyword">else</span> {
		vm_size_t size_used =
			vm_map_round_page(used * <span class="enscript-keyword">sizeof</span>(vm_info_object_t),
					  VM_MAP_PAGE_MASK(ipc_kernel_map));

		kr = vm_map_unwire(
			ipc_kernel_map,
			vm_map_trunc_page(addr,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr + size_used,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			FALSE);
		assert(kr == KERN_SUCCESS);

		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)addr,
				   (vm_map_size_t)size_used, TRUE, &amp;copy);
		assert(kr == KERN_SUCCESS);

		<span class="enscript-keyword">if</span> (size != size_used)
			kmem_free(ipc_kernel_map,
				  addr + size_used, size - size_used);
	}

	*regionp = region;
	*objectsp = (vm_info_object_array_t) copy;
	*objectsCntp = used;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_VM_DEBUG */</span>
}
<span class="enscript-comment">/*
 * Return an array of virtual pages that are mapped to a task.
 */</span>
kern_return_t
<span class="enscript-function-name">vm32_mapped_pages_info</span>(
	__DEBUG_ONLY vm_map_t			map,
	__DEBUG_ONLY page_address_array_t	*pages,
	__DEBUG_ONLY mach_msg_type_number_t	*pages_count)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_VM_DEBUG</span>
        <span class="enscript-keyword">return</span> KERN_FAILURE;
#<span class="enscript-reference">else</span>
	pmap_t		pmap;
	vm_size_t	size, size_used;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	actual, space;
	page_address_array_t list;
	vm_offset_t	addr;

	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL)
	    <span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	pmap = map-&gt;pmap;
	size = pmap_resident_count(pmap) * <span class="enscript-keyword">sizeof</span>(vm_offset_t);
	size = vm_map_round_page(size,
				 VM_MAP_PAGE_MASK(ipc_kernel_map));

	<span class="enscript-keyword">for</span> (;;) {
	    (<span class="enscript-type">void</span>) vm_allocate(ipc_kernel_map, &amp;addr, size, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IPC));
	    (<span class="enscript-type">void</span>) vm_map_unwire(
		    ipc_kernel_map,
		    vm_map_trunc_page(addr,
				      VM_MAP_PAGE_MASK(ipc_kernel_map)),
		    vm_map_round_page(addr + size,
				      VM_MAP_PAGE_MASK(ipc_kernel_map)),
		    FALSE);

	    list = (page_address_array_t) addr;
	    space = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size / <span class="enscript-keyword">sizeof</span>(vm_offset_t));

	    actual = pmap_list_resident_pages(pmap,
					list,
					space);
	    <span class="enscript-keyword">if</span> (actual &lt;= space)
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-comment">/*
	     * Free memory if not enough
	     */</span>
	    (<span class="enscript-type">void</span>) kmem_free(ipc_kernel_map, addr, size);

	    <span class="enscript-comment">/*
	     * Try again, doubling the size
	     */</span>
	    size = vm_map_round_page(actual * <span class="enscript-keyword">sizeof</span>(vm_offset_t),
				     VM_MAP_PAGE_MASK(ipc_kernel_map));
	}
	<span class="enscript-keyword">if</span> (actual == 0) {
	    *pages = 0;
	    *pages_count = 0;
	    (<span class="enscript-type">void</span>) kmem_free(ipc_kernel_map, addr, size);
	}
	<span class="enscript-keyword">else</span> {
	    *pages_count = actual;
	    size_used = vm_map_round_page(actual * <span class="enscript-keyword">sizeof</span>(vm_offset_t),
					  VM_MAP_PAGE_MASK(ipc_kernel_map));
	    (<span class="enscript-type">void</span>) vm_map_wire(
		    ipc_kernel_map,
		    vm_map_trunc_page(addr,
				      VM_MAP_PAGE_MASK(ipc_kernel_map)),
		    vm_map_round_page(addr + size,
				      VM_MAP_PAGE_MASK(ipc_kernel_map)), 
		    VM_PROT_READ|VM_PROT_WRITE,
		    FALSE);
	    (<span class="enscript-type">void</span>) vm_map_copyin(ipc_kernel_map,
				(vm_map_address_t)addr,
				(vm_map_size_t)size_used,
				TRUE,
				(vm_map_copy_t *)pages);
	    <span class="enscript-keyword">if</span> (size_used != size) {
		(<span class="enscript-type">void</span>) kmem_free(ipc_kernel_map,
				addr + size_used,
				size - size_used);
	    }
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_VM_DEBUG */</span>
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM32_SUPPORT */</span>

<span class="enscript-comment">/*
 *	Routine:	host_virtual_physical_table_info
 *	Purpose:
 *		Return information about the VP table.
 *	Conditions:
 *		Nothing locked.  Obeys CountInOut protocol.
 *	Returns:
 *		KERN_SUCCESS		Returned information.
 *		KERN_INVALID_HOST	The host is null.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">host_virtual_physical_table_info</span>(
	__DEBUG_ONLY host_t			host,
	__DEBUG_ONLY hash_info_bucket_array_t	*infop,
	__DEBUG_ONLY mach_msg_type_number_t 	*countp)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_VM_DEBUG</span>
        <span class="enscript-keyword">return</span> KERN_FAILURE;
#<span class="enscript-reference">else</span>
	vm_offset_t addr;
	vm_size_t size = 0;
	hash_info_bucket_t *info;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> potential, actual;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (host == HOST_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;

	<span class="enscript-comment">/* start with in-line data */</span>

	info = *infop;
	potential = *countp;

	<span class="enscript-keyword">for</span> (;;) {
		actual = vm_page_info(info, potential);
		<span class="enscript-keyword">if</span> (actual &lt;= potential)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* allocate more memory */</span>

		<span class="enscript-keyword">if</span> (info != *infop)
			kmem_free(ipc_kernel_map, addr, size);

		size = vm_map_round_page(actual * <span class="enscript-keyword">sizeof</span> *info,
					 VM_MAP_PAGE_MASK(ipc_kernel_map));
		kr = kmem_alloc_pageable(ipc_kernel_map, &amp;addr, size, VM_KERN_MEMORY_IPC);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

		info = (hash_info_bucket_t *) addr;
		potential = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (size/<span class="enscript-keyword">sizeof</span> (*info));
	}

	<span class="enscript-keyword">if</span> (info == *infop) {
		<span class="enscript-comment">/* data fit in-line; nothing to deallocate */</span>

		*countp = actual;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (actual == 0) {
		kmem_free(ipc_kernel_map, addr, size);

		*countp = 0;
	} <span class="enscript-keyword">else</span> {
		vm_map_copy_t copy;
		vm_size_t used;

		used = vm_map_round_page(actual * <span class="enscript-keyword">sizeof</span> *info,
					 VM_MAP_PAGE_MASK(ipc_kernel_map));

		<span class="enscript-keyword">if</span> (used != size)
			kmem_free(ipc_kernel_map, addr + used, size - used);

		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)addr,
				   (vm_map_size_t)used, TRUE, &amp;copy);
		assert(kr == KERN_SUCCESS);

		*infop = (hash_info_bucket_t *) copy;
		*countp = actual;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_VM_DEBUG */</span>
}
</pre>
<hr />
</body></html>