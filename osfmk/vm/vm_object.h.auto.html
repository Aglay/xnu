<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_object.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_object.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm_object.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Virtual memory object module definitions.
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_VM_VM_OBJECT_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VM_VM_OBJECT_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_pagemap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;task_swapper.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/macro_help.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_external.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_options.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/btlog.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_object_tracking_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> boolean_t vm_object_tracking_inited;
<span class="enscript-type">extern</span> btlog_t *vm_object_tracking_btlog;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING_BTDEPTH</span> 7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING_OP_CREATED</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING_OP_MODIFIED</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_TRACKING_OP_TRUESHARE</span>	3
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_OBJECT_TRACKING */</span>

<span class="enscript-type">struct</span> vm_page;
<span class="enscript-type">struct</span> vm_shared_region_slide_info;

<span class="enscript-comment">/*
 *	Types defined:
 *
 *	vm_object_t		Virtual memory object.
 *	vm_object_fault_info_t	Used to determine cluster size.
 */</span>

<span class="enscript-type">struct</span> vm_object_fault_info {
	<span class="enscript-type">int</span>		interruptible;
        uint32_t	user_tag;
        vm_size_t	cluster_size;
        vm_behavior_t	behavior;
        vm_map_offset_t	lo_offset;
	vm_map_offset_t	hi_offset;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
	<span class="enscript-comment">/* boolean_t */</span>	no_cache:1,
	<span class="enscript-comment">/* boolean_t */</span>	stealth:1,
	<span class="enscript-comment">/* boolean_t */</span>	io_sync:1,
	<span class="enscript-comment">/* boolean_t */</span> cs_bypass:1,
	<span class="enscript-comment">/* boolean_t */</span>	mark_zf_absent:1,
	<span class="enscript-comment">/* boolean_t */</span> batch_pmap_op:1,
		<span class="enscript-reference">__vm_object_fault_info_unused_bits</span>:26;
	<span class="enscript-type">int</span>		pmap_options;
};


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">vo_size</span>				vo_un1.vou_size
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vo_cache_pages_to_scan</span>		vo_un1.vou_cache_pages_to_scan
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vo_shadow_offset</span>		vo_un2.vou_shadow_offset
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vo_cache_ts</span>			vo_un2.vou_cache_ts
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vo_purgeable_owner</span>		vo_un2.vou_purgeable_owner
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vo_slide_info</span>			vo_un2.vou_slide_info

<span class="enscript-type">struct</span> vm_object {
	queue_head_t		memq;		<span class="enscript-comment">/* Resident memory */</span>
        lck_rw_t		Lock;		<span class="enscript-comment">/* Synchronization */</span>

	<span class="enscript-type">union</span> {
		vm_object_size_t  vou_size;	<span class="enscript-comment">/* Object size (only valid if internal) */</span>
		<span class="enscript-type">int</span>		  vou_cache_pages_to_scan;	<span class="enscript-comment">/* pages yet to be visited in an
								 * external object in cache
								 */</span>
	} vo_un1;

	<span class="enscript-type">struct</span> vm_page		*memq_hint;
	<span class="enscript-type">int</span>			ref_count;	<span class="enscript-comment">/* Number of references */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
	<span class="enscript-type">int</span>			res_count;	<span class="enscript-comment">/* Residency references (swap)*/</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		resident_page_count;
						<span class="enscript-comment">/* number of resident pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		wired_page_count; <span class="enscript-comment">/* number of wired pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		reusable_page_count;

	<span class="enscript-type">struct</span> vm_object	*copy;		<span class="enscript-comment">/* Object that should receive
						 * a copy of my changed pages,
						 * for copy_delay, or just the
						 * temporary object that
						 * shadows this object, for
						 * copy_call.
						 */</span>
	<span class="enscript-type">struct</span> vm_object	*shadow;	<span class="enscript-comment">/* My shadow */</span>

	<span class="enscript-type">union</span> {
		vm_object_offset_t vou_shadow_offset;	<span class="enscript-comment">/* Offset into shadow */</span>
		clock_sec_t	vou_cache_ts;	<span class="enscript-comment">/* age of an external object
						 * present in cache
						 */</span>
		task_t		vou_purgeable_owner;	<span class="enscript-comment">/* If the purg'a'ble bits below are set 
							 * to volatile/emtpy, this is the task 
							 * that owns this purgeable object.
							 */</span>
		<span class="enscript-type">struct</span> vm_shared_region_slide_info *vou_slide_info;
	} vo_un2;

	memory_object_t		pager;		<span class="enscript-comment">/* Where to get data */</span>
	vm_object_offset_t	paging_offset;	<span class="enscript-comment">/* Offset into memory object */</span>
	memory_object_control_t	pager_control;	<span class="enscript-comment">/* Where data comes back */</span>

	memory_object_copy_strategy_t
				copy_strategy;	<span class="enscript-comment">/* How to handle data copy */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-comment">/*
	 * Some user processes (mostly VirtualMachine software) take a large
	 * number of UPLs (via IOMemoryDescriptors) to wire pages in large
	 * VM objects and overflow the 16-bit &quot;activity_in_progress&quot; counter.
	 * Since we never enforced any limit there, let's give them 32 bits
	 * for backwards compatibility's sake.
	 */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		paging_in_progress:16,
				<span class="enscript-reference">__object1_unused_bits</span>:16;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		activity_in_progress;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* __LP64__ */</span>
	<span class="enscript-comment">/*
	 * On 32-bit platforms, enlarging &quot;activity_in_progress&quot; would increase
	 * the size of &quot;struct vm_object&quot;.  Since we don't know of any actual
	 * overflow of these counters on these platforms, let's keep the
	 * counters as 16-bit integers.
	 */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>		paging_in_progress;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>		activity_in_progress;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
						<span class="enscript-comment">/* The memory object ports are
						 * being used (e.g., for pagein
						 * or pageout) -- don't change
						 * any of these fields (i.e.,
						 * don't collapse, destroy or
						 * terminate)
						 */</span>

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
	<span class="enscript-comment">/* boolean_t array */</span>	all_wanted:11,	<span class="enscript-comment">/* Bit array of &quot;want to be
						 * awakened&quot; notations.  See
						 * VM_OBJECT_EVENT_* items
						 * below */</span>
	<span class="enscript-comment">/* boolean_t */</span>	pager_created:1,	<span class="enscript-comment">/* Has pager been created? */</span>
	<span class="enscript-comment">/* boolean_t */</span>	pager_initialized:1,	<span class="enscript-comment">/* Are fields ready to use? */</span>
	<span class="enscript-comment">/* boolean_t */</span>	pager_ready:1,		<span class="enscript-comment">/* Will pager take requests? */</span>

	<span class="enscript-comment">/* boolean_t */</span>		pager_trusted:1,<span class="enscript-comment">/* The pager for this object
						 * is trusted. This is true for
						 * all internal objects (backed
						 * by the default pager)
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		can_persist:1,	<span class="enscript-comment">/* The kernel may keep the data
						 * for this object (and rights
						 * to the memory object) after
						 * all address map references 
						 * are deallocated?
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		internal:1,	<span class="enscript-comment">/* Created by the kernel (and
						 * therefore, managed by the
						 * default memory manger)
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		temporary:1,	<span class="enscript-comment">/* Permanent objects may be
						 * changed externally by the 
						 * memory manager, and changes
						 * made in memory must be
						 * reflected back to the memory
						 * manager.  Temporary objects
						 * lack both of these
						 * characteristics.
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		private:1,	<span class="enscript-comment">/* magic device_pager object,
						 * holds private pages only */</span>
	<span class="enscript-comment">/* boolean_t */</span>		pageout:1,	<span class="enscript-comment">/* pageout object. contains
						 * private pages that refer to
						 * a real memory object. */</span>
	<span class="enscript-comment">/* boolean_t */</span>		alive:1,	<span class="enscript-comment">/* Not yet terminated */</span>

	<span class="enscript-comment">/* boolean_t */</span>		purgable:2,	<span class="enscript-comment">/* Purgable state.  See
						 * VM_PURGABLE_* 
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		purgeable_when_ripe:1, <span class="enscript-comment">/* Purgeable when a token
							* becomes ripe.
							*/</span>
	<span class="enscript-comment">/* boolean_t */</span>		shadowed:1,	<span class="enscript-comment">/* Shadow may exist */</span>
	<span class="enscript-comment">/* boolean_t */</span>		advisory_pageout:1,
						<span class="enscript-comment">/* Instead of sending page
						 * via OOL, just notify
						 * pager that the kernel
						 * wants to discard it, page
						 * remains in object */</span>
	<span class="enscript-comment">/* boolean_t */</span>		true_share:1,
						<span class="enscript-comment">/* This object is mapped
						 * in more than one place
						 * and hence cannot be 
						 * coalesced */</span>
	<span class="enscript-comment">/* boolean_t */</span>		terminating:1,
						<span class="enscript-comment">/* Allows vm_object_lookup
						 * and vm_object_deallocate
						 * to special case their
						 * behavior when they are
						 * called as a result of
						 * page cleaning during
						 * object termination
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		named:1,	<span class="enscript-comment">/* An enforces an internal
						 * naming convention, by
						 * calling the right routines
						 * for allocation and 
						 * destruction, UBC references
						 * against the vm_object are
						 * checked.
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		shadow_severed:1,
						<span class="enscript-comment">/* When a permanent object 
						 * backing a COW goes away
					  	 * unexpectedly.  This bit
						 * allows vm_fault to return
						 * an error rather than a
						 * zero filled page.
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		phys_contiguous:1,
						<span class="enscript-comment">/* Memory is wired and
						 * guaranteed physically 
						 * contiguous.  However
						 * it is not device memory
						 * and obeys normal virtual
						 * memory rules w.r.t pmap
						 * access bits.
						 */</span>
	<span class="enscript-comment">/* boolean_t */</span>		nophyscache:1;
						<span class="enscript-comment">/* When mapped at the 
						 * pmap level, don't allow
						 * primary caching. (for
						 * I/O)
						 */</span>
						


	queue_chain_t		cached_list;	<span class="enscript-comment">/* Attachment point for the
						 * list of objects cached as a
						 * result of their can_persist
						 * value
						 */</span>

	queue_head_t		msr_q;		<span class="enscript-comment">/* memory object synchronise
						   request queue */</span>

  <span class="enscript-comment">/*
   * the following fields are not protected by any locks
   * they are updated via atomic compare and swap
   */</span>
	vm_object_offset_t	last_alloc;	<span class="enscript-comment">/* last allocation offset */</span>
	<span class="enscript-type">int</span>			sequential;	<span class="enscript-comment">/* sequential access size */</span>

        uint32_t		pages_created;
        uint32_t		pages_used;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_PAGEMAP</span>
	vm_external_map_t	existence_map;	<span class="enscript-comment">/* bitmap of pages written to
						 * backing storage */</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_PAGEMAP */</span>
	vm_offset_t		cow_hint;	<span class="enscript-comment">/* last page present in     */</span>
						<span class="enscript-comment">/* shadow but not in object */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-type">struct</span> vm_object	*paging_object;	<span class="enscript-comment">/* object which pages to be
						 * swapped out are temporary
						 * put in current object
						 */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* hold object lock when altering */</span>
	<span class="enscript-type">unsigned</span>	<span class="enscript-type">int</span>
		<span class="enscript-reference">wimg_bits</span>:8,	        <span class="enscript-comment">/* cache WIMG bits         */</span>		
		<span class="enscript-reference">code_signed</span>:1,		<span class="enscript-comment">/* pages are signed and should be
					   validated; the signatures are stored
					   with the pager */</span>
		<span class="enscript-reference">hashed</span>:1,		<span class="enscript-comment">/* object/pager entered in hash */</span>
		<span class="enscript-reference">transposed</span>:1,		<span class="enscript-comment">/* object was transposed with another */</span>
		<span class="enscript-reference">mapping_in_progress</span>:1,	<span class="enscript-comment">/* pager being mapped/unmapped */</span>
		<span class="enscript-reference">phantom_isssd</span>:1,
		<span class="enscript-reference">volatile_empty</span>:1,
		<span class="enscript-reference">volatile_fault</span>:1,
		<span class="enscript-reference">all_reusable</span>:1,
		<span class="enscript-reference">blocked_access</span>:1,
		<span class="enscript-reference">set_cache_attr</span>:1,
		<span class="enscript-reference">object_slid</span>:1,
		<span class="enscript-reference">purgeable_queue_type</span>:2,
		<span class="enscript-reference">purgeable_queue_group</span>:3,
		<span class="enscript-reference">io_tracking</span>:1,
		<span class="enscript-reference">__object2_unused_bits</span>:7;	<span class="enscript-comment">/* for expansion */</span>

	uint8_t			scan_collisions;
        vm_tag_t		wire_tag;
	uint8_t			__object4_unused_bits[2];

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
	uint32_t		phantom_object_id;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span> || <span class="enscript-variable-name">UPL_DEBUG</span>
	queue_head_t		uplq;		<span class="enscript-comment">/* List of outstanding upls */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">VM_PIP_DEBUG</span>
<span class="enscript-comment">/*
 * Keep track of the stack traces for the first holders
 * of a &quot;paging_in_progress&quot; reference for this VM object.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PIP_DEBUG_STACK_FRAMES</span>	25	<span class="enscript-comment">/* depth of each stack trace */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PIP_DEBUG_MAX_REFS</span>		10	<span class="enscript-comment">/* track that many references */</span>
	<span class="enscript-type">struct</span> __pip_backtrace {
		<span class="enscript-type">void</span> *pip_retaddr[VM_PIP_DEBUG_STACK_FRAMES];
	} pip_holders[VM_PIP_DEBUG_MAX_REFS];
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VM_PIP_DEBUG  */</span>

        queue_chain_t		objq;      <span class="enscript-comment">/* object queue - currently used for purgable queues */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-type">void</span> *purgeable_owner_bt[16];
	task_t vo_purgeable_volatilizer; <span class="enscript-comment">/* who made it volatile? */</span>
	<span class="enscript-type">void</span> *purgeable_volatilizer_bt[16];
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_OBJECT_PURGEABLE_FAULT_ERROR</span>(object)				\
	((object)-&gt;volatile_fault &amp;&amp;					\
	 ((object)-&gt;purgable == VM_PURGABLE_VOLATILE ||			\
	  (object)-&gt;purgable == VM_PURGABLE_EMPTY))

<span class="enscript-type">extern</span>
vm_object_t	kernel_object;		<span class="enscript-comment">/* the single kernel object */</span>

<span class="enscript-type">extern</span>
vm_object_t	compressor_object;	<span class="enscript-comment">/* the single compressor object */</span>

<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_object_absent_max;	<span class="enscript-comment">/* maximum number of absent pages
					   at a time for each object */</span>

# <span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MSYNC_INITIALIZED</span>			0
# <span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MSYNC_SYNCHRONIZING</span>			1
# <span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MSYNC_DONE</span>				2

<span class="enscript-type">struct</span> msync_req {
	queue_chain_t		msr_q;		<span class="enscript-comment">/* object request queue */</span>
	queue_chain_t		req_q;		<span class="enscript-comment">/* vm_msync request queue */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		flag;
	vm_object_offset_t	offset;
	vm_object_size_t	length;
	vm_object_t		object;		<span class="enscript-comment">/* back pointer */</span>
	decl_lck_mtx_data(,	msync_req_lock)	<span class="enscript-comment">/* Lock for this structure */</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> msync_req	*msync_req_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MSYNC_REQ_NULL</span>		((msync_req_t) 0)


<span class="enscript-type">extern</span> lck_grp_t		vm_map_lck_grp;
<span class="enscript-type">extern</span> lck_attr_t		vm_map_lck_attr;

<span class="enscript-comment">/*
 * Macros to allocate and free msync_reqs
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">msync_req_alloc</span>(msr)						\
    MACRO_BEGIN							\
        (msr) = (msync_req_t)kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> msync_req));		\
        lck_mtx_init(&amp;(msr)-&gt;msync_req_lock, &amp;vm_map_lck_grp, &amp;vm_map_lck_attr);		\
        msr-&gt;flag = VM_MSYNC_INITIALIZED;				\
    MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">msync_req_free</span>(msr)						\
    MACRO_BEGIN								\
        lck_mtx_destroy(&amp;(msr)-&gt;msync_req_lock, &amp;vm_map_lck_grp);	\
	kfree((msr), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> msync_req));				\
    MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">msr_lock</span>(msr)   lck_mtx_lock(&amp;(msr)-&gt;msync_req_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">msr_unlock</span>(msr) lck_mtx_unlock(&amp;(msr)-&gt;msync_req_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_OBJECT_WIRED</span>(object)						\
    MACRO_BEGIN								\
    <span class="enscript-keyword">if</span> ((object)-&gt;purgable == VM_PURGABLE_DENY)				\
    {									\
	lck_spin_lock(&amp;vm_objects_wired_lock);				\
	assert(!(object)-&gt;objq.next);					\
	queue_enter(&amp;vm_objects_wired, (object), vm_object_t, objq);    \
	lck_spin_unlock(&amp;vm_objects_wired_lock);			\
    }									\
    MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_OBJECT_UNWIRED</span>(object)					 \
    MACRO_BEGIN								 \
    (object)-&gt;wire_tag = VM_KERN_MEMORY_NONE;				 \
    <span class="enscript-keyword">if</span> (((object)-&gt;purgable == VM_PURGABLE_DENY) &amp;&amp; (object)-&gt;objq.next) \
    {									 \
	lck_spin_lock(&amp;vm_objects_wired_lock);				 \
	queue_remove(&amp;vm_objects_wired, (object), vm_object_t, objq);    \
	lck_spin_unlock(&amp;vm_objects_wired_lock);			 \
    }									 \
    MACRO_END


<span class="enscript-comment">/*
 *	Declare procedures that operate on VM objects.
 */</span>

__private_extern__ <span class="enscript-type">void</span>		vm_object_bootstrap(<span class="enscript-type">void</span>);

__private_extern__ <span class="enscript-type">void</span>		vm_object_init(<span class="enscript-type">void</span>);

__private_extern__ <span class="enscript-type">void</span>		vm_object_init_lck_grp(<span class="enscript-type">void</span>);

__private_extern__ <span class="enscript-type">void</span>		vm_object_reaper_init(<span class="enscript-type">void</span>);

__private_extern__ vm_object_t	vm_object_allocate(vm_object_size_t size);

__private_extern__ <span class="enscript-type">void</span>    _vm_object_allocate(vm_object_size_t size,
			    vm_object_t object);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>

__private_extern__ <span class="enscript-type">void</span>	vm_object_res_reference(
				vm_object_t 		object);
__private_extern__ <span class="enscript-type">void</span>	vm_object_res_deallocate(
				vm_object_t		object);
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_OBJ_RES_INCR</span>(object)	(object)-&gt;res_count++
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_OBJ_RES_DECR</span>(object)	(object)-&gt;res_count--

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_OBJ_RES_INCR</span>(object)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_OBJ_RES_DECR</span>(object)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_res_reference</span>(object)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_res_deallocate</span>(object)

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_reference_locked</span>(object)		\
	MACRO_BEGIN					\
	vm_object_t RLObject = (object);		\
	vm_object_lock_assert_exclusive(object);	\
	assert((RLObject)-&gt;ref_count &gt; 0);		\
	(RLObject)-&gt;ref_count++;			\
	assert((RLObject)-&gt;ref_count &gt; 1);		\
	vm_object_res_reference(RLObject);		\
	MACRO_END


#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_reference_shared</span>(object)				\
	MACRO_BEGIN							\
	vm_object_t RLObject = (object);				\
	vm_object_lock_assert_shared(object);				\
	assert((RLObject)-&gt;ref_count &gt; 0);				\
	OSAddAtomic(1, &amp;(RLObject)-&gt;ref_count);		\
	assert((RLObject)-&gt;ref_count &gt; 0);				\
	<span class="enscript-comment">/* XXX we would need an atomic version of the following ... */</span>	\
	vm_object_res_reference(RLObject);				\
	MACRO_END


__private_extern__ <span class="enscript-type">void</span>		vm_object_reference(
					vm_object_t	object);

#<span class="enscript-reference">if</span>	!<span class="enscript-variable-name">MACH_ASSERT</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_object_reference</span>(object)			\
MACRO_BEGIN						\
	vm_object_t RObject = (object);			\
	<span class="enscript-keyword">if</span> (RObject) {					\
		vm_object_lock_shared(RObject);		\
		vm_object_reference_shared(RObject);	\
		vm_object_unlock(RObject);		\
	}						\
MACRO_END

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>

__private_extern__ <span class="enscript-type">void</span>		vm_object_deallocate(
					vm_object_t	object);

__private_extern__ kern_return_t vm_object_release_name(
					vm_object_t	object,
					<span class="enscript-type">int</span>		flags);
							
__private_extern__ <span class="enscript-type">void</span>		vm_object_pmap_protect(
					vm_object_t		object,
					vm_object_offset_t	offset,
					vm_object_size_t	size,
					pmap_t			pmap,
					vm_map_offset_t		pmap_start,
					vm_prot_t		prot);

__private_extern__ <span class="enscript-type">void</span>		vm_object_pmap_protect_options(
					vm_object_t		object,
					vm_object_offset_t	offset,
					vm_object_size_t	size,
					pmap_t			pmap,
					vm_map_offset_t		pmap_start,
					vm_prot_t		prot,
					<span class="enscript-type">int</span>			options);

__private_extern__ <span class="enscript-type">void</span>		vm_object_page_remove(
					vm_object_t		object,
					vm_object_offset_t	start,
					vm_object_offset_t	end);

__private_extern__ <span class="enscript-type">void</span>		vm_object_deactivate_pages(
					vm_object_t		object,
					vm_object_offset_t	offset,
					vm_object_size_t	size,
					boolean_t               kill_page,
					boolean_t		reusable_page,
					<span class="enscript-type">struct</span> pmap		*pmap,
					vm_map_offset_t		pmap_offset);

__private_extern__ <span class="enscript-type">void</span>	vm_object_reuse_pages(
	vm_object_t		object,
	vm_object_offset_t	start_offset,
	vm_object_offset_t	end_offset,
	boolean_t		allow_partial_reuse);

__private_extern__ <span class="enscript-type">void</span>		vm_object_purge(
	                               vm_object_t		object,
				       <span class="enscript-type">int</span>			flags);

__private_extern__ kern_return_t vm_object_purgable_control(
	vm_object_t	object,
	vm_purgable_t	control,
	<span class="enscript-type">int</span>		*state);

__private_extern__ kern_return_t vm_object_get_page_counts(
	vm_object_t		object,
	vm_object_offset_t	offset,
	vm_object_size_t	size,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*resident_page_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*dirty_page_count);

__private_extern__ boolean_t	vm_object_coalesce(
					vm_object_t		prev_object,
					vm_object_t		next_object,
					vm_object_offset_t	prev_offset,
					vm_object_offset_t	next_offset,
					vm_object_size_t	prev_size,
					vm_object_size_t	next_size);

__private_extern__ boolean_t	vm_object_shadow(
					vm_object_t		*object,
					vm_object_offset_t	*offset,
					vm_object_size_t	length);

__private_extern__ <span class="enscript-type">void</span>		vm_object_collapse(
					vm_object_t		object,
					vm_object_offset_t	offset,
					boolean_t		can_bypass);

__private_extern__ boolean_t	vm_object_copy_quickly(
				vm_object_t		*_object,
				vm_object_offset_t	src_offset,
				vm_object_size_t	size,
				boolean_t		*_src_needs_copy,
				boolean_t		*_dst_needs_copy);

__private_extern__ kern_return_t	vm_object_copy_strategically(
				vm_object_t		src_object,
				vm_object_offset_t	src_offset,
				vm_object_size_t	size,
				vm_object_t		*dst_object,
				vm_object_offset_t	*dst_offset,
				boolean_t		*dst_needs_copy);

__private_extern__ kern_return_t	vm_object_copy_slowly(
				vm_object_t		src_object,
				vm_object_offset_t	src_offset,
				vm_object_size_t	size,
				boolean_t		interruptible,
				vm_object_t		*_result_object);

__private_extern__ vm_object_t	vm_object_copy_delayed(
				vm_object_t		src_object,
				vm_object_offset_t	src_offset,
				vm_object_size_t	size,
				boolean_t		src_object_shared);



__private_extern__ kern_return_t	vm_object_destroy(
					vm_object_t	object,
					kern_return_t	reason);

__private_extern__ <span class="enscript-type">void</span>		vm_object_pager_create(
					vm_object_t	object);

__private_extern__ <span class="enscript-type">void</span>		vm_object_compressor_pager_create(
					vm_object_t	object);

__private_extern__ <span class="enscript-type">void</span>		vm_object_page_map(
				vm_object_t	object,
				vm_object_offset_t	offset,
				vm_object_size_t	size,
				vm_object_offset_t	(*map_fn)
					(<span class="enscript-type">void</span> *, vm_object_offset_t),
					<span class="enscript-type">void</span> 		*map_fn_data);

__private_extern__ kern_return_t vm_object_upl_request(
				vm_object_t		object, 
				vm_object_offset_t	offset,
				upl_size_t		size,
				upl_t			*upl,
				upl_page_info_t		*page_info,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*count,
				upl_control_flags_t	flags);

__private_extern__ kern_return_t vm_object_transpose(
				vm_object_t		object1,
				vm_object_t		object2,
				vm_object_size_t	transpose_size);

__private_extern__ boolean_t vm_object_sync(
				vm_object_t		object,
				vm_object_offset_t	offset,
				vm_object_size_t	size,
				boolean_t		should_flush,
				boolean_t		should_return,
				boolean_t		should_iosync);

__private_extern__ kern_return_t vm_object_update(
				vm_object_t		object,
				vm_object_offset_t	offset,
				vm_object_size_t	size,
				vm_object_offset_t	*error_offset,
				<span class="enscript-type">int</span>			*io_errno,
				memory_object_return_t	should_return,
				<span class="enscript-type">int</span>			flags,
				vm_prot_t		prot);

__private_extern__ kern_return_t vm_object_lock_request(
				vm_object_t		object,
				vm_object_offset_t	offset,
				vm_object_size_t	size,
				memory_object_return_t	should_return,
				<span class="enscript-type">int</span>			flags,
				vm_prot_t		prot);



__private_extern__ vm_object_t	vm_object_enter(
					memory_object_t		pager,
					vm_object_size_t	size,
					boolean_t		internal,
					boolean_t		init,
					boolean_t		check_named);


__private_extern__ <span class="enscript-type">void</span>	vm_object_cluster_size(
					vm_object_t		object,
					vm_object_offset_t	*start,
					vm_size_t		*length,
					vm_object_fault_info_t  fault_info,
					uint32_t		*io_streaming);

__private_extern__ kern_return_t vm_object_populate_with_private(
	vm_object_t		object,
	vm_object_offset_t	offset,
	ppnum_t			phys_page,
	vm_size_t		size);

__private_extern__ <span class="enscript-type">void</span> vm_object_change_wimg_mode(
	vm_object_t		object,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		wimg_mode);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">adjust_vm_object_cache</span>(
	vm_size_t oval,
	vm_size_t nval);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_object_page_op</span>(
	vm_object_t		object,
	vm_object_offset_t	offset,
	<span class="enscript-type">int</span>			ops,
	ppnum_t			*phys_entry,
	<span class="enscript-type">int</span>			*flags);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_object_range_op</span>(
	vm_object_t		object,
	vm_object_offset_t	offset_beg,
	vm_object_offset_t	offset_end,
	<span class="enscript-type">int</span>                     ops,
	uint32_t		*range);


__private_extern__ <span class="enscript-type">void</span>		vm_object_reap_pages(
	                                vm_object_t object,
					<span class="enscript-type">int</span>	reap_type);
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REAP_REAP</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">REAP_TERMINATE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REAP_PURGEABLE</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REAP_DATA_FLUSH</span>	3

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
<span class="enscript-type">struct</span> default_freezer_handle;

__private_extern__ kern_return_t 
<span class="enscript-function-name">vm_object_pack</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*purgeable_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*wired_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*clean_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*dirty_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		dirty_budget,
	boolean_t		*shared,
	vm_object_t		src_object,
	<span class="enscript-type">struct</span> default_freezer_handle *df_handle);

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pack_pages</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*wired_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*clean_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*dirty_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		dirty_budget,
	vm_object_t		src_object,
	<span class="enscript-type">struct</span> default_freezer_handle *df_handle);

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_compressed_freezer_pageout</span>(
	vm_object_t     object);

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_compressed_freezer_done</span>(
	<span class="enscript-type">void</span>);

__private_extern__  kern_return_t
<span class="enscript-function-name">vm_object_pagein</span>(
	vm_object_t     object);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_object_pageout</span>(
	vm_object_t     object);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-type">struct</span> io_reprioritize_req {
	uint64_t 	blkno;
	uint32_t 	len;
	<span class="enscript-type">int</span> 		priority;
	<span class="enscript-type">struct</span> vnode 	*devvp;
	queue_chain_t 	io_reprioritize_list;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> io_reprioritize_req *io_reprioritize_req_t;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_io_reprioritize_init</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Event waiting handling
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_INITIALIZED</span>		0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_PAGER_READY</span>		1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_PAGING_IN_PROGRESS</span>	2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_MAPPING_IN_PROGRESS</span>	3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_LOCK_IN_PROGRESS</span>	4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_UNCACHING</span>		5
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_COPY_CALL</span>		6
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_OBJECT_EVENT_CACHING</span>			7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_EVENT_UNBLOCKED</span>		8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_OBJECT_EVENT_PAGING_ONLY_IN_PROGRESS</span>	9

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_object_assert_wait</span>(object, event, interruptible)		\
	(((object)-&gt;all_wanted |= 1 &lt;&lt; (event)),			\
	 assert_wait((event_t)((vm_offset_t)(object)+(event)),(interruptible)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_object_wait</span>(object, event, interruptible)			\
	(vm_object_assert_wait((object),(event),(interruptible)),	\
	vm_object_unlock(object),					\
	thread_block(THREAD_CONTINUE_NULL))				\

#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_sleep_vm_object</span>(object, event, interruptible)		\
        lck_rw_sleep(&amp;(object)-&gt;Lock, LCK_SLEEP_PROMOTED_PRI, (event_t)(event), (interruptible))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_sleep</span>(object, event, interruptible)			\
	(((object)-&gt;all_wanted |= 1 &lt;&lt; (event)),			\
	 thread_sleep_vm_object((object), 				\
		((vm_offset_t)(object)+(event)), (interruptible)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_object_wakeup</span>(object, event)					\
	MACRO_BEGIN							\
	<span class="enscript-keyword">if</span> ((object)-&gt;all_wanted &amp; (1 &lt;&lt; (event)))			\
		thread_wakeup((event_t)((vm_offset_t)(object) + (event))); \
	(object)-&gt;all_wanted &amp;= ~(1 &lt;&lt; (event));			\
	MACRO_END

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_object_set_wanted</span>(object, event)				\
	MACRO_BEGIN							\
	((object)-&gt;all_wanted |= (1 &lt;&lt; (event)));			\
	MACRO_END

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_object_wanted</span>(object, event)					\
	((object)-&gt;all_wanted &amp; (1 &lt;&lt; (event)))

<span class="enscript-comment">/*
 *	Routines implemented as macros
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_PIP_DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PIP_DEBUG_BEGIN</span>(object)					\
	MACRO_BEGIN							\
	<span class="enscript-type">int</span> pip = ((object)-&gt;paging_in_progress +			\
		   (object)-&gt;activity_in_progress);			\
	<span class="enscript-keyword">if</span> (pip &lt; VM_PIP_DEBUG_MAX_REFS) {				\
		(<span class="enscript-type">void</span>) OSBacktrace(&amp;(object)-&gt;pip_holders[pip].pip_retaddr[0], \
				   VM_PIP_DEBUG_STACK_FRAMES);		\
	}								\
	MACRO_END
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* VM_PIP_DEBUG */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PIP_DEBUG_BEGIN</span>(object)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VM_PIP_DEBUG */</span>

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_object_activity_begin</span>(object)			\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	VM_PIP_DEBUG_BEGIN((object));					\
	(object)-&gt;activity_in_progress++;				\
	<span class="enscript-keyword">if</span> ((object)-&gt;activity_in_progress == 0) {			\
		panic(<span class="enscript-string">&quot;vm_object_activity_begin(%p): overflow\n&quot;</span>, (object));\
	}								\
	MACRO_END

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_object_activity_end</span>(object)				\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	<span class="enscript-keyword">if</span> ((object)-&gt;activity_in_progress == 0) {			\
		panic(<span class="enscript-string">&quot;vm_object_activity_end(%p): underflow\n&quot;</span>, (object));\
	}								\
	(object)-&gt;activity_in_progress--;				\
	<span class="enscript-keyword">if</span> ((object)-&gt;paging_in_progress == 0 &amp;&amp;			\
	    (object)-&gt;activity_in_progress == 0)			\
		vm_object_wakeup((object),				\
				 VM_OBJECT_EVENT_PAGING_IN_PROGRESS);	\
	MACRO_END

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_object_paging_begin</span>(object)				\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	VM_PIP_DEBUG_BEGIN((object));					\
	(object)-&gt;paging_in_progress++;					\
	<span class="enscript-keyword">if</span> ((object)-&gt;paging_in_progress == 0) {			\
		panic(<span class="enscript-string">&quot;vm_object_paging_begin(%p): overflow\n&quot;</span>, (object));\
	}								\
	MACRO_END

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_object_paging_end</span>(object)				\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	<span class="enscript-keyword">if</span> ((object)-&gt;paging_in_progress == 0) {			\
		panic(<span class="enscript-string">&quot;vm_object_paging_end(%p): underflow\n&quot;</span>, (object));\
	}								\
	(object)-&gt;paging_in_progress--;					\
	<span class="enscript-keyword">if</span> ((object)-&gt;paging_in_progress == 0) {			\
		vm_object_wakeup((object),				\
				 VM_OBJECT_EVENT_PAGING_ONLY_IN_PROGRESS); \
		<span class="enscript-keyword">if</span> ((object)-&gt;activity_in_progress == 0)		\
			vm_object_wakeup((object),			\
					 VM_OBJECT_EVENT_PAGING_IN_PROGRESS); \
	}								\
	MACRO_END

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_object_paging_wait</span>(object, interruptible)		\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	<span class="enscript-keyword">while</span> ((object)-&gt;paging_in_progress != 0 ||			\
	       (object)-&gt;activity_in_progress != 0) {			\
		wait_result_t  _wr;					\
									\
		_wr = vm_object_sleep((object),				\
				VM_OBJECT_EVENT_PAGING_IN_PROGRESS,	\
				(interruptible));			\
									\
		<span class="enscript-comment">/*XXX if ((interruptible) &amp;&amp; (_wr != THREAD_AWAKENED))*/</span>\
			<span class="enscript-comment">/*XXX break; */</span>					\
	}								\
	MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_paging_only_wait</span>(object, interruptible)		\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	<span class="enscript-keyword">while</span> ((object)-&gt;paging_in_progress != 0) {			\
		wait_result_t  _wr;					\
									\
		_wr = vm_object_sleep((object),				\
				VM_OBJECT_EVENT_PAGING_ONLY_IN_PROGRESS,\
				(interruptible));			\
									\
		<span class="enscript-comment">/*XXX if ((interruptible) &amp;&amp; (_wr != THREAD_AWAKENED))*/</span>\
			<span class="enscript-comment">/*XXX break; */</span>					\
	}								\
	MACRO_END


#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_mapping_begin</span>(object) 				\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	assert(! (object)-&gt;mapping_in_progress);			\
	(object)-&gt;mapping_in_progress = TRUE;				\
	MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_mapping_end</span>(object)					\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	assert((object)-&gt;mapping_in_progress);				\
	(object)-&gt;mapping_in_progress = FALSE;				\
	vm_object_wakeup((object),					\
			 VM_OBJECT_EVENT_MAPPING_IN_PROGRESS);		\
	MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_mapping_wait</span>(object, interruptible)			\
	MACRO_BEGIN							\
	vm_object_lock_assert_exclusive((object));			\
	<span class="enscript-keyword">while</span> ((object)-&gt;mapping_in_progress) {				\
		wait_result_t	_wr;					\
									\
		_wr = vm_object_sleep((object),				\
				      VM_OBJECT_EVENT_MAPPING_IN_PROGRESS, \
				      (interruptible));			\
		<span class="enscript-comment">/*XXX if ((interruptible) &amp;&amp; (_wr != THREAD_AWAKENED))*/</span>\
			<span class="enscript-comment">/*XXX break; */</span>					\
	}								\
	assert(!(object)-&gt;mapping_in_progress);				\
	MACRO_END



#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OBJECT_LOCK_SHARED</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OBJECT_LOCK_EXCLUSIVE</span>	1

<span class="enscript-type">extern</span> lck_grp_t	vm_object_lck_grp;
<span class="enscript-type">extern</span> lck_grp_attr_t	vm_object_lck_grp_attr;
<span class="enscript-type">extern</span> lck_attr_t	vm_object_lck_attr;
<span class="enscript-type">extern</span> lck_attr_t	kernel_object_lck_attr;
<span class="enscript-type">extern</span> lck_attr_t	compressor_object_lck_attr;

<span class="enscript-type">extern</span> vm_object_t	vm_pageout_scan_wants_object;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_object_lock(vm_object_t);
<span class="enscript-type">extern</span> boolean_t	vm_object_lock_try(vm_object_t);
<span class="enscript-type">extern</span> boolean_t	_vm_object_lock_try(vm_object_t);
<span class="enscript-type">extern</span> boolean_t	vm_object_lock_avoid(vm_object_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_object_lock_shared(vm_object_t);
<span class="enscript-type">extern</span> boolean_t	vm_object_lock_try_shared(vm_object_t);

<span class="enscript-comment">/*
 *	Object locking macros
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_init</span>(object)					\
	lck_rw_init(&amp;(object)-&gt;Lock, &amp;vm_object_lck_grp,		\
		    (((object) == kernel_object ||			\
		      (object) == vm_submap_object) ?			\
		     &amp;kernel_object_lck_attr :				\
		     (((object) == compressor_object) ?			\
		     &amp;compressor_object_lck_attr :			\
		      &amp;vm_object_lck_attr)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_destroy</span>(object)	lck_rw_destroy(&amp;(object)-&gt;Lock, &amp;vm_object_lck_grp)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_unlock</span>(object)	lck_rw_done(&amp;(object)-&gt;Lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_upgrade</span>(object)	lck_rw_lock_shared_to_exclusive(&amp;(object)-&gt;Lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_try_scan</span>(object)	_vm_object_lock_try(object)

<span class="enscript-comment">/*
 * CAUTION: the following vm_object_lock_assert_held*() macros merely
 * check if anyone is holding the lock, but the holder may not necessarily
 * be the caller...
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_held</span>(object) \
	lck_rw_assert(&amp;(object)-&gt;Lock, LCK_RW_ASSERT_HELD)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_shared</span>(object)	\
	lck_rw_assert(&amp;(object)-&gt;Lock, LCK_RW_ASSERT_SHARED)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_exclusive</span>(object) \
	lck_rw_assert(&amp;(object)-&gt;Lock, LCK_RW_ASSERT_EXCLUSIVE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_notheld</span>(object) \
	lck_rw_assert(&amp;(object)-&gt;Lock, LCK_RW_ASSERT_NOTHELD)
#<span class="enscript-reference">else</span>  <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_held</span>(object)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_shared</span>(object)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_exclusive</span>(object)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_lock_assert_notheld</span>(object)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_round_page</span>(x) (((vm_object_offset_t)(x) + PAGE_MASK) &amp; ~((signed)PAGE_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_object_trunc_page</span>(x) ((vm_object_offset_t)(x) &amp; ~((signed)PAGE_MASK))

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	vm_object_cache_add(vm_object_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	vm_object_cache_remove(vm_object_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	vm_object_cache_evict(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _VM_VM_OBJECT_H_ */</span>
</pre>
<hr />
</body></html>