<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_map_store_rb.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_map_store_rb.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map_store_rb.h&gt;</span>

<span class="enscript-function-name">RB_GENERATE</span>(rb_head, vm_map_store, entry, rb_node_compare);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_FOR_STORE</span>( store)	\
	(vm_map_entry_t)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)store) - ((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vm_map_links)))

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_init_rb</span>( <span class="enscript-type">struct</span> vm_map_header* hdr )
{
	RB_INIT(&amp;(hdr-&gt;rb_head_store));
}

<span class="enscript-type">int</span> <span class="enscript-function-name">rb_node_compare</span>(<span class="enscript-type">struct</span> vm_map_store *node, <span class="enscript-type">struct</span> vm_map_store *parent)
{
	vm_map_entry_t vme_c;
	vm_map_entry_t vme_p;

	vme_c = VME_FOR_STORE(node);
	vme_p =  VME_FOR_STORE(parent);
	<span class="enscript-keyword">if</span> (vme_c-&gt;vme_start &lt; vme_p-&gt;vme_start)
		<span class="enscript-keyword">return</span> -1;
	<span class="enscript-keyword">if</span> (vme_c-&gt;vme_start &gt;= vme_p-&gt;vme_end)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_store_walk_rb</span>( vm_map_t map, vm_map_entry_t *wrong_vme, vm_map_entry_t *vm_entry)
{
	<span class="enscript-type">struct</span> vm_map_header hdr = map-&gt;hdr;
	<span class="enscript-type">struct</span> vm_map_store *rb_entry = RB_ROOT(&amp;(hdr.rb_head_store));
	vm_map_entry_t cur = *vm_entry;

	rb_entry = RB_FIND( rb_head, &amp;(hdr.rb_head_store), &amp;(cur-&gt;store));	
	<span class="enscript-keyword">if</span>(rb_entry == NULL)
		panic(<span class="enscript-string">&quot;NO SUCH ENTRY %p. Gave back %p&quot;</span>, *vm_entry, *wrong_vme);
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;Cur: %p, L: %p, R: %p&quot;</span>,  VME_FOR_STORE(rb_entry),  VME_FOR_STORE(RB_LEFT(rb_entry,entry)),  VME_FOR_STORE(RB_RIGHT(rb_entry,entry)));
}


boolean_t <span class="enscript-function-name">vm_map_store_lookup_entry_rb</span>( vm_map_t map, vm_map_offset_t address, vm_map_entry_t *vm_entry)
{
	<span class="enscript-type">struct</span> vm_map_header hdr = map-&gt;hdr;
	<span class="enscript-type">struct</span> vm_map_store *rb_entry = RB_ROOT(&amp;(hdr.rb_head_store));
	vm_map_entry_t cur = vm_map_to_entry(map);
	vm_map_entry_t prev = VM_MAP_ENTRY_NULL;

	<span class="enscript-keyword">while</span> (rb_entry != (<span class="enscript-type">struct</span> vm_map_store*)NULL) {
       		cur =  VME_FOR_STORE(rb_entry);
		<span class="enscript-keyword">if</span>(cur == VM_MAP_ENTRY_NULL)
			panic(<span class="enscript-string">&quot;no entry&quot;</span>);
		<span class="enscript-keyword">if</span> (address &gt;= cur-&gt;vme_start) {
			<span class="enscript-keyword">if</span> (address &lt; cur-&gt;vme_end) {
				*vm_entry = cur;
				<span class="enscript-keyword">return</span> TRUE;
			}
			rb_entry = RB_RIGHT(rb_entry, entry);
			prev = cur;
		} <span class="enscript-keyword">else</span> {
			rb_entry = RB_LEFT(rb_entry, entry);
		}
	}
	<span class="enscript-keyword">if</span>( prev == VM_MAP_ENTRY_NULL){
		prev = vm_map_to_entry(map);
	}
	*vm_entry = prev;
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-type">void</span> 	vm_map_store_entry_link_rb( <span class="enscript-type">struct</span> vm_map_header *mapHdr, __unused vm_map_entry_t after_where, vm_map_entry_t entry)
{
	<span class="enscript-type">struct</span> rb_head *rbh = &amp;(mapHdr-&gt;rb_head_store);
	<span class="enscript-type">struct</span> vm_map_store *store = &amp;(entry-&gt;store);
	<span class="enscript-type">struct</span> vm_map_store *tmp_store;
	<span class="enscript-keyword">if</span>((tmp_store = RB_INSERT( rb_head, rbh, store )) != NULL) {
		panic(<span class="enscript-string">&quot;VMSEL: INSERT FAILED: 0x%lx, 0x%lx, 0x%lx, 0x%lx&quot;</span>, (uintptr_t)entry-&gt;vme_start, (uintptr_t)entry-&gt;vme_end,
				(uintptr_t)(VME_FOR_STORE(tmp_store))-&gt;vme_start,  (uintptr_t)(VME_FOR_STORE(tmp_store))-&gt;vme_end);
	}
}

<span class="enscript-type">void</span>	vm_map_store_entry_unlink_rb( <span class="enscript-type">struct</span> vm_map_header *mapHdr, vm_map_entry_t entry)
{
	<span class="enscript-type">struct</span> rb_head *rbh = &amp;(mapHdr-&gt;rb_head_store);
	<span class="enscript-type">struct</span> vm_map_store *rb_entry;
	<span class="enscript-type">struct</span> vm_map_store *store = &amp;(entry-&gt;store);
	
	rb_entry = RB_FIND( rb_head, rbh, store);	
	<span class="enscript-keyword">if</span>(rb_entry == NULL)
		panic(<span class="enscript-string">&quot;NO ENTRY TO DELETE&quot;</span>);
	RB_REMOVE( rb_head, rbh, store );
}

<span class="enscript-type">void</span>	vm_map_store_copy_insert_rb( vm_map_t map, __unused vm_map_entry_t after_where, vm_map_copy_t copy)
{
	<span class="enscript-type">struct</span> vm_map_header *mapHdr = &amp;(map-&gt;hdr);
	<span class="enscript-type">struct</span> rb_head *rbh = &amp;(mapHdr-&gt;rb_head_store);
	<span class="enscript-type">struct</span> vm_map_store *store;
	vm_map_entry_t entry = vm_map_copy_first_entry(copy);
	<span class="enscript-type">int</span> inserted=0, nentries = copy-&gt;cpy_hdr.nentries;
		
	<span class="enscript-keyword">while</span> (entry != vm_map_copy_to_entry(copy) &amp;&amp; nentries &gt; 0) {		
		vm_map_entry_t prev = entry;
		store = &amp;(entry-&gt;store);
		<span class="enscript-keyword">if</span>( RB_INSERT( rb_head, rbh, store ) != NULL){
			panic(<span class="enscript-string">&quot;VMSCIR1: INSERT FAILED: %d: %p, %p, %p, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx&quot;</span>,inserted, prev, entry, vm_map_copy_to_entry(copy), 
					(uintptr_t)prev-&gt;vme_start,  (uintptr_t)prev-&gt;vme_end,  (uintptr_t)entry-&gt;vme_start,  (uintptr_t)entry-&gt;vme_end,  
					 (uintptr_t)(VME_FOR_STORE(rbh-&gt;rbh_root))-&gt;vme_start,  (uintptr_t)(VME_FOR_STORE(rbh-&gt;rbh_root))-&gt;vme_end);
		} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MAP_ENTRY_INSERTION_DEBUG</span>
			fastbacktrace(&amp;entry-&gt;vme_insertion_bt[0],
				      (<span class="enscript-keyword">sizeof</span> (entry-&gt;vme_insertion_bt) / <span class="enscript-keyword">sizeof</span> (uintptr_t)));
#<span class="enscript-reference">endif</span>
			entry = entry-&gt;vme_next;
			inserted++;
			nentries--;
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_store_copy_reset_rb</span>( vm_map_copy_t copy, vm_map_entry_t entry, <span class="enscript-type">int</span> nentries )
{
	<span class="enscript-type">struct</span> vm_map_header *mapHdr = &amp;(copy-&gt;cpy_hdr);
	<span class="enscript-type">struct</span> rb_head *rbh = &amp;(mapHdr-&gt;rb_head_store);
	<span class="enscript-type">struct</span> vm_map_store *store;
	<span class="enscript-type">int</span> deleted=0;
		
	<span class="enscript-keyword">while</span> (entry != vm_map_copy_to_entry(copy) &amp;&amp; nentries &gt; 0) {		
		store = &amp;(entry-&gt;store);
		RB_REMOVE( rb_head, rbh, store );
		entry = entry-&gt;vme_next;
		deleted++;
		nentries--;
	}
}

<span class="enscript-type">extern</span> zone_t	vm_map_holes_zone;	<span class="enscript-comment">/* zone for vm map holes (vm_map_links) structures */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_combine_hole</span>(vm_map_t map, vm_map_entry_t hole_entry);
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_combine_hole</span>(__unused vm_map_t map, vm_map_entry_t hole_entry)
{

	vm_map_entry_t middle_hole_entry, last_hole_entry;

	hole_entry-&gt;vme_end = hole_entry-&gt;vme_next-&gt;vme_end;

	middle_hole_entry = hole_entry-&gt;vme_next;
	last_hole_entry = middle_hole_entry-&gt;vme_next;

	assert(last_hole_entry-&gt;vme_prev == middle_hole_entry);
	assert(middle_hole_entry-&gt;vme_end != last_hole_entry-&gt;vme_start);

	last_hole_entry-&gt;vme_prev = hole_entry;
	hole_entry-&gt;vme_next = last_hole_entry;

	middle_hole_entry-&gt;vme_prev = NULL;
	middle_hole_entry-&gt;vme_next = NULL;

	zfree(vm_map_holes_zone, middle_hole_entry);

	assert(hole_entry-&gt;vme_start &lt; hole_entry-&gt;vme_end);
	assert(last_hole_entry-&gt;vme_start &lt; last_hole_entry-&gt;vme_end);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_delete_hole</span>(vm_map_t map, vm_map_entry_t hole_entry);
<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_delete_hole</span>(vm_map_t map, vm_map_entry_t hole_entry)
{
	<span class="enscript-keyword">if</span> (hole_entry == (vm_map_entry_t) map-&gt;holes_list) {

		<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_next == (vm_map_entry_t) map-&gt;holes_list) {

			map-&gt;holes_list = NULL;
			SAVE_HINT_HOLE_WRITE(map, NULL);
		} <span class="enscript-keyword">else</span> {

			vm_map_entry_t l_next, l_prev;

			l_next = (vm_map_entry_t) map-&gt;holes_list-&gt;next;
			l_prev = (vm_map_entry_t) map-&gt;holes_list-&gt;prev;
			map-&gt;holes_list = (<span class="enscript-type">struct</span> vm_map_links*) l_next;

			l_next-&gt;vme_prev = l_prev;
			l_prev-&gt;vme_next = l_next;

			SAVE_HINT_HOLE_WRITE(map, (<span class="enscript-type">struct</span> vm_map_links*) l_next);
		}
	} <span class="enscript-keyword">else</span> {

		SAVE_HINT_HOLE_WRITE(map, (<span class="enscript-type">struct</span> vm_map_links*) hole_entry-&gt;vme_prev);

		hole_entry-&gt;vme_prev-&gt;vme_next = hole_entry-&gt;vme_next;
		hole_entry-&gt;vme_next-&gt;vme_prev = hole_entry-&gt;vme_prev;
	}

	hole_entry-&gt;vme_next = NULL;
	hole_entry-&gt;vme_prev = NULL;
	zfree(vm_map_holes_zone, hole_entry);
}


<span class="enscript-comment">/*
 * For Debugging.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">check_map_sanity</span>(vm_map_t map, vm_map_entry_t old_hole_entry)
{
	vm_map_entry_t	hole_entry, next_hole_entry;
	vm_map_entry_t	map_entry, next_map_entry;

	<span class="enscript-keyword">if</span> (map-&gt;holes_list == NULL) {

		<span class="enscript-keyword">return</span>;
	}

	hole_entry = (vm_map_entry_t) map-&gt;holes_list;
	next_hole_entry = hole_entry-&gt;vme_next;

	map_entry = vm_map_first_entry(map);
	next_map_entry = map_entry-&gt;vme_next;

	<span class="enscript-keyword">while</span>(map_entry-&gt;vme_start &gt; hole_entry-&gt;vme_start) {
		hole_entry = next_hole_entry;
		next_hole_entry = hole_entry-&gt;vme_next;

		<span class="enscript-keyword">if</span> (hole_entry == (vm_map_entry_t)map-&gt;holes_list)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">while</span> (map_entry != vm_map_to_entry(map)) {

		<span class="enscript-keyword">if</span> (map_entry-&gt;vme_start &gt;= map-&gt;max_offset)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (map_entry-&gt;vme_end != map_entry-&gt;vme_next-&gt;vme_start) {

			<span class="enscript-keyword">if</span> (map_entry-&gt;vme_next == vm_map_to_entry(map))
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start != map_entry-&gt;vme_end) {
				panic(<span class="enscript-string">&quot;hole_entry not aligned %p(0x%llx), %p (0x%llx), %p&quot;</span>, hole_entry, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_start, map_entry-&gt;vme_next, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)map_entry-&gt;vme_end, old_hole_entry);
				assert(hole_entry-&gt;vme_start == map_entry-&gt;vme_end);
			}

			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_end != map_entry-&gt;vme_next-&gt;vme_start) {
				panic(<span class="enscript-string">&quot;hole_entry not next aligned %p(0x%llx), %p (0x%llx), %p&quot;</span>, hole_entry, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_end, map_entry-&gt;vme_next, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)map_entry-&gt;vme_next-&gt;vme_start, old_hole_entry);
				assert(hole_entry-&gt;vme_end == map_entry-&gt;vme_next-&gt;vme_start);
			}

			hole_entry = next_hole_entry;
			next_hole_entry = hole_entry-&gt;vme_next;

			<span class="enscript-keyword">if</span> (hole_entry == (vm_map_entry_t)map-&gt;holes_list)
				<span class="enscript-keyword">break</span>;
		}

		map_entry = map_entry-&gt;vme_next;
	}
}

<span class="enscript-comment">/*
 * For debugging.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">copy_hole_info</span>(vm_map_entry_t hole_entry, vm_map_entry_t old_hole_entry)
{
	old_hole_entry-&gt;vme_prev = hole_entry-&gt;vme_prev;
	old_hole_entry-&gt;vme_next = hole_entry-&gt;vme_next;
	old_hole_entry-&gt;vme_start = hole_entry-&gt;vme_start;
	old_hole_entry-&gt;vme_end = hole_entry-&gt;vme_end;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">update_holes_on_entry_deletion</span>(vm_map_t map, vm_map_entry_t old_entry);
<span class="enscript-type">void</span>
<span class="enscript-function-name">update_holes_on_entry_deletion</span>(vm_map_t map, vm_map_entry_t old_entry)
{
	<span class="enscript-comment">/*
	 * Dealing with the deletion of an older entry.
	 */</span>

	vm_map_entry_t		hole_entry, next_hole_entry;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-type">struct</span> vm_map_entry	old_hole_entry;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
	boolean_t		create_new_hole = TRUE;

	hole_entry = (vm_map_entry_t) map-&gt;hole_hint;

	<span class="enscript-keyword">if</span> (hole_entry) {

		<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_end == old_entry-&gt;vme_start) {
			<span class="enscript-comment">/*
			 * Found a hole right after above our entry.
			 * Hit.
			 */</span>

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start == old_entry-&gt;vme_end) {

			<span class="enscript-keyword">if</span> (hole_entry != (vm_map_entry_t) map-&gt;holes_list) {

				<span class="enscript-comment">/*
				 * Found a hole right after below our entry but
				 * make sure we don't erroneously extend backwards.
				 *  
				 * Hit.
				 */</span>

				hole_entry = hole_entry-&gt;vme_prev;
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start &gt; old_entry-&gt;vme_end) {

			<span class="enscript-comment">/*
			 * Useless hint. Start from the top.
			 */</span>

			hole_entry = (vm_map_entry_t) map-&gt;holes_list;
		}

		<span class="enscript-keyword">if</span> (hole_entry != (vm_map_entry_t) map-&gt;holes_list) {
			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start &gt; old_entry-&gt;vme_start) {
				panic(<span class="enscript-string">&quot;Hole hint failed: Hole entry start: 0x%llx, entry start: 0x%llx, map hole start: 0x%llx, map hint start: 0x%llx\n&quot;</span>,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_start,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)old_entry-&gt;vme_start,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)map-&gt;holes_list-&gt;start,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)map-&gt;hole_hint-&gt;start);
			}
			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_end &gt; old_entry-&gt;vme_start) {
				panic(<span class="enscript-string">&quot;Hole hint failed: Hole entry end: 0x%llx, entry start: 0x%llx, map hole start: 0x%llx, map hint start: 0x%llx\n&quot;</span>,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_end,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)old_entry-&gt;vme_start,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)map-&gt;holes_list-&gt;start,
					(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)map-&gt;hole_hint-&gt;start);
			}
		}

		<span class="enscript-keyword">while</span> (1) {

			next_hole_entry = hole_entry-&gt;vme_next;

			<span class="enscript-comment">/*
			 * Hole is right above the entry.
			 */</span>
			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_end == old_entry-&gt;vme_start) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

				<span class="enscript-comment">/*
				 * Is there another hole right below the entry?
				 * Can we combine holes?
				 */</span>

				<span class="enscript-keyword">if</span> (old_entry-&gt;vme_end == hole_entry-&gt;vme_next-&gt;vme_start) {

					vm_map_combine_hole(map, hole_entry);
				} <span class="enscript-keyword">else</span> {

					hole_entry-&gt;vme_end = old_entry-&gt;vme_end;
				}
				create_new_hole = FALSE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * Hole is right below the entry.
			 */</span>
			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start == old_entry-&gt;vme_end) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

				hole_entry-&gt;vme_start = old_entry-&gt;vme_start;
				create_new_hole = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * Hole is beyond our entry. Let's go back to the last hole
			 * before our entry so we have the right place to link up the
			 * new hole that will be needed.
			 */</span>
			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start &gt; old_entry-&gt;vme_end) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

				<span class="enscript-keyword">if</span> (hole_entry != (vm_map_entry_t) map-&gt;holes_list) {
					assert(hole_entry-&gt;vme_start != old_entry-&gt;vme_start);
					hole_entry = hole_entry-&gt;vme_prev;
				}
				<span class="enscript-keyword">break</span>;
			}

			hole_entry = next_hole_entry;

			<span class="enscript-keyword">if</span> (hole_entry == (vm_map_entry_t)map-&gt;holes_list) {
				hole_entry = hole_entry-&gt;vme_prev;
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> (create_new_hole) {
		<span class="enscript-type">struct</span> vm_map_links	*new_hole_entry = NULL;
		vm_map_entry_t		l_next, l_prev;

		new_hole_entry = zalloc(vm_map_holes_zone);

		<span class="enscript-comment">/*
		 * First hole in the map?
		 * OR
		 * A hole that is located above the current first hole in the map?
		 */</span>
		<span class="enscript-keyword">if</span> (map-&gt;holes_list == NULL || (hole_entry == (vm_map_entry_t) map-&gt;holes_list &amp;&amp; hole_entry-&gt;vme_start &gt; old_entry-&gt;vme_start)) {

			<span class="enscript-keyword">if</span> (map-&gt;holes_list == NULL) {

				map-&gt;holes_list = new_hole_entry;
				new_hole_entry-&gt;prev = new_hole_entry-&gt;next = (vm_map_entry_t)map-&gt;holes_list;
			} <span class="enscript-keyword">else</span> {

				l_next = (vm_map_entry_t) map-&gt;holes_list;
				l_prev = map-&gt;holes_list-&gt;prev;
				map-&gt;holes_list = new_hole_entry;
				new_hole_entry-&gt;next = l_next;
				new_hole_entry-&gt;prev = l_prev;

				l_prev-&gt;vme_next = l_next-&gt;vme_prev = (vm_map_entry_t) new_hole_entry;
			}
		} <span class="enscript-keyword">else</span> {

			l_next = hole_entry-&gt;vme_next;
			l_prev = hole_entry-&gt;vme_next-&gt;vme_prev;

			new_hole_entry-&gt;prev = hole_entry;
			new_hole_entry-&gt;next = l_next;

			hole_entry-&gt;vme_next = (vm_map_entry_t)new_hole_entry;
			l_next-&gt;vme_prev = (vm_map_entry_t) new_hole_entry;
		}

		new_hole_entry-&gt;start = old_entry-&gt;vme_start;
		new_hole_entry-&gt;end = old_entry-&gt;vme_end;

		hole_entry = (vm_map_entry_t) new_hole_entry;

		assert(new_hole_entry-&gt;start &lt; new_hole_entry-&gt;end);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	SAVE_HINT_HOLE_WRITE(map, (<span class="enscript-type">struct</span> vm_map_links*) hole_entry);
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">update_holes_on_entry_creation</span>(vm_map_t map, vm_map_entry_t new_entry);
<span class="enscript-type">void</span>
<span class="enscript-function-name">update_holes_on_entry_creation</span>(vm_map_t map, vm_map_entry_t new_entry)
{

	vm_map_entry_t			hole_entry, next_hole_entry;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-type">struct</span> vm_map_entry		old_hole_entry;
	vm_map_entry_t			tmp_entry;
	boolean_t				check_map_with_hole_sanity = TRUE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-comment">/*
	 * Case A: The entry is aligned exactly with the start and end of the hole.
	 *	   This will delete the hole.
	 *
	 * Case B: The entry is completely within a hole but NOT aligned with the start/end of the hole.
	 *	   This  will split a hole.
	 *
	 * Case C: The entry overlaps with the hole. The entry could be extending upwards (C1) or downwards (C2).
	 *	   This will reduce the size of the hole or delete the hole completely if it is smaller than the entry.
	 */</span>

	hole_entry = (vm_map_entry_t) map-&gt;holes_list;
	assert(hole_entry);
	next_hole_entry = hole_entry-&gt;vme_next;

	<span class="enscript-keyword">while</span> (1) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-comment">/*
		 * If the entry doesn't exist in the RB tree, we are likely dealing with copy maps where
		 * the entries belonging to the copy map are linked into the list of entries silently and
		 * then added to the RB-tree later on.
		 * So sanity checks are useless in that case.
		 */</span>
		check_map_with_hole_sanity = vm_map_lookup_entry(map, new_entry-&gt;vme_start, &amp;tmp_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

		<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start == new_entry-&gt;vme_start &amp;&amp;
		    hole_entry-&gt;vme_end == new_entry-&gt;vme_end) {

			<span class="enscript-comment">/* Case A */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			<span class="enscript-keyword">if</span> (hole_entry == (vm_map_entry_t) map-&gt;holes_list) {

				<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_next == (vm_map_entry_t) map-&gt;holes_list) {

					next_hole_entry = vm_map_last_entry(map);
					assert(next_hole_entry-&gt;vme_end &gt;= map-&gt;max_offset);
				}
			}

			vm_map_delete_hole(map, hole_entry);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-keyword">if</span> (check_map_with_hole_sanity)
				check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
			<span class="enscript-keyword">return</span>;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start &lt; new_entry-&gt;vme_start &amp;&amp;
			   hole_entry-&gt;vme_end &gt; new_entry-&gt;vme_end) {

			<span class="enscript-comment">/* Case B */</span>
			<span class="enscript-type">struct</span> vm_map_links *new_hole_entry = NULL;

			new_hole_entry = zalloc(vm_map_holes_zone);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			new_hole_entry-&gt;prev = hole_entry;
			new_hole_entry-&gt;next = hole_entry-&gt;vme_next;
			hole_entry-&gt;vme_next-&gt;vme_prev = (vm_map_entry_t)new_hole_entry;
			hole_entry-&gt;vme_next = (vm_map_entry_t)new_hole_entry;

			new_hole_entry-&gt;start = new_entry-&gt;vme_end;
			new_hole_entry-&gt;end = hole_entry-&gt;vme_end;
			hole_entry-&gt;vme_end = new_entry-&gt;vme_start;

			assert(hole_entry-&gt;vme_start &lt; hole_entry-&gt;vme_end);
			assert(new_hole_entry-&gt;start &lt; new_hole_entry-&gt;end);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-keyword">if</span> (check_map_with_hole_sanity)
				check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			SAVE_HINT_HOLE_WRITE(map, (<span class="enscript-type">struct</span> vm_map_links*) hole_entry);
			<span class="enscript-keyword">return</span>;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((new_entry-&gt;vme_start &lt;= hole_entry-&gt;vme_start) &amp;&amp; (hole_entry-&gt;vme_start &lt; new_entry-&gt;vme_end)) {

			<span class="enscript-comment">/*
			 * Case C1: Entry moving upwards and a part/full hole lies within the bounds of the entry.
			 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_end &lt;= new_entry-&gt;vme_end) {

				vm_map_delete_hole(map, hole_entry);
			} <span class="enscript-keyword">else</span> {
				hole_entry-&gt;vme_start = new_entry-&gt;vme_end;
				SAVE_HINT_HOLE_WRITE(map, (<span class="enscript-type">struct</span> vm_map_links*) hole_entry);
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-keyword">if</span> (check_map_with_hole_sanity)
				check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			<span class="enscript-keyword">return</span>;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((new_entry-&gt;vme_start &lt; hole_entry-&gt;vme_end) &amp;&amp; (hole_entry-&gt;vme_end &lt;= new_entry-&gt;vme_end)) {

			<span class="enscript-comment">/*
			 * Case C2: Entry moving downwards and a part/full hole lies within the bounds of the entry.
			 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			copy_hole_info(hole_entry, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			<span class="enscript-keyword">if</span> (hole_entry-&gt;vme_start &gt;= new_entry-&gt;vme_start) {
				vm_map_delete_hole(map, hole_entry);
			} <span class="enscript-keyword">else</span> {
				hole_entry-&gt;vme_end = new_entry-&gt;vme_start;
				SAVE_HINT_HOLE_WRITE(map, (<span class="enscript-type">struct</span> vm_map_links*) hole_entry);
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-keyword">if</span> (check_map_with_hole_sanity)
				check_map_sanity(map, &amp;old_hole_entry);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

			<span class="enscript-keyword">return</span>;
		}

		hole_entry = next_hole_entry;
		next_hole_entry = hole_entry-&gt;vme_next;

		<span class="enscript-keyword">if</span> (hole_entry == (vm_map_entry_t)map-&gt;holes_list)
			<span class="enscript-keyword">break</span>;
	}

	panic(<span class="enscript-string">&quot;Illegal action: h1: %p, s:0x%llx, e:0x%llx...h2:%p, s:0x%llx, e:0x%llx...h3:0x%p, s:0x%llx, e:0x%llx\n&quot;</span>,
		hole_entry-&gt;vme_prev,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_prev-&gt;vme_start,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_prev-&gt;vme_end,
		hole_entry,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_start,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_end,
		hole_entry-&gt;vme_next,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_next-&gt;vme_start,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)hole_entry-&gt;vme_next-&gt;vme_end);

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">update_first_free_rb</span>(vm_map_t map, vm_map_entry_t entry, boolean_t new_entry_creation)
{

	<span class="enscript-keyword">if</span> (map-&gt;holelistenabled) {

		<span class="enscript-comment">/*
		 * Holes can be used to track ranges all the way up to MACH_VM_MAX_ADDRESS or more (e.g. kernel map).
		 */</span>
		vm_map_offset_t max_valid_offset = (map-&gt;max_offset &gt; MACH_VM_MAX_ADDRESS) ? map-&gt;max_offset : MACH_VM_MAX_ADDRESS;

		<span class="enscript-comment">/*
		 * Clipping an entry will not result in the creation/deletion/modification of
		 * a hole. Those calls pass NULL for their target entry.
		 */</span>
		<span class="enscript-keyword">if</span> (entry == NULL) {
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * Commpage is pinned beyond the map's max offset. That shouldn't affect the
		 * holes within the bounds of the map.
		 */</span>
		<span class="enscript-keyword">if</span> (vm_map_trunc_page(entry-&gt;vme_start, VM_MAP_PAGE_MASK(map)) &gt;= max_valid_offset) {
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 *
		 * Note:
		 *
		 * - A new entry has already been added to the map
		 * OR
		 * - An older entry has already been deleted from the map
		 *
		 * We are updating the hole list after the fact (except in one special case involving copy maps).
		 *
		 */</span>

		<span class="enscript-keyword">if</span> (new_entry_creation) {

			update_holes_on_entry_creation(map, entry);
		} <span class="enscript-keyword">else</span> {

			update_holes_on_entry_deletion(map, entry);
		}
	}
}
</pre>
<hr />
</body></html>