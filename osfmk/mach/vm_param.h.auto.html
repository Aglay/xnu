<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_param.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_param.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	mach/vm_param.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Machine independent virtual memory parameters.
 *
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_MACH_VM_PARAM_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_MACH_VM_PARAM_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_param.h&gt;</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">KERNEL</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">ASSEMBLER</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_types.h&gt;</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ASSEMBLER */</span>

<span class="enscript-comment">/*
 *	The machine independent pages are refered to as PAGES.  A page
 *	is some number of hardware pages, depending on the target machine.
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">ASSEMBLER</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAGE_SIZE_64</span> (unsigned long long)PAGE_SIZE		<span class="enscript-comment">/* pagesize in addr units */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAGE_MASK_64</span> (unsigned long long)PAGE_MASK		<span class="enscript-comment">/* mask for off in page */</span>

<span class="enscript-comment">/*
 *	Convert addresses to pages and vice versa.  No rounding is used.
 *      The atop_32 and ptoa_32 macros should not be use on 64 bit types.
 *      The round_page_64 and trunc_page_64 macros should be used instead.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop_32</span>(x) ((uint32_t)(x) &gt;&gt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa_32</span>(x) ((uint32_t)(x) &lt;&lt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop_64</span>(x) ((uint64_t)(x) &gt;&gt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa_64</span>(x) ((uint64_t)(x) &lt;&lt; PAGE_SHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop_kernel</span>(x) ((vm_address_t)(x) &gt;&gt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa_kernel</span>(x) ((vm_address_t)(x) &lt;&lt; PAGE_SHIFT)

<span class="enscript-comment">/*
 *      While the following block is enabled, the legacy atop and ptoa
 *      macros will behave correctly.  If not, they will generate
 *      invalid lvalue errors.
 */</span>

#<span class="enscript-reference">if</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop</span>(x)	((vm_address_t)(x) &gt;&gt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa</span>(x)	((vm_address_t)(x) &lt;&lt; PAGE_SHIFT)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop</span>(x) (0UL = 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa</span>(x) (0UL = 0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Page-size rounding macros for the Public fixed-width VM types.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mach_vm_round_page</span>(x) (((mach_vm_offset_t)(x) + PAGE_MASK) &amp; ~((signed)PAGE_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mach_vm_trunc_page</span>(x) ((mach_vm_offset_t)(x) &amp; ~((signed)PAGE_MASK))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">memory_object_round_page</span>(x) (((memory_object_offset_t)(x) + PAGE_MASK) &amp; ~((signed)PAGE_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">memory_object_trunc_page</span>(x) ((memory_object_offset_t)(x) &amp; ~((signed)PAGE_MASK))

<span class="enscript-comment">/*
 *	Rounding macros for the legacy (scalable with the current task's
 *	address space size) VM types.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_page</span>(x) (((vm_offset_t)(x) + PAGE_MASK) &amp; ~((vm_offset_t)PAGE_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_page</span>(x) ((vm_offset_t)(x) &amp; ~((vm_offset_t)PAGE_MASK))

<span class="enscript-comment">/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.  The round_page_32 and trunc_page_32 macros should not be
 *      use on 64 bit types.  The round_page_64 and trunc_page_64 macros
 *      should be used instead.
 *
 *	These should only be used in the rare case the size of the address
 *	or length is hard-coded as 32 or 64 bit.  Otherwise, the macros
 *	associated with the specific VM type should be used.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_page_32</span>(x) (((uint32_t)(x) + PAGE_MASK) &amp; ~((uint32_t)PAGE_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_page_32</span>(x) ((uint32_t)(x) &amp; ~((uint32_t)PAGE_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_page_64</span>(x) (((uint64_t)(x) + PAGE_MASK_64) &amp; ~((uint64_t)PAGE_MASK_64))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_page_64</span>(x) ((uint64_t)(x) &amp; ~((uint64_t)PAGE_MASK_64))

<span class="enscript-comment">/*
 *      Enable the following block to find uses of xxx_32 macros that should
 *      be xxx_64.  These macros only work in C code, not C++.  The resulting
 *      binaries are not functional.  Look for invalid lvalue errors in
 *      the compiler output.
 *
 *      Enabling the following block will also find use of the xxx_64 macros
 *      that have been passed pointers.  The parameters should be case to an
 *      unsigned long type first.  Look for invalid operands to binary + error
 *      in the compiler output.
 */</span>

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">atop_32</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ptoa_32</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">round_page_32</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">trunc_page_32</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">atop_64</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ptoa_64</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">round_page_64</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">trunc_page_64</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__cplusplus</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop_32</span>(x) \
    (__builtin_choose_expr (<span class="enscript-keyword">sizeof</span>(x) != <span class="enscript-keyword">sizeof</span>(uint64_t), \
        (*(<span class="enscript-type">long</span> *)0), \
        (0UL)) = 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa_32</span>(x) \
    (__builtin_choose_expr (<span class="enscript-keyword">sizeof</span>(x) != <span class="enscript-keyword">sizeof</span>(uint64_t), \
        (*(<span class="enscript-type">long</span> *)0), \
        (0UL)) = 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_page_32</span>(x) \
    (__builtin_choose_expr (<span class="enscript-keyword">sizeof</span>(x) != <span class="enscript-keyword">sizeof</span>(uint64_t), \
        (*(<span class="enscript-type">long</span> *)0), \
        (0UL)) = 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_page_32</span>(x) \
    (__builtin_choose_expr (<span class="enscript-keyword">sizeof</span>(x) != <span class="enscript-keyword">sizeof</span>(uint64_t), \
        (*(<span class="enscript-type">long</span> *)0), \
        (0UL)) = 0)
#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop_32</span>(x) (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa_32</span>(x) (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_page_32</span>(x) (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_page_32</span>(x) (0)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! __cplusplus */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">atop_64</span>(x) ((uint64_t)((x) + (uint8_t *)0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptoa_64</span>(x) ((uint64_t)((x) + (uint8_t *)0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_page_64</span>(x) ((uint64_t)((x) + (uint8_t *)0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_page_64</span>(x) ((uint64_t)((x) + (uint8_t *)0))

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Determine whether an address is page-aligned, or a count is
 *	an exact page multiple.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">page_aligned</span>(x)	(((x) &amp; PAGE_MASK) == 0)

<span class="enscript-type">extern</span> vm_size_t	mem_size;		<span class="enscript-comment">/* 32-bit size of memory - limited by maxmem - deprecated */</span>
<span class="enscript-type">extern</span> uint64_t		max_mem;		<span class="enscript-comment">/* 64-bit size of memory - limited by maxmem */</span>

<span class="enscript-comment">/*
 * The default pager does not handle 64-bit offsets inside its objects,
 * so this limits the size of anonymous memory objects to 4GB minus 1 page.
 * When we need to allocate a chunk of anonymous memory over that size,
 * we have to allocate more than one chunk.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ANON_MAX_SIZE</span>	0xFFFFF000ULL
<span class="enscript-comment">/*
 * Work-around for &lt;rdar://problem/6626493&gt;
 * Break large anonymous memory areas into 128MB chunks to alleviate
 * the cost of copying when copy-on-write is not possible because a small
 * portion of it being wired.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ANON_CHUNK_SIZE</span>	(128ULL * 1024 * 1024) <span class="enscript-comment">/* 128MB */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>

<span class="enscript-type">extern</span> uint64_t		mem_actual;		<span class="enscript-comment">/* 64-bit size of memory - not limited by maxmem */</span>
<span class="enscript-type">extern</span> uint64_t		sane_size;		<span class="enscript-comment">/* Memory size to use for defaults calculations */</span>
<span class="enscript-type">extern</span> addr64_t 	vm_last_addr;	<span class="enscript-comment">/* Highest kernel virtual address known to the VM system */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> vm_offset_t	vm_min_kernel_address;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> vm_offset_t	vm_max_kernel_address;

<span class="enscript-type">extern</span> vm_offset_t		vm_kernel_stext;
<span class="enscript-type">extern</span> vm_offset_t		vm_kernel_etext;
<span class="enscript-type">extern</span> vm_offset_t		vm_kernel_base;
<span class="enscript-type">extern</span> vm_offset_t		vm_kernel_top;
<span class="enscript-type">extern</span> vm_offset_t		vm_kernel_slide;
<span class="enscript-type">extern</span> vm_offset_t		vm_hib_base;
<span class="enscript-type">extern</span> vm_offset_t		vm_kernel_addrperm;

<span class="enscript-type">extern</span> vm_offset_t		vm_kext_base;
<span class="enscript-type">extern</span> vm_offset_t		vm_kext_top;
<span class="enscript-type">extern</span> vm_offset_t      vm_prelink_stext;
<span class="enscript-type">extern</span> vm_offset_t      vm_prelink_etext;
<span class="enscript-type">extern</span> vm_offset_t      vm_prelink_sinfo;
<span class="enscript-type">extern</span> vm_offset_t      vm_prelink_einfo;
<span class="enscript-type">extern</span> vm_offset_t      vm_slinkedit;
<span class="enscript-type">extern</span> vm_offset_t      vm_elinkedit;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_IS_SLID</span>(_o)						       \
		(((vm_offset_t)(_o) &gt;= vm_kernel_base) &amp;&amp;		       \
		 ((vm_offset_t)(_o) &lt;=  vm_kernel_top))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_IS_KEXT</span>(_o)      \
                (((vm_offset_t)(_o) &gt;= vm_kext_base) &amp;&amp;   \
                 ((vm_offset_t)(_o) &lt;  vm_kext_top))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_IS_PRELINKTEXT</span>(_o)        \
        (((vm_offset_t)(_o) &gt;= vm_prelink_stext) &amp;&amp;     \
        ((vm_offset_t)(_o) &lt;  vm_prelink_etext))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_IS_PRELINKINFO</span>(_o)        \
    (((vm_offset_t)(_o) &gt;= vm_prelink_sinfo) &amp;&amp;     \
    ((vm_offset_t)(_o) &lt;  vm_prelink_einfo))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_IS_KEXT_LINKEDIT</span>(_o)        \
    (((vm_offset_t)(_o) &gt;= vm_slinkedit) &amp;&amp;     \
    ((vm_offset_t)(_o) &lt;  vm_elinkedit))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_SLIDE</span>(_u)						       \
		((vm_offset_t)(_u) + vm_kernel_slide)

<span class="enscript-comment">/*
 * The following macros are to be used when exposing kernel addresses to
 * userspace via any of the various debug or info facilities that might exist
 * (e.g. stackshot, proc_info syscall, etc.). It is important to understand
 * the goal of each macro and choose the right one depending on what you are
 * trying to do. Misuse of these macros can result in critical data leaks
 * which in turn lead to all sorts of system vulnerabilities.
 *
 * Note that in general the ideal goal is to protect addresses from userspace
 * in a way that is reversible assuming you know the permutation and/or slide.
 *
 * The macros are as follows:
 * 
 * VM_KERNEL_UNSLIDE:
 *     Use this macro when you are exposing an address to userspace which is
 *     a &quot;static&quot; kernel or kext address (i.e. coming from text or data
 *     sections). These are the addresses which get &quot;slid&quot; via ASLR on kernel
 *     or kext load, and it's precisely the slide value we are trying to
 *     protect from userspace.
 *
 * VM_KERNEL_ADDRPERM:
 *     Use this macro when you are exposing an address to userspace which is
 *     coming from the kernel's &quot;heap&quot;. Since these adresses are not &quot;loaded&quot;
 *     from anywhere, there is no slide applied and we instead apply the
 *     permutation value to obscure the address.
 *
 * VM_KERNEL_UNSLIDE_OR_ADDRPERM:
 *     Use this macro when you are exposing an address to userspace that could
 *     come from either kernel text/data *or* the heap. This is a rare case,
 *     but one that does come up and must be handled correctly.
 *
 * Nesting of these macros should be considered invalid.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_UNSLIDE</span>(_v)						       \
		((VM_KERNEL_IS_SLID(_v) ||				       \
		  VM_KERNEL_IS_KEXT(_v) ||      \
          VM_KERNEL_IS_PRELINKTEXT(_v) ||   \
          VM_KERNEL_IS_PRELINKINFO(_v) ||   \
          VM_KERNEL_IS_KEXT_LINKEDIT(_v)) ?      \
			(vm_offset_t)(_v) - vm_kernel_slide :    \
			(vm_offset_t)(_v))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_KERNEL_ADDRPERM</span>(_v)						       \
		(((vm_offset_t)(_v) == 0) ?				       \
			(vm_offset_t)(0) :				       \
			(vm_offset_t)(_v) + vm_kernel_addrperm)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_KERNEL_UNSLIDE_OR_PERM</span>(_v)					       \
		((VM_KERNEL_IS_SLID(_v) ||				       \
          VM_KERNEL_IS_KEXT(_v) ||      \
          VM_KERNEL_IS_PRELINKTEXT(_v) ||   \
          VM_KERNEL_IS_PRELINKINFO(_v) ||   \
          VM_KERNEL_IS_KEXT_LINKEDIT(_v)) ?         \
			(vm_offset_t)(_v) - vm_kernel_slide :    \
			VM_KERNEL_ADDRPERM(_v))
	

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-type">extern</span> vm_size_t	page_size;
<span class="enscript-type">extern</span> vm_size_t	page_mask;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		page_shift;

<span class="enscript-comment">/* We need a way to get rid of compiler warnings when we cast from   */</span>
<span class="enscript-comment">/* a 64 bit value to an address (which may be 32 bits or 64-bits).   */</span>
<span class="enscript-comment">/* An intptr_t is used convert the value to the right precision, and */</span>
<span class="enscript-comment">/* then to an address. This macro is also used to convert addresses  */</span>
<span class="enscript-comment">/* to 32-bit integers, which is a hard failure for a 64-bit kernel   */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__CAST_DOWN_CHECK</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__CAST_DOWN_CHECK</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAST_DOWN</span>( type, addr ) \
    ( ((type)((uintptr_t) (addr)/(<span class="enscript-keyword">sizeof</span>(type) &lt; <span class="enscript-keyword">sizeof</span>(uintptr_t) ? 0 : 1))) )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAST_DOWN_EXPLICIT</span>( type, addr )  ( ((type)((uintptr_t) (addr))) ) 

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __CAST_DOWN_CHECK */</span>

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ASSEMBLER */</span>

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _MACH_VM_PARAM_H_ */</span>
</pre>
<hr />
</body></html>