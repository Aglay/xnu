<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kdp_core.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kdp_core.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_KDP_INTERACTIVE_DEBUGGING</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_attributes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libsa/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/zlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_core.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPolledInterface.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msgbuf.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/ml/i386/kdp_x86_common.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>



<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*pmap_traverse_callback)(vm_map_offset_t start,
				      vm_map_offset_t end,
				      <span class="enscript-type">void</span> *context);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pmap_traverse_present_mappings</span>(pmap_t pmap,
					  vm_map_offset_t start,
					  vm_map_offset_t end,
					  pmap_traverse_callback callback,
					  <span class="enscript-type">void</span> *context);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump_pmap_traverse_preflight_callback</span>(vm_map_offset_t start,
					       vm_map_offset_t end,
					       <span class="enscript-type">void</span> *context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump_pmap_traverse_send_seg_callback</span>(vm_map_offset_t start,
					      vm_map_offset_t end,
					      <span class="enscript-type">void</span> *context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump_pmap_traverse_send_segdata_callback</span>(vm_map_offset_t start,
						  vm_map_offset_t end,
						  <span class="enscript-type">void</span> *context);

<span class="enscript-type">struct</span> kdp_core_out_vars;
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*kern_dump_output_proc)(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> request, <span class="enscript-type">char</span> *corename, 
    			             uint64_t length, <span class="enscript-type">void</span> *panic_data);

<span class="enscript-type">struct</span> kdp_core_out_vars
{
     kern_dump_output_proc outproc;
     z_output_func	   zoutput;
     size_t                zipped;
     uint64_t              totalbytes;
     uint64_t              lastpercent;
     IOReturn              error;
     <span class="enscript-type">unsigned</span>              outremain;
     <span class="enscript-type">unsigned</span>              outlen;
     <span class="enscript-type">unsigned</span>              writes;
     Bytef *               outbuf;
};

<span class="enscript-type">struct</span> kern_dump_preflight_context
{
    uint32_t region_count;
    uint64_t dumpable_bytes;
};

<span class="enscript-type">struct</span> kern_dump_send_context
{
    <span class="enscript-type">struct</span> kdp_core_out_vars * outvars;
    uint64_t hoffset;
    uint64_t foffset;
    uint64_t header_size;
    uint64_t dumpable_bytes;
    uint32_t region_count;
};

<span class="enscript-type">extern</span> uint32_t kdp_crashdump_pkt_size;

<span class="enscript-type">static</span> vm_offset_t kdp_core_zmem;
<span class="enscript-type">static</span> size_t      kdp_core_zsize;
<span class="enscript-type">static</span> size_t      kdp_core_zoffset;
<span class="enscript-type">static</span> z_stream	   kdp_core_zs;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBG</span>	kdb_printf

boolean_t <span class="enscript-function-name">kdp_has_polled_corefile</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (NULL != gIOPolledCoreFileVars);
}

<span class="enscript-type">static</span> IOReturn 
<span class="enscript-function-name">kern_dump_disk_proc</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> request, __unused <span class="enscript-type">char</span> *corename, 
		    uint64_t length, <span class="enscript-type">void</span> * data)
{
    uint64_t        noffset;
    uint32_t        err = kIOReturnSuccess;

    <span class="enscript-keyword">switch</span> (request) 
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">KDP_WRQ</span>:
	    err = IOPolledFileSeek(gIOPolledCoreFileVars, 0);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">break</span>;
	    err = IOPolledFilePollersOpen(gIOPolledCoreFileVars, kIOPolledBeforeSleepState, false);
	    <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">KDP_SEEK</span>:
	    noffset = *((uint64_t *) data);
	    err = IOPolledFileWrite(gIOPolledCoreFileVars, 0, 0, NULL);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">break</span>;
	    err = IOPolledFileSeek(gIOPolledCoreFileVars, noffset);
	    <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">KDP_DATA</span>:
	    err = IOPolledFileWrite(gIOPolledCoreFileVars, data, length, NULL);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">KDP_EOF</span>:
	    err = IOPolledFileWrite(gIOPolledCoreFileVars, 0, 0, NULL);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">break</span>;
	    err = IOPolledFilePollersClose(gIOPolledCoreFileVars, kIOPolledBeforeSleepState);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_core_zoutput</span>(z_streamp strm, Bytef *buf, <span class="enscript-type">unsigned</span> len)
{
    <span class="enscript-type">struct</span> kdp_core_out_vars * vars = (typeof(vars)) strm-&gt;opaque;
    IOReturn                   ret;

    vars-&gt;zipped += len;

    <span class="enscript-keyword">if</span> (vars-&gt;error &gt;= 0)
    {
	<span class="enscript-keyword">if</span> ((ret = (*vars-&gt;outproc)(KDP_DATA, NULL, len, buf)) != kIOReturnSuccess)
	{ 
	    DEBG(<span class="enscript-string">&quot;KDP_DATA(0x%x)\n&quot;</span>, ret);
	    vars-&gt;error = ret;
	}
	<span class="enscript-keyword">if</span> (!buf &amp;&amp; !len) DEBG(<span class="enscript-string">&quot;100..&quot;</span>);
    }
    <span class="enscript-keyword">return</span> (len);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_core_zoutputbuf</span>(z_streamp strm, Bytef *inbuf, <span class="enscript-type">unsigned</span> inlen)
{
    <span class="enscript-type">struct</span> kdp_core_out_vars * vars = (typeof(vars)) strm-&gt;opaque;
    <span class="enscript-type">unsigned</span> remain;
    IOReturn ret;
    <span class="enscript-type">unsigned</span> chunk;
    boolean_t flush;

    remain = inlen;
    vars-&gt;zipped += inlen;
    flush = (!inbuf &amp;&amp; !inlen);

    <span class="enscript-keyword">while</span> ((vars-&gt;error &gt;= 0) &amp;&amp; (remain || flush))
    {
	chunk = vars-&gt;outremain;
	<span class="enscript-keyword">if</span> (chunk &gt; remain) chunk = remain;
	bcopy(inbuf, &amp;vars-&gt;outbuf[vars-&gt;outlen - vars-&gt;outremain], chunk);
	vars-&gt;outremain -= chunk;
	remain          -= chunk;
	inbuf           += chunk;
	
	<span class="enscript-keyword">if</span> (vars-&gt;outremain &amp;&amp; !flush) <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">if</span> ((ret = (*vars-&gt;outproc)(KDP_DATA, NULL, 
					vars-&gt;outlen - vars-&gt;outremain, 
					vars-&gt;outbuf)) != kIOReturnSuccess)
	{ 
	    DEBG(<span class="enscript-string">&quot;KDP_DATA(0x%x)\n&quot;</span>, ret);
	    vars-&gt;error = ret;
	}
	<span class="enscript-keyword">if</span> (flush)
	{
	    DEBG(<span class="enscript-string">&quot;100..&quot;</span>);
	    flush = false;
	}
	vars-&gt;outremain = vars-&gt;outlen;
    }
    <span class="enscript-keyword">return</span> (inlen);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_core_zinput</span>(z_streamp strm, Bytef *buf, <span class="enscript-type">unsigned</span> size)
{
    <span class="enscript-type">struct</span> kdp_core_out_vars * vars = (typeof(vars)) strm-&gt;opaque;
    uint64_t                   percent;
    <span class="enscript-type">unsigned</span>                   len;

    len = strm-&gt;avail_in;
    <span class="enscript-keyword">if</span> (len &gt; size) len = size;
    <span class="enscript-keyword">if</span> (len == 0) <span class="enscript-keyword">return</span> 0;

    <span class="enscript-keyword">if</span> (strm-&gt;next_in != (Bytef *) strm) memcpy(buf, strm-&gt;next_in, len);
    <span class="enscript-keyword">else</span>		                 bzero(buf, len);
    strm-&gt;adler = z_crc32(strm-&gt;adler, buf, len);

    strm-&gt;avail_in -= len;
    strm-&gt;next_in  += len;
    strm-&gt;total_in += len;

    <span class="enscript-keyword">if</span> (0 == (511 &amp; vars-&gt;writes++))
    {
	percent = (strm-&gt;total_in * 100) / vars-&gt;totalbytes;
	<span class="enscript-keyword">if</span> ((percent - vars-&gt;lastpercent) &gt;= 10)
	{
	    vars-&gt;lastpercent = percent;
	    DEBG(<span class="enscript-string">&quot;%lld..&quot;</span>, percent);
	}
    }

    <span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)len;
}

<span class="enscript-type">static</span> IOReturn
<span class="enscript-function-name">kdp_core_stream_output</span>(<span class="enscript-type">struct</span> kdp_core_out_vars * vars, uint64_t length, <span class="enscript-type">void</span> * data)
{
    z_stream * zs;
    <span class="enscript-type">int</span>        zr;
    boolean_t  flush;

    flush = (!length &amp;&amp; !data);
    zr = Z_OK;

    zs = &amp;kdp_core_zs;
    assert(!zs-&gt;avail_in);

    <span class="enscript-keyword">while</span> (vars-&gt;error &gt;= 0)
    {
	<span class="enscript-keyword">if</span> (!zs-&gt;avail_in &amp;&amp; !flush)
	{
	    <span class="enscript-keyword">if</span> (!length) <span class="enscript-keyword">break</span>;
	    zs-&gt;next_in = data ? data : (Bytef *) zs <span class="enscript-comment">/* zero marker */</span>;
	    zs-&gt;avail_in = (uInt)length;
	    length = 0;
	}
	<span class="enscript-keyword">if</span> (!zs-&gt;avail_out)
	{
	    zs-&gt;next_out  = (Bytef *) zs;
	    zs-&gt;avail_out = UINT32_MAX;
	}
	zr = deflate(zs, flush ? Z_FINISH : Z_NO_FLUSH);
	<span class="enscript-keyword">if</span> (Z_STREAM_END == zr) <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">if</span> (zr != Z_OK) 
	{
	    DEBG(<span class="enscript-string">&quot;ZERR %d\n&quot;</span>, zr);
	    vars-&gt;error = zr;
	}
    }

    <span class="enscript-keyword">if</span> (flush) (*vars-&gt;zoutput)(zs, NULL, 0);

    <span class="enscript-keyword">return</span> (vars-&gt;error);
}

<span class="enscript-type">extern</span> vm_offset_t c_buffers;
<span class="enscript-type">extern</span> vm_size_t   c_buffers_size;

ppnum_t
<span class="enscript-function-name">kernel_pmap_present_mapping</span>(uint64_t vaddr, uint64_t * pvincr)
{
    ppnum_t ppn;
    uint64_t vincr;
    vincr = PAGE_SIZE_64;

    assert(!(vaddr &amp; PAGE_MASK_64));

    <span class="enscript-comment">/* VA ranges to exclude */</span>
    <span class="enscript-keyword">if</span> (vaddr == c_buffers)
    {
	<span class="enscript-comment">/* compressor data */</span>
	ppn = 0;
	vincr = c_buffers_size;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vaddr == kdp_core_zmem)
    {
	<span class="enscript-comment">/* zlib working memory */</span>
	ppn = 0;
	vincr = kdp_core_zsize;
    }
    <span class="enscript-keyword">else</span>
    ppn = pmap_find_phys(kernel_pmap, vaddr);

    *pvincr = vincr;
    <span class="enscript-keyword">return</span> (ppn);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pmap_traverse_present_mappings</span>(pmap_t __unused pmap,
				   vm_map_offset_t start,
				   vm_map_offset_t end,
				   pmap_traverse_callback callback,
				   <span class="enscript-type">void</span> *context)
{
    IOReturn        ret;
    vm_map_offset_t vcurstart, vcur;
    uint64_t        vincr;
    vm_map_offset_t debug_start;
    vm_map_offset_t debug_end;
    boolean_t       lastvavalid;

    debug_start = trunc_page((vm_map_offset_t) debug_buf_addr);
    debug_end   = round_page((vm_map_offset_t) (debug_buf_addr + debug_buf_size));

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    assert(!is_ept_pmap(pmap));
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">/* Assumes pmap is locked, or being called from the kernel debugger */</span>
    
    <span class="enscript-keyword">if</span> (start &gt; end) <span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

    ret = KERN_SUCCESS;
    lastvavalid = FALSE;
    <span class="enscript-keyword">for</span> (vcur = vcurstart = start; (ret == KERN_SUCCESS) &amp;&amp; (vcur &lt; end); ) {
	ppnum_t ppn;

	ppn = kernel_pmap_present_mapping(vcur, &amp;vincr);
	<span class="enscript-keyword">if</span> (ppn != 0)
	{
	    <span class="enscript-keyword">if</span> (((vcur &lt; debug_start) || (vcur &gt;= debug_end))
	    	&amp;&amp; !pmap_valid_page(ppn))
	    {
		<span class="enscript-comment">/* not something we want */</span>
		ppn = 0;
	    }
	}

	<span class="enscript-keyword">if</span> (ppn != 0) {
	    <span class="enscript-keyword">if</span> (!lastvavalid) {
		<span class="enscript-comment">/* Start of a new virtual region */</span>
		vcurstart = vcur;
		lastvavalid = TRUE;
	    }
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-keyword">if</span> (lastvavalid) {
		<span class="enscript-comment">/* end of a virtual region */</span>
		ret = callback(vcurstart, vcur, context);
		lastvavalid = FALSE;
	    }

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	    <span class="enscript-comment">/* Try to skip by 2MB if possible */</span>
	    <span class="enscript-keyword">if</span> (((vcur &amp; PDMASK) == 0) &amp;&amp; cpu_64bit) {
		pd_entry_t *pde;
		pde = pmap_pde(pmap, vcur);
		<span class="enscript-keyword">if</span> (0 == pde || ((*pde &amp; INTEL_PTE_VALID) == 0)) {
		    <span class="enscript-comment">/* Make sure we wouldn't overflow */</span>
		    <span class="enscript-keyword">if</span> (vcur &lt; (end - NBPD)) {
			vincr = NBPD;
		    }
		}
	    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>
	}
	vcur += vincr;
    }
    
    <span class="enscript-keyword">if</span> ((ret == KERN_SUCCESS) &amp;&amp; lastvavalid) {
	<span class="enscript-comment">/* send previous run */</span>
	ret = callback(vcurstart, vcur, context);
    }
    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump_pmap_traverse_preflight_callback</span>(vm_map_offset_t start,
					   vm_map_offset_t end,
					   <span class="enscript-type">void</span> *context)
{
    <span class="enscript-type">struct</span> kern_dump_preflight_context *kdc = (<span class="enscript-type">struct</span> kern_dump_preflight_context *)context;
    IOReturn ret = KERN_SUCCESS;

    kdc-&gt;region_count++;
    kdc-&gt;dumpable_bytes += (end - start);

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump_pmap_traverse_send_seg_callback</span>(vm_map_offset_t start,
					  vm_map_offset_t end,
					  <span class="enscript-type">void</span> *context)
{
    <span class="enscript-type">struct</span> kern_dump_send_context *kdc = (<span class="enscript-type">struct</span> kern_dump_send_context *)context;
    IOReturn ret = KERN_SUCCESS;
    kernel_segment_command_t sc;
    vm_size_t size = (vm_size_t)(end - start);

    <span class="enscript-keyword">if</span> (kdc-&gt;hoffset + <span class="enscript-keyword">sizeof</span>(sc) &gt; kdc-&gt;header_size) {
	<span class="enscript-keyword">return</span> (KERN_NO_SPACE);
    }

    kdc-&gt;region_count++;
    kdc-&gt;dumpable_bytes += (end - start);

    <span class="enscript-comment">/*
     *	Fill in segment command structure.
     */</span>

    sc.cmd = LC_SEGMENT_KERNEL;
    sc.cmdsize = <span class="enscript-keyword">sizeof</span>(kernel_segment_command_t);
    sc.segname[0] = 0;
    sc.vmaddr = (vm_address_t)start;
    sc.vmsize = size;
    sc.fileoff = (vm_address_t)kdc-&gt;foffset;
    sc.filesize = size;
    sc.maxprot = VM_PROT_READ;
    sc.initprot = VM_PROT_READ;
    sc.nsects = 0;
    sc.flags = 0;

    <span class="enscript-keyword">if</span> ((ret = kdp_core_stream_output(kdc-&gt;outvars, <span class="enscript-keyword">sizeof</span>(kernel_segment_command_t), (caddr_t) &amp;sc)) != kIOReturnSuccess) {
	DEBG(<span class="enscript-string">&quot;kdp_core_stream_output(0x%x)\n&quot;</span>, ret);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    kdc-&gt;hoffset += <span class="enscript-keyword">sizeof</span>(kernel_segment_command_t);
    kdc-&gt;foffset += size;

<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> (ret);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump_pmap_traverse_send_segdata_callback</span>(vm_map_offset_t start,
					      vm_map_offset_t end,
					      <span class="enscript-type">void</span> *context)
{
    <span class="enscript-type">struct</span> kern_dump_send_context *kdc = (<span class="enscript-type">struct</span> kern_dump_send_context *)context;
    <span class="enscript-type">int</span> ret = KERN_SUCCESS;
    vm_size_t size = (vm_size_t)(end - start);

    kdc-&gt;region_count++;
    kdc-&gt;dumpable_bytes += size;
    <span class="enscript-keyword">if</span> ((ret = kdp_core_stream_output(kdc-&gt;outvars, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)size, (caddr_t)(uintptr_t)start)) != kIOReturnSuccess)	{
	DEBG(<span class="enscript-string">&quot;kdp_core_stream_output(0x%x)\n&quot;</span>, ret);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    kdc-&gt;foffset += size;

<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_kern_dump</span>(kern_dump_output_proc outproc, bool local)
{
    <span class="enscript-type">struct</span> kern_dump_preflight_context kdc_preflight;
    <span class="enscript-type">struct</span> kern_dump_send_context      kdc_sendseg;
    <span class="enscript-type">struct</span> kern_dump_send_context      kdc_send;
    <span class="enscript-type">struct</span> kdp_core_out_vars           outvars;
    <span class="enscript-type">struct</span> mach_core_fileheader         hdr;
    kernel_mach_header_t mh;
    uint32_t	         segment_count, tstate_count;
    size_t		 command_size = 0, header_size = 0, tstate_size = 0;
    uint64_t	         hoffset, foffset;
    <span class="enscript-type">int</span>                  ret;
    <span class="enscript-type">char</span> *               log_start;
    uint64_t             log_length;
    uint64_t             new_logs;
    boolean_t            opened;

    opened     = false;
    log_start  = debug_buf_ptr;
    log_length = 0;
    <span class="enscript-keyword">if</span> (log_start &gt;= debug_buf_addr)
    {
	log_length = log_start - debug_buf_addr;
	<span class="enscript-keyword">if</span> (log_length &lt;= debug_buf_size) log_length = debug_buf_size - log_length;
	<span class="enscript-keyword">else</span> log_length = 0;
    }

    <span class="enscript-keyword">if</span> (local)
    {
	<span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_WRQ, NULL, 0, &amp;hoffset)) != kIOReturnSuccess) {
	    DEBG(<span class="enscript-string">&quot;KDP_WRQ(0x%x)\n&quot;</span>, ret);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    }
    opened = true;

    <span class="enscript-comment">// init gzip
</span>    bzero(&amp;outvars, <span class="enscript-keyword">sizeof</span>(outvars));
    bzero(&amp;hdr, <span class="enscript-keyword">sizeof</span>(hdr));
    outvars.outproc = outproc;
    kdp_core_zs.avail_in  = 0;
    kdp_core_zs.next_in   = NULL;
    kdp_core_zs.avail_out = 0;
    kdp_core_zs.next_out  = NULL;
    kdp_core_zs.opaque    = &amp;outvars;
    kdc_sendseg.outvars   = &amp;outvars;
    kdc_send.outvars      = &amp;outvars;

    <span class="enscript-keyword">if</span> (local)
    {
	outvars.outbuf      = NULL;
        outvars.outlen      = 0;
        outvars.outremain   = 0;
	outvars.zoutput     = kdp_core_zoutput;
    	<span class="enscript-comment">// space for file header &amp; log
</span>    	foffset = (4096 + log_length + 4095) &amp; ~4095ULL;
	hdr.log_offset = 4096;
	hdr.gzip_offset = foffset;
	<span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_SEEK, NULL, <span class="enscript-keyword">sizeof</span>(foffset), &amp;foffset)) != kIOReturnSuccess) { 
		DEBG(<span class="enscript-string">&quot;KDP_SEEK(0x%x)\n&quot;</span>, ret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} 
    }
    <span class="enscript-keyword">else</span>
    {
	outvars.outbuf    = (Bytef *) (kdp_core_zmem + kdp_core_zoffset);
	assert((kdp_core_zoffset + kdp_crashdump_pkt_size) &lt;= kdp_core_zsize);
        outvars.outlen    = kdp_crashdump_pkt_size;
        outvars.outremain = outvars.outlen;
	outvars.zoutput  = kdp_core_zoutputbuf;
    }

    deflateResetWithIO(&amp;kdp_core_zs, kdp_core_zinput, outvars.zoutput);


    kdc_preflight.region_count = 0;
    kdc_preflight.dumpable_bytes = 0;

    ret = pmap_traverse_present_mappings(kernel_pmap,
					 VM_MIN_KERNEL_AND_KEXT_ADDRESS,
					 VM_MAX_KERNEL_ADDRESS,
					 kern_dump_pmap_traverse_preflight_callback,
					 &amp;kdc_preflight);
    <span class="enscript-keyword">if</span> (ret)
    {
	DEBG(<span class="enscript-string">&quot;pmap traversal failed: %d\n&quot;</span>, ret);
	<span class="enscript-keyword">return</span> (ret);
    }

    outvars.totalbytes = kdc_preflight.dumpable_bytes;
    assert(outvars.totalbytes);
    segment_count = kdc_preflight.region_count;

    kern_collectth_state_size(&amp;tstate_count, &amp;tstate_size);

    command_size = segment_count * <span class="enscript-keyword">sizeof</span>(kernel_segment_command_t) + tstate_count * tstate_size;

    header_size = command_size + <span class="enscript-keyword">sizeof</span>(kernel_mach_header_t);

    <span class="enscript-comment">/*
     *	Set up Mach-O header for currently executing kernel.
     */</span>

    mh.magic = _mh_execute_header.magic;
    mh.cputype = _mh_execute_header.cputype;;
    mh.cpusubtype = _mh_execute_header.cpusubtype;
    mh.filetype = MH_CORE;
    mh.ncmds = segment_count + tstate_count;
    mh.sizeofcmds = (uint32_t)command_size;
    mh.flags = 0;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
    mh.reserved = 0;
#<span class="enscript-reference">endif</span>

    hoffset = 0;	                                <span class="enscript-comment">/* offset into header */</span>
    foffset = (uint64_t) round_page(header_size);	<span class="enscript-comment">/* offset into file */</span>

    <span class="enscript-comment">/* Transmit the Mach-O MH_CORE header, and segment and thread commands 
     */</span>
    <span class="enscript-keyword">if</span> ((ret = kdp_core_stream_output(&amp;outvars, <span class="enscript-keyword">sizeof</span>(kernel_mach_header_t), (caddr_t) &amp;mh) != kIOReturnSuccess))
    {
	DEBG(<span class="enscript-string">&quot;KDP_DATA(0x%x)\n&quot;</span>, ret);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    hoffset += <span class="enscript-keyword">sizeof</span>(kernel_mach_header_t);

    DEBG(<span class="enscript-string">&quot;%s&quot;</span>, local ? <span class="enscript-string">&quot;Writing local kernel core...&quot;</span> :
    	    	       <span class="enscript-string">&quot;Transmitting kernel state, please wait:\n&quot;</span>);

    kdc_sendseg.region_count   = 0;
    kdc_sendseg.dumpable_bytes = 0;
    kdc_sendseg.hoffset = hoffset;
    kdc_sendseg.foffset = foffset;
    kdc_sendseg.header_size = header_size;

    <span class="enscript-keyword">if</span> ((ret = pmap_traverse_present_mappings(kernel_pmap,
					 VM_MIN_KERNEL_AND_KEXT_ADDRESS,
					 VM_MAX_KERNEL_ADDRESS,
					 kern_dump_pmap_traverse_send_seg_callback,
					 &amp;kdc_sendseg)) != kIOReturnSuccess)
    {
	DEBG(<span class="enscript-string">&quot;pmap_traverse_present_mappings(0x%x)\n&quot;</span>, ret);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    hoffset = kdc_sendseg.hoffset;
    <span class="enscript-comment">/*
     * Now send out the LC_THREAD load command, with the thread information
     * for the current activation.
     */</span>

    <span class="enscript-keyword">if</span> (tstate_size &gt; 0)
    {
	<span class="enscript-type">void</span> * iter;
	<span class="enscript-type">char</span> tstate[tstate_size];
	iter = NULL;
	<span class="enscript-keyword">do</span> {
	    <span class="enscript-comment">/*
	     * Now send out the LC_THREAD load command, with the thread information
	     */</span>
	    kern_collectth_state (current_thread(), tstate, tstate_size, &amp;iter);

	    <span class="enscript-keyword">if</span> ((ret = kdp_core_stream_output(&amp;outvars, tstate_size, tstate)) != kIOReturnSuccess) {
		    DEBG(<span class="enscript-string">&quot;kdp_core_stream_output(0x%x)\n&quot;</span>, ret);
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	    }
	}
	<span class="enscript-keyword">while</span> (iter);
    }

    kdc_send.region_count   = 0;
    kdc_send.dumpable_bytes = 0;
    foffset = (uint64_t) round_page(header_size);	<span class="enscript-comment">/* offset into file */</span>
    kdc_send.foffset = foffset;
    kdc_send.hoffset = 0;
    foffset = round_page_64(header_size) - header_size;
    <span class="enscript-keyword">if</span> (foffset)
    {
	<span class="enscript-comment">// zero fill to page align
</span>	<span class="enscript-keyword">if</span> ((ret = kdp_core_stream_output(&amp;outvars, foffset, NULL)) != kIOReturnSuccess) {
		DEBG(<span class="enscript-string">&quot;kdp_core_stream_output(0x%x)\n&quot;</span>, ret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    }

    ret = pmap_traverse_present_mappings(kernel_pmap,
					 VM_MIN_KERNEL_AND_KEXT_ADDRESS,
					 VM_MAX_KERNEL_ADDRESS,
					 kern_dump_pmap_traverse_send_segdata_callback,
					 &amp;kdc_send);
    <span class="enscript-keyword">if</span> (ret) {
	DEBG(<span class="enscript-string">&quot;pmap_traverse_present_mappings(0x%x)\n&quot;</span>, ret);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-keyword">if</span> ((ret = kdp_core_stream_output(&amp;outvars, 0, NULL) != kIOReturnSuccess)) {
	DEBG(<span class="enscript-string">&quot;kdp_core_stream_output(0x%x)\n&quot;</span>, ret);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret) DEBG(<span class="enscript-string">&quot;success\n&quot;</span>);
    <span class="enscript-keyword">else</span>                         outvars.zipped = 0;

    DEBG(<span class="enscript-string">&quot;Mach-o header: %lu\n&quot;</span>, header_size);
    DEBG(<span class="enscript-string">&quot;Region counts: [%u, %u, %u]\n&quot;</span>, kdc_preflight.region_count,
					  kdc_sendseg.region_count, 
					  kdc_send.region_count);
    DEBG(<span class="enscript-string">&quot;Byte counts  : [%llu, %llu, %llu, %lu, %llu]\n&quot;</span>, kdc_preflight.dumpable_bytes, 
							   kdc_sendseg.dumpable_bytes, 
							   kdc_send.dumpable_bytes, 
							   outvars.zipped, log_length);
    <span class="enscript-keyword">if</span> (local &amp;&amp; opened)
    {
    	<span class="enscript-comment">// write debug log
</span>    	foffset = 4096;
	<span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_SEEK, NULL, <span class="enscript-keyword">sizeof</span>(foffset), &amp;foffset)) != kIOReturnSuccess) { 
	    DEBG(<span class="enscript-string">&quot;KDP_SEEK(0x%x)\n&quot;</span>, ret);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	} 

	new_logs = debug_buf_ptr - log_start;
	<span class="enscript-keyword">if</span> (new_logs &gt; log_length) new_logs = log_length;
    	
	<span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_DATA, NULL, new_logs, log_start)) != kIOReturnSuccess)
	{ 
	    DEBG(<span class="enscript-string">&quot;KDP_DATA(0x%x)\n&quot;</span>, ret);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	} 

    	<span class="enscript-comment">// write header
</span>
    	foffset = 0;
	<span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_SEEK, NULL, <span class="enscript-keyword">sizeof</span>(foffset), &amp;foffset)) != kIOReturnSuccess) { 
	    DEBG(<span class="enscript-string">&quot;KDP_SEEK(0x%x)\n&quot;</span>, ret);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	} 

	hdr.signature  = MACH_CORE_FILEHEADER_SIGNATURE;
	hdr.log_length = new_logs;
        hdr.gzip_length = outvars.zipped;

	<span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_DATA, NULL, <span class="enscript-keyword">sizeof</span>(hdr), &amp;hdr)) != kIOReturnSuccess)
	{ 
	    DEBG(<span class="enscript-string">&quot;KDP_DATA(0x%x)\n&quot;</span>, ret);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-comment">/* close / last packet */</span>
    <span class="enscript-keyword">if</span> ((ret = (*outproc)(KDP_EOF, NULL, 0, ((<span class="enscript-type">void</span> *) 0))) != kIOReturnSuccess)
    {
	DEBG(<span class="enscript-string">&quot;KDP_EOF(0x%x)\n&quot;</span>, ret);
    }	


    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kern_dump</span>(boolean_t local)
{
    <span class="enscript-type">static</span> boolean_t dumped_local;
    <span class="enscript-keyword">if</span> (local) {
	<span class="enscript-keyword">if</span> (dumped_local) <span class="enscript-keyword">return</span> (0);
	dumped_local = TRUE;
	<span class="enscript-keyword">return</span> (do_kern_dump(&amp;kern_dump_disk_proc, true));
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KDP_INTERACTIVE_DEBUGGING</span>
    <span class="enscript-keyword">return</span> (do_kern_dump(&amp;kdp_send_crashdump_data, false));
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> (-1);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">kdp_core_zalloc</span>(<span class="enscript-type">void</span> * __unused ref, u_int items, u_int size)
{
    <span class="enscript-type">void</span> * result;

    result = (<span class="enscript-type">void</span> *) (kdp_core_zmem + kdp_core_zoffset);
    kdp_core_zoffset += ~31L &amp; (31 + (items * size));    <span class="enscript-comment">// 32b align for vector crc
</span>    assert(kdp_core_zoffset &lt;= kdp_core_zsize);

    <span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_core_zfree</span>(<span class="enscript-type">void</span> * __unused ref, <span class="enscript-type">void</span> * __unused ptr) {}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LEVEL</span> Z_BEST_SPEED
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NETBUF</span> 1440

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_core_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> wbits = 12;
    <span class="enscript-type">int</span> memlevel = 3;
    kern_return_t kr;

    <span class="enscript-keyword">if</span> (kdp_core_zs.zalloc) <span class="enscript-keyword">return</span>;
    kdp_core_zsize = round_page(NETBUF + zlib_deflate_memory_size(wbits, memlevel));
    printf(<span class="enscript-string">&quot;kdp_core zlib memory 0x%lx\n&quot;</span>, kdp_core_zsize);
    kr = kmem_alloc(kernel_map, &amp;kdp_core_zmem, kdp_core_zsize, VM_KERN_MEMORY_DIAG);
    assert (KERN_SUCCESS == kr);

    kdp_core_zoffset = 0;
    kdp_core_zs.zalloc = kdp_core_zalloc;
    kdp_core_zs.zfree  = kdp_core_zfree;

    <span class="enscript-keyword">if</span> (deflateInit2(&amp;kdp_core_zs, LEVEL, Z_DEFLATED,
		     wbits + 16 <span class="enscript-comment">/*gzip mode*/</span>, memlevel, Z_DEFAULT_STRATEGY))
    {
	<span class="enscript-comment">/* Allocation failed */</span>
	bzero(&amp;kdp_core_zs, <span class="enscript-keyword">sizeof</span>(kdp_core_zs));
	kdp_core_zoffset = 0;
    }
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_KDP_INTERACTIVE_DEBUGGING */</span>
</pre>
<hr />
</body></html>