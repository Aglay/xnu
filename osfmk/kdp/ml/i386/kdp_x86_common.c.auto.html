<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kdp_x86_common.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kdp_x86_common.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_attributes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libsa/types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap_internal.h&gt;</span> <span class="enscript-comment">/* pmap_pde */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_core.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/ml/i386/kdp_x86_common.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>

<span class="enscript-comment">// #define KDP_VM_READ_DEBUG 1
</span><span class="enscript-comment">// #define KDP_VM_WRITE_DEBUG 1
</span>
<span class="enscript-comment">/*
 * A (potentially valid) physical address is not a kernel address
 * i.e. it'a a user address.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_PHYS_ADDR</span>(addr)		IS_USERADDR64_CANONICAL(addr)

boolean_t kdp_read_io;
boolean_t kdp_trans_off;

addr64_t <span class="enscript-function-name">kdp_vtophys</span>(pmap_t pmap, addr64_t va);

pmap_t kdp_pmap = 0;

addr64_t
<span class="enscript-function-name">kdp_vtophys</span>(
	pmap_t pmap,
	addr64_t va)
{
	addr64_t    pa;
	ppnum_t pp;

	pp = pmap_find_phys(pmap, va);
	<span class="enscript-keyword">if</span>(!pp) <span class="enscript-keyword">return</span> 0;
        
	pa = ((addr64_t)pp &lt;&lt; PAGE_SHIFT) | (va &amp; PAGE_MASK);

	<span class="enscript-keyword">return</span>(pa);
}

mach_vm_size_t
<span class="enscript-function-name">kdp_machine_vm_read</span>( mach_vm_address_t src, caddr_t dst, mach_vm_size_t len)
{
	addr64_t cur_virt_src = PAL_KDP_ADDR((addr64_t)src);
	addr64_t cur_virt_dst = PAL_KDP_ADDR((addr64_t)(intptr_t)dst);
	addr64_t cur_phys_dst, cur_phys_src;
	mach_vm_size_t resid = len;
	mach_vm_size_t cnt = 0, cnt_src, cnt_dst;
	pmap_t src_pmap = kernel_pmap;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KDP_VM_READ_DEBUG</span>
	printf(<span class="enscript-string">&quot;kdp_vm_read: src %llx dst %p len %llx\n&quot;</span>, src, (<span class="enscript-type">void</span> *)dst, len);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (kdp_trans_off &amp;&amp; IS_PHYS_ADDR(src)) {
		kdp_readphysmem64_req_t rq;
		mach_vm_size_t ret;

		rq.address = src;
		rq.nbytes = (uint32_t)len;
		ret = kdp_machine_phys_read(&amp;rq, dst, KDP_CURRENT_LCPU);
		<span class="enscript-keyword">return</span> ret;
	}

<span class="enscript-comment">/* If a different pmap has been specified with kdp_pmap, use it to translate the
 * source (cur_virt_src); otherwise, the source is translated using the
 * kernel_pmap.
 */</span>
	<span class="enscript-keyword">if</span> (kdp_pmap)
		src_pmap = kdp_pmap;

	<span class="enscript-keyword">while</span> (resid != 0) {
		<span class="enscript-keyword">if</span> (!(cur_phys_src = kdp_vtophys(src_pmap,
			    cur_virt_src)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

<span class="enscript-comment">/* Always translate the destination buffer using the kernel_pmap */</span>
		<span class="enscript-keyword">if</span>(!(cur_phys_dst = kdp_vtophys(kernel_pmap, cur_virt_dst)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-comment">/* Validate physical page numbers unless kdp_read_io is set */</span>
		<span class="enscript-keyword">if</span> (kdp_read_io == FALSE)
			<span class="enscript-keyword">if</span> (!pmap_valid_page(i386_btop(cur_phys_dst)) || !pmap_valid_page(i386_btop(cur_phys_src)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

<span class="enscript-comment">/* Get length left on page */</span>
		cnt_src = PAGE_SIZE - (cur_phys_src &amp; PAGE_MASK);
		cnt_dst = PAGE_SIZE - (cur_phys_dst &amp; PAGE_MASK);
		<span class="enscript-keyword">if</span> (cnt_src &gt; cnt_dst)
			cnt = cnt_dst;
		<span class="enscript-keyword">else</span>
			cnt = cnt_src;
		<span class="enscript-keyword">if</span> (cnt &gt; resid) 
			cnt = resid;

<span class="enscript-comment">/* Do a physical copy */</span>
		<span class="enscript-keyword">if</span> (EFAULT == ml_copy_phys(cur_phys_src,
					   cur_phys_dst,
					   (vm_size_t)cnt))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		cur_virt_src += cnt;
		cur_virt_dst += cnt;
		resid -= cnt;
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> (len - resid);
}

mach_vm_size_t
<span class="enscript-function-name">kdp_machine_phys_read</span>(kdp_readphysmem64_req_t *rq, caddr_t dst,
		      uint16_t lcpu)
{
	mach_vm_address_t src = rq-&gt;address;
	mach_vm_size_t    len = rq-&gt;nbytes;
	
	addr64_t cur_virt_dst;
	addr64_t cur_phys_dst, cur_phys_src;
	mach_vm_size_t resid = len;
	mach_vm_size_t cnt = 0, cnt_src, cnt_dst;

        <span class="enscript-keyword">if</span> ((lcpu != KDP_CURRENT_LCPU) &amp;&amp; (lcpu != cpu_number())) {
		<span class="enscript-keyword">return</span> (mach_vm_size_t) 
			kdp_x86_xcpu_invoke(lcpu, (kdp_x86_xcpu_func_t)kdp_machine_phys_read, rq, dst);
        }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KDP_VM_READ_DEBUG</span>
	printf(<span class="enscript-string">&quot;kdp_phys_read: src %llx dst %p len %llx\n&quot;</span>, src, (<span class="enscript-type">void</span> *)dst, len);
#<span class="enscript-reference">endif</span>

	cur_virt_dst = (addr64_t)(intptr_t)dst;
	cur_phys_src = (addr64_t)src;

	<span class="enscript-keyword">while</span> (resid != 0) {

		<span class="enscript-keyword">if</span>(!(cur_phys_dst = kdp_vtophys(kernel_pmap, cur_virt_dst)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

<span class="enscript-comment">/* Get length left on page */</span>
		cnt_src = PAGE_SIZE - (cur_phys_src &amp; PAGE_MASK);
		cnt_dst = PAGE_SIZE - (cur_phys_dst &amp; PAGE_MASK);
		<span class="enscript-keyword">if</span> (cnt_src &gt; cnt_dst)
			cnt = cnt_dst;
		<span class="enscript-keyword">else</span>
			cnt = cnt_src;
		<span class="enscript-keyword">if</span> (cnt &gt; resid) 
			cnt = resid;

	<span class="enscript-comment">/* Do a physical copy; use ml_copy_phys() in the event this is
	 * a short read with potential side effects.
	 */</span>
		<span class="enscript-keyword">if</span> (EFAULT == ml_copy_phys(cur_phys_src,
					   cur_phys_dst,
					   (vm_size_t)cnt))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		cur_phys_src += cnt;
		cur_virt_dst += cnt;
		resid -= cnt;
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> (len - resid);
}

<span class="enscript-comment">/*
 * 
 */</span>
mach_vm_size_t
<span class="enscript-function-name">kdp_machine_vm_write</span>( caddr_t src, mach_vm_address_t dst, mach_vm_size_t len)
{       
	addr64_t cur_virt_src, cur_virt_dst;
	addr64_t cur_phys_src, cur_phys_dst;
	<span class="enscript-type">unsigned</span> resid, cnt, cnt_src, cnt_dst;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KDP_VM_WRITE_DEBUG</span>
	printf(<span class="enscript-string">&quot;kdp_vm_write: src %p dst %llx len %llx - %08X %08X\n&quot;</span>, (<span class="enscript-type">void</span> *)src, dst, len, ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)src)[0], ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)src)[1]);
#<span class="enscript-reference">endif</span>

	cur_virt_src = PAL_KDP_ADDR((addr64_t)(intptr_t)src);
	cur_virt_dst = PAL_KDP_ADDR((addr64_t)dst);

	resid = (<span class="enscript-type">unsigned</span>)len;

	<span class="enscript-keyword">while</span> (resid != 0) {
		<span class="enscript-keyword">if</span> ((cur_phys_dst = kdp_vtophys(kernel_pmap, cur_virt_dst)) == 0) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-keyword">if</span> ((cur_phys_src = kdp_vtophys(kernel_pmap, cur_virt_src)) == 0) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-comment">/* Copy as many bytes as possible without crossing a page */</span>
		cnt_src = (<span class="enscript-type">unsigned</span>)(PAGE_SIZE - (cur_phys_src &amp; PAGE_MASK));
		cnt_dst = (<span class="enscript-type">unsigned</span>)(PAGE_SIZE - (cur_phys_dst &amp; PAGE_MASK));

		<span class="enscript-keyword">if</span> (cnt_src &gt; cnt_dst)
			cnt = cnt_dst;
		<span class="enscript-keyword">else</span>
			cnt = cnt_src;
		<span class="enscript-keyword">if</span> (cnt &gt; resid) 
			cnt = resid;

		<span class="enscript-keyword">if</span> (EFAULT == ml_copy_phys(cur_phys_src, cur_phys_dst, cnt))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;		<span class="enscript-comment">/* Copy stuff over */</span>

		cur_virt_src +=cnt;
		cur_virt_dst +=cnt;
		resid -= cnt;
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> (len - resid);
}

<span class="enscript-comment">/*
 * 
 */</span>
mach_vm_size_t
<span class="enscript-function-name">kdp_machine_phys_write</span>(kdp_writephysmem64_req_t *rq, caddr_t src,
		       uint16_t lcpu)
{       
	mach_vm_address_t dst = rq-&gt;address;
	mach_vm_size_t    len = rq-&gt;nbytes;
	addr64_t cur_virt_src;
	addr64_t cur_phys_src, cur_phys_dst;
	<span class="enscript-type">unsigned</span> resid, cnt, cnt_src, cnt_dst;

        <span class="enscript-keyword">if</span> ((lcpu != KDP_CURRENT_LCPU) &amp;&amp; (lcpu != cpu_number())) {
		<span class="enscript-keyword">return</span> (mach_vm_size_t) 
			kdp_x86_xcpu_invoke(lcpu, (kdp_x86_xcpu_func_t)kdp_machine_phys_write, rq, src);
        }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KDP_VM_WRITE_DEBUG</span>
	printf(<span class="enscript-string">&quot;kdp_phys_write: src %p dst %llx len %llx - %08X %08X\n&quot;</span>, (<span class="enscript-type">void</span> *)src, dst, len, ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)src)[0], ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)src)[1]);
#<span class="enscript-reference">endif</span>

	cur_virt_src = (addr64_t)(intptr_t)src;
	cur_phys_dst = (addr64_t)dst;

	resid = (<span class="enscript-type">unsigned</span>)len;

	<span class="enscript-keyword">while</span> (resid != 0) {
		<span class="enscript-keyword">if</span> ((cur_phys_src = kdp_vtophys(kernel_pmap, cur_virt_src)) == 0) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-comment">/* Copy as many bytes as possible without crossing a page */</span>
		cnt_src = (<span class="enscript-type">unsigned</span>)(PAGE_SIZE - (cur_phys_src &amp; PAGE_MASK));
		cnt_dst = (<span class="enscript-type">unsigned</span>)(PAGE_SIZE - (cur_phys_dst &amp; PAGE_MASK));

		<span class="enscript-keyword">if</span> (cnt_src &gt; cnt_dst)
			cnt = cnt_dst;
		<span class="enscript-keyword">else</span>
			cnt = cnt_src;
		<span class="enscript-keyword">if</span> (cnt &gt; resid) 
			cnt = resid;

		<span class="enscript-keyword">if</span> (EFAULT == ml_copy_phys(cur_phys_src, cur_phys_dst, cnt))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;		<span class="enscript-comment">/* Copy stuff over */</span>

		cur_virt_src +=cnt;
		cur_phys_dst +=cnt;
		resid -= cnt;
	}

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> (len - resid);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_machine_ioport_read</span>(kdp_readioport_req_t *rq, caddr_t data, uint16_t lcpu)
{
	uint16_t addr = rq-&gt;address;
	uint16_t size = rq-&gt;nbytes;

	<span class="enscript-keyword">if</span> ((lcpu != KDP_CURRENT_LCPU) &amp;&amp; (lcpu != cpu_number())) {
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) kdp_x86_xcpu_invoke(lcpu, (kdp_x86_xcpu_func_t)kdp_machine_ioport_read, rq, data);
        }

        <span class="enscript-keyword">switch</span> (size)
	{
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		*((uint8_t *) data)  = inb(addr);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		*((uint16_t *) data) = inw(addr);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		*((uint32_t *) data) = inl(addr);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KDPERR_BADFLAVOR;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_machine_ioport_write</span>(kdp_writeioport_req_t *rq, caddr_t data, uint16_t lcpu)
{
	uint16_t addr = rq-&gt;address;
	uint16_t size = rq-&gt;nbytes;

	<span class="enscript-keyword">if</span> ((lcpu != KDP_CURRENT_LCPU) &amp;&amp; (lcpu != cpu_number())) {
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) kdp_x86_xcpu_invoke(lcpu, (kdp_x86_xcpu_func_t)kdp_machine_ioport_write, rq, data);
	}

	<span class="enscript-keyword">switch</span> (size)
	{
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		outb(addr, *((uint8_t *) data));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		outw(addr, *((uint16_t *) data));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		outl(addr, *((uint32_t *) data));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KDPERR_BADFLAVOR;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_machine_msr64_read</span>(kdp_readmsr64_req_t *rq, caddr_t data, uint16_t lcpu)
{
	uint64_t *value = (uint64_t *) data;
	uint32_t msr    = rq-&gt;address;

	<span class="enscript-keyword">if</span> ((lcpu != KDP_CURRENT_LCPU) &amp;&amp; (lcpu != cpu_number())) {
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) kdp_x86_xcpu_invoke(lcpu, (kdp_x86_xcpu_func_t)kdp_machine_msr64_read, rq, data);
	}

	*value = rdmsr64(msr);
	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_machine_msr64_write</span>(kdp_writemsr64_req_t *rq, caddr_t data, uint16_t lcpu)
{
	uint64_t *value = (uint64_t *) data;
	uint32_t msr    = rq-&gt;address;

	<span class="enscript-keyword">if</span> ((lcpu != KDP_CURRENT_LCPU) &amp;&amp; (lcpu != cpu_number())) {
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) kdp_x86_xcpu_invoke(lcpu, (kdp_x86_xcpu_func_t)kdp_machine_msr64_write, rq, data);
	}

	wrmsr64(msr, *value);
	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
}

pt_entry_t *debugger_ptep;
vm_map_offset_t debugger_window_kva;

<span class="enscript-comment">/* Establish a pagetable window that can be remapped on demand.
 * This is utilized by the debugger to address regions outside
 * the physical map.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_machine_init</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">if</span> (debug_boot_arg == 0)
		<span class="enscript-keyword">return</span>;

	vm_map_entry_t e;
	kern_return_t kr = vm_map_find_space(kernel_map,
	    &amp;debugger_window_kva,
	    PAGE_SIZE, 0,
	    VM_MAKE_TAG(VM_KERN_MEMORY_OSFMK), &amp;e);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;%s: vm_map_find_space failed with %d\n&quot;</span>, __FUNCTION__, kr);
	}

	vm_map_unlock(kernel_map);

	debugger_ptep = pmap_pte(kernel_pmap, debugger_window_kva);

	<span class="enscript-keyword">if</span> (debugger_ptep == NULL) {
		pmap_expand(kernel_pmap, debugger_window_kva, PMAP_EXPAND_OPTIONS_NONE);
		debugger_ptep = pmap_pte(kernel_pmap, debugger_window_kva);
	}
}



</pre>
<hr />
</body></html>