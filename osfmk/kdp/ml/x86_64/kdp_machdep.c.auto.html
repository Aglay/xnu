<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kdp_machdep.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kdp_machdep.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_kdp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/trap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_callout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span> <span class="enscript-comment">/* for PE_halt_restart */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span> <span class="enscript-comment">/* for halt_all_cpus */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KDP_TEST_HARNESS</span> 0
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KDP_TEST_HARNESS</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">dprintf</span>(x) printf x
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">dprintf</span>(x)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> cpu_type_t <span class="enscript-function-name">cpuid_cputype</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> cpu_subtype_t <span class="enscript-function-name">cpuid_cpusubtype</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> vm_offset_t <span class="enscript-function-name">machine_trace_thread_get_kva</span>(vm_offset_t cur_target_addr, vm_map_t map, uint32_t *thread_trace_flags);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">machine_trace_thread_clear_validation_cache</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>		print_saved_state(<span class="enscript-type">void</span> *);
<span class="enscript-type">void</span>		kdp_call(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>		kdp_getc(<span class="enscript-type">void</span>);
boolean_t	kdp_call_kdb(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>		kdp_getstate(x86_thread_state64_t *);
<span class="enscript-type">void</span>		kdp_setstate(x86_thread_state64_t *);
<span class="enscript-type">void</span>		kdp_print_phys(<span class="enscript-type">int</span>);

<span class="enscript-type">int</span>
<span class="enscript-function-name">machine_trace_thread</span>(thread_t thread, <span class="enscript-type">char</span> *tracepos, <span class="enscript-type">char</span> *tracebound, <span class="enscript-type">int</span> nframes, boolean_t user_p, uint32_t *thread_trace_flags);

<span class="enscript-type">int</span>
<span class="enscript-function-name">machine_trace_thread64</span>(thread_t thread, <span class="enscript-type">char</span> *tracepos, <span class="enscript-type">char</span> *tracebound, <span class="enscript-type">int</span> nframes, boolean_t user_p, uint32_t *thread_trace_flags);

<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">machine_read64</span>(addr64_t srcaddr, caddr_t dstaddr, uint32_t len);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kdp_callouts(kdp_event_t event);

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_exception</span>(
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*pkt,
    <span class="enscript-type">int</span>	*len,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>	*remote_port,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	exception,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	code,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	subcode
)
{
    kdp_exception_t	*rq = (kdp_exception_t *)pkt;

    rq-&gt;hdr.request = KDP_EXCEPTION;
    rq-&gt;hdr.is_reply = 0;
    rq-&gt;hdr.seq = kdp.exception_seq;
    rq-&gt;hdr.key = 0;
    rq-&gt;hdr.len = <span class="enscript-keyword">sizeof</span> (*rq);
    
    rq-&gt;n_exc_info = 1;
    rq-&gt;exc_info[0].cpu = 0;
    rq-&gt;exc_info[0].exception = exception;
    rq-&gt;exc_info[0].code = code;
    rq-&gt;exc_info[0].subcode = subcode;
    
    rq-&gt;hdr.len += rq-&gt;n_exc_info * <span class="enscript-keyword">sizeof</span> (kdp_exc_info_t);
    
    bcopy((<span class="enscript-type">char</span> *)rq, (<span class="enscript-type">char</span> *)pkt, rq-&gt;hdr.len);

    kdp.exception_ack_needed = TRUE;
    
    *remote_port = kdp.exception_port;
    *len = rq-&gt;hdr.len;
}

boolean_t
<span class="enscript-function-name">kdp_exception_ack</span>(
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*pkt,
    <span class="enscript-type">int</span>			len
)
{
    kdp_exception_ack_t	*rq = (kdp_exception_ack_t *)pkt;

    <span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) len) &lt; <span class="enscript-keyword">sizeof</span> (*rq))
	<span class="enscript-keyword">return</span>(FALSE);
	
    <span class="enscript-keyword">if</span> (!rq-&gt;hdr.is_reply || rq-&gt;hdr.request != KDP_EXCEPTION)
    	<span class="enscript-keyword">return</span>(FALSE);
	
    dprintf((<span class="enscript-string">&quot;kdp_exception_ack seq %x %x\n&quot;</span>, rq-&gt;hdr.seq, kdp.exception_seq));
	
    <span class="enscript-keyword">if</span> (rq-&gt;hdr.seq == kdp.exception_seq) {
	kdp.exception_ack_needed = FALSE;
	kdp.exception_seq++;
    }
    <span class="enscript-keyword">return</span>(TRUE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_getstate</span>(
    x86_thread_state64_t	*state
)
{
    x86_saved_state64_t	*saved_state;
    
    saved_state = (x86_saved_state64_t *)kdp.saved_state;
    
    state-&gt;rax = saved_state-&gt;rax;
    state-&gt;rbx = saved_state-&gt;rbx;
    state-&gt;rcx = saved_state-&gt;rcx;
    state-&gt;rdx = saved_state-&gt;rdx;
    state-&gt;rdi = saved_state-&gt;rdi;
    state-&gt;rsi = saved_state-&gt;rsi;
    state-&gt;rbp = saved_state-&gt;rbp;

    state-&gt;r8  = saved_state-&gt;r8;
    state-&gt;r9  = saved_state-&gt;r9;
    state-&gt;r10 = saved_state-&gt;r10;
    state-&gt;r11 = saved_state-&gt;r11;
    state-&gt;r12 = saved_state-&gt;r12;
    state-&gt;r13 = saved_state-&gt;r13;
    state-&gt;r14 = saved_state-&gt;r14;
    state-&gt;r15 = saved_state-&gt;r15;
    
    state-&gt;rsp = saved_state-&gt;isf.rsp;
    state-&gt;rflags = saved_state-&gt;isf.rflags;
    state-&gt;rip = saved_state-&gt;isf.rip;

    state-&gt;cs = saved_state-&gt;isf.cs;
    state-&gt;fs = saved_state-&gt;fs;
    state-&gt;gs = saved_state-&gt;gs;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_setstate</span>(
    x86_thread_state64_t	*state
)
{
    x86_saved_state64_t		*saved_state;
    
    saved_state = (x86_saved_state64_t *)kdp.saved_state;
    saved_state-&gt;rax = state-&gt;rax;
    saved_state-&gt;rbx = state-&gt;rbx;
    saved_state-&gt;rcx = state-&gt;rcx;
    saved_state-&gt;rdx = state-&gt;rdx;
    saved_state-&gt;rdi = state-&gt;rdi;
    saved_state-&gt;rsi = state-&gt;rsi;
    saved_state-&gt;rbp = state-&gt;rbp;
    saved_state-&gt;r8  = state-&gt;r8;
    saved_state-&gt;r9  = state-&gt;r9;
    saved_state-&gt;r10 = state-&gt;r10;
    saved_state-&gt;r11 = state-&gt;r11;
    saved_state-&gt;r12 = state-&gt;r12;
    saved_state-&gt;r13 = state-&gt;r13;
    saved_state-&gt;r14 = state-&gt;r14;
    saved_state-&gt;r15 = state-&gt;r15;

    saved_state-&gt;isf.rflags = state-&gt;rflags;
    saved_state-&gt;isf.rsp = state-&gt;rsp;
    saved_state-&gt;isf.rip = state-&gt;rip;

    saved_state-&gt;fs = (uint32_t)state-&gt;fs;
    saved_state-&gt;gs = (uint32_t)state-&gt;gs;
}


kdp_error_t
<span class="enscript-function-name">kdp_machine_read_regs</span>(
    __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cpu,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flavor,
    <span class="enscript-type">char</span> *data,
    <span class="enscript-type">int</span> *size
)
{
    <span class="enscript-type">static</span> x86_float_state64_t  null_fpstate;

    <span class="enscript-keyword">switch</span> (flavor) {

    <span class="enscript-keyword">case</span> <span class="enscript-reference">x86_THREAD_STATE64</span>:
	dprintf((<span class="enscript-string">&quot;kdp_readregs THREAD_STATE64\n&quot;</span>));
	kdp_getstate((x86_thread_state64_t *)data);
	*size = <span class="enscript-keyword">sizeof</span> (x86_thread_state64_t);
	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">x86_FLOAT_STATE64</span>:
	dprintf((<span class="enscript-string">&quot;kdp_readregs THREAD_FPSTATE64\n&quot;</span>));
	*(x86_float_state64_t *)data = null_fpstate;
	*size = <span class="enscript-keyword">sizeof</span> (x86_float_state64_t);
	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
	
    <span class="enscript-reference">default</span>:
	dprintf((<span class="enscript-string">&quot;kdp_readregs bad flavor %d\n&quot;</span>, flavor));
	*size = 0;
	<span class="enscript-keyword">return</span> KDPERR_BADFLAVOR;
    }
}

kdp_error_t
<span class="enscript-function-name">kdp_machine_write_regs</span>(
    __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cpu,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flavor,
    <span class="enscript-type">char</span> *data,
    __unused <span class="enscript-type">int</span> *size
)
{
    <span class="enscript-keyword">switch</span> (flavor) {

    <span class="enscript-keyword">case</span> <span class="enscript-reference">x86_THREAD_STATE64</span>:
	dprintf((<span class="enscript-string">&quot;kdp_writeregs THREAD_STATE64\n&quot;</span>));
	kdp_setstate((x86_thread_state64_t *)data);
	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">x86_FLOAT_STATE64</span>:
	dprintf((<span class="enscript-string">&quot;kdp_writeregs THREAD_FPSTATE64\n&quot;</span>));
	<span class="enscript-keyword">return</span> KDPERR_NO_ERROR;
	
    <span class="enscript-reference">default</span>:
	dprintf((<span class="enscript-string">&quot;kdp_writeregs bad flavor %d\n&quot;</span>, flavor));
	<span class="enscript-keyword">return</span> KDPERR_BADFLAVOR;
    }
}



<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_machine_hostinfo</span>(
    kdp_hostinfo_t *hostinfo
)
{
    <span class="enscript-type">int</span>			i;

    hostinfo-&gt;cpus_mask = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; machine_info.max_cpus; i++) {
	<span class="enscript-keyword">if</span> (cpu_data_ptr[i] == NULL)
            <span class="enscript-keyword">continue</span>;
	
        hostinfo-&gt;cpus_mask |= (1 &lt;&lt; i);
    }

    hostinfo-&gt;cpu_type = cpuid_cputype() | CPU_ARCH_ABI64;
    hostinfo-&gt;cpu_subtype = cpuid_cpusubtype();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_panic</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>		*msg
)
{
    kprintf(<span class="enscript-string">&quot;kdp panic: %s\n&quot;</span>, msg);    
    __asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;hlt&quot;</span>);	
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_machine_reboot</span>(<span class="enscript-type">void</span>)
{
	printf(<span class="enscript-string">&quot;Attempting system restart...&quot;</span>);
	<span class="enscript-comment">/* Call the platform specific restart*/</span>
	<span class="enscript-keyword">if</span> (PE_halt_restart)
		(*PE_halt_restart)(kPERestartCPU);
	<span class="enscript-comment">/* If we do reach this, give up */</span>
	halt_all_cpus(TRUE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_intr_disbl</span>(<span class="enscript-type">void</span>)
{
   <span class="enscript-keyword">return</span> splhigh();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_intr_enbl</span>(<span class="enscript-type">int</span> s)
{
	splx(s);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_getc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>	cnmaygetc();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_us_spin</span>(<span class="enscript-type">int</span> usec)
{
    delay(usec/100);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">print_saved_state</span>(<span class="enscript-type">void</span> *state)
{
    x86_saved_state64_t		*saved_state;

    saved_state = state;

	kprintf(<span class="enscript-string">&quot;pc = 0x%llx\n&quot;</span>, saved_state-&gt;isf.rip);
	kprintf(<span class="enscript-string">&quot;cr2= 0x%llx\n&quot;</span>, saved_state-&gt;cr2);
	kprintf(<span class="enscript-string">&quot;rp = TODO FIXME\n&quot;</span>);
	kprintf(<span class="enscript-string">&quot;sp = %p\n&quot;</span>, saved_state);

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_sync_cache</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>;	<span class="enscript-comment">/* No op here. */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_call</span>(<span class="enscript-type">void</span>)
{
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;int	$3&quot;</span>);	<span class="enscript-comment">/* Let the processor do the work */</span>
}


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _cframe_t {
    <span class="enscript-type">struct</span> _cframe_t	*prev;
    <span class="enscript-type">unsigned</span>		caller;
    <span class="enscript-type">unsigned</span>		args[0];
} cframe_t;

<span class="enscript-type">extern</span> pt_entry_t *DMAP2;
<span class="enscript-type">extern</span> caddr_t DADDR2;

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_print_phys</span>(<span class="enscript-type">int</span> src)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>   *iptr;
	<span class="enscript-type">int</span>             i;

	*(<span class="enscript-type">int</span> *) DMAP2 = 0x63 | (src &amp; 0xfffff000);
	invlpg((uintptr_t) DADDR2);
	iptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) DADDR2;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 100; i++) {
		kprintf(<span class="enscript-string">&quot;0x%x &quot;</span>, *iptr++);
		<span class="enscript-keyword">if</span> ((i % 8) == 0)
			kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
	*(<span class="enscript-type">int</span> *) DMAP2 = 0;

}

boolean_t
<span class="enscript-function-name">kdp_i386_trap</span>(
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		trapno,
    x86_saved_state64_t	*saved_state,
    kern_return_t	result,
    vm_offset_t		va
)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> exception, subcode = 0, code;

    <span class="enscript-keyword">if</span> (trapno != T_INT3 &amp;&amp; trapno != T_DEBUG) {
    	kprintf(<span class="enscript-string">&quot;Debugger: Unexpected kernel trap number: &quot;</span>
		<span class="enscript-string">&quot;0x%x, RIP: 0x%llx, CR2: 0x%llx\n&quot;</span>,
		trapno, saved_state-&gt;isf.rip, saved_state-&gt;cr2);
	<span class="enscript-keyword">if</span> (!kdp.is_conn)
	    <span class="enscript-keyword">return</span> FALSE;
    }	

    mp_kdp_enter();
    kdp_callouts(KDP_EVENT_ENTER);

    <span class="enscript-keyword">if</span> (saved_state-&gt;isf.rflags &amp; EFL_TF) {
	    enable_preemption_no_check();
    }

    <span class="enscript-keyword">switch</span> (trapno) {
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_DIVIDE_ERROR</span>:
	exception = EXC_ARITHMETIC;
	code = EXC_I386_DIVERR;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_OVERFLOW</span>:
	exception = EXC_SOFTWARE;
	code = EXC_I386_INTOFLT;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_OUT_OF_BOUNDS</span>:
	exception = EXC_ARITHMETIC;
	code = EXC_I386_BOUNDFLT;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_INVALID_OPCODE</span>:
	exception = EXC_BAD_INSTRUCTION;
	code = EXC_I386_INVOPFLT;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_SEGMENT_NOT_PRESENT</span>:
	exception = EXC_BAD_INSTRUCTION;
	code = EXC_I386_SEGNPFLT;
	subcode	= (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)saved_state-&gt;isf.err;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_STACK_FAULT</span>:
	exception = EXC_BAD_INSTRUCTION;
	code = EXC_I386_STKFLT;
	subcode	= (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)saved_state-&gt;isf.err;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_GENERAL_PROTECTION</span>:
	exception = EXC_BAD_INSTRUCTION;
	code = EXC_I386_GPFLT;
	subcode	= (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)saved_state-&gt;isf.err;
	<span class="enscript-keyword">break</span>;
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_PAGE_FAULT</span>:
    	exception = EXC_BAD_ACCESS;
	code = result;
	subcode = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)va;
	<span class="enscript-keyword">break</span>;
    
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_WATCHPOINT</span>:
	exception = EXC_SOFTWARE;
	code = EXC_I386_ALIGNFLT;
	<span class="enscript-keyword">break</span>;
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_DEBUG</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_INT3</span>:
	exception = EXC_BREAKPOINT;
	code = EXC_I386_BPTFLT;
	<span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:
    	exception = EXC_BAD_INSTRUCTION;
	code = trapno;
	<span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (current_cpu_datap()-&gt;cpu_fatal_trap_state) {
	    current_cpu_datap()-&gt;cpu_post_fatal_trap_state = saved_state;
	    saved_state = current_cpu_datap()-&gt;cpu_fatal_trap_state;
    }

    kdp_raise_exception(exception, code, subcode, saved_state);
    <span class="enscript-comment">/* If the instruction single step bit is set, disable kernel preemption
     */</span>
    <span class="enscript-keyword">if</span> (saved_state-&gt;isf.rflags &amp; EFL_TF) {
	    disable_preemption();
    }

    kdp_callouts(KDP_EVENT_EXIT);
    mp_kdp_exit();

    <span class="enscript-keyword">return</span> TRUE;
}

boolean_t 
<span class="enscript-function-name">kdp_call_kdb</span>(
        <span class="enscript-type">void</span>) 
{       
        <span class="enscript-keyword">return</span>(FALSE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_machine_get_breakinsn</span>(
						  uint8_t *bytes,
						  uint32_t *size
)
{
	bytes[0] = 0xcc;
	*size = 1;
}

<span class="enscript-type">extern</span> pmap_t kdp_pmap;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RETURN_OFFSET</span> 4

<span class="enscript-type">int</span>
<span class="enscript-function-name">machine_trace_thread</span>(thread_t thread, <span class="enscript-type">char</span> *tracepos, <span class="enscript-type">char</span> *tracebound, <span class="enscript-type">int</span> nframes, boolean_t user_p, uint32_t *thread_trace_flags)
{
	uint32_t *tracebuf = (uint32_t *)tracepos;
	uint32_t fence = 0;
	uint32_t stackptr = 0;
	uint32_t stacklimit = 0xfc000000;
	<span class="enscript-type">int</span> framecount = 0;
	uint32_t init_eip = 0;
	uint32_t prevsp = 0;
	uint32_t framesize = 2 * <span class="enscript-keyword">sizeof</span>(vm_offset_t);
	vm_offset_t kern_virt_addr = 0;

	<span class="enscript-keyword">if</span> (user_p) {
	        x86_saved_state32_t	*iss32;
		
		iss32 = USER_REGS32(thread);
		init_eip = iss32-&gt;eip;
		stackptr = iss32-&gt;ebp;

		stacklimit = 0xffffffff;
		kdp_pmap = thread-&gt;task-&gt;map-&gt;pmap;
	}
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;32-bit trace attempted on 64-bit kernel&quot;</span>);

    <span class="enscript-comment">/* bounds check before we start advancing tracebuf */</span>
    <span class="enscript-keyword">if</span> ((tracebound - ((<span class="enscript-type">char</span> *)tracebuf)) &lt; (4 * framesize)) {
        machine_trace_thread_clear_validation_cache();
        kdp_pmap = 0;
        <span class="enscript-keyword">return</span> 0;
    }

	*tracebuf++ = init_eip;

	<span class="enscript-keyword">for</span> (framecount = 0; framecount &lt; nframes; framecount++) {

		<span class="enscript-keyword">if</span> ((tracebound - ((<span class="enscript-type">char</span> *)tracebuf)) &lt; (4 * framesize)) {
			tracebuf--;
			<span class="enscript-keyword">break</span>;
		}

		*tracebuf++ = stackptr;
		<span class="enscript-comment">/* Invalid frame, or hit fence */</span>
		<span class="enscript-keyword">if</span> (!stackptr || (stackptr == fence)) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Unaligned frame */</span>
		<span class="enscript-keyword">if</span> (stackptr &amp; 0x0000003) {
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> (stackptr &lt;= prevsp) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (stackptr &gt; stacklimit) {
			<span class="enscript-keyword">break</span>;
		}

		kern_virt_addr = machine_trace_thread_get_kva(stackptr + RETURN_OFFSET, thread-&gt;task-&gt;map, thread_trace_flags);

		<span class="enscript-keyword">if</span> (!kern_virt_addr) {
			<span class="enscript-keyword">if</span> (thread_trace_flags) {
				*thread_trace_flags |= kThreadTruncatedBT;
			}
			<span class="enscript-keyword">break</span>;
		}

		*tracebuf = *(uint32_t *)kern_virt_addr;
		tracebuf++;
		
		prevsp = stackptr;
		kern_virt_addr = machine_trace_thread_get_kva(stackptr, thread-&gt;task-&gt;map, thread_trace_flags);

		<span class="enscript-keyword">if</span> (!kern_virt_addr) {
			<span class="enscript-keyword">if</span> (thread_trace_flags) {
				*thread_trace_flags |= kThreadTruncatedBT;
			}

			<span class="enscript-comment">/* We need to fill in a complete LR/FP record, even if we couldn't find a FP */</span>
			*tracebuf++ = 0;
			<span class="enscript-keyword">break</span>;
		}

		stackptr = *(uint32_t *)kern_virt_addr;
	}
    
	machine_trace_thread_clear_validation_cache();
	kdp_pmap = 0;

	<span class="enscript-keyword">return</span> (uint32_t) (((<span class="enscript-type">char</span> *) tracebuf) - tracepos);
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RETURN_OFFSET64</span>	8
<span class="enscript-comment">/* Routine to encapsulate the 64-bit address read hack*/</span>
<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">machine_read64</span>(addr64_t srcaddr, caddr_t dstaddr, uint32_t len)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-type">unsigned</span>)kdp_machine_vm_read(srcaddr, dstaddr, len);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">machine_trace_thread64</span>(thread_t thread, <span class="enscript-type">char</span> *tracepos, <span class="enscript-type">char</span> *tracebound, <span class="enscript-type">int</span> nframes, boolean_t user_p, uint32_t *thread_trace_flags)
{
	uint64_t *tracebuf = (uint64_t *)tracepos;
	uint32_t fence = 0;
	addr64_t stackptr = 0;
	<span class="enscript-type">int</span>	 framecount = 0;
	addr64_t init_rip = 0;
	addr64_t prevsp = 0;
	<span class="enscript-type">unsigned</span> framesize = 2 * <span class="enscript-keyword">sizeof</span>(addr64_t);
	vm_offset_t kern_virt_addr = 0;

	<span class="enscript-keyword">if</span> (user_p) {
		x86_saved_state64_t	*iss64;
		iss64 = USER_REGS64(thread);
		init_rip = iss64-&gt;isf.rip;
		stackptr = iss64-&gt;rbp;
		kdp_pmap = thread-&gt;task-&gt;map-&gt;pmap;
	}
	<span class="enscript-keyword">else</span> {
		stackptr = STACK_IKS(thread-&gt;kernel_stack)-&gt;k_rbp;
		init_rip = STACK_IKS(thread-&gt;kernel_stack)-&gt;k_rip;
		init_rip = VM_KERNEL_UNSLIDE(init_rip);
        kdp_pmap = NULL;
	}

    <span class="enscript-comment">/* bounds check before we start advancing tracebuf */</span>
    <span class="enscript-keyword">if</span> ((uint32_t)(tracebound - ((<span class="enscript-type">char</span> *)tracebuf)) &lt; (4 * framesize)) {
        machine_trace_thread_clear_validation_cache();
        kdp_pmap = NULL;
        <span class="enscript-keyword">return</span> 0;
    }
    *tracebuf++ = init_rip;
    
	<span class="enscript-keyword">for</span> (framecount = 0; framecount &lt; nframes; framecount++) {

		<span class="enscript-keyword">if</span> ((uint32_t)(tracebound - ((<span class="enscript-type">char</span> *)tracebuf)) &lt; (4 * framesize)) {
			tracebuf--;
			<span class="enscript-keyword">break</span>;
		}

		*tracebuf++ = stackptr;

		<span class="enscript-keyword">if</span> (!stackptr || (stackptr == fence)){
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (stackptr &amp; 0x0000007) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (stackptr &lt;= prevsp) {
			<span class="enscript-keyword">break</span>;
		}

		kern_virt_addr = machine_trace_thread_get_kva(stackptr + RETURN_OFFSET64, thread-&gt;task-&gt;map, thread_trace_flags);

		<span class="enscript-keyword">if</span> (!kern_virt_addr) {
			<span class="enscript-keyword">if</span> (thread_trace_flags) {
				*thread_trace_flags |= kThreadTruncatedBT;
			}
			<span class="enscript-keyword">break</span>;
		}

		*tracebuf = *(uint64_t *)kern_virt_addr;
		<span class="enscript-keyword">if</span> (!user_p)
			*tracebuf = VM_KERNEL_UNSLIDE(*tracebuf);

		tracebuf++;

		prevsp = stackptr;
		kern_virt_addr = machine_trace_thread_get_kva(stackptr, thread-&gt;task-&gt;map, thread_trace_flags);

		<span class="enscript-keyword">if</span> (!kern_virt_addr) {
			<span class="enscript-keyword">if</span> (thread_trace_flags) {
				*thread_trace_flags |= kThreadTruncatedBT;
			}

			<span class="enscript-comment">/* We need to fill in a complete LR/FP record, even if we couldn't find a FP */</span>
			*tracebuf++ = 0;
			<span class="enscript-keyword">break</span>;
		}

		stackptr = *(uint64_t *)kern_virt_addr;
	}

	machine_trace_thread_clear_validation_cache();
	kdp_pmap = NULL;

	<span class="enscript-keyword">return</span> (uint32_t) (((<span class="enscript-type">char</span> *) tracebuf) - tracepos);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kdp_callout {
	<span class="enscript-type">struct</span> kdp_callout	*callout_next;
	kdp_callout_fn_t	callout_fn;
	<span class="enscript-type">void</span>			*callout_arg;
} *kdp_callout_list = NULL;


<span class="enscript-comment">/*
 * Called from kernel context to register a kdp event callout.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_register_callout</span>(
	kdp_callout_fn_t	fn,
	<span class="enscript-type">void</span>			*arg)
{
	<span class="enscript-type">struct</span> kdp_callout	*kcp;
	<span class="enscript-type">struct</span> kdp_callout	*list_head;

	kcp = kalloc(<span class="enscript-keyword">sizeof</span>(*kcp));
	<span class="enscript-keyword">if</span> (kcp == NULL)
		panic(<span class="enscript-string">&quot;kdp_register_callout() kalloc failed&quot;</span>);

	kcp-&gt;callout_fn  = fn;
	kcp-&gt;callout_arg = arg;

	<span class="enscript-comment">/* Lock-less list insertion using compare and exchange. */</span>
	<span class="enscript-keyword">do</span> {
		list_head = kdp_callout_list;
		kcp-&gt;callout_next = list_head;
	} <span class="enscript-keyword">while</span> (!OSCompareAndSwapPtr(list_head, kcp, (<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;kdp_callout_list));
}

<span class="enscript-comment">/*
 * Called at exception/panic time when extering or exiting kdp.  
 * We are single-threaded at this time and so we don't use locks.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_callouts</span>(kdp_event_t event)
{
	<span class="enscript-type">struct</span> kdp_callout	*kcp = kdp_callout_list;

	<span class="enscript-keyword">while</span> (kcp) {
		kcp-&gt;callout_fn(kcp-&gt;callout_arg, event); 
		kcp = kcp-&gt;callout_next;
	}	
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_ml_enter_debugger</span>(<span class="enscript-type">void</span>)
{
	__asm__ __volatile__(<span class="enscript-string">&quot;int3&quot;</span>);
}
</pre>
<hr />
</body></html>