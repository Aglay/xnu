<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>video_console.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">video_console.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 * 
 */</span>
<span class="enscript-comment">/*
 * @APPLE_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/*
 *	NetBSD: ite.c,v 1.16 1995/07/17 01:24:34 briggs Exp	
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: ite.c 1.28 92/12/20$
 *
 *	@(#)ite.c	8.2 (Berkeley) 1/12/94
 */</span>

<span class="enscript-comment">/*
 * ite.c
 *
 * The ite module handles the system console; that is, stuff printed
 * by the kernel and by user programs while &quot;desktop&quot; and X aren't
 * running.  Some (very small) parts are based on hp300's 4.4 ite.c,
 * hence the above copyright.
 *
 *   -- Brad and Lawrence, June 26th, 1994
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/video_console.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/serial_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/io_map_entries.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_cpu.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;iso_font.c&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;progress_meter_data.c&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;sys/msgbuf.h&quot;</span>

<span class="enscript-comment">/*
 * Generic Console (Front-End)
 * ---------------------------
 */</span>

<span class="enscript-type">struct</span> vc_info vinfo;

<span class="enscript-type">void</span> <span class="enscript-function-name">noroot_icon_test</span>(<span class="enscript-type">void</span>);


<span class="enscript-type">extern</span> <span class="enscript-type">int</span>       disableConsoleOutput;
<span class="enscript-type">static</span> boolean_t gc_enabled     = FALSE;
<span class="enscript-type">static</span> boolean_t gc_initialized = FALSE;
<span class="enscript-type">static</span> boolean_t vm_initialized = FALSE;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">void</span> (*initialize)(<span class="enscript-type">struct</span> vc_info * info);
	<span class="enscript-type">void</span> (*enable)(boolean_t enable);
	<span class="enscript-type">void</span> (*paint_char)(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch,
			   <span class="enscript-type">int</span> attrs, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch_previous,
			   <span class="enscript-type">int</span> attrs_previous);
	<span class="enscript-type">void</span> (*clear_screen)(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top,
			     <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom, <span class="enscript-type">int</span> which);
	<span class="enscript-type">void</span> (*scroll_down)(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom);
	<span class="enscript-type">void</span> (*scroll_up)(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom);
	<span class="enscript-type">void</span> (*hide_cursor)(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy);
	<span class="enscript-type">void</span> (*show_cursor)(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy);
	<span class="enscript-type">void</span> (*update_color)(<span class="enscript-type">int</span> color, boolean_t fore);
} gc_ops;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *gc_buffer_attributes;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *gc_buffer_characters;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *gc_buffer_colorcodes;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *gc_buffer_tab_stops;
<span class="enscript-type">static</span> uint32_t gc_buffer_columns;
<span class="enscript-type">static</span> uint32_t gc_buffer_rows;
<span class="enscript-type">static</span> uint32_t gc_buffer_size;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">static</span>, vcputc_lock);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCPUTC_LOCK_INIT</span>()				\
MACRO_BEGIN						\
	simple_lock_init(&amp;vcputc_lock, 0);		\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCPUTC_LOCK_LOCK</span>()				\
MACRO_BEGIN						\
	boolean_t istate = ml_get_interrupts_enabled();	\
	<span class="enscript-keyword">while</span> (!simple_lock_try(&amp;vcputc_lock))		\
	{						\
		<span class="enscript-keyword">if</span> (!istate)				\
			handle_pending_TLB_flushes();	\
		cpu_pause();				\
	}						\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCPUTC_LOCK_UNLOCK</span>()				\
MACRO_BEGIN						\
	simple_unlock(&amp;vcputc_lock);			\
MACRO_END
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> hw_lock_data_t vcputc_lock;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCPUTC_LOCK_INIT</span>()				\
MACRO_BEGIN						\
	hw_lock_init(&amp;vcputc_lock);			\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCPUTC_LOCK_LOCK</span>()				\
MACRO_BEGIN						\
	<span class="enscript-keyword">if</span> (!hw_lock_to(&amp;vcputc_lock, ~0U))\
	{						\
		panic(<span class="enscript-string">&quot;VCPUTC_LOCK_LOCK&quot;</span>);		\
	}						\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCPUTC_LOCK_UNLOCK</span>()				\
MACRO_BEGIN						\
	hw_lock_unlock(&amp;vcputc_lock);			\
MACRO_END
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
# Attribute codes: 
# 00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed
# Text color codes:
# 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white
# Background color codes:
# 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white
*/</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_NONE</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_BOLD</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_UNDER</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_REVERSE</span>	4

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COLOR_BACKGROUND</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COLOR_FOREGROUND</span> 7

#<span class="enscript-reference">define</span> <span class="enscript-function-name">COLOR_CODE_GET</span>(code, fore)        (((code) &amp; ((fore) ? 0xF0 : 0x0F))            &gt;&gt; ((fore) ? 4 : 0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COLOR_CODE_SET</span>(code, color, fore) (((code) &amp; ((fore) ? 0x0F : 0xF0)) | ((color) &lt;&lt; ((fore) ? 4 : 0)))

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> gc_color_code;

<span class="enscript-comment">/* VT100 state: */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXPARS</span>	16
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> gc_x, gc_y, gc_savex, gc_savey;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> gc_par[MAXPARS], gc_numpars, gc_hanging_cursor, gc_attr, gc_saveattr;

<span class="enscript-comment">/* VT100 scroll region */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> gc_scrreg_top, gc_scrreg_bottom;

<span class="enscript-type">enum</span> vt100state_e {
	ESnormal,		<span class="enscript-comment">/* Nothing yet                             */</span>
	ESesc,			<span class="enscript-comment">/* Got ESC                                 */</span>
	ESsquare,		<span class="enscript-comment">/* Got ESC [				   */</span>
	ESgetpars,		<span class="enscript-comment">/* About to get or getting the parameters  */</span>
	ESgotpars,		<span class="enscript-comment">/* Finished getting the parameters         */</span>
	ESfunckey,		<span class="enscript-comment">/* Function key                            */</span>
	EShash,			<span class="enscript-comment">/* DEC-specific stuff (screen align, etc.) */</span>
	ESsetG0,		<span class="enscript-comment">/* Specify the G0 character set            */</span>
	ESsetG1,		<span class="enscript-comment">/* Specify the G1 character set            */</span>
	ESask,
	EScharsize,
	ESignore		<span class="enscript-comment">/* Ignore this sequence                    */</span>
} gc_vt100state = ESnormal;


<span class="enscript-type">enum</span> 
{
    <span class="enscript-comment">/* secs */</span>
    kProgressAcquireDelay   = 0,
    kProgressReacquireDelay = 5,
};

<span class="enscript-type">static</span> int8_t vc_rotate_matr[4][2][2] = {
  { {  1,  0 },
    {  0,  1 } },
  { {  0,  1 },
    { -1,  0 } },
  { { -1,  0 },
    {  0, -1 } },
  { {  0, -1 },
    {  1,  0 } }
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> gc_wrap_mode = 1, gc_relative_origin = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> gc_charset_select = 0, gc_save_charset_s = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> gc_charset[2] = { 0, 0 };
<span class="enscript-type">static</span> <span class="enscript-type">int</span> gc_charset_save[2] = { 0, 0 };

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_clear_line</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">int</span> which);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_clear_screen</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">int</span> top,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom, <span class="enscript-type">int</span> which);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_enable</span>(boolean_t enable);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_hide_cursor</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_initialize</span>(<span class="enscript-type">struct</span> vc_info * info);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">gc_is_tab_stop</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> column);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_paint_char</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch,
		<span class="enscript-type">int</span> attrs);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putchar</span>(<span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_askcmd</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_charsetcmd</span>(<span class="enscript-type">int</span> charset, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_charsizecmd</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_esc</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_getpars</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_gotpars</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_normal</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_putc_square</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_reset_screen</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_reset_tabs</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_reset_vt100</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_scroll_down</span>(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_scroll_up</span>(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_set_tab_stop</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> column, boolean_t enabled);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_show_cursor</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gc_update_color</span>(<span class="enscript-type">int</span> color, boolean_t fore);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_clear_line</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">int</span> which)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> start, end, i;

	<span class="enscript-comment">/*
	 * This routine runs extremely slowly.  I don't think it's
	 * used all that often, except for To end of line.  I'll go
	 * back and speed this up when I speed up the whole vc
	 * module. --LK
	 */</span>

	<span class="enscript-keyword">switch</span> (which) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:		<span class="enscript-comment">/* To end of line	 */</span>
		start = xx;
		end = vinfo.v_columns-1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:		<span class="enscript-comment">/* To start of line	 */</span>
		start = 0;
		end = xx;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:		<span class="enscript-comment">/* Whole line		 */</span>
		start = 0;
		end = vinfo.v_columns-1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (i = start; i &lt;= end; i++) {
		gc_paint_char(i, yy, <span class="enscript-string">' '</span>, ATTR_NONE);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_clear_screen</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom,
		<span class="enscript-type">int</span> which)
{
	<span class="enscript-keyword">if</span> (!gc_buffer_size) <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ( xx &lt; gc_buffer_columns &amp;&amp; yy &lt; gc_buffer_rows &amp;&amp; bottom &lt;= gc_buffer_rows )
	{
		uint32_t start, end;

		<span class="enscript-keyword">switch</span> (which) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:		<span class="enscript-comment">/* To end of screen	 */</span>
				start = (yy * gc_buffer_columns) + xx;
				end = (bottom * gc_buffer_columns) - 1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:		<span class="enscript-comment">/* To start of screen	 */</span>
				start = (top * gc_buffer_columns);
				end = (yy * gc_buffer_columns) + xx;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:		<span class="enscript-comment">/* Whole screen		 */</span>
				start = (top * gc_buffer_columns);
				end = (bottom * gc_buffer_columns) - 1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				start = 0;
				end = 0;
				<span class="enscript-keyword">break</span>;
		}

		memset(gc_buffer_attributes + start, ATTR_NONE, end - start + 1);
		memset(gc_buffer_characters + start, <span class="enscript-string">' '</span>, end - start + 1);
		memset(gc_buffer_colorcodes + start, gc_color_code, end - start + 1);
	}

	gc_ops.clear_screen(xx, yy, top, bottom, which);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_enable</span>( boolean_t enable )
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer_attributes = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer_characters = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer_colorcodes = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer_tab_stops  = NULL;
	uint32_t buffer_columns = 0;
	uint32_t buffer_rows = 0;
	uint32_t buffer_size = 0;
	spl_t s;

	<span class="enscript-keyword">if</span> ( enable == FALSE )
	{
		<span class="enscript-comment">// only disable console output if it goes to the graphics console
</span>		<span class="enscript-keyword">if</span> ( console_is_serial() == FALSE )
			disableConsoleOutput = TRUE;
		gc_enabled           = FALSE;
		gc_ops.enable(FALSE);
	}

	s = splhigh( );
	VCPUTC_LOCK_LOCK( );

	<span class="enscript-keyword">if</span> ( gc_buffer_size )
	{
		buffer_attributes = gc_buffer_attributes;
		buffer_characters = gc_buffer_characters;
		buffer_colorcodes = gc_buffer_colorcodes;
		buffer_tab_stops  = gc_buffer_tab_stops;
		buffer_columns    = gc_buffer_columns;
		buffer_rows       = gc_buffer_rows;
		buffer_size       = gc_buffer_size;

		gc_buffer_attributes = NULL;
		gc_buffer_characters = NULL;
		gc_buffer_colorcodes = NULL;
		gc_buffer_tab_stops  = NULL;
		gc_buffer_columns    = 0;
		gc_buffer_rows       = 0;
		gc_buffer_size       = 0;

		VCPUTC_LOCK_UNLOCK( );
		splx( s );

		kfree( buffer_attributes, buffer_size );
		kfree( buffer_characters, buffer_size );
		kfree( buffer_colorcodes, buffer_size );
		kfree( buffer_tab_stops,  buffer_columns );
	}
	<span class="enscript-keyword">else</span>
	{
		VCPUTC_LOCK_UNLOCK( );
		splx( s );
	}

	<span class="enscript-keyword">if</span> ( enable )
	{
		<span class="enscript-keyword">if</span> ( vm_initialized )
		{
			buffer_columns = vinfo.v_columns;
			buffer_rows    = vinfo.v_rows;
			buffer_size    = buffer_columns * buffer_rows;

			<span class="enscript-keyword">if</span> ( buffer_size )
			{
				buffer_attributes = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc( buffer_size );
				buffer_characters = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc( buffer_size );
				buffer_colorcodes = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc( buffer_size );
				buffer_tab_stops  = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc( buffer_columns );

				<span class="enscript-keyword">if</span> ( buffer_attributes == NULL ||
				     buffer_characters == NULL ||
				     buffer_colorcodes == NULL ||
				     buffer_tab_stops  == NULL )
				{
					<span class="enscript-keyword">if</span> ( buffer_attributes ) kfree( buffer_attributes, buffer_size );
					<span class="enscript-keyword">if</span> ( buffer_characters ) kfree( buffer_characters, buffer_size );
					<span class="enscript-keyword">if</span> ( buffer_colorcodes ) kfree( buffer_colorcodes, buffer_size );
					<span class="enscript-keyword">if</span> ( buffer_tab_stops  ) kfree( buffer_tab_stops,  buffer_columns );

					buffer_attributes = NULL;
					buffer_characters = NULL;
					buffer_colorcodes = NULL;
					buffer_tab_stops  = NULL;
					buffer_columns = 0;
					buffer_rows    = 0;
					buffer_size    = 0;
				}
				<span class="enscript-keyword">else</span>
				{
					memset( buffer_attributes, ATTR_NONE, buffer_size );
					memset( buffer_characters, <span class="enscript-string">' '</span>, buffer_size );
					memset( buffer_colorcodes, COLOR_CODE_SET( 0, COLOR_FOREGROUND, TRUE ), buffer_size );
					memset( buffer_tab_stops, 0, buffer_columns );
				}
			}
		}

		s = splhigh( );
		VCPUTC_LOCK_LOCK( );

		gc_buffer_attributes = buffer_attributes;
		gc_buffer_characters = buffer_characters;
		gc_buffer_colorcodes = buffer_colorcodes;
		gc_buffer_tab_stops  = buffer_tab_stops;
		gc_buffer_columns    = buffer_columns;
		gc_buffer_rows       = buffer_rows;
		gc_buffer_size       = buffer_size;

		gc_reset_screen();

		VCPUTC_LOCK_UNLOCK( );
		splx( s );

		gc_ops.clear_screen(gc_x, gc_y, 0, vinfo.v_rows, 2);
		gc_ops.show_cursor(gc_x, gc_y);

		gc_ops.enable(TRUE);
		gc_enabled           = TRUE;
		disableConsoleOutput = FALSE;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_hide_cursor</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy)
{
	<span class="enscript-keyword">if</span> ( xx &lt; gc_buffer_columns &amp;&amp; yy &lt; gc_buffer_rows )
	{
		uint32_t index = (yy * gc_buffer_columns) + xx;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> attribute = gc_buffer_attributes[index];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> character = gc_buffer_characters[index];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> colorcode = gc_buffer_colorcodes[index];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> colorcodesave = gc_color_code;

		gc_update_color(COLOR_CODE_GET(colorcode, TRUE ), TRUE );
		gc_update_color(COLOR_CODE_GET(colorcode, FALSE), FALSE);

		gc_ops.paint_char(xx, yy, character, attribute, 0, 0);

		gc_update_color(COLOR_CODE_GET(colorcodesave, TRUE ), TRUE );
		gc_update_color(COLOR_CODE_GET(colorcodesave, FALSE), FALSE);
	}
	<span class="enscript-keyword">else</span>
	{
		gc_ops.hide_cursor(xx, yy);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_initialize</span>(<span class="enscript-type">struct</span> vc_info * info)
{
	<span class="enscript-keyword">if</span> ( gc_initialized == FALSE )
	{
		<span class="enscript-comment">/* Init our lock */</span>
		VCPUTC_LOCK_INIT();

		gc_initialized = TRUE;
	}

	gc_ops.initialize(info);

	gc_reset_vt100();
	gc_x = gc_y = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_paint_char</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch, <span class="enscript-type">int</span> attrs)
{
	<span class="enscript-keyword">if</span> ( xx &lt; gc_buffer_columns &amp;&amp; yy &lt; gc_buffer_rows )
	{
		uint32_t index = (yy * gc_buffer_columns) + xx;
 
		gc_buffer_attributes[index] = attrs;
		gc_buffer_characters[index] = ch;
		gc_buffer_colorcodes[index] = gc_color_code;
	}

	gc_ops.paint_char(xx, yy, ch, attrs, 0, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_putchar</span>(<span class="enscript-type">char</span> ch)
{
	<span class="enscript-keyword">if</span> (!ch) {
		<span class="enscript-keyword">return</span>;	<span class="enscript-comment">/* ignore null characters */</span>
	}
	<span class="enscript-keyword">switch</span> (gc_vt100state) {
		<span class="enscript-reference">default</span>:gc_vt100state = ESnormal;	<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESnormal</span>:
		gc_putc_normal(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESesc</span>:
		gc_putc_esc(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESsquare</span>:
		gc_putc_square(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESgetpars</span>:
		gc_putc_getpars(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESgotpars</span>:
		gc_putc_gotpars(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESask</span>:
		gc_putc_askcmd(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EScharsize</span>:
		gc_putc_charsizecmd(ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESsetG0</span>:
		gc_putc_charsetcmd(0, ch);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESsetG1</span>:
		gc_putc_charsetcmd(1, ch);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (gc_x &gt;= vinfo.v_columns) {
		<span class="enscript-keyword">if</span> (0 == vinfo.v_columns)
			gc_x = 0;
		<span class="enscript-keyword">else</span>
			gc_x = vinfo.v_columns - 1;
	}
	<span class="enscript-keyword">if</span> (gc_y &gt;= vinfo.v_rows) {
		<span class="enscript-keyword">if</span> (0 == vinfo.v_rows)
			gc_y = 0;
		<span class="enscript-keyword">else</span>
			gc_y = vinfo.v_rows - 1;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_putc_askcmd</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	<span class="enscript-keyword">if</span> (ch &gt;= <span class="enscript-string">'0'</span> &amp;&amp; ch &lt;= <span class="enscript-string">'9'</span>) {
		gc_par[gc_numpars] = (10*gc_par[gc_numpars]) + (ch-<span class="enscript-string">'0'</span>);
		<span class="enscript-keyword">return</span>;
	}
	gc_vt100state = ESnormal;

	<span class="enscript-keyword">switch</span> (gc_par[0]) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
			gc_relative_origin = ch == <span class="enscript-string">'h'</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:	<span class="enscript-comment">/* wrap around mode h=1, l=0*/</span>
			gc_wrap_mode = ch == <span class="enscript-string">'h'</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_putc_charsetcmd</span>(<span class="enscript-type">int</span> charset, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	gc_vt100state = ESnormal;

	<span class="enscript-keyword">switch</span> (ch) {
		<span class="enscript-keyword">case</span> <span class="enscript-string">'A'</span> :
		<span class="enscript-keyword">case</span> <span class="enscript-string">'B'</span> :
		<span class="enscript-reference">default</span>:
			gc_charset[charset] = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'0'</span> :	<span class="enscript-comment">/* Graphic characters */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-string">'2'</span> :
			gc_charset[charset] = 0x21;
			<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_putc_charsizecmd</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	gc_vt100state = ESnormal;

	<span class="enscript-keyword">switch</span> (ch) {
		<span class="enscript-keyword">case</span> <span class="enscript-string">'3'</span> :
		<span class="enscript-keyword">case</span> <span class="enscript-string">'4'</span> :
		<span class="enscript-keyword">case</span> <span class="enscript-string">'5'</span> :
		<span class="enscript-keyword">case</span> <span class="enscript-string">'6'</span> :
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'8'</span> :	<span class="enscript-comment">/* fill 'E's */</span>
			{
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, yy;
				<span class="enscript-keyword">for</span> (yy = 0; yy &lt; vinfo.v_rows; yy++)
					<span class="enscript-keyword">for</span> (xx = 0; xx &lt; vinfo.v_columns; xx++)
						gc_paint_char(xx, yy, <span class="enscript-string">'E'</span>, ATTR_NONE);
			}
			<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_putc_esc</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	gc_vt100state = ESnormal;

	<span class="enscript-keyword">switch</span> (ch) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'['</span>:
		gc_vt100state = ESsquare;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>:		<span class="enscript-comment">/* Reset terminal 	 */</span>
		gc_reset_vt100();
		gc_clear_screen(gc_x, gc_y, 0, vinfo.v_rows, 2);
		gc_x = gc_y = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'D'</span>:		<span class="enscript-comment">/* Line feed		 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-string">'E'</span>:
		<span class="enscript-keyword">if</span> (gc_y &gt;= gc_scrreg_bottom -1) {
			gc_scroll_up(1, gc_scrreg_top, gc_scrreg_bottom);
			gc_y = gc_scrreg_bottom - 1;
		} <span class="enscript-keyword">else</span> {
			gc_y++;
		}
		<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">'E'</span>) gc_x = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'H'</span>:		<span class="enscript-comment">/* Set tab stop		 */</span>
		gc_set_tab_stop(gc_x, TRUE);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'M'</span>:		<span class="enscript-comment">/* Cursor up		 */</span>
		<span class="enscript-keyword">if</span> (gc_y &lt;= gc_scrreg_top) {
			gc_scroll_down(1, gc_scrreg_top, gc_scrreg_bottom);
			gc_y = gc_scrreg_top;
		} <span class="enscript-keyword">else</span> {
			gc_y--;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'&gt;'</span>:
		gc_reset_vt100();
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'7'</span>:		<span class="enscript-comment">/* Save cursor		 */</span>
		gc_savex = gc_x;
		gc_savey = gc_y;
		gc_saveattr = gc_attr;
		gc_save_charset_s = gc_charset_select;
		gc_charset_save[0] = gc_charset[0];
		gc_charset_save[1] = gc_charset[1];
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'8'</span>:		<span class="enscript-comment">/* Restore cursor	 */</span>
		gc_x = gc_savex;
		gc_y = gc_savey;
		gc_attr = gc_saveattr;
		gc_charset_select = gc_save_charset_s;
		gc_charset[0] = gc_charset_save[0];
		gc_charset[1] = gc_charset_save[1];
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'Z'</span>:		<span class="enscript-comment">/* return terminal ID */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'#'</span>:		<span class="enscript-comment">/* change characters height */</span>
		gc_vt100state = EScharsize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'('</span>:
		gc_vt100state = ESsetG0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">')'</span>:		<span class="enscript-comment">/* character set sequence */</span>
		gc_vt100state = ESsetG1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'='</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* Rest not supported */</span>
		<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_putc_getpars</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">'?'</span>) {
		gc_vt100state = ESask;
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">'['</span>) {
		gc_vt100state = ESnormal;
		<span class="enscript-comment">/* Not supported */</span>
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">';'</span> &amp;&amp; gc_numpars &lt; MAXPARS - 1) {
		gc_numpars++;
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">if</span> (ch &gt;= <span class="enscript-string">'0'</span> &amp;&amp; ch &lt;= <span class="enscript-string">'9'</span>) {
			gc_par[gc_numpars] *= 10;
			gc_par[gc_numpars] += ch - <span class="enscript-string">'0'</span>;
		} <span class="enscript-keyword">else</span> {
			gc_numpars++;
			gc_vt100state = ESgotpars;
			gc_putc_gotpars(ch);
		}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_putc_gotpars</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (ch &lt; <span class="enscript-string">' '</span>) {
		<span class="enscript-comment">/* special case for vttest for handling cursor
		   movement in escape sequences */</span>
		gc_putc_normal(ch);
		gc_vt100state = ESgotpars;
		<span class="enscript-keyword">return</span>;
	}
	gc_vt100state = ESnormal;
	<span class="enscript-keyword">switch</span> (ch) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'A'</span>:		<span class="enscript-comment">/* Up			 */</span>
		gc_y -= gc_par[0] ? gc_par[0] : 1;
		<span class="enscript-keyword">if</span> (gc_y &lt; gc_scrreg_top)
			gc_y = gc_scrreg_top;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'B'</span>:		<span class="enscript-comment">/* Down			 */</span>
		gc_y += gc_par[0] ? gc_par[0] : 1;
		<span class="enscript-keyword">if</span> (gc_y &gt;= gc_scrreg_bottom)
			gc_y = gc_scrreg_bottom - 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'C'</span>:		<span class="enscript-comment">/* Right		 */</span>
		gc_x += gc_par[0] ? gc_par[0] : 1;
		<span class="enscript-keyword">if</span> (gc_x &gt;= vinfo.v_columns)
			gc_x = vinfo.v_columns-1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'D'</span>:		<span class="enscript-comment">/* Left			 */</span>
		<span class="enscript-keyword">if</span> (gc_par[0] &gt; gc_x)
			gc_x = 0;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gc_par[0])
			gc_x -= gc_par[0];
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gc_x)
			--gc_x;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'H'</span>:		<span class="enscript-comment">/* Set cursor position	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-string">'f'</span>:
		gc_x = gc_par[1] ? gc_par[1] - 1 : 0;
		gc_y = gc_par[0] ? gc_par[0] - 1 : 0;
		<span class="enscript-keyword">if</span> (gc_relative_origin)
			gc_y += gc_scrreg_top;
		gc_hanging_cursor = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'X'</span>:		<span class="enscript-comment">/* clear p1 characters */</span>
		<span class="enscript-keyword">if</span> (gc_numpars) {
			<span class="enscript-keyword">for</span> (i = gc_x; i &lt; gc_x + gc_par[0]; i++)
				gc_paint_char(i, gc_y, <span class="enscript-string">' '</span>, ATTR_NONE);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'J'</span>:		<span class="enscript-comment">/* Clear part of screen	 */</span>
		gc_clear_screen(gc_x, gc_y, 0, vinfo.v_rows, gc_par[0]);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'K'</span>:		<span class="enscript-comment">/* Clear part of line	 */</span>
		gc_clear_line(gc_x, gc_y, gc_par[0]);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'g'</span>:		<span class="enscript-comment">/* tab stops	 	 */</span>
		<span class="enscript-keyword">switch</span> (gc_par[0]) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:	<span class="enscript-comment">/* reset tab stops */</span>
				<span class="enscript-comment">/* gc_reset_tabs(); */</span>
				<span class="enscript-keyword">break</span>;				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:	<span class="enscript-comment">/* Clear every tabs */</span>
				{
					<span class="enscript-keyword">for</span> (i = 0; i &lt;= vinfo.v_columns; i++)
						gc_set_tab_stop(i, FALSE);
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
				gc_set_tab_stop(gc_x, FALSE);
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'m'</span>:		<span class="enscript-comment">/* Set attribute	 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; gc_numpars; i++) {
			<span class="enscript-keyword">switch</span> (gc_par[i]) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
				gc_attr = ATTR_NONE;
				gc_update_color(COLOR_BACKGROUND, FALSE);
				gc_update_color(COLOR_FOREGROUND, TRUE );	
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
				gc_attr |= ATTR_BOLD;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
				gc_attr |= ATTR_UNDER;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
				gc_attr |= ATTR_REVERSE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">22</span>:
				gc_attr &amp;= ~ATTR_BOLD;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">24</span>:
				gc_attr &amp;= ~ATTR_UNDER;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">27</span>:
				gc_attr &amp;= ~ATTR_REVERSE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">25</span>:	<span class="enscript-comment">/* blink/no blink */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> (gc_par[i] &gt;= 30 &amp;&amp; gc_par[i] &lt;= 37)
					gc_update_color(gc_par[i] - 30, TRUE);
				<span class="enscript-keyword">if</span> (gc_par[i] &gt;= 40 &amp;&amp; gc_par[i] &lt;= 47)
					gc_update_color(gc_par[i] - 40, FALSE);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'r'</span>:		<span class="enscript-comment">/* Set scroll region	 */</span>
		gc_x = gc_y = 0;
		<span class="enscript-comment">/* ensure top &lt; bottom, and both within limits */</span>
		<span class="enscript-keyword">if</span> ((gc_numpars &gt; 0) &amp;&amp; (gc_par[0] &lt; vinfo.v_rows)) {
			gc_scrreg_top = gc_par[0] ? gc_par[0] - 1 : 0;
		} <span class="enscript-keyword">else</span> {
			gc_scrreg_top = 0;
		}
		<span class="enscript-keyword">if</span> ((gc_numpars &gt; 1) &amp;&amp; (gc_par[1] &lt;= vinfo.v_rows) &amp;&amp; (gc_par[1] &gt; gc_par[0])) {
			gc_scrreg_bottom = gc_par[1];
			<span class="enscript-keyword">if</span> (gc_scrreg_bottom &gt; vinfo.v_rows)
				gc_scrreg_bottom = vinfo.v_rows;
		} <span class="enscript-keyword">else</span> {
			gc_scrreg_bottom = vinfo.v_rows;
		}
		<span class="enscript-keyword">if</span> (gc_relative_origin)
			gc_y = gc_scrreg_top;
		<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_putc_normal</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	<span class="enscript-keyword">switch</span> (ch) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'\a'</span>:		<span class="enscript-comment">/* Beep			 */</span>
        <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">127</span>:		<span class="enscript-comment">/* Delete		 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-string">'\b'</span>:		<span class="enscript-comment">/* Backspace		 */</span>
		<span class="enscript-keyword">if</span> (gc_hanging_cursor) {
			gc_hanging_cursor = 0;
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">if</span> (gc_x &gt; 0) {
				gc_x--;
			}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'\t'</span>:		<span class="enscript-comment">/* Tab			 */</span>
		<span class="enscript-keyword">if</span> (gc_buffer_tab_stops) <span class="enscript-keyword">while</span> (gc_x &lt; vinfo.v_columns &amp;&amp; !gc_is_tab_stop(++gc_x));

		<span class="enscript-keyword">if</span> (gc_x &gt;= vinfo.v_columns)
			gc_x = vinfo.v_columns-1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0x0b</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0x0c</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-string">'\n'</span>:		<span class="enscript-comment">/* Line feed		 */</span>
		<span class="enscript-keyword">if</span> (gc_y &gt;= gc_scrreg_bottom -1 ) {
			gc_scroll_up(1, gc_scrreg_top, gc_scrreg_bottom);
			gc_y = gc_scrreg_bottom - 1;
		} <span class="enscript-keyword">else</span> {
			gc_y++;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'\r'</span>:		<span class="enscript-comment">/* Carriage return	 */</span>
		gc_x = 0;
		gc_hanging_cursor = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0x0e</span>:  <span class="enscript-comment">/* Select G1 charset (Control-N) */</span>
		gc_charset_select = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0x0f</span>:  <span class="enscript-comment">/* Select G0 charset (Control-O) */</span>
		gc_charset_select = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0x18</span> : <span class="enscript-comment">/* CAN : cancel */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0x1A</span> : <span class="enscript-comment">/* like cancel */</span>
			<span class="enscript-comment">/* well, i do nothing here, may be later */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> '\033':		<span class="enscript-comment">/* Escape		 */</span>
		gc_vt100state = ESesc;
		gc_hanging_cursor = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> (ch &gt;= <span class="enscript-string">' '</span>) {
			<span class="enscript-keyword">if</span> (gc_hanging_cursor) {
				gc_x = 0;
				<span class="enscript-keyword">if</span> (gc_y &gt;= gc_scrreg_bottom -1 ) {
					gc_scroll_up(1, gc_scrreg_top, gc_scrreg_bottom);
					gc_y = gc_scrreg_bottom - 1;
				} <span class="enscript-keyword">else</span> {
					gc_y++;
				}
				gc_hanging_cursor = 0;
			}
			gc_paint_char(gc_x, gc_y, (ch &gt;= 0x60 &amp;&amp; ch &lt;= 0x7f) ? ch + gc_charset[gc_charset_select]
								: ch, gc_attr);
			<span class="enscript-keyword">if</span> (gc_x == vinfo.v_columns - 1) {
				gc_hanging_cursor = gc_wrap_mode;
			} <span class="enscript-keyword">else</span> {
				gc_x++;
			}
		}
		<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_putc_square</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
	<span class="enscript-type">int</span>     i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXPARS; i++) {
		gc_par[i] = 0;
	}

	gc_numpars = 0;
	gc_vt100state = ESgetpars;

	gc_putc_getpars(ch);

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_reset_screen</span>(<span class="enscript-type">void</span>)
{
	gc_reset_vt100();
	gc_x = gc_y = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_reset_tabs</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">if</span> (!gc_buffer_tab_stops) <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vinfo.v_columns; i++) {
		gc_buffer_tab_stops[i] = ((i % 8) == 0);
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_set_tab_stop</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> column, boolean_t enabled)
{
	<span class="enscript-keyword">if</span> (gc_buffer_tab_stops &amp;&amp; (column &lt; vinfo.v_columns)) {
		gc_buffer_tab_stops[column] = enabled;
	}
}

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">gc_is_tab_stop</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> column)
{
	<span class="enscript-keyword">if</span> (gc_buffer_tab_stops == NULL)
		<span class="enscript-keyword">return</span> ((column % 8) == 0);
	<span class="enscript-keyword">if</span> (column &lt; vinfo.v_columns)
		<span class="enscript-keyword">return</span> gc_buffer_tab_stops[column];
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_reset_vt100</span>(<span class="enscript-type">void</span>)
{
	gc_reset_tabs();
	gc_scrreg_top    = 0;
	gc_scrreg_bottom = vinfo.v_rows;
	gc_attr = ATTR_NONE;
	gc_charset[0] = gc_charset[1] = 0;
	gc_charset_select = 0;
	gc_wrap_mode = 1;
	gc_relative_origin = 0;
	gc_update_color(COLOR_BACKGROUND, FALSE);
	gc_update_color(COLOR_FOREGROUND, TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_scroll_down</span>(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom)
{
	<span class="enscript-keyword">if</span> (!gc_buffer_size) <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ( bottom &lt;= gc_buffer_rows )
	{
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> colorcodesave = gc_color_code;
		uint32_t column, row;
		uint32_t index, jump;

		jump = num * gc_buffer_columns;

		<span class="enscript-keyword">for</span> ( row = bottom - 1 ; row &gt;= top + num ; row-- )
		{
			index = row * gc_buffer_columns;

			<span class="enscript-keyword">for</span> ( column = 0 ; column &lt; gc_buffer_columns ; index++, column++ )
			{
				<span class="enscript-keyword">if</span> ( gc_buffer_attributes[index] != gc_buffer_attributes[index - jump] || 
				     gc_buffer_characters[index] != gc_buffer_characters[index - jump] || 
				     gc_buffer_colorcodes[index] != gc_buffer_colorcodes[index - jump] )
				{
					<span class="enscript-keyword">if</span> ( gc_color_code != gc_buffer_colorcodes[index - jump] )
					{
						gc_update_color(COLOR_CODE_GET(gc_buffer_colorcodes[index - jump], TRUE ), TRUE );
						gc_update_color(COLOR_CODE_GET(gc_buffer_colorcodes[index - jump], FALSE), FALSE);
					}

					<span class="enscript-keyword">if</span> ( gc_buffer_colorcodes[index] != gc_buffer_colorcodes[index - jump] )
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> gc_buffer_characters[index - jump],
						                   <span class="enscript-comment">/* attrs          */</span> gc_buffer_attributes[index - jump],
						                   <span class="enscript-comment">/* ch_previous    */</span> 0,
						                   <span class="enscript-comment">/* attrs_previous */</span> 0 );
					}
					<span class="enscript-keyword">else</span>
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> gc_buffer_characters[index - jump],
						                   <span class="enscript-comment">/* attrs          */</span> gc_buffer_attributes[index - jump],
						                   <span class="enscript-comment">/* ch_previous    */</span> gc_buffer_characters[index],
						                   <span class="enscript-comment">/* attrs_previous */</span> gc_buffer_attributes[index] );
					}

					gc_buffer_attributes[index] = gc_buffer_attributes[index - jump];
					gc_buffer_characters[index] = gc_buffer_characters[index - jump];
					gc_buffer_colorcodes[index] = gc_buffer_colorcodes[index - jump];
				}
			}
		}

		<span class="enscript-keyword">if</span> ( colorcodesave != gc_color_code )
		{
			gc_update_color(COLOR_CODE_GET(colorcodesave, TRUE ), TRUE );
			gc_update_color(COLOR_CODE_GET(colorcodesave, FALSE), FALSE);
		}

		<span class="enscript-comment">/* Now set the freed up lines to the background colour */</span>

		<span class="enscript-keyword">for</span> ( row = top ; row &lt; top + num ; row++ )
		{
			index = row * gc_buffer_columns;

			<span class="enscript-keyword">for</span> ( column = 0 ; column &lt; gc_buffer_columns ; index++, column++ )
			{
				<span class="enscript-keyword">if</span> ( gc_buffer_attributes[index] != ATTR_NONE     || 
				     gc_buffer_characters[index] != <span class="enscript-string">' '</span>           || 
				     gc_buffer_colorcodes[index] != gc_color_code )
				{
					<span class="enscript-keyword">if</span> ( gc_buffer_colorcodes[index] != gc_color_code )
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> <span class="enscript-string">' '</span>,
						                   <span class="enscript-comment">/* attrs          */</span> ATTR_NONE,
						                   <span class="enscript-comment">/* ch_previous    */</span> 0,
						                   <span class="enscript-comment">/* attrs_previous */</span> 0 );
					}
					<span class="enscript-keyword">else</span>
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> <span class="enscript-string">' '</span>,
						                   <span class="enscript-comment">/* attrs          */</span> ATTR_NONE,
						                   <span class="enscript-comment">/* ch_previous    */</span> gc_buffer_characters[index],
						                   <span class="enscript-comment">/* attrs_previous */</span> gc_buffer_attributes[index] );
					}

					gc_buffer_attributes[index] = ATTR_NONE;
					gc_buffer_characters[index] = <span class="enscript-string">' '</span>;
					gc_buffer_colorcodes[index] = gc_color_code;
				}
			}
		}
	}
	<span class="enscript-keyword">else</span>
	{
		gc_ops.scroll_down(num, top, bottom);

		<span class="enscript-comment">/* Now set the freed up lines to the background colour */</span>

		gc_clear_screen(vinfo.v_columns - 1, top + num - 1, top, bottom, 1);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">gc_scroll_up</span>(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bottom)
{
	<span class="enscript-keyword">if</span> (!gc_buffer_size) <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ( bottom &lt;= gc_buffer_rows )
	{
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> colorcodesave = gc_color_code;
		uint32_t column, row;
		uint32_t index, jump;

		jump = num * gc_buffer_columns;

		<span class="enscript-keyword">for</span> ( row = top ; row &lt; bottom - num ; row++ )
		{
			index = row * gc_buffer_columns;

			<span class="enscript-keyword">for</span> ( column = 0 ; column &lt; gc_buffer_columns ; index++, column++ )
			{
				<span class="enscript-keyword">if</span> ( gc_buffer_attributes[index] != gc_buffer_attributes[index + jump] || 
				     gc_buffer_characters[index] != gc_buffer_characters[index + jump] || 
				     gc_buffer_colorcodes[index] != gc_buffer_colorcodes[index + jump] )
				{
					<span class="enscript-keyword">if</span> ( gc_color_code != gc_buffer_colorcodes[index + jump] )
					{
						gc_update_color(COLOR_CODE_GET(gc_buffer_colorcodes[index + jump], TRUE ), TRUE );
						gc_update_color(COLOR_CODE_GET(gc_buffer_colorcodes[index + jump], FALSE), FALSE);
					}

					<span class="enscript-keyword">if</span> ( gc_buffer_colorcodes[index] != gc_buffer_colorcodes[index + jump] )
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> gc_buffer_characters[index + jump],
						                   <span class="enscript-comment">/* attrs          */</span> gc_buffer_attributes[index + jump],
						                   <span class="enscript-comment">/* ch_previous    */</span> 0,
						                   <span class="enscript-comment">/* attrs_previous */</span> 0 );
					}
					<span class="enscript-keyword">else</span>
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> gc_buffer_characters[index + jump],
						                   <span class="enscript-comment">/* attrs          */</span> gc_buffer_attributes[index + jump],
						                   <span class="enscript-comment">/* ch_previous    */</span> gc_buffer_characters[index],
						                   <span class="enscript-comment">/* attrs_previous */</span> gc_buffer_attributes[index] );
					}

					gc_buffer_attributes[index] = gc_buffer_attributes[index + jump];
					gc_buffer_characters[index] = gc_buffer_characters[index + jump];
					gc_buffer_colorcodes[index] = gc_buffer_colorcodes[index + jump];
				}
			}
		}

		<span class="enscript-keyword">if</span> ( colorcodesave != gc_color_code )
		{
			gc_update_color(COLOR_CODE_GET(colorcodesave, TRUE ), TRUE );
			gc_update_color(COLOR_CODE_GET(colorcodesave, FALSE), FALSE);
		}

		<span class="enscript-comment">/* Now set the freed up lines to the background colour */</span>

		<span class="enscript-keyword">for</span> ( row = bottom - num ; row &lt; bottom ; row++ )
		{
			index = row * gc_buffer_columns;

			<span class="enscript-keyword">for</span> ( column = 0 ; column &lt; gc_buffer_columns ; index++, column++ )
			{
				<span class="enscript-keyword">if</span> ( gc_buffer_attributes[index] != ATTR_NONE     || 
				     gc_buffer_characters[index] != <span class="enscript-string">' '</span>           || 
				     gc_buffer_colorcodes[index] != gc_color_code )
				{
					<span class="enscript-keyword">if</span> ( gc_buffer_colorcodes[index] != gc_color_code )
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> <span class="enscript-string">' '</span>,
						                   <span class="enscript-comment">/* attrs          */</span> ATTR_NONE,
						                   <span class="enscript-comment">/* ch_previous    */</span> 0,
						                   <span class="enscript-comment">/* attrs_previous */</span> 0 );
					}
					<span class="enscript-keyword">else</span>
					{
						gc_ops.paint_char( <span class="enscript-comment">/* xx             */</span> column,
						                   <span class="enscript-comment">/* yy             */</span> row,
						                   <span class="enscript-comment">/* ch             */</span> <span class="enscript-string">' '</span>,
						                   <span class="enscript-comment">/* attrs          */</span> ATTR_NONE,
						                   <span class="enscript-comment">/* ch_previous    */</span> gc_buffer_characters[index],
						                   <span class="enscript-comment">/* attrs_previous */</span> gc_buffer_attributes[index] );
					}

					gc_buffer_attributes[index] = ATTR_NONE;
					gc_buffer_characters[index] = <span class="enscript-string">' '</span>;
					gc_buffer_colorcodes[index] = gc_color_code;
				}
			}
		}
	}
	<span class="enscript-keyword">else</span>
	{
		gc_ops.scroll_up(num, top, bottom);

		<span class="enscript-comment">/* Now set the freed up lines to the background colour */</span>

		gc_clear_screen(0, bottom - num, top, bottom, 0);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_show_cursor</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy)
{
	<span class="enscript-keyword">if</span> ( xx &lt; gc_buffer_columns &amp;&amp; yy &lt; gc_buffer_rows )
	{
		uint32_t index = (yy * gc_buffer_columns) + xx;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> attribute = gc_buffer_attributes[index];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> character = gc_buffer_characters[index];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> colorcode = gc_buffer_colorcodes[index];
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> colorcodesave = gc_color_code;

		gc_update_color(COLOR_CODE_GET(colorcode, FALSE), TRUE );
		gc_update_color(COLOR_CODE_GET(colorcode, TRUE ), FALSE);

		gc_ops.paint_char(xx, yy, character, attribute, 0, 0);

		gc_update_color(COLOR_CODE_GET(colorcodesave, TRUE ), TRUE );
		gc_update_color(COLOR_CODE_GET(colorcodesave, FALSE), FALSE);
	}
	<span class="enscript-keyword">else</span>
	{
		gc_ops.show_cursor(xx, yy);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_update_color</span>(<span class="enscript-type">int</span> color, boolean_t fore)
{
	assert(gc_ops.update_color);

	gc_color_code = COLOR_CODE_SET(gc_color_code, color, fore);
	gc_ops.update_color(color, fore);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vcputc</span>(__unused <span class="enscript-type">int</span> l, __unused <span class="enscript-type">int</span> u, <span class="enscript-type">int</span> c)
{
	<span class="enscript-keyword">if</span> ( gc_initialized &amp;&amp; ( gc_enabled || debug_mode ) )
	{
		spl_t s;

		s = splhigh();
#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		x86_filter_TLB_coherency_interrupts(TRUE);
#<span class="enscript-reference">endif</span>
		VCPUTC_LOCK_LOCK();
		<span class="enscript-keyword">if</span> ( gc_enabled || debug_mode )
		{
			gc_hide_cursor(gc_x, gc_y);
			gc_putchar(c);
			gc_show_cursor(gc_x, gc_y);
		}
		VCPUTC_LOCK_UNLOCK();
#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		x86_filter_TLB_coherency_interrupts(FALSE);
#<span class="enscript-reference">endif</span>
		splx(s);
	}
}

<span class="enscript-comment">/*
 * Video Console (Back-End)
 * ------------------------
 */</span>
 
<span class="enscript-comment">/*
 * For the color support (Michel Pollet)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> vc_color_index_table[33] = 
	{  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2 };

<span class="enscript-type">static</span> uint32_t vc_colors[8][4] = {
	{ 0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000 },	<span class="enscript-comment">/* black */</span>
	{ 0x23232323, 0x7C007C00, 0x00FF0000, 0x3FF00000 },	<span class="enscript-comment">/* red	*/</span>
	{ 0xb9b9b9b9, 0x03e003e0, 0x0000FF00, 0x000FFC00 },	<span class="enscript-comment">/* green */</span>
	{ 0x05050505, 0x7FE07FE0, 0x00FFFF00, 0x3FFFFC00 },	<span class="enscript-comment">/* yellow */</span>
	{ 0xd2d2d2d2, 0x001f001f, 0x000000FF, 0x000003FF },	<span class="enscript-comment">/* blue	 */</span>
<span class="enscript-comment">//	{ 0x80808080, 0x31933193, 0x00666699, 0x00000000 },	/* blue	 */
</span>	{ 0x18181818, 0x7C1F7C1F, 0x00FF00FF, 0x3FF003FF },	<span class="enscript-comment">/* magenta */</span>
	{ 0xb4b4b4b4, 0x03FF03FF, 0x0000FFFF, 0x000FFFFF },	<span class="enscript-comment">/* cyan	*/</span>
	{ 0x00000000, 0x7FFF7FFF, 0x00FFFFFF, 0x3FFFFFFF }	<span class="enscript-comment">/* white */</span>
};

<span class="enscript-type">static</span> uint32_t vc_color_fore = 0;
<span class="enscript-type">static</span> uint32_t vc_color_back = 0;

<span class="enscript-comment">/* 
 * New Rendering code from Michel Pollet
 */</span>

<span class="enscript-comment">/* Rendered Font Buffer */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *vc_rendered_font = NULL;

<span class="enscript-comment">/* Rendered Font Size */</span>
<span class="enscript-type">static</span> uint32_t vc_rendered_font_size = 0;

<span class="enscript-comment">/* Size of a character in the table (bytes) */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> vc_rendered_char_size = 0;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REN_MAX_DEPTH</span>	32
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> vc_rendered_char[ISO_CHAR_HEIGHT * ((REN_MAX_DEPTH / 8) * ISO_CHAR_WIDTH)];

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">internal_set_progressmeter</span>(<span class="enscript-type">int</span> new_value);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">internal_enable_progressmeter</span>(<span class="enscript-type">int</span> new_value);

<span class="enscript-type">enum</span>
{
    kProgressMeterOff    = FALSE,
    kProgressMeterUser   = TRUE,
    kProgressMeterKernel = 3,
};
<span class="enscript-type">enum</span>
{
    kProgressMeterMax    = 1024,
    kProgressMeterEnd    = 512,
};


<span class="enscript-type">static</span> boolean_t vc_progress_white = 
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_VC_PROGRESS_WHITE</span>
                                     TRUE;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !CONFIG_VC_PROGRESS_WHITE */</span>
                                     FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_VC_PROGRESS_WHITE */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> vc_acquire_delay = kProgressAcquireDelay;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vc_clear_screen</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scrreg_top,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scrreg_bottom, <span class="enscript-type">int</span> which)
{
	uint32_t *p, *endp, *row;
	<span class="enscript-type">int</span>      linelongs, col;
	<span class="enscript-type">int</span>      rowline, rowlongs;

	<span class="enscript-keyword">if</span>(!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;

	linelongs = vinfo.v_rowbytes * (ISO_CHAR_HEIGHT &gt;&gt; 2);
	rowline = vinfo.v_rowscanbytes &gt;&gt; 2;
	rowlongs = vinfo.v_rowbytes &gt;&gt; 2;

	p = (uint32_t*) vinfo.v_baseaddr;
	endp = (uint32_t*) vinfo.v_baseaddr;

	<span class="enscript-keyword">switch</span> (which) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:		<span class="enscript-comment">/* To end of screen	 */</span>
		gc_clear_line(xx, yy, 0);
		<span class="enscript-keyword">if</span> (yy &lt; scrreg_bottom - 1) {
			p += (yy + 1) * linelongs;
			endp += scrreg_bottom * linelongs;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:		<span class="enscript-comment">/* To start of screen	 */</span>
		gc_clear_line(xx, yy, 1);
		<span class="enscript-keyword">if</span> (yy &gt; scrreg_top) {
			p += scrreg_top * linelongs;
			endp += yy * linelongs;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:		<span class="enscript-comment">/* Whole screen		 */</span>
		p += scrreg_top * linelongs;
		<span class="enscript-keyword">if</span> (scrreg_bottom == vinfo.v_rows) {
			endp += rowlongs * vinfo.v_height;
		} <span class="enscript-keyword">else</span> {
			endp += scrreg_bottom * linelongs;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">for</span> (row = p ; row &lt; endp ; row += rowlongs) {
		<span class="enscript-keyword">for</span> (col = 0; col &lt; rowline; col++) 
			*(row+col) = vc_color_back;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_render_char</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *renderptr, <span class="enscript-type">short</span> newdepth)
{
	<span class="enscript-type">union</span> {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>  *charptr;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *shortptr;
		uint32_t  *longptr;
	} current; 	<span class="enscript-comment">/* current place in rendered font, multiple types. */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *theChar;	<span class="enscript-comment">/* current char in iso_font */</span>
	<span class="enscript-type">int</span> line;

	current.charptr = renderptr;
	theChar = iso_font + (ch * ISO_CHAR_HEIGHT);

	<span class="enscript-keyword">for</span> (line = 0; line &lt; ISO_CHAR_HEIGHT; line++) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> mask = 1;
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">switch</span> (newdepth) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>: 
				*current.charptr++ = (*theChar &amp; mask) ? 0xFF : 0;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">16</span>:
				*current.shortptr++ = (*theChar &amp; mask) ? 0xFFFF : 0;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">30</span>: 
			<span class="enscript-keyword">case</span> <span class="enscript-reference">32</span>: 
				*current.longptr++ = (*theChar &amp; mask) ? 0xFFFFFFFF : 0;
				<span class="enscript-keyword">break</span>;
			}
			mask &lt;&lt;= 1;
		} <span class="enscript-keyword">while</span> (mask);	<span class="enscript-comment">/* while the single bit drops to the right */</span>
		theChar++;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_paint_char_8</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch, <span class="enscript-type">int</span> attrs,
		__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch_previous, __unused <span class="enscript-type">int</span> attrs_previous)
{
	uint32_t *theChar;
	uint32_t *where;
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">if</span> (vc_rendered_font) {
		theChar = (uint32_t*)(vc_rendered_font + (ch * vc_rendered_char_size));
	} <span class="enscript-keyword">else</span> {
		vc_render_char(ch, vc_rendered_char, 8);
		theChar = (uint32_t*)(vc_rendered_char);
	}
	where = (uint32_t*)(vinfo.v_baseaddr + 
					(yy * ISO_CHAR_HEIGHT * vinfo.v_rowbytes) + 
					(xx * ISO_CHAR_WIDTH));

	<span class="enscript-keyword">if</span> (!attrs) <span class="enscript-keyword">for</span> (i = 0; i &lt; ISO_CHAR_HEIGHT; i++) {	<span class="enscript-comment">/* No attr? FLY !*/</span>
		uint32_t *store = where;
		<span class="enscript-type">int</span> x;
		<span class="enscript-keyword">for</span> (x = 0; x &lt; 2; x++) {
			uint32_t val = *theChar++;
			val = (vc_color_back &amp; ~val) | (vc_color_fore &amp; val);
			*store++ = val;
		}
		
		where = (uint32_t*)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (i = 0; i &lt; ISO_CHAR_HEIGHT; i++) {	<span class="enscript-comment">/* a little slower */</span>
		uint32_t *store = where, lastpixel = 0;
		<span class="enscript-type">int</span> x;
		<span class="enscript-keyword">for</span> (x = 0 ; x &lt; 2; x++) {
			uint32_t val = *theChar++, save = val;
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_BOLD) {	<span class="enscript-comment">/* bold support */</span>
				<span class="enscript-keyword">if</span> (lastpixel &amp;&amp; !(save &amp; 0xFF000000))
					val |= 0xff000000;
				<span class="enscript-keyword">if</span> ((save &amp; 0xFFFF0000) == 0xFF000000)
					val |= 0x00FF0000;
				<span class="enscript-keyword">if</span> ((save &amp; 0x00FFFF00) == 0x00FF0000)
					val |= 0x0000FF00;
				<span class="enscript-keyword">if</span> ((save &amp; 0x0000FFFF) == 0x0000FF00)
					val |= 0x000000FF;
			}
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_REVERSE) val = ~val;
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_UNDER &amp;&amp;  i == ISO_CHAR_HEIGHT-1) val = ~val;

			val = (vc_color_back &amp; ~val) | (vc_color_fore &amp; val);
			*store++ = val;
			lastpixel = save &amp; 0xff;
		}
		
		where = (uint32_t*)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);		
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_paint_char_16</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch, <span class="enscript-type">int</span> attrs,
		 __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch_previous,
		 __unused <span class="enscript-type">int</span> attrs_previous) 
{
	uint32_t *theChar;
	uint32_t *where;
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">if</span> (vc_rendered_font) {
		theChar = (uint32_t*)(vc_rendered_font + (ch * vc_rendered_char_size));
	} <span class="enscript-keyword">else</span> {
		vc_render_char(ch, vc_rendered_char, 16);
		theChar = (uint32_t*)(vc_rendered_char);
	}
	where = (uint32_t*)(vinfo.v_baseaddr + 
				 (yy * ISO_CHAR_HEIGHT * vinfo.v_rowbytes) + 
				 (xx * ISO_CHAR_WIDTH * 2));

	<span class="enscript-keyword">if</span> (!attrs) <span class="enscript-keyword">for</span> (i = 0; i &lt; ISO_CHAR_HEIGHT; i++) {	<span class="enscript-comment">/* No attrs ? FLY ! */</span>
		uint32_t *store = where;
		<span class="enscript-type">int</span> x;
		<span class="enscript-keyword">for</span> (x = 0; x &lt; 4; x++) {
			uint32_t val = *theChar++;
			val = (vc_color_back &amp; ~val) | (vc_color_fore &amp; val);
			*store++ = val;
		}
		
		where = (uint32_t*)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (i = 0; i &lt; ISO_CHAR_HEIGHT; i++) { <span class="enscript-comment">/* a little bit slower */</span>
		uint32_t *store = where, lastpixel = 0;
		<span class="enscript-type">int</span> x;
		<span class="enscript-keyword">for</span> (x = 0 ; x &lt; 4; x++) {
			uint32_t val = *theChar++, save = val;
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_BOLD) {	<span class="enscript-comment">/* bold support */</span>
				<span class="enscript-keyword">if</span> (save == 0xFFFF0000) val |= 0xFFFF;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lastpixel &amp;&amp; !(save &amp; 0xFFFF0000))
					val |= 0xFFFF0000;
			}
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_REVERSE) val = ~val;
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_UNDER &amp;&amp;  i == ISO_CHAR_HEIGHT-1) val = ~val;

			val = (vc_color_back &amp; ~val) | (vc_color_fore &amp; val);

			*store++ = val;
			lastpixel = save &amp; 0x7fff;
		}
		
		where = (uint32_t*)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);		
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_paint_char_32</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch, <span class="enscript-type">int</span> attrs,
		 <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch_previous, <span class="enscript-type">int</span> attrs_previous) 
{
	uint32_t *theChar;
	uint32_t *theCharPrevious;
	uint32_t *where;
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">if</span> (vc_rendered_font) {
		theChar = (uint32_t*)(vc_rendered_font + (ch * vc_rendered_char_size));
		theCharPrevious = (uint32_t*)(vc_rendered_font + (ch_previous * vc_rendered_char_size));
	} <span class="enscript-keyword">else</span> {
		vc_render_char(ch, vc_rendered_char, 32);
		theChar = (uint32_t*)(vc_rendered_char);
		theCharPrevious = NULL;
	}
	<span class="enscript-keyword">if</span> (!ch_previous) {
		theCharPrevious = NULL;
	}
	<span class="enscript-keyword">if</span> (attrs_previous) {
		theCharPrevious = NULL;
	}
	where = (uint32_t*)(vinfo.v_baseaddr + 
					(yy * ISO_CHAR_HEIGHT * vinfo.v_rowbytes) + 
					(xx * ISO_CHAR_WIDTH * 4));

	<span class="enscript-keyword">if</span> (!attrs) <span class="enscript-keyword">for</span> (i = 0; i &lt; ISO_CHAR_HEIGHT; i++) {	<span class="enscript-comment">/* No attrs ? FLY ! */</span>
		uint32_t *store = where;
		<span class="enscript-type">int</span> x;
		<span class="enscript-keyword">for</span> (x = 0; x &lt; 8; x++) {
			uint32_t val = *theChar++;
			<span class="enscript-keyword">if</span> (theCharPrevious == NULL || val != *theCharPrevious++ ) {
				val = (vc_color_back &amp; ~val) | (vc_color_fore &amp; val);
				*store++ = val;
			} <span class="enscript-keyword">else</span> {
				store++;
			}
		}
		
		where = (uint32_t *)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (i = 0; i &lt; ISO_CHAR_HEIGHT; i++) {	<span class="enscript-comment">/* a little slower */</span>
		uint32_t *store = where, lastpixel = 0;
		<span class="enscript-type">int</span> x;
		<span class="enscript-keyword">for</span> (x = 0 ; x &lt; 8; x++) {
			uint32_t val = *theChar++, save = val;
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_BOLD) {	<span class="enscript-comment">/* bold support */</span>
				<span class="enscript-keyword">if</span> (lastpixel &amp;&amp; !save)
					val = 0xFFFFFFFF;
			}
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_REVERSE) val = ~val;
			<span class="enscript-keyword">if</span> (attrs &amp; ATTR_UNDER &amp;&amp;  i == ISO_CHAR_HEIGHT-1) val = ~val;

			val = (vc_color_back &amp; ~val) | (vc_color_fore &amp; val);
			*store++ = val;
			lastpixel = save;
		}
		
		where = (uint32_t*)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);		
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_paint_char</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch, <span class="enscript-type">int</span> attrs,
	      <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch_previous, <span class="enscript-type">int</span> attrs_previous)
{
	<span class="enscript-keyword">if</span>(!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span>(vinfo.v_depth) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
		vc_paint_char_8(xx, yy, ch, attrs, ch_previous, attrs_previous);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">16</span>:
		vc_paint_char_16(xx, yy, ch, attrs, ch_previous,
				 attrs_previous);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">30</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">32</span>:
		vc_paint_char_32(xx, yy, ch, attrs, ch_previous,
				 attrs_previous);
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_render_font</span>(<span class="enscript-type">short</span> newdepth)
{
	<span class="enscript-type">static</span> <span class="enscript-type">short</span> olddepth = 0;

	<span class="enscript-type">int</span> charindex;	<span class="enscript-comment">/* index in ISO font */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *rendered_font;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rendered_font_size;
	<span class="enscript-type">int</span> rendered_char_size;
	spl_t s;

	<span class="enscript-keyword">if</span> (vm_initialized == FALSE) {
		<span class="enscript-keyword">return</span>;	<span class="enscript-comment">/* nothing to do */</span>
	}
	<span class="enscript-keyword">if</span> (olddepth == newdepth &amp;&amp; vc_rendered_font) {
		<span class="enscript-keyword">return</span>;	<span class="enscript-comment">/* nothing to do */</span>
	}

	s = splhigh();
	VCPUTC_LOCK_LOCK();

	rendered_font      = vc_rendered_font;
	rendered_font_size = vc_rendered_font_size;
	rendered_char_size = vc_rendered_char_size;

	vc_rendered_font      = NULL;
	vc_rendered_font_size = 0;
	vc_rendered_char_size = 0;

	VCPUTC_LOCK_UNLOCK();
	splx(s);

	<span class="enscript-keyword">if</span> (rendered_font) {
		kfree(rendered_font, rendered_font_size);
		rendered_font = NULL;
	}

	<span class="enscript-keyword">if</span> (newdepth) {
		rendered_char_size = ISO_CHAR_HEIGHT * (((newdepth + 7) / 8) * ISO_CHAR_WIDTH);
		rendered_font_size = (ISO_CHAR_MAX-ISO_CHAR_MIN+1) * rendered_char_size;
		rendered_font = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc(rendered_font_size);
	}

	<span class="enscript-keyword">if</span> (rendered_font == NULL) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (charindex = ISO_CHAR_MIN; charindex &lt;= ISO_CHAR_MAX; charindex++) {
		vc_render_char(charindex, rendered_font + (charindex * rendered_char_size), newdepth);
	}

	olddepth = newdepth;

	s = splhigh();
	VCPUTC_LOCK_LOCK();

	vc_rendered_font      = rendered_font;
	vc_rendered_font_size = rendered_font_size;
	vc_rendered_char_size = rendered_char_size;

	VCPUTC_LOCK_UNLOCK();
	splx(s);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_enable</span>(boolean_t enable)
{
	vc_render_font(enable ? vinfo.v_depth : 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_reverse_cursor</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xx, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> yy)
{
	uint32_t *where;
	<span class="enscript-type">int</span> line, col;

	<span class="enscript-keyword">if</span>(!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;

	where = (uint32_t*)(vinfo.v_baseaddr + 
			(yy * ISO_CHAR_HEIGHT * vinfo.v_rowbytes) + 
			(xx <span class="enscript-comment">/** ISO_CHAR_WIDTH*/</span> * vinfo.v_depth));
	<span class="enscript-keyword">for</span> (line = 0; line &lt; ISO_CHAR_HEIGHT; line++) {
		<span class="enscript-keyword">switch</span> (vinfo.v_depth) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
				where[0] = ~where[0];
				where[1] = ~where[1];
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">16</span>:
				<span class="enscript-keyword">for</span> (col = 0; col &lt; 4; col++)
					where[col] = ~where[col];
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">32</span>:
				<span class="enscript-keyword">for</span> (col = 0; col &lt; 8; col++)
					where[col] = ~where[col];
				<span class="enscript-keyword">break</span>;
		}
		where = (uint32_t*)(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)where)+vinfo.v_rowbytes);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vc_scroll_down</span>(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scrreg_top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scrreg_bottom)
{
	uint32_t *from, *to,  linelongs, i, line, rowline, rowscanline;

	<span class="enscript-keyword">if</span>(!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;

	linelongs = vinfo.v_rowbytes * (ISO_CHAR_HEIGHT &gt;&gt; 2);
	rowline = vinfo.v_rowbytes &gt;&gt; 2;
	rowscanline = vinfo.v_rowscanbytes &gt;&gt; 2;

	to = (uint32_t *) vinfo.v_baseaddr + (linelongs * scrreg_bottom)
		- (rowline - rowscanline);
	from = to - (linelongs * num);	<span class="enscript-comment">/* handle multiple line scroll (Michel Pollet) */</span>

	i = (scrreg_bottom - scrreg_top) - num;

	<span class="enscript-keyword">while</span> (i-- &gt; 0) {
		<span class="enscript-keyword">for</span> (line = 0; line &lt; ISO_CHAR_HEIGHT; line++) {
			<span class="enscript-comment">/*
			 * Only copy what is displayed
			 */</span>
			video_scroll_down(from, 
					(from-(vinfo.v_rowscanbytes &gt;&gt; 2)), 
					to);

			from -= rowline;
			to -= rowline;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vc_scroll_up</span>(<span class="enscript-type">int</span> num, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scrreg_top, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scrreg_bottom)
{
	uint32_t *from, *to, linelongs, i, line, rowline, rowscanline;

	<span class="enscript-keyword">if</span>(!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;

	linelongs = vinfo.v_rowbytes * (ISO_CHAR_HEIGHT &gt;&gt; 2);
	rowline = vinfo.v_rowbytes &gt;&gt; 2;
	rowscanline = vinfo.v_rowscanbytes &gt;&gt; 2;

	to = (uint32_t *) vinfo.v_baseaddr + (scrreg_top * linelongs);
	from = to + (linelongs * num);	<span class="enscript-comment">/* handle multiple line scroll (Michel Pollet) */</span>

	i = (scrreg_bottom - scrreg_top) - num;

	<span class="enscript-keyword">while</span> (i-- &gt; 0) {
		<span class="enscript-keyword">for</span> (line = 0; line &lt; ISO_CHAR_HEIGHT; line++) {
			<span class="enscript-comment">/*
			 * Only copy what is displayed
			 */</span>
			video_scroll_up(from, 
					(from+(vinfo.v_rowscanbytes &gt;&gt; 2)), 
					to);

			from += rowline;
			to += rowline;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_update_color</span>(<span class="enscript-type">int</span> color, boolean_t fore)
{
	<span class="enscript-keyword">if</span> (!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (fore) {
        	vc_color_fore = vc_colors[color][vc_color_index_table[vinfo.v_depth]];
	} <span class="enscript-keyword">else</span> {
		vc_color_back = vc_colors[color][vc_color_index_table[vinfo.v_depth]];
	}
}

<span class="enscript-comment">/*
 * Video Console (Back-End): Icon Control
 * --------------------------------------
 */</span>

<span class="enscript-type">static</span> vc_progress_element *	vc_progress;
<span class="enscript-type">enum</span> { kMaxProgressData = 3 };
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *    vc_progress_data[kMaxProgressData];
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *    vc_progress_alpha;
<span class="enscript-type">static</span> boolean_t		vc_progress_enable;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *    vc_clut;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *    vc_clut8;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>            vc_revclut8[256];
<span class="enscript-type">static</span> uint32_t            	vc_progress_interval;
<span class="enscript-type">static</span> uint32_t            	vc_progress_count;
<span class="enscript-type">static</span> uint32_t            	vc_progress_angle;
<span class="enscript-type">static</span> uint64_t			vc_progress_deadline;
<span class="enscript-type">static</span> thread_call_data_t	vc_progress_call;
<span class="enscript-type">static</span> boolean_t		vc_needsave;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *			vc_saveunder;
<span class="enscript-type">static</span> vm_size_t		vc_saveunder_len;
<span class="enscript-type">static</span> int8_t			vc_uiscale = 1;
<span class="enscript-type">int</span>                             vc_user_options;
<span class="enscript-function-name">decl_simple_lock_data</span>(,vc_progress_lock)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>           		vc_progress_withmeter = 3;
<span class="enscript-type">int</span>                             vc_progressmeter_enable;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>                      vc_progressmeter_drawn;
<span class="enscript-type">int</span>            	                vc_progressmeter_value;
<span class="enscript-type">static</span> uint32_t            	vc_progressmeter_count;
<span class="enscript-type">static</span> uint32_t            	vc_progress_meter_start;
<span class="enscript-type">static</span> uint32_t            	vc_progress_meter_end;
<span class="enscript-type">static</span> uint64_t            	vc_progressmeter_interval;
<span class="enscript-type">static</span> uint64_t            	vc_progressmeter_deadline;
<span class="enscript-type">static</span> thread_call_data_t	vc_progressmeter_call;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *                   vc_progressmeter_backbuffer;
<span class="enscript-type">static</span> boolean_t                vc_progressmeter_hold;
<span class="enscript-type">static</span> uint32_t                 vc_progressmeter_diskspeed = 256;


<span class="enscript-type">enum</span> {
    kSave          = 0x10,
    kDataIndexed   = 0x20,
    kDataAlpha     = 0x40,
    kDataBack      = 0x80,
    kDataRotate    = 0x03,
    kDataRotate0   = 0,
    kDataRotate90  = 1,
    kDataRotate180 = 2,
    kDataRotate270 = 3
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">void</span> * backBuffer,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_8</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * backBuffer,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_16</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> * backBuffer,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_32</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * backBuffer,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_30</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * backBuffer,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_progress_task</span>( <span class="enscript-type">void</span> * arg0, <span class="enscript-type">void</span> * arg );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_progressmeter_task</span>( <span class="enscript-type">void</span> * arg0, <span class="enscript-type">void</span> * arg );

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
			    <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">void</span> * backBuffer,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
    <span class="enscript-keyword">if</span> (!vinfo.v_depth)                                <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(x + width))  &gt; vinfo.v_width)  <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(y + height)) &gt; vinfo.v_height) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">switch</span>( vinfo.v_depth) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
            <span class="enscript-keyword">if</span>( vc_clut8 == vc_clut)
                vc_blit_rect_8( x, y, bx, width, height, sourceRow, backRow, dataPtr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) backBuffer, flags );
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">16</span>:
	    vc_blit_rect_16( x, y, bx, width, height, sourceRow, backRow, dataPtr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) backBuffer, flags );
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">32</span>:
	    vc_blit_rect_32( x, y, bx, width, height, sourceRow, backRow, dataPtr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) backBuffer, flags );
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">30</span>:
	    vc_blit_rect_30( x, y, bx, width, height, sourceRow, backRow, dataPtr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) backBuffer, flags );
	    <span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_blit_rect_8</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, __unused <span class="enscript-type">int</span> bx,
	       <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
	       <span class="enscript-type">int</span> sourceRow, __unused <span class="enscript-type">int</span> backRow,
	       <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
	       __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * backBuffer,
	       __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
    <span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> * dst;
    <span class="enscript-type">int</span> line, col;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data = 0, out = 0;
    <span class="enscript-type">int</span> sx, sy, a, b, c, d;
    <span class="enscript-type">int</span> scale = 0x10000;

    a = vc_rotate_matr[kDataRotate &amp; flags][0][0] * scale;
    b = vc_rotate_matr[kDataRotate &amp; flags][0][1] * scale;
    c = vc_rotate_matr[kDataRotate &amp; flags][1][0] * scale;
    d = vc_rotate_matr[kDataRotate &amp; flags][1][1] * scale;
    sx = ((a + b) &lt; 0) ? ((width * scale)  - 0x8000) : 0;
    sy = ((c + d) &lt; 0) ? ((height * scale) - 0x8000) : 0;

    <span class="enscript-keyword">if</span> (!sourceRow) data = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(uintptr_t)dataPtr;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 == sourceRow) a = 0;

    dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) (vinfo.v_baseaddr +
                                    (y * vinfo.v_rowbytes) +
                                    (x * 4));

    <span class="enscript-keyword">for</span>( line = 0; line &lt; height; line++)
    {
        <span class="enscript-keyword">for</span>( col = 0; col &lt; width; col++)
	{
	    <span class="enscript-keyword">if</span> (sourceRow) data = dataPtr[((sx + (col * a) + (line * b)) &gt;&gt; 16)
				+ sourceRow * (((sy + (col * c) + (line * d)) &gt;&gt; 16))];
	    <span class="enscript-keyword">if</span> (kDataAlpha &amp; flags)
		out = vc_revclut8[data];
            <span class="enscript-keyword">else</span>
		out = data;
            *(dst + col) = out;
	}
        dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) (((<span class="enscript-type">volatile</span> <span class="enscript-type">char</span>*)dst) + vinfo.v_rowbytes);
    }
}

<span class="enscript-comment">/* For ARM, 16-bit is 565 (RGB); it is 1555 (XRGB) on other platforms */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUT_MASK_R</span>	0xf8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUT_MASK_G</span>	0xf8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUT_MASK_B</span>	0xf8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUT_SHIFT_R</span>	&lt;&lt; 7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUT_SHIFT_G</span>	&lt;&lt; 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLUT_SHIFT_B</span>	&gt;&gt; 3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASK_R</span>		0x7c00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASK_G</span>		0x03e0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASK_B</span>		0x001f
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASK_R_8</span>	0x3fc00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASK_G_8</span>	0x01fe0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASK_B_8</span>	0x000ff

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_16</span>( <span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx,
			     <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			     <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			     <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			     <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> * backPtr,
			     <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
    <span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> * dst;
    <span class="enscript-type">int</span> line, col;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data = 0, out = 0, back = 0;
    <span class="enscript-type">int</span> sx, sy, a, b, c, d;
    <span class="enscript-type">int</span> scale = 0x10000;

    a = vc_rotate_matr[kDataRotate &amp; flags][0][0] * scale;
    b = vc_rotate_matr[kDataRotate &amp; flags][0][1] * scale;
    c = vc_rotate_matr[kDataRotate &amp; flags][1][0] * scale;
    d = vc_rotate_matr[kDataRotate &amp; flags][1][1] * scale;
    sx = ((a + b) &lt; 0) ? ((width * scale)  - 0x8000) : 0;
    sy = ((c + d) &lt; 0) ? ((height * scale) - 0x8000) : 0;

    <span class="enscript-keyword">if</span> (!sourceRow) data = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(uintptr_t)dataPtr;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 == sourceRow) a = 0;

    <span class="enscript-keyword">if</span> (backPtr)
	backPtr += bx;
    dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) (vinfo.v_baseaddr +
                                    (y * vinfo.v_rowbytes) +
                                    (x * 2));

    <span class="enscript-keyword">for</span>( line = 0; line &lt; height; line++)
    {
        <span class="enscript-keyword">for</span>( col = 0; col &lt; width; col++)
	{
	    <span class="enscript-keyword">if</span> (sourceRow) data = dataPtr[((sx + (col * a) + (line * b)) &gt;&gt; 16)
				+ sourceRow * (((sy + (col * c) + (line * d)) &gt;&gt; 16))];
	    <span class="enscript-keyword">if</span> (backPtr) {
		<span class="enscript-keyword">if</span> (kSave &amp; flags) {
		    back = *(dst + col);
		    *backPtr++ = back;
		} <span class="enscript-keyword">else</span>
		    back = *backPtr++;
	    }
	    <span class="enscript-keyword">if</span> (kDataIndexed &amp; flags) {
		out = ( (CLUT_MASK_R &amp; (vc_clut[data*3 + 0])) CLUT_SHIFT_R)
		       | ( (CLUT_MASK_G &amp; (vc_clut[data*3 + 1])) CLUT_SHIFT_G)
		       | ( (CLUT_MASK_B &amp; (vc_clut[data*3 + 2])) CLUT_SHIFT_B);
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kDataAlpha &amp; flags) {
		out = (((((back &amp; MASK_R) * data) + MASK_R_8) &gt;&gt; 8) &amp; MASK_R)
		     | (((((back &amp; MASK_G) * data) + MASK_G_8) &gt;&gt; 8) &amp; MASK_G)
		     | (((((back &amp; MASK_B) * data) + MASK_B_8) &gt;&gt; 8) &amp; MASK_B);
		<span class="enscript-keyword">if</span> (vc_progress_white) out += (((0xff - data) &amp; CLUT_MASK_R) CLUT_SHIFT_R)
					    | (((0xff - data) &amp; CLUT_MASK_G) CLUT_SHIFT_G)
					    | (((0xff - data) &amp; CLUT_MASK_B) CLUT_SHIFT_B);
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kDataBack &amp; flags)
		out = back;
	    <span class="enscript-keyword">else</span>
		out = data;
            *(dst + col) = out;
	}
        dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) (((<span class="enscript-type">volatile</span> <span class="enscript-type">char</span>*)dst) + vinfo.v_rowbytes);
	<span class="enscript-keyword">if</span> (backPtr)
	    backPtr += backRow - width;
    }
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_32</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx, 
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * backPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
    <span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * dst;
    <span class="enscript-type">int</span> line, col;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data = 0, out = 0, back = 0;
    <span class="enscript-type">int</span> sx, sy, a, b, c, d;
    <span class="enscript-type">int</span> scale = 0x10000;

    a = vc_rotate_matr[kDataRotate &amp; flags][0][0] * scale;
    b = vc_rotate_matr[kDataRotate &amp; flags][0][1] * scale;
    c = vc_rotate_matr[kDataRotate &amp; flags][1][0] * scale;
    d = vc_rotate_matr[kDataRotate &amp; flags][1][1] * scale;
    sx = ((a + b) &lt; 0) ? ((width * scale)  - 0x8000) : 0;
    sy = ((c + d) &lt; 0) ? ((height * scale) - 0x8000) : 0;

    <span class="enscript-keyword">if</span> (!sourceRow) data = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(uintptr_t)dataPtr;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 == sourceRow) a = 0;
        
    <span class="enscript-keyword">if</span> (backPtr)
	backPtr += bx;
    dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) (vinfo.v_baseaddr +
                                    (y * vinfo.v_rowbytes) +
                                    (x * 4));

    <span class="enscript-keyword">for</span>( line = 0; line &lt; height; line++)
    {
        <span class="enscript-keyword">for</span>( col = 0; col &lt; width; col++)
	{
	    <span class="enscript-keyword">if</span> (sourceRow) data = dataPtr[((sx + (col * a) + (line * b)) &gt;&gt; 16)
				+ sourceRow * (((sy + (col * c) + (line * d)) &gt;&gt; 16))];
	    <span class="enscript-keyword">if</span> (backPtr) {
		<span class="enscript-keyword">if</span> (kSave &amp; flags) {
		    back = *(dst + col);
		    *backPtr++ = back;
		} <span class="enscript-keyword">else</span>
		    back = *backPtr++;
	    }
	    <span class="enscript-keyword">if</span> (kDataIndexed &amp; flags) {
		out =     (vc_clut[data*3 + 0] &lt;&lt; 16)
			| (vc_clut[data*3 + 1] &lt;&lt; 8)
			| (vc_clut[data*3 + 2]);
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kDataAlpha &amp; flags) {
		out = (((((back &amp; 0x00ff00ff) * data) + 0x00ff00ff) &gt;&gt; 8) &amp; 0x00ff00ff)
		     | (((((back &amp; 0x0000ff00) * data) + 0x0000ff00) &gt;&gt; 8) &amp; 0x0000ff00);
		<span class="enscript-keyword">if</span> (vc_progress_white) out += ((0xff - data) &lt;&lt; 16)
					    | ((0xff - data) &lt;&lt; 8)
					    |  (0xff - data);
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kDataBack &amp; flags)
		out = back;
	    <span class="enscript-keyword">else</span>
		out = data;
            *(dst + col) = out;
	}
        dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) (((<span class="enscript-type">volatile</span> <span class="enscript-type">char</span>*)dst) + vinfo.v_rowbytes);
	<span class="enscript-keyword">if</span> (backPtr)
	    backPtr += backRow - width;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_blit_rect_30</span>(<span class="enscript-type">int</span> x, <span class="enscript-type">int</span> y, <span class="enscript-type">int</span> bx, 
                            <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> height,
			    <span class="enscript-type">int</span> sourceRow, <span class="enscript-type">int</span> backRow,
			    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * dataPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * backPtr,
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
    <span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * dst;
    <span class="enscript-type">int</span> line, col;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data = 0, out = 0, back = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> exp;
    <span class="enscript-type">int</span> sx, sy, a, b, c, d;
    <span class="enscript-type">int</span> scale = 0x10000;

    a = vc_rotate_matr[kDataRotate &amp; flags][0][0] * scale;
    b = vc_rotate_matr[kDataRotate &amp; flags][0][1] * scale;
    c = vc_rotate_matr[kDataRotate &amp; flags][1][0] * scale;
    d = vc_rotate_matr[kDataRotate &amp; flags][1][1] * scale;
    sx = ((a + b) &lt; 0) ? ((width * scale)  - 0x8000) : 0;
    sy = ((c + d) &lt; 0) ? ((height * scale) - 0x8000) : 0;

    <span class="enscript-keyword">if</span> (!sourceRow) data = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(uintptr_t)dataPtr;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 == sourceRow) a = 0;
        
    <span class="enscript-keyword">if</span> (backPtr)
	backPtr += bx;
    dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) (vinfo.v_baseaddr +
                                    (y * vinfo.v_rowbytes) +
                                    (x * 4));

    <span class="enscript-keyword">for</span>( line = 0; line &lt; height; line++)
    {
        <span class="enscript-keyword">for</span>( col = 0; col &lt; width; col++)
	{
	    <span class="enscript-keyword">if</span> (sourceRow) data = dataPtr[((sx + (col * a) + (line * b)) &gt;&gt; 16)
				+ sourceRow * (((sy + (col * c) + (line * d)) &gt;&gt; 16))];
	    <span class="enscript-keyword">if</span> (backPtr) {
		<span class="enscript-keyword">if</span> (kSave &amp; flags) {
		    back = *(dst + col);
		    *backPtr++ = back;
		} <span class="enscript-keyword">else</span>
		    back = *backPtr++;
	    }
	    <span class="enscript-keyword">if</span> (kDataIndexed &amp; flags) {
		out =     (vc_clut[data*3 + 0] &lt;&lt; 22)
			| (vc_clut[data*3 + 1] &lt;&lt; 12)
			| (vc_clut[data*3 + 2] &lt;&lt; 2);
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kDataAlpha &amp; flags) {
		exp = back;
		exp =  (((((exp &amp; 0x3FF003FF) * data) + 0x0FF000FF) &gt;&gt; 8) &amp; 0x3FF003FF)
		     | (((((exp &amp; 0x000FFC00) * data) + 0x0003FC00) &gt;&gt; 8) &amp; 0x000FFC00);
		out = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)exp;
		<span class="enscript-keyword">if</span> (vc_progress_white) out += ((0xFF - data) &lt;&lt; 22)
					    | ((0xFF - data) &lt;&lt; 12)
					    | ((0xFF - data) &lt;&lt; 2);
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kDataBack &amp; flags)
		out = back;
	    <span class="enscript-keyword">else</span>
		out = data;
            *(dst + col) = out;
	}
        dst = (<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) (((<span class="enscript-type">volatile</span> <span class="enscript-type">char</span>*)dst) + vinfo.v_rowbytes);
	<span class="enscript-keyword">if</span> (backPtr)
	    backPtr += backRow - width;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vc_clean_boot_graphics</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-comment">// clean up possible FDE login graphics
</span>    vc_progress_set(FALSE, 0);
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *
    color = (typeof(color))(uintptr_t)(vc_progress_white ? 0x00000000 : 0xBFBFBFBF);
    vc_blit_rect(0, 0, 0, vinfo.v_width, vinfo.v_height, 0, 0, color, NULL, 0);
}

<span class="enscript-comment">/*
 * Routines to render the lzss image format
 */</span>

<span class="enscript-type">struct</span> lzss_image_state {
	uint32_t col;
	uint32_t row;
	uint32_t width;
	uint32_t height;
	uint32_t bytes_per_row;
	<span class="enscript-type">volatile</span> uint32_t * row_start;
	<span class="enscript-type">const</span> uint8_t* clut;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> lzss_image_state lzss_image_state;

<span class="enscript-comment">// returns 0 if OK, 1 if error
</span><span class="enscript-type">static</span> inline <span class="enscript-type">int</span> 
<span class="enscript-function-name">vc_decompress_lzss_next_pixel</span> (<span class="enscript-type">int</span> next_data, lzss_image_state* state) 
{
    uint32_t palette_index = 0;
    uint32_t pixel_value   = 0;

    palette_index = next_data * 3;

    pixel_value = ( (uint32_t) state-&gt;clut[palette_index + 0] &lt;&lt; 16) 
                | ( (uint32_t) state-&gt;clut[palette_index + 1] &lt;&lt; 8) 
                | ( (uint32_t) state-&gt;clut[palette_index + 2]); 

    *(state-&gt;row_start + state-&gt;col) = pixel_value;

    <span class="enscript-keyword">if</span> (++state-&gt;col &gt;= state-&gt;width) {
        state-&gt;col = 0;
        <span class="enscript-keyword">if</span> (++state-&gt;row &gt;= state-&gt;height) {
            <span class="enscript-keyword">return</span> 1;
        }
        state-&gt;row_start = (<span class="enscript-type">volatile</span> uint32_t *) (((uintptr_t)state-&gt;row_start) + state-&gt;bytes_per_row);
    }
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * Blit an lzss compressed image to the framebuffer
 * Assumes 32 bit screen (which is everything we ship at the moment)
 * The function vc_display_lzss_icon was copied from libkern/mkext.c, then modified.
 */</span>

<span class="enscript-comment">/* 
 * TODO: Does lzss use too much stack? 4096 plus bytes... 
 * 	Can probably chop it down by 1/2.
 */</span>

<span class="enscript-comment">/**************************************************************
 LZSS.C -- A Data Compression Program
***************************************************************
    4/6/1989 Haruhiko Okumura
    Use, distribute, and modify this program freely.
    Please send me your improved versions.
        PC-VAN      SCIENCE
        NIFTY-Serve PAF01022
        CompuServe  74050,1022

**************************************************************/</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N</span>         4096  <span class="enscript-comment">/* size of ring buffer - must be power of 2 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">F</span>         18    <span class="enscript-comment">/* upper limit for match_length */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THRESHOLD</span> 2     <span class="enscript-comment">/* encode string into position and length
                           if match_length is greater than this */</span>

<span class="enscript-comment">// returns 0 if OK, 1 if error
</span><span class="enscript-comment">// x and y indicate upper left corner of image location on screen
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">vc_display_lzss_icon</span>(uint32_t dst_x,       uint32_t dst_y,
                     uint32_t image_width, uint32_t image_height,
                     <span class="enscript-type">const</span> uint8_t *compressed_image,
                     uint32_t       compressed_size, 
                     <span class="enscript-type">const</span> uint8_t *clut)
{
    uint32_t* image_start;
    uint32_t bytes_per_pixel = 4;
    uint32_t bytes_per_row = vinfo.v_rowbytes;

    vc_clean_boot_graphics();

    image_start = (uint32_t *) (vinfo.v_baseaddr + (dst_y * bytes_per_row) + (dst_x * bytes_per_pixel));
    
    lzss_image_state state = {0, 0, image_width, image_height, bytes_per_row, image_start, clut};

    <span class="enscript-type">int</span> rval = 0;

    <span class="enscript-type">const</span> uint8_t *src = compressed_image;
    uint32_t srclen = compressed_size;

    <span class="enscript-comment">/* ring buffer of size N, with extra F-1 bytes to aid string comparison */</span>
    uint8_t text_buf[N + F - 1];
    <span class="enscript-type">const</span> uint8_t *srcend = src + srclen;
    <span class="enscript-type">int</span>  i, j, k, r, c;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags;

    srcend = src + srclen;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; N - F; i++)
        text_buf[i] = <span class="enscript-string">' '</span>;
    r = N - F;
    flags = 0;
    <span class="enscript-keyword">for</span> ( ; ; ) {
        <span class="enscript-keyword">if</span> (((flags &gt;&gt;= 1) &amp; 0x100) == 0) {
            <span class="enscript-keyword">if</span> (src &lt; srcend) c = *src++; <span class="enscript-keyword">else</span> <span class="enscript-keyword">break</span>;
            flags = c | 0xFF00;  <span class="enscript-comment">/* uses higher byte cleverly */</span>
        }   <span class="enscript-comment">/* to count eight */</span>
        <span class="enscript-keyword">if</span> (flags &amp; 1) {
            <span class="enscript-keyword">if</span> (src &lt; srcend) c = *src++; <span class="enscript-keyword">else</span> <span class="enscript-keyword">break</span>;
            rval = vc_decompress_lzss_next_pixel(c, &amp;state);
            <span class="enscript-keyword">if</span> (rval != 0)
                <span class="enscript-keyword">return</span> rval;
            text_buf[r++] = c;
            r &amp;= (N - 1);
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">if</span> (src &lt; srcend) i = *src++; <span class="enscript-keyword">else</span> <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">if</span> (src &lt; srcend) j = *src++; <span class="enscript-keyword">else</span> <span class="enscript-keyword">break</span>;
            i |= ((j &amp; 0xF0) &lt;&lt; 4);
            j  =  (j &amp; 0x0F) + THRESHOLD;
            <span class="enscript-keyword">for</span> (k = 0; k &lt;= j; k++) {
                c = text_buf[(i + k) &amp; (N - 1)];
                rval = vc_decompress_lzss_next_pixel(c, &amp;state);
                <span class="enscript-keyword">if</span> (rval != 0 )
                    <span class="enscript-keyword">return</span> rval;
                text_buf[r++] = c;
                r &amp;= (N - 1);
            }
        }
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">noroot_icon_test</span>(<span class="enscript-type">void</span>) {
    boolean_t o_vc_progress_enable = vc_progress_enable;

    vc_progress_enable = 1;

    PE_display_icon( 0, <span class="enscript-string">&quot;noroot&quot;</span>);

    vc_progress_enable = o_vc_progress_enable;
}


<span class="enscript-type">void</span> <span class="enscript-function-name">vc_display_icon</span>( vc_progress_element * desc,
			<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * data )
{
    <span class="enscript-type">int</span>			x, y, width, height;

    <span class="enscript-keyword">if</span>( vc_progress_enable &amp;&amp; vc_clut) {

	vc_clean_boot_graphics();

	width = desc-&gt;width;
	height = desc-&gt;height;
	x = desc-&gt;dx;
	y = desc-&gt;dy;
	<span class="enscript-keyword">if</span>( 1 &amp; desc-&gt;flags) {
	    x += ((vinfo.v_width - width) / 2);
	    y += ((vinfo.v_height - height) / 2);
	}
	vc_blit_rect( x, y, 0, width, height, width, 0, data, NULL, kDataIndexed );
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vc_progress_initialize</span>( vc_progress_element * desc,
			<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * data1x,
			<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * data2x,
			<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * data3x,
			<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * clut )
{
    uint64_t	abstime;

    <span class="enscript-keyword">if</span>( (!clut) || (!desc) || (!data1x))
	<span class="enscript-keyword">return</span>;
    vc_clut = clut;
    vc_clut8 = clut;

    vc_progress = desc;
    vc_progress_data[0] = data1x;
    vc_progress_data[1] = data2x;
    vc_progress_data[2] = data3x;
    <span class="enscript-keyword">if</span>( 2 &amp; vc_progress-&gt;flags)
        vc_progress_alpha = data1x
                            + vc_progress-&gt;count * vc_progress-&gt;width * vc_progress-&gt;height;
    <span class="enscript-keyword">else</span>
        vc_progress_alpha = NULL;

    thread_call_setup(&amp;vc_progress_call, vc_progress_task, NULL);
    clock_interval_to_absolutetime_interval(vc_progress-&gt;time, 1000 * 1000, &amp;abstime);
    vc_progress_interval = (uint32_t)abstime;

    thread_call_setup(&amp;vc_progressmeter_call, vc_progressmeter_task, NULL);
    clock_interval_to_absolutetime_interval(1000 / 8, 1000 * 1000, &amp;abstime);
    vc_progressmeter_interval = (uint32_t)abstime;

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vc_progress_set</span>(boolean_t enable, uint32_t vc_delay)
{
    spl_t	     s;
    <span class="enscript-type">void</span>             *saveBuf = NULL;
    vm_size_t        saveLen = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     count;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     index;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>    pdata8;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>   pdata16;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> * buf16;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     pdata32;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *   buf32;


    <span class="enscript-keyword">if</span> (kBootArgsFlagBlack &amp; ((boot_args *) PE_state.bootArgs)-&gt;flags) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (1 &amp; vc_progress_withmeter)
    {
	<span class="enscript-keyword">if</span> (enable) internal_enable_progressmeter(kProgressMeterKernel);

	s = splhigh();
	simple_lock(&amp;vc_progress_lock);

	<span class="enscript-keyword">if</span>( vc_progress_enable != enable) {
	    vc_progress_enable = enable;
	    <span class="enscript-keyword">if</span>( enable)
	    {
		vc_progressmeter_count = 0;
		clock_interval_to_deadline(vc_delay,
					   1000 * 1000 * 1000 <span class="enscript-comment">/*second scale*/</span>,
					   &amp;vc_progressmeter_deadline);
		thread_call_enter_delayed(&amp;vc_progressmeter_call, vc_progressmeter_deadline);
	    } 
	    <span class="enscript-keyword">else</span> thread_call_cancel(&amp;vc_progressmeter_call);
	}

	simple_unlock(&amp;vc_progress_lock);
	splx(s);

	<span class="enscript-keyword">if</span> (!enable) internal_enable_progressmeter(kProgressMeterOff);
	<span class="enscript-keyword">return</span>;
    }


    <span class="enscript-keyword">if</span>(!vc_progress) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span>( enable) {
        saveLen = (vc_progress-&gt;width * vc_uiscale) * (vc_progress-&gt;height * vc_uiscale) * vinfo.v_depth / 8;
        saveBuf = kalloc( saveLen );

	<span class="enscript-keyword">switch</span>( vinfo.v_depth) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span> :
		<span class="enscript-keyword">for</span>( count = 0; count &lt; 256; count++) {
		    vc_revclut8[count] = vc_clut[0x01 * 3];
		    pdata8 = (vc_clut[0x01 * 3] * count + 0x0ff) &gt;&gt; 8;
		    <span class="enscript-keyword">for</span>( index = 0; index &lt; 256; index++) {
			<span class="enscript-keyword">if</span>( (pdata8 == vc_clut[index * 3 + 0]) &amp;&amp;
			    (pdata8 == vc_clut[index * 3 + 1]) &amp;&amp;
			    (pdata8 == vc_clut[index * 3 + 2])) {
			    vc_revclut8[count] = index;
			    <span class="enscript-keyword">break</span>;
			}
		    }
		}
		memset( saveBuf, 0x01, saveLen );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">16</span> :
		buf16 = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) saveBuf;
		pdata16 = ((vc_clut[0x01 * 3 + 0] &amp; CLUT_MASK_R) CLUT_SHIFT_R)
		       | ((vc_clut[0x01 * 3 + 0] &amp; CLUT_MASK_G) CLUT_SHIFT_G)
		       | ((vc_clut[0x01 * 3 + 0] &amp; CLUT_MASK_B) CLUT_SHIFT_B);
		<span class="enscript-keyword">for</span>( count = 0; count &lt; saveLen / 2; count++)
		    buf16[count] = pdata16;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">32</span> :
		buf32 = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) saveBuf;
		pdata32 = ((vc_clut[0x01 * 3 + 0] &amp; 0xff) &lt;&lt; 16)
		       | ((vc_clut[0x01 * 3 + 1] &amp; 0xff) &lt;&lt; 8)
		       | ((vc_clut[0x01 * 3 + 2] &amp; 0xff) &lt;&lt; 0);
		<span class="enscript-keyword">for</span>( count = 0; count &lt; saveLen / 4; count++)
		    buf32[count] = pdata32;
		<span class="enscript-keyword">break</span>;
	}
    }

    s = splhigh();
    simple_lock(&amp;vc_progress_lock);

    <span class="enscript-keyword">if</span>( vc_progress_enable != enable) {
        vc_progress_enable = enable;
        <span class="enscript-keyword">if</span>( enable) {
            vc_needsave      = TRUE;
            vc_saveunder     = saveBuf;
            vc_saveunder_len = saveLen;
            saveBuf	          = NULL;
            saveLen 	      = 0;
            vc_progress_count = 0;
	    vc_progress_angle = 0;

            clock_interval_to_deadline(vc_delay,
				       1000 * 1000 * 1000 <span class="enscript-comment">/*second scale*/</span>,
				       &amp;vc_progress_deadline);
            thread_call_enter_delayed(&amp;vc_progress_call, vc_progress_deadline);

        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">if</span>( vc_saveunder) {
                saveBuf      = vc_saveunder;
                saveLen      = vc_saveunder_len;
                vc_saveunder = NULL;
                vc_saveunder_len = 0;
            }

            thread_call_cancel(&amp;vc_progress_call);
        }
    }

    simple_unlock(&amp;vc_progress_lock);
    splx(s);

    <span class="enscript-keyword">if</span>( saveBuf)
        kfree( saveBuf, saveLen );
}


<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">vc_progressmeter_range</span>(uint32_t pos)
{
    uint32_t ret;

    <span class="enscript-keyword">if</span> (pos &gt; kProgressMeterEnd) pos = kProgressMeterEnd;
    ret = vc_progress_meter_start 
    	+ ((pos * (vc_progress_meter_end - vc_progress_meter_start)) / kProgressMeterEnd);

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_progressmeter_task</span>(__unused <span class="enscript-type">void</span> *arg0, __unused <span class="enscript-type">void</span> *arg)
{
    spl_t    s;
    uint64_t interval;

    s = splhigh();
    simple_lock(&amp;vc_progress_lock);
    <span class="enscript-keyword">if</span> (vc_progressmeter_enable)
    {
	uint32_t pos = (vc_progressmeter_count &gt;&gt; 13);
	internal_set_progressmeter(vc_progressmeter_range(pos));
	<span class="enscript-keyword">if</span> (pos &lt; kProgressMeterEnd)
	{
            <span class="enscript-type">static</span> uint16_t incr[8] = { 10000, 10000, 8192, 4096, 2048, 384, 384, 64 };
	    vc_progressmeter_count += incr[(pos * 8) / kProgressMeterEnd];

	    interval = vc_progressmeter_interval;
	    interval = ((interval * 256) / vc_progressmeter_diskspeed);

	    clock_deadline_for_periodic_event(interval, mach_absolute_time(), &amp;vc_progressmeter_deadline);
	    thread_call_enter_delayed(&amp;vc_progressmeter_call, vc_progressmeter_deadline);
	}
    }
    simple_unlock(&amp;vc_progress_lock);
    splx(s);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">vc_progress_setdiskspeed</span>(uint32_t speed)
{
    vc_progressmeter_diskspeed = speed;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_progress_task</span>(__unused <span class="enscript-type">void</span> *arg0, __unused <span class="enscript-type">void</span> *arg)
{
    spl_t s;
    <span class="enscript-type">int</span>		   x, y, width, height;
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * data;

    s = splhigh();
    simple_lock(&amp;vc_progress_lock);

    <span class="enscript-keyword">if</span>( vc_progress_enable) {
    
	vc_progress_count++;
	<span class="enscript-keyword">if</span>( vc_progress_count &gt;= vc_progress-&gt;count) {
	    vc_progress_count = 0;
	    vc_progress_angle++;
	}

	width  = (vc_progress-&gt;width * vc_uiscale);
	height = (vc_progress-&gt;height * vc_uiscale);
	x = (vc_progress-&gt;dx * vc_uiscale);
	y = (vc_progress-&gt;dy * vc_uiscale);
	data = vc_progress_data[vc_uiscale - 1];
	<span class="enscript-keyword">if</span> (data)
        {
	    data += vc_progress_count * width * height;
	    <span class="enscript-keyword">if</span>( 1 &amp; vc_progress-&gt;flags) {
		x += ((vinfo.v_width - width) / 2);
		y += ((vinfo.v_height - height) / 2);
	    }
    
	    assert(((x + width) &lt; (<span class="enscript-type">int</span>)vinfo.v_width) &amp;&amp; 
		       ((y + height) &lt; (<span class="enscript-type">int</span>)vinfo.v_height));
    
	    vc_blit_rect( x, y, 0, 
			  width, height, width, width,
			  data, vc_saveunder,
			  kDataAlpha 
			  | (vc_progress_angle &amp; kDataRotate) 
			  | (vc_needsave ? kSave : 0) );
	    vc_needsave = FALSE;

	    clock_deadline_for_periodic_event(vc_progress_interval, mach_absolute_time(), &amp;vc_progress_deadline);
	    thread_call_enter_delayed(&amp;vc_progress_call, vc_progress_deadline);
	}
    }
    simple_unlock(&amp;vc_progress_lock);
    splx(s);
}

<span class="enscript-comment">/*
 * Generic Console (Front-End): Master Control
 * -------------------------------------------
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/i386/boot.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> boolean_t gc_acquired      = FALSE;
<span class="enscript-type">static</span> boolean_t gc_graphics_boot = FALSE;
<span class="enscript-type">static</span> boolean_t gc_desire_text   = FALSE;
<span class="enscript-type">static</span> boolean_t gc_paused_progress;

<span class="enscript-type">static</span> uint64_t lastVideoPhys   = 0;
<span class="enscript-type">static</span> vm_offset_t  lastVideoVirt   = 0;
<span class="enscript-type">static</span> vm_size_t lastVideoSize   = 0;
<span class="enscript-type">static</span> boolean_t    lastVideoMapped = FALSE;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gc_pause</span>( boolean_t pause, boolean_t graphics_now )
{
	spl_t s;

	s = splhigh( );
	VCPUTC_LOCK_LOCK( );

    disableConsoleOutput = (pause &amp;&amp; !console_is_serial());
    gc_enabled           = (!pause &amp;&amp; !graphics_now);

    VCPUTC_LOCK_UNLOCK( );

    simple_lock(&amp;vc_progress_lock);

    <span class="enscript-keyword">if</span> (pause) 
    {
        gc_paused_progress = vc_progress_enable;
	vc_progress_enable = FALSE;
    }
    <span class="enscript-keyword">else</span> vc_progress_enable = gc_paused_progress;

    <span class="enscript-keyword">if</span> (vc_progress_enable)
    {
	<span class="enscript-keyword">if</span> (1 &amp; vc_progress_withmeter) thread_call_enter_delayed(&amp;vc_progressmeter_call, vc_progressmeter_deadline);
	<span class="enscript-keyword">else</span>                           
	thread_call_enter_delayed(&amp;vc_progress_call, vc_progress_deadline);
    }

    simple_unlock(&amp;vc_progress_lock);
    splx(s);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_initialize</span>(__unused <span class="enscript-type">struct</span> vc_info * vinfo_p)
{

	vinfo.v_rows = vinfo.v_height / ISO_CHAR_HEIGHT;
	vinfo.v_columns = vinfo.v_width / ISO_CHAR_WIDTH;
	vinfo.v_rowscanbytes = ((vinfo.v_depth + 7) / 8) * vinfo.v_width;
	vc_uiscale = vinfo.v_scale;
	<span class="enscript-keyword">if</span> (vc_uiscale &gt; kMaxProgressData) vc_uiscale = kMaxProgressData;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!vc_uiscale)              vc_uiscale = 1;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">initialize_screen</span>(PE_Video * boot_vinfo, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> op)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fbsize = 0;
	vm_offset_t newVideoVirt = 0;
	boolean_t graphics_now;
	ppnum_t fbppage;

	<span class="enscript-keyword">if</span> ( boot_vinfo )
	{
		<span class="enscript-type">struct</span> vc_info new_vinfo = vinfo;
		<span class="enscript-comment">/* 
		 *	First, check if we are changing the size and/or location of the framebuffer
		 */</span>
		new_vinfo.v_name[0]  = 0;
		new_vinfo.v_physaddr = boot_vinfo-&gt;v_baseAddr &amp; ~3;		<span class="enscript-comment">/* Get the physical address */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
		new_vinfo.v_physaddr |= (((uint64_t) boot_vinfo-&gt;v_baseAddrHigh) &lt;&lt; 32);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (kPEBaseAddressChange != op)
		{
		    new_vinfo.v_width    = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)boot_vinfo-&gt;v_width;
		    new_vinfo.v_height   = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)boot_vinfo-&gt;v_height;
		    new_vinfo.v_depth    = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)boot_vinfo-&gt;v_depth;
		    new_vinfo.v_rowbytes = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)boot_vinfo-&gt;v_rowBytes;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		    new_vinfo.v_type     = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)boot_vinfo-&gt;v_display;
#<span class="enscript-reference">else</span>
		    new_vinfo.v_type = 0;
#<span class="enscript-reference">endif</span>
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scale   = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)boot_vinfo-&gt;v_scale;
            <span class="enscript-keyword">if</span> (scale == kPEScaleFactor1x )
                new_vinfo.v_scale = kPEScaleFactor1x;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (scale == kPEScaleFactor2x)
                new_vinfo.v_scale = kPEScaleFactor2x;
            <span class="enscript-keyword">else</span> <span class="enscript-comment">/* Scale factor not set, default to 1x */</span>
                new_vinfo.v_scale = kPEScaleFactor1x;

		}
     
		<span class="enscript-keyword">if</span> (!lastVideoMapped)
		    kprintf(<span class="enscript-string">&quot;initialize_screen: b=%08llX, w=%08X, h=%08X, r=%08X, d=%08X\n&quot;</span>,                  <span class="enscript-comment">/* (BRINGUP) */</span>
			    new_vinfo.v_physaddr, new_vinfo.v_width,  new_vinfo.v_height,  new_vinfo.v_rowbytes, new_vinfo.v_type);     <span class="enscript-comment">/* (BRINGUP) */</span>

		<span class="enscript-keyword">if</span> (!new_vinfo.v_physaddr)							<span class="enscript-comment">/* Check to see if we have a framebuffer */</span>
		{
			kprintf(<span class="enscript-string">&quot;initialize_screen: No video - forcing serial mode\n&quot;</span>);		<span class="enscript-comment">/* (BRINGUP) */</span>
			new_vinfo.v_depth = 0;						<span class="enscript-comment">/* vc routines are nop */</span>
			(<span class="enscript-type">void</span>)switch_to_serial_console();				<span class="enscript-comment">/* Switch into serial mode */</span>
			gc_graphics_boot = FALSE;					<span class="enscript-comment">/* Say we are not in graphics mode */</span>
			disableConsoleOutput = FALSE;					<span class="enscript-comment">/* Allow printfs to happen */</span>
			gc_acquired = TRUE;
		}
		<span class="enscript-keyword">else</span>
		{
		    <span class="enscript-comment">/*
		     * If VM is up, we are given a virtual address, unless b0 is set to indicate physical.
		     */</span>
			<span class="enscript-keyword">if</span> ((kernel_map != VM_MAP_NULL) &amp;&amp; (0 == (1 &amp; boot_vinfo-&gt;v_baseAddr)))
		    {
			    fbppage = pmap_find_phys(kernel_pmap, (addr64_t)boot_vinfo-&gt;v_baseAddr);	<span class="enscript-comment">/* Get the physical address of frame buffer */</span>
			    <span class="enscript-keyword">if</span>(!fbppage)						<span class="enscript-comment">/* Did we find it? */</span>
			    {
				    panic(<span class="enscript-string">&quot;initialize_screen: Strange framebuffer - addr = %08X\n&quot;</span>, (uint32_t)boot_vinfo-&gt;v_baseAddr);
			    }
			    new_vinfo.v_physaddr = (((uint64_t)fbppage) &lt;&lt; PAGE_SHIFT) | (boot_vinfo-&gt;v_baseAddr &amp; PAGE_MASK);			<span class="enscript-comment">/* Get the physical address */</span>
		    }
    
		    <span class="enscript-keyword">if</span> (boot_vinfo-&gt;v_length != 0)
			    fbsize = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) round_page(boot_vinfo-&gt;v_length);
		    <span class="enscript-keyword">else</span>
			    fbsize = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) round_page(new_vinfo.v_height * new_vinfo.v_rowbytes);			<span class="enscript-comment">/* Remember size */</span>

    
		    <span class="enscript-keyword">if</span> ((lastVideoPhys != new_vinfo.v_physaddr) || (fbsize &gt; lastVideoSize))		<span class="enscript-comment">/* Did framebuffer change location or get bigger? */</span>
		    {
			    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags = VM_WIMG_IO;
			    newVideoVirt = io_map_spec((vm_map_offset_t)new_vinfo.v_physaddr, fbsize, flags);	<span class="enscript-comment">/* Allocate address space for framebuffer */</span>
    		    }
		}

		<span class="enscript-keyword">if</span> (newVideoVirt != 0)
		    new_vinfo.v_baseaddr = newVideoVirt + boot_vinfo-&gt;v_offset;				<span class="enscript-comment">/* Set the new framebuffer address */</span>
		<span class="enscript-keyword">else</span>
		    new_vinfo.v_baseaddr = lastVideoVirt + boot_vinfo-&gt;v_offset;				<span class="enscript-comment">/* Set the new framebuffer address */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		<span class="enscript-comment">// Adjust the video buffer pointer to point to where it is in high virtual (above the hole)
</span>		new_vinfo.v_baseaddr |= (VM_MIN_KERNEL_ADDRESS &amp; ~LOW_4GB_MASK);
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/* Update the vinfo structure atomically with respect to the vc_progress task if running */</span>
		<span class="enscript-keyword">if</span> (vc_progress)
		{
		    simple_lock(&amp;vc_progress_lock);
		    vinfo = new_vinfo;
		    simple_unlock(&amp;vc_progress_lock);
		}
		<span class="enscript-keyword">else</span>
		{
		    vinfo = new_vinfo;
		}

		<span class="enscript-comment">// If we changed the virtual address, remove the old mapping
</span>		<span class="enscript-keyword">if</span> (newVideoVirt != 0)
		{
			<span class="enscript-keyword">if</span> (lastVideoVirt)							<span class="enscript-comment">/* Was the framebuffer mapped before? */</span>
			{
				<span class="enscript-comment">/* XXX why did this ever succeed? */</span>
				<span class="enscript-comment">/* TODO: Consider this. */</span>
				<span class="enscript-keyword">if</span> (!TEST_PAGE_SIZE_4K &amp;&amp; lastVideoMapped)	<span class="enscript-comment">/* Was this not a special pre-VM mapping? */</span>
				{
					pmap_remove(kernel_pmap, trunc_page_64(lastVideoVirt),
						round_page_64(lastVideoVirt + lastVideoSize));	<span class="enscript-comment">/* Toss mappings */</span>
				}
				<span class="enscript-keyword">if</span>(lastVideoMapped)                            <span class="enscript-comment">/* Was this not a special pre-VM mapping? */</span>
				{
					kmem_free(kernel_map, lastVideoVirt, lastVideoSize);	<span class="enscript-comment">/* Toss kernel addresses */</span>
				}
			}
			lastVideoPhys = new_vinfo.v_physaddr;					<span class="enscript-comment">/* Remember the framebuffer address */</span>
			lastVideoSize = fbsize;							<span class="enscript-comment">/* Remember the size */</span>
			lastVideoVirt = newVideoVirt;						<span class="enscript-comment">/* Remember the virtual framebuffer address */</span>
			lastVideoMapped  = (NULL != kernel_map);
		}

        <span class="enscript-keyword">if</span> (kPEBaseAddressChange != op)
        {
			<span class="enscript-comment">// Graphics mode setup by the booter.
</span>
			gc_ops.initialize   = vc_initialize;
			gc_ops.enable       = vc_enable;
			gc_ops.paint_char   = vc_paint_char;
			gc_ops.scroll_down  = vc_scroll_down;
			gc_ops.scroll_up    = vc_scroll_up;
			gc_ops.clear_screen = vc_clear_screen;
			gc_ops.hide_cursor  = vc_reverse_cursor;
			gc_ops.show_cursor  = vc_reverse_cursor;
			gc_ops.update_color = vc_update_color;
            gc_initialize(&amp;vinfo);
		}
	}

    graphics_now = gc_graphics_boot &amp;&amp; !gc_desire_text;
	<span class="enscript-keyword">switch</span> ( op )
	{
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPEGraphicsMode</span>:
			gc_graphics_boot = TRUE;
			gc_desire_text = FALSE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPETextMode</span>:
			disable_debug_output = FALSE;
			gc_graphics_boot = FALSE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPEAcquireScreen</span>:
			<span class="enscript-keyword">if</span> ( gc_acquired ) <span class="enscript-keyword">break</span>;
			vc_progress_set( graphics_now, (kVCDarkReboot &amp; vc_user_options) ? 120 : vc_acquire_delay );
			gc_enable( !graphics_now );
			gc_acquired = TRUE;
			gc_desire_text = FALSE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPEDisableScreen</span>:
            <span class="enscript-keyword">if</span> (gc_acquired) 
            {
                gc_pause( TRUE, graphics_now );
            }
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPEEnableScreen</span>:
            <span class="enscript-keyword">if</span> (gc_acquired) 
            {
                gc_pause( FALSE, graphics_now );
            }
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPETextScreen</span>:
			<span class="enscript-keyword">if</span> ( console_is_serial() ) <span class="enscript-keyword">break</span>;

			disable_debug_output = FALSE;
			<span class="enscript-keyword">if</span> ( gc_acquired == FALSE )
			{
				gc_desire_text = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ( gc_graphics_boot == FALSE ) <span class="enscript-keyword">break</span>;

			vc_progress_set( FALSE, 0 );
			vc_enable_progressmeter( FALSE );
			gc_enable( TRUE );
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPEReleaseScreen</span>:
			gc_acquired = FALSE;
			gc_desire_text = FALSE;
			gc_enable( FALSE );
			<span class="enscript-keyword">if</span> ( gc_graphics_boot == FALSE ) <span class="enscript-keyword">break</span>;

			vc_progress_set( FALSE, 0 );
			vc_acquire_delay = kProgressReacquireDelay;
			vc_enable_progressmeter(FALSE);
			vc_progress_white      = TRUE;
			vc_progress_withmeter &amp;= ~1;
			vc_clut8 = NULL;
			<span class="enscript-keyword">break</span>;


		<span class="enscript-keyword">case</span> <span class="enscript-reference">kPERefreshBootGraphics</span>:
		{
		    spl_t     s;
		    boolean_t save;

		    <span class="enscript-keyword">if</span> (kBootArgsFlagBlack &amp; ((boot_args *) PE_state.bootArgs)-&gt;flags) <span class="enscript-keyword">break</span>;

		    save = vc_progress_white;
		    vc_progress_white = (0 != (kBootArgsFlagBlackBg &amp; ((boot_args *) PE_state.bootArgs)-&gt;flags));

		    internal_enable_progressmeter(kProgressMeterKernel);

		    s = splhigh();
		    simple_lock(&amp;vc_progress_lock);

		    vc_progressmeter_drawn = 0;
		    internal_set_progressmeter(vc_progressmeter_range(vc_progressmeter_count &gt;&gt; 13));

		    simple_unlock(&amp;vc_progress_lock);
		    splx(s);

		    internal_enable_progressmeter(kProgressMeterOff);
		    vc_progress_white = save;
		}
	}
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">dim_screen</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *p, *endp, *row;
	<span class="enscript-type">int</span>      col, rowline, rowlongs;
	<span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mask;

	<span class="enscript-keyword">if</span>(!vinfo.v_depth)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ( vinfo.v_depth == 32 )
		mask = 0x007F7F7F;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( vinfo.v_depth == 30 )
		mask = (0x1ff&lt;&lt;20) | (0x1ff&lt;&lt;10) | 0x1ff;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( vinfo.v_depth == 16 )
		mask = 0x3DEF3DEF;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>;

	rowline = (<span class="enscript-type">int</span>)(vinfo.v_rowscanbytes / 4);
	rowlongs = (<span class="enscript-type">int</span>)(vinfo.v_rowbytes / 4);

	p = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>*) vinfo.v_baseaddr;
	endp = p + (rowlongs * vinfo.v_height);

	<span class="enscript-keyword">for</span> (row = p ; row &lt; endp ; row += rowlongs) {
		<span class="enscript-keyword">for</span> (p = &amp;row[0], col = 0; col &lt; rowline; col++) {
			*p = (*p &gt;&gt; 1) &amp; mask;
			++p;
		}
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">vcattach</span>(<span class="enscript-type">void</span>); <span class="enscript-comment">/* XXX gcc 4 warning cleanup */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vcattach</span>(<span class="enscript-type">void</span>)
{
	vm_initialized = TRUE;

        <span class="enscript-type">const</span> boot_args * bootargs  = (typeof(bootargs)) PE_state.bootArgs;

	vc_progress_white = (0 != ((kBootArgsFlagBlackBg | kBootArgsFlagLoginUI) 
					  &amp; bootargs-&gt;flags));
	PE_parse_boot_argn(<span class="enscript-string">&quot;meter&quot;</span>, &amp;vc_progress_withmeter, <span class="enscript-keyword">sizeof</span>(vc_progress_withmeter));

	<span class="enscript-keyword">if</span> (kBootArgsFlagInstallUI &amp; bootargs-&gt;flags)
	{
	    vc_progress_meter_start = (bootargs-&gt;bootProgressMeterStart * kProgressMeterMax) / 65535;
	    vc_progress_meter_end   = (bootargs-&gt;bootProgressMeterEnd   * kProgressMeterMax) / 65535;
	}
	<span class="enscript-keyword">else</span>
	{
	    vc_progress_meter_start = 0;
	    vc_progress_meter_end   = kProgressMeterMax;
	}
	simple_lock_init(&amp;vc_progress_lock, 0);

	<span class="enscript-keyword">if</span> ( gc_graphics_boot == FALSE )
	{
		<span class="enscript-type">long</span> index;

		<span class="enscript-keyword">if</span> ( gc_acquired )
		{
			initialize_screen(NULL, kPEReleaseScreen);
		}

		initialize_screen(NULL, kPEAcquireScreen);

		<span class="enscript-keyword">for</span> ( index = 0 ; index &lt; msgbufp-&gt;msg_bufx ; index++ )
		{
			<span class="enscript-keyword">if</span> (msgbufp-&gt;msg_bufc[index] == <span class="enscript-string">'\0'</span>) {
				<span class="enscript-keyword">continue</span>;
			}

			vcputc( 0, 0, msgbufp-&gt;msg_bufc[index] );

			<span class="enscript-keyword">if</span> ( msgbufp-&gt;msg_bufc[index] == <span class="enscript-string">'\n'</span> )
			{
				vcputc( 0, 0,<span class="enscript-string">'\r'</span> );
			}
		}
	}
}


<span class="enscript-comment">// redraw progress meter between pixels x1, x2, position at x3
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vc_draw_progress_meter</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> x1, <span class="enscript-type">int</span> x2, <span class="enscript-type">int</span> x3)
{
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * data;
    <span class="enscript-type">int</span> x, w;
    <span class="enscript-type">int</span> ox, oy;
    <span class="enscript-type">int</span> endCapPos;
    <span class="enscript-type">int</span> onoff;
    <span class="enscript-comment">// 1 rounded fill, 0 square end
</span>    <span class="enscript-type">int</span> style = (0 == (2 &amp; vc_progress_withmeter));

    ox = ((vinfo.v_width - (kProgressBarWidth * vc_uiscale)) / 2);
    oy = vinfo.v_height - (vinfo.v_height / 3) - ((kProgressBarHeight * vc_uiscale) / 2);

    <span class="enscript-keyword">if</span> (kDataBack == flags)
    {
	<span class="enscript-comment">// restore back bits
</span>	vc_blit_rect(ox + x1, oy, x1,
		    x2, (kProgressBarHeight * vc_uiscale), 0, (kProgressBarWidth * vc_uiscale),
		    NULL, vc_progressmeter_backbuffer, flags);
	<span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">for</span> (x = x1; x &lt; x2; x += w)
    {
	onoff = (x &lt; x3);
	endCapPos = ((style &amp;&amp; onoff) ? x3 : (kProgressBarWidth * vc_uiscale));
	<span class="enscript-keyword">if</span> (x &lt; (kProgressBarCapWidth * vc_uiscale))
	{
	    <span class="enscript-keyword">if</span> (x2 &lt; (kProgressBarCapWidth * vc_uiscale))
		w = x2 - x;
	    <span class="enscript-keyword">else</span>
		w = (kProgressBarCapWidth * vc_uiscale) - x;
	    data = progressmeter_leftcap[vc_uiscale &gt;= 2][onoff];
	    data += x;
	    vc_blit_rect(ox + x, oy, x, w,
			    (kProgressBarHeight * vc_uiscale), 
			    (kProgressBarCapWidth * vc_uiscale), 
			    (kProgressBarWidth * vc_uiscale),
			    data, vc_progressmeter_backbuffer, flags);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (x &lt; (endCapPos - (kProgressBarCapWidth * vc_uiscale)))
	{
	    <span class="enscript-keyword">if</span> (x2 &lt; (endCapPos - (kProgressBarCapWidth * vc_uiscale)))
		w = x2 - x;
	    <span class="enscript-keyword">else</span>
		w = (endCapPos - (kProgressBarCapWidth * vc_uiscale)) - x;
	    data = progressmeter_middle[vc_uiscale &gt;= 2][onoff];
	    vc_blit_rect(ox + x, oy, x, w,
			    (kProgressBarHeight * vc_uiscale),
			    1,
			    (kProgressBarWidth * vc_uiscale),
			    data, vc_progressmeter_backbuffer, flags);
	}
	<span class="enscript-keyword">else</span>
	{
	    w = endCapPos - x;
	    data =  progressmeter_rightcap[vc_uiscale &gt;= 2][onoff];
	    data += x - (endCapPos - (kProgressBarCapWidth * vc_uiscale));
	    vc_blit_rect(ox + x, oy, x, w,
			    (kProgressBarHeight * vc_uiscale), 
			    (kProgressBarCapWidth * vc_uiscale), 
			    (kProgressBarWidth * vc_uiscale),
			    data, vc_progressmeter_backbuffer, flags);
	}
    }
}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IORecordProgressBackbuffer</span>(<span class="enscript-type">void</span> * buffer, size_t size, uint32_t theme);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">internal_enable_progressmeter</span>(<span class="enscript-type">int</span> new_value)
{
    spl_t     s;
    <span class="enscript-type">void</span>    * new_buffer;
    boolean_t stashBackbuffer;

    stashBackbuffer = FALSE;
    new_buffer = NULL;
    <span class="enscript-keyword">if</span> (new_value)
    {
	new_buffer = kalloc((kProgressBarWidth * vc_uiscale) 
		            * (kProgressBarHeight * vc_uiscale) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
    }

    s = splhigh();
    simple_lock(&amp;vc_progress_lock);

    <span class="enscript-keyword">if</span> (kProgressMeterUser == new_value)
    {
	<span class="enscript-keyword">if</span> (gc_enabled || !gc_acquired || !gc_graphics_boot
	 || (kProgressMeterKernel == vc_progressmeter_enable)) new_value = vc_progressmeter_enable;
    }

    <span class="enscript-keyword">if</span> (new_value != vc_progressmeter_enable)
    {
	<span class="enscript-keyword">if</span> (new_value)
	{
	    <span class="enscript-keyword">if</span> (kProgressMeterOff == vc_progressmeter_enable)
	    {
		vc_progressmeter_backbuffer = new_buffer;
		vc_draw_progress_meter(kDataAlpha | kSave, 0, (kProgressBarWidth * vc_uiscale), 0);
		new_buffer = NULL;
		vc_progressmeter_drawn = 0;
	    }
	    vc_progressmeter_enable = new_value;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vc_progressmeter_backbuffer)
	{
	    <span class="enscript-keyword">if</span> (kProgressMeterUser == vc_progressmeter_enable)
	    {
		vc_draw_progress_meter(kDataBack, 0, (kProgressBarWidth * vc_uiscale), vc_progressmeter_drawn);
	    }
	    <span class="enscript-keyword">else</span> stashBackbuffer = TRUE;
	    new_buffer = vc_progressmeter_backbuffer;
	    vc_progressmeter_backbuffer = NULL;
	    vc_progressmeter_enable = FALSE;
	}
    }

    simple_unlock(&amp;vc_progress_lock);
    splx(s);

    <span class="enscript-keyword">if</span> (new_buffer)
    {
	<span class="enscript-keyword">if</span> (stashBackbuffer) IORecordProgressBackbuffer(new_buffer, 
	    		                                (kProgressBarWidth * vc_uiscale) 
	    		                                * (kProgressBarHeight * vc_uiscale) 
	    		                                * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>),
	    		                                vc_progress_white);
	kfree(new_buffer, (kProgressBarWidth * vc_uiscale) 
			* (kProgressBarHeight * vc_uiscale) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">internal_set_progressmeter</span>(<span class="enscript-type">int</span> new_value)
{
    <span class="enscript-type">int</span> x1, x3;
    <span class="enscript-type">int</span> capRedraw;
    <span class="enscript-comment">// 1 rounded fill, 0 square end
</span>    <span class="enscript-type">int</span> style = (0 == (2 &amp; vc_progress_withmeter));

    <span class="enscript-keyword">if</span> ((new_value &lt; 0) || (new_value &gt; kProgressMeterMax)) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (vc_progressmeter_enable)
    {
	vc_progressmeter_value = new_value;

	capRedraw = (style ? (kProgressBarCapWidth * vc_uiscale) : 0);
	x3 = (((kProgressBarWidth * vc_uiscale) - 2 * capRedraw) * vc_progressmeter_value) / kProgressMeterMax;
	x3 += (2 * capRedraw);

	<span class="enscript-keyword">if</span> (x3 &gt; vc_progressmeter_drawn)
	{
	    x1 = capRedraw;
	    <span class="enscript-keyword">if</span> (x1 &gt; vc_progressmeter_drawn) x1 = vc_progressmeter_drawn;
	    vc_draw_progress_meter(kDataAlpha, vc_progressmeter_drawn - x1, x3, x3);
        }
	<span class="enscript-keyword">else</span>
	{
	    vc_draw_progress_meter(kDataAlpha, x3 - capRedraw, vc_progressmeter_drawn, x3);
	}
	vc_progressmeter_drawn = x3;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vc_enable_progressmeter</span>(<span class="enscript-type">int</span> new_value)
{
    <span class="enscript-keyword">if</span> (kProgressMeterKernel == vc_progressmeter_enable)
    {
    	vc_progressmeter_hold = new_value;
    }
    <span class="enscript-keyword">else</span>
    {
	internal_enable_progressmeter(new_value ? kProgressMeterUser : kProgressMeterOff);
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vc_set_progressmeter</span>(<span class="enscript-type">int</span> new_value)
{
    spl_t s;

    s = splhigh();
    simple_lock(&amp;vc_progress_lock);

    <span class="enscript-keyword">if</span> (vc_progressmeter_enable &amp;&amp; (kProgressMeterKernel != vc_progressmeter_enable))
    {
	internal_set_progressmeter((new_value * kProgressMeterMax) / 100);
    }

    simple_unlock(&amp;vc_progress_lock);
    splx(s);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vc_set_options</span>(<span class="enscript-type">int</span> new_value)
{
     vc_user_options = new_value;
}


</pre>
<hr />
</body></html>