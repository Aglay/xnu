<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>default_pager_internal.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">default_pager_internal.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

<span class="enscript-comment">/*
 *	Default pager.
 *		General definitions.
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_DEFAULT_PAGER_INTERNAL_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_DEFAULT_PAGER_INTERNAL_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/diag.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;device/device_types.h&gt;</span>

<span class="enscript-comment">/*
 * Default option settings.
 */</span>
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">PARALLEL</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PARALLEL</span>	1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">CHECKSUM</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CHECKSUM</span>	0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACH_PORT_FACE</span> mach_port_t

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RECLAIM_SWAP</span>	1
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RECLAIM_SWAP</span>	0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">USE_PRECIOUS</span>	0

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">USER_PAGER</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UP</span>(stuff)	stuff
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* USER_PAGER */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UP</span>(stuff)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USER_PAGER */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">dprintf</span>(args)						\
	<span class="enscript-keyword">do</span> {							\
		printf(<span class="enscript-string">&quot;%s[KERNEL]: &quot;</span>, my_name);		\
		printf args;					\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Debug.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">char</span>	my_name[];

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_PAGER_DEBUG</span>	0

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEFAULT_PAGER_DEBUG</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	debug_mask;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DEBUG_MSG_EXTERNAL</span>	0x00000001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_MSG_INTERNAL</span>	0x00000002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_MO_EXTERNAL</span>	0x00000100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_MO_INTERNAL</span>	0x00000200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_VS_EXTERNAL</span>	0x00010000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_VS_INTERNAL</span>	0x00020000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_BS_EXTERNAL</span>	0x01000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_BS_INTERNAL</span>	0x02000000

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DP_DEBUG</span>(level, args)						\
	<span class="enscript-keyword">do</span> {								\
		<span class="enscript-keyword">if</span> (debug_mask &amp; (level)) 				\
			dprintf(args); 					\
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT</span>(expr)							\
	<span class="enscript-keyword">do</span> {								\
		<span class="enscript-keyword">if</span> (!(expr))						\
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
			panic(<span class="enscript-string">&quot;%s[%d]%s: assertion failed in %s line %d: %s&quot;</span>,\
			      my_name, dp_thread_id(), here,		\
			      __FILE__, __LINE__, # expr);		\
#<span class="enscript-reference">else</span>
		  panic(<span class="enscript-string">&quot;%s[KERNEL]: assertion failed in %s line %d: %s&quot;</span>,\
			      my_name, __FILE__, __LINE__, # expr); \
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* DEFAULT_PAGER_DEBUG */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DP_DEBUG</span>(level, args) do {} while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT</span>(clause) do {} while(0)

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEFAULT_PAGER_DEBUG */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">mach_error_string</span>(kern_return_t);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PAGER_SUCCESS</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PAGER_FULL</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PAGER_ERROR</span>	2

<span class="enscript-comment">/*
 * VM and IPC globals.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vm_page_size</span> PAGE_SIZE
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vm_page_mask</span> PAGE_MASK
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vm_page_shift</span> PAGE_SHIFT
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> vm_object_size_t	vm_page_size;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>	vm_page_mask;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		vm_page_shift;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ptoa</span>(p)	((p)*vm_page_size)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atop</span>(a)	((a)/vm_page_size)
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">howmany</span>(a,b)	((((a) % (b)) == 0) ? ((a) / (b)) : (((a) / (b)) + 1))

<span class="enscript-type">extern</span> memory_object_default_t	default_pager_object;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">extern</span> lck_mtx_t		dpt_lock;	<span class="enscript-comment">/* Lock for the dpt array */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	default_pager_internal_count;
<span class="enscript-type">extern</span> MACH_PORT_FACE	default_pager_host_port;
<span class="enscript-comment">/* extern task_t		default_pager_self; */</span>  <span class="enscript-comment">/* dont need or want */</span>
<span class="enscript-type">extern</span> MACH_PORT_FACE	default_pager_internal_set;
<span class="enscript-type">extern</span> MACH_PORT_FACE	default_pager_external_set;
<span class="enscript-type">extern</span> MACH_PORT_FACE	default_pager_default_set;
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> mach_port_t	default_pager_host_port;
<span class="enscript-type">extern</span> task_port_t	default_pager_self;
<span class="enscript-type">extern</span> mach_port_t	default_pager_internal_set;
<span class="enscript-type">extern</span> mach_port_t	default_pager_external_set;
<span class="enscript-type">extern</span> mach_port_t	default_pager_default_set;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> vm32_offset_t dp_offset_t;
<span class="enscript-type">typedef</span> vm32_size_t dp_size_t;
<span class="enscript-type">typedef</span> vm32_address_t dp_address_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> default_pager_thread {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
	cthread_t	dpt_thread;	<span class="enscript-comment">/* Server thread. */</span>
#<span class="enscript-reference">endif</span>
	vm_offset_t	dpt_buffer;	<span class="enscript-comment">/* Read buffer. */</span>
	boolean_t	dpt_internal;	<span class="enscript-comment">/* Do we handle internal objects? */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
	<span class="enscript-type">int</span>		dpt_id;		<span class="enscript-comment">/* thread id for printf */</span>
#<span class="enscript-reference">else</span>
	<span class="enscript-type">int</span>		checked_out;	
#<span class="enscript-reference">endif</span>
	boolean_t	dpt_initialized_p; <span class="enscript-comment">/* Thread is ready for requests.  */</span>
} default_pager_thread_t;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">extern</span> default_pager_thread_t	**dpt_array;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Global statistics.
 */</span>
<span class="enscript-type">struct</span> global_stats {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pageout_calls;	<span class="enscript-comment">/* # pageout calls */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pagein_calls;	<span class="enscript-comment">/* # pagein calls */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pages_in;		<span class="enscript-comment">/* # pages paged in (total) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pages_out;		<span class="enscript-comment">/* # pages paged out (total) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pages_unavail;	<span class="enscript-comment">/* # zero-fill pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pages_init;		<span class="enscript-comment">/* # page init requests */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	gs_pages_init_writes;	<span class="enscript-comment">/* # page init writes */</span>
	VSTATS_LOCK_DECL(gs_lock)
};
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> global_stats global_stats;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GSTAT</span>(clause)	VSTATS_ACTION(&amp;global_stats.gs_lock, (clause))

<span class="enscript-comment">/*
 * Cluster related definitions.
 * Clusters are sized in number of pages per cluster.
 * Cluster sizes must be powers of two.
 *
 * These numbers are related to the struct vs_map,
 * defined below.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_CLUSTER_SIZE</span> 8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_CLUSTER_SHIFT</span> 3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_CLSIZE</span> 0

<span class="enscript-comment">/*
 * bit map related macros
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBBY</span>		8	<span class="enscript-comment">/* bits per byte XXX */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BYTEMASK</span>	0xff
#<span class="enscript-reference">define</span> <span class="enscript-function-name">setbit</span>(a,i)	(*(((char *)(a)) + ((i)/NBBY)) |= 1&lt;&lt;((i)%NBBY))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">clrbit</span>(a,i)	(*(((char *)(a)) + ((i)/NBBY)) &amp;= ~(1&lt;&lt;((i)%NBBY)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isset</span>(a,i)	(*(((char *)(a)) + ((i)/NBBY)) &amp; (1&lt;&lt;((i)%NBBY)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isclr</span>(a,i)	((*(((char *)(a)) + ((i)/NBBY)) &amp; (1&lt;&lt;((i)%NBBY))) == 0)

<span class="enscript-comment">/*
 *	Default Pager.
 *		Backing Store Management.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BS_MAXPRI</span>	4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BS_MINPRI</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BS_NOPRI</span>	-1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BS_FULLPRI</span>	-2

<span class="enscript-comment">/*
 * Quick way to access the emergency segment backing store structures
 * without a full-blown search.
 */</span>
<span class="enscript-type">extern</span> MACH_PORT_FACE		emergency_segment_backing_store;

<span class="enscript-comment">/*
 * Mapping between backing store port and backing store object.
 */</span>
<span class="enscript-type">struct</span> backing_store {
	queue_chain_t	bs_links;	<span class="enscript-comment">/* link in backing_store_list */</span>
	lck_mtx_t		bs_lock;	<span class="enscript-comment">/* lock for the structure */</span>
	MACH_PORT_FACE	bs_port;	<span class="enscript-comment">/* backing store port */</span>
	<span class="enscript-type">int</span>		bs_priority;
	<span class="enscript-type">int</span>		bs_clsize;	<span class="enscript-comment">/* cluster size in pages */</span>

	<span class="enscript-comment">/* statistics */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bs_pages_free;		<span class="enscript-comment">/* # unallocated pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bs_pages_total;		<span class="enscript-comment">/* # pages (total) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bs_pages_in;		<span class="enscript-comment">/* # page read requests */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bs_pages_in_fail;	<span class="enscript-comment">/* # page read errors */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bs_pages_out;		<span class="enscript-comment">/* # page write requests */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bs_pages_out_fail;	<span class="enscript-comment">/* # page write errors */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> backing_store 	*backing_store_t;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BACKING_STORE_NULL</span>	((backing_store_t) 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BS_STAT</span>(bs, clause)	VSTATS_ACTION(&amp;(bs)-&gt;bs_lock, (clause))

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BS_LOCK_INIT</span>(bs)	lck_mtx_init(&amp;(bs)-&gt;bs_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BS_LOCK_DESTROY</span>(bs)	lck_mtx_destroy(&amp;(bs)-&gt;bs_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BS_LOCK</span>(bs)			lck_mtx_lock(&amp;(bs)-&gt;bs_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BS_UNLOCK</span>(bs)		lck_mtx_unlock(&amp;(bs)-&gt;bs_lock)

<span class="enscript-type">struct</span> backing_store_list_head {
	queue_head_t	bsl_queue;
	lck_mtx_t 	bsl_lock;
#<span class="enscript-reference">endif</span>
};
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> backing_store_list_head	backing_store_list;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	backing_store_release_trigger_disable;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSL_LOCK_INIT</span>()		lck_mtx_init(&amp;backing_store_list.bsl_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSL_LOCK_DESTROY</span>()	lck_mtx_destroy(&amp;backing_store_list.bsl_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BSL_LOCK</span>()			lck_mtx_lock(&amp;backing_store_list.bsl_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BSL_UNLOCK</span>()		lck_mtx_unlock(&amp;backing_store_list.bsl_lock)

<span class="enscript-comment">/*
 * 	Paging segment management.
 * 	Controls allocation of blocks within paging area.
 */</span>
<span class="enscript-type">struct</span> paging_segment {
	<span class="enscript-comment">/* device management */</span>
	<span class="enscript-type">union</span> {
		MACH_PORT_FACE	dev;		<span class="enscript-comment">/* Port to device */</span>
	 	<span class="enscript-type">struct</span> vnode	*vnode;		<span class="enscript-comment">/* vnode for bs file */</span>
	} storage_type;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_segtype;	<span class="enscript-comment">/* file type or partition */</span>
	MACH_PORT_FACE	ps_device;	<span class="enscript-comment">/* Port to device */</span>
	dp_offset_t	ps_offset;	<span class="enscript-comment">/* Offset of segment within device */</span>
	dp_offset_t	ps_recnum;	<span class="enscript-comment">/* Number of device records in segment*/</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_pgnum;	<span class="enscript-comment">/* Number of pages in segment */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_record_shift;<span class="enscript-comment">/* Bit shift: pages to device records */</span>

	<span class="enscript-comment">/* clusters and pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_clshift;	<span class="enscript-comment">/* Bit shift: clusters to pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_ncls;	<span class="enscript-comment">/* Number of clusters in segment */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_clcount;	<span class="enscript-comment">/* Number of free clusters */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_pgcount;	<span class="enscript-comment">/* Number of free pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_hint;	<span class="enscript-comment">/* Hint of where to look next. */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_special_clusters; <span class="enscript-comment">/* Clusters that might come in while we've 
					* released the locks doing a ps_delete.
					*/</span>

	<span class="enscript-comment">/* bitmap */</span>
	lck_mtx_t		ps_lock;	<span class="enscript-comment">/* Lock for contents of struct */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*ps_bmap;	<span class="enscript-comment">/* Map of used clusters */</span>
	
	<span class="enscript-comment">/* backing store */</span>
	backing_store_t	ps_bs;		<span class="enscript-comment">/* Backing store segment belongs to */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PS_CAN_USE</span>		0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PS_GOING_AWAY</span>		0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PS_EMERGENCY_SEGMENT</span>	0x4
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_state;
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_PS_OK_TO_USE</span>(ps)		((ps-&gt;ps_state &amp; PS_CAN_USE) == PS_CAN_USE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_PS_GOING_AWAY</span>(ps)		((ps-&gt;ps_state &amp; PS_GOING_AWAY) == PS_GOING_AWAY)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_PS_EMERGENCY_SEGMENT</span>(ps)	((ps-&gt;ps_state &amp; PS_EMERGENCY_SEGMENT) == PS_EMERGENCY_SEGMENT)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ps_vnode</span>	storage_type.vnode
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ps_device</span>	storage_type.dev
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PS_PARTITION</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PS_FILE</span>	2

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> paging_segment *paging_segment_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAGING_SEGMENT_NULL</span>	((paging_segment_t) 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PS_LOCK_INIT</span>(ps)	lck_mtx_init(&amp;(ps)-&gt;ps_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PS_LOCK_DESTROY</span>(ps)	lck_mtx_destroy(&amp;(ps)-&gt;ps_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PS_LOCK</span>(ps)			lck_mtx_lock(&amp;(ps)-&gt;ps_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PS_UNLOCK</span>(ps)		lck_mtx_unlock(&amp;(ps)-&gt;ps_lock)

<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	pseg_index_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INVALID_PSEG_INDEX</span>	((pseg_index_t)-1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EMERGENCY_PSEG_INDEX</span>		((pseg_index_t) 0)
<span class="enscript-comment">/*
 * MAX_PSEG_INDEX value is related to struct vs_map below.
 * &quot;0&quot; is reserved for empty map entries (no segment).
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_PSEG_INDEX</span>	63	<span class="enscript-comment">/* 0 is reserved for empty map */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_NUM_PAGING_SEGMENTS</span> MAX_PSEG_INDEX

<span class="enscript-comment">/* paging segments array */</span>
<span class="enscript-type">extern</span> paging_segment_t	paging_segments[MAX_NUM_PAGING_SEGMENTS];
<span class="enscript-type">extern</span> lck_mtx_t paging_segments_lock;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	paging_segment_count;	<span class="enscript-comment">/* number of active paging segments */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	paging_segment_max;	<span class="enscript-comment">/* highest used paging segment index */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ps_select_array[DEFAULT_PAGER_BACKING_STORE_MAXPRI+1];

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PSL_LOCK_INIT</span>()		lck_mtx_init(&amp;paging_segments_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PSL_LOCK_DESTROY</span>()	lck_mtx_destroy(&amp;paging_segments_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PSL_LOCK</span>()		lck_mtx_lock(&amp;paging_segments_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PSL_UNLOCK</span>()	lck_mtx_unlock(&amp;paging_segments_lock)

<span class="enscript-comment">/*
 * Vstruct manipulation.  The vstruct is the pager's internal
 * representation of vm objects it manages.  There is one vstruct allocated
 * per vm object.
 *
 * The following data structures are defined for vstruct and vm object
 * management.
 */</span>

<span class="enscript-comment">/*
 * vs_map
 * A structure used only for temporary objects.  It is the element
 * contained in the vs_clmap structure, which contains information
 * about which clusters and pages in an object are present on backing
 * store (a paging file).
 * Note that this structure and its associated constants may change
 * with minimal impact on code.  The only function which knows the
 * internals of this structure is ps_clmap().
 *
 * If it is necessary to change the maximum number of paging segments
 * or pages in a cluster, then this structure is the one most
 * affected.   The constants and structures which *may* change are:
 *	MAX_CLUSTER_SIZE
 *	MAX_CLUSTER_SHIFT
 *	MAX_NUM_PAGING_SEGMENTS
 *	VSTRUCT_DEF_CLSHIFT
 *	struct vs_map and associated macros and constants (VSM_*)
 *	  (only the macro definitions need change, the exported (inside the
 *	   pager only) interfaces remain the same; the constants are for
 *	   internal vs_map manipulation only).
 *	struct clbmap (below).
 */</span>
<span class="enscript-type">struct</span> vs_map {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vsmap_entry:23,		<span class="enscript-comment">/* offset in paging segment */</span>
			<span class="enscript-reference">vsmap_psindex</span>:8,	<span class="enscript-comment">/* paging segment */</span>
			<span class="enscript-reference">vsmap_error</span>:1,
			<span class="enscript-reference">vsmap_bmap</span>:16,
			<span class="enscript-reference">vsmap_alloc</span>:16;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vs_map *vs_map_t;


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSM_ENTRY_NULL</span>	0x7fffff

<span class="enscript-comment">/*
 * Exported macros for manipulating the vs_map structure --
 * checking status, getting and setting bits.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSCLSIZE</span>(vs)		(1U &lt;&lt; (vs)-&gt;vs_clshift)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_ISCLR</span>(vsm)		(((vsm).vsmap_entry == VSM_ENTRY_NULL) &amp;&amp;   \
					((vsm).vsmap_error == 0))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_ISERR</span>(vsm)		((vsm).vsmap_error)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_SETCLOFF</span>(vsm, val)	((vsm).vsmap_entry = (val))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_SETERR</span>(vsm, err)	((vsm).vsmap_error = 1,   \
					(vsm).vsmap_entry = (err))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_GETERR</span>(vsm)		((vsm).vsmap_entry)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_SETPG</span>(vsm, page)	((vsm).vsmap_bmap |= (1 &lt;&lt; (page)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_CLRPG</span>(vsm, page)	((vsm).vsmap_bmap &amp;= ~(1 &lt;&lt; (page)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_SETPS</span>(vsm, psindx)	((vsm).vsmap_psindex = (psindx))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_PSINDEX</span>(vsm)	((vsm).vsmap_psindex)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_PS</span>(vsm)		paging_segments[(vsm).vsmap_psindex]
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_BMAP</span>(vsm)		((vsm).vsmap_bmap)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_CLOFF</span>(vsm)		((vsm).vsmap_entry)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_CLR</span>(vsm)		((vsm).vsmap_entry = VSM_ENTRY_NULL,   \
					(vsm).vsmap_psindex = 0,   \
					(vsm).vsmap_error = 0,	   \
					(vsm).vsmap_bmap = 0,	   \
					(vsm).vsmap_alloc = 0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_ALLOC</span>(vsm)		((vsm).vsmap_alloc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_SETALLOC</span>(vsm, page)	((vsm).vsmap_alloc |= (1 &lt;&lt; (page)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VSM_CLRALLOC</span>(vsm, page)	((vsm).vsmap_alloc &amp;= ~(1 &lt;&lt; (page)))

<span class="enscript-comment">/*
 * Constants and macros for dealing with vstruct maps,
 * which comprise vs_map structures, which
 * map vm objects to backing storage (paging files and clusters).
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLMAP_THRESHOLD</span>	512 	<span class="enscript-comment">/* bytes */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CLMAP_ENTRIES</span>		(CLMAP_THRESHOLD/(int)sizeof(struct vs_map))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CLMAP_SIZE</span>(ncls)	(ncls*(int)sizeof(struct vs_map))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INDIRECT_CLMAP_ENTRIES</span>(ncls) (((ncls-1)/CLMAP_ENTRIES) + 1)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">INDIRECT_CLMAP_SIZE</span>(ncls) (INDIRECT_CLMAP_ENTRIES(ncls) * (int)sizeof(struct vs_map *))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">INDIRECT_CLMAP</span>(size)	(CLMAP_SIZE(size) &gt; CLMAP_THRESHOLD)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RMAPSIZE</span>(blocks) 	(howmany(blocks,NBBY))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_FIND</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_ALLOC</span> 2

<span class="enscript-comment">/*
 * clmap
 *
 * A cluster map returned by ps_clmap.  It is an abstracted cluster of
 * pages.  It gives the caller information about the cluster
 * desired.  On read it tells the caller if a cluster is mapped, and if so,
 * which of its pages are valid.  It should not be referenced directly,
 * except by  ps_clmap; macros should be used.  If the number of pages
 * in a cluster needs to be more than 32, then the struct clbmap must
 * become larger.
 */</span>
<span class="enscript-type">struct</span> clbmap {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	clb_map;
};

<span class="enscript-type">struct</span> clmap {
	paging_segment_t cl_ps;		<span class="enscript-comment">/* paging segment backing cluster */</span>
	<span class="enscript-type">int</span>		cl_numpages;	<span class="enscript-comment">/* number of valid pages */</span>
	<span class="enscript-type">struct</span> clbmap	cl_bmap;	<span class="enscript-comment">/* map of pages in cluster */</span>
	<span class="enscript-type">int</span>		cl_error;	<span class="enscript-comment">/* cluster error value */</span>
	<span class="enscript-type">struct</span> clbmap	cl_alloc;	<span class="enscript-comment">/* map of allocated pages in cluster */</span>
};

#<span class="enscript-reference">define</span>  <span class="enscript-function-name">CLMAP_ERROR</span>(clm)	(clm).cl_error
#<span class="enscript-reference">define</span>  <span class="enscript-function-name">CLMAP_PS</span>(clm)		(clm).cl_ps
#<span class="enscript-reference">define</span>  <span class="enscript-function-name">CLMAP_NPGS</span>(clm)	(clm).cl_numpages
#<span class="enscript-reference">define</span>	 <span class="enscript-function-name">CLMAP_ISSET</span>(clm,i)	((1&lt;&lt;(i))&amp;((clm).cl_bmap.clb_map))
#<span class="enscript-reference">define</span>  <span class="enscript-function-name">CLMAP_ALLOC</span>(clm)	(clm).cl_alloc.clb_map
<span class="enscript-comment">/*
 * Shift off unused bits in a partial cluster
 */</span>
#<span class="enscript-reference">define</span>  <span class="enscript-function-name">CLMAP_SHIFT</span>(clm,vs)	\
	(clm)-&gt;cl_bmap.clb_map &gt;&gt;= (VSCLSIZE(vs) - (clm)-&gt;cl_numpages)
#<span class="enscript-reference">define</span>  <span class="enscript-function-name">CLMAP_SHIFTALLOC</span>(clm,vs)	\
	(clm)-&gt;cl_alloc.clb_map &gt;&gt;= (VSCLSIZE(vs) - (clm)-&gt;cl_numpages)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vstruct_alias {
	memory_object_pager_ops_t name;
	<span class="enscript-type">struct</span> vstruct *vs;
} vstruct_alias_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPT_LOCK_INIT</span>(lock)		lck_mtx_init(&amp;(lock), &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPT_LOCK_DESTROY</span>(lock)		lck_mtx_destroy(&amp;(lock), &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPT_LOCK</span>(lock)			lck_mtx_lock(&amp;(lock))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPT_UNLOCK</span>(lock)		lck_mtx_unlock(&amp;(lock))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPT_SLEEP</span>(lock, e, i)	lck_mtx_sleep(&amp;(lock), LCK_SLEEP_DEFAULT, (event_t)(e), i)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VS_LOCK_TYPE</span>			hw_lock_data_t
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_LOCK_INIT</span>(vs)		hw_lock_init(&amp;(vs)-&gt;vs_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_TRY_LOCK</span>(vs)			(VS_LOCK(vs),TRUE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_LOCK</span>(vs)				hw_lock_lock(&amp;(vs)-&gt;vs_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_UNLOCK</span>(vs)			hw_lock_unlock(&amp;(vs)-&gt;vs_lock)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VS_MAP_LOCK_TYPE</span>		lck_mtx_t
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_MAP_LOCK_INIT</span>(vs)	lck_mtx_init(&amp;(vs)-&gt;vs_map_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_MAP_LOCK_DESTROY</span>(vs)	lck_mtx_destroy(&amp;(vs)-&gt;vs_map_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_MAP_LOCK</span>(vs)			lck_mtx_lock(&amp;(vs)-&gt;vs_map_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_MAP_TRY_LOCK</span>(vs)		lck_mtx_try_lock(&amp;(vs)-&gt;vs_map_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_MAP_UNLOCK</span>(vs)		lck_mtx_unlock(&amp;(vs)-&gt;vs_map_lock)


<span class="enscript-comment">/*
 * VM Object Structure:  This is the structure used to manage
 * default pager object associations with their control counter-
 * parts (VM objects).
 *
 * The start of this structure MUST match a &quot;struct memory_object&quot;.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vstruct {
	<span class="enscript-type">struct</span> ipc_object_header	vs_pager_header;	<span class="enscript-comment">/* fake ip_kotype() */</span>
	memory_object_pager_ops_t vs_pager_ops; <span class="enscript-comment">/* == &amp;default_pager_ops */</span>
	memory_object_control_t vs_control;	<span class="enscript-comment">/* our mem obj control ref */</span>
	VS_LOCK_TYPE		vs_lock;	<span class="enscript-comment">/* data for the lock */</span>

	<span class="enscript-comment">/* JMM - Could combine these first two in a single pending count now */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_next_seqno;	<span class="enscript-comment">/* next sequence num to issue */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_seqno;	<span class="enscript-comment">/* Pager port sequence number */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_readers;	<span class="enscript-comment">/* Reads in progress */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_writers;	<span class="enscript-comment">/* Writes in progress */</span>

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
	<span class="enscript-comment">/* boolean_t */</span>		vs_waiting_seqno:1,	<span class="enscript-comment">/* to wait on seqno */</span>
	<span class="enscript-comment">/* boolean_t */</span>		vs_waiting_read:1, 	<span class="enscript-comment">/* waiting on reader? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		vs_waiting_write:1,	<span class="enscript-comment">/* waiting on writer? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		vs_waiting_async:1,	<span class="enscript-comment">/* waiting on async? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		vs_indirect:1,		<span class="enscript-comment">/* map indirect? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		vs_xfer_pending:1;	<span class="enscript-comment">/* xfer out of seg? */</span>

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_async_pending;<span class="enscript-comment">/* pending async write count */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_errors;	<span class="enscript-comment">/* Pageout error count */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_references;	<span class="enscript-comment">/* references */</span>

	queue_chain_t		vs_links;	<span class="enscript-comment">/* Link in pager-wide list */</span>

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_clshift;	<span class="enscript-comment">/* Bit shift: clusters-&gt;pages */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vs_size;	<span class="enscript-comment">/* Object size in clusters */</span>
	lck_mtx_t		vs_map_lock;	<span class="enscript-comment">/* to protect map below */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> vs_map	*vsu_dmap;	<span class="enscript-comment">/* Direct map of clusters */</span>
		<span class="enscript-type">struct</span> vs_map	**vsu_imap;	<span class="enscript-comment">/* Indirect map of clusters */</span>
	} vs_un;
} *vstruct_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vs_dmap</span> vs_un.vsu_dmap
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vs_imap</span> vs_un.vsu_imap

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSTRUCT_NULL</span>	((vstruct_t) 0)

__private_extern__ <span class="enscript-type">void</span> vs_async_wait(vstruct_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PARALLEL</span>
__private_extern__ <span class="enscript-type">void</span> vs_lock(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_unlock(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_start_read(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_finish_read(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_wait_for_readers(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_start_write(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_finish_write(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_wait_for_writers(vstruct_t);
__private_extern__ <span class="enscript-type">void</span> vs_wait_for_sync_writers(vstruct_t);
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* PARALLEL */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_lock</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_unlock</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_start_read</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_wait_for_readers</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_finish_read</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_start_write</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_wait_for_writers</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_wait_for_sync_writers</span>(vs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_finish_write</span>(vs)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PARALLEL */</span>

<span class="enscript-comment">/*
 * Data structures and variables dealing with asynchronous
 * completion of paging operations.
 */</span>
<span class="enscript-comment">/*
 * vs_async
 * 	A structure passed to ps_write_device for asynchronous completions.
 * 	It contains enough information to complete the write and
 *	inform the VM of its completion.
 */</span>
<span class="enscript-type">struct</span> vs_async {
	<span class="enscript-type">struct</span> vs_async	*vsa_next;	<span class="enscript-comment">/* pointer to next structure */</span>
	vstruct_t	vsa_vs;		<span class="enscript-comment">/* the vstruct for the object */</span>
	vm_offset_t	vsa_addr;	<span class="enscript-comment">/* the vaddr of the data moved */</span>
	vm_offset_t	vsa_offset;	<span class="enscript-comment">/* the object offset of the data */</span>
	vm_size_t	vsa_size;	<span class="enscript-comment">/* the number of bytes moved */</span>
	paging_segment_t vsa_ps;	<span class="enscript-comment">/* the paging segment used */</span>
	<span class="enscript-type">int</span>		vsa_flags;	<span class="enscript-comment">/* flags */</span>
	<span class="enscript-type">int</span>		vsa_error;	<span class="enscript-comment">/* error, if there is one */</span>
	MACH_PORT_FACE	reply_port;	<span class="enscript-comment">/* associated reply port */</span>
};

<span class="enscript-comment">/*
 * flags values.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSA_READ</span>	0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSA_WRITE</span>	0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSA_TRANSFER</span>	0x0004

<span class="enscript-comment">/*
 * List of all vstructs.  A specific vstruct is
 * found directly via its port, this list is
 * only used for monitoring purposes by the
 * default_pager_object* calls
 */</span>
<span class="enscript-type">struct</span> vstruct_list_head {
	queue_head_t	vsl_queue;
	lck_mtx_t		vsl_lock;
	<span class="enscript-type">int</span>		vsl_count;	<span class="enscript-comment">/* saves code */</span>
};

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vstruct_list_head	vstruct_list;

__private_extern__ <span class="enscript-type">void</span> vstruct_list_insert(vstruct_t vs);
__private_extern__ <span class="enscript-type">void</span> vstruct_list_delete(vstruct_t vs);


<span class="enscript-type">extern</span> lck_grp_t		default_pager_lck_grp;
<span class="enscript-type">extern</span> lck_attr_t		default_pager_lck_attr;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VSL_LOCK_INIT</span>()		lck_mtx_init(&amp;vstruct_list.vsl_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VSL_LOCK_DESTROY</span>()	lck_mtx_destroy(&amp;vstruct_list.vsl_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VSL_LOCK</span>()			lck_mtx_lock(&amp;vstruct_list.vsl_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VSL_LOCK_TRY</span>()		lck_mtx_try_lock(&amp;vstruct_list.vsl_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VSL_UNLOCK</span>()		lck_mtx_unlock(&amp;vstruct_list.vsl_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VSL_SLEEP</span>(e,i)		lck_mtx_sleep(&amp;vstruct_list.vsl_lock, LCK_SLEEP_DEFAULT, (e), (i))

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">extern</span> zone_t	vstruct_zone;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Create port alias for vstruct address.
 *
 * We assume that the last two bits of a vstruct address will be zero due to
 * memory allocation restrictions, hence are available for use as a sanity
 * check.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> memory_object_pager_ops default_pager_ops;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mem_obj_is_vs</span>(_mem_obj_)					\
	(((_mem_obj_) != NULL) &amp;&amp;					\
	 ((_mem_obj_)-&gt;mo_pager_ops == &amp;default_pager_ops))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mem_obj_to_vs</span>(_mem_obj_)					\
	((vstruct_t)(_mem_obj_))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vs_to_mem_obj</span>(_vs_) ((memory_object_t)(_vs_))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vs_lookup</span>(_mem_obj_, _vs_)					\
	<span class="enscript-keyword">do</span> {								\
	<span class="enscript-keyword">if</span> (!mem_obj_is_vs(_mem_obj_))					\
		panic(<span class="enscript-string">&quot;bad dp memory object&quot;</span>);				\
	_vs_ = mem_obj_to_vs(_mem_obj_);				\
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vs_lookup_safe</span>(_mem_obj_, _vs_)					\
	<span class="enscript-keyword">do</span> {								\
	<span class="enscript-keyword">if</span> (!mem_obj_is_vs(_mem_obj_))					\
		_vs_ = VSTRUCT_NULL;					\
	<span class="enscript-keyword">else</span>								\
		_vs_ = mem_obj_to_vs(_mem_obj_);			\
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vs_to_port</span>(_vs_)	(((vm_offset_t)(_vs_))+1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">port_to_vs</span>(_port_)	((vstruct_t)(((vm_offset_t)(_port_))&amp;~3))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">port_is_vs</span>(_port_)	((((vm_offset_t)(_port_))&amp;3) == 1)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vs_lookup</span>(_port_, _vs_)						\
	<span class="enscript-keyword">do</span> {								\
		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(_port_) || !port_is_vs(_port_)	\
		    || port_to_vs(_port_)-&gt;vs_mem_obj != (_port_))	\
			Panic(<span class="enscript-string">&quot;bad pager port&quot;</span>);			\
		_vs_ = port_to_vs(_port_);				\
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Cross-module routines declaration.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		dp_thread_id(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> boolean_t	device_reply_server(mach_msg_header_t *,
					    mach_msg_header_t *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">extern</span> boolean_t	default_pager_no_senders(memory_object_t,
						 mach_port_mscount_t);
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		default_pager_no_senders(memory_object_t,
						 mach_port_seqno_t,
						 mach_port_mscount_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		local_log2(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		bs_initialize(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		bs_global_info(uint64_t *,
				       uint64_t *);
<span class="enscript-type">extern</span> boolean_t	bs_add_device(<span class="enscript-type">char</span> *,
				      MACH_PORT_FACE);
<span class="enscript-type">extern</span> vstruct_t	ps_vstruct_create(dp_size_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		ps_vstruct_dealloc(vstruct_t);
<span class="enscript-type">extern</span> kern_return_t	ps_vstruct_reclaim(vstruct_t,
					   boolean_t,
					   boolean_t);
<span class="enscript-type">extern</span> kern_return_t	pvs_cluster_read(vstruct_t,
					 dp_offset_t,
					 dp_size_t,
					 <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> kern_return_t	vs_cluster_write(vstruct_t,
					 upl_t,
					 upl_offset_t,
					 upl_size_t,
					 boolean_t,
					 <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> dp_offset_t	ps_clmap(vstruct_t,
				 dp_offset_t,
				 <span class="enscript-type">struct</span> clmap *,
				 <span class="enscript-type">int</span>,
				 dp_size_t,
				 <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> vm_size_t	ps_vstruct_allocated_size(vstruct_t);
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ps_vstruct_allocated_pages(vstruct_t,
						   default_pager_page_t *,
						   <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> boolean_t	bs_set_default_clsize(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> boolean_t	verbose;

<span class="enscript-type">extern</span> thread_call_t	default_pager_backing_store_monitor_callout;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		default_pager_backing_store_monitor(thread_call_param_t, thread_call_param_t);

<span class="enscript-type">extern</span> ipc_port_t	max_pages_trigger_port;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	dp_pages_free;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	maximum_pages_free;

<span class="enscript-comment">/* Do we know yet if swap files need to be encrypted ? */</span>
<span class="enscript-type">extern</span> boolean_t	dp_encryption_inited;
<span class="enscript-comment">/* Should we encrypt data before writing to swap ? */</span>
<span class="enscript-type">extern</span> boolean_t	dp_encryption;

<span class="enscript-type">extern</span> boolean_t	dp_isssd;

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _DEFAULT_PAGER_INTERNAL_H_ */</span>
</pre>
<hr />
</body></html>