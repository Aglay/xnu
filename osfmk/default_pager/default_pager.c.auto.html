<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>default_pager.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">default_pager.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

<span class="enscript-comment">/*
 * 	Default pager.
 * 		Threads management.
 *		Requests handling.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;default_pager_internal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_object_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>

<span class="enscript-type">char</span>	my_name[] = <span class="enscript-string">&quot;(default pager): &quot;</span>;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEFAULT_PAGER_DEBUG</span>
<span class="enscript-type">int</span>	debug_mask = 0;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEFAULT_PAGER_DEBUG */</span>

<span class="enscript-comment">/*
 * Use 16 Kbyte stacks instead of the default 64K.
 * Use 4 Kbyte waiting stacks instead of the default 8K.
 */</span>

vm_size_t	cthread_stack_size = 16 *1024;
<span class="enscript-type">extern</span> vm_size_t cthread_wait_stack_size;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>	vm_page_mask;
<span class="enscript-type">int</span>		vm_page_shift;
#<span class="enscript-reference">endif</span>

boolean_t	verbose;

<span class="enscript-comment">/* task_t default_pager_self; */</span>	<span class="enscript-comment">/* Our task port. */</span>
lck_mtx_t				dpt_lock;       <span class="enscript-comment">/* lock for the dpt array struct */</span>
default_pager_thread_t	**dpt_array;

memory_object_default_t default_pager_object; <span class="enscript-comment">/* for memory_object_create. */</span>

MACH_PORT_FACE default_pager_default_set; <span class="enscript-comment">/* Port set for &quot;default&quot; thread. */</span>
MACH_PORT_FACE default_pager_internal_set; <span class="enscript-comment">/* Port set for internal objects. */</span>
MACH_PORT_FACE default_pager_external_set; <span class="enscript-comment">/* Port set for external objects. */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_PAGER_INTERNAL_COUNT</span>	(4)


<span class="enscript-comment">/* Memory created by default_pager_object_create should mostly be resident. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_PAGER_EXTERNAL_COUNT</span>	(2)

<span class="enscript-type">int</span>	default_pager_internal_count = DEFAULT_PAGER_INTERNAL_COUNT;
<span class="enscript-comment">/* Number of &quot;internal&quot; threads. */</span>
<span class="enscript-type">int</span>	default_pager_external_count = DEFAULT_PAGER_EXTERNAL_COUNT;
<span class="enscript-comment">/* Number of &quot;external&quot; threads. */</span>

<span class="enscript-comment">/*
 * Forward declarations.
 */</span>
boolean_t <span class="enscript-function-name">default_pager_notify_server</span>(mach_msg_header_t *,
				      mach_msg_header_t *);
boolean_t <span class="enscript-function-name">default_pager_demux_object</span>(mach_msg_header_t *,
				     mach_msg_header_t *);
boolean_t <span class="enscript-function-name">default_pager_demux_default</span>(mach_msg_header_t *,
				      mach_msg_header_t *);
default_pager_thread_t *<span class="enscript-function-name">start_default_pager_thread</span>(<span class="enscript-type">int</span>, boolean_t);
<span class="enscript-type">void</span>	default_pager(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	default_pager_thread(<span class="enscript-type">void</span> *);
<span class="enscript-type">void</span>	default_pager_initialize(<span class="enscript-type">void</span>);
boolean_t	dp_parse_argument(<span class="enscript-type">char</span> *);	<span class="enscript-comment">/* forward; */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	d_to_i(<span class="enscript-type">char</span> *);			<span class="enscript-comment">/* forward; */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> vstruct_def_clshift;

<span class="enscript-type">struct</span> global_stats global_stats;

<span class="enscript-comment">/*
 * Initialize and Run the default pager
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">default_pager</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>			i, id;
	__unused <span class="enscript-type">static</span> <span class="enscript-type">char</span> here[] = <span class="enscript-string">&quot;default_pager&quot;</span>;
	default_pager_thread_t	dpt;
	kern_return_t kr;



	<span class="enscript-comment">/*
	 * Give me space for the thread array and zero it.
	 */</span>
	i = default_pager_internal_count + default_pager_external_count + 1;
	dpt_array = (default_pager_thread_t **)
	    kalloc(i * <span class="enscript-keyword">sizeof</span>(default_pager_thread_t *));
	memset(dpt_array, 0, i * <span class="enscript-keyword">sizeof</span>(default_pager_thread_t *));

	<span class="enscript-comment">/* Setup my thread structure.  */</span>
	id = 0;
	dpt.dpt_buffer = 0;
	dpt.dpt_internal = FALSE;
	dpt.dpt_initialized_p = TRUE;
	dpt_array[0] = &amp;dpt;

	<span class="enscript-comment">/*
	 * Now we create the threads that will actually
	 * manage objects.
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; default_pager_internal_count; i++) {
		dpt_array[id] = (default_pager_thread_t *)
				kalloc(<span class="enscript-keyword">sizeof</span> (default_pager_thread_t));
		<span class="enscript-keyword">if</span> (dpt_array[id] == NULL)
	 		Panic(<span class="enscript-string">&quot;alloc pager thread&quot;</span>);
		kr = vm_allocate(kernel_map, &amp;((dpt_array[id])-&gt;dpt_buffer),
				 vm_page_size &lt;&lt; vstruct_def_clshift, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_OSFMK));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			Panic(<span class="enscript-string">&quot;alloc thread buffer&quot;</span>);
		kr = vm_map_wire(kernel_map, (dpt_array[id])-&gt;dpt_buffer, 
			((dpt_array[id])-&gt;dpt_buffer)
					+(vm_page_size &lt;&lt; vstruct_def_clshift), 
			VM_PROT_DEFAULT | VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_OSFMK),
			FALSE);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			Panic(<span class="enscript-string">&quot;wire thread buffer&quot;</span>);
		(dpt_array[id])-&gt;dpt_internal = TRUE;
		(dpt_array[id])-&gt;dpt_initialized_p = TRUE;
		(dpt_array[id])-&gt;checked_out = FALSE;
		id++;
	}
	DPT_LOCK_INIT(dpt_lock);
}






<span class="enscript-comment">/* simple utility: only works for 2^n */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">local_log2</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> n)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	i = 0;

	<span class="enscript-keyword">if</span>(n == 0) <span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">while</span> ((n &amp; 1) == 0) {
		i++;
		n &gt;&gt;= 1;
	}
	<span class="enscript-keyword">return</span> i;
}




<span class="enscript-comment">/* another simple utility, d_to_i(char*) supporting only decimal
 * and devoid of range checking; obscure name chosen deliberately
 * to avoid confusion with semantic-rich POSIX routines */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">d_to_i</span>(<span class="enscript-type">char</span> * arg)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rval = 0;
    <span class="enscript-type">char</span> ch;

    <span class="enscript-keyword">while</span> ((ch = *arg++) &amp;&amp; ch &gt;= <span class="enscript-string">'0'</span> &amp;&amp; ch &lt;= <span class="enscript-string">'9'</span>) {
	rval *= 10;
	rval += ch - <span class="enscript-string">'0'</span>;
    }
    <span class="enscript-keyword">return</span>(rval);
}




<span class="enscript-comment">/*
 * Check for non-disk-partition arguments of the form
 *	attribute=argument
 * returning TRUE if one if found
 */</span>
boolean_t <span class="enscript-function-name">dp_parse_argument</span>(<span class="enscript-type">char</span> *av)
{
	<span class="enscript-type">char</span> *rhs = av;
	__unused <span class="enscript-type">static</span> <span class="enscript-type">char</span>	here[] = <span class="enscript-string">&quot;dp_parse_argument&quot;</span>;

	<span class="enscript-comment">/* Check for '-v' flag */</span>

	<span class="enscript-keyword">if</span> (av[0] == <span class="enscript-string">'-'</span> &amp;&amp; av[1] == <span class="enscript-string">'v'</span> &amp;&amp; av[2] == 0) {
		verbose = TRUE ;
		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-comment">/*
	 * If we find a '=' followed by an argument in the string,
	 * check for known arguments
	 */</span>
	<span class="enscript-keyword">while</span> (*rhs &amp;&amp; *rhs != <span class="enscript-string">'='</span>)
		rhs++;
	<span class="enscript-keyword">if</span> (*rhs &amp;&amp; *++rhs) {
		<span class="enscript-comment">/* clsize=N pages */</span>
		<span class="enscript-keyword">if</span> (strprefix(av,<span class="enscript-string">&quot;cl&quot;</span>)) {
			<span class="enscript-keyword">if</span> (!bs_set_default_clsize(d_to_i(rhs)))
				dprintf((<span class="enscript-string">&quot;Bad argument (%s) - ignored\n&quot;</span>, av));
			<span class="enscript-keyword">return</span>(TRUE);
		}
		<span class="enscript-comment">/* else if strprefix(av,&quot;another_argument&quot;)) {
			handle_another_argument(av);
			return(TRUE);
		} */</span>
	}
	<span class="enscript-keyword">return</span>(FALSE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">start_def_pager</span>( __unused <span class="enscript-type">char</span> *bs_device )
{
<span class="enscript-comment">/*
	MACH_PORT_FACE		master_device_port;
*/</span>
<span class="enscript-comment">/*
	MACH_PORT_FACE		security_port;
*/</span>
	__unused <span class="enscript-type">static</span> <span class="enscript-type">char</span> here[] = <span class="enscript-string">&quot;main&quot;</span>;




	<span class="enscript-comment">/* setup read buffers, etc */</span>
	default_pager_initialize();

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>	
	default_pager();
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (DEFAULT_PAGER_IS_ACTIVE) {
		<span class="enscript-comment">/* start the backing store monitor, it runs on a callout thread */</span>
		default_pager_backing_store_monitor_callout = 
			thread_call_allocate(default_pager_backing_store_monitor, NULL);
		<span class="enscript-keyword">if</span> (!default_pager_backing_store_monitor_callout)
			panic(<span class="enscript-string">&quot;can't start backing store monitor thread&quot;</span>);
		thread_call_enter(default_pager_backing_store_monitor_callout);
	}

	<span class="enscript-keyword">return</span> (0);
}

kern_return_t
<span class="enscript-function-name">default_pager_info</span>(
	memory_object_default_t	pager,
	default_pager_info_t	*infop)
{
	uint64_t	pages_total, pages_free;

	<span class="enscript-keyword">if</span> (pager != default_pager_object)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT; 

	bs_global_info(&amp;pages_total, &amp;pages_free);

	infop-&gt;dpi_total_space = (vm_size_t) ptoa_64(pages_total);
	infop-&gt;dpi_free_space = (vm_size_t) ptoa_64(pages_free);
	infop-&gt;dpi_page_size = vm_page_size;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


kern_return_t
<span class="enscript-function-name">default_pager_info_64</span>(
	memory_object_default_t	pager,
	default_pager_info_64_t	*infop)
{
	uint64_t	pages_total, pages_free;

	<span class="enscript-keyword">if</span> (pager != default_pager_object)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT; 

	bs_global_info(&amp;pages_total, &amp;pages_free);

	infop-&gt;dpi_total_space = ptoa_64(pages_total);
	infop-&gt;dpi_free_space = ptoa_64(pages_free);
	infop-&gt;dpi_page_size = vm_page_size;
	infop-&gt;dpi_flags = 0;
	<span class="enscript-keyword">if</span> (dp_encryption_inited &amp;&amp; dp_encryption == TRUE) {
		infop-&gt;dpi_flags |= DPI_ENCRYPTED;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

lck_grp_t		default_pager_lck_grp;
lck_grp_attr_t	default_pager_lck_grp_attr;
lck_attr_t		default_pager_lck_attr;



<span class="enscript-type">void</span>
<span class="enscript-function-name">default_pager_initialize</span>(<span class="enscript-type">void</span>)
{
	kern_return_t		kr;
	__unused <span class="enscript-type">static</span> <span class="enscript-type">char</span>	here[] = <span class="enscript-string">&quot;default_pager_initialize&quot;</span>;

	lck_grp_attr_setdefault(&amp;default_pager_lck_grp_attr);
	lck_grp_init(&amp;default_pager_lck_grp, <span class="enscript-string">&quot;default_pager&quot;</span>, &amp;default_pager_lck_grp_attr);
	lck_attr_setdefault(&amp;default_pager_lck_attr);	

	<span class="enscript-comment">/*
	 * Vm variables.
	 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MACH_KERNEL</span>
	vm_page_mask = vm_page_size - 1;
	assert((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) vm_page_size == vm_page_size);
	vm_page_shift = local_log2((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) vm_page_size);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * List of all vstructs.
	 */</span>
	vstruct_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vstruct),
			     10000 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vstruct),
			     8192, <span class="enscript-string">&quot;vstruct zone&quot;</span>);
	zone_change(vstruct_zone, Z_CALLERACCT, FALSE);
	zone_change(vstruct_zone, Z_NOENCRYPT, TRUE);

	VSL_LOCK_INIT();
	queue_init(&amp;vstruct_list.vsl_queue);
	vstruct_list.vsl_count = 0;

	VSTATS_LOCK_INIT(&amp;global_stats.gs_lock);

	bs_initialize();

	<span class="enscript-comment">/*
	 * Exported DMM port.
	 */</span>
	default_pager_object = ipc_port_alloc_kernel();


	<span class="enscript-comment">/*
	 * Export pager interfaces.
	 */</span>
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">USER_PAGER</span>
	<span class="enscript-keyword">if</span> ((kr = netname_check_in(name_server_port, <span class="enscript-string">&quot;UserPager&quot;</span>,
				   default_pager_self,
				   default_pager_object))
	    != KERN_SUCCESS) {
		dprintf((<span class="enscript-string">&quot;netname_check_in returned 0x%x\n&quot;</span>, kr));
		exit(1);
	}
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* USER_PAGER */</span>
	{
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> clsize;
		memory_object_default_t dmm;

		dmm = default_pager_object;
		assert((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) vm_page_size == vm_page_size);
		clsize = ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) vm_page_size &lt;&lt; vstruct_def_clshift);
		kr = host_default_memory_manager(host_priv_self(), &amp;dmm, clsize);
		<span class="enscript-keyword">if</span> ((kr != KERN_SUCCESS) ||
		    (dmm != MEMORY_OBJECT_DEFAULT_NULL))
			Panic(<span class="enscript-string">&quot;default memory manager&quot;</span>);

	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USER_PAGER */</span>


}

</pre>
<hr />
</body></html>