<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dp_backing_store.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dp_backing_store.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

<span class="enscript-comment">/*
 *	Default Pager.
 *		Paging File Management.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/upl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_alerts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;default_pager/default_pager_object_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>


<span class="enscript-comment">/* todo - need large internal object support */</span>

<span class="enscript-comment">/*
 * ALLOC_STRIDE... the maximum number of bytes allocated from
 * a swap file before moving on to the next swap file... if
 * all swap files reside on a single disk, this value should
 * be very large (this is the default assumption)... if the 
 * swap files are spread across multiple disks, than this value
 * should be small (128 * 1024)...
 *
 * This should be determined dynamically in the future
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ALLOC_STRIDE</span>  (1024 * 1024 * 1024)
<span class="enscript-type">int</span> physical_transfer_cluster_count = 0;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_SUPER_CLUSTER</span>	0x40000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_SUPER_PAGES</span>          (VM_SUPER_CLUSTER / PAGE_MIN_SIZE)

<span class="enscript-comment">/*
 * 0 means no shift to pages, so == 1 page/cluster. 1 would mean
 * 2 pages/cluster, 2 means 4 pages/cluster, and so on.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSTRUCT_MIN_CLSHIFT</span>	0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSTRUCT_DEF_CLSHIFT</span>	2
<span class="enscript-type">int</span> default_pager_clsize = 0;

<span class="enscript-type">int</span> vstruct_def_clshift = VSTRUCT_DEF_CLSHIFT;

<span class="enscript-comment">/* statistics */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> clustered_writes[VM_SUPER_PAGES+1];
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> clustered_reads[VM_SUPER_PAGES+1];

<span class="enscript-comment">/*
 * Globals used for asynchronous paging operations:
 * 	vs_async_list:	head of list of to-be-completed I/O ops
 *	async_num_queued: number of pages completed, but not yet
 *		processed by async thread.
 *	async_requests_out: number of pages of requests not completed.
 */</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vs_async *vs_async_list;
<span class="enscript-type">int</span>	async_num_queued;
<span class="enscript-type">int</span>	async_requests_out;
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VS_ASYNC_REUSE</span> 1
<span class="enscript-type">struct</span> vs_async *vs_async_free_list;

lck_mtx_t	default_pager_async_lock;	<span class="enscript-comment">/* Protects globals above */</span>


<span class="enscript-type">int</span> vs_alloc_async_failed = 0;			<span class="enscript-comment">/* statistics */</span>
<span class="enscript-type">int</span> vs_alloc_async_count = 0;			<span class="enscript-comment">/* statistics */</span>
<span class="enscript-type">struct</span> vs_async *<span class="enscript-function-name">vs_alloc_async</span>(<span class="enscript-type">void</span>);		<span class="enscript-comment">/* forward */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">vs_free_async</span>(<span class="enscript-type">struct</span> vs_async *vsa);	<span class="enscript-comment">/* forward */</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_ALLOC_ASYNC</span>()	vs_alloc_async()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_FREE_ASYNC</span>(vsa)	vs_free_async(vsa)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_ASYNC_LOCK</span>()		lck_mtx_lock(&amp;default_pager_async_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_ASYNC_UNLOCK</span>()	lck_mtx_unlock(&amp;default_pager_async_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_ASYNC_LOCK_INIT</span>()	lck_mtx_init(&amp;default_pager_async_lock, &amp;default_pager_lck_grp, &amp;default_pager_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_ASYNC_LOCK_DESTROY</span>()	lck_mtx_destroy(&amp;default_pager_async_lock, &amp;default_pager_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VS_ASYNC_LOCK_ADDR</span>()	(&amp;default_pager_async_lock)
<span class="enscript-comment">/*
 *  Paging Space Hysteresis triggers and the target notification port
 *
 */</span> 
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	dp_pages_free_drift_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	dp_pages_free_drifted_max = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	minimum_pages_remaining	= 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	maximum_pages_free = 0;
ipc_port_t	min_pages_trigger_port = NULL;
ipc_port_t	max_pages_trigger_port = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
boolean_t	use_emergency_swap_file_first = TRUE;
#<span class="enscript-reference">else</span>
boolean_t	use_emergency_swap_file_first = FALSE;
#<span class="enscript-reference">endif</span>
boolean_t	bs_low = FALSE;
<span class="enscript-type">int</span>		backing_store_release_trigger_disable = 0;
boolean_t	backing_store_stop_compaction = FALSE;
boolean_t	backing_store_abort_compaction = FALSE;

<span class="enscript-comment">/* Have we decided if swap needs to be encrypted yet ? */</span>
boolean_t	dp_encryption_inited = FALSE;
<span class="enscript-comment">/* Should we encrypt swap ? */</span>
boolean_t	dp_encryption = FALSE;

boolean_t	dp_isssd = FALSE;

<span class="enscript-comment">/*
 * Object sizes are rounded up to the next power of 2,
 * unless they are bigger than a given maximum size.
 */</span>
vm_size_t	max_doubled_size = 4 * 1024 * 1024;	<span class="enscript-comment">/* 4 meg */</span>

<span class="enscript-comment">/*
 * List of all backing store and segments.
 */</span>
MACH_PORT_FACE		emergency_segment_backing_store;
<span class="enscript-type">struct</span> backing_store_list_head backing_store_list;
paging_segment_t	paging_segments[MAX_NUM_PAGING_SEGMENTS];
lck_mtx_t			paging_segments_lock;
<span class="enscript-type">int</span>			paging_segment_max = 0;
<span class="enscript-type">int</span>			paging_segment_count = 0;
<span class="enscript-type">int</span> ps_select_array[BS_MAXPRI+1] = { -1,-1,-1,-1,-1 };


<span class="enscript-comment">/*
 * Total pages free in system
 * This differs from clusters committed/avail which is a measure of the
 * over commitment of paging segments to backing store.  An idea which is
 * likely to be deprecated.
 */</span>
<span class="enscript-type">unsigned</span>  <span class="enscript-type">int</span>	dp_pages_free = 0;
<span class="enscript-type">unsigned</span>  <span class="enscript-type">int</span>	dp_pages_reserve = 0;
<span class="enscript-type">unsigned</span>  <span class="enscript-type">int</span>	cluster_transfer_minimum = 100;

<span class="enscript-comment">/* 
 * Trim state 
 */</span>
<span class="enscript-type">struct</span> ps_vnode_trim_data {
	<span class="enscript-type">struct</span> vnode *vp;
	dp_offset_t   offset;
	dp_size_t     length;
};

<span class="enscript-comment">/* forward declarations */</span>
kern_return_t <span class="enscript-function-name">ps_write_file</span>(paging_segment_t, upl_t, upl_offset_t, dp_offset_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);	<span class="enscript-comment">/* forward */</span>
kern_return_t <span class="enscript-function-name">ps_read_file</span> (paging_segment_t, upl_t, upl_offset_t, dp_offset_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *, <span class="enscript-type">int</span>);	<span class="enscript-comment">/* forward */</span>
default_pager_thread_t *<span class="enscript-function-name">get_read_buffer</span>( <span class="enscript-type">void</span> );
kern_return_t <span class="enscript-function-name">ps_vstruct_transfer_from_segment</span>(
	vstruct_t	 vs,
	paging_segment_t segment,
	upl_t		 upl);
kern_return_t <span class="enscript-function-name">ps_read_device</span>(paging_segment_t, dp_offset_t, vm_offset_t *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *, <span class="enscript-type">int</span>);	<span class="enscript-comment">/* forward */</span>
kern_return_t <span class="enscript-function-name">ps_write_device</span>(paging_segment_t, dp_offset_t, vm_offset_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> vs_async *);	<span class="enscript-comment">/* forward */</span>
kern_return_t <span class="enscript-function-name">vs_cluster_transfer</span>(
	vstruct_t	vs,
	dp_offset_t	offset,
	dp_size_t	cnt,
	upl_t		upl);
vs_map_t <span class="enscript-function-name">vs_get_map_entry</span>(
	vstruct_t	vs, 
	dp_offset_t	offset);

kern_return_t
<span class="enscript-function-name">default_pager_backing_store_delete_internal</span>( MACH_PORT_FACE );

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ps_vnode_trim_init</span>(<span class="enscript-type">struct</span> ps_vnode_trim_data *data);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ps_vnode_trim_now</span>(<span class="enscript-type">struct</span> ps_vnode_trim_data *data);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ps_vnode_trim_more</span>(<span class="enscript-type">struct</span> ps_vnode_trim_data *data, <span class="enscript-type">struct</span> vs_map *map, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> shift, dp_size_t length);

default_pager_thread_t *
<span class="enscript-function-name">get_read_buffer</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-type">int</span>	i;

	DPT_LOCK(dpt_lock);
	<span class="enscript-keyword">while</span>(TRUE) {
		<span class="enscript-keyword">for</span> (i=0; i&lt;default_pager_internal_count; i++) {
			<span class="enscript-keyword">if</span>(dpt_array[i]-&gt;checked_out == FALSE) {
			  dpt_array[i]-&gt;checked_out = TRUE;
			  DPT_UNLOCK(dpt_lock);
			  <span class="enscript-keyword">return</span>  dpt_array[i];
			}
		}
		DPT_SLEEP(dpt_lock, &amp;dpt_array, THREAD_UNINT);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bs_initialize</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * List of all backing store.
	 */</span>
	BSL_LOCK_INIT();
	queue_init(&amp;backing_store_list.bsl_queue);
	PSL_LOCK_INIT();

	VS_ASYNC_LOCK_INIT();
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">VS_ASYNC_REUSE</span>
	vs_async_free_list = NULL;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VS_ASYNC_REUSE */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; VM_SUPER_PAGES + 1; i++) {
		clustered_writes[i] = 0;
		clustered_reads[i] = 0;
	}

}

<span class="enscript-comment">/*
 * When things do not quite workout...
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">bs_no_paging_space</span>(boolean_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">bs_no_paging_space</span>(
	boolean_t out_of_memory)
{

	<span class="enscript-keyword">if</span> (out_of_memory)
		dprintf((<span class="enscript-string">&quot;*** OUT OF MEMORY ***\n&quot;</span>));
	panic(<span class="enscript-string">&quot;bs_no_paging_space: NOT ENOUGH PAGING SPACE&quot;</span>);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">bs_more_space</span>(<span class="enscript-type">int</span>);	<span class="enscript-comment">/* forward */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">bs_commit</span>(<span class="enscript-type">int</span>);		<span class="enscript-comment">/* forward */</span>

boolean_t	user_warned = FALSE;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	clusters_committed = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	clusters_available = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	clusters_committed_peak = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">bs_more_space</span>(
	<span class="enscript-type">int</span>	nclusters)
{
	BSL_LOCK();
	<span class="enscript-comment">/*
	 * Account for new paging space.
	 */</span>
	clusters_available += nclusters;

	<span class="enscript-keyword">if</span> (clusters_available &gt;= clusters_committed) {
		<span class="enscript-keyword">if</span> (verbose &amp;&amp; user_warned) {
			printf(<span class="enscript-string">&quot;%s%s - %d excess clusters now.\n&quot;</span>,
			       my_name,
			       <span class="enscript-string">&quot;paging space is OK now&quot;</span>,
			       clusters_available - clusters_committed);
			user_warned = FALSE;
			clusters_committed_peak = 0;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (verbose &amp;&amp; user_warned) {
			printf(<span class="enscript-string">&quot;%s%s - still short of %d clusters.\n&quot;</span>,
			       my_name,
			       <span class="enscript-string">&quot;WARNING: paging space over-committed&quot;</span>,
			       clusters_committed - clusters_available);
			clusters_committed_peak -= nclusters;
		}
	}
	BSL_UNLOCK();

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bs_commit</span>(
	<span class="enscript-type">int</span>	nclusters)
{
	BSL_LOCK();
	clusters_committed += nclusters;
	<span class="enscript-keyword">if</span> (clusters_committed &gt; clusters_available) {
		<span class="enscript-keyword">if</span> (verbose &amp;&amp; !user_warned) {
			user_warned = TRUE;
			printf(<span class="enscript-string">&quot;%s%s - short of %d clusters.\n&quot;</span>,
			       my_name,
			       <span class="enscript-string">&quot;WARNING: paging space over-committed&quot;</span>,
			       clusters_committed - clusters_available);
		}
		<span class="enscript-keyword">if</span> (clusters_committed &gt; clusters_committed_peak) {
			clusters_committed_peak = clusters_committed;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (verbose &amp;&amp; user_warned) {
			printf(<span class="enscript-string">&quot;%s%s - was short of up to %d clusters.\n&quot;</span>,
			       my_name,
			       <span class="enscript-string">&quot;paging space is OK now&quot;</span>,
			       clusters_committed_peak - clusters_available);
			user_warned = FALSE;
			clusters_committed_peak = 0;
		}
	}
	BSL_UNLOCK();

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span> default_pager_info_verbose = 1;

<span class="enscript-type">void</span>
<span class="enscript-function-name">bs_global_info</span>(
	uint64_t	*totalp,
	uint64_t	*freep)
{
	uint64_t		pages_total, pages_free;
	paging_segment_t	ps;
	<span class="enscript-type">int</span>			i;

	PSL_LOCK();
	pages_total = pages_free = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
		ps = paging_segments[i];
		<span class="enscript-keyword">if</span> (ps == PAGING_SEGMENT_NULL) 
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * no need to lock: by the time this data
		 * gets back to any remote requestor it
		 * will be obsolete anyways
		 */</span>
		pages_total += ps-&gt;ps_pgnum;
		pages_free += ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift;
		DP_DEBUG(DEBUG_BS_INTERNAL,
			 (<span class="enscript-string">&quot;segment #%d: %d total, %d free\n&quot;</span>,
			  i, ps-&gt;ps_pgnum, ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift));
	}
	*totalp = pages_total;
	*freep = pages_free;
	<span class="enscript-keyword">if</span> (verbose &amp;&amp; user_warned &amp;&amp; default_pager_info_verbose) {
		<span class="enscript-keyword">if</span> (clusters_available &lt; clusters_committed) {
			printf(<span class="enscript-string">&quot;%s %d clusters committed, %d available.\n&quot;</span>,
			       my_name,
			       clusters_committed,
			       clusters_available);
		}
	}
	PSL_UNLOCK();
}

backing_store_t <span class="enscript-function-name">backing_store_alloc</span>(<span class="enscript-type">void</span>);	<span class="enscript-comment">/* forward */</span>

backing_store_t
<span class="enscript-function-name">backing_store_alloc</span>(<span class="enscript-type">void</span>)
{
	backing_store_t bs;

	bs = (backing_store_t) kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> backing_store));
	<span class="enscript-keyword">if</span> (bs == BACKING_STORE_NULL)
		panic(<span class="enscript-string">&quot;backing_store_alloc: no memory&quot;</span>);

	BS_LOCK_INIT(bs);
	bs-&gt;bs_port = MACH_PORT_NULL;
	bs-&gt;bs_priority = 0;
	bs-&gt;bs_clsize = 0;
	bs-&gt;bs_pages_total = 0;
	bs-&gt;bs_pages_in = 0;
	bs-&gt;bs_pages_in_fail = 0;
	bs-&gt;bs_pages_out = 0;
	bs-&gt;bs_pages_out_fail = 0;

	<span class="enscript-keyword">return</span> bs;
}

backing_store_t <span class="enscript-function-name">backing_store_lookup</span>(MACH_PORT_FACE);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-comment">/* Even in both the component space and external versions of this pager, */</span>
<span class="enscript-comment">/* backing_store_lookup will be called from tasks in the application space */</span>
backing_store_t
<span class="enscript-function-name">backing_store_lookup</span>(
	MACH_PORT_FACE port)
{
	backing_store_t	bs;

<span class="enscript-comment">/*
	port is currently backed with a vs structure in the alias field
	we could create an ISBS alias and a port_is_bs call but frankly
	I see no reason for the test, the bs-&gt;port == port check below
	will work properly on junk entries.

	if ((port == MACH_PORT_NULL) || port_is_vs(port))
*/</span>
	<span class="enscript-keyword">if</span> (port == MACH_PORT_NULL)
		<span class="enscript-keyword">return</span> BACKING_STORE_NULL;

	BSL_LOCK();
	queue_iterate(&amp;backing_store_list.bsl_queue, bs, backing_store_t,
		      bs_links) {
		BS_LOCK(bs);
		<span class="enscript-keyword">if</span> (bs-&gt;bs_port == port) {
			BSL_UNLOCK();
			<span class="enscript-comment">/* Success, return it locked. */</span>
			<span class="enscript-keyword">return</span> bs;
		}
		BS_UNLOCK(bs);
	}
	BSL_UNLOCK();
	<span class="enscript-keyword">return</span> BACKING_STORE_NULL;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">backing_store_add</span>(backing_store_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">backing_store_add</span>(
	__unused backing_store_t bs)
{
<span class="enscript-comment">//	MACH_PORT_FACE		port = bs-&gt;bs_port;
</span><span class="enscript-comment">//	MACH_PORT_FACE		pset = default_pager_default_set;
</span>	kern_return_t		kr = KERN_SUCCESS;

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;backing_store_add: add to set&quot;</span>);

}

<span class="enscript-comment">/*
 * Set up default page shift, but only if not already
 * set and argument is within range.
 */</span>
boolean_t
<span class="enscript-function-name">bs_set_default_clsize</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> npages)
{
	<span class="enscript-keyword">switch</span>(npages){
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
		<span class="enscript-keyword">if</span> (default_pager_clsize == 0)	<span class="enscript-comment">/* if not yet set */</span>
			vstruct_def_clshift = local_log2(npages);
		<span class="enscript-keyword">return</span>(TRUE);
	}
	<span class="enscript-keyword">return</span>(FALSE);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">bs_get_global_clsize</span>(<span class="enscript-type">int</span> clsize);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">bs_get_global_clsize</span>(
	<span class="enscript-type">int</span>	clsize)
{
	<span class="enscript-type">int</span>			i;
	memory_object_default_t	dmm;
	kern_return_t		kr;

	<span class="enscript-comment">/*
	 * Only allow setting of cluster size once. If called
	 * with no cluster size (default), we use the compiled-in default
	 * for the duration. The same cluster size is used for all
	 * paging segments.
	 */</span>
	<span class="enscript-keyword">if</span> (default_pager_clsize == 0) {
		<span class="enscript-comment">/*
		 * Keep cluster size in bit shift because it's quicker
		 * arithmetic, and easier to keep at a power of 2.
		 */</span>
		<span class="enscript-keyword">if</span> (clsize != NO_CLSIZE) {
			<span class="enscript-keyword">for</span> (i = 0; (1 &lt;&lt; i) &lt; clsize; i++);
			<span class="enscript-keyword">if</span> (i &gt; MAX_CLUSTER_SHIFT)
				i = MAX_CLUSTER_SHIFT;
			vstruct_def_clshift = i;
		}
		default_pager_clsize = (1 &lt;&lt; vstruct_def_clshift);

		<span class="enscript-comment">/*
		 * Let the user know the new (and definitive) cluster size.
		 */</span>
		<span class="enscript-keyword">if</span> (verbose)
			printf(<span class="enscript-string">&quot;%scluster size = %d page%s\n&quot;</span>,
		       		my_name, default_pager_clsize,
		       		(default_pager_clsize == 1) ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>);

		<span class="enscript-comment">/*
		 * Let the kernel know too, in case it hasn't used the
		 * default value provided in main() yet.
		 */</span>
		dmm = default_pager_object;
		clsize = default_pager_clsize * vm_page_size;	<span class="enscript-comment">/* in bytes */</span>
		kr = host_default_memory_manager(host_priv_self(),
						 &amp;dmm,
						 clsize);
		memory_object_default_deallocate(dmm);

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		   panic(<span class="enscript-string">&quot;bs_get_global_cl_size:host_default_memory_manager&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (dmm != default_pager_object) {
		  panic(<span class="enscript-string">&quot;bs_get_global_cl_size:there is another default pager&quot;</span>);
		}
	}
	ASSERT(default_pager_clsize &gt; 0 &amp;&amp;
	       (default_pager_clsize &amp; (default_pager_clsize - 1)) == 0);

	<span class="enscript-keyword">return</span> default_pager_clsize;
}

kern_return_t
<span class="enscript-function-name">default_pager_backing_store_create</span>(
	memory_object_default_t	pager,
	<span class="enscript-type">int</span>			priority,
	<span class="enscript-type">int</span>			clsize,		<span class="enscript-comment">/* in bytes */</span>
	MACH_PORT_FACE		*backing_store)
{
	backing_store_t	bs;
	MACH_PORT_FACE	port;
<span class="enscript-comment">//	kern_return_t	kr;
</span>	<span class="enscript-type">struct</span> vstruct_alias *alias_struct;

	<span class="enscript-keyword">if</span> (pager != default_pager_object)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	bs = backing_store_alloc();
	port = ipc_port_alloc_kernel();
	ipc_port_make_send(port);
	assert (port != IP_NULL);

	DP_DEBUG(DEBUG_BS_EXTERNAL,
		 (<span class="enscript-string">&quot;priority=%d clsize=%d bs_port=0x%x\n&quot;</span>,
		  priority, clsize, (<span class="enscript-type">int</span>) backing_store));

	alias_struct = (<span class="enscript-type">struct</span> vstruct_alias *) 
				kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vstruct_alias));
	<span class="enscript-keyword">if</span>(alias_struct != NULL) {
		alias_struct-&gt;vs = (<span class="enscript-type">struct</span> vstruct *)bs;
		alias_struct-&gt;name = &amp;default_pager_ops;
		port-&gt;ip_alias = (uintptr_t) alias_struct;
	}
	<span class="enscript-keyword">else</span> {
		ipc_port_dealloc_kernel((MACH_PORT_FACE)(port));

		BS_LOCK_DESTROY(bs);
		kfree(bs, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> backing_store));

		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	bs-&gt;bs_port = port;
	<span class="enscript-keyword">if</span> (priority == DEFAULT_PAGER_BACKING_STORE_MAXPRI)
		priority = BS_MAXPRI;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (priority == BS_NOPRI)
		priority = BS_MAXPRI;
	<span class="enscript-keyword">else</span>
		priority = BS_MINPRI;
	bs-&gt;bs_priority = priority;

	bs-&gt;bs_clsize = bs_get_global_clsize(atop_32(clsize));

	BSL_LOCK();
	queue_enter(&amp;backing_store_list.bsl_queue, bs, backing_store_t,
		    bs_links);
	BSL_UNLOCK();

	backing_store_add(bs);

	*backing_store = port;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">default_pager_backing_store_info</span>(
	MACH_PORT_FACE		backing_store,
	backing_store_flavor_t	flavour,
	backing_store_info_t	info,
	mach_msg_type_number_t	*size)
{
	backing_store_t			bs;
	backing_store_basic_info_t	basic;
	<span class="enscript-type">int</span>				i;
	paging_segment_t		ps;

	<span class="enscript-keyword">if</span> (flavour != BACKING_STORE_BASIC_INFO ||
	    *size &lt; BACKING_STORE_BASIC_INFO_COUNT)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	basic = (backing_store_basic_info_t)info;
	*size = BACKING_STORE_BASIC_INFO_COUNT;

	VSTATS_LOCK(&amp;global_stats.gs_lock);
	basic-&gt;pageout_calls	= global_stats.gs_pageout_calls;
	basic-&gt;pagein_calls	= global_stats.gs_pagein_calls;
	basic-&gt;pages_in		= global_stats.gs_pages_in;
	basic-&gt;pages_out	= global_stats.gs_pages_out;
	basic-&gt;pages_unavail	= global_stats.gs_pages_unavail;
	basic-&gt;pages_init	= global_stats.gs_pages_init;
	basic-&gt;pages_init_writes= global_stats.gs_pages_init_writes;
	VSTATS_UNLOCK(&amp;global_stats.gs_lock);

	<span class="enscript-keyword">if</span> ((bs = backing_store_lookup(backing_store)) == BACKING_STORE_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	basic-&gt;bs_pages_total	= bs-&gt;bs_pages_total;
	PSL_LOCK();
	bs-&gt;bs_pages_free = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
		ps = paging_segments[i];
		<span class="enscript-keyword">if</span> (ps != PAGING_SEGMENT_NULL &amp;&amp; ps-&gt;ps_bs == bs) {
			PS_LOCK(ps);
			bs-&gt;bs_pages_free += ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift;
			PS_UNLOCK(ps);
		}
	}
	PSL_UNLOCK();
	basic-&gt;bs_pages_free	= bs-&gt;bs_pages_free;
	basic-&gt;bs_pages_in	= bs-&gt;bs_pages_in;
	basic-&gt;bs_pages_in_fail	= bs-&gt;bs_pages_in_fail;
	basic-&gt;bs_pages_out	= bs-&gt;bs_pages_out;
	basic-&gt;bs_pages_out_fail= bs-&gt;bs_pages_out_fail;

	basic-&gt;bs_priority	= bs-&gt;bs_priority;
	basic-&gt;bs_clsize	= ptoa_32(bs-&gt;bs_clsize);	<span class="enscript-comment">/* in bytes */</span>

	BS_UNLOCK(bs);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">ps_delete</span>(paging_segment_t);	<span class="enscript-comment">/* forward */</span>
boolean_t <span class="enscript-function-name">current_thread_aborted</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">int</span>
<span class="enscript-function-name">ps_delete</span>(
	paging_segment_t ps)
{
	vstruct_t	vs;
	kern_return_t	error = KERN_SUCCESS;
	<span class="enscript-type">int</span>		vs_count;
	
	VSL_LOCK();  		<span class="enscript-comment">/* get the lock on the list of vs's	 */</span>

	<span class="enscript-comment">/* The lock relationship and sequence is farily complicated  	 */</span>
	<span class="enscript-comment">/* this code looks at a live list, locking and unlocking the list */</span>
	<span class="enscript-comment">/* as it traverses it.  It depends on the locking behavior of	 */</span>
	<span class="enscript-comment">/* default_pager_no_senders.  no_senders always locks the vstruct */</span>
	<span class="enscript-comment">/* targeted for removal before locking the vstruct list.  However */</span>
	<span class="enscript-comment">/* it will remove that member of the list without locking its    */</span>
	<span class="enscript-comment">/* neighbors.  We can be sure when we hold a lock on a vstruct   */</span>
	<span class="enscript-comment">/* it cannot be removed from the list but we must hold the list  */</span>
	<span class="enscript-comment">/* lock to be sure that its pointers to its neighbors are valid. */</span>
	<span class="enscript-comment">/* Also, we can hold off destruction of a vstruct when the list  */</span>
	<span class="enscript-comment">/* lock and the vs locks are not being held by bumping the 	 */</span>
	<span class="enscript-comment">/* vs_async_pending count.      */</span>


	<span class="enscript-keyword">while</span>(backing_store_release_trigger_disable != 0) {
		VSL_SLEEP(&amp;backing_store_release_trigger_disable, THREAD_UNINT);
	}

	<span class="enscript-comment">/* we will choose instead to hold a send right */</span>
	vs_count = vstruct_list.vsl_count;
	vs = (vstruct_t) queue_first((queue_entry_t)&amp;(vstruct_list.vsl_queue));
	<span class="enscript-keyword">if</span>(vs == (vstruct_t)&amp;vstruct_list)  {
		VSL_UNLOCK();
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	VS_LOCK(vs);
	vs_async_wait(vs);  <span class="enscript-comment">/* wait for any pending async writes */</span>
	<span class="enscript-keyword">if</span> ((vs_count != 0) &amp;&amp; (vs != NULL))
		vs-&gt;vs_async_pending += 1;  <span class="enscript-comment">/* hold parties calling  */</span>
					    <span class="enscript-comment">/* vs_async_wait */</span>

	<span class="enscript-keyword">if</span> (bs_low == FALSE)
		backing_store_abort_compaction = FALSE;

	VS_UNLOCK(vs);
	VSL_UNLOCK();
	<span class="enscript-keyword">while</span>((vs_count != 0) &amp;&amp; (vs != NULL)) {
		<span class="enscript-comment">/* We take the count of AMO's before beginning the         */</span>
		<span class="enscript-comment">/* transfer of of the target segment.                      */</span>
		<span class="enscript-comment">/* We are guaranteed that the target segment cannot get    */</span>
		<span class="enscript-comment">/* more users.  We also know that queue entries are        */</span>
		<span class="enscript-comment">/* made at the back of the list.  If some of the entries   */</span>
		<span class="enscript-comment">/* we would check disappear while we are traversing the    */</span>
		<span class="enscript-comment">/* list then we will either check new entries which        */</span>
		<span class="enscript-comment">/* do not have any backing store in the target segment     */</span>
		<span class="enscript-comment">/* or re-check old entries.  This might not be optimal     */</span>
		<span class="enscript-comment">/* but it will always be correct. The alternative is to    */</span>
		<span class="enscript-comment">/* take a snapshot of the list.			   	   */</span>
		vstruct_t	next_vs;
		
		<span class="enscript-keyword">if</span>(dp_pages_free &lt; cluster_transfer_minimum)
			error = KERN_FAILURE;
		<span class="enscript-keyword">else</span> {
			vm_object_t	    transfer_object;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	    count;
			upl_t		    upl;
			upl_control_flags_t upl_flags;

			transfer_object = vm_object_allocate((vm_object_size_t)VM_SUPER_CLUSTER);
			count = 0;
			upl_flags = (UPL_NO_SYNC | UPL_CLEAN_IN_PLACE |
				     UPL_SET_LITE | UPL_SET_INTERNAL);
			<span class="enscript-keyword">if</span> (dp_encryption) {
				<span class="enscript-comment">/* mark the pages as &quot;encrypted&quot; when they come in */</span>
				upl_flags |= UPL_ENCRYPT;
			}
			error = vm_object_upl_request(transfer_object, 
				(vm_object_offset_t)0, VM_SUPER_CLUSTER,
				&amp;upl, NULL, &amp;count, upl_flags);

			<span class="enscript-keyword">if</span>(error == KERN_SUCCESS) {
				error = ps_vstruct_transfer_from_segment(
							vs, ps, upl);
				upl_commit(upl, NULL, 0);
				upl_deallocate(upl);
			} <span class="enscript-keyword">else</span> {
				error = KERN_FAILURE;
			}
			vm_object_deallocate(transfer_object);
		}
		<span class="enscript-keyword">if</span>(error || current_thread_aborted()) {
			VS_LOCK(vs);
			vs-&gt;vs_async_pending -= 1;  <span class="enscript-comment">/* release vs_async_wait */</span>
			<span class="enscript-keyword">if</span> (vs-&gt;vs_async_pending == 0 &amp;&amp; vs-&gt;vs_waiting_async) {
				vs-&gt;vs_waiting_async = FALSE;
				VS_UNLOCK(vs);
				thread_wakeup(&amp;vs-&gt;vs_async_pending);
			} <span class="enscript-keyword">else</span> {
				VS_UNLOCK(vs);
			}
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}

		VSL_LOCK(); 

		<span class="enscript-keyword">while</span>(backing_store_release_trigger_disable != 0) {
			VSL_SLEEP(&amp;backing_store_release_trigger_disable,
				  THREAD_UNINT);
		}

		next_vs = (vstruct_t) queue_next(&amp;(vs-&gt;vs_links));
		<span class="enscript-keyword">if</span>((next_vs != (vstruct_t)&amp;vstruct_list) &amp;&amp; 
				(vs != next_vs) &amp;&amp; (vs_count != 1)) {
			VS_LOCK(next_vs);
			vs_async_wait(next_vs);  <span class="enscript-comment">/* wait for any  */</span>
						 <span class="enscript-comment">/* pending async writes */</span>
			next_vs-&gt;vs_async_pending += 1; <span class="enscript-comment">/* hold parties  */</span>
						<span class="enscript-comment">/* calling vs_async_wait */</span>
			VS_UNLOCK(next_vs);
		}
		VSL_UNLOCK();
		VS_LOCK(vs);
		vs-&gt;vs_async_pending -= 1; 
		<span class="enscript-keyword">if</span> (vs-&gt;vs_async_pending == 0 &amp;&amp; vs-&gt;vs_waiting_async) {
			vs-&gt;vs_waiting_async = FALSE;
			VS_UNLOCK(vs);
			thread_wakeup(&amp;vs-&gt;vs_async_pending);
		} <span class="enscript-keyword">else</span> {
			VS_UNLOCK(vs);
		}
		<span class="enscript-keyword">if</span>((vs == next_vs) || (next_vs == (vstruct_t)&amp;vstruct_list))
			vs = NULL;
		<span class="enscript-keyword">else</span>
			vs = next_vs;
		vs_count--;
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


kern_return_t
<span class="enscript-function-name">default_pager_backing_store_delete_internal</span>(
	MACH_PORT_FACE backing_store)
{
	backing_store_t		bs;
	<span class="enscript-type">int</span>			i;
	paging_segment_t	ps;
	<span class="enscript-type">int</span>			error;
	<span class="enscript-type">int</span>			interim_pages_removed = 0;
	boolean_t		dealing_with_emergency_segment = ( backing_store == emergency_segment_backing_store );

	<span class="enscript-keyword">if</span> ((bs = backing_store_lookup(backing_store)) == BACKING_STORE_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

<span class="enscript-reference">restart</span>:
	PSL_LOCK();
	error = KERN_SUCCESS;
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
		ps = paging_segments[i];
		<span class="enscript-keyword">if</span> (ps != PAGING_SEGMENT_NULL &amp;&amp;
		    ps-&gt;ps_bs == bs &amp;&amp;
		    ! IS_PS_GOING_AWAY(ps)) {
			PS_LOCK(ps);
			
			<span class="enscript-keyword">if</span>( IS_PS_GOING_AWAY(ps) || !IS_PS_OK_TO_USE(ps)) {
			<span class="enscript-comment">/* 
			 * Someone is already busy reclamining this paging segment.
			 * If it's the emergency segment we are looking at then check
			 * that someone has not already recovered it and set the right
			 * state i.e. online but not activated.
			 */</span>
				PS_UNLOCK(ps);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/* disable access to this segment */</span>
			ps-&gt;ps_state &amp;= ~PS_CAN_USE;
			ps-&gt;ps_state |= PS_GOING_AWAY;
			PS_UNLOCK(ps);
			<span class="enscript-comment">/*
			 * The &quot;ps&quot; segment is &quot;off-line&quot; now,
			 * we can try and delete it...
			 */</span>
			<span class="enscript-keyword">if</span>(dp_pages_free &lt; (cluster_transfer_minimum
				 			+ ps-&gt;ps_pgcount)) {
				error = KERN_FAILURE;
				PSL_UNLOCK();
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* remove all pages associated with the  */</span>
				<span class="enscript-comment">/* segment from the list of free pages   */</span>
				<span class="enscript-comment">/* when transfer is through, all target  */</span>
				<span class="enscript-comment">/* segment pages will appear to be free  */</span>
				
				dp_pages_free -=  ps-&gt;ps_pgcount;
				interim_pages_removed += ps-&gt;ps_pgcount;
				PSL_UNLOCK();
				error = ps_delete(ps);
			}
			<span class="enscript-keyword">if</span> (error != KERN_SUCCESS) {
				<span class="enscript-comment">/*
				 * We couldn't delete the segment,
				 * probably because there's not enough
				 * virtual memory left.
				 * Re-enable all the segments.
				 */</span>
				PSL_LOCK();
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
	}

	<span class="enscript-keyword">if</span> (error != KERN_SUCCESS) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
			ps = paging_segments[i];
			<span class="enscript-keyword">if</span> (ps != PAGING_SEGMENT_NULL &amp;&amp;
			    ps-&gt;ps_bs == bs &amp;&amp;
			    IS_PS_GOING_AWAY(ps)) {
				PS_LOCK(ps);
				
				<span class="enscript-keyword">if</span>( !IS_PS_GOING_AWAY(ps)) {
					PS_UNLOCK(ps);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/* Handle the special clusters that came in while we let go the lock*/</span>	
				<span class="enscript-keyword">if</span>( ps-&gt;ps_special_clusters) {
					dp_pages_free += ps-&gt;ps_special_clusters &lt;&lt; ps-&gt;ps_clshift;
					ps-&gt;ps_pgcount += ps-&gt;ps_special_clusters &lt;&lt; ps-&gt;ps_clshift;
					ps-&gt;ps_clcount += ps-&gt;ps_special_clusters;
					<span class="enscript-keyword">if</span> ( ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] == BS_FULLPRI) {
						ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] = 0;
					}
					ps-&gt;ps_special_clusters = 0;
				}
				<span class="enscript-comment">/* re-enable access to this segment */</span>
				ps-&gt;ps_state &amp;= ~PS_GOING_AWAY;
				ps-&gt;ps_state |= PS_CAN_USE;
				PS_UNLOCK(ps);
			}
		}
		dp_pages_free += interim_pages_removed;
		PSL_UNLOCK();
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
		ps = paging_segments[i];
		<span class="enscript-keyword">if</span> (ps != PAGING_SEGMENT_NULL &amp;&amp;
		    ps-&gt;ps_bs == bs) { 
			<span class="enscript-keyword">if</span>(IS_PS_GOING_AWAY(ps)) {
				<span class="enscript-keyword">if</span>(IS_PS_EMERGENCY_SEGMENT(ps)) {
					PS_LOCK(ps);
					ps-&gt;ps_state &amp;= ~PS_GOING_AWAY;
					ps-&gt;ps_special_clusters = 0;
					ps-&gt;ps_pgcount = ps-&gt;ps_pgnum;
					ps-&gt;ps_clcount = ps-&gt;ps_ncls = ps-&gt;ps_pgcount &gt;&gt; ps-&gt;ps_clshift;
					dp_pages_reserve += ps-&gt;ps_pgcount;
					PS_UNLOCK(ps);
				} <span class="enscript-keyword">else</span> {
					paging_segments[i] = PAGING_SEGMENT_NULL;
					paging_segment_count--;
					PS_LOCK(ps);
					kfree(ps-&gt;ps_bmap, RMAPSIZE(ps-&gt;ps_ncls));
					kfree(ps, <span class="enscript-keyword">sizeof</span> *ps);
				}
			}
		}
	}

	<span class="enscript-comment">/* Scan the entire ps array separately to make certain we find the */</span>
	<span class="enscript-comment">/* proper paging_segment_max                                       */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_NUM_PAGING_SEGMENTS; i++) {
		<span class="enscript-keyword">if</span>(paging_segments[i] != PAGING_SEGMENT_NULL)
		   paging_segment_max = i;
	}

	PSL_UNLOCK();

	<span class="enscript-keyword">if</span>( dealing_with_emergency_segment ) {
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-comment">/*
	 * All the segments have been deleted.
	 * We can remove the backing store.
	 */</span>

	<span class="enscript-comment">/*
	 * Disable lookups of this backing store.
	 */</span>
	<span class="enscript-keyword">if</span>((<span class="enscript-type">void</span> *)bs-&gt;bs_port-&gt;ip_alias != NULL)
		kfree((<span class="enscript-type">void</span> *) bs-&gt;bs_port-&gt;ip_alias,
		      <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vstruct_alias));
	ipc_port_dealloc_kernel((ipc_port_t) (bs-&gt;bs_port));
	bs-&gt;bs_port = MACH_PORT_NULL;
	BS_UNLOCK(bs);

	<span class="enscript-comment">/*
	 * Remove backing store from backing_store list.
	 */</span>
	BSL_LOCK();
	queue_remove(&amp;backing_store_list.bsl_queue, bs, backing_store_t,
		     bs_links);
	BSL_UNLOCK();

	<span class="enscript-comment">/*
	 * Free the backing store structure.
	 */</span>
	BS_LOCK_DESTROY(bs);
	kfree(bs, <span class="enscript-keyword">sizeof</span> *bs);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">default_pager_backing_store_delete</span>(
	MACH_PORT_FACE backing_store) 
{
	<span class="enscript-keyword">if</span>( backing_store != emergency_segment_backing_store ) {
		default_pager_backing_store_delete_internal(emergency_segment_backing_store);
	}
	<span class="enscript-keyword">return</span>(default_pager_backing_store_delete_internal(backing_store));
}

<span class="enscript-type">int</span>	ps_enter(paging_segment_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">ps_enter</span>(
	paging_segment_t ps)
{
	<span class="enscript-type">int</span> i;

	PSL_LOCK();

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_NUM_PAGING_SEGMENTS; i++) {
		<span class="enscript-keyword">if</span> (paging_segments[i] == PAGING_SEGMENT_NULL)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (i &lt; MAX_NUM_PAGING_SEGMENTS) {
		paging_segments[i] = ps;
		<span class="enscript-keyword">if</span> (i &gt; paging_segment_max)
			paging_segment_max = i;
		paging_segment_count++;
		<span class="enscript-keyword">if</span> ((ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] == BS_NOPRI) ||
			(ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] == BS_FULLPRI))
			ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] = 0;
		i = 0;
	} <span class="enscript-keyword">else</span> {
		PSL_UNLOCK();
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	PSL_UNLOCK();
	<span class="enscript-keyword">return</span> i;
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEVICE_PAGING</span>
kern_return_t
<span class="enscript-function-name">default_pager_add_segment</span>(
	MACH_PORT_FACE	backing_store,
	MACH_PORT_FACE	device,
	recnum_t	offset,
	recnum_t	count,
	<span class="enscript-type">int</span>		record_size)
{
	backing_store_t		bs;
	paging_segment_t	ps;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			error;

	<span class="enscript-keyword">if</span> ((bs = backing_store_lookup(backing_store))
	    == BACKING_STORE_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	PSL_LOCK();
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
		ps = paging_segments[i];
		<span class="enscript-keyword">if</span> (ps == PAGING_SEGMENT_NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * Check for overlap on same device.
		 */</span>
		<span class="enscript-keyword">if</span> (!(ps-&gt;ps_device != device
		      || offset &gt;= ps-&gt;ps_offset + ps-&gt;ps_recnum
		      || offset + count &lt;= ps-&gt;ps_offset)) {
			PSL_UNLOCK();
			BS_UNLOCK(bs);
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}
	}
	PSL_UNLOCK();

	<span class="enscript-comment">/*
	 * Set up the paging segment
	 */</span>
	ps = (paging_segment_t) kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> paging_segment));
	<span class="enscript-keyword">if</span> (ps == PAGING_SEGMENT_NULL) {
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	ps-&gt;ps_segtype = PS_PARTITION;
	ps-&gt;ps_device = device;
	ps-&gt;ps_offset = offset;
	ps-&gt;ps_record_shift = local_log2(vm_page_size / record_size);
	ps-&gt;ps_recnum = count;
	ps-&gt;ps_pgnum = count &gt;&gt; ps-&gt;ps_record_shift;

	ps-&gt;ps_pgcount = ps-&gt;ps_pgnum;
	ps-&gt;ps_clshift = local_log2(bs-&gt;bs_clsize);
	ps-&gt;ps_clcount = ps-&gt;ps_ncls = ps-&gt;ps_pgcount &gt;&gt; ps-&gt;ps_clshift;
	ps-&gt;ps_hint = 0;

	PS_LOCK_INIT(ps);
	ps-&gt;ps_bmap = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc(RMAPSIZE(ps-&gt;ps_ncls));
	<span class="enscript-keyword">if</span> (!ps-&gt;ps_bmap) {
		PS_LOCK_DESTROY(ps);
		kfree(ps, <span class="enscript-keyword">sizeof</span> *ps);
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}
	<span class="enscript-keyword">for</span> (i = 0; i &lt; ps-&gt;ps_ncls; i++) {
		clrbit(ps-&gt;ps_bmap, i);
	}

	<span class="enscript-keyword">if</span>(paging_segment_count == 0) {
		ps-&gt;ps_state = PS_EMERGENCY_SEGMENT;
		<span class="enscript-keyword">if</span>(use_emergency_swap_file_first) {
			ps-&gt;ps_state |= PS_CAN_USE;
		}
	} <span class="enscript-keyword">else</span> {
		ps-&gt;ps_state = PS_CAN_USE;
	}

	ps-&gt;ps_bs = bs;

	<span class="enscript-keyword">if</span> ((error = ps_enter(ps)) != 0) {
		kfree(ps-&gt;ps_bmap, RMAPSIZE(ps-&gt;ps_ncls));

		PS_LOCK_DESTROY(ps);
		kfree(ps, <span class="enscript-keyword">sizeof</span> *ps);
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	bs-&gt;bs_pages_free += ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift;
	bs-&gt;bs_pages_total += ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift;
	BS_UNLOCK(bs);

	PSL_LOCK();
	<span class="enscript-keyword">if</span>(IS_PS_OK_TO_USE(ps)) {
		dp_pages_free += ps-&gt;ps_pgcount;
	} <span class="enscript-keyword">else</span> {
		dp_pages_reserve += ps-&gt;ps_pgcount;
	}
	PSL_UNLOCK();

	bs_more_space(ps-&gt;ps_clcount);

	DP_DEBUG(DEBUG_BS_INTERNAL,
		 (<span class="enscript-string">&quot;device=0x%x,offset=0x%x,count=0x%x,record_size=0x%x,shift=%d,total_size=0x%x\n&quot;</span>,
		  device, offset, count, record_size,
		  ps-&gt;ps_record_shift, ps-&gt;ps_pgnum));

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

boolean_t
<span class="enscript-function-name">bs_add_device</span>(
	<span class="enscript-type">char</span>		*dev_name,
	MACH_PORT_FACE	master)
{
	security_token_t	null_security_token = {
		{ 0, 0 }
	};
	MACH_PORT_FACE	device;
	<span class="enscript-type">int</span>		info[DEV_GET_SIZE_COUNT];
	mach_msg_type_number_t info_count;
	MACH_PORT_FACE	bs = MACH_PORT_NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	rec_size;
	recnum_t	count;
	<span class="enscript-type">int</span>		clsize;
	MACH_PORT_FACE  reply_port;

	<span class="enscript-keyword">if</span> (ds_device_open_sync(master, MACH_PORT_NULL, D_READ | D_WRITE,
			null_security_token, dev_name, &amp;device))
		<span class="enscript-keyword">return</span> FALSE;

	info_count = DEV_GET_SIZE_COUNT;
	<span class="enscript-keyword">if</span> (!ds_device_get_status(device, DEV_GET_SIZE, info, &amp;info_count)) {
		rec_size = info[DEV_GET_SIZE_RECORD_SIZE];
		count = info[DEV_GET_SIZE_DEVICE_SIZE] /  rec_size;
		clsize = bs_get_global_clsize(0);
		<span class="enscript-keyword">if</span> (!default_pager_backing_store_create(
					default_pager_object,
					DEFAULT_PAGER_BACKING_STORE_MAXPRI,
					(clsize * vm_page_size),
					&amp;bs)) {
			<span class="enscript-keyword">if</span> (!default_pager_add_segment(bs, device,
						       0, count, rec_size)) {
				<span class="enscript-keyword">return</span> TRUE;
			}
			ipc_port_release_receive(bs);
		}
	}

	ipc_port_release_send(device);
	<span class="enscript-keyword">return</span> FALSE;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVICE_PAGING */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">VS_ASYNC_REUSE</span>

<span class="enscript-type">struct</span> vs_async *
<span class="enscript-function-name">vs_alloc_async</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> vs_async	*vsa;
	MACH_PORT_FACE	reply_port;
<span class="enscript-comment">//	kern_return_t	kr;
</span>
	VS_ASYNC_LOCK();
	<span class="enscript-keyword">if</span> (vs_async_free_list == NULL) {
		VS_ASYNC_UNLOCK();
		vsa = (<span class="enscript-type">struct</span> vs_async *) kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vs_async));
		<span class="enscript-keyword">if</span> (vsa != NULL) {
			<span class="enscript-comment">/*
			 * Try allocating a reply port named after the
			 * address of the vs_async structure.
			 */</span>
			<span class="enscript-type">struct</span> vstruct_alias 	*alias_struct;

			reply_port = ipc_port_alloc_kernel();
			alias_struct = (<span class="enscript-type">struct</span> vstruct_alias *) 
				kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vstruct_alias));
			<span class="enscript-keyword">if</span>(alias_struct != NULL) {
				__IGNORE_WCASTALIGN(alias_struct-&gt;vs = (<span class="enscript-type">struct</span> vstruct *)vsa);
				alias_struct-&gt;name = &amp;default_pager_ops;
				reply_port-&gt;ip_alias = (uintptr_t) alias_struct;
				vsa-&gt;reply_port = reply_port;
				vs_alloc_async_count++;
			}
			<span class="enscript-keyword">else</span> {
				vs_alloc_async_failed++;
				ipc_port_dealloc_kernel((MACH_PORT_FACE) 
								(reply_port));
				kfree(vsa, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vs_async));
				vsa = NULL;
			}
		}
	} <span class="enscript-keyword">else</span> {
		vsa = vs_async_free_list;
		vs_async_free_list = vs_async_free_list-&gt;vsa_next;
		VS_ASYNC_UNLOCK();
	}

	<span class="enscript-keyword">return</span> vsa;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vs_free_async</span>(
	<span class="enscript-type">struct</span> vs_async *vsa)
{
	VS_ASYNC_LOCK();
	vsa-&gt;vsa_next = vs_async_free_list;
	vs_async_free_list = vsa;
	VS_ASYNC_UNLOCK();
}

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* VS_ASYNC_REUSE */</span>

<span class="enscript-type">struct</span> vs_async *
<span class="enscript-function-name">vs_alloc_async</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> vs_async	*vsa;
	MACH_PORT_FACE	reply_port;
	kern_return_t	kr;

	vsa = (<span class="enscript-type">struct</span> vs_async *) kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vs_async));
	<span class="enscript-keyword">if</span> (vsa != NULL) {
		<span class="enscript-comment">/*
		 * Try allocating a reply port named after the
		 * address of the vs_async structure.
		 */</span>
			reply_port = ipc_port_alloc_kernel();
			alias_struct = (vstruct_alias *) 
				kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vstruct_alias));
			<span class="enscript-keyword">if</span>(alias_struct != NULL) {
				alias_struct-&gt;vs = reply_port;
				alias_struct-&gt;name = &amp;default_pager_ops;
				reply_port-&gt;defpager_importance.alias = (<span class="enscript-type">int</span>) vsa;
				vsa-&gt;reply_port = reply_port;
				vs_alloc_async_count++;
			}
			<span class="enscript-keyword">else</span> {
				vs_alloc_async_failed++;
				ipc_port_dealloc_kernel((MACH_PORT_FACE) 
								(reply_port));
				kfree(vsa, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vs_async));
				vsa = NULL;
			}
	}

	<span class="enscript-keyword">return</span> vsa;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vs_free_async</span>(
	<span class="enscript-type">struct</span> vs_async *vsa)
{
	MACH_PORT_FACE	reply_port;
	kern_return_t	kr;

	reply_port = vsa-&gt;reply_port;
	kfree(reply_port-&gt;ip_alias, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vstuct_alias));
	kfree(vsa, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> vs_async));
	ipc_port_dealloc_kernel((MACH_PORT_FACE) (reply_port));
#<span class="enscript-reference">if</span> 0
	VS_ASYNC_LOCK();
	vs_alloc_async_count--;
	VS_ASYNC_UNLOCK();
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* VS_ASYNC_REUSE */</span>

zone_t	vstruct_zone;

vstruct_t
<span class="enscript-function-name">ps_vstruct_create</span>(
	dp_size_t size)
{
	vstruct_t	vs;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;

	vs = (vstruct_t) zalloc(vstruct_zone);
	<span class="enscript-keyword">if</span> (vs == VSTRUCT_NULL) {
		<span class="enscript-keyword">return</span> VSTRUCT_NULL;
	}

	VS_LOCK_INIT(vs);

	<span class="enscript-comment">/*
	 * The following fields will be provided later.
	 */</span>
	vs-&gt;vs_pager_ops = NULL;
	vs-&gt;vs_control = MEMORY_OBJECT_CONTROL_NULL;
	vs-&gt;vs_references = 1;
	vs-&gt;vs_seqno = 0;

	vs-&gt;vs_waiting_seqno = FALSE;
	vs-&gt;vs_waiting_read = FALSE;
	vs-&gt;vs_waiting_write = FALSE;
	vs-&gt;vs_waiting_async = FALSE;

	vs-&gt;vs_readers = 0;
	vs-&gt;vs_writers = 0;

	vs-&gt;vs_errors = 0;

	vs-&gt;vs_clshift = local_log2(bs_get_global_clsize(0));
	vs-&gt;vs_size = ((atop_32(round_page_32(size)) - 1) &gt;&gt; vs-&gt;vs_clshift) + 1;
	vs-&gt;vs_async_pending = 0;

	<span class="enscript-comment">/*
	 * Allocate the pmap, either CLMAP_SIZE or INDIRECT_CLMAP_SIZE
	 * depending on the size of the memory object.
	 */</span>
	<span class="enscript-keyword">if</span> (INDIRECT_CLMAP(vs-&gt;vs_size)) {
		vs-&gt;vs_imap = (<span class="enscript-type">struct</span> vs_map **)
			kalloc(INDIRECT_CLMAP_SIZE(vs-&gt;vs_size));
		vs-&gt;vs_indirect = TRUE;
	} <span class="enscript-keyword">else</span> {
		vs-&gt;vs_dmap = (<span class="enscript-type">struct</span> vs_map *)
			kalloc(CLMAP_SIZE(vs-&gt;vs_size));
		vs-&gt;vs_indirect = FALSE;
	}
	vs-&gt;vs_xfer_pending = FALSE;
	DP_DEBUG(DEBUG_VS_INTERNAL,
		 (<span class="enscript-string">&quot;map=0x%x, indirect=%d\n&quot;</span>, (<span class="enscript-type">int</span>) vs-&gt;vs_dmap, vs-&gt;vs_indirect));

	<span class="enscript-comment">/*
	 * Check to see that we got the space.
	 */</span>
	<span class="enscript-keyword">if</span> (!vs-&gt;vs_dmap) {
		kfree(vs, <span class="enscript-keyword">sizeof</span> *vs);
		<span class="enscript-keyword">return</span> VSTRUCT_NULL;
	}

	<span class="enscript-comment">/*
	 * Zero the indirect pointers, or clear the direct pointers.
	 */</span>
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect)
		memset(vs-&gt;vs_imap, 0,
		       INDIRECT_CLMAP_SIZE(vs-&gt;vs_size));
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; vs-&gt;vs_size; i++) 
			VSM_CLR(vs-&gt;vs_dmap[i]);

	VS_MAP_LOCK_INIT(vs);

	bs_commit(vs-&gt;vs_size);

	<span class="enscript-keyword">return</span> vs;
}

paging_segment_t <span class="enscript-function-name">ps_select_segment</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);	<span class="enscript-comment">/* forward */</span>

paging_segment_t
<span class="enscript-function-name">ps_select_segment</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	shift,
	<span class="enscript-type">int</span>		*psindex)
{
	paging_segment_t	ps;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			j;

	<span class="enscript-comment">/*
	 * Optimize case where there's only one segment.
	 * paging_segment_max will index the one and only segment.
	 */</span>

	PSL_LOCK();
	<span class="enscript-keyword">if</span> (paging_segment_count == 1) {
		paging_segment_t lps = PAGING_SEGMENT_NULL;	<span class="enscript-comment">/* used to avoid extra PS_UNLOCK */</span>
		ipc_port_t trigger = IP_NULL;

		ps = paging_segments[paging_segment_max];
		*psindex = paging_segment_max;
		PS_LOCK(ps);
		<span class="enscript-keyword">if</span>( !IS_PS_EMERGENCY_SEGMENT(ps) ) {
			panic(<span class="enscript-string">&quot;Emergency paging segment missing\n&quot;</span>);
		}
		ASSERT(ps-&gt;ps_clshift &gt;= shift);
		<span class="enscript-keyword">if</span>(IS_PS_OK_TO_USE(ps)) {
			<span class="enscript-keyword">if</span> (ps-&gt;ps_clcount) {
				ps-&gt;ps_clcount--;
				dp_pages_free -=  1 &lt;&lt; ps-&gt;ps_clshift;
				ps-&gt;ps_pgcount -=  1 &lt;&lt; ps-&gt;ps_clshift;
				<span class="enscript-keyword">if</span>(min_pages_trigger_port &amp;&amp; 
				  (dp_pages_free &lt; minimum_pages_remaining)) {
					trigger = min_pages_trigger_port;
					min_pages_trigger_port = NULL;
					bs_low = TRUE;
					backing_store_abort_compaction = TRUE;
				}
				lps = ps;
			} 
		} 
		PS_UNLOCK(ps);
		
		<span class="enscript-keyword">if</span>( lps == PAGING_SEGMENT_NULL ) {
			<span class="enscript-keyword">if</span>(dp_pages_free) {
				dp_pages_free_drift_count++;
				<span class="enscript-keyword">if</span>(dp_pages_free &gt; dp_pages_free_drifted_max) {
					dp_pages_free_drifted_max = dp_pages_free;
				}
				dprintf((<span class="enscript-string">&quot;Emergency swap segment:dp_pages_free before zeroing out: %d\n&quot;</span>,dp_pages_free));
			}
	        	dp_pages_free = 0;
		}

		PSL_UNLOCK();

		<span class="enscript-keyword">if</span> (trigger != IP_NULL) {
			dprintf((<span class="enscript-string">&quot;ps_select_segment - send HI_WAT_ALERT\n&quot;</span>));

			default_pager_space_alert(trigger, HI_WAT_ALERT);
			ipc_port_release_send(trigger);
		}
		<span class="enscript-keyword">return</span> lps;
	}

	<span class="enscript-keyword">if</span> (paging_segment_count == 0) {
		<span class="enscript-keyword">if</span>(dp_pages_free) {
			dp_pages_free_drift_count++;
			<span class="enscript-keyword">if</span>(dp_pages_free &gt; dp_pages_free_drifted_max) {
				dp_pages_free_drifted_max = dp_pages_free;
			}
			dprintf((<span class="enscript-string">&quot;No paging segments:dp_pages_free before zeroing out: %d\n&quot;</span>,dp_pages_free));
		}
	        dp_pages_free = 0;
		PSL_UNLOCK();
		<span class="enscript-keyword">return</span> PAGING_SEGMENT_NULL;
	}

	<span class="enscript-keyword">for</span> (i = BS_MAXPRI;
	     i &gt;= BS_MINPRI; i--) {
		<span class="enscript-type">int</span> start_index;

		<span class="enscript-keyword">if</span> ((ps_select_array[i] == BS_NOPRI) ||
				(ps_select_array[i] == BS_FULLPRI))
			<span class="enscript-keyword">continue</span>;
		start_index = ps_select_array[i];

		<span class="enscript-keyword">if</span>(!(paging_segments[start_index])) {
			j = start_index+1;
			physical_transfer_cluster_count = 0;
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((physical_transfer_cluster_count+1) == (ALLOC_STRIDE &gt;&gt; 
				(((paging_segments[start_index])-&gt;ps_clshift)
				+ vm_page_shift))) {
			physical_transfer_cluster_count = 0;
			j = start_index + 1;
		} <span class="enscript-keyword">else</span> {
			physical_transfer_cluster_count+=1;
			j = start_index;
			<span class="enscript-keyword">if</span>(start_index == 0)
				start_index = paging_segment_max; 
			<span class="enscript-keyword">else</span>
				start_index = start_index - 1;
		}

		<span class="enscript-keyword">while</span> (1) {
			<span class="enscript-keyword">if</span> (j &gt; paging_segment_max)
				j = 0;
			<span class="enscript-keyword">if</span> ((ps = paging_segments[j]) &amp;&amp;
			    (ps-&gt;ps_bs-&gt;bs_priority == i)) {
				<span class="enscript-comment">/*
				 * Force the ps cluster size to be
				 * &gt;= that of the vstruct.
				 */</span>
				PS_LOCK(ps);
				<span class="enscript-keyword">if</span> (IS_PS_OK_TO_USE(ps)) {
					<span class="enscript-keyword">if</span> ((ps-&gt;ps_clcount) &amp;&amp;
						   (ps-&gt;ps_clshift &gt;= shift)) {
						ipc_port_t trigger = IP_NULL;

						ps-&gt;ps_clcount--;
						dp_pages_free -=  1 &lt;&lt; ps-&gt;ps_clshift;
						ps-&gt;ps_pgcount -=  1 &lt;&lt; ps-&gt;ps_clshift;
						<span class="enscript-keyword">if</span>(min_pages_trigger_port &amp;&amp; 
							(dp_pages_free &lt; 
							minimum_pages_remaining)) {
							trigger = min_pages_trigger_port;
							min_pages_trigger_port = NULL;
							bs_low = TRUE;
							backing_store_abort_compaction = TRUE;
						}
						PS_UNLOCK(ps);
						<span class="enscript-comment">/*
						 * found one, quit looking.
						 */</span>
						ps_select_array[i] = j;
						PSL_UNLOCK();
						
						<span class="enscript-keyword">if</span> (trigger != IP_NULL) {
							dprintf((<span class="enscript-string">&quot;ps_select_segment - send HI_WAT_ALERT\n&quot;</span>));

							default_pager_space_alert(
								trigger,
								HI_WAT_ALERT);
							ipc_port_release_send(trigger);
						}
						*psindex = j;
						<span class="enscript-keyword">return</span> ps;
					}
				}
				PS_UNLOCK(ps);
			}
			<span class="enscript-keyword">if</span> (j == start_index) {
				<span class="enscript-comment">/*
				 * none at this priority -- mark it full
				 */</span>
				ps_select_array[i] = BS_FULLPRI;
				<span class="enscript-keyword">break</span>;
			}
			j++;
		}
	}
	
	<span class="enscript-keyword">if</span>(dp_pages_free) {
		dp_pages_free_drift_count++;
		<span class="enscript-keyword">if</span>(dp_pages_free &gt; dp_pages_free_drifted_max) {
			dp_pages_free_drifted_max = dp_pages_free;
		}
		dprintf((<span class="enscript-string">&quot;%d Paging Segments: dp_pages_free before zeroing out: %d\n&quot;</span>,paging_segment_count,dp_pages_free));
	}
	dp_pages_free = 0;
	PSL_UNLOCK();
	<span class="enscript-keyword">return</span> PAGING_SEGMENT_NULL;
}

dp_offset_t <span class="enscript-function-name">ps_allocate_cluster</span>(vstruct_t, <span class="enscript-type">int</span> *, paging_segment_t); <span class="enscript-comment">/*forward*/</span>

dp_offset_t
<span class="enscript-function-name">ps_allocate_cluster</span>(
	vstruct_t		vs,
	<span class="enscript-type">int</span>			*psindex,
	paging_segment_t	use_ps)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		byte_num;
	<span class="enscript-type">int</span>			bit_num = 0;
	paging_segment_t	ps;
	dp_offset_t		cluster;
	ipc_port_t		trigger = IP_NULL;

	<span class="enscript-comment">/*
	 * Find best paging segment.
	 * ps_select_segment will decrement cluster count on ps.
	 * Must pass cluster shift to find the most appropriate segment.
	 */</span>
	<span class="enscript-comment">/* NOTE:  The addition of paging segment delete capability threatened
	 * to seriously complicate the treatment of paging segments in this
	 * module and the ones that call it (notably ps_clmap), because of the
	 * difficulty in assuring that the paging segment would continue to
	 * exist between being unlocked and locked.   This was
	 * avoided because all calls to this module are based in either
	 * dp_memory_object calls which rely on the vs lock, or by
	 * the transfer function which is part of the segment delete path.
	 * The transfer function which is part of paging segment delete is 
	 * protected from multiple callers by the backing store lock.  
	 * The paging segment delete function treats mappings to a paging 
	 * segment on a vstruct by vstruct basis, locking the vstruct targeted 
	 * while data is transferred to the remaining segments.  This is in
	 * line with the view that incomplete or in-transition mappings between
	 * data, a vstruct, and backing store are protected by the vs lock. 
	 * This and the ordering of the paging segment &quot;going_away&quot; bit setting
	 * protects us.
	 */</span>
<span class="enscript-reference">retry</span>:
	<span class="enscript-keyword">if</span> (use_ps != PAGING_SEGMENT_NULL) {
		ps = use_ps;
		PSL_LOCK();
		PS_LOCK(ps);

		ASSERT(ps-&gt;ps_clcount != 0);

		ps-&gt;ps_clcount--;
		dp_pages_free -=  1 &lt;&lt; ps-&gt;ps_clshift;
		ps-&gt;ps_pgcount -=  1 &lt;&lt; ps-&gt;ps_clshift;
		<span class="enscript-keyword">if</span>(min_pages_trigger_port &amp;&amp; 
				(dp_pages_free &lt; minimum_pages_remaining)) {
			trigger = min_pages_trigger_port;
			min_pages_trigger_port = NULL;
			bs_low = TRUE;
			backing_store_abort_compaction = TRUE;
		}
		PSL_UNLOCK();
		PS_UNLOCK(ps);
		<span class="enscript-keyword">if</span> (trigger != IP_NULL) {
			dprintf((<span class="enscript-string">&quot;ps_allocate_cluster - send HI_WAT_ALERT\n&quot;</span>));

			default_pager_space_alert(trigger, HI_WAT_ALERT);
			ipc_port_release_send(trigger);
		}

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ps = ps_select_segment(vs-&gt;vs_clshift, psindex)) ==
		   PAGING_SEGMENT_NULL) {
		<span class="enscript-type">static</span> clock_sec_t lastnotify = 0;
		clock_sec_t now;
		clock_nsec_t nanoseconds_dummy;
		
		<span class="enscript-comment">/* 
		 * Don't immediately jump to the emergency segment. Give the
		 * dynamic pager a chance to create it's first normal swap file.
		 * Unless, of course the very first normal swap file can't be 
		 * created due to some problem and we didn't expect that problem
		 * i.e. use_emergency_swap_file_first was never set to true initially.
		 * It then gets set in the swap file creation error handling.
		 */</span>
		<span class="enscript-keyword">if</span>(paging_segment_count &gt; 1 || use_emergency_swap_file_first == TRUE) {
			
			ps = paging_segments[EMERGENCY_PSEG_INDEX];
			<span class="enscript-keyword">if</span>(IS_PS_EMERGENCY_SEGMENT(ps) &amp;&amp; !IS_PS_GOING_AWAY(ps)) {
				PSL_LOCK();
				PS_LOCK(ps);
				
				<span class="enscript-keyword">if</span>(IS_PS_GOING_AWAY(ps)) {
					<span class="enscript-comment">/* Someone de-activated the emergency paging segment*/</span>
					PS_UNLOCK(ps);
					PSL_UNLOCK();

				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(dp_pages_free) {
					<span class="enscript-comment">/* 
					 * Someone has already activated the emergency paging segment 
					 * OR
					 * Between us having rec'd a NULL segment from ps_select_segment
					 * and reaching here a new normal segment could have been added.
					 * E.g. we get NULL segment and another thread just added the
					 * new swap file. Hence check to see if we have more dp_pages_free
					 * before activating the emergency segment.
					 */</span>
					PS_UNLOCK(ps);
					PSL_UNLOCK();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
				
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(!IS_PS_OK_TO_USE(ps) &amp;&amp; ps-&gt;ps_clcount) {
					<span class="enscript-comment">/*
					 * PS_CAN_USE is only reset from the emergency segment when it's
					 * been successfully recovered. So it's legal to have an emergency
					 * segment that has PS_CAN_USE but no clusters because it's recovery
					 * failed.
					 */</span>
					backing_store_t bs = ps-&gt;ps_bs;
					ps-&gt;ps_state |= PS_CAN_USE;
					<span class="enscript-keyword">if</span>(ps_select_array[bs-&gt;bs_priority] == BS_FULLPRI ||
						ps_select_array[bs-&gt;bs_priority] == BS_NOPRI) {
						ps_select_array[bs-&gt;bs_priority] = 0;
					}
					dp_pages_free += ps-&gt;ps_pgcount;
					dp_pages_reserve -= ps-&gt;ps_pgcount;
					PS_UNLOCK(ps);
					PSL_UNLOCK();
					dprintf((<span class="enscript-string">&quot;Switching ON Emergency paging segment\n&quot;</span>));
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
				}

				PS_UNLOCK(ps);
				PSL_UNLOCK();
			}
		}
		
		<span class="enscript-comment">/*
		 * Emit a notification of the low-paging resource condition
		 * but don't issue it more than once every five seconds.  This
		 * prevents us from overflowing logs with thousands of
		 * repetitions of the message.
		 */</span>
		clock_get_system_nanotime(&amp;now, &amp;nanoseconds_dummy);
		<span class="enscript-keyword">if</span> (paging_segment_count &gt; 1 &amp;&amp; (now &gt; lastnotify + 5)) {
			<span class="enscript-comment">/* With an activated emergency paging segment we still
			 * didn't get any clusters. This could mean that the 
			 * emergency paging segment is exhausted.
 			 */</span>
			dprintf((<span class="enscript-string">&quot;System is out of paging space.\n&quot;</span>));
			lastnotify = now;
		}

		PSL_LOCK();
		
		<span class="enscript-keyword">if</span>(min_pages_trigger_port) {
			trigger = min_pages_trigger_port;
			min_pages_trigger_port = NULL;
			bs_low = TRUE;
			backing_store_abort_compaction = TRUE;
		}
		PSL_UNLOCK();
		<span class="enscript-keyword">if</span> (trigger != IP_NULL) {
			dprintf((<span class="enscript-string">&quot;ps_allocate_cluster - send HI_WAT_ALERT\n&quot;</span>));

			default_pager_space_alert(trigger, HI_WAT_ALERT);
			ipc_port_release_send(trigger);
		}
		<span class="enscript-keyword">return</span> (dp_offset_t) -1;
	}

	<span class="enscript-comment">/*
	 * Look for an available cluster.  At the end of the loop,
	 * byte_num is the byte offset and bit_num is the bit offset of the
	 * first zero bit in the paging segment bitmap.
	 */</span>
	PS_LOCK(ps);
	byte_num = ps-&gt;ps_hint;
	<span class="enscript-keyword">for</span> (; byte_num &lt; howmany(ps-&gt;ps_ncls, NBBY); byte_num++) {
		<span class="enscript-keyword">if</span> (*(ps-&gt;ps_bmap + byte_num) != BYTEMASK) {
			<span class="enscript-keyword">for</span> (bit_num = 0; bit_num &lt; NBBY; bit_num++) {
				<span class="enscript-keyword">if</span> (isclr((ps-&gt;ps_bmap + byte_num), bit_num))
					<span class="enscript-keyword">break</span>;
			}
			ASSERT(bit_num != NBBY);
			<span class="enscript-keyword">break</span>;
		}
	}
	ps-&gt;ps_hint = byte_num;
	cluster = (byte_num*NBBY) + bit_num;

	<span class="enscript-comment">/* Space was reserved, so this must be true */</span>
	ASSERT(cluster &lt; ps-&gt;ps_ncls);

	setbit(ps-&gt;ps_bmap, cluster);
	PS_UNLOCK(ps);

	<span class="enscript-keyword">return</span> cluster;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ps_deallocate_cluster</span>(paging_segment_t, dp_offset_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ps_deallocate_cluster</span>(
	paging_segment_t	ps,
	dp_offset_t		cluster)
{

	<span class="enscript-keyword">if</span> (cluster &gt;= ps-&gt;ps_ncls)
		panic(<span class="enscript-string">&quot;ps_deallocate_cluster: Invalid cluster number&quot;</span>);

	<span class="enscript-comment">/*
	 * Lock the paging segment, clear the cluster's bitmap and increment the
	 * number of free cluster.
	 */</span>
	PSL_LOCK();
	PS_LOCK(ps);
	clrbit(ps-&gt;ps_bmap, cluster);
	<span class="enscript-keyword">if</span>( IS_PS_OK_TO_USE(ps)) {
		++ps-&gt;ps_clcount;
		ps-&gt;ps_pgcount +=  1 &lt;&lt; ps-&gt;ps_clshift;
		dp_pages_free +=  1 &lt;&lt; ps-&gt;ps_clshift;
	} <span class="enscript-keyword">else</span> {
		ps-&gt;ps_special_clusters += 1;
	}

	<span class="enscript-comment">/*
	 * Move the hint down to the freed cluster if it is
	 * less than the current hint.
	 */</span>
	<span class="enscript-keyword">if</span> ((cluster/NBBY) &lt; ps-&gt;ps_hint) {
		ps-&gt;ps_hint = (cluster/NBBY);
	}


	<span class="enscript-comment">/*
	 * If we're freeing space on a full priority, reset the array.
	 */</span>
	<span class="enscript-keyword">if</span> ( IS_PS_OK_TO_USE(ps) &amp;&amp; ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] == BS_FULLPRI)
		ps_select_array[ps-&gt;ps_bs-&gt;bs_priority] = 0;
	PS_UNLOCK(ps);
	PSL_UNLOCK();

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ps_dealloc_vsmap</span>(<span class="enscript-type">struct</span> vs_map *, dp_size_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ps_dealloc_vsmap</span>(
	<span class="enscript-type">struct</span> vs_map	*vsmap,
	dp_size_t	size)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> ps_vnode_trim_data trim_data;

	ps_vnode_trim_init(&amp;trim_data);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++) {
		<span class="enscript-keyword">if</span> (!VSM_ISCLR(vsmap[i]) &amp;&amp; !VSM_ISERR(vsmap[i])) {
			ps_vnode_trim_more(&amp;trim_data,
					      &amp;vsmap[i],
					      VSM_PS(vsmap[i])-&gt;ps_clshift,
					      vm_page_size &lt;&lt; VSM_PS(vsmap[i])-&gt;ps_clshift);
			ps_deallocate_cluster(VSM_PS(vsmap[i]),
					      VSM_CLOFF(vsmap[i]));
		} <span class="enscript-keyword">else</span> {
			ps_vnode_trim_now(&amp;trim_data);
		}
	}
	ps_vnode_trim_now(&amp;trim_data);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ps_vstruct_dealloc</span>(
	vstruct_t vs)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
<span class="enscript-comment">//	spl_t	s;
</span>
	VS_MAP_LOCK(vs);

	<span class="enscript-comment">/*
	 * If this is an indirect structure, then we walk through the valid
	 * (non-zero) indirect pointers and deallocate the clusters
	 * associated with each used map entry (via ps_dealloc_vsmap).
	 * When all of the clusters in an indirect block have been
	 * freed, we deallocate the block.  When all of the indirect
	 * blocks have been deallocated we deallocate the memory
	 * holding the indirect pointers.
	 */</span>
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size); i++) {
			<span class="enscript-keyword">if</span> (vs-&gt;vs_imap[i] != NULL) {
				ps_dealloc_vsmap(vs-&gt;vs_imap[i], CLMAP_ENTRIES);
				kfree(vs-&gt;vs_imap[i], CLMAP_THRESHOLD);
			}
		}
		kfree(vs-&gt;vs_imap, INDIRECT_CLMAP_SIZE(vs-&gt;vs_size));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Direct map.  Free used clusters, then memory.
		 */</span>
		ps_dealloc_vsmap(vs-&gt;vs_dmap, vs-&gt;vs_size);
		kfree(vs-&gt;vs_dmap, CLMAP_SIZE(vs-&gt;vs_size));
	}
	VS_MAP_UNLOCK(vs);

	bs_commit(- vs-&gt;vs_size);

	VS_MAP_LOCK_DESTROY(vs);

	zfree(vstruct_zone, vs);
}

kern_return_t
<span class="enscript-function-name">ps_vstruct_reclaim</span>(
	vstruct_t vs,
	boolean_t return_to_vm,
	boolean_t reclaim_backing_store)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j;
	<span class="enscript-type">struct</span> vs_map	*vsmap;
	boolean_t	vsmap_all_clear, vsimap_all_clear;
	<span class="enscript-type">struct</span> vm_object_fault_info fault_info;
	<span class="enscript-type">int</span>		clmap_off;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vsmap_size;
	kern_return_t	kr = KERN_SUCCESS;

	VS_MAP_LOCK(vs);

	fault_info.cluster_size = VM_SUPER_CLUSTER;
	fault_info.behavior = VM_BEHAVIOR_SEQUENTIAL;
	fault_info.user_tag = 0;
	fault_info.pmap_options = 0;
	fault_info.lo_offset = 0;
	fault_info.hi_offset = ptoa_32(vs-&gt;vs_size &lt;&lt; vs-&gt;vs_clshift);
	fault_info.io_sync = reclaim_backing_store;
	fault_info.batch_pmap_op = FALSE;

	<span class="enscript-comment">/*
	 * If this is an indirect structure, then we walk through the valid
	 * (non-zero) indirect pointers and deallocate the clusters
	 * associated with each used map entry (via ps_dealloc_vsmap).
	 * When all of the clusters in an indirect block have been
	 * freed, we deallocate the block.  When all of the indirect
	 * blocks have been deallocated we deallocate the memory
	 * holding the indirect pointers.
	 */</span>
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		vsimap_all_clear = TRUE;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size); i++) {
			vsmap = vs-&gt;vs_imap[i];
			<span class="enscript-keyword">if</span> (vsmap == NULL)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* loop on clusters in this indirect map */</span>
			clmap_off = (vm_page_size * CLMAP_ENTRIES *
				     VSCLSIZE(vs) * i);
			<span class="enscript-keyword">if</span> (i+1 == INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size))
				vsmap_size = vs-&gt;vs_size - (CLMAP_ENTRIES * i);
			<span class="enscript-keyword">else</span>
				vsmap_size = CLMAP_ENTRIES;
			vsmap_all_clear = TRUE;
			<span class="enscript-keyword">if</span> (return_to_vm) {
				<span class="enscript-keyword">for</span> (j = 0; j &lt; vsmap_size;) {
					<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
					    VSM_ISERR(vsmap[j])) {
						j++;
						clmap_off += vm_page_size * VSCLSIZE(vs);
						<span class="enscript-keyword">continue</span>;
					}
					VS_MAP_UNLOCK(vs);
					kr = pvs_cluster_read(
						vs,
						clmap_off,
						(dp_size_t) -1, <span class="enscript-comment">/* read whole cluster */</span>
						&amp;fault_info);

					VS_MAP_LOCK(vs); <span class="enscript-comment">/* XXX what if it changed ? */</span>
					<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
						vsmap_all_clear = FALSE;
						vsimap_all_clear = FALSE;

						kr = KERN_MEMORY_ERROR;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
					}
				}
			}
			<span class="enscript-keyword">if</span> (vsmap_all_clear) {
				ps_dealloc_vsmap(vsmap, CLMAP_ENTRIES);
				kfree(vsmap, CLMAP_THRESHOLD);
				vs-&gt;vs_imap[i] = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (vsimap_all_clear) {
<span class="enscript-comment">//			kfree(vs-&gt;vs_imap, INDIRECT_CLMAP_SIZE(vs-&gt;vs_size));
</span>		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Direct map.  Free used clusters, then memory.
		 */</span>
		vsmap = vs-&gt;vs_dmap;
		<span class="enscript-keyword">if</span> (vsmap == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vsmap_all_clear = TRUE;
		<span class="enscript-comment">/* loop on clusters in the direct map */</span>
		<span class="enscript-keyword">if</span> (return_to_vm) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; vs-&gt;vs_size;) {
				<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
				    VSM_ISERR(vsmap[j])) {
					j++;
					<span class="enscript-keyword">continue</span>;
				}
				clmap_off = vm_page_size * (j &lt;&lt; vs-&gt;vs_clshift);
				VS_MAP_UNLOCK(vs);
				kr = pvs_cluster_read(
					vs,
					clmap_off,
					(dp_size_t) -1, <span class="enscript-comment">/* read whole cluster */</span>
					&amp;fault_info);

				VS_MAP_LOCK(vs); <span class="enscript-comment">/* XXX what if it changed ? */</span>
				<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
					vsmap_all_clear = FALSE;

					kr = KERN_MEMORY_ERROR;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				} <span class="enscript-keyword">else</span> {
<span class="enscript-comment">//					VSM_CLR(vsmap[j]);
</span>				}
			}
		}
		<span class="enscript-keyword">if</span> (vsmap_all_clear) {
			ps_dealloc_vsmap(vs-&gt;vs_dmap, vs-&gt;vs_size);
<span class="enscript-comment">//			kfree(vs-&gt;vs_dmap, CLMAP_SIZE(vs-&gt;vs_size));
</span>		}
	}
<span class="enscript-reference">out</span>:
	VS_MAP_UNLOCK(vs);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">ps_map_extend</span>(vstruct_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">ps_map_extend</span>(
	vstruct_t	vs,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	new_size)
{
	<span class="enscript-type">struct</span> vs_map	**new_imap;
	<span class="enscript-type">struct</span> vs_map	*new_dmap = NULL;
	<span class="enscript-type">int</span>		newdsize;
	<span class="enscript-type">int</span>		i;
	<span class="enscript-type">void</span>		*old_map = NULL;
	<span class="enscript-type">int</span>		old_map_size = 0;

	<span class="enscript-keyword">if</span> (vs-&gt;vs_size &gt;= new_size) {
		<span class="enscript-comment">/*
		 * Someone has already done the work.
		 */</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/*
	 * If the new size extends into the indirect range, then we have one
	 * of two cases: we are going from indirect to indirect, or we are
	 * going from direct to indirect.  If we are going from indirect to
	 * indirect, then it is possible that the new size will fit in the old
	 * indirect map.  If this is the case, then just reset the size of the
	 * vstruct map and we are done.  If the new size will not
	 * fit into the old indirect map, then we have to allocate a new
	 * indirect map and copy the old map pointers into this new map.
	 *
	 * If we are going from direct to indirect, then we have to allocate a
	 * new indirect map and copy the old direct pages into the first
	 * indirect page of the new map.
	 * NOTE: allocating memory here is dangerous, as we're in the
	 * pageout path.
	 */</span>
	<span class="enscript-keyword">if</span> (INDIRECT_CLMAP(new_size)) {
		<span class="enscript-type">int</span> new_map_size = INDIRECT_CLMAP_SIZE(new_size);

		<span class="enscript-comment">/*
		 * Get a new indirect map and zero it.
		 */</span>
		old_map_size = INDIRECT_CLMAP_SIZE(vs-&gt;vs_size);
		<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect &amp;&amp;
		    (new_map_size == old_map_size)) {
			bs_commit(new_size - vs-&gt;vs_size);
			vs-&gt;vs_size = new_size;
			<span class="enscript-keyword">return</span> 0;
		}

		new_imap = (<span class="enscript-type">struct</span> vs_map **)kalloc(new_map_size);
		<span class="enscript-keyword">if</span> (new_imap == NULL) {
			<span class="enscript-keyword">return</span> -1;
		}
		memset(new_imap, 0, new_map_size);

		<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
			<span class="enscript-comment">/* Copy old entries into new map */</span>
			memcpy(new_imap, vs-&gt;vs_imap, old_map_size);
			<span class="enscript-comment">/* Arrange to free the old map */</span>
			old_map = (<span class="enscript-type">void</span> *) vs-&gt;vs_imap;
			newdsize = 0;
		} <span class="enscript-keyword">else</span> {	<span class="enscript-comment">/* Old map was a direct map */</span>
			<span class="enscript-comment">/* Allocate an indirect page */</span>
			<span class="enscript-keyword">if</span> ((new_imap[0] = (<span class="enscript-type">struct</span> vs_map *)
			     kalloc(CLMAP_THRESHOLD)) == NULL) {
				kfree(new_imap, new_map_size);
				<span class="enscript-keyword">return</span> -1;
			}
			new_dmap = new_imap[0];
			newdsize = CLMAP_ENTRIES;
		}
	} <span class="enscript-keyword">else</span> {
		new_imap = NULL;
		newdsize = new_size;
		<span class="enscript-comment">/*
		 * If the new map is a direct map, then the old map must
		 * also have been a direct map.  All we have to do is
		 * to allocate a new direct map, copy the old entries
		 * into it and free the old map.
		 */</span>
		<span class="enscript-keyword">if</span> ((new_dmap = (<span class="enscript-type">struct</span> vs_map *)
		     kalloc(CLMAP_SIZE(new_size))) == NULL) {
			<span class="enscript-keyword">return</span> -1;
		}
	}
	<span class="enscript-keyword">if</span> (newdsize) {

		<span class="enscript-comment">/* Free the old map */</span>
		old_map = (<span class="enscript-type">void</span> *) vs-&gt;vs_dmap;
		old_map_size = CLMAP_SIZE(vs-&gt;vs_size);

		<span class="enscript-comment">/* Copy info from the old map into the new map */</span>
		memcpy(new_dmap, vs-&gt;vs_dmap, old_map_size);

		<span class="enscript-comment">/* Initialize the rest of the new map */</span>
		<span class="enscript-keyword">for</span> (i = vs-&gt;vs_size; i &lt; newdsize; i++)
			VSM_CLR(new_dmap[i]);
	}
	<span class="enscript-keyword">if</span> (new_imap) {
		vs-&gt;vs_imap = new_imap;
		vs-&gt;vs_indirect = TRUE;
	} <span class="enscript-keyword">else</span>
		vs-&gt;vs_dmap = new_dmap;
	bs_commit(new_size - vs-&gt;vs_size);
	vs-&gt;vs_size = new_size;
	<span class="enscript-keyword">if</span> (old_map)
		kfree(old_map, old_map_size);
	<span class="enscript-keyword">return</span> 0;
}

dp_offset_t
<span class="enscript-function-name">ps_clmap</span>(
	vstruct_t	vs,
	dp_offset_t	offset,
	<span class="enscript-type">struct</span> clmap	*clmap,
	<span class="enscript-type">int</span>		flag,
	dp_size_t	size,
	<span class="enscript-type">int</span>		error)
{
	dp_offset_t	cluster;	<span class="enscript-comment">/* The cluster of offset.	*/</span>
	dp_offset_t	newcl;		<span class="enscript-comment">/* The new cluster allocated.	*/</span>
	dp_offset_t	newoff;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
	<span class="enscript-type">struct</span> vs_map	*vsmap;

	VS_MAP_LOCK(vs);

	ASSERT(vs-&gt;vs_dmap);
	cluster = atop_32(offset) &gt;&gt; vs-&gt;vs_clshift;

	<span class="enscript-comment">/*
	 * Initialize cluster error value
	 */</span>
	clmap-&gt;cl_error = 0;

	<span class="enscript-comment">/*
	 * If the object has grown, extend the page map.
	 */</span>
	<span class="enscript-keyword">if</span> (cluster &gt;= vs-&gt;vs_size) {
		<span class="enscript-keyword">if</span> (flag == CL_FIND) {
			<span class="enscript-comment">/* Do not allocate if just doing a lookup */</span>
			VS_MAP_UNLOCK(vs);
			<span class="enscript-keyword">return</span> (dp_offset_t) -1;
		}
		<span class="enscript-keyword">if</span> (ps_map_extend(vs, cluster + 1)) {
			VS_MAP_UNLOCK(vs);
			<span class="enscript-keyword">return</span> (dp_offset_t) -1;
		}
	}

	<span class="enscript-comment">/*
	 * Look for the desired cluster.  If the map is indirect, then we
	 * have a two level lookup.  First find the indirect block, then
	 * find the actual cluster.  If the indirect block has not yet
	 * been allocated, then do so.  If the cluster has not yet been
	 * allocated, then do so.
	 *
	 * If any of the allocations fail, then return an error.
	 * Don't allocate if just doing a lookup.
	 */</span>
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		<span class="enscript-type">long</span>	ind_block = cluster/CLMAP_ENTRIES;

		<span class="enscript-comment">/* Is the indirect block allocated? */</span>
		vsmap = vs-&gt;vs_imap[ind_block];
		<span class="enscript-keyword">if</span> (vsmap == NULL) {
			<span class="enscript-keyword">if</span> (flag == CL_FIND) {
				VS_MAP_UNLOCK(vs);
				<span class="enscript-keyword">return</span> (dp_offset_t) -1;
			}

			<span class="enscript-comment">/* Allocate the indirect block */</span>
			vsmap = (<span class="enscript-type">struct</span> vs_map *) kalloc(CLMAP_THRESHOLD);
			<span class="enscript-keyword">if</span> (vsmap == NULL) {
				VS_MAP_UNLOCK(vs);
				<span class="enscript-keyword">return</span> (dp_offset_t) -1;
			}
			<span class="enscript-comment">/* Initialize the cluster offsets */</span>
			<span class="enscript-keyword">for</span> (i = 0; i &lt; CLMAP_ENTRIES; i++)
				VSM_CLR(vsmap[i]);
			vs-&gt;vs_imap[ind_block] = vsmap;
		}
	} <span class="enscript-keyword">else</span>
		vsmap = vs-&gt;vs_dmap;

	ASSERT(vsmap);
	vsmap += cluster%CLMAP_ENTRIES;

	<span class="enscript-comment">/*
	 * At this point, vsmap points to the struct vs_map desired.
	 *
	 * Look in the map for the cluster, if there was an error on a
	 * previous write, flag it and return.  If it is not yet
	 * allocated, then allocate it, if we're writing; if we're
	 * doing a lookup and the cluster's not allocated, return error.
	 */</span>
	<span class="enscript-keyword">if</span> (VSM_ISERR(*vsmap)) {
		clmap-&gt;cl_error = VSM_GETERR(*vsmap);
		VS_MAP_UNLOCK(vs);
		<span class="enscript-keyword">return</span> (dp_offset_t) -1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VSM_ISCLR(*vsmap)) {
		<span class="enscript-type">int</span> psindex;

		<span class="enscript-keyword">if</span> (flag == CL_FIND) {
			<span class="enscript-comment">/*
			 * If there's an error and the entry is clear, then
			 * we've run out of swap space.  Record the error
			 * here and return.
			 */</span>
			<span class="enscript-keyword">if</span> (error) {
				VSM_SETERR(*vsmap, error);
			}
			VS_MAP_UNLOCK(vs);
			<span class="enscript-keyword">return</span> (dp_offset_t) -1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Attempt to allocate a cluster from the paging segment
			 */</span>
			newcl = ps_allocate_cluster(vs, &amp;psindex,
						    PAGING_SEGMENT_NULL);
			<span class="enscript-keyword">if</span> (newcl == (dp_offset_t) -1) {
				VS_MAP_UNLOCK(vs);
				<span class="enscript-keyword">return</span> (dp_offset_t) -1;
			}
			VSM_CLR(*vsmap);
			VSM_SETCLOFF(*vsmap, newcl);
			VSM_SETPS(*vsmap, psindex);
		}
	} <span class="enscript-keyword">else</span>
		newcl = VSM_CLOFF(*vsmap);

	<span class="enscript-comment">/*
	 * Fill in pertinent fields of the clmap
	 */</span>
	clmap-&gt;cl_ps = VSM_PS(*vsmap);
	clmap-&gt;cl_numpages = VSCLSIZE(vs);
	clmap-&gt;cl_bmap.clb_map = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) VSM_BMAP(*vsmap);

	<span class="enscript-comment">/*
	 * Byte offset in paging segment is byte offset to cluster plus
	 * byte offset within cluster.  It looks ugly, but should be
	 * relatively quick.
	 */</span>
	ASSERT(trunc_page(offset) == offset);
	newcl = ptoa_32(newcl) &lt;&lt; vs-&gt;vs_clshift;
	newoff = offset &amp; ((1&lt;&lt;(vm_page_shift + vs-&gt;vs_clshift)) - 1);
	<span class="enscript-keyword">if</span> (flag == CL_ALLOC) {
		<span class="enscript-comment">/*
		 * set bits in the allocation bitmap according to which
		 * pages were requested.  size is in bytes.
		 */</span>
		i = atop_32(newoff);
		<span class="enscript-keyword">while</span> ((size &gt; 0) &amp;&amp; (i &lt; VSCLSIZE(vs))) {
			VSM_SETALLOC(*vsmap, i);
			i++;
			size -= vm_page_size;
		}
	}
	clmap-&gt;cl_alloc.clb_map = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) VSM_ALLOC(*vsmap);
	<span class="enscript-keyword">if</span> (newoff) {
		<span class="enscript-comment">/*
		 * Offset is not cluster aligned, so number of pages
		 * and bitmaps must be adjusted
		 */</span>
		clmap-&gt;cl_numpages -= atop_32(newoff);
		CLMAP_SHIFT(clmap, vs);
		CLMAP_SHIFTALLOC(clmap, vs);
	}

	<span class="enscript-comment">/*
	 *
	 * The setting of valid bits and handling of write errors
	 * must be done here, while we hold the lock on the map.
	 * It logically should be done in ps_vs_write_complete().
	 * The size and error information has been passed from
	 * ps_vs_write_complete().  If the size parameter is non-zero,
	 * then there is work to be done.  If error is also non-zero,
	 * then the error number is recorded in the cluster and the
	 * entire cluster is in error.
	 */</span>
	<span class="enscript-keyword">if</span> (size &amp;&amp; flag == CL_FIND) {
		dp_offset_t off = (dp_offset_t) 0;

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">for</span> (i = VSCLSIZE(vs) - clmap-&gt;cl_numpages; size &gt; 0;
			     i++) {
				VSM_SETPG(*vsmap, i);
				size -= vm_page_size;
			}
			ASSERT(i &lt;= VSCLSIZE(vs));
		} <span class="enscript-keyword">else</span> {
			BS_STAT(clmap-&gt;cl_ps-&gt;ps_bs,
				clmap-&gt;cl_ps-&gt;ps_bs-&gt;bs_pages_out_fail +=
					atop_32(size));
			off = VSM_CLOFF(*vsmap);
			VSM_SETERR(*vsmap, error);
		}
		<span class="enscript-comment">/*
		 * Deallocate cluster if error, and no valid pages
		 * already present.
		 */</span>
		<span class="enscript-keyword">if</span> (off != (dp_offset_t) 0)
			ps_deallocate_cluster(clmap-&gt;cl_ps, off);
		VS_MAP_UNLOCK(vs);
		<span class="enscript-keyword">return</span> (dp_offset_t) 0;
	} <span class="enscript-keyword">else</span>
		VS_MAP_UNLOCK(vs);

	DP_DEBUG(DEBUG_VS_INTERNAL,
		 (<span class="enscript-string">&quot;returning 0x%X,vs=0x%X,vsmap=0x%X,flag=%d\n&quot;</span>,
		  newcl+newoff, (<span class="enscript-type">int</span>) vs, (<span class="enscript-type">int</span>) vsmap, flag));
	DP_DEBUG(DEBUG_VS_INTERNAL,
		 (<span class="enscript-string">&quot;	clmap-&gt;cl_ps=0x%X,cl_numpages=%d,clbmap=0x%x,cl_alloc=%x\n&quot;</span>,
		  (<span class="enscript-type">int</span>) clmap-&gt;cl_ps, clmap-&gt;cl_numpages,
		  (<span class="enscript-type">int</span>) clmap-&gt;cl_bmap.clb_map, (<span class="enscript-type">int</span>) clmap-&gt;cl_alloc.clb_map));

	<span class="enscript-keyword">return</span> (newcl + newoff);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ps_clunmap</span>(vstruct_t, dp_offset_t, dp_size_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ps_clunmap</span>(
	vstruct_t	vs,
	dp_offset_t	offset,
	dp_size_t	length)
{
	dp_offset_t		cluster; <span class="enscript-comment">/* The cluster number of offset */</span>
	<span class="enscript-type">struct</span> vs_map		*vsmap;
	<span class="enscript-type">struct</span> ps_vnode_trim_data trim_data;

	ps_vnode_trim_init(&amp;trim_data);

	VS_MAP_LOCK(vs);

	<span class="enscript-comment">/*
	 * Loop through all clusters in this range, freeing paging segment
	 * clusters and map entries as encountered.
	 */</span>
	<span class="enscript-keyword">while</span> (length &gt; 0) {
		dp_offset_t 	newoff;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;

		cluster = atop_32(offset) &gt;&gt; vs-&gt;vs_clshift;
		<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect)	<span class="enscript-comment">/* indirect map */</span>
			vsmap = vs-&gt;vs_imap[cluster/CLMAP_ENTRIES];
		<span class="enscript-keyword">else</span>
			vsmap = vs-&gt;vs_dmap;
		<span class="enscript-keyword">if</span> (vsmap == NULL) {
			ps_vnode_trim_now(&amp;trim_data);
			VS_MAP_UNLOCK(vs);
			<span class="enscript-keyword">return</span>;
		}
		vsmap += cluster%CLMAP_ENTRIES;
		<span class="enscript-keyword">if</span> (VSM_ISCLR(*vsmap)) {
			ps_vnode_trim_now(&amp;trim_data);
			length -= vm_page_size;
			offset += vm_page_size;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * We've got a valid mapping.  Clear it and deallocate
		 * paging segment cluster pages.
		 * Optimize for entire cluster cleraing.
		 */</span>
		<span class="enscript-keyword">if</span> ( (newoff = (offset&amp;((1&lt;&lt;(vm_page_shift+vs-&gt;vs_clshift))-1))) ) {
			<span class="enscript-comment">/*
			 * Not cluster aligned.
			 */</span>
			ASSERT(trunc_page(newoff) == newoff);
			i = atop_32(newoff);
		} <span class="enscript-keyword">else</span>
			i = 0;
		<span class="enscript-keyword">while</span> ((i &lt; VSCLSIZE(vs)) &amp;&amp; (length &gt; 0)) {
			VSM_CLRPG(*vsmap, i);
			VSM_CLRALLOC(*vsmap, i);
			length -= vm_page_size;
			offset += vm_page_size;
			i++;
		}

		<span class="enscript-comment">/*
		 * If map entry is empty, clear and deallocate cluster.
		 */</span>
		<span class="enscript-keyword">if</span> (!VSM_BMAP(*vsmap)) {
			ps_vnode_trim_more(&amp;trim_data, 
					      vsmap,
					      vs-&gt;vs_clshift,
					      VSCLSIZE(vs) * vm_page_size);
			ps_deallocate_cluster(VSM_PS(*vsmap),
					      VSM_CLOFF(*vsmap));
			VSM_CLR(*vsmap);
		} <span class="enscript-keyword">else</span> {
			ps_vnode_trim_now(&amp;trim_data);
		}
	}
	ps_vnode_trim_now(&amp;trim_data);

	VS_MAP_UNLOCK(vs);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ps_vs_write_complete</span>(vstruct_t, dp_offset_t, dp_size_t, <span class="enscript-type">int</span>); <span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ps_vs_write_complete</span>(
	vstruct_t	vs,
	dp_offset_t	offset,
	dp_size_t	size,
	<span class="enscript-type">int</span>		error)
{
	<span class="enscript-type">struct</span> clmap	clmap;

	<span class="enscript-comment">/*
	 * Get the struct vsmap for this cluster.
	 * Use READ, even though it was written, because the
	 * cluster MUST be present, unless there was an error
	 * in the original ps_clmap (e.g. no space), in which
	 * case, nothing happens.
	 *
	 * Must pass enough information to ps_clmap to allow it
	 * to set the vs_map structure bitmap under lock.
	 */</span>
	(<span class="enscript-type">void</span>) ps_clmap(vs, offset, &amp;clmap, CL_FIND, size, error);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">vs_cl_write_complete</span>(vstruct_t, paging_segment_t, dp_offset_t, vm_offset_t, dp_size_t, boolean_t, <span class="enscript-type">int</span>);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">vs_cl_write_complete</span>(
	vstruct_t			vs,
	__unused paging_segment_t	ps,
	dp_offset_t			offset,
	__unused vm_offset_t		addr,
	dp_size_t			size,
	boolean_t			async,
	<span class="enscript-type">int</span>				error)
{
<span class="enscript-comment">//	kern_return_t	kr;
</span>
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/*
		 * For internal objects, the error is recorded on a
		 * per-cluster basis by ps_clmap() which is called
		 * by ps_vs_write_complete() below.
		 */</span>
		dprintf((<span class="enscript-string">&quot;write failed error = 0x%x\n&quot;</span>, error));
		<span class="enscript-comment">/* add upl_abort code here */</span>
	} <span class="enscript-keyword">else</span>
		GSTAT(global_stats.gs_pages_out += atop_32(size));
	<span class="enscript-comment">/*
	 * Notify the vstruct mapping code, so it can do its accounting.
	 */</span>
	ps_vs_write_complete(vs, offset, size, error);

	<span class="enscript-keyword">if</span> (async) {
		VS_LOCK(vs);
		ASSERT(vs-&gt;vs_async_pending &gt; 0);
		vs-&gt;vs_async_pending -= size;
		<span class="enscript-keyword">if</span> (vs-&gt;vs_async_pending == 0 &amp;&amp; vs-&gt;vs_waiting_async) {
			vs-&gt;vs_waiting_async = FALSE;
			VS_UNLOCK(vs);
			thread_wakeup(&amp;vs-&gt;vs_async_pending);
		} <span class="enscript-keyword">else</span> {
			VS_UNLOCK(vs);
		}
	}
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEVICE_PAGING</span>
kern_return_t <span class="enscript-function-name">device_write_reply</span>(MACH_PORT_FACE, kern_return_t, io_buf_len_t);

kern_return_t
<span class="enscript-function-name">device_write_reply</span>(
	MACH_PORT_FACE	reply_port,
	kern_return_t	device_code,
	io_buf_len_t	bytes_written)
{
	<span class="enscript-type">struct</span> vs_async	*vsa;

	vsa = (<span class="enscript-type">struct</span> vs_async *)
		((<span class="enscript-type">struct</span> vstruct_alias *)(reply_port-&gt;ip_alias))-&gt;vs;

	<span class="enscript-keyword">if</span> (device_code == KERN_SUCCESS &amp;&amp; bytes_written != vsa-&gt;vsa_size) {
		device_code = KERN_FAILURE;
	}

	vsa-&gt;vsa_error = device_code;


	ASSERT(vsa-&gt;vsa_vs != VSTRUCT_NULL);
	<span class="enscript-keyword">if</span>(vsa-&gt;vsa_flags &amp; VSA_TRANSFER) {
		<span class="enscript-comment">/* revisit when async disk segments redone */</span>
		<span class="enscript-keyword">if</span>(vsa-&gt;vsa_error) {
		   <span class="enscript-comment">/* need to consider error condition.  re-write data or */</span>
		   <span class="enscript-comment">/* throw it away here. */</span>
		   vm_map_copy_discard((vm_map_copy_t)vsa-&gt;vsa_addr);
		}
		ps_vs_write_complete(vsa-&gt;vsa_vs, vsa-&gt;vsa_offset, 
						vsa-&gt;vsa_size, vsa-&gt;vsa_error);
	} <span class="enscript-keyword">else</span> {
		vs_cl_write_complete(vsa-&gt;vsa_vs, vsa-&gt;vsa_ps, vsa-&gt;vsa_offset,
			     vsa-&gt;vsa_addr, vsa-&gt;vsa_size, TRUE,
			     vsa-&gt;vsa_error);
	}
	VS_FREE_ASYNC(vsa);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t <span class="enscript-function-name">device_write_reply_inband</span>(MACH_PORT_FACE, kern_return_t, io_buf_len_t);
kern_return_t
<span class="enscript-function-name">device_write_reply_inband</span>(
	MACH_PORT_FACE		reply_port,
	kern_return_t		return_code,
	io_buf_len_t		bytes_written)
{
	panic(<span class="enscript-string">&quot;device_write_reply_inband: illegal&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t <span class="enscript-function-name">device_read_reply</span>(MACH_PORT_FACE, kern_return_t, io_buf_ptr_t, mach_msg_type_number_t);
kern_return_t
<span class="enscript-function-name">device_read_reply</span>(
	MACH_PORT_FACE		reply_port,
	kern_return_t		return_code,
	io_buf_ptr_t		data,
	mach_msg_type_number_t	dataCnt)
{
	<span class="enscript-type">struct</span> vs_async	*vsa;
	vsa = (<span class="enscript-type">struct</span> vs_async *)
		((<span class="enscript-type">struct</span> vstruct_alias *)(reply_port-&gt;defpager_importance.alias))-&gt;vs;
	vsa-&gt;vsa_addr = (vm_offset_t)data;
	vsa-&gt;vsa_size = (vm_size_t)dataCnt;
	vsa-&gt;vsa_error = return_code;
	thread_wakeup(&amp;vsa);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t <span class="enscript-function-name">device_read_reply_inband</span>(MACH_PORT_FACE, kern_return_t, io_buf_ptr_inband_t, mach_msg_type_number_t);
kern_return_t
<span class="enscript-function-name">device_read_reply_inband</span>(
	MACH_PORT_FACE		reply_port,
	kern_return_t		return_code,
	io_buf_ptr_inband_t	data,
	mach_msg_type_number_t	dataCnt)
{
	panic(<span class="enscript-string">&quot;device_read_reply_inband: illegal&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t <span class="enscript-function-name">device_read_reply_overwrite</span>(MACH_PORT_FACE, kern_return_t, io_buf_len_t);
kern_return_t
<span class="enscript-function-name">device_read_reply_overwrite</span>(
	MACH_PORT_FACE		reply_port,
	kern_return_t		return_code,
	io_buf_len_t		bytes_read)
{
	panic(<span class="enscript-string">&quot;device_read_reply_overwrite: illegal\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t <span class="enscript-function-name">device_open_reply</span>(MACH_PORT_FACE, kern_return_t, MACH_PORT_FACE);
kern_return_t
<span class="enscript-function-name">device_open_reply</span>(
	MACH_PORT_FACE		reply_port,
	kern_return_t		return_code,
	MACH_PORT_FACE		device_port)
{
	panic(<span class="enscript-string">&quot;device_open_reply: illegal\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">ps_read_device</span>(
	paging_segment_t	ps,
	dp_offset_t		offset,
	vm_offset_t		*bufferp,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*residualp,
	<span class="enscript-type">int</span> 			flags)
{
	kern_return_t	kr;
	recnum_t	dev_offset;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bytes_wanted;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bytes_read;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	total_read;
	vm_offset_t	dev_buffer;
	vm_offset_t	buf_ptr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	records_read;
	<span class="enscript-type">struct</span> vs_async *vsa;	

	device_t	device;
	vm_map_copy_t	device_data = NULL;
	default_pager_thread_t *dpt = NULL;

	device = dev_port_lookup(ps-&gt;ps_device);
	clustered_reads[atop_32(size)]++;

	dev_offset = (ps-&gt;ps_offset +
		      (offset &gt;&gt; (vm_page_shift - ps-&gt;ps_record_shift)));
	bytes_wanted = size;
	total_read = 0;
	*bufferp = (vm_offset_t)NULL;
	
	<span class="enscript-keyword">do</span> {
		vsa = VS_ALLOC_ASYNC();
		<span class="enscript-keyword">if</span> (vsa) {
			vsa-&gt;vsa_vs = NULL;
			vsa-&gt;vsa_addr = 0;
			vsa-&gt;vsa_offset = 0;
			vsa-&gt;vsa_size = 0;
			vsa-&gt;vsa_ps = NULL;
		}
		ip_lock(vsa-&gt;reply_port);
		vsa-&gt;reply_port-&gt;ip_sorights++;
		ip_reference(vsa-&gt;reply_port);
		ip_unlock(vsa-&gt;reply_port);
		kr = ds_device_read_common(device,
				 vsa-&gt;reply_port,
			         (mach_msg_type_name_t) 
					MACH_MSG_TYPE_MOVE_SEND_ONCE,
				 (dev_mode_t) 0,
				 dev_offset,
				 bytes_wanted,
				 (IO_READ | IO_CALL),
				 (io_buf_ptr_t *) &amp;dev_buffer,
				 (mach_msg_type_number_t *) &amp;bytes_read);
		<span class="enscript-keyword">if</span>(kr == MIG_NO_REPLY) { 
			assert_wait(&amp;vsa, THREAD_UNINT);
			thread_block(THREAD_CONTINUE_NULL);

			dev_buffer = vsa-&gt;vsa_addr;
			bytes_read = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vsa-&gt;vsa_size;
			kr = vsa-&gt;vsa_error;
		} 
		VS_FREE_ASYNC(vsa);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS || bytes_read == 0) {
			<span class="enscript-keyword">break</span>;
		}
		total_read += bytes_read;

		<span class="enscript-comment">/*
		 * If we got the entire range, use the returned dev_buffer.
		 */</span>
		<span class="enscript-keyword">if</span> (bytes_read == size) {
			*bufferp = (vm_offset_t)dev_buffer;
			<span class="enscript-keyword">break</span>;
		}

#<span class="enscript-reference">if</span> 1
		dprintf((<span class="enscript-string">&quot;read only %d bytes out of %d\n&quot;</span>,
			 bytes_read, bytes_wanted));
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span>(dpt == NULL) {
			dpt = get_read_buffer();
			buf_ptr = dpt-&gt;dpt_buffer;
			*bufferp = (vm_offset_t)buf_ptr;
		}
		<span class="enscript-comment">/*
		 * Otherwise, copy the data into the provided buffer (*bufferp)
		 * and append the rest of the range as it comes in.
		 */</span>
		memcpy((<span class="enscript-type">void</span> *) buf_ptr, (<span class="enscript-type">void</span> *) dev_buffer, bytes_read);
		buf_ptr += bytes_read;
		bytes_wanted -= bytes_read;
		records_read = (bytes_read &gt;&gt;
				(vm_page_shift - ps-&gt;ps_record_shift));
		dev_offset += records_read;
		DP_DEBUG(DEBUG_VS_INTERNAL,
			 (<span class="enscript-string">&quot;calling vm_deallocate(addr=0x%X,size=0x%X)\n&quot;</span>,
			  dev_buffer, bytes_read));
		<span class="enscript-keyword">if</span> (vm_deallocate(kernel_map, dev_buffer, bytes_read)
		    != KERN_SUCCESS)
			Panic(<span class="enscript-string">&quot;dealloc buf&quot;</span>);
	} <span class="enscript-keyword">while</span> (bytes_wanted);

	*residualp = size - total_read;
	<span class="enscript-keyword">if</span>((dev_buffer != *bufferp) &amp;&amp; (total_read != 0)) {
		vm_offset_t temp_buffer;
		vm_allocate(kernel_map, &amp;temp_buffer, total_read, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_OSFMK));
		memcpy((<span class="enscript-type">void</span> *) temp_buffer, (<span class="enscript-type">void</span> *) *bufferp, total_read);
		<span class="enscript-keyword">if</span>(vm_map_copyin_page_list(kernel_map, temp_buffer, total_read, 
			VM_MAP_COPYIN_OPT_SRC_DESTROY | 
			VM_MAP_COPYIN_OPT_STEAL_PAGES | 
			VM_MAP_COPYIN_OPT_PMAP_ENTER,
			(vm_map_copy_t *)&amp;device_data, FALSE))
				panic(<span class="enscript-string">&quot;ps_read_device: cannot copyin locally provided buffer\n&quot;</span>);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>((kr == KERN_SUCCESS) &amp;&amp; (total_read != 0) &amp;&amp; (dev_buffer != 0)){
		<span class="enscript-keyword">if</span>(vm_map_copyin_page_list(kernel_map, dev_buffer, bytes_read, 
			VM_MAP_COPYIN_OPT_SRC_DESTROY | 
			VM_MAP_COPYIN_OPT_STEAL_PAGES | 
			VM_MAP_COPYIN_OPT_PMAP_ENTER,
			(vm_map_copy_t *)&amp;device_data, FALSE))
				panic(<span class="enscript-string">&quot;ps_read_device: cannot copyin backing store provided buffer\n&quot;</span>);
	}
	<span class="enscript-keyword">else</span> {
		device_data = NULL;
	}
	*bufferp = (vm_offset_t)device_data;

	<span class="enscript-keyword">if</span>(dpt != NULL) {
		<span class="enscript-comment">/* Free the receive buffer */</span>
		dpt-&gt;checked_out = 0;	
		thread_wakeup(&amp;dpt_array);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">ps_write_device</span>(
	paging_segment_t	ps,
	dp_offset_t		offset,
	vm_offset_t		addr,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size,
	<span class="enscript-type">struct</span> vs_async		*vsa)
{
	recnum_t	dev_offset;
	io_buf_len_t	bytes_to_write, bytes_written;
	recnum_t	records_written;
	kern_return_t	kr;
	MACH_PORT_FACE	reply_port;



	clustered_writes[atop_32(size)]++;

	dev_offset = (ps-&gt;ps_offset +
		      (offset &gt;&gt; (vm_page_shift - ps-&gt;ps_record_shift)));
	bytes_to_write = size;

	<span class="enscript-keyword">if</span> (vsa) {
		<span class="enscript-comment">/*
		 * Asynchronous write.
		 */</span>
		reply_port = vsa-&gt;reply_port;
		ip_lock(reply_port);
		reply_port-&gt;ip_sorights++;
		ip_reference(reply_port);
		ip_unlock(reply_port);
		{
		device_t	device;
		device = dev_port_lookup(ps-&gt;ps_device);

		vsa-&gt;vsa_addr = addr;
		kr=ds_device_write_common(device,
			reply_port,
			(mach_msg_type_name_t) MACH_MSG_TYPE_MOVE_SEND_ONCE,
			(dev_mode_t) 0,
			dev_offset,
			(io_buf_ptr_t)	addr,
			size, 
			(IO_WRITE | IO_CALL),
			&amp;bytes_written);
		}
		<span class="enscript-keyword">if</span> ((kr != KERN_SUCCESS) &amp;&amp; (kr != MIG_NO_REPLY)) {
			<span class="enscript-keyword">if</span> (verbose) 
				dprintf((<span class="enscript-string">&quot;%s0x%x, addr=0x%x,&quot;</span>
					 <span class="enscript-string">&quot;size=0x%x,offset=0x%x\n&quot;</span>,
					 <span class="enscript-string">&quot;device_write_request returned &quot;</span>,
					 kr, addr, size, offset));
			BS_STAT(ps-&gt;ps_bs,
				ps-&gt;ps_bs-&gt;bs_pages_out_fail += atop_32(size));
			<span class="enscript-comment">/* do the completion notification to free resources */</span>
			device_write_reply(reply_port, kr, 0);
			<span class="enscript-keyword">return</span> PAGER_ERROR;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {
		<span class="enscript-comment">/*
		 * Synchronous write.
		 */</span>
		{
		device_t	device;
		device = dev_port_lookup(ps-&gt;ps_device);
		kr=ds_device_write_common(device,
			IP_NULL, 0,
			(dev_mode_t) 0,
			dev_offset,
			(io_buf_ptr_t)	addr,
			size, 
			(IO_WRITE | IO_SYNC | IO_KERNEL_BUF),
			&amp;bytes_written);
		}
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			dprintf((<span class="enscript-string">&quot;%s0x%x, addr=0x%x,size=0x%x,offset=0x%x\n&quot;</span>,
				 <span class="enscript-string">&quot;device_write returned &quot;</span>,
				 kr, addr, size, offset));
			BS_STAT(ps-&gt;ps_bs,
				ps-&gt;ps_bs-&gt;bs_pages_out_fail += atop_32(size));
			<span class="enscript-keyword">return</span> PAGER_ERROR;
		}
		<span class="enscript-keyword">if</span> (bytes_written &amp; ((vm_page_size &gt;&gt; ps-&gt;ps_record_shift) - 1))
			Panic(<span class="enscript-string">&quot;fragmented write&quot;</span>);
		records_written = (bytes_written &gt;&gt;
				   (vm_page_shift - ps-&gt;ps_record_shift));
		dev_offset += records_written;
#<span class="enscript-reference">if</span> 1
		<span class="enscript-keyword">if</span> (bytes_written != bytes_to_write) {
			dprintf((<span class="enscript-string">&quot;wrote only %d bytes out of %d\n&quot;</span>,
				 bytes_written, bytes_to_write));
		}
#<span class="enscript-reference">endif</span>
		bytes_to_write -= bytes_written;
		addr += bytes_written;
	} <span class="enscript-keyword">while</span> (bytes_to_write &gt; 0);

	<span class="enscript-keyword">return</span> PAGER_SUCCESS;
}


#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !DEVICE_PAGING */</span>

kern_return_t
<span class="enscript-function-name">ps_read_device</span>(
	__unused paging_segment_t	ps,
	__unused dp_offset_t		offset,
	__unused vm_offset_t		*bufferp,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*residualp,
	__unused <span class="enscript-type">int</span> 				flags)
{
  panic(<span class="enscript-string">&quot;ps_read_device not supported&quot;</span>);
  <span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">ps_write_device</span>(
	__unused paging_segment_t	ps,
	__unused dp_offset_t		offset,
	__unused vm_offset_t		addr,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size,
	__unused <span class="enscript-type">struct</span> vs_async	*vsa)
{
  panic(<span class="enscript-string">&quot;ps_write_device not supported&quot;</span>);
  <span class="enscript-keyword">return</span> KERN_FAILURE;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVICE_PAGING */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">pvs_object_data_provided</span>(vstruct_t, upl_t, upl_offset_t, upl_size_t);	<span class="enscript-comment">/* forward */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">pvs_object_data_provided</span>(
	__unused vstruct_t		vs,
	__unused upl_t			upl,
	__unused upl_offset_t	offset,
	upl_size_t				size)
{
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">RECLAIM_SWAP</span>
	boolean_t	empty;
#<span class="enscript-reference">endif</span>

	DP_DEBUG(DEBUG_VS_INTERNAL,
		 (<span class="enscript-string">&quot;buffer=0x%x,offset=0x%x,size=0x%x\n&quot;</span>,
		  upl, offset, size));

	ASSERT(size &gt; 0);
	GSTAT(global_stats.gs_pages_in += atop_32(size));

<span class="enscript-comment">/* check upl iosync flag instead of using RECLAIM_SWAP*/</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">RECLAIM_SWAP</span>
	<span class="enscript-keyword">if</span> (size != upl-&gt;size) {
		<span class="enscript-keyword">if</span> (size) {
			ps_clunmap(vs, offset, size);
			upl_commit_range(upl, 0, size, 0, NULL, 0, &amp;empty);
		}
		upl_abort(upl, UPL_ABORT_ERROR);
		upl_deallocate(upl);
	} <span class="enscript-keyword">else</span> {
		ps_clunmap(vs, offset, size);
		upl_commit(upl, NULL, 0);
		upl_deallocate(upl);
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* RECLAIM_SWAP */</span>

}

<span class="enscript-type">static</span> memory_object_offset_t   last_start;
<span class="enscript-type">static</span> vm_size_t		last_length;

<span class="enscript-comment">/*
 * A &quot;cnt&quot; of 0 means that the caller just wants to check if the page at
 * offset &quot;vs_offset&quot; exists in the backing store.  That page hasn't been
 * prepared, so no need to release it.
 *
 * A &quot;cnt&quot; of -1 means that the caller wants to bring back from the backing
 * store all existing pages in the cluster containing &quot;vs_offset&quot;.
 */</span>
kern_return_t
<span class="enscript-function-name">pvs_cluster_read</span>(
	vstruct_t	vs,
	dp_offset_t	vs_offset,
	dp_size_t	cnt,
        <span class="enscript-type">void</span>		*fault_info)
{
	kern_return_t		error = KERN_SUCCESS;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		residual;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		request_flags;
	<span class="enscript-type">int</span>			io_flags = 0;
	<span class="enscript-type">int</span>			seg_index;
	<span class="enscript-type">int</span>			pages_in_cl;
	<span class="enscript-type">int</span>	                cl_size;
	<span class="enscript-type">int</span>	                cl_mask;
	<span class="enscript-type">int</span>			cl_index;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		xfer_size;
	dp_offset_t		orig_vs_offset;
	dp_offset_t		ps_offset[(VM_SUPER_CLUSTER / PAGE_SIZE) &gt;&gt; VSTRUCT_MIN_CLSHIFT];
	paging_segment_t        psp[(VM_SUPER_CLUSTER / PAGE_SIZE) &gt;&gt; VSTRUCT_MIN_CLSHIFT];
	<span class="enscript-type">struct</span> clmap		clmap;
	upl_t			upl;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		page_list_count;
	memory_object_offset_t	cluster_start;
	vm_size_t		cluster_length;
	uint32_t		io_streaming;
	<span class="enscript-type">int</span>			i;
	boolean_t		io_sync = FALSE;
	boolean_t		reclaim_all = FALSE;

	pages_in_cl = 1 &lt;&lt; vs-&gt;vs_clshift;
	cl_size = pages_in_cl * vm_page_size;
	cl_mask = cl_size - 1;

	request_flags = UPL_NO_SYNC | UPL_RET_ONLY_ABSENT | UPL_SET_LITE;
	
	<span class="enscript-keyword">if</span> (cnt == (dp_size_t) -1)
		reclaim_all = TRUE;

	<span class="enscript-keyword">if</span> (reclaim_all == TRUE) {
		<span class="enscript-comment">/*
		 * We've been called from ps_vstruct_reclaim() to move all
		 * the object's swapped pages back to VM pages.
		 * This can put memory pressure on the system, so we do want
		 * to wait for free pages, to avoid getting in the way of the
		 * vm_pageout_scan() thread.
		 * Let's not use UPL_NOBLOCK in this case.
		 */</span>
		vs_offset &amp;= ~cl_mask;
		i = pages_in_cl;
	} <span class="enscript-keyword">else</span> {
		i = 1;

		<span class="enscript-comment">/*
		 * if the I/O cluster size == PAGE_SIZE, we don't want to set
		 * the UPL_NOBLOCK since we may be trying to recover from a
		 * previous partial pagein I/O that occurred because we were low
		 * on memory and bailed early in order to honor the UPL_NOBLOCK...
		 * since we're only asking for a single page, we can block w/o fear
		 * of tying up pages while waiting for more to become available
		 */</span>
		<span class="enscript-keyword">if</span> (fault_info == NULL || ((vm_object_fault_info_t)fault_info)-&gt;cluster_size &gt; PAGE_SIZE)
			request_flags |= UPL_NOBLOCK;
	}

<span class="enscript-reference">again</span>:
	cl_index = (vs_offset &amp; cl_mask) / vm_page_size;

        <span class="enscript-keyword">if</span> ((ps_clmap(vs, vs_offset &amp; ~cl_mask, &amp;clmap, CL_FIND, 0, 0) == (dp_offset_t)-1) ||
	    !CLMAP_ISSET(clmap, cl_index)) {
	        <span class="enscript-comment">/*
		 * the needed page doesn't exist in the backing store...
		 * we don't want to try to do any I/O, just abort the
		 * page and let the fault handler provide a zero-fill
		 */</span>
		<span class="enscript-keyword">if</span> (cnt == 0) {
			<span class="enscript-comment">/*
			 * The caller was just poking at us to see if
			 * the page has been paged out.  No need to 
			 * mess with the page at all.
			 * Just let the caller know we don't have that page.
			 */</span>
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
		<span class="enscript-keyword">if</span> (reclaim_all == TRUE) {
			i--;
			<span class="enscript-keyword">if</span> (i == 0) {
				<span class="enscript-comment">/* no more pages in this cluster */</span>
				<span class="enscript-keyword">return</span> KERN_FAILURE;
			}
			<span class="enscript-comment">/* try the next page in this cluster */</span>
			vs_offset += vm_page_size;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}

		page_list_count = 0;

		memory_object_super_upl_request(vs-&gt;vs_control,	(memory_object_offset_t)vs_offset,
						PAGE_SIZE, PAGE_SIZE, 
						&amp;upl, NULL, &amp;page_list_count,
						request_flags  | UPL_SET_INTERNAL);
		upl_range_needed(upl, 0, 1);

		<span class="enscript-keyword">if</span> (clmap.cl_error)
		        upl_abort(upl, UPL_ABORT_ERROR);
		<span class="enscript-keyword">else</span>
		        upl_abort(upl, UPL_ABORT_UNAVAILABLE);
		upl_deallocate(upl);

		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">if</span> (cnt == 0) {
		<span class="enscript-comment">/*
		 * The caller was just poking at us to see if
		 * the page has been paged out.  No need to 
		 * mess with the page at all.
		 * Just let the caller know we do have that page.
		 */</span>
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	
	<span class="enscript-keyword">if</span>(((vm_object_fault_info_t)fault_info)-&gt;io_sync == TRUE ) {
		io_sync = TRUE;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RECLAIM_SWAP</span>
		io_sync = TRUE;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* RECLAIM_SWAP */</span>
	}

	<span class="enscript-keyword">if</span>( io_sync == TRUE ) {

		io_flags |= UPL_IOSYNC | UPL_NOCOMMIT;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">USE_PRECIOUS</span>
		request_flags |= UPL_PRECIOUS | UPL_CLEAN_IN_PLACE;
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* USE_PRECIOUS */</span>
		request_flags |= UPL_REQUEST_SET_DIRTY;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USE_PRECIOUS */</span>
	}

	assert(dp_encryption_inited);
	<span class="enscript-keyword">if</span> (dp_encryption) {
		<span class="enscript-comment">/*
		 * ENCRYPTED SWAP:
		 * request that the UPL be prepared for
		 * decryption.
		 */</span>
		request_flags |= UPL_ENCRYPT;
		io_flags |= UPL_PAGING_ENCRYPTED;
	}
	orig_vs_offset = vs_offset;

	assert(cnt != 0);
	cnt = VM_SUPER_CLUSTER;
	cluster_start = (memory_object_offset_t) vs_offset;
	cluster_length = (vm_size_t) cnt;
	io_streaming = 0;

	<span class="enscript-comment">/*
	 * determine how big a speculative I/O we should try for...
	 */</span>
	<span class="enscript-keyword">if</span> (memory_object_cluster_size(vs-&gt;vs_control, &amp;cluster_start, &amp;cluster_length, &amp;io_streaming, (memory_object_fault_info_t)fault_info) == KERN_SUCCESS) {
		assert(vs_offset &gt;= (dp_offset_t) cluster_start &amp;&amp;
		       vs_offset &lt; (dp_offset_t) (cluster_start + cluster_length));
	        vs_offset = (dp_offset_t) cluster_start;
		cnt = (dp_size_t) cluster_length;
	} <span class="enscript-keyword">else</span> {
		cluster_length = PAGE_SIZE;
	        cnt = PAGE_SIZE;
	}

	<span class="enscript-keyword">if</span> (io_streaming)
                io_flags |= UPL_IOSTREAMING;

	last_start = cluster_start;
	last_length = cluster_length;

	<span class="enscript-comment">/*
	 * This loop will be executed multiple times until the entire
	 * range has been looked at or we issue an I/O... if the request spans cluster
	 * boundaries, the clusters will be checked for logical continunity,
	 * if contiguous the I/O request will span multiple clusters...
	 * at most only 1 I/O will be issued... it will encompass the original offset
	 */</span>
	<span class="enscript-keyword">while</span> (cnt &amp;&amp; error == KERN_SUCCESS) {
	        <span class="enscript-type">int</span>     ps_info_valid;

		<span class="enscript-keyword">if</span> ((vs_offset &amp; cl_mask) &amp;&amp; (cnt &gt; (VM_SUPER_CLUSTER - (vs_offset &amp; cl_mask)))) {
			size = VM_SUPER_CLUSTER;
			size -= vs_offset &amp; cl_mask;
	        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cnt &gt; VM_SUPER_CLUSTER)
		        size = VM_SUPER_CLUSTER;
		<span class="enscript-keyword">else</span>
		        size = cnt;

		cnt -= size;

		ps_info_valid = 0;
		seg_index     = 0;

		<span class="enscript-keyword">while</span> (size &gt; 0 &amp;&amp; error == KERN_SUCCESS) {
		        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  abort_size;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  lsize;
			<span class="enscript-type">int</span>           failed_size;
			<span class="enscript-type">int</span>           beg_pseg;
			<span class="enscript-type">int</span>           beg_indx;
			dp_offset_t   cur_offset;

			<span class="enscript-keyword">if</span> ( !ps_info_valid) {
			        ps_offset[seg_index] = ps_clmap(vs, vs_offset &amp; ~cl_mask, &amp;clmap, CL_FIND, 0, 0);
				psp[seg_index]       = CLMAP_PS(clmap);
				ps_info_valid = 1;
			}
		        <span class="enscript-comment">/*
			 * skip over unallocated physical segments 
			 */</span>
			<span class="enscript-keyword">if</span> (ps_offset[seg_index] == (dp_offset_t) -1) {
				abort_size = cl_size - (vs_offset &amp; cl_mask);
				abort_size = MIN(abort_size, size);

				size      -= abort_size;
				vs_offset += abort_size;

				seg_index++;
				ps_info_valid = 0;

				<span class="enscript-keyword">continue</span>;
			}
			cl_index = (vs_offset &amp; cl_mask) / vm_page_size;

			<span class="enscript-keyword">for</span> (abort_size = 0; cl_index &lt; pages_in_cl &amp;&amp; abort_size &lt; size; cl_index++) {
			        <span class="enscript-comment">/*
				 * skip over unallocated pages
				 */</span>
			        <span class="enscript-keyword">if</span> (CLMAP_ISSET(clmap, cl_index))
				        <span class="enscript-keyword">break</span>;
				abort_size += vm_page_size;
			}
			<span class="enscript-keyword">if</span> (abort_size) {
				size      -= abort_size;
				vs_offset += abort_size;

				<span class="enscript-keyword">if</span> (cl_index == pages_in_cl) {
				        <span class="enscript-comment">/*
					 * if we're at the end of this physical cluster
					 * then bump to the next one and continue looking
					 */</span>
				        seg_index++;
					ps_info_valid = 0;

					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (size == 0)
				        <span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * remember the starting point of the first allocated page 
			 * for the I/O we're about to issue
			 */</span>
			beg_pseg   = seg_index;
			beg_indx   = cl_index;
			cur_offset = vs_offset;

			<span class="enscript-comment">/*
			 * calculate the size of the I/O that we can do...
			 * this may span multiple physical segments if
			 * they are contiguous
			 */</span>
			<span class="enscript-keyword">for</span> (xfer_size = 0; xfer_size &lt; size; ) {

			        <span class="enscript-keyword">while</span> (cl_index &lt; pages_in_cl &amp;&amp; xfer_size &lt; size) {
				        <span class="enscript-comment">/*
					 * accumulate allocated pages within 
					 * a physical segment
					 */</span>
				        <span class="enscript-keyword">if</span> (CLMAP_ISSET(clmap, cl_index)) {
					        xfer_size  += vm_page_size;
						cur_offset += vm_page_size;
						cl_index++;

						BS_STAT(psp[seg_index]-&gt;ps_bs,
							psp[seg_index]-&gt;ps_bs-&gt;bs_pages_in++);
					} <span class="enscript-keyword">else</span>
					        <span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">if</span> (cl_index &lt; pages_in_cl || xfer_size &gt;= size) {
				        <span class="enscript-comment">/*
					 * we've hit an unallocated page or 
					 * the end of this request... see if
					 * it's time to fire the I/O
					 */</span>
				        <span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">/*
				 * we've hit the end of the current physical
				 * segment and there's more to do, so try 
				 * moving to the next one
				 */</span>
				seg_index++;
				  
				ps_offset[seg_index] = ps_clmap(vs, cur_offset &amp; ~cl_mask, &amp;clmap, CL_FIND, 0, 0);
				psp[seg_index] = CLMAP_PS(clmap);
				ps_info_valid = 1;

				<span class="enscript-keyword">if</span> ((ps_offset[seg_index - 1] != (ps_offset[seg_index] - cl_size)) || (psp[seg_index - 1] != psp[seg_index])) {
				        <span class="enscript-comment">/*
					 * if the physical segment we're about 
					 * to step into is not contiguous to 
					 * the one we're currently in, or it's 
					 * in a different paging file, or
					 * it hasn't been allocated....
					 * we stop this run and go check
					 * to see if it's time to fire the I/O
					 */</span>
				        <span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">/*
				 * start with first page of the next physical
				 * segment
				 */</span>
				cl_index = 0;
			}
			<span class="enscript-keyword">if</span> (xfer_size == 0) {
			        <span class="enscript-comment">/*
				 * no I/O to generate for this segment
				 */</span>
			        <span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (cur_offset &lt;= orig_vs_offset) {
			        <span class="enscript-comment">/*
				 * we've hit a hole in our speculative cluster
				 * before the offset that we're really after...
				 * don't issue the I/O since it doesn't encompass
				 * the original offset and we're looking to only
				 * pull in the speculative pages if they can be
				 * made part of a single I/O
				 */</span>
			        size      -= xfer_size;
				vs_offset += xfer_size;

				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/*
			 * we have a contiguous range of allocated pages
			 * to read from that encompasses the original offset
			 */</span>
			page_list_count = 0;
			memory_object_super_upl_request(vs-&gt;vs_control, (memory_object_offset_t)vs_offset,
							xfer_size, xfer_size, 
							&amp;upl, NULL, &amp;page_list_count,
							request_flags | UPL_SET_INTERNAL);

			error = ps_read_file(psp[beg_pseg], 
					     upl, (upl_offset_t) 0, 
					     ps_offset[beg_pseg] + (beg_indx * vm_page_size), 
					     xfer_size, &amp;residual, io_flags);


			<span class="enscript-comment">/*
			 * Adjust counts and send response to VM.  Optimize 
			 * for the common case, i.e. no error and/or partial
			 * data. If there was an error, then we need to error
			 * the entire range, even if some data was successfully
			 * read. If there was a partial read we may supply some
			 * data and may error some as well.  In all cases the
			 * VM must receive some notification for every page 
			 * in the range.
			 */</span>
			<span class="enscript-keyword">if</span> ((error == KERN_SUCCESS) &amp;&amp; (residual == 0)) {
			        <span class="enscript-comment">/*
				 * Got everything we asked for, supply the data
				 * to the VM.  Note that as a side effect of 
				 * supplying the data, the buffer holding the 
				 * supplied data is deallocated from the pager's
				 *  address space.
				 */</span>
				lsize = xfer_size;
				failed_size = 0;
			} <span class="enscript-keyword">else</span> {
				lsize = 0;
			        failed_size = xfer_size;

				<span class="enscript-keyword">if</span> (error == KERN_SUCCESS) {
				        <span class="enscript-keyword">if</span> (residual == xfer_size) {
					        <span class="enscript-comment">/*
						 * If a read operation returns no error
						 * and no data moved, we turn it into
						 * an error, assuming we're reading at
						 * or beyong EOF.
						 * Fall through and error the entire range.
						 */</span>
					        error = KERN_FAILURE;
					} <span class="enscript-keyword">else</span> {
					        <span class="enscript-comment">/*
						 * Otherwise, we have partial read. If
						 * the part read is a integral number
						 * of pages supply it. Otherwise round
						 * it up to a page boundary, zero fill
						 * the unread part, and supply it.
						 * Fall through and error the remainder
						 * of the range, if any.
						 */</span>
					        <span class="enscript-type">int</span> fill;

						fill = residual &amp; (vm_page_size - 1);
						lsize = (xfer_size - residual) + fill;

						<span class="enscript-keyword">if</span> (lsize &lt; xfer_size)
						        failed_size = xfer_size - lsize;

						<span class="enscript-keyword">if</span> (reclaim_all == FALSE)
							error = KERN_FAILURE;
					}
				} 
			}
			pvs_object_data_provided(vs, upl, vs_offset, lsize);

			<span class="enscript-keyword">if</span> (failed_size) {
			        <span class="enscript-comment">/*
				 * There was an error in some part of the range, tell
				 * the VM. Note that error is explicitly checked again
				 * since it can be modified above.
				 */</span>
				BS_STAT(psp[beg_pseg]-&gt;ps_bs,
					psp[beg_pseg]-&gt;ps_bs-&gt;bs_pages_in_fail += atop_32(failed_size));
			}
			<span class="enscript-comment">/*
			 * we've issued a single I/O that encompassed the original offset
			 * at this point we either met our speculative request length or 
			 * we ran into a 'hole' (i.e. page not present in the cluster, cluster
			 * not present or not physically contiguous to the previous one), so
			 * we're done issuing I/O at this point
			 */</span>
			<span class="enscript-keyword">return</span> (error);
		}
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span> vs_do_async_write = 1;

kern_return_t
<span class="enscript-function-name">vs_cluster_write</span>(
	vstruct_t	vs,
	upl_t		internal_upl,
	upl_offset_t	offset,
	upl_size_t	cnt,
	boolean_t	dp_internal,
	<span class="enscript-type">int</span> 		flags)
{
	upl_size_t	transfer_size;
	<span class="enscript-type">int</span>		error = 0;
	<span class="enscript-type">struct</span> clmap	clmap;

	dp_offset_t	actual_offset;	<span class="enscript-comment">/* Offset within paging segment */</span>
	paging_segment_t ps;
	dp_offset_t	mobj_base_addr;
	dp_offset_t	mobj_target_addr;

	upl_t		upl;
	upl_page_info_t *pl;
	<span class="enscript-type">int</span>		page_index;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	page_max_index;
	<span class="enscript-type">int</span>		list_size;
	<span class="enscript-type">int</span>		pages_in_cl;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	cl_size;
	<span class="enscript-type">int</span>             base_index;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	seg_size;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	upl_offset_in_object;
	boolean_t	minimal_clustering = FALSE;
	boolean_t	found_dirty;

	<span class="enscript-keyword">if</span> (!dp_encryption_inited) {
		<span class="enscript-comment">/*
		 * ENCRYPTED SWAP:
		 * Once we've started using swap, we
		 * can't change our mind on whether
		 * it needs to be encrypted or
		 * not.
		 */</span>
		dp_encryption_inited = TRUE;
	}
	<span class="enscript-keyword">if</span> (dp_encryption) {
		<span class="enscript-comment">/*
		 * ENCRYPTED SWAP:
		 * the UPL will need to be encrypted...
		 */</span>
		flags |= UPL_PAGING_ENCRYPTED;
	}

	pages_in_cl = 1 &lt;&lt; vs-&gt;vs_clshift;
	cl_size = pages_in_cl * vm_page_size;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	minimal_clustering = TRUE;
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (dp_isssd == TRUE)
		minimal_clustering = TRUE;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (!dp_internal) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> page_list_count;
		<span class="enscript-type">int</span>	     request_flags;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> super_size;
		<span class="enscript-type">int</span>          first_dirty;
		<span class="enscript-type">int</span>          num_dirty;
		<span class="enscript-type">int</span>          num_of_pages;
		<span class="enscript-type">int</span>          seg_index;
		upl_offset_t  upl_offset;
		upl_offset_t  upl_offset_aligned;
		dp_offset_t  seg_offset;
		dp_offset_t  ps_offset[((VM_SUPER_CLUSTER / PAGE_SIZE) &gt;&gt; VSTRUCT_MIN_CLSHIFT) + 1];
		paging_segment_t   psp[((VM_SUPER_CLUSTER / PAGE_SIZE) &gt;&gt; VSTRUCT_MIN_CLSHIFT) + 1];


		<span class="enscript-keyword">if</span> (bs_low)
			super_size = cl_size;
		<span class="enscript-keyword">else</span>
			super_size = VM_SUPER_CLUSTER;

		request_flags = UPL_NOBLOCK | UPL_CLEAN_IN_PLACE |
			        UPL_RET_ONLY_DIRTY | UPL_COPYOUT_FROM | 
				UPL_NO_SYNC | UPL_SET_INTERNAL | UPL_SET_LITE;

		<span class="enscript-keyword">if</span> (dp_encryption) {
			<span class="enscript-comment">/*
			 * ENCRYPTED SWAP:
			 * request that the UPL be prepared for
			 * encryption.
			 */</span>
			request_flags |= UPL_ENCRYPT;
			flags |= UPL_PAGING_ENCRYPTED;
		}

		page_list_count = 0;
		memory_object_super_upl_request(vs-&gt;vs_control,
				(memory_object_offset_t)offset,
				cnt, super_size, 
				&amp;upl, NULL, &amp;page_list_count,
				request_flags | UPL_FOR_PAGEOUT);

		<span class="enscript-comment">/*
		 * The default pager does not handle objects larger than
		 * 4GB, so it does not deal with offset that don't fit in
		 * 32-bit.  Cast down upl-&gt;offset now and make sure we
		 * did not lose any valuable bits.
		 */</span>
		upl_offset_in_object = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) upl-&gt;offset;
		assert(upl-&gt;offset == upl_offset_in_object);

		pl = UPL_GET_INTERNAL_PAGE_LIST(upl);

		seg_size = cl_size - (upl_offset_in_object % cl_size);
		upl_offset_aligned = upl_offset_in_object &amp; ~(cl_size - 1);
		page_index = 0;
		page_max_index = upl-&gt;size / PAGE_SIZE;
		found_dirty = TRUE;

		<span class="enscript-keyword">for</span> (seg_index = 0, transfer_size = upl-&gt;size; transfer_size &gt; 0; ) {

			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	seg_pgcnt;

			seg_pgcnt = seg_size / PAGE_SIZE;

			<span class="enscript-keyword">if</span> (minimal_clustering == TRUE) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	non_dirty;

				non_dirty = 0;
				found_dirty = FALSE;

				<span class="enscript-keyword">for</span> (; non_dirty &lt; seg_pgcnt; non_dirty++) {
					<span class="enscript-keyword">if</span> ((page_index + non_dirty) &gt;= page_max_index)
						<span class="enscript-keyword">break</span>;

					<span class="enscript-keyword">if</span> (UPL_DIRTY_PAGE(pl, page_index + non_dirty) ||
					    UPL_PRECIOUS_PAGE(pl, page_index + non_dirty)) {
						found_dirty = TRUE;
						<span class="enscript-keyword">break</span>;
					}
				}
			}
			<span class="enscript-keyword">if</span> (found_dirty == TRUE) {
				ps_offset[seg_index] = 
					ps_clmap(vs, 
						 upl_offset_aligned,
						 &amp;clmap, CL_ALLOC, 
						 cl_size, 0); 

				<span class="enscript-keyword">if</span> (ps_offset[seg_index] == (dp_offset_t) -1) {
					upl_abort(upl, 0);
					upl_deallocate(upl);
				
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				}
				psp[seg_index] = CLMAP_PS(clmap);
			}
			<span class="enscript-keyword">if</span> (transfer_size &gt; seg_size) {
				page_index += seg_pgcnt;
			        transfer_size -= seg_size;
				upl_offset_aligned += cl_size;
				seg_size = cl_size;
				seg_index++;
			} <span class="enscript-keyword">else</span>
			        transfer_size = 0;
		}
		<span class="enscript-comment">/*
		 * Ignore any non-present pages at the end of the
		 * UPL.
		 */</span>
		<span class="enscript-keyword">for</span> (page_index = upl-&gt;size / vm_page_size; page_index &gt; 0;)  {
			<span class="enscript-keyword">if</span> (UPL_PAGE_PRESENT(pl, --page_index)) {
				page_index++;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (page_index == 0) {
			<span class="enscript-comment">/*
			 * no pages in the UPL
			 * abort and return
			 */</span>
			upl_abort(upl, 0);
			upl_deallocate(upl);

			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}
		num_of_pages = page_index;

		base_index = (upl_offset_in_object % cl_size) / PAGE_SIZE;

		<span class="enscript-keyword">for</span> (page_index = 0; page_index &lt; num_of_pages; ) {
			<span class="enscript-comment">/*
			 * skip over non-dirty pages
			 */</span>
			<span class="enscript-keyword">for</span> ( ; page_index &lt; num_of_pages; page_index++) {
			        <span class="enscript-keyword">if</span> (UPL_DIRTY_PAGE(pl, page_index) 
					|| UPL_PRECIOUS_PAGE(pl, page_index))
				        <span class="enscript-comment">/*
					 * this is a page we need to write
					 * go see if we can buddy it up with 
					 * others that are contiguous to it
					 */</span>
				        <span class="enscript-keyword">break</span>;
				<span class="enscript-comment">/*
				 * if the page is not-dirty, but present we 
				 * need to commit it...  This is an unusual 
				 * case since we only asked for dirty pages
				 */</span>
				<span class="enscript-keyword">if</span> (UPL_PAGE_PRESENT(pl, page_index)) {
					boolean_t empty = FALSE;
				        upl_commit_range(upl, 
						 page_index * vm_page_size,
						 vm_page_size, 
						 UPL_COMMIT_NOTIFY_EMPTY,
						 pl,
						 page_list_count,
						 &amp;empty);
					<span class="enscript-keyword">if</span> (empty) {
						assert(page_index == 
						       num_of_pages - 1);
						upl_deallocate(upl);
					}
				}
			}
			<span class="enscript-keyword">if</span> (page_index == num_of_pages)
			        <span class="enscript-comment">/*
				 * no more pages to look at, we're out of here
				 */</span>
			        <span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * gather up contiguous dirty pages... we have at 
			 * least 1 * otherwise we would have bailed above
			 * make sure that each physical segment that we step
			 * into is contiguous to the one we're currently in
			 * if it's not, we have to stop and write what we have
			 */</span>
			<span class="enscript-keyword">for</span> (first_dirty = page_index; 
					page_index &lt; num_of_pages; ) {
				<span class="enscript-keyword">if</span> ( !UPL_DIRTY_PAGE(pl, page_index) 
					&amp;&amp; !UPL_PRECIOUS_PAGE(pl, page_index))
				        <span class="enscript-keyword">break</span>;
				page_index++;
				<span class="enscript-comment">/*
				 * if we just looked at the last page in the UPL
				 * we don't need to check for physical segment
				 * continuity
				 */</span>
				<span class="enscript-keyword">if</span> (page_index &lt; num_of_pages) {
				        <span class="enscript-type">int</span> cur_seg;
				        <span class="enscript-type">int</span> nxt_seg;

				        cur_seg = (base_index + (page_index - 1))/pages_in_cl;
					nxt_seg = (base_index + page_index)/pages_in_cl;

					<span class="enscript-keyword">if</span> (cur_seg != nxt_seg) {
					        <span class="enscript-keyword">if</span> ((ps_offset[cur_seg] != (ps_offset[nxt_seg] - cl_size)) || (psp[cur_seg] != psp[nxt_seg]))
						<span class="enscript-comment">/*
						 * if the segment we're about 
						 * to step into is not 
						 * contiguous to the one we're 
						 * currently in, or it's in a 
						 * different paging file....
						 * we stop here and generate 
						 * the I/O
						 */</span>
						        <span class="enscript-keyword">break</span>;
					}
				}
			}
			num_dirty = page_index - first_dirty;

			<span class="enscript-keyword">if</span> (num_dirty) {
			        upl_offset = first_dirty * vm_page_size;
				transfer_size = num_dirty * vm_page_size;

				<span class="enscript-keyword">while</span> (transfer_size) {

					<span class="enscript-keyword">if</span> ((seg_size = cl_size - 
						((upl_offset_in_object +
						  upl_offset) % cl_size)) 
							&gt; transfer_size)
					        seg_size = transfer_size;

					ps_vs_write_complete(
						vs, 
						(upl_offset_in_object +
						 upl_offset), 
						seg_size, error);

					transfer_size -= seg_size;
					upl_offset += seg_size;
				}
			        upl_offset = first_dirty * vm_page_size;
				transfer_size = num_dirty * vm_page_size;

			        seg_index  = (base_index + first_dirty) / pages_in_cl;
				seg_offset = (upl_offset_in_object + upl_offset) % cl_size;

				error = ps_write_file(psp[seg_index], 
						upl, upl_offset,
						ps_offset[seg_index] 
								+ seg_offset, 
						transfer_size, flags);
			}
		}

	} <span class="enscript-keyword">else</span> {
		assert(cnt &lt;= (<span class="enscript-type">unsigned</span>) (vm_page_size &lt;&lt; vs-&gt;vs_clshift));
		list_size = cnt;

		page_index = 0;
		<span class="enscript-comment">/* The caller provides a mapped_data which is derived  */</span>
		<span class="enscript-comment">/* from a temporary object.  The targeted pages are    */</span>
		<span class="enscript-comment">/* guaranteed to be set at offset 0 in the mapped_data */</span>
		<span class="enscript-comment">/* The actual offset however must still be derived     */</span>
		<span class="enscript-comment">/* from the offset in the vs in question               */</span>
		mobj_base_addr = offset;
		mobj_target_addr = mobj_base_addr;

		<span class="enscript-keyword">for</span> (transfer_size = list_size; transfer_size != 0;) {
			actual_offset = ps_clmap(vs, mobj_target_addr, 
				&amp;clmap, CL_ALLOC, 
				transfer_size &lt; cl_size ? 
					transfer_size : cl_size, 0);
			<span class="enscript-keyword">if</span>(actual_offset == (dp_offset_t) -1) {
				error = 1;
				<span class="enscript-keyword">break</span>;
			}
			cnt = MIN(transfer_size, 
				  (<span class="enscript-type">unsigned</span>) CLMAP_NPGS(clmap) * vm_page_size);
			ps = CLMAP_PS(clmap);
			<span class="enscript-comment">/* Assume that the caller has given us contiguous */</span>
			<span class="enscript-comment">/* pages */</span>
	 	   	<span class="enscript-keyword">if</span>(cnt) {
				ps_vs_write_complete(vs, mobj_target_addr, 
								cnt, error);
				error = ps_write_file(ps, internal_upl,
						0, actual_offset,
						cnt, flags);
				<span class="enscript-keyword">if</span> (error)
				        <span class="enscript-keyword">break</span>;
		   	   }
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		   	actual_offset += cnt;
		   	mobj_target_addr += cnt;
			transfer_size -= cnt;
		   	cnt = 0;

			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span>(error)
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

vm_size_t
<span class="enscript-function-name">ps_vstruct_allocated_size</span>(
	vstruct_t	vs)
{
	<span class="enscript-type">int</span>		num_pages;
	<span class="enscript-type">struct</span> vs_map	*vsmap;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, k;

	num_pages = 0;
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		<span class="enscript-comment">/* loop on indirect maps */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size); i++) {
			vsmap = vs-&gt;vs_imap[i];
			<span class="enscript-keyword">if</span> (vsmap == NULL)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* loop on clusters in this indirect map */</span>
			<span class="enscript-keyword">for</span> (j = 0; j &lt; CLMAP_ENTRIES; j++) {
				<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
				    VSM_ISERR(vsmap[j]))
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-comment">/* loop on pages in this cluster */</span>
				<span class="enscript-keyword">for</span> (k = 0; k &lt; VSCLSIZE(vs); k++) {
					<span class="enscript-keyword">if</span> ((VSM_BMAP(vsmap[j])) &amp; (1 &lt;&lt; k))
						num_pages++;
				}
			}
		}
	} <span class="enscript-keyword">else</span> {
		vsmap = vs-&gt;vs_dmap;
		<span class="enscript-keyword">if</span> (vsmap == NULL)
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-comment">/* loop on clusters in the direct map */</span>
		<span class="enscript-keyword">for</span> (j = 0; j &lt; CLMAP_ENTRIES; j++) {
			<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
			    VSM_ISERR(vsmap[j])) 
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* loop on pages in this cluster */</span>
			<span class="enscript-keyword">for</span> (k = 0; k &lt; VSCLSIZE(vs); k++) {
				<span class="enscript-keyword">if</span> ((VSM_BMAP(vsmap[j])) &amp; (1 &lt;&lt; k))
					num_pages++;
			}
		}
	}

	<span class="enscript-keyword">return</span> ptoa_32(num_pages);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ps_vstruct_allocated_pages</span>(
	vstruct_t		vs,
	default_pager_page_t	*pages,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		pages_size)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	num_pages;
	<span class="enscript-type">struct</span> vs_map	*vsmap;
	dp_offset_t	offset;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, k;

	num_pages = 0;
	offset = 0;
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		<span class="enscript-comment">/* loop on indirect maps */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size); i++) {
			vsmap = vs-&gt;vs_imap[i];
			<span class="enscript-keyword">if</span> (vsmap == NULL) {
				offset += (vm_page_size * CLMAP_ENTRIES *
					   VSCLSIZE(vs));
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* loop on clusters in this indirect map */</span>
			<span class="enscript-keyword">for</span> (j = 0; j &lt; CLMAP_ENTRIES; j++) {
				<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
				    VSM_ISERR(vsmap[j])) {
					offset += vm_page_size * VSCLSIZE(vs);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/* loop on pages in this cluster */</span>
				<span class="enscript-keyword">for</span> (k = 0; k &lt; VSCLSIZE(vs); k++) {
					<span class="enscript-keyword">if</span> ((VSM_BMAP(vsmap[j])) &amp; (1 &lt;&lt; k)) {
						num_pages++;
						<span class="enscript-keyword">if</span> (num_pages &lt; pages_size)
							pages++-&gt;dpp_offset =
								offset;
					}
					offset += vm_page_size;
				}
			}
		}
	} <span class="enscript-keyword">else</span> {
		vsmap = vs-&gt;vs_dmap;
		<span class="enscript-keyword">if</span> (vsmap == NULL)
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-comment">/* loop on clusters in the direct map */</span>
		<span class="enscript-keyword">for</span> (j = 0; j &lt; CLMAP_ENTRIES; j++) {
			<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
			    VSM_ISERR(vsmap[j])) {
				offset += vm_page_size * VSCLSIZE(vs);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* loop on pages in this cluster */</span>
			<span class="enscript-keyword">for</span> (k = 0; k &lt; VSCLSIZE(vs); k++) {
				<span class="enscript-keyword">if</span> ((VSM_BMAP(vsmap[j])) &amp; (1 &lt;&lt; k)) {
					num_pages++;
					<span class="enscript-keyword">if</span> (num_pages &lt; pages_size)
						pages++-&gt;dpp_offset = offset;
				}
				offset += vm_page_size;
			}
		}
	}

	<span class="enscript-keyword">return</span> num_pages;
}


kern_return_t
<span class="enscript-function-name">ps_vstruct_transfer_from_segment</span>(
	vstruct_t	 vs,
	paging_segment_t segment,
	upl_t		 upl)
{
	<span class="enscript-type">struct</span> vs_map	*vsmap;
<span class="enscript-comment">//	struct vs_map	old_vsmap;
</span><span class="enscript-comment">//	struct vs_map	new_vsmap;
</span>	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j;

	VS_LOCK(vs);	<span class="enscript-comment">/* block all work on this vstruct */</span>
			<span class="enscript-comment">/* can't allow the normal multiple write */</span>
			<span class="enscript-comment">/* semantic because writes may conflict */</span>
	vs-&gt;vs_xfer_pending = TRUE;
	vs_wait_for_sync_writers(vs);
	vs_start_write(vs);
	vs_wait_for_readers(vs);
	<span class="enscript-comment">/* we will unlock the vs to allow other writes while transferring */</span>
	<span class="enscript-comment">/* and will be guaranteed of the persistance of the vs struct     */</span>
	<span class="enscript-comment">/* because the caller of  ps_vstruct_transfer_from_segment bumped */</span>
	<span class="enscript-comment">/* vs_async_pending */</span>
	<span class="enscript-comment">/* OK we now have guaranteed no other parties are accessing this */</span>
	<span class="enscript-comment">/* vs.  Now that we are also supporting simple lock versions of  */</span>
	<span class="enscript-comment">/* vs_lock we cannot hold onto VS_LOCK as we may block below.    */</span>
	<span class="enscript-comment">/* our purpose in holding it before was the multiple write case */</span>
	<span class="enscript-comment">/* we now use the boolean xfer_pending to do that.  We can use  */</span>
	<span class="enscript-comment">/* a boolean instead of a count because we have guaranteed single */</span>
	<span class="enscript-comment">/* file access to this code in its caller */</span>
	VS_UNLOCK(vs);
<span class="enscript-reference">vs_changed</span>:
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vsmap_size;
		<span class="enscript-type">int</span>		clmap_off;
		<span class="enscript-comment">/* loop on indirect maps */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size); i++) {
			vsmap = vs-&gt;vs_imap[i];
			<span class="enscript-keyword">if</span> (vsmap == NULL)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* loop on clusters in this indirect map */</span>
			clmap_off = (vm_page_size * CLMAP_ENTRIES *
					   VSCLSIZE(vs) * i);
			<span class="enscript-keyword">if</span>(i+1 == INDIRECT_CLMAP_ENTRIES(vs-&gt;vs_size))
				vsmap_size = vs-&gt;vs_size - (CLMAP_ENTRIES * i);
			<span class="enscript-keyword">else</span>
				vsmap_size = CLMAP_ENTRIES;
			<span class="enscript-keyword">for</span> (j = 0; j &lt; vsmap_size; j++) {
				<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
				    VSM_ISERR(vsmap[j]) ||
				    (VSM_PS(vsmap[j]) != segment))
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span>(vs_cluster_transfer(vs, 
					(vm_page_size * (j &lt;&lt; vs-&gt;vs_clshift))
					+ clmap_off, 
					vm_page_size &lt;&lt; vs-&gt;vs_clshift,
					upl)
						!= KERN_SUCCESS) {
				   VS_LOCK(vs);
				   vs-&gt;vs_xfer_pending = FALSE;
				   VS_UNLOCK(vs);
				   vs_finish_write(vs);
				   <span class="enscript-keyword">return</span> KERN_FAILURE;
				}
				<span class="enscript-comment">/* allow other readers/writers during transfer*/</span>
				VS_LOCK(vs);
				vs-&gt;vs_xfer_pending = FALSE;
				VS_UNLOCK(vs);
				vs_finish_write(vs);

				<span class="enscript-keyword">if</span> (backing_store_abort_compaction || backing_store_stop_compaction) {
					backing_store_abort_compaction = FALSE;
					dprintf((<span class="enscript-string">&quot;ps_vstruct_transfer_from_segment - ABORTED\n&quot;</span>));
					<span class="enscript-keyword">return</span> KERN_FAILURE;
				}
				vnode_pager_throttle();

				VS_LOCK(vs);
				vs-&gt;vs_xfer_pending = TRUE;
				vs_wait_for_sync_writers(vs);
				vs_start_write(vs);
				vs_wait_for_readers(vs);
				VS_UNLOCK(vs);
				<span class="enscript-keyword">if</span> (!(vs-&gt;vs_indirect)) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">vs_changed</span>;
				}
			}
		}
	} <span class="enscript-keyword">else</span> {
		vsmap = vs-&gt;vs_dmap;
		<span class="enscript-keyword">if</span> (vsmap == NULL) {
			VS_LOCK(vs);
			vs-&gt;vs_xfer_pending = FALSE;
			VS_UNLOCK(vs);
			vs_finish_write(vs);
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}
		<span class="enscript-comment">/* loop on clusters in the direct map */</span>
		<span class="enscript-keyword">for</span> (j = 0; j &lt; vs-&gt;vs_size; j++) {
			<span class="enscript-keyword">if</span> (VSM_ISCLR(vsmap[j]) ||
			    VSM_ISERR(vsmap[j]) ||
			    (VSM_PS(vsmap[j]) != segment))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span>(vs_cluster_transfer(vs, 
				vm_page_size * (j &lt;&lt; vs-&gt;vs_clshift), 
				vm_page_size &lt;&lt; vs-&gt;vs_clshift,
				upl) != KERN_SUCCESS) {
			   VS_LOCK(vs);
			   vs-&gt;vs_xfer_pending = FALSE;
			   VS_UNLOCK(vs);
			   vs_finish_write(vs);
			   <span class="enscript-keyword">return</span> KERN_FAILURE;
			}
			<span class="enscript-comment">/* allow other readers/writers during transfer*/</span>
			VS_LOCK(vs);
			vs-&gt;vs_xfer_pending = FALSE;
			VS_UNLOCK(vs);
			vs_finish_write(vs);
			VS_LOCK(vs);
			vs-&gt;vs_xfer_pending = TRUE;
			vs_wait_for_sync_writers(vs);
			vs_start_write(vs);
			vs_wait_for_readers(vs);
			VS_UNLOCK(vs);
			<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">vs_changed</span>;
			}
		}
	}

	VS_LOCK(vs);
	vs-&gt;vs_xfer_pending = FALSE;
	VS_UNLOCK(vs);
	vs_finish_write(vs);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}



vs_map_t
<span class="enscript-function-name">vs_get_map_entry</span>(
	vstruct_t	vs, 
	dp_offset_t	offset)
{
	<span class="enscript-type">struct</span> vs_map	*vsmap;
	dp_offset_t	cluster;

	cluster = atop_32(offset) &gt;&gt; vs-&gt;vs_clshift;
	<span class="enscript-keyword">if</span> (vs-&gt;vs_indirect) {
		<span class="enscript-type">long</span>	ind_block = cluster/CLMAP_ENTRIES;

		<span class="enscript-comment">/* Is the indirect block allocated? */</span>
		vsmap = vs-&gt;vs_imap[ind_block];
		<span class="enscript-keyword">if</span>(vsmap == (vs_map_t) NULL)
			<span class="enscript-keyword">return</span> vsmap;
	} <span class="enscript-keyword">else</span>
		vsmap = vs-&gt;vs_dmap;
	vsmap += cluster%CLMAP_ENTRIES;
	<span class="enscript-keyword">return</span> vsmap;
}

kern_return_t
<span class="enscript-function-name">vs_cluster_transfer</span>(
	vstruct_t	vs,
	dp_offset_t	offset,
	dp_size_t	cnt,
	upl_t		upl)
{
	dp_offset_t		actual_offset;
	paging_segment_t	ps;
	<span class="enscript-type">struct</span> clmap		clmap;
	kern_return_t		error = KERN_SUCCESS;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size, size_wanted;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		residual = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		unavail_size;
<span class="enscript-comment">//	default_pager_thread_t	*dpt;
</span><span class="enscript-comment">//	boolean_t		dealloc;
</span>	<span class="enscript-type">struct</span>	vs_map		*vsmap_ptr = NULL;
	<span class="enscript-type">struct</span>	vs_map		read_vsmap;
	<span class="enscript-type">struct</span>	vs_map		original_read_vsmap;
	<span class="enscript-type">struct</span>	vs_map		write_vsmap;
<span class="enscript-comment">//	upl_t				sync_upl;
</span><span class="enscript-comment">//	vm_offset_t			ioaddr;
</span>
	<span class="enscript-comment">/* vs_cluster_transfer reads in the pages of a cluster and
	 * then writes these pages back to new backing store.  The
	 * segment the pages are being read from is assumed to have
	 * been taken off-line and is no longer considered for new
	 * space requests.
         */</span>

	<span class="enscript-comment">/*
	 * This loop will be executed once per cluster referenced.
	 * Typically this means once, since it's unlikely that the
	 * VM system will ask for anything spanning cluster boundaries.
	 *
	 * If there are holes in a cluster (in a paging segment), we stop
	 * reading at the hole, then loop again, hoping to
	 * find valid pages later in the cluster.  This continues until
	 * the entire range has been examined, and read, if present.  The
	 * pages are written as they are read.  If a failure occurs after
	 * some pages are written the unmap call at the bottom of the loop
	 * recovers the backing store and the old backing store remains
	 * in effect.
	 */</span>

	VSM_CLR(write_vsmap);
	VSM_CLR(original_read_vsmap);
	<span class="enscript-comment">/* grab the actual object's pages to sync with I/O */</span>
	<span class="enscript-keyword">while</span> (cnt &amp;&amp; (error == KERN_SUCCESS)) {
		vsmap_ptr = vs_get_map_entry(vs, offset);
		actual_offset = ps_clmap(vs, offset, &amp;clmap, CL_FIND, 0, 0);

		<span class="enscript-keyword">if</span> (actual_offset == (dp_offset_t) -1) {

			<span class="enscript-comment">/*
			 * Nothing left to write in this cluster at least
			 * set write cluster information for any previous
			 * write, clear for next cluster, if there is one
			 */</span>
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> local_size, clmask, clsize;

			clsize = vm_page_size &lt;&lt; vs-&gt;vs_clshift;
			clmask = clsize - 1;
			local_size = clsize - (offset &amp; clmask);
			ASSERT(local_size);
			local_size = MIN(local_size, cnt);

			<span class="enscript-comment">/* This cluster has no data in it beyond what may */</span>
			<span class="enscript-comment">/* have been found on a previous iteration through */</span>
			<span class="enscript-comment">/* the loop &quot;write_vsmap&quot; */</span>
			*vsmap_ptr = write_vsmap;
			VSM_CLR(write_vsmap);
			VSM_CLR(original_read_vsmap);

			cnt -= local_size;
			offset += local_size;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * Count up contiguous available or unavailable
		 * pages.
		 */</span>
		ps = CLMAP_PS(clmap);
		ASSERT(ps);
		size = 0;
		unavail_size = 0;
		<span class="enscript-keyword">for</span> (i = 0;
		     (size &lt; cnt) &amp;&amp; (unavail_size &lt; cnt) &amp;&amp;
		     (i &lt; CLMAP_NPGS(clmap)); i++) {
			<span class="enscript-keyword">if</span> (CLMAP_ISSET(clmap, i)) {
				<span class="enscript-keyword">if</span> (unavail_size != 0)
					<span class="enscript-keyword">break</span>;
				size += vm_page_size;
				BS_STAT(ps-&gt;ps_bs,
					ps-&gt;ps_bs-&gt;bs_pages_in++);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (size != 0)
					<span class="enscript-keyword">break</span>;
				unavail_size += vm_page_size;
			}
		}

		<span class="enscript-keyword">if</span> (size == 0) {
			ASSERT(unavail_size);
			ps_clunmap(vs, offset, unavail_size);
			cnt -= unavail_size;
			offset += unavail_size;
			<span class="enscript-keyword">if</span>((offset &amp; ((vm_page_size &lt;&lt; vs-&gt;vs_clshift) - 1)) 
				== 0) {
				<span class="enscript-comment">/* There is no more to transfer in this
				   cluster
				*/</span>
				*vsmap_ptr = write_vsmap;
				VSM_CLR(write_vsmap);
				VSM_CLR(original_read_vsmap);
			} 
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span>(VSM_ISCLR(original_read_vsmap))
			original_read_vsmap = *vsmap_ptr;

		<span class="enscript-keyword">if</span>(ps-&gt;ps_segtype == PS_PARTITION) {
			panic(<span class="enscript-string">&quot;swap partition not supported\n&quot;</span>);
			<span class="enscript-comment">/*NOTREACHED*/</span>
			error = KERN_FAILURE;
			residual = size;
<span class="enscript-comment">/*
			NEED TO ISSUE WITH SYNC &amp; NO COMMIT
			error = ps_read_device(ps, actual_offset, &amp;buffer,
				       size, &amp;residual, flags);
*/</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* NEED TO ISSUE WITH SYNC &amp; NO COMMIT */</span>
			error = ps_read_file(ps, upl, (upl_offset_t) 0, actual_offset, 
					size, &amp;residual, 
					(UPL_IOSYNC | UPL_NOCOMMIT | (dp_encryption ? UPL_PAGING_ENCRYPTED : 0)));
		}

		read_vsmap = *vsmap_ptr;


		<span class="enscript-comment">/*
		 * Adjust counts and put data in new BS.  Optimize for the
		 * common case, i.e. no error and/or partial data.
		 * If there was an error, then we need to error the entire
		 * range, even if some data was successfully read.
		 * 
		 */</span>
		<span class="enscript-keyword">if</span> ((error == KERN_SUCCESS) &amp;&amp; (residual == 0)) {

			<span class="enscript-comment">/*
			 * Got everything we asked for, supply the data to
			 * the new BS.  Note that as a side effect of supplying
			 * the data, the buffer holding the supplied data is
			 * deallocated from the pager's address space unless
			 * the write is unsuccessful.
			 */</span>

			<span class="enscript-comment">/* note buffer will be cleaned up in all cases by */</span>
			<span class="enscript-comment">/* internal_cluster_write or if an error on write */</span>
			<span class="enscript-comment">/* the vm_map_copy_page_discard call              */</span>
			*vsmap_ptr = write_vsmap;

			<span class="enscript-keyword">if</span>(vs_cluster_write(vs, upl, offset, 
					size, TRUE, UPL_IOSYNC | UPL_NOCOMMIT ) != KERN_SUCCESS) {
			 	error = KERN_FAILURE;
				<span class="enscript-keyword">if</span>(!(VSM_ISCLR(*vsmap_ptr))) {
					<span class="enscript-comment">/* unmap the new backing store object */</span>
					ps_clunmap(vs, offset, size);
				}
				<span class="enscript-comment">/* original vsmap */</span>
				*vsmap_ptr = original_read_vsmap;
				VSM_CLR(write_vsmap);
			} <span class="enscript-keyword">else</span> {
			       <span class="enscript-keyword">if</span>((offset + size) &amp; 
					((vm_page_size &lt;&lt; vs-&gt;vs_clshift)
					- 1)) { 
					<span class="enscript-comment">/* There is more to transfer in this
					   cluster
					*/</span>
					write_vsmap = *vsmap_ptr;
					*vsmap_ptr = read_vsmap;
					ps_clunmap(vs, offset, size);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* discard the old backing object */</span>
					write_vsmap = *vsmap_ptr;
					*vsmap_ptr = read_vsmap;
					ps_clunmap(vs, offset, size);
					*vsmap_ptr = write_vsmap;
					VSM_CLR(write_vsmap);
					VSM_CLR(original_read_vsmap);
				}
			}
		} <span class="enscript-keyword">else</span> {
			size_wanted = size;
			<span class="enscript-keyword">if</span> (error == KERN_SUCCESS) {
				<span class="enscript-keyword">if</span> (residual == size) {
					<span class="enscript-comment">/*
					 * If a read operation returns no error
					 * and no data moved, we turn it into
					 * an error, assuming we're reading at
					 * or beyond EOF.
					 * Fall through and error the entire
					 * range.
					 */</span>
					error = KERN_FAILURE;
					*vsmap_ptr = write_vsmap;
					<span class="enscript-keyword">if</span>(!(VSM_ISCLR(*vsmap_ptr))) {
					<span class="enscript-comment">/* unmap the new backing store object */</span>
					ps_clunmap(vs, offset, size);
					}
					*vsmap_ptr = original_read_vsmap;
					VSM_CLR(write_vsmap);
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * Otherwise, we have partial read. 
					 * This is also considered an error
					 * for the purposes of cluster transfer
					 */</span>
					error = KERN_FAILURE;
					*vsmap_ptr = write_vsmap;
					<span class="enscript-keyword">if</span>(!(VSM_ISCLR(*vsmap_ptr))) {
					<span class="enscript-comment">/* unmap the new backing store object */</span>
					ps_clunmap(vs, offset, size);
					}
					*vsmap_ptr = original_read_vsmap;
					VSM_CLR(write_vsmap);
					<span class="enscript-keyword">continue</span>;
				}
			}

		}
		cnt -= size;
		offset += size;

	} <span class="enscript-comment">/* END while (cnt &amp;&amp; (error == 0)) */</span>
	<span class="enscript-keyword">if</span>(!VSM_ISCLR(write_vsmap))
		*vsmap_ptr = write_vsmap;

	<span class="enscript-keyword">return</span> error;
}

kern_return_t
<span class="enscript-function-name">default_pager_add_file</span>(
	MACH_PORT_FACE	backing_store,
	vnode_ptr_t	vp,
	<span class="enscript-type">int</span>		record_size,
	vm_size_t	size)
{
	backing_store_t		bs;
	paging_segment_t	ps;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		j;
	<span class="enscript-type">int</span>			error;

	<span class="enscript-keyword">if</span> ((bs = backing_store_lookup(backing_store))
	    == BACKING_STORE_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	PSL_LOCK();
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= paging_segment_max; i++) {
		ps = paging_segments[i];
		<span class="enscript-keyword">if</span> (ps == PAGING_SEGMENT_NULL)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (ps-&gt;ps_segtype != PS_FILE)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * Check for overlap on same device.
		 */</span>
		<span class="enscript-keyword">if</span> (ps-&gt;ps_vnode == (<span class="enscript-type">struct</span> vnode *)vp) {
			PSL_UNLOCK();
			BS_UNLOCK(bs);
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}
	}
	PSL_UNLOCK();

	<span class="enscript-comment">/*
	 * Set up the paging segment
	 */</span>
	ps = (paging_segment_t) kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> paging_segment));
	<span class="enscript-keyword">if</span> (ps == PAGING_SEGMENT_NULL) {
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	ps-&gt;ps_segtype = PS_FILE;
	ps-&gt;ps_vnode = (<span class="enscript-type">struct</span> vnode *)vp;
	ps-&gt;ps_offset = 0;
	ps-&gt;ps_record_shift = local_log2(vm_page_size / record_size);
	assert((dp_size_t) size == size);
	ps-&gt;ps_recnum = (dp_size_t) size;
	ps-&gt;ps_pgnum = ((dp_size_t) size) &gt;&gt; ps-&gt;ps_record_shift;

	ps-&gt;ps_pgcount = ps-&gt;ps_pgnum;
	ps-&gt;ps_clshift = local_log2(bs-&gt;bs_clsize);
	ps-&gt;ps_clcount = ps-&gt;ps_ncls = ps-&gt;ps_pgcount &gt;&gt; ps-&gt;ps_clshift;
	ps-&gt;ps_special_clusters = 0;
	ps-&gt;ps_hint = 0;

	PS_LOCK_INIT(ps);
	ps-&gt;ps_bmap = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc(RMAPSIZE(ps-&gt;ps_ncls));
	<span class="enscript-keyword">if</span> (!ps-&gt;ps_bmap) {
		PS_LOCK_DESTROY(ps);
		kfree(ps, <span class="enscript-keyword">sizeof</span> *ps);
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}
	<span class="enscript-keyword">for</span> (j = 0; j &lt; ps-&gt;ps_ncls; j++) {
		clrbit(ps-&gt;ps_bmap, j);
	}

	<span class="enscript-keyword">if</span>(paging_segment_count == 0) {
		ps-&gt;ps_state = PS_EMERGENCY_SEGMENT;
		<span class="enscript-keyword">if</span>(use_emergency_swap_file_first) {
			ps-&gt;ps_state |= PS_CAN_USE;
		}
		emergency_segment_backing_store = backing_store;
	} <span class="enscript-keyword">else</span> {
		ps-&gt;ps_state = PS_CAN_USE;
	}
	
	ps-&gt;ps_bs = bs;

	<span class="enscript-keyword">if</span> ((error = ps_enter(ps)) != 0) {
		kfree(ps-&gt;ps_bmap, RMAPSIZE(ps-&gt;ps_ncls));
		PS_LOCK_DESTROY(ps);
		kfree(ps, <span class="enscript-keyword">sizeof</span> *ps);
		BS_UNLOCK(bs);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	bs-&gt;bs_pages_free += ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift;
	bs-&gt;bs_pages_total += ps-&gt;ps_clcount &lt;&lt; ps-&gt;ps_clshift;
	PSL_LOCK();
	<span class="enscript-keyword">if</span>(IS_PS_OK_TO_USE(ps)) {
		dp_pages_free += ps-&gt;ps_pgcount;
	} <span class="enscript-keyword">else</span> {
		dp_pages_reserve += ps-&gt;ps_pgcount;
	}
	PSL_UNLOCK();

	BS_UNLOCK(bs);

	bs_more_space(ps-&gt;ps_clcount);

	<span class="enscript-comment">/*
	 * If the paging segment being activated is not the emergency
	 * segment and we notice that the emergency segment is being
	 * used then we help recover it. If all goes well, the
	 * emergency segment will be back to its original state of
	 * online but not activated (till it's needed the next time).
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-keyword">if</span> (!memorystatus_freeze_enabled)
#<span class="enscript-reference">endif</span>
	{
		ps = paging_segments[EMERGENCY_PSEG_INDEX];
		<span class="enscript-keyword">if</span>(IS_PS_EMERGENCY_SEGMENT(ps) &amp;&amp; IS_PS_OK_TO_USE(ps)) {
			<span class="enscript-keyword">if</span>(default_pager_backing_store_delete(emergency_segment_backing_store)) {
				dprintf((<span class="enscript-string">&quot;Failed to recover emergency paging segment\n&quot;</span>));
			} <span class="enscript-keyword">else</span> {
				dprintf((<span class="enscript-string">&quot;Recovered emergency paging segment\n&quot;</span>));
			}
		}
	}
	
	DP_DEBUG(DEBUG_BS_INTERNAL,
		 (<span class="enscript-string">&quot;device=0x%x,offset=0x%x,count=0x%x,record_size=0x%x,shift=%d,total_size=0x%x\n&quot;</span>,
		  device, offset, (dp_size_t) size, record_size,
		  ps-&gt;ps_record_shift, ps-&gt;ps_pgnum));

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}



kern_return_t
<span class="enscript-function-name">ps_read_file</span>(
	paging_segment_t	ps,
	upl_t			upl,
	upl_offset_t		upl_offset,
	dp_offset_t		offset,
	upl_size_t		size,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*residualp,
	<span class="enscript-type">int</span>			flags)
{
	vm_object_offset_t	f_offset;
	<span class="enscript-type">int</span>			error = 0;
	<span class="enscript-type">int</span>			result;

	assert(dp_encryption_inited);

	clustered_reads[atop_32(size)]++;

	f_offset = (vm_object_offset_t)(ps-&gt;ps_offset + offset);
	
	<span class="enscript-comment">/*
	 * for transfer case we need to pass uploffset and flags
	 */</span>
	assert((upl_size_t) size == size);
	error = vnode_pagein(ps-&gt;ps_vnode, upl, upl_offset, f_offset, (upl_size_t)size, flags, NULL);

	<span class="enscript-comment">/* The vnode_pagein semantic is somewhat at odds with the existing   */</span>
	<span class="enscript-comment">/* device_read semantic.  Partial reads are not experienced at this  */</span>
	<span class="enscript-comment">/* level.  It is up to the bit map code and cluster read code to     */</span>
	<span class="enscript-comment">/* check that requested data locations are actually backed, and the  */</span>
	<span class="enscript-comment">/* pagein code to either read all of the requested data or return an */</span>
	<span class="enscript-comment">/* error. */</span>

	<span class="enscript-keyword">if</span> (error)
		result = KERN_FAILURE;
	<span class="enscript-keyword">else</span> {
		*residualp = 0;
		result = KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> result;
}

kern_return_t
<span class="enscript-function-name">ps_write_file</span>(
	paging_segment_t	ps,
	upl_t                   upl,
	upl_offset_t		upl_offset,
	dp_offset_t		offset,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		size,
	<span class="enscript-type">int</span>			flags)
{
	vm_object_offset_t	f_offset;
	kern_return_t		result;

	assert(dp_encryption_inited);

	clustered_writes[atop_32(size)]++;
	f_offset = (vm_object_offset_t)(ps-&gt;ps_offset + offset);

	<span class="enscript-keyword">if</span> (flags &amp; UPL_PAGING_ENCRYPTED) {
		<span class="enscript-comment">/*
		 * ENCRYPTED SWAP:
		 * encrypt all the pages that we're going
		 * to pageout.
		 */</span>
		upl_encrypt(upl, upl_offset, size);
	}
	assert((upl_size_t) size == size);
	<span class="enscript-keyword">if</span> (vnode_pageout(ps-&gt;ps_vnode,	upl, upl_offset, f_offset, (upl_size_t)size, flags, NULL))
	        result = KERN_FAILURE;
	<span class="enscript-keyword">else</span>
	        result = KERN_SUCCESS;

	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ps_vnode_trim_init</span>(<span class="enscript-type">struct</span> ps_vnode_trim_data *data)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">data</span>)
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ps_vnode_trim_now</span>(<span class="enscript-type">struct</span> ps_vnode_trim_data *data)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">data</span>)
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ps_vnode_trim_more</span>(<span class="enscript-type">struct</span> ps_vnode_trim_data *data, <span class="enscript-type">struct</span> vs_map *map, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> shift, dp_size_t length)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">data</span>, <span class="enscript-variable-name">map</span>, <span class="enscript-variable-name">shift</span>, <span class="enscript-variable-name">length</span>)
}

kern_return_t
<span class="enscript-function-name">default_pager_triggers</span>( __unused MACH_PORT_FACE default_pager,
	<span class="enscript-type">int</span>		hi_wat,
	<span class="enscript-type">int</span>		lo_wat,
	<span class="enscript-type">int</span>		flags,
	MACH_PORT_FACE  trigger_port)
{
	MACH_PORT_FACE release = IPC_PORT_NULL;
	kern_return_t kr;
	clock_sec_t now;
	clock_nsec_t nanoseconds_dummy;
	<span class="enscript-type">static</span> clock_sec_t error_notify = 0;

	PSL_LOCK();
	<span class="enscript-keyword">if</span> (flags == SWAP_ENCRYPT_ON) {
		<span class="enscript-comment">/* ENCRYPTED SWAP: turn encryption on */</span>
		release = trigger_port;
		<span class="enscript-keyword">if</span> (!dp_encryption_inited) {
			dp_encryption_inited = TRUE;
			dp_encryption = TRUE;
			kr = KERN_SUCCESS;
		} <span class="enscript-keyword">else</span> {
			kr = KERN_FAILURE;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags == SWAP_ENCRYPT_OFF) {
		<span class="enscript-comment">/* ENCRYPTED SWAP: turn encryption off */</span>
		release = trigger_port;
		<span class="enscript-keyword">if</span> (!dp_encryption_inited) {
			dp_encryption_inited = TRUE;
			dp_encryption = FALSE;
			kr = KERN_SUCCESS;
		} <span class="enscript-keyword">else</span> {
			kr = KERN_FAILURE;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags == HI_WAT_ALERT) {
		release = min_pages_trigger_port;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
		<span class="enscript-comment">/* High and low water signals aren't applicable when freeze is */</span>
		<span class="enscript-comment">/* enabled, so release the trigger ports here and return       */</span>
		<span class="enscript-comment">/* KERN_FAILURE.                                               */</span>
		<span class="enscript-keyword">if</span> (memorystatus_freeze_enabled) {
			<span class="enscript-keyword">if</span> (IP_VALID( trigger_port )){
				ipc_port_release_send( trigger_port );
			}
			min_pages_trigger_port = IPC_PORT_NULL;
			kr = KERN_FAILURE;
		}
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		{
			min_pages_trigger_port = trigger_port;
			minimum_pages_remaining = hi_wat/vm_page_size;
			bs_low = FALSE;
			kr = KERN_SUCCESS;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags ==  LO_WAT_ALERT) {
		release = max_pages_trigger_port;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
		<span class="enscript-keyword">if</span> (memorystatus_freeze_enabled) {
			<span class="enscript-keyword">if</span> (IP_VALID( trigger_port )){
				ipc_port_release_send( trigger_port );
			}
			max_pages_trigger_port = IPC_PORT_NULL;
			kr = KERN_FAILURE;
		}
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		{
			max_pages_trigger_port = trigger_port;
			maximum_pages_free = lo_wat/vm_page_size;
			kr = KERN_SUCCESS;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags == USE_EMERGENCY_SWAP_FILE_FIRST) {
		use_emergency_swap_file_first = TRUE;
		release = trigger_port;
		kr = KERN_SUCCESS;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags == SWAP_FILE_CREATION_ERROR) {
		release = trigger_port;
		kr = KERN_SUCCESS;
		<span class="enscript-keyword">if</span>( paging_segment_count == 1) {
			use_emergency_swap_file_first = TRUE;
		}
		no_paging_space_action();
		clock_get_system_nanotime(&amp;now, &amp;nanoseconds_dummy);
		<span class="enscript-keyword">if</span> (now &gt; error_notify + 5) {
			dprintf((<span class="enscript-string">&quot;Swap File Error.\n&quot;</span>));
			error_notify = now;
		}
	} <span class="enscript-keyword">else</span> {
		release = trigger_port;
		kr =  KERN_INVALID_ARGUMENT;
	}
	PSL_UNLOCK();

	<span class="enscript-keyword">if</span> (IP_VALID(release))
		ipc_port_release_send(release);
	
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * Monitor the amount of available backing store vs. the amount of
 * required backing store, notify a listener (if present) when 
 * backing store may safely be removed.
 *
 * We attempt to avoid the situation where backing store is 
 * discarded en masse, as this can lead to thrashing as the
 * backing store is compacted.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_INTERVAL</span>	3	<span class="enscript-comment">/* time between free level checks */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_LATENCY</span>	10	<span class="enscript-comment">/* number of intervals before release */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> dp_pages_free_low_count = 0;
thread_call_t default_pager_backing_store_monitor_callout;

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_pager_backing_store_monitor</span>(__unused thread_call_param_t p1,
									__unused thread_call_param_t p2)
{
<span class="enscript-comment">//	unsigned long long	average;
</span>	ipc_port_t		trigger;
	uint64_t		deadline;

	<span class="enscript-comment">/*
	 * We determine whether it will be safe to release some
	 * backing store by watching the free page level.  If
	 * it remains below the maximum_pages_free threshold for
	 * at least PF_LATENCY checks (taken at PF_INTERVAL seconds)
	 * then we deem it safe.
	 *
	 * Note that this establishes a maximum rate at which backing
	 * store will be released, as each notification (currently)
	 * only results in a single backing store object being
	 * released.
	 */</span>
	<span class="enscript-keyword">if</span> (dp_pages_free &gt; maximum_pages_free) {
		dp_pages_free_low_count++;
	} <span class="enscript-keyword">else</span> {
		dp_pages_free_low_count = 0;
	}

	<span class="enscript-comment">/* decide whether to send notification */</span>
	trigger = IP_NULL;
	<span class="enscript-keyword">if</span> (max_pages_trigger_port &amp;&amp;
	    (backing_store_release_trigger_disable == 0) &amp;&amp;
	    (dp_pages_free_low_count &gt; PF_LATENCY)) {
		trigger = max_pages_trigger_port;
		max_pages_trigger_port = NULL;
	}

	<span class="enscript-comment">/* send notification */</span>
	<span class="enscript-keyword">if</span> (trigger != IP_NULL) {
		VSL_LOCK();
		<span class="enscript-keyword">if</span>(backing_store_release_trigger_disable != 0) {
			assert_wait((event_t) 
				    &amp;backing_store_release_trigger_disable, 
				    THREAD_UNINT);
			VSL_UNLOCK();
			thread_block(THREAD_CONTINUE_NULL);
		} <span class="enscript-keyword">else</span> {
			VSL_UNLOCK();
		}
		dprintf((<span class="enscript-string">&quot;default_pager_backing_store_monitor - send LO_WAT_ALERT\n&quot;</span>));

		default_pager_space_alert(trigger, LO_WAT_ALERT);
		ipc_port_release_send(trigger);
		dp_pages_free_low_count = 0;
	}

	clock_interval_to_deadline(PF_INTERVAL, NSEC_PER_SEC, &amp;deadline);
	thread_call_enter_delayed(default_pager_backing_store_monitor_callout, deadline);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">default_pager_swap_pages_free</span>() {
	<span class="enscript-keyword">return</span> dp_pages_free;
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>