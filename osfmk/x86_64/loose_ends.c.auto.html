<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>loose_ends.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">loose_ends.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_KDP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_callout.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MACH_KDP */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">KERNEL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_DEBUG</span> KERNEL_DEBUG_CONSTANT
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KDEBUG</span> 1

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* XXX - should be gone from here */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		invalidate_icache64(addr64_t addr, <span class="enscript-type">unsigned</span> cnt, <span class="enscript-type">int</span> phys);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		flush_dcache64(addr64_t addr, <span class="enscript-type">unsigned</span> count, <span class="enscript-type">int</span> phys);
<span class="enscript-type">extern</span> boolean_t	phys_page_exists(ppnum_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		bcopy_no_overwrite(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *from, <span class="enscript-type">char</span> *to,vm_size_t bytes);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		pmap_set_reference(ppnum_t pn);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		mapping_set_mod(ppnum_t pa); 
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		mapping_set_ref(ppnum_t pn);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		ovbcopy(<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*from,
				<span class="enscript-type">char</span>		*to,
				vm_size_t	nbytes);
<span class="enscript-type">void</span> <span class="enscript-function-name">machine_callstack</span>(uintptr_t *buf, vm_size_t callstack_max);


#<span class="enscript-reference">define</span> <span class="enscript-function-name">value_64bit</span>(value)  ((value) &amp; 0xFFFFFFFF00000000ULL)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">low32</span>(x)  ((unsigned int)((x) &amp; 0x00000000FFFFFFFFULL))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INT_SIZE</span>	(BYTE_SIZE * sizeof (int))

<span class="enscript-comment">/*
 * Set indicated bit in bit string.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">setbit</span>(<span class="enscript-type">int</span> bitno, <span class="enscript-type">int</span> *s)
{
	s[bitno / INT_SIZE] |= 1 &lt;&lt; (bitno % INT_SIZE);
}

<span class="enscript-comment">/*
 * Clear indicated bit in bit string.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clrbit</span>(<span class="enscript-type">int</span> bitno, <span class="enscript-type">int</span> *s)
{
	s[bitno / INT_SIZE] &amp;= ~(1 &lt;&lt; (bitno % INT_SIZE));
}

<span class="enscript-comment">/*
 * Test if indicated bit is set in bit string.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">testbit</span>(<span class="enscript-type">int</span> bitno, <span class="enscript-type">int</span> *s)
{
	<span class="enscript-keyword">return</span> s[bitno / INT_SIZE] &amp; (1 &lt;&lt; (bitno % INT_SIZE));
}

<span class="enscript-comment">/*
 * Find first bit set in bit string.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ffsbit</span>(<span class="enscript-type">int</span> *s)
{
	<span class="enscript-type">int</span>             offset;

	<span class="enscript-keyword">for</span> (offset = 0; !*s; offset += (<span class="enscript-type">int</span>)INT_SIZE, ++s);
	<span class="enscript-keyword">return</span> offset + __builtin_ctz(*s);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ffs</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mask)
{
	<span class="enscript-keyword">if</span> (mask == 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">/*
	 * NOTE: cannot use __builtin_ffs because it generates a call to
	 * 'ffs'
	 */</span>
	<span class="enscript-keyword">return</span> 1 + __builtin_ctz(mask);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bzero_phys_nc</span>(
	      addr64_t src64,
	      uint32_t bytes)
{
  bzero_phys(src64,bytes);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bzero_phys</span>(
	   addr64_t src64,
	   uint32_t bytes)
{
	bzero(PHYSMAP_PTOV(src64), bytes);
}


<span class="enscript-comment">/*
 * bcopy_phys - like bcopy but copies from/to physical addresses.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">bcopy_phys</span>(
	   addr64_t src64,
	   addr64_t dst64,
	   vm_size_t bytes)
{
	<span class="enscript-comment">/* Not necessary for K64 - but ensure we stay within a page */</span>
	<span class="enscript-keyword">if</span> (((((uint32_t)src64 &amp; (NBPG-1)) + bytes) &gt; NBPG) ||
            ((((uint32_t)dst64 &amp; (NBPG-1)) + bytes) &gt; NBPG) ) {
	        panic(<span class="enscript-string">&quot;bcopy_phys alignment&quot;</span>);
	}
	bcopy(PHYSMAP_PTOV(src64), PHYSMAP_PTOV(dst64), bytes);
}

<span class="enscript-comment">/*
 * allow a function to get a quick virtual mapping of a physical page
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">apply_func_phys</span>(
		addr64_t dst64,
		vm_size_t bytes,
		<span class="enscript-type">int</span> (*func)(<span class="enscript-type">void</span> * buffer, vm_size_t bytes, <span class="enscript-type">void</span> * arg),
		<span class="enscript-type">void</span> * arg)
{
	<span class="enscript-comment">/* Not necessary for K64 - but ensure we stay within a page */</span>
	<span class="enscript-keyword">if</span> (((((uint32_t)dst64 &amp; (NBPG-1)) + bytes) &gt; NBPG) ) {
	        panic(<span class="enscript-string">&quot;apply_func_phys alignment&quot;</span>);
	}

	<span class="enscript-keyword">return</span> func(PHYSMAP_PTOV(dst64), bytes, arg);
}

<span class="enscript-comment">/* 
 * ovbcopy - like bcopy, but recognizes overlapping ranges and handles 
 *           them correctly.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ovbcopy</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*from,
	<span class="enscript-type">char</span>		*to,
	vm_size_t	bytes)		<span class="enscript-comment">/* num bytes to copy */</span>
{
	<span class="enscript-comment">/* Assume that bcopy copies left-to-right (low addr first). */</span>
	<span class="enscript-keyword">if</span> (from + bytes &lt;= to || to + bytes &lt;= from || to == from)
		bcopy_no_overwrite(from, to, bytes);	<span class="enscript-comment">/* non-overlapping or no-op*/</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (from &gt; to)
		bcopy_no_overwrite(from, to, bytes);	<span class="enscript-comment">/* overlapping but OK */</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* to &gt; from: overlapping, and must copy right-to-left. */</span>
		from += bytes - 1;
		to += bytes - 1;
		<span class="enscript-keyword">while</span> (bytes-- &gt; 0)
			*to-- = *from--;
	}
}


<span class="enscript-comment">/*
 *  Read data from a physical address. Memory should not be cache inhibited.
 */</span>

uint64_t reportphyreaddelayabs;
uint32_t reportphyreadosbt;

<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ml_phys_read_data</span>(pmap_paddr_t paddr, <span class="enscript-type">int</span> size)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> s1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> s2;
	boolean_t istate;
	uint64_t sabs, eabs;

	<span class="enscript-keyword">if</span> (__improbable(!physmap_enclosed(paddr)))
		panic(<span class="enscript-string">&quot;%s: 0x%llx out of bounds\n&quot;</span>, __FUNCTION__, paddr);

	<span class="enscript-keyword">if</span> (__improbable(reportphyreaddelayabs != 0)) {
		istate = ml_set_interrupts_enabled(FALSE);
		sabs = mach_absolute_time();
	}

        <span class="enscript-keyword">switch</span> (size) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		s1 = *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)PHYSMAP_PTOV(paddr);
		result = s1;
		<span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		s2 = *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)PHYSMAP_PTOV(paddr);
		result = s2;
		<span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		result = *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)PHYSMAP_PTOV(paddr);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;Invalid size %d for ml_phys_read_data\n&quot;</span>, size);
		<span class="enscript-keyword">break</span>;
        }

	<span class="enscript-keyword">if</span> (__improbable(reportphyreaddelayabs != 0)) {
		eabs = mach_absolute_time();
		(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(istate);

		<span class="enscript-keyword">if</span> ((eabs - sabs) &gt; reportphyreaddelayabs) {
			<span class="enscript-keyword">if</span> (reportphyreadosbt) {
				OSReportWithBacktrace(<span class="enscript-string">&quot;ml_phys_read_data took %lluus\n&quot;</span>, (eabs - sabs) / 1000);
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			DTRACE_PHYSLAT3(physread, uint64_t, (eabs - sabs),
			    pmap_paddr_t, paddr, uint32_t, size);
#<span class="enscript-reference">endif</span>
		}
	}

        <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">ml_phys_read_long_long</span>(pmap_paddr_t paddr )
{
	<span class="enscript-keyword">if</span> (!physmap_enclosed(paddr))
		panic(<span class="enscript-string">&quot;%s: 0x%llx out of bounds\n&quot;</span>, __FUNCTION__, paddr);
	<span class="enscript-keyword">return</span> *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> *)PHYSMAP_PTOV(paddr);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read</span>( vm_offset_t paddr)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr, 4);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_word</span>(vm_offset_t paddr) {

        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr, 4);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_64</span>(addr64_t paddr64)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr64, 4);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_word_64</span>(addr64_t paddr64)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr64, 4);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_half</span>(vm_offset_t paddr)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr, 2);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_half_64</span>(addr64_t paddr64)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr64, 2);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_byte</span>(vm_offset_t paddr)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr, 1);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ml_phys_read_byte_64</span>(addr64_t paddr64)
{
        <span class="enscript-keyword">return</span> ml_phys_read_data((pmap_paddr_t)paddr64, 1);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-function-name">ml_phys_read_double</span>(vm_offset_t paddr)
{
        <span class="enscript-keyword">return</span> ml_phys_read_long_long((pmap_paddr_t)paddr);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-function-name">ml_phys_read_double_64</span>(addr64_t paddr64)
{
        <span class="enscript-keyword">return</span> ml_phys_read_long_long((pmap_paddr_t)paddr64);
}



<span class="enscript-comment">/*
 *  Write data to a physical address. Memory should not be cache inhibited.
 */</span>

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">ml_phys_write_data</span>(pmap_paddr_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> data, <span class="enscript-type">int</span> size)
{
	<span class="enscript-keyword">if</span> (!physmap_enclosed(paddr))
		panic(<span class="enscript-string">&quot;%s: 0x%llx out of bounds\n&quot;</span>, __FUNCTION__, paddr);

        <span class="enscript-keyword">switch</span> (size) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	    *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)PHYSMAP_PTOV(paddr) = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)data;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
	    *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)PHYSMAP_PTOV(paddr) = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>)data;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
	    *(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)PHYSMAP_PTOV(paddr) = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)data;
            <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;Invalid size %d for ml_phys_write_data\n&quot;</span>, size);
		<span class="enscript-keyword">break</span>;
        }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ml_phys_write_long_long</span>(pmap_paddr_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> data)
{
	<span class="enscript-keyword">if</span> (!physmap_enclosed(paddr))
		panic(<span class="enscript-string">&quot;%s: 0x%llx out of bounds\n&quot;</span>, __FUNCTION__, paddr);

	*(<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> *)PHYSMAP_PTOV(paddr) = data;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_byte</span>(vm_offset_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr, data, 1);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_byte_64</span>(addr64_t paddr64, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr64, data, 1);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_half</span>(vm_offset_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr, data, 2);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_half_64</span>(addr64_t paddr64, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr64, data, 2);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write</span>(vm_offset_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr, data, 4);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_64</span>(addr64_t paddr64, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr64, data, 4);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_word</span>(vm_offset_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr, data, 4);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_word_64</span>(addr64_t paddr64, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> data)
{
        ml_phys_write_data((pmap_paddr_t)paddr64, data, 4);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_double</span>(vm_offset_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> data)
{
        ml_phys_write_long_long((pmap_paddr_t)paddr, data);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ml_phys_write_double_64</span>(addr64_t paddr64, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> data)
{
        ml_phys_write_long_long((pmap_paddr_t)paddr64, data);
}


<span class="enscript-comment">/* PCI config cycle probing
 *
 *
 *      Read the memory location at physical address paddr.
 * *Does not* recover from machine checks, unlike the PowerPC implementation.
 * Should probably be deprecated.
 */</span>

boolean_t
<span class="enscript-function-name">ml_probe_read</span>(vm_offset_t paddr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *val)
{
    <span class="enscript-keyword">if</span> ((PAGE_SIZE - (paddr &amp; PAGE_MASK)) &lt; 4)
        <span class="enscript-keyword">return</span> FALSE;

    *val = ml_phys_read((pmap_paddr_t)paddr);

    <span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 *  Read the memory location at physical address paddr.
 *  This is a part of a device probe, so there is a good chance we will
 *  have a machine check here. So we have to be able to handle that.
 *  We assume that machine checks are enabled both in MSR and HIDs
 */</span>
boolean_t 
<span class="enscript-function-name">ml_probe_read_64</span>(addr64_t paddr64, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *val)
{
    <span class="enscript-keyword">if</span> ((PAGE_SIZE - (paddr64 &amp; PAGE_MASK)) &lt; 4)
        <span class="enscript-keyword">return</span> FALSE;

    *val = ml_phys_read_64((pmap_paddr_t)paddr64);
    <span class="enscript-keyword">return</span> TRUE;
}


<span class="enscript-type">int</span> <span class="enscript-function-name">bcmp</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>	*pa,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>	*pb,
	size_t	len)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *a = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)pa;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *b = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)pb;

	<span class="enscript-keyword">if</span> (len == 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">do</span>
		<span class="enscript-keyword">if</span> (*a++ != *b++)
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">while</span> (--len);

	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)len;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memcmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *s1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *s2, size_t n)
{
	<span class="enscript-keyword">if</span> (n != 0) {
		<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *p1 = s1, *p2 = s2;

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (*p1++ != *p2++)
				<span class="enscript-keyword">return</span> (*--p1 - *--p2);
		} <span class="enscript-keyword">while</span> (--n != 0);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">memmove</span>(<span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, size_t ulen)
{
	bcopy(src, dst, ulen);
	<span class="enscript-keyword">return</span> dst;
}

<span class="enscript-comment">/*
 * Abstract:
 * strlen returns the number of characters in &quot;string&quot; preceeding
 * the terminating null character.
 */</span>

size_t
<span class="enscript-function-name">strlen</span>(
	<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *string)
{
	<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ret = string;

	<span class="enscript-keyword">while</span> (*string++ != <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">return</span> string - 1 - ret;
}

uint32_t
<span class="enscript-function-name">hw_compare_and_store</span>(uint32_t oldval, uint32_t newval, <span class="enscript-type">volatile</span> uint32_t *dest)
{
	<span class="enscript-keyword">return</span> OSCompareAndSwap((UInt32)oldval,
				(UInt32)newval,
				(<span class="enscript-type">volatile</span> UInt32 *)dest);
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>

<span class="enscript-comment">/*
 * Machine-dependent routine to fill in an array with up to callstack_max
 * levels of return pc information.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">machine_callstack</span>(
	__unused uintptr_t	*buf,
	__unused vm_size_t	callstack_max)
{
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">fillPage</span>(ppnum_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fill)
{
	pmap_paddr_t    src;
	<span class="enscript-type">int</span>             i;
	<span class="enscript-type">int</span>             cnt = PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>   *addr;

	src = i386_ptob(pa);
	<span class="enscript-keyword">for</span> (i = 0, addr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)PHYSMAP_PTOV(src); i &lt; cnt; i++)
		*addr++ = fill;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">__clflush</span>(<span class="enscript-type">void</span> *ptr)
{
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;clflush (%0)&quot;</span> : : <span class="enscript-string">&quot;r&quot;</span> (ptr));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">dcache_incoherent_io_store64</span>(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count)
{
	addr64_t  linesize = cpuid_info()-&gt;cache_linesize;
	addr64_t  bound = (pa + count + linesize - 1) &amp; ~(linesize - 1);

	mfence();

	<span class="enscript-keyword">while</span> (pa &lt; bound) {
		__clflush(PHYSMAP_PTOV(pa));
		pa += linesize;
	}

	mfence();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">dcache_incoherent_io_flush64</span>(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count)
{
    <span class="enscript-keyword">return</span>(dcache_incoherent_io_store64(pa,count));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">flush_dcache64</span>(addr64_t addr, <span class="enscript-type">unsigned</span> count, <span class="enscript-type">int</span> phys)
{
	<span class="enscript-keyword">if</span> (phys) {
		dcache_incoherent_io_flush64(addr, count);
	}
	<span class="enscript-keyword">else</span> {
		uint64_t  linesize = cpuid_info()-&gt;cache_linesize;
		addr64_t  bound = (addr + count + linesize -1) &amp; ~(linesize - 1);
		mfence();
		<span class="enscript-keyword">while</span> (addr &lt; bound) {
			__clflush((<span class="enscript-type">void</span> *) (uintptr_t) addr);
			addr += linesize;
		}
		mfence();
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">invalidate_icache64</span>(__unused addr64_t addr,
		    __unused <span class="enscript-type">unsigned</span> count,
		    __unused <span class="enscript-type">int</span> phys)
{
}


addr64_t         vm_last_addr;

<span class="enscript-type">void</span>
<span class="enscript-function-name">mapping_set_mod</span>(ppnum_t pn)
{
  pmap_set_modify(pn);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mapping_set_ref</span>(ppnum_t pn)
{
  pmap_set_reference(pn);
}

<span class="enscript-type">extern</span> i386_cpu_info_t	cpuid_cpu_info;
<span class="enscript-type">void</span>
<span class="enscript-function-name">cache_flush_page_phys</span>(ppnum_t pa)
{
	boolean_t	istate;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*cacheline_addr;
	i386_cpu_info_t	*cpuid_infop = cpuid_info();
	<span class="enscript-type">int</span>		cacheline_size;
	<span class="enscript-type">int</span>		cachelines_to_flush;

	cacheline_size = cpuid_infop-&gt;cache_linesize;
	<span class="enscript-keyword">if</span> (cacheline_size == 0)
		panic(<span class="enscript-string">&quot;cacheline_size=0 cpuid_infop=%p\n&quot;</span>, cpuid_infop);
	cachelines_to_flush = PAGE_SIZE/cacheline_size;

	mfence();

	istate = ml_set_interrupts_enabled(FALSE);

	<span class="enscript-keyword">for</span> (cacheline_addr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)PHYSMAP_PTOV(i386_ptob(pa));
	     cachelines_to_flush &gt; 0;
	     cachelines_to_flush--, cacheline_addr += cacheline_size) {
		__clflush((<span class="enscript-type">void</span> *) cacheline_addr);
	}

	(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(istate);

	mfence();
}


#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_KDP</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_register_callout</span>(kdp_callout_fn_t fn, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">fn</span>,<span class="enscript-variable-name">arg</span>)
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_VMX</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">host_vmxon</span>(boolean_t exclusive __unused)
{
	<span class="enscript-keyword">return</span> VMX_UNSUPPORTED;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">host_vmxoff</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>