<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>WKdmCompress_new.s</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">WKdmCompress_new.s&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 <span class="enscript-keyword">*</span> Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> This file contains Original Code and/or Modifications of Original Code
 <span class="enscript-keyword">*</span> as defined in and that are subject to the Apple Public Source License
 <span class="enscript-keyword">*</span> Version 2.0 (the 'License'). You may not use this file except in
 <span class="enscript-keyword">*</span> compliance with the License. The rights granted to you under the License
 <span class="enscript-keyword">*</span> may not be used to create, or enable the creation or redistribution of,
 <span class="enscript-keyword">*</span> unlawful or unlicensed copies of an Apple operating system, or to
 <span class="enscript-keyword">*</span> circumvent, violate, or enable the circumvention or violation of, any
 <span class="enscript-keyword">*</span> terms of an Apple operating system software license agreement.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> Please obtain a copy of the License at
 <span class="enscript-keyword">*</span> <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> The Original Code and all software distributed under the License are
 <span class="enscript-keyword">*</span> distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 <span class="enscript-keyword">*</span> EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 <span class="enscript-keyword">*</span> INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 <span class="enscript-keyword">*</span> FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 <span class="enscript-keyword">*</span> Please see the License for the specific language governing rights and
 <span class="enscript-keyword">*</span> limitations under the License.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 <span class="enscript-keyword">*/
</span>
/*
 <span class="enscript-keyword">This</span> file contains x86_64 hand optimized implementation of WKdm memory page compressor. 

 	<span class="enscript-keyword">int</span> WKdm_compress (WK_word* src_buf, WK_word* dest_buf, WK_word* scratch, unsigned int bytes_budget)<span class="enscript-comment">;

</span>	<span class="enscript-keyword">input</span> :
		<span class="enscript-keyword">src_buf</span> : address of input page (length = 1024 words)
		<span class="enscript-keyword">dest_buf</span> : address of output buffer (may not be 16-byte aligned)
		<span class="enscript-keyword">scratch</span> : a 16-byte aligned 4k bytes scratch memory provided by the caller, 
		<span class="enscript-keyword">bytes_budget</span> : a given byte target in compression

	<span class="enscript-keyword">output</span> :

		<span class="enscript-keyword">if</span> the input buffer can be compressed within the given byte budget, the dest_buf is written with compressed data and the function returns with number of bytes for the compressed data  
		<span class="enscript-keyword">o.w.,</span> the function returns -1 to signal that the input data can not be compressed with the given byte budget.
		<span class="enscript-keyword">During</span> the scan and tag process, each word that can not be compressed will be written to dest_buf, followed by a 12-bytes header + 256-bytes tag area.
		<span class="enscript-keyword">When</span> the functions returns -1, dest_buf is filled with all those words that can not be compressed and should be considered undefined.
		<span class="enscript-keyword">The</span> worst-case scenario is that all words can not be compressed. Hence, the minimum size requirement for dest_buf should be 12+256+4096 = 4364 bytes to prevent from memory fault. 

 <span class="enscript-keyword">The</span> 4th argument bytes_budget is the target compress budget in bytes.
 <span class="enscript-keyword">Should</span> the input page can be compressed within the budget, the compressed data is written to *dest_buf, and the function returns the number of compressed bytes.
 <span class="enscript-keyword">Otherwise,</span> the function returns -1 (to signal to the caller that the page can not be compressed).

 <span class="enscript-keyword">WKdm</span> Compression algorithm is briefly stated as follows:

	<span class="enscript-keyword">There</span> is a dynamically updated dictionary consisting of 16 words. Each dictionary word is initialized to 1 at the point of entry to the function.
	<span class="enscript-keyword">For</span> a nonzero input word x, its 8-bits (10-bits scaled up) is used to determine a corresponding word from the dictionary, represented by dict_index (4-bits) and dict_word (32-bits).
		<span class="enscript-keyword">a.</span> k = (x&gt;&gt;10)&amp;255<span class="enscript-comment">;						// 8-bit hash table index
		b. dict_index = hashTable[k];			// 4-bit dictionary index, hashTable[] is fixed	
</span>		<span class="enscript-keyword">c.</span> dict_word = dictionary[dict_index]<span class="enscript-comment">;	// 32-bit dictionary word, dictionary[] is dynamically updated 

</span> 	<span class="enscript-keyword">Each</span> input word x is classified/tagged into 4 classes :
		<span class="enscript-keyword">0</span> : x = 0
		<span class="enscript-keyword">1</span> : (x&gt;&gt;10) == (dict_word&gt;&gt;10), bits 10:31 of the input word match a dictionary word
  		<span class="enscript-keyword">2</span> : (x&gt;&gt;10) != (dict_word&gt;&gt;10), the above condition (22 higher bits matched) is not met, meaning a dictionary miss
  		<span class="enscript-keyword">3</span> : (x == dict_word), the exact input word is in the dictionary

	<span class="enscript-keyword">For</span> each class, different numbers of bits are needed for the decompressor to reproduce the original input word.
		<span class="enscript-keyword">0</span> : 2-bits tag (32-&gt;2 compression)
		<span class="enscript-keyword">1</span> : 2-bits tag + 4-bits dict_index + 10-bits lower bits (32-&gt;16 compression)
		<span class="enscript-keyword">2</span> : 2-bits tag + 32-bits new word (32-&gt;34 expansion)
		<span class="enscript-keyword">3</span> : 2-bits tag + 4-bits dict_index (32-&gt;6 compression)

	<span class="enscript-keyword">It</span> is obvious now that WKdm compress algorithm works well for pages where there are lots of zero words (32-&gt;2) and/or there are freqeunt repeats of some word patterns (32-&gt;6). 

	<span class="enscript-keyword">the</span> output bit stream (*dest_buf) consists of 
		<span class="enscript-keyword">a.</span> 12 bytes header
		<span class="enscript-keyword">b.</span> 256 bytes for 1024 packed tags
		<span class="enscript-keyword">c.</span> (varying number of) words for new words not matched to dictionary word. 
		<span class="enscript-keyword">d.</span> (varying number of) 32-bit words for packed 4-bit dict_indices (for class 1 and 3)
		<span class="enscript-keyword">e.</span> (varying number of) 32-bit words for packed 10-bit low bits (for class 1)

	<span class="enscript-keyword">the</span> header is actually of 3 words that specify the ending offset (in 32-bit words) from the start of the bit stream of c,d,e, respectively.
	<span class="enscript-keyword">Note</span> that there might be padding bits in d (if the number of dict_indices does not divide by 8), and there are 2/12/22 padding bits for packing 3/2/1 low 10-bits in a 32-bit word.


	<span class="enscript-keyword">The</span> WKdm compress algorithm 1st runs a scan and classification pass, tagging and write unpacked data into temporary buffers. It follows by packing those data into the output buffer.

	<span class="enscript-keyword">The</span> temp buffers are

		<span class="enscript-keyword">uint8_t</span> 	tempTagsArray[1024]<span class="enscript-comment">;			// temporary saving for tags before final packing
		uint8_t 	tempQPosArray[1024];			// temporary saving for dict_indices before final packing
</span>		<span class="enscript-keyword">uint16_t</span> 	tempLowBitsArray[1024]<span class="enscript-comment">;			// temporary saving for partially matched lower 10 bits before final packing

</span>	<span class="enscript-keyword">Since</span> the new words (that can not matched fully or partially to the dictionary) are stored right after the header and the tags section and need no packing, we directly write them to
	<span class="enscript-keyword">the</span> destination buffer.

		<span class="enscript-keyword">uint32_t</span>	*new_word = dest_buf+3+64<span class="enscript-comment">;		// 3 words for header, 64 words for tags, new words come right after the tags.

</span>	<span class="enscript-keyword">Now</span> since we are given a byte budget for this compressor, we can monitor the byte usage on the fly in the scanning and tagging pass.

	<span class="enscript-keyword">bytes_budget</span> -= 12 + 256<span class="enscript-comment">; // header and tags (1024 * 2 /8 = 256 bytes) 

</span>	<span class="enscript-keyword">whenever</span> an input word is classified as class

		<span class="enscript-keyword">2</span> : bytes_budget-=4<span class="enscript-comment">; if (bytes_budget&lt;=0) exit -1;

</span>	<span class="enscript-keyword">when</span> writing the 8 4-bits/3 10-bits, monitor bytes_budget and exit -1 when byte_budget &lt;=0<span class="enscript-comment">;

</span>	<span class="enscript-keyword">without</span> showing the bit budget management, the pseudo code is given as follows:

	<span class="enscript-keyword">uint8_t</span> 	*tags=tempTagsArray<span class="enscript-comment">;
	uint8_t 	*dict=tempQPosArray;
</span>	<span class="enscript-keyword">uint8_t</span> 	*partial=tempLowBitsArray<span class="enscript-comment">;

</span>	<span class="enscript-keyword">for</span> (i=0<span class="enscript-comment">;i&lt;1024;i++) {
			x = *src_buf++;
</span>			<span class="enscript-keyword">if</span> (x == 0) {		// zero, 2-bits tag
					<span class="enscript-keyword">*tags++</span> = 0<span class="enscript-comment">;
			} else {
</span>
				<span class="enscript-keyword">//</span> find dict_index and dict_word from x
				<span class="enscript-keyword">k</span> = (x&gt;&gt;10)&amp;255<span class="enscript-comment">;
				dict_index = hashTable[k];
</span>				<span class="enscript-keyword">dict_word</span> = dictionary[dict_index]<span class="enscript-comment">;

</span>				<span class="enscript-keyword">if</span> (dict_word == x) { // exactly match
					<span class="enscript-keyword">//</span> 2-bits tag + 4-bits table index
					<span class="enscript-keyword">*tags++</span> = 3<span class="enscript-comment">;
					*dict++ = dict_index;
</span>				<span class="enscript-keyword">}</span> else if (((x^dict_word)&gt;&gt;10)==0) {	// 22 higher bits matched
					<span class="enscript-keyword">//</span> 2-bits tag + 4-bits table index + 10-bits lower partial
					<span class="enscript-keyword">*tags++</span> = 1<span class="enscript-comment">;
                    *dict++ = dict_index;
</span>					<span class="enscript-keyword">*partial++</span> = x &amp;0x3ff<span class="enscript-comment">;
					dictionary[dict_index] = x;
</span>				<span class="enscript-keyword">}</span> else {	// not matched
					<span class="enscript-keyword">//</span> 2-bits tag + 32-bits new word
					<span class="enscript-keyword">*tags++</span> = 2<span class="enscript-comment">;
					*new_word++ = x;
</span>					<span class="enscript-keyword">dictionary[dict_index]</span> = x<span class="enscript-comment">;
				}
</span>			<span class="enscript-keyword">}
</span>	<span class="enscript-keyword">}
</span>
	<span class="enscript-keyword">after</span> this classification/tagging pass is completed, the 3 temp buffers are packed into the output *dest_buf:

		<span class="enscript-keyword">1.</span> 1024 tags are packed into 256 bytes right after the 12-bytes header
		<span class="enscript-keyword">2.</span> dictionary indices (4-bits each) are packed into are right after the new words section
		<span class="enscript-keyword">3.</span> 3 low 10-bits are packed into a 32-bit word, this is after the dictionary indices section.

 	<span class="enscript-keyword">cclee,</span> 11/30/12

    <span class="enscript-keyword">Added</span> zero page, single value page, sparse page, early abort optimizations
    <span class="enscript-keyword">rsrini,</span> 09/14/14

*/

	<span class="enscript-keyword">.text
</span>	<span class="enscript-keyword">.align</span> 4,0x90

#define SV_RETURN           $0                      // return value when SV, ZV page is found
#define MZV_MAGIC           $17185                  // magic value used to identify MZV page encoding
#define CHKPT_BYTES         416                     // for early aborts: checkpoint after processing this many bytes. Must be in range [4..4096]
#define CHKPT_TAG_BYTES     (CHKPT_BYTES/16)        // size of the tags for  CHKPT_BYTES of data
#define CHKPT_SHRUNK_BYTES  426                     // for early aborts: max size of compressed stream to allow further processing ..
                                                    <span class="enscript-keyword">//</span>      .. to disable early aborts, set CHKPT_SHRUNK_BYTES to 4096

#if CHKPT_BYTES &gt; 4096
    <span class="enscript-keyword">#error</span> CHKPT_BYTES must be &lt;= 4096
#endif
#if CHKPT_BYTES &lt; 4
    <span class="enscript-keyword">#error</span> CHKPT_BYTES must be &gt;= 4
#endif

.globl _WKdm_compress_new
<span class="enscript-function-name">_WKdm_compress_new:</span>
	<span class="enscript-keyword">pushq</span>	%rbp
	<span class="enscript-keyword">movq</span>	%rsp, %rbp
	<span class="enscript-keyword">pushq</span>	%r15
	<span class="enscript-keyword">pushq</span>	%r14
	<span class="enscript-keyword">pushq</span>	%r13
	<span class="enscript-keyword">pushq</span>	%r12
	<span class="enscript-keyword">pushq</span>	%rbx
	<span class="enscript-keyword">subq</span>	$(48+64), %rsp

	<span class="enscript-keyword">#define</span>	tempTagsArray       64(%rsp)
	<span class="enscript-keyword">#define</span>	tempLowBitsArray	72(%rsp)

    <span class="enscript-keyword">#define</span> start_next_full_patt  80(%rsp)
    <span class="enscript-keyword">#define</span> start_next_input_word 88(%rsp)
    <span class="enscript-keyword">#define</span> byte_budget           96(%rsp)
    <span class="enscript-keyword">#define</span> start_next_qp         tempQPosArray
    <span class="enscript-keyword">#define</span> start_next_low_bits   tempLowBitsArray 
    <span class="enscript-keyword">
</span>	<span class="enscript-keyword">#define</span>	next_tag			%r8
	<span class="enscript-keyword">#define</span>	next_input_word		%rdi
	<span class="enscript-keyword">#define</span>	end_of_input		%r13
	<span class="enscript-keyword">#define</span>	next_full_patt		%rbx
	<span class="enscript-keyword">#define</span>	dict_location		%rcx
	<span class="enscript-keyword">#define</span>	next_qp				%r10
    <span class="enscript-keyword">#define</span> checkpoint          %r11
	<span class="enscript-keyword">#define</span>	dictionary			%rsp
	<span class="enscript-keyword">#define</span>	dest_buf			%r12
	<span class="enscript-keyword">#define</span>	hashTable			%r14
	<span class="enscript-keyword">#define</span> tempQPosArray		%r15
	<span class="enscript-keyword">#define</span>	next_low_bits		%rsi
	<span class="enscript-keyword">#define</span>	byte_count			%r9d

	<span class="enscript-keyword">movq</span>	%rsi, %r12						// dest_buf

	<span class="enscript-keyword">movq</span>	%rdx, tempTagsArray 			// &amp;tempTagsArray[0]
	<span class="enscript-keyword">movq</span>	%rdx, next_tag					// next_tag always points to the one following the current tag 

	<span class="enscript-keyword">leaq</span>	1024(%rdx), tempQPosArray		// &amp;tempQPosArray[0]
	<span class="enscript-keyword">movq</span>	tempQPosArray, next_qp			// next_qp

    <span class="enscript-keyword">leaq</span>    CHKPT_BYTES(%rdi), checkpoint   // checkpoint = src_buf + CHKPT_BYTES
	<span class="enscript-keyword">leaq</span>	4096(%rdi), end_of_input		// end_of_input = src_buf + num_input_words
	<span class="enscript-keyword">leaq</span>	268(%rsi), %rbx					// dest_buf + [TAGS_AREA_OFFSET + (num_input_words / 16)]*4

	<span class="enscript-keyword">movl</span>	%ecx, byte_count
	<span class="enscript-keyword">subl</span>	$(12+256), byte_count			// header + tags
	<span class="enscript-keyword">jle</span>		L_budgetExhausted

                                            <span class="enscript-keyword">//</span> NOTE: ALL THE DICTIONARY VALUES MUST BE INITIALIZED TO ZERO
                                            <span class="enscript-keyword">//</span> THIS IS NEEDED TO EFFICIENTLY DETECT SINGLE VALUE PAGES
	<span class="enscript-keyword">//</span> PRELOAD_DICTIONARY<span class="enscript-comment">;
	movl	$0, 0(dictionary)
</span>	<span class="enscript-keyword">movl</span>	$0, 4(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 8(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 12(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 16(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 20(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 24(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 28(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 32(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 36(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 40(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 44(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 48(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 52(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 56(dictionary)
	<span class="enscript-keyword">movl</span>	$0, 60(dictionary)

	<span class="enscript-keyword">leaq</span>	2048(%rdx), %rax				// &amp;tempLowBitsArray[0]
	<span class="enscript-keyword">movq</span>	%rax, tempLowBitsArray			// save for later reference
	<span class="enscript-keyword">movq</span>	%rax, next_low_bits				// next_low_bits	

	<span class="enscript-keyword">leaq</span>	_hashLookupTable_new(%rip), hashTable	// hash look up table

    <span class="enscript-keyword">movq</span>    next_full_patt, start_next_full_patt
    <span class="enscript-keyword">movq</span>    next_input_word, start_next_input_word
    <span class="enscript-keyword">movl</span>    %ecx, byte_budget               // save the byte budget    


	<span class="enscript-keyword">jmp</span>		L_scan_loop

	<span class="enscript-keyword">.align</span> 4,0x90
<span class="enscript-function-name">L_RECORD_ZERO:</span>
	<span class="enscript-keyword">movb</span>	$0, -1(next_tag)						// *next_tag = ZERO<span class="enscript-comment">;
	addq	$4, next_input_word 					// next_input_word++;
</span>	<span class="enscript-keyword">cmpq</span>	next_input_word, checkpoint             // checkpoint time?
	<span class="enscript-keyword">je</span>		CHECKPOINT

<span class="enscript-function-name">L_scan_loop:</span>
	<span class="enscript-keyword">movl</span>	(next_input_word), %edx
	<span class="enscript-keyword">incq</span>	next_tag								// next_tag++
	<span class="enscript-keyword">testl</span>	%edx, %edx
	<span class="enscript-keyword">je</span>		L_RECORD_ZERO							// if (input_word==0) RECORD_ZERO
	<span class="enscript-keyword">movl</span>	%edx, %eax								// a copy of input_word
	<span class="enscript-keyword">shrl</span>	$10, %eax								// input_high_bits = HIGH_BITS(input_word)<span class="enscript-comment">;
	movzbl	%al, %eax								// 8-bit index to the Hash Table
</span>	<span class="enscript-keyword">movsbq</span>	(hashTable,%rax),%rax					// HASH_TO_DICT_BYTE_OFFSET(input_word)
	<span class="enscript-keyword">leaq</span>	(dictionary, %rax), dict_location		// ((char*) dictionary) + HASH_TO_DICT_BYTE_OFFSET(input_word))<span class="enscript-comment">;
	movl	(dict_location), %eax					// dict_word = *dict_location;
</span>	<span class="enscript-keyword">addq</span>	$4, next_input_word						// next_input_word++
	<span class="enscript-keyword">cmpl</span>	%eax, %edx								// dict_word vs input_word
	<span class="enscript-keyword">je</span>		L_RECORD_EXACT							// if identical, RECORD_EXACT
	<span class="enscript-keyword">xorl</span>	%edx, %eax
	<span class="enscript-keyword">shrl</span>	$10, %eax								// HIGH_BITS(dict_word)
	<span class="enscript-keyword">je</span>		L_RECORD_PARTIAL						// if identical, RECORD_PARTIAL

<span class="enscript-function-name">L_RECORD_MISS:</span>
	<span class="enscript-keyword">movl</span>	%edx, (next_full_patt)					// *next_full_patt = input_word<span class="enscript-comment">;
	addq	$4, next_full_patt						// next_full_patt++ 
</span>	<span class="enscript-keyword">movl</span>	%edx, (dict_location)					// *dict_location = input_word
	<span class="enscript-keyword">movb</span>	$2, -1(next_tag)						// *next_tag = 2 for miss
	<span class="enscript-keyword">subl</span>	$4, byte_count							// fill in a new 4-bytes word
	<span class="enscript-keyword">jle</span>		L_budgetExhausted
	<span class="enscript-keyword">cmpq</span>	next_input_word, checkpoint             // checkpoint time?
	<span class="enscript-keyword">jne</span>     L_scan_loop
	<span class="enscript-keyword">jmp</span>	    CHECKPOINT	

<span class="enscript-function-name">L_done_search:</span>

	<span class="enscript-keyword">//</span> SET_QPOS_AREA_START(dest_buf,next_full_patt)<span class="enscript-comment">;
	movq	next_full_patt, %rax					// next_full_patt
</span>	<span class="enscript-keyword">subq</span>	dest_buf, %rax							// next_full_patt - dest_buf								
	<span class="enscript-keyword">sarq</span>	$2, %rax								// offset in 4-bytes
	<span class="enscript-keyword">movl</span>	%eax, %r13d								// r13d = (next_full_patt - dest_buf)
	<span class="enscript-keyword">movl</span>	%eax, 0(dest_buf)						// dest_buf[0] = next_full_patt - dest_buf
	<span class="enscript-keyword">decq</span>	next_tag
	<span class="enscript-keyword">cmpq</span>	next_tag, tempTagsArray					// &amp;tempTagsArray[0] vs next_tag
	<span class="enscript-keyword">jae</span>		L13										// if (&amp;tempTagsArray[0] &gt;= next_tag), skip the following

	<span class="enscript-keyword">//</span> boundary_tmp = WK_pack_2bits(tempTagsArray, (WK_word *) next_tag, dest_buf + HEADER_SIZE_IN_WORDS)<span class="enscript-comment">;

</span>	<span class="enscript-keyword">movq</span>	dest_buf, %rdi							// dest_buf
	<span class="enscript-keyword">movq</span>	tempTagsArray, %rcx						// &amp;tempTagsArray[0]

	<span class="enscript-keyword">.align</span> 4,0x90
<span class="enscript-function-name">L_pack_2bits:</span>
	<span class="enscript-keyword">movq</span>	8(%rcx), %rax							// w3
	<span class="enscript-keyword">addq</span>	$16, %rcx								// tempTagsArray += 16<span class="enscript-comment">;
	shlq	$4, %rax
</span>	<span class="enscript-keyword">addq</span>	$4, %rdi								// dest_buf += 4<span class="enscript-comment">;
	orq		-16(%rcx), %rax							// w3
</span>	<span class="enscript-keyword">movq</span>	%rax, %rdx
	<span class="enscript-keyword">shrq</span>	$30, %rax
	<span class="enscript-keyword">orl</span>		%edx, %eax
	<span class="enscript-keyword">cmpq</span>	%rcx, next_tag							// cmp next_tag vs dest_buf
	<span class="enscript-keyword">movl</span>	%eax, 8(%rdi)							// save at *(dest_buf + HEADER_SIZE_IN_WORDS)
	<span class="enscript-keyword">ja</span>		L_pack_2bits							// if (next_tag &gt; dest_buf) repeat L_pack_2bits

	<span class="enscript-keyword">/*</span> Pack the queue positions into the area just after the full words. */

<span class="enscript-function-name">L13:</span>
	<span class="enscript-keyword">mov</span>		next_qp, %rax							// next_qp
	<span class="enscript-keyword">sub</span>		tempQPosArray, %rax						// num_bytes_to_pack = next_qp - (char *) tempQPosArray<span class="enscript-comment">; 
	addl	$7, %eax								// num_bytes_to_pack+7
</span>	<span class="enscript-keyword">shrl</span>	$3, %eax								// num_packed_words = (num_bytes_to_pack + 7) &gt;&gt; 3

	<span class="enscript-keyword">shll</span>	$2, %eax								// turn into bytes
	<span class="enscript-keyword">subl</span>	%eax, byte_count						// 
	<span class="enscript-keyword">jl</span>		L_budgetExhausted
	<span class="enscript-keyword">shrl</span>	$1, %eax 								// num_source_words = num_packed_words * 2<span class="enscript-comment">;

</span>	<span class="enscript-keyword">leaq</span>	(tempQPosArray,%rax,4), %rcx			// endQPosArray = tempQPosArray + num_source_words
	<span class="enscript-keyword">cmpq</span>	%rcx, next_qp							// next_qp vs endQPosArray
	<span class="enscript-keyword">jae</span>		L16										// if (next_qp &gt;= endQPosArray) skip the following zero paddings
	<span class="enscript-keyword">movq</span>	%rcx, %rax
	<span class="enscript-keyword">subq</span>	next_qp, %rax
	<span class="enscript-keyword">subl</span>	$4, %eax
	<span class="enscript-keyword">jl</span>		1f
	<span class="enscript-keyword">.align</span> 4,0x90
<span class="enscript-function-name">0:</span>	movl	$0, (next_qp)	
	<span class="enscript-keyword">addq</span>	$4, next_qp
	<span class="enscript-keyword">subl</span>	$4, %eax
	<span class="enscript-keyword">jge</span>		0b
<span class="enscript-function-name">1:</span>	testl	$2, %eax
	<span class="enscript-keyword">je</span>		1f
	<span class="enscript-keyword">movw</span>	$0, (next_qp)	
	<span class="enscript-keyword">addq</span>	$2, next_qp
<span class="enscript-function-name">1:</span>	testl	$1, %eax
	<span class="enscript-keyword">je</span>		1f
	<span class="enscript-keyword">movb</span>	$0, (next_qp)	
	<span class="enscript-keyword">addq</span>	$1, next_qp
<span class="enscript-function-name">1:</span>
<span class="enscript-function-name">L16:</span>
	<span class="enscript-keyword">movq</span>	next_full_patt, %rdi					// next_full_patt
	<span class="enscript-keyword">cmpq</span>	tempQPosArray, %rcx						// endQPosArray vs tempQPosArray
	<span class="enscript-keyword">jbe</span>		L20										// if (endQPosArray &lt;= tempQPosArray) skip the following
	<span class="enscript-keyword">movq</span>	tempQPosArray, %rdx						// tempQPosArray

	<span class="enscript-keyword">/*</span> byte_count -= (rcx - tempQPosArray)/2 */

	<span class="enscript-keyword">.align</span> 4,0x90
<span class="enscript-function-name">L_pack_4bits:</span>
	<span class="enscript-keyword">movl</span>	4(%rdx), %eax							// src_next[1]
	<span class="enscript-keyword">addq</span>	$8, %rdx								// src_next += 2<span class="enscript-comment">;
	sall	$4, %eax								// (src_next[1] &lt;&lt; 4)
</span>	<span class="enscript-keyword">addq</span>	$4, %rdi								// dest_next++<span class="enscript-comment">;
	orl		-8(%rdx), %eax							// temp = src_next[0] | (src_next[1] &lt;&lt; 4)
</span>	<span class="enscript-keyword">cmpq</span>	%rdx, %rcx								// source_end vs src_next
	<span class="enscript-keyword">movl</span>	%eax, -4(%rdi)							// dest_next[0] = temp<span class="enscript-comment">;
	ja		L_pack_4bits							// while (src_next &lt; source_end) repeat the loop
</span>
	<span class="enscript-keyword">//</span> SET_LOW_BITS_AREA_START(dest_buf,boundary_tmp)<span class="enscript-comment">;
	movq	%rdi, %rax								// boundary_tmp
</span>	<span class="enscript-keyword">subq</span>	dest_buf, %rax							// boundary_tmp - dest_buf
	<span class="enscript-keyword">movq</span>	%rax, %r13								// boundary_tmp - dest_buf
	<span class="enscript-keyword">shrq</span>	$2, %r13								// boundary_tmp - dest_buf in words
<span class="enscript-function-name">L20:</span>
	<span class="enscript-keyword">movl</span>	%r13d, 4(dest_buf)						// dest_buf[1] = boundary_tmp - dest_buf

	<span class="enscript-keyword">movq</span>	tempLowBitsArray, %rcx					// tempLowBitsArray
	<span class="enscript-keyword">movq</span>	next_low_bits, %rbx						// next_low_bits
	<span class="enscript-keyword">subq</span>	%rcx, %rbx								// next_low_bits - tempLowBitsArray (in bytes)
	<span class="enscript-keyword">sarq</span>	$1, %rbx								// num_tenbits_to_pack (in half-words)

	<span class="enscript-keyword">#define</span>	size	%ebx

	<span class="enscript-keyword">subl</span>	$3, size								// pre-decrement num_tenbits_to_pack by 3
	<span class="enscript-keyword">jl</span>		1f										// if num_tenbits_to_pack &lt; 3, skip the following loop

	<span class="enscript-keyword">.align</span>	4,0x90
<span class="enscript-function-name">0:</span>
	<span class="enscript-keyword">movzwl</span>	4(%rcx), %eax							// w2	
	<span class="enscript-keyword">addq</span>	$6, %rcx								// next w0/w1/w2 triplet
	<span class="enscript-keyword">sall</span>	$10, %eax								// w1 &lt;&lt; 10
	<span class="enscript-keyword">or</span>		-4(%rcx), %ax							// w1
	<span class="enscript-keyword">addq</span>	$4, %rdi								// dest_buf++
	<span class="enscript-keyword">sall</span>	$10, %eax								// w1 &lt;&lt; 10
	<span class="enscript-keyword">or</span>		-6(%rcx), %ax							// (w0) | (w1&lt;&lt;10) | (w2&lt;&lt;20)
	<span class="enscript-keyword">subl</span>	$4, byte_count							// fill in a new 4-bytes word
	<span class="enscript-keyword">jle</span>		L_budgetExhausted
	<span class="enscript-keyword">subl</span>	$3, size								// num_tenbits_to_pack-=3
	<span class="enscript-keyword">movl</span>	%eax, -4(%rdi)							// pack w0,w1,w2 into 1 dest_buf word
	<span class="enscript-keyword">jge</span>		0b										// if no less than 3 elements, back to loop head

<span class="enscript-function-name">1:</span> 	addl	$3, size								// post-increment num_tenbits_to_pack by 3
	<span class="enscript-keyword">je</span>		3f										// if num_tenbits_to_pack is a multiple of 3, skip the following
	<span class="enscript-keyword">movzwl</span>	(%rcx), %eax							// w0
	<span class="enscript-keyword">subl</span>	$1, size								// num_tenbits_to_pack--
	<span class="enscript-keyword">je</span>		2f										//
	<span class="enscript-keyword">movzwl</span>	2(%rcx), %edx							// w1
	<span class="enscript-keyword">sall</span>	$10, %edx								// w1 &lt;&lt; 10
	<span class="enscript-keyword">orl</span>		%edx, %eax								// w0 | (w1&lt;&lt;10)
<span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">subl</span>	$4, byte_count							// fill in a new 4-bytes word
	<span class="enscript-keyword">jle</span>		L_budgetExhausted
	<span class="enscript-keyword">movl</span>	%eax, (%rdi)							// write the final dest_buf word
	<span class="enscript-keyword">addq</span>	$4, %rdi								// dest_buf++

<span class="enscript-function-name">3:</span>	movq	%rdi, %rax								// boundary_tmp
	<span class="enscript-keyword">subq</span>	dest_buf, %rax							// boundary_tmp - dest_buf
	<span class="enscript-keyword">shrq</span>	$2, %rax								// boundary_tmp - dest_buf in terms of words
	<span class="enscript-keyword">movl</span>	%eax, 8(dest_buf)						// SET_LOW_BITS_AREA_END(dest_buf,boundary_tmp)
	<span class="enscript-keyword">shlq</span>	$2, %rax								// boundary_tmp - dest_buf in terms of bytes

<span class="enscript-function-name">L_done:</span>
	<span class="enscript-keyword">//</span> restore registers and return
	<span class="enscript-keyword">addq</span>	$(48+64), %rsp
	<span class="enscript-keyword">popq</span>	%rbx
	<span class="enscript-keyword">popq</span>	%r12
	<span class="enscript-keyword">popq</span>	%r13
	<span class="enscript-keyword">popq</span>	%r14
	<span class="enscript-keyword">popq</span>	%r15
	<span class="enscript-keyword">leave
</span>	<span class="enscript-keyword">ret
</span>
    <span class="enscript-keyword">.align</span>  4
<span class="enscript-function-name">L_budgetExhausted:</span>
	<span class="enscript-keyword">mov</span>		$-1, %rax
	<span class="enscript-keyword">jmp</span>		L_done
	<span class="enscript-keyword">
</span>
	<span class="enscript-keyword">.align</span> 4,0x90
<span class="enscript-function-name">L_RECORD_EXACT:</span>
	<span class="enscript-keyword">subq</span>	dictionary, %rcx					// dict_location - dictionary
	<span class="enscript-keyword">sarq</span>	$2, %rcx							// divide by 4 for word offset
	<span class="enscript-keyword">movb</span>	$3, -1(next_tag)					// *next_tag = 3 for exact
	<span class="enscript-keyword">movb</span>	%cl, (next_qp)						// *next_qp = word offset (4-bit)
	<span class="enscript-keyword">incq</span>	next_qp								// next_qp++
	<span class="enscript-keyword">cmpq</span>	next_input_word, checkpoint         // checkpoint time?
	<span class="enscript-keyword">jne</span>     L_scan_loop
	<span class="enscript-keyword">jmp</span>	    CHECKPOINT	

	<span class="enscript-keyword">.align</span> 4,0x90
<span class="enscript-function-name">L_RECORD_PARTIAL:</span>
	<span class="enscript-keyword">movq</span>	%rcx, %rax							// dict_location
	<span class="enscript-keyword">movb</span>	$1, -1(next_tag)					// *next_tag = 1 for partial matched
	<span class="enscript-keyword">subq</span>	dictionary, %rax					// dict_location - dictionary
	<span class="enscript-keyword">movl</span>	%edx, (%rcx)						// *dict_location = input_word<span class="enscript-comment">;
	sarq	$2, %rax							// offset in 32-bit word
</span>	<span class="enscript-keyword">movb</span>	%al, (next_qp)						// update *next_qp
	<span class="enscript-keyword">andl</span>	$1023, %edx							// lower 10 bits
	<span class="enscript-keyword">incq</span>	next_qp								// next_qp++
	<span class="enscript-keyword">mov</span>		%dx, (next_low_bits)				// save next_low_bits
	<span class="enscript-keyword">addq</span>	$2, next_low_bits					// next_low_bits++
	<span class="enscript-keyword">cmpq</span>	next_input_word, checkpoint         // checkpoint time?
	<span class="enscript-keyword">jne</span>     L_scan_loop

<span class="enscript-function-name">CHECKPOINT:</span>

    <span class="enscript-keyword">cmpq</span>	end_of_input, checkpoint            // end of buffer or compression ratio check?
    <span class="enscript-keyword">jne</span>     L_check_compression_ratio

<span class="enscript-function-name">L_check_zero_page:</span>
                                                <span class="enscript-keyword">//</span> check if any dictionary misses in page
    <span class="enscript-keyword">cmpq</span>    start_next_full_patt, next_full_patt
    <span class="enscript-keyword">jne</span>     L_check_single_value_page

    <span class="enscript-keyword">cmpq</span>    start_next_qp, next_qp              // check if any partial or exact dictionary matches
    <span class="enscript-keyword">jne</span>     L_check_single_value_page

    <span class="enscript-keyword">mov</span>     SV_RETURN, %rax                     // Magic return value
    <span class="enscript-keyword">jmp</span>     L_done

<span class="enscript-function-name">L_check_single_value_page:</span>

    <span class="enscript-keyword">movq</span>    next_full_patt, %rax                // get # dictionary misses
    <span class="enscript-keyword">subq</span>    start_next_full_patt, %rax
    <span class="enscript-keyword">shrq</span>    $2, %rax
    <span class="enscript-keyword">
</span>    <span class="enscript-keyword">movq</span>    next_qp, %r11                       // get # dictionary hits (exact + partial)
    <span class="enscript-keyword">subq</span>    start_next_qp, %r11
    <span class="enscript-keyword">
</span>    <span class="enscript-keyword">movq</span>    next_low_bits, %r13                 // get # dictionary partial hits
    <span class="enscript-keyword">subq</span>    start_next_low_bits, %r13
    <span class="enscript-keyword">shrq</span>    $1, %r13

    <span class="enscript-keyword">movq</span>    tempTagsArray, %r14                 // get the address of the first tag

    <span class="enscript-keyword">//</span> Single value page if one of the follwoing is true:
    <span class="enscript-keyword">//</span>  partial == 0 AND hits == 1023 AND miss == 1 AND tag[0] == 2 (i.e. miss)
    <span class="enscript-keyword">//</span>  partial == 1 AND hits == 1024 AND tag[0] == 1 (i.e. partial)
    <span class="enscript-keyword">//
</span>    <span class="enscript-keyword">cmpq</span>    $0, %r13                            // were there 0 partial hits?
    <span class="enscript-keyword">jne</span>     1f

    <span class="enscript-keyword">cmpq</span>    $1023, %r11                         // were there 1023 dictionary hits
    <span class="enscript-keyword">jne</span>     1f

    <span class="enscript-keyword">cmpq</span>    $1, %rax                            // was there exacly 1 dictionary miss?
    <span class="enscript-keyword">jne</span>     1f 

    <span class="enscript-keyword">cmpb</span>    $2, 0(%r14)                         // was the very 1st tag a miss?
    <span class="enscript-keyword">je</span>      L_is_single_value_page

<span class="enscript-function-name">1:</span>
    <span class="enscript-keyword">cmpq</span>    $1, %r13                            // was there 1 partial hit?
    <span class="enscript-keyword">jne</span>     L_check_mostly_zero

    <span class="enscript-keyword">cmpq</span>    $1024, %r11                         // were there 1024 dictionary hits
    <span class="enscript-keyword">jne</span>     L_check_mostly_zero

    <span class="enscript-keyword">cmpb</span>    $1, 0(%r14)                         // was the very 1st tag a partial?
    <span class="enscript-keyword">jne</span>     L_check_mostly_zero
     <span class="enscript-keyword">
</span><span class="enscript-function-name">L_is_single_value_page:</span>
    <span class="enscript-keyword">
</span>    <span class="enscript-keyword">mov</span>     SV_RETURN, %rax                     // Magic return value
    <span class="enscript-keyword">jmp</span>     L_done

<span class="enscript-function-name">L_check_mostly_zero:</span>
                                                <span class="enscript-keyword">//</span> how much space will the sparse packer take?
    <span class="enscript-keyword">addq</span>    %r11, %rax                          // rax += (next_qp - start_next_qp)
    <span class="enscript-keyword">movq</span>    $6, %rdx
    <span class="enscript-keyword">mulq</span>    %rdx                                // rax *= 6 (i.e. 4 byte word + 2 byte offset)
    <span class="enscript-keyword">addq</span>    $4, %rax                            // rax += 4 byte for header
    <span class="enscript-keyword">movq</span>    %rax, %r11 
                                                <span class="enscript-keyword">//</span> how much space will the defaut packer take?
    <span class="enscript-keyword">movq</span>    next_low_bits, %rax
    <span class="enscript-keyword">subq</span>    start_next_low_bits, %rax           // get bytes consumed by lower-10 bits
    <span class="enscript-keyword">movq</span>    $1365, %rdx
    <span class="enscript-keyword">mulq</span>    %rdx
    <span class="enscript-keyword">shrq</span>    $11, %rax                           // rax = 2/3*(next_low_bits - start_next_low_bits)
    <span class="enscript-keyword">movq</span>    next_full_patt, %rdx
    <span class="enscript-keyword">subq</span>    start_next_full_patt, %rdx          // get bytes consumed by dictionary misses
    <span class="enscript-keyword">addq</span>    %rdx, %rax                          // rax += (next_full_patt - start_next_full_patt)
    <span class="enscript-keyword">movq</span>    next_qp, %rdx
    <span class="enscript-keyword">subq</span>    start_next_qp, %rdx
    <span class="enscript-keyword">shrq</span>    $1, %rdx                            // get bytes consumed by dictionary hits
    <span class="enscript-keyword">addq</span>    %rdx, %rax                          // rax += (next_qp - start_next_qp)/2
    <span class="enscript-keyword">addq</span>    $(12+256), %rax                     // rax += bytes taken by the header + tags

    <span class="enscript-keyword">cmpq</span>    %r11, %rax                          // is default packer the better option?
    <span class="enscript-keyword">jb</span>      L_done_search

    <span class="enscript-keyword">cmpl</span>    byte_budget, %r11d                  // can the sparse packer fit into the given budget?
    <span class="enscript-keyword">ja</span>      L_budgetExhausted

<span class="enscript-function-name">L_sparse_packer:</span>

    <span class="enscript-keyword">movl</span>    MZV_MAGIC, 0(dest_buf)              // header to indicate a sparse packer
    <span class="enscript-keyword">addq</span>    $4, dest_buf

    <span class="enscript-keyword">movq</span>    $0, %rdx                            // rdx = byte offset in src of non-0 word
    <span class="enscript-keyword">movq</span>    start_next_input_word, %r8
<span class="enscript-function-name">1:</span>
    <span class="enscript-keyword">movq</span>    0(%r8, %rdx), %rax                  // rax = read dword
	<span class="enscript-keyword">testq</span>	%rax, %rax                          // is dword == 0
    <span class="enscript-keyword">jne</span>     5f
<span class="enscript-function-name">3:</span>
    <span class="enscript-keyword">addq</span>    $8, %rdx                            // 8 more bytes have been processed
<span class="enscript-function-name">4:</span>
    <span class="enscript-keyword">cmpq</span>    $4096, %rdx
    <span class="enscript-keyword">jne</span>     1b
    <span class="enscript-keyword">movq</span>    %r11, %rax                          // store the size of the compressed stream
    <span class="enscript-keyword">jmp</span>     L_done

<span class="enscript-function-name">5:</span>
    <span class="enscript-keyword">testl</span>   %eax, %eax                          // is lower word == 0
    <span class="enscript-keyword">je</span>      6f
    <span class="enscript-keyword">movl</span>    %eax, 0(dest_buf)                   // store the non-0 word in the dest buffer
    <span class="enscript-keyword">mov</span>     %dx, 4(dest_buf)                    // store the byte index
    <span class="enscript-keyword">addq</span>    $6, dest_buf
<span class="enscript-function-name">6:</span>
    <span class="enscript-keyword">shrq</span>    $32, %rax                           // get the upper word into position
    <span class="enscript-keyword">testl</span>   %eax, %eax                          // is upper word == 0
    <span class="enscript-keyword">je</span>      3b
    <span class="enscript-keyword">addq</span>    $4, %rdx
    <span class="enscript-keyword">movl</span>    %eax, 0(dest_buf)                   // store the word in the dest buffer
    <span class="enscript-keyword">mov</span>     %dx, 4(dest_buf)                    // store the byte index
    <span class="enscript-keyword">addq</span>    $6, dest_buf
    <span class="enscript-keyword">addq</span>    $4, %rdx
    <span class="enscript-keyword">jmp</span>     4b

<span class="enscript-function-name">L_check_compression_ratio:</span>

    <span class="enscript-keyword">movq</span>    end_of_input, checkpoint            // checkpoint = end of buffer

    <span class="enscript-keyword">movq</span>    next_low_bits, %rax
    <span class="enscript-keyword">subq</span>    start_next_low_bits, %rax           // get bytes consumed by lower-10 bits
    <span class="enscript-keyword">movq</span>    $1365, %rdx
    <span class="enscript-keyword">mulq</span>    %rdx
    <span class="enscript-keyword">shrq</span>    $11, %rax                           // rax = 2/3*(next_low_bits - start_next_low_bits)
    <span class="enscript-keyword">
</span>    <span class="enscript-keyword">movq</span>    next_full_patt, %rdx
    <span class="enscript-keyword">subq</span>    start_next_full_patt, %rdx          // get bytes consumed by dictionary misses
    <span class="enscript-keyword">addq</span>    %rdx, %rax                          // rax += (next_full_patt - start_next_full_patt)

    <span class="enscript-keyword">movq</span>    next_qp, %rdx
    <span class="enscript-keyword">subq</span>    start_next_qp, %rdx
    <span class="enscript-keyword">shrq</span>    $1, %rdx
    <span class="enscript-keyword">addq</span>    %rdx, %rax                          // rax += (next_qp - start_next_qp)/2

    <span class="enscript-keyword">addq</span>    $CHKPT_TAG_BYTES, %rax              // rax += bytes taken by the tags
    <span class="enscript-keyword">cmpq</span>    $CHKPT_SHRUNK_BYTES, %rax
    <span class="enscript-keyword">ja</span>      L_budgetExhausted                   // compressed size exceeds budget
    <span class="enscript-keyword">jmp</span>     L_scan_loop 

</pre>
<hr />
</body></html>