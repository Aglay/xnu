<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>machine_routines_asm.s</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">machine_routines_asm.s&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 <span class="enscript-keyword">*</span> Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> This file contains Original Code and/or Modifications of Original Code
 <span class="enscript-keyword">*</span> as defined in and that are subject to the Apple Public Source License
 <span class="enscript-keyword">*</span> Version 2.0 (the 'License'). You may not use this file except in
 <span class="enscript-keyword">*</span> compliance with the License. The rights granted to you under the License
 <span class="enscript-keyword">*</span> may not be used to create, or enable the creation or redistribution of,
 <span class="enscript-keyword">*</span> unlawful or unlicensed copies of an Apple operating system, or to
 <span class="enscript-keyword">*</span> circumvent, violate, or enable the circumvention or violation of, any
 <span class="enscript-keyword">*</span> terms of an Apple operating system software license agreement.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> Please obtain a copy of the License at
 <span class="enscript-keyword">*</span> <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> The Original Code and all software distributed under the License are
 <span class="enscript-keyword">*</span> distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 <span class="enscript-keyword">*</span> EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 <span class="enscript-keyword">*</span> INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 <span class="enscript-keyword">*</span> FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 <span class="enscript-keyword">*</span> Please see the License for the specific language governing rights and
 <span class="enscript-keyword">*</span> limitations under the License.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 <span class="enscript-keyword">*/
</span> <span class="enscript-keyword">
</span>#include &lt;i386/asm.h&gt;
#include &lt;i386/rtclock_asm.h&gt;
#include &lt;i386/proc_reg.h&gt;
#include &lt;i386/eflags.h&gt;
       <span class="enscript-keyword">
</span>#include &lt;i386/postcode.h&gt;
#include &lt;i386/apic.h&gt;
#include &lt;i386/vmx/vmx_asm.h&gt;
#include &lt;assym.s&gt;

/*
**      ml_get_timebase()
**
**      Returns TSC in RAX
**
*/
ENTRY(ml_get_timebase)

	<span class="enscript-keyword">lfence
</span>	<span class="enscript-keyword">rdtsc
</span>	<span class="enscript-keyword">lfence
</span>        <span class="enscript-keyword">shlq</span>	$32,%rdx 
        <span class="enscript-keyword">orq</span>	%rdx,%rax
			<span class="enscript-keyword">
</span>	<span class="enscript-keyword">ret
</span>
/*
 <span class="enscript-keyword">*</span>  	Convert between various timer units 
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	This code converts 64-bit time units to other units.
 <span class="enscript-keyword">*</span>	For example, the TSC is converted to HPET units.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Time is a 64-bit integer that is some number of ticks.
 <span class="enscript-keyword">*</span>	Conversion is 64-bit fixed point number which is composed
 <span class="enscript-keyword">*</span>	of a 32 bit integer and a 32 bit fraction. 
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	The time ticks are multiplied by the conversion factor.  The
 <span class="enscript-keyword">*</span>	calculations are done as a 128-bit value but both the high
 <span class="enscript-keyword">*</span>	and low words are dropped.  The high word is overflow and the
 <span class="enscript-keyword">*</span>	low word is the fraction part of the result.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	We return a 64-bit value.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Note that we can use this function to multiply 2 conversion factors.
 <span class="enscript-keyword">*</span>	We do this in order to calculate the multiplier used to convert
 <span class="enscript-keyword">*</span>	directly between any two units.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	uint64_t tmrCvt(uint64_t time,		// %rdi
 <span class="enscript-keyword">*</span>			uint64_t conversion)	// %rsi
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>ENTRY(tmrCvt)
	<span class="enscript-keyword">cmpq</span>	$1,%rsi				/* check for unity fastpath */
	<span class="enscript-keyword">je</span>	1f
	<span class="enscript-keyword">movq</span>	%rdi,%rax
	<span class="enscript-keyword">mulq</span>	%rsi				/* result is %rdx:%rax */
	<span class="enscript-keyword">shrdq</span>   $32,%rdx,%rax			/* %rdx:%rax &gt;&gt;= 32 */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	%rdi,%rax
	<span class="enscript-keyword">ret
</span>
 <span class="enscript-keyword">/*
</span> <span class="enscript-keyword">*</span> void _rtc_nanotime_adjust(
 <span class="enscript-keyword">*</span>		uint64_t        tsc_base_delta,	// %rdi
 <span class="enscript-keyword">*</span>		rtc_nanotime_t  *dst)<span class="enscript-comment">;		// %rsi
 */
</span>ENTRY(_rtc_nanotime_adjust)
	<span class="enscript-keyword">movl</span>	RNT_GENERATION(%rsi),%eax	/* get current generation */
	<span class="enscript-keyword">movl</span>	$0,RNT_GENERATION(%rsi)		/* flag data as being updated */
	<span class="enscript-keyword">addq</span>	%rdi,RNT_TSC_BASE(%rsi)

	<span class="enscript-keyword">incl</span>	%eax				/* next generation */
	<span class="enscript-keyword">jnz</span>	1f
	<span class="enscript-keyword">incl</span>	%eax				/* skip 0, which is a flag */
<span class="enscript-function-name">1:</span>	movl	%eax,RNT_GENERATION(%rsi)	/* update generation */

	<span class="enscript-keyword">ret
</span>
/*
 <span class="enscript-keyword">*</span> uint64_t _rtc_nanotime_read(rtc_nanotime_t *rntp)<span class="enscript-comment">;
 *
</span> <span class="enscript-keyword">*</span> This is the same as the commpage nanotime routine, except that it uses the
 <span class="enscript-keyword">*</span> kernel internal <span class="enscript-string">&quot;rtc_nanotime_info&quot;</span> data instead of the commpage data.
 <span class="enscript-keyword">*</span> These two copies of data are kept in sync by rtc_clock_napped().
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> Warning!  There are several copies of this code in the trampolines found in
 <span class="enscript-keyword">*</span> osfmk/x86_64/idt64.s, coming from the various TIMER macros in rtclock_asm.h.
 <span class="enscript-keyword">*</span> They're all kept in sync by using the RTC_NANOTIME_READ() macro.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> The algorithm we use is:
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	ns = ((((rdtsc - rnt_tsc_base)&lt;&lt;rnt_shift)*rnt_tsc_scale) / 2**32) + rnt_ns_base<span class="enscript-comment">;
 *
</span> <span class="enscript-keyword">*</span> rnt_shift, a constant computed during initialization, is the smallest value for which:
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	(tscFreq &lt;&lt; rnt_shift) &gt; SLOW_TSC_THRESHOLD
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> Where SLOW_TSC_THRESHOLD is about 10e9.  Since most processor's tscFreqs are greater
 <span class="enscript-keyword">*</span> than 1GHz, rnt_shift is usually 0.  rnt_tsc_scale is also a 32-bit constant:
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	rnt_tsc_scale = (10e9 * 2**32) / (tscFreq &lt;&lt; rnt_shift)<span class="enscript-comment">;
 *
</span> <span class="enscript-keyword">*</span> On 64-bit processors this algorithm could be simplified by doing a 64x64 bit
 <span class="enscript-keyword">*</span> multiply of rdtsc by tscFCvtt2n:
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	ns = (((rdtsc - rnt_tsc_base) * tscFCvtt2n) / 2**32) + rnt_ns_base<span class="enscript-comment">;
 *
</span> <span class="enscript-keyword">*</span> We don't do so in order to use the same algorithm in 32- and 64-bit mode.
 <span class="enscript-keyword">*</span> When U32 goes away, we should reconsider.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> Since this routine is not synchronized and can be called in any context, 
 <span class="enscript-keyword">*</span> we use a generation count to guard against seeing partially updated data.
 <span class="enscript-keyword">*</span> In addition, the _rtc_nanotime_store() routine zeroes the generation before
 <span class="enscript-keyword">*</span> updating the data, and stores the nonzero generation only after all fields
 <span class="enscript-keyword">*</span> have been stored.  Because IA32 guarantees that stores by one processor
 <span class="enscript-keyword">*</span> must be seen in order by another, we can avoid using a lock.  We spin while
 <span class="enscript-keyword">*</span> the generation is zero.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> unint64_t _rtc_nanotime_read(
 <span class="enscript-keyword">*</span>			rtc_nanotime_t *rntp)<span class="enscript-comment">;		// %rdi
 *
</span> <span class="enscript-keyword">*/
</span>ENTRY(_rtc_nanotime_read)

	<span class="enscript-keyword">PAL_RTC_NANOTIME_READ_FAST()
</span>
	<span class="enscript-keyword">ret
</span>    <span class="enscript-keyword">
</span>/*
 <span class="enscript-keyword">*</span> extern uint64_t _rtc_tsc_to_nanoseconds(
 <span class="enscript-keyword">*</span>          uint64_t    value,              // %rdi
 <span class="enscript-keyword">*</span>          pal_rtc_nanotime_t	*rntp)<span class="enscript-comment">;     // %rsi
 *
</span> <span class="enscript-keyword">*</span> Converts TSC units to nanoseconds, using an abbreviated form of the above
 <span class="enscript-keyword">*</span> algorithm.  Note that while we could have simply used tmrCvt(value,tscFCvtt2n),
 <span class="enscript-keyword">*</span> which would avoid the need for this asm, doing so is a bit more risky since
 <span class="enscript-keyword">*</span> we'd be using a different algorithm with possibly different rounding etc.
 <span class="enscript-keyword">*/
</span>
ENTRY(_rtc_tsc_to_nanoseconds)
	<span class="enscript-keyword">movq</span>    %rdi,%rax			/* copy value (in TSC units) to convert */
	<span class="enscript-keyword">movl</span>    RNT_SHIFT(%rsi),%ecx
	<span class="enscript-keyword">movl</span>    RNT_SCALE(%rsi),%edx
	<span class="enscript-keyword">shlq</span>    %cl,%rax			/* tscUnits &lt;&lt; shift */
	<span class="enscript-keyword">mulq</span>    %rdx				/* (tscUnits &lt;&lt; shift) * scale */
	<span class="enscript-keyword">shrdq</span>   $32,%rdx,%rax			/* %rdx:%rax &gt;&gt;= 32 */
	<span class="enscript-keyword">ret
</span>    <span class="enscript-keyword">
</span>    <span class="enscript-keyword">
</span>
Entry(call_continuation)
	<span class="enscript-keyword">movq</span>	%rdi,%rcx			/* get continuation */
	<span class="enscript-keyword">movq</span>	%rsi,%rdi			/* continuation param */
	<span class="enscript-keyword">movq</span>	%rdx,%rsi			/* wait result */
	<span class="enscript-keyword">movq</span>	%gs:CPU_KERNEL_STACK,%rsp	/* set the stack */
	<span class="enscript-keyword">xorq</span>	%rbp,%rbp			/* zero frame pointer */
	<span class="enscript-keyword">call</span>	*%rcx				/* call continuation */
	<span class="enscript-keyword">movq</span>	%gs:CPU_ACTIVE_THREAD,%rdi
	<span class="enscript-keyword">call</span>	EXT(thread_terminate)

Entry(x86_init_wrapper)
	<span class="enscript-keyword">xor</span>	%rbp, %rbp
	<span class="enscript-keyword">movq</span>	%rsi, %rsp
	<span class="enscript-keyword">callq</span>	*%rdi

#if CONFIG_VMX

/*
 <span class="enscript-keyword">*</span>	__vmxon -- Enter VMX Operation
 <span class="enscript-keyword">*</span>	int __vmxon(addr64_t v)<span class="enscript-comment">;
 */
</span>Entry(__vmxon)
	<span class="enscript-keyword">FRAME
</span>	<span class="enscript-keyword">push</span>	%rdi
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">mov</span>	$(VMX_FAIL_INVALID), %ecx
	<span class="enscript-keyword">mov</span>	$(VMX_FAIL_VALID), %edx
	<span class="enscript-keyword">mov</span>	$(VMX_SUCCEED), %eax
	<span class="enscript-keyword">vmxon</span>	(%rsp)
	<span class="enscript-keyword">cmovcl</span> 	%ecx, %eax	/* CF = 1, ZF = 0 */
	<span class="enscript-keyword">cmovzl</span>	%edx, %eax	/* CF = 0, ZF = 1 */

	<span class="enscript-keyword">pop</span>	%rdi
	<span class="enscript-keyword">EMARF
</span>	<span class="enscript-keyword">ret
</span>
/*
 <span class="enscript-keyword">*</span>	__vmxoff -- Leave VMX Operation
 <span class="enscript-keyword">*</span>	int __vmxoff(void)<span class="enscript-comment">;
 */
</span>Entry(__vmxoff)
	<span class="enscript-keyword">FRAME
</span>	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">mov</span>	$(VMX_FAIL_INVALID), %ecx
	<span class="enscript-keyword">mov</span>	$(VMX_FAIL_VALID), %edx
	<span class="enscript-keyword">mov</span>	$(VMX_SUCCEED), %eax
	<span class="enscript-keyword">vmxoff
</span>	<span class="enscript-keyword">cmovcl</span> 	%ecx, %eax	/* CF = 1, ZF = 0 */
	<span class="enscript-keyword">cmovzl</span>	%edx, %eax	/* CF = 0, ZF = 1 */

	<span class="enscript-keyword">EMARF
</span>	<span class="enscript-keyword">ret
</span>
#endif /* CONFIG_VMX */

/*
 <span class="enscript-keyword">*</span>	mfence -- Memory Barrier
 <span class="enscript-keyword">*</span>	Use out-of-line assembly to get
 <span class="enscript-keyword">*</span>	standard x86-64 ABI guarantees
 <span class="enscript-keyword">*</span>	about what the caller's codegen
 <span class="enscript-keyword">*</span>	has in registers vs. memory
 <span class="enscript-keyword">*/
</span>Entry(do_mfence)
	<span class="enscript-keyword">mfence
</span>	<span class="enscript-keyword">ret
</span></pre>
<hr />
</body></html>