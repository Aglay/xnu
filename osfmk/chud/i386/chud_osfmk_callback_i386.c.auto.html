<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>chud_osfmk_callback_i386.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">chud_osfmk_callback_i386.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/trap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/lapic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_TIMER_CALLBACK_CANCEL</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_TIMER_CALLBACK_ENTER</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_TIMER_CALLBACK</span>		2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_AST_SEND</span>			3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_AST_CALLBACK</span>		4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_CPUSIG_SEND</span>		5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHUD_CPUSIG_CALLBACK</span>		6

__private_extern__
<span class="enscript-type">void</span> <span class="enscript-function-name">chudxnu_cancel_all_callbacks</span>(<span class="enscript-type">void</span>)
{
    chudxnu_cpusig_callback_cancel();
    chudxnu_cpu_timer_callback_cancel_all();
    chudxnu_interrupt_callback_cancel();
    chudxnu_perfmon_ast_callback_cancel();
    chudxnu_kdebug_callback_cancel();
    chudxnu_trap_callback_cancel();
	chudxnu_syscall_callback_cancel();
	chudxnu_dtrace_callback_cancel();
}

<span class="enscript-type">static</span> lck_grp_t	chud_request_lck_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	chud_request_lck_grp_attr;
<span class="enscript-type">static</span> lck_attr_t	chud_request_lck_attr;


<span class="enscript-type">static</span> chudcpu_data_t chudcpu_boot_cpu;
<span class="enscript-type">void</span> *
<span class="enscript-function-name">chudxnu_cpu_alloc</span>(boolean_t boot_processor)
{
	chudcpu_data_t	*chud_proc_info;

	<span class="enscript-keyword">if</span> (boot_processor) {
		chud_proc_info = &amp;chudcpu_boot_cpu;

		lck_attr_setdefault(&amp;chud_request_lck_attr);
		lck_grp_attr_setdefault(&amp;chud_request_lck_grp_attr);
		lck_grp_init(&amp;chud_request_lck_grp, <span class="enscript-string">&quot;chud_request&quot;</span>, &amp;chud_request_lck_grp_attr);

	} <span class="enscript-keyword">else</span> {
		chud_proc_info = (chudcpu_data_t *)
					kalloc(<span class="enscript-keyword">sizeof</span>(chudcpu_data_t));
		<span class="enscript-keyword">if</span> (chud_proc_info == (chudcpu_data_t *)NULL) {
			<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *)NULL;
		}
	}
	bzero((<span class="enscript-type">char</span> *)chud_proc_info, <span class="enscript-keyword">sizeof</span>(chudcpu_data_t));
	chud_proc_info-&gt;t_deadline = 0xFFFFFFFFFFFFFFFFULL;

	mpqueue_init(&amp;chud_proc_info-&gt;cpu_request_queue, &amp;chud_request_lck_grp, &amp;chud_request_lck_attr);

	<span class="enscript-comment">/* timer_call_cancel() can be called before first usage, so init here: &lt;rdar://problem/9320202&gt; */</span>
	timer_call_setup(&amp;(chud_proc_info-&gt;cpu_timer_call), NULL, NULL);


	<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *)chud_proc_info;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_cpu_free</span>(<span class="enscript-type">void</span> *cp)
{
	<span class="enscript-keyword">if</span> (cp == NULL || cp == (<span class="enscript-type">void</span> *)&amp;chudcpu_boot_cpu) {
		<span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> {
		kfree(cp,<span class="enscript-keyword">sizeof</span>(chudcpu_data_t));
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_private_cpu_timer_callback</span>(
	timer_call_param_t param0,
	timer_call_param_t param1)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">param0</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">param1</span>)
	chudcpu_data_t			*chud_proc_info;
	boolean_t			oldlevel;
	x86_thread_state_t 		state;
	mach_msg_type_number_t		count;
	chudxnu_cpu_timer_callback_func_t fn;

	oldlevel = ml_set_interrupts_enabled(FALSE);
	chud_proc_info = (chudcpu_data_t *)(current_cpu_datap()-&gt;cpu_chud);

	count = x86_THREAD_STATE_COUNT;
	<span class="enscript-keyword">if</span> (chudxnu_thread_get_state(current_thread(),
				     x86_THREAD_STATE,
				     (thread_state_t)&amp;state,
				     &amp;count,
				     FALSE) == KERN_SUCCESS) {
			fn = chud_proc_info-&gt;cpu_timer_callback_fn;
       		<span class="enscript-keyword">if</span> (fn) {
       			(fn)(
				x86_THREAD_STATE,
				(thread_state_t)&amp;state,
				count);
       		} 
	} 
	
	ml_set_interrupts_enabled(oldlevel);
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_cpu_timer_callback_enter</span>(
	chudxnu_cpu_timer_callback_func_t	func,
	uint32_t				time,
	uint32_t				units)
{
	chudcpu_data_t	*chud_proc_info;
	boolean_t	oldlevel;

	oldlevel = ml_set_interrupts_enabled(FALSE);
	chud_proc_info = (chudcpu_data_t *)(current_cpu_datap()-&gt;cpu_chud);

	<span class="enscript-comment">// cancel any existing callback for this cpu
</span>	timer_call_cancel(&amp;(chud_proc_info-&gt;cpu_timer_call));

	chud_proc_info-&gt;cpu_timer_callback_fn = func;

	clock_interval_to_deadline(time, units, &amp;(chud_proc_info-&gt;t_deadline));
	timer_call_setup(&amp;(chud_proc_info-&gt;cpu_timer_call),
			 chudxnu_private_cpu_timer_callback, NULL);
	timer_call_enter(&amp;(chud_proc_info-&gt;cpu_timer_call),
			 chud_proc_info-&gt;t_deadline,
			 TIMER_CALL_SYS_CRITICAL|TIMER_CALL_LOCAL);

	ml_set_interrupts_enabled(oldlevel);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_cpu_timer_callback_cancel</span>(<span class="enscript-type">void</span>)
{
	chudcpu_data_t	*chud_proc_info;
	boolean_t	oldlevel;

	oldlevel = ml_set_interrupts_enabled(FALSE);
	chud_proc_info = (chudcpu_data_t *)(current_cpu_datap()-&gt;cpu_chud);

	timer_call_cancel(&amp;(chud_proc_info-&gt;cpu_timer_call));

	<span class="enscript-comment">// set to max value:
</span>	chud_proc_info-&gt;t_deadline |= ~(chud_proc_info-&gt;t_deadline);
	chud_proc_info-&gt;cpu_timer_callback_fn = NULL;

	ml_set_interrupts_enabled(oldlevel);
 	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_cpu_timer_callback_cancel_all</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	cpu;
	chudcpu_data_t	*chud_proc_info;

	<span class="enscript-keyword">for</span>(cpu=0; cpu &lt; real_ncpus; cpu++) {
		chud_proc_info = (chudcpu_data_t *) cpu_data_ptr[cpu]-&gt;cpu_chud;
		<span class="enscript-keyword">if</span> (chud_proc_info == NULL)
			<span class="enscript-keyword">continue</span>;
		timer_call_cancel(&amp;(chud_proc_info-&gt;cpu_timer_call));
		chud_proc_info-&gt;t_deadline |= ~(chud_proc_info-&gt;t_deadline);
		chud_proc_info-&gt;cpu_timer_callback_fn = NULL;
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">trap</span> ****
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">chud_null_trap</span>(uint32_t trapentry, thread_flavor_t flavor,
	thread_state_t tstate,  mach_msg_type_number_t count);
<span class="enscript-type">static</span> chudxnu_trap_callback_func_t trap_callback_fn = chud_null_trap;

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">chud_null_trap</span>(uint32_t trapentry __unused, thread_flavor_t flavor __unused,
	thread_state_t tstate __unused,  mach_msg_type_number_t count __unused) {
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">chudxnu_private_trap_callback</span>(
	<span class="enscript-type">int</span> trapno,
	<span class="enscript-type">void</span>			*regs,
	<span class="enscript-type">int</span>			unused1,
	<span class="enscript-type">int</span>			unused2)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">regs</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">unused1</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">unused2</span>)
	kern_return_t retval = KERN_FAILURE;
	chudxnu_trap_callback_func_t fn = trap_callback_fn;

	<span class="enscript-keyword">if</span>(fn) {
		boolean_t oldlevel;
		x86_thread_state_t state;
		mach_msg_type_number_t count;
		thread_t thread = current_thread();
		
		oldlevel = ml_set_interrupts_enabled(FALSE);
		
		<span class="enscript-comment">/* prevent reentry into CHUD when dtracing */</span>
		<span class="enscript-keyword">if</span>(thread-&gt;t_chud &amp; T_IN_CHUD) {
			<span class="enscript-comment">/* restore interrupts */</span>
			ml_set_interrupts_enabled(oldlevel);

			<span class="enscript-keyword">return</span> KERN_FAILURE;	<span class="enscript-comment">// not handled - pass off to dtrace
</span>		}

		<span class="enscript-comment">/* update the chud state bits */</span>
		thread-&gt;t_chud |= T_IN_CHUD;

		count = x86_THREAD_STATE_COUNT;
		
		<span class="enscript-keyword">if</span>(chudxnu_thread_get_state(thread,
				x86_THREAD_STATE,
				(thread_state_t)&amp;state,
				&amp;count,
				FALSE) == KERN_SUCCESS) {
		  
					retval = (fn)(
						trapno,
						x86_THREAD_STATE,
						(thread_state_t)&amp;state,
						count);
		}

		<span class="enscript-comment">/* no longer in CHUD */</span>
		thread-&gt;t_chud &amp;= ~(T_IN_CHUD);

		ml_set_interrupts_enabled(oldlevel);
	}

	<span class="enscript-keyword">return</span> retval;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_trap_callback_enter</span>(chudxnu_trap_callback_func_t func)
{
	<span class="enscript-keyword">if</span>(OSCompareAndSwapPtr(NULL, chudxnu_private_trap_callback, 
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;perfTrapHook)) {

		chudxnu_trap_callback_func_t old = trap_callback_fn;
		<span class="enscript-keyword">while</span>(!OSCompareAndSwapPtr(old, func, 
			(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;trap_callback_fn)) {
			old = trap_callback_fn;
		}
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_trap_callback_cancel</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span>(OSCompareAndSwapPtr(chudxnu_private_trap_callback,  NULL,
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;perfTrapHook)) {

		chudxnu_trap_callback_func_t old = trap_callback_fn;
		<span class="enscript-keyword">while</span>(!OSCompareAndSwapPtr(old, chud_null_trap, 
			(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;trap_callback_fn)) {
			old = trap_callback_fn;
		}
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">ast</span> ****
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">chud_null_ast</span>(thread_flavor_t flavor, thread_state_t tstate,  
	mach_msg_type_number_t count);
<span class="enscript-type">static</span> chudxnu_perfmon_ast_callback_func_t perfmon_ast_callback_fn = chud_null_ast;

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">chud_null_ast</span>(thread_flavor_t flavor __unused,
	thread_state_t tstate __unused,  mach_msg_type_number_t count __unused) {
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">chudxnu_private_chud_ast_callback</span>(ast_t reasons, ast_t *myast)
{	
	boolean_t oldlevel = ml_set_interrupts_enabled(FALSE);
	kern_return_t retval = KERN_FAILURE;
	chudxnu_perfmon_ast_callback_func_t fn = perfmon_ast_callback_fn;
	
	<span class="enscript-keyword">if</span> (fn) {
		<span class="enscript-keyword">if</span> ((*myast &amp; AST_CHUD_URGENT) &amp;&amp; (reasons &amp; (AST_URGENT | AST_CHUD_URGENT))) { <span class="enscript-comment">// Only execute urgent callbacks if reasons specifies an urgent context.
</span>			*myast &amp;= ~AST_CHUD_URGENT;
			
			<span class="enscript-keyword">if</span> (AST_URGENT == *myast) { <span class="enscript-comment">// If the only flag left is AST_URGENT, we can clear it; we know that we set it, but if there are also other bits set in reasons then someone else might still need AST_URGENT, so we'll leave it set.  The normal machinery in ast_taken will ensure it gets cleared eventually, as necessary.
</span>				*myast = AST_NONE;
			}
			
			retval = KERN_SUCCESS;
		}
		
		<span class="enscript-keyword">if</span> ((*myast &amp; AST_CHUD) &amp;&amp; (reasons &amp; AST_CHUD)) { <span class="enscript-comment">// Only execute non-urgent callbacks if reasons actually specifies AST_CHUD.  This implies non-urgent callbacks since the only time this'll happen is if someone either calls ast_taken with AST_CHUD explicitly (not done at time of writing, but possible) or with AST_ALL, which of course includes AST_CHUD.
</span>			*myast &amp;= ~AST_CHUD;
			retval = KERN_SUCCESS;
		}
	
		<span class="enscript-keyword">if</span> (KERN_SUCCESS == retval) {
			x86_thread_state_t state;
			mach_msg_type_number_t count = x86_THREAD_STATE_COUNT;
			thread_t thread = current_thread();
			
			<span class="enscript-keyword">if</span> (KERN_SUCCESS == chudxnu_thread_get_state(thread,
														 x86_THREAD_STATE,
														 (thread_state_t)&amp;state,
														 &amp;count,
														 (thread-&gt;task != kernel_task))) {
				(fn)(x86_THREAD_STATE, (thread_state_t)&amp;state, count);
			}
		}
	}
    
	ml_set_interrupts_enabled(oldlevel);
	<span class="enscript-keyword">return</span> retval;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_perfmon_ast_callback_enter</span>(chudxnu_perfmon_ast_callback_func_t func)
{
	<span class="enscript-keyword">if</span>(OSCompareAndSwapPtr(NULL, chudxnu_private_chud_ast_callback,
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;perfASTHook)) {
		chudxnu_perfmon_ast_callback_func_t old = perfmon_ast_callback_fn;

		<span class="enscript-keyword">while</span>(!OSCompareAndSwapPtr(old, func,
			(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;perfmon_ast_callback_fn)) {
			old = perfmon_ast_callback_fn;
		}

		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_perfmon_ast_callback_cancel</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span>(OSCompareAndSwapPtr(chudxnu_private_chud_ast_callback, NULL,
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;perfASTHook)) {
		chudxnu_perfmon_ast_callback_func_t old = perfmon_ast_callback_fn;

		<span class="enscript-keyword">while</span>(!OSCompareAndSwapPtr(old, chud_null_ast,
			(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;perfmon_ast_callback_fn)) {
			old = perfmon_ast_callback_fn;
		}

		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_perfmon_ast_send_urgent</span>(boolean_t urgent)
{
    boolean_t oldlevel = ml_set_interrupts_enabled(FALSE);
	ast_t *myast = ast_pending();

    <span class="enscript-keyword">if</span>(urgent) {
        *myast |= (AST_CHUD_URGENT | AST_URGENT);
    } <span class="enscript-keyword">else</span> {
        *myast |= (AST_CHUD);
    }

    ml_set_interrupts_enabled(oldlevel);
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">interrupt</span> ****
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">chud_null_int</span>(uint32_t trapentry, thread_flavor_t flavor, 
	thread_state_t tstate,  mach_msg_type_number_t count);
<span class="enscript-type">static</span> chudxnu_interrupt_callback_func_t interrupt_callback_fn = chud_null_int;

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">chud_null_int</span>(uint32_t trapentry __unused, thread_flavor_t flavor __unused,
	thread_state_t tstate __unused,  mach_msg_type_number_t count __unused) {
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_private_interrupt_callback</span>(<span class="enscript-type">void</span> *foo) __attribute__((used));

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_private_interrupt_callback</span>(<span class="enscript-type">void</span> *foo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">foo</span>)
	chudxnu_interrupt_callback_func_t fn = interrupt_callback_fn;

	<span class="enscript-keyword">if</span>(fn) {
		boolean_t			oldlevel;
		x86_thread_state_t		state;
		mach_msg_type_number_t		count;

		oldlevel = ml_set_interrupts_enabled(FALSE);

		count = x86_THREAD_STATE_COUNT;
		<span class="enscript-keyword">if</span>(chudxnu_thread_get_state(current_thread(),
					    x86_THREAD_STATE,
					    (thread_state_t)&amp;state,
					    &amp;count,
					    FALSE) == KERN_SUCCESS) {
			(fn)(
				X86_INTERRUPT_PERFMON,
				x86_THREAD_STATE,
				(thread_state_t)&amp;state,
				count);
		}
		ml_set_interrupts_enabled(oldlevel);
	}
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_interrupt_callback_enter</span>(chudxnu_interrupt_callback_func_t func)
{
	<span class="enscript-keyword">if</span>(OSCompareAndSwapPtr(chud_null_int, func, 
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;interrupt_callback_fn)) {
		lapic_set_pmi_func((i386_intr_func_t)chudxnu_private_interrupt_callback);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
    <span class="enscript-keyword">return</span> KERN_FAILURE;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_interrupt_callback_cancel</span>(<span class="enscript-type">void</span>)
{
	chudxnu_interrupt_callback_func_t old = interrupt_callback_fn;

	<span class="enscript-keyword">while</span>(!OSCompareAndSwapPtr(old, chud_null_int,
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;interrupt_callback_fn)) {
		old = interrupt_callback_fn;
	}

    lapic_set_pmi_func(NULL);
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">cpu</span> <span class="enscript-variable-name">signal</span> ****
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> chudxnu_cpusig_callback_func_t cpusig_callback_fn = NULL;

<span class="enscript-type">static</span>          kern_return_t
<span class="enscript-function-name">chudxnu_private_cpu_signal_handler</span>(<span class="enscript-type">int</span> request)
{
	chudxnu_cpusig_callback_func_t fn = cpusig_callback_fn;
	
	<span class="enscript-keyword">if</span> (fn) {
	x86_thread_state_t  state;
		mach_msg_type_number_t count = x86_THREAD_STATE_COUNT;

		<span class="enscript-keyword">if</span> (chudxnu_thread_get_state(current_thread(),
					     x86_THREAD_STATE,
					     (thread_state_t) &amp;state, &amp;count,
					     FALSE) == KERN_SUCCESS) {
			<span class="enscript-keyword">return</span> (fn)(
					request, x86_THREAD_STATE,
					(thread_state_t) &amp;state, count);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS; <span class="enscript-comment">//ignored
</span>}
<span class="enscript-comment">/*
 * chudxnu_cpu_signal_handler() is called from the IPI handler
 * when a CHUD signal arrives from another processor.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_cpu_signal_handler</span>(<span class="enscript-type">void</span>)
{
	chudcpu_signal_request_t	*reqp;
	chudcpu_data_t			*chudinfop;

	chudinfop = (chudcpu_data_t *) current_cpu_datap()-&gt;cpu_chud;

	mpdequeue_head(&amp;(chudinfop-&gt;cpu_request_queue),
		       (queue_entry_t *) &amp;reqp);
	<span class="enscript-keyword">while</span> (reqp != NULL) {
		chudxnu_private_cpu_signal_handler(reqp-&gt;req_code);
		reqp-&gt;req_sync = 0;
		mpdequeue_head(&amp;(chudinfop-&gt;cpu_request_queue),
			       (queue_entry_t *) &amp;reqp);
	}
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_cpusig_callback_enter</span>(chudxnu_cpusig_callback_func_t func)
{
	<span class="enscript-keyword">if</span>(OSCompareAndSwapPtr(NULL, func, 
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;cpusig_callback_fn)) {
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_cpusig_callback_cancel</span>(<span class="enscript-type">void</span>)
{
	chudxnu_cpusig_callback_func_t old = cpusig_callback_fn;

	<span class="enscript-keyword">while</span>(!OSCompareAndSwapPtr(old, NULL,
		(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;cpusig_callback_fn)) {
		old = cpusig_callback_fn;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_cpusig_send</span>(<span class="enscript-type">int</span> otherCPU, uint32_t request_code)
{
	<span class="enscript-type">int</span>				thisCPU;
	kern_return_t			retval = KERN_FAILURE;
	chudcpu_signal_request_t	request;
	uint64_t			deadline;
	chudcpu_data_t			*target_chudp;
	boolean_t old_level;

	disable_preemption();
	<span class="enscript-comment">// force interrupts on for a cross CPU signal.
</span>	old_level = chudxnu_set_interrupts_enabled(TRUE);
	thisCPU = cpu_number();

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>) otherCPU &lt; real_ncpus &amp;&amp;
	    thisCPU != otherCPU &amp;&amp;
	    cpu_data_ptr[otherCPU]-&gt;cpu_running) {

		target_chudp = (chudcpu_data_t *)
					cpu_data_ptr[otherCPU]-&gt;cpu_chud;

		<span class="enscript-comment">/* Fill out request */</span>
		request.req_sync = 0xFFFFFFFF;		<span class="enscript-comment">/* set sync flag */</span>
		<span class="enscript-comment">//request.req_type = CPRQchud;		/* set request type */
</span>		request.req_code = request_code;	<span class="enscript-comment">/* set request */</span>

		<span class="enscript-comment">/*
		 * Insert the new request in the target cpu's request queue
		 * and signal target cpu.
		 */</span>
		mpenqueue_tail(&amp;target_chudp-&gt;cpu_request_queue,
			       &amp;request.req_entry);
		i386_signal_cpu(otherCPU, MP_CHUD, ASYNC);

		<span class="enscript-comment">/* Wait for response or timeout */</span>
		deadline = mach_absolute_time() + LockTimeOut;
		<span class="enscript-keyword">while</span> (request.req_sync != 0) {
			<span class="enscript-keyword">if</span> (mach_absolute_time() &gt; deadline) {
				panic(<span class="enscript-string">&quot;chudxnu_cpusig_send(%d,%d) timed out\n&quot;</span>,
					otherCPU, request_code);
			}
			cpu_pause();
		}
		retval = KERN_SUCCESS;
	} <span class="enscript-keyword">else</span> {
		retval = KERN_INVALID_ARGUMENT;
	}

	chudxnu_set_interrupts_enabled(old_level);
	enable_preemption();
	<span class="enscript-keyword">return</span> retval;
}
</pre>
<hr />
</body></html>