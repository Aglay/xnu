<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>chud_thread_i386.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">chud_thread_i386.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">thread</span> <span class="enscript-variable-name">state</span> ****
#<span class="enscript-reference">endif</span>

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_thread_get_state</span>(
						 thread_t	 	thread, 
						 thread_flavor_t	 	flavor,
						 thread_state_t	 	tstate,
						 mach_msg_type_number_t	*count,
						 boolean_t	 	user_only)
{
	<span class="enscript-keyword">if</span> (user_only) {
		<span class="enscript-comment">/* We can't get user state for kernel threads */</span>
		<span class="enscript-keyword">if</span> (thread-&gt;task == kernel_task)
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		<span class="enscript-comment">/* this properly handles deciding whether or not the thread is 64 bit or not */</span>
		<span class="enscript-keyword">return</span> machine_thread_get_state(thread, flavor, tstate, count);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// i386 machine_thread_get_kern_state() is different from the PPC version which returns
</span>		<span class="enscript-comment">// the previous save area - user or kernel - rather than kernel or NULL if no kernel
</span>		<span class="enscript-comment">// interrupt state available
</span>		
		<span class="enscript-comment">// the real purpose of this branch is the following:
</span>		<span class="enscript-comment">// the user doesn't care if the thread states are user or kernel, he
</span>		<span class="enscript-comment">// just wants the thread state, so we need to determine the proper one
</span>		<span class="enscript-comment">// to return, kernel or user, for the given thread.
</span>		<span class="enscript-keyword">if</span>(thread == current_thread() &amp;&amp; current_cpu_datap()-&gt;cpu_int_state) {
			<span class="enscript-comment">// the above are conditions where we possibly can read the kernel
</span>			<span class="enscript-comment">// state. we still need to determine if this interrupt happened in
</span>			<span class="enscript-comment">// kernel or user context
</span>			<span class="enscript-keyword">if</span>(USER_STATE(thread) == current_cpu_datap()-&gt;cpu_int_state &amp;&amp;
			   current_cpu_datap()-&gt;cpu_interrupt_level == 1) {
				<span class="enscript-comment">// interrupt happened in user land
</span>				<span class="enscript-keyword">return</span> machine_thread_get_state(thread, flavor, tstate, count);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// kernel interrupt.
</span>				<span class="enscript-keyword">return</span> machine_thread_get_kern_state(thread, flavor, tstate, count);
			}
		} <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// get the user-mode thread state
</span>			<span class="enscript-keyword">return</span> machine_thread_get_state(thread, flavor, tstate, count);
		}
	}
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_thread_set_state</span>(
						 thread_t		thread, 
						 thread_flavor_t		flavor,
						 thread_state_t		tstate,
						 mach_msg_type_number_t	count,
						 boolean_t 		user_only)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">user_only</span>)
	<span class="enscript-keyword">return</span> machine_thread_set_state(thread, flavor, tstate, count);
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">task</span> <span class="enscript-variable-name">memory</span> <span class="enscript-variable-name">read</span>/<span class="enscript-variable-name">write</span> ****
#<span class="enscript-reference">endif</span>

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_task_read</span>(
				  task_t		task,
				  <span class="enscript-type">void</span>		*kernaddr,
				  uint64_t	usraddr,
				  vm_size_t	size)
{
	kern_return_t ret = KERN_SUCCESS;
	boolean_t old_level;
	
	<span class="enscript-keyword">if</span>(ml_at_interrupt_context()) {
		<span class="enscript-keyword">return</span> KERN_FAILURE; <span class="enscript-comment">// Can't look at tasks on interrupt stack
</span>	}

	<span class="enscript-comment">/*
	 * pmap layer requires interrupts to be on
	 */</span>
	old_level = ml_set_interrupts_enabled(TRUE);
	
	<span class="enscript-keyword">if</span>(current_task()==task) {	
		
		<span class="enscript-keyword">if</span>(copyin(usraddr, kernaddr, size)) {
			ret = KERN_FAILURE;
		}
	} <span class="enscript-keyword">else</span> {
		vm_map_t map = get_task_map(task);
		ret = vm_map_read_user(map, usraddr, kernaddr, size);
	}
    
	ml_set_interrupts_enabled(old_level);

	<span class="enscript-keyword">return</span> ret;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_task_write</span>(
				   task_t		task,
				   uint64_t	useraddr,
				   <span class="enscript-type">void</span>		*kernaddr,
				   vm_size_t	size)
{
	kern_return_t ret = KERN_SUCCESS;
	boolean_t old_level;
	
	<span class="enscript-keyword">if</span>(ml_at_interrupt_context()) {
		<span class="enscript-keyword">return</span> KERN_FAILURE; <span class="enscript-comment">// can't poke into tasks on interrupt stack
</span>	}

	<span class="enscript-comment">/*
	 * pmap layer requires interrupts to be on
	 */</span>
	old_level = ml_set_interrupts_enabled(TRUE);
	
	<span class="enscript-keyword">if</span>(current_task()==task) {    
		
		<span class="enscript-keyword">if</span>(copyout(kernaddr, useraddr, size)) {
			ret = KERN_FAILURE;
		}
	} <span class="enscript-keyword">else</span> {
		vm_map_t map = get_task_map(task);
		ret = vm_map_write_user(map, kernaddr, useraddr, size);
	}		
	
	ml_set_interrupts_enabled(old_level);

	<span class="enscript-keyword">return</span> ret;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_kern_read</span>(<span class="enscript-type">void</span> *dstaddr, vm_offset_t srcaddr, vm_size_t size)
{
	<span class="enscript-keyword">return</span> (ml_nofault_copy(srcaddr, (vm_offset_t) dstaddr, size) == size ?
			<span class="enscript-reference">KERN_SUCCESS</span>: KERN_FAILURE);
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_kern_write</span>(
				   vm_offset_t	dstaddr,
				   <span class="enscript-type">void</span>		*srcaddr,
				   vm_size_t	size)
{
	<span class="enscript-keyword">return</span> (ml_nofault_copy((vm_offset_t) srcaddr, dstaddr, size) == size ?
			<span class="enscript-reference">KERN_SUCCESS</span>: KERN_FAILURE);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VALID_STACK_ADDRESS</span>(supervisor, addr, minKernAddr, maxKernAddr)   (supervisor ? (addr&gt;=minKernAddr &amp;&amp; addr&lt;=maxKernAddr) : TRUE)
<span class="enscript-comment">// don't try to read in the hole
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">VALID_STACK_ADDRESS64</span>(supervisor, addr, minKernAddr, maxKernAddr) \
(supervisor ? ((uint64_t)addr &gt;= minKernAddr &amp;&amp; (uint64_t)addr &lt;= maxKernAddr) : \
((uint64_t)addr != 0ULL &amp;&amp; ((uint64_t)addr &lt;= 0x00007FFFFFFFFFFFULL || (uint64_t)addr &gt;= 0xFFFF800000000000ULL)))

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _cframe64_t {
	uint64_t	prevFP;		<span class="enscript-comment">// can't use a real pointer here until we're a 64 bit kernel
</span>	uint64_t	caller;
	uint64_t	args[0];
}cframe64_t;


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _cframe_t {
	uint32_t		prev;	<span class="enscript-comment">// this is really a user32-space pointer to the previous frame
</span>	uint32_t		caller;
	uint32_t		args[0];
} cframe_t;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">find_user_regs</span>(thread_t);
<span class="enscript-type">extern</span> x86_saved_state32_t *<span class="enscript-function-name">find_kern_regs</span>(thread_t);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">do_backtrace32</span>(
	task_t task,
	thread_t thread,
	x86_saved_state32_t *regs, 
	uint64_t *frames,
	mach_msg_type_number_t *start_idx,
	mach_msg_type_number_t max_idx,
	boolean_t supervisor)
{
	uint32_t tmpWord = 0UL;
	uint64_t currPC = (uint64_t) regs-&gt;eip;
	uint64_t currFP = (uint64_t) regs-&gt;ebp;
	uint64_t prevPC = 0ULL;
	uint64_t prevFP = 0ULL;
	uint64_t kernStackMin = thread-&gt;kernel_stack;
    uint64_t kernStackMax = kernStackMin + kernel_stack_size;
	mach_msg_type_number_t ct = *start_idx;
	kern_return_t kr = KERN_FAILURE;

	<span class="enscript-keyword">if</span>(ct &gt;= max_idx)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;	<span class="enscript-comment">// no frames traced
</span>	
	frames[ct++] = chudxnu_vm_unslide(currPC, supervisor);

	<span class="enscript-comment">// build a backtrace of this 32 bit state.
</span>	<span class="enscript-keyword">while</span>(VALID_STACK_ADDRESS(supervisor, currFP, kernStackMin, kernStackMax)) {
		cframe_t *fp = (cframe_t *) (uintptr_t) currFP;

        <span class="enscript-keyword">if</span>(!currFP) {
            currPC = 0;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span>(ct &gt;= max_idx) {
			*start_idx = ct;
            <span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
        }

		<span class="enscript-comment">/* read our caller */</span>
		<span class="enscript-keyword">if</span>(supervisor) {
			kr = chudxnu_kern_read(&amp;tmpWord, (vm_offset_t) &amp;fp-&gt;caller, <span class="enscript-keyword">sizeof</span>(uint32_t));
		} <span class="enscript-keyword">else</span> {
			kr = chudxnu_task_read(task, &amp;tmpWord, (vm_offset_t) &amp;fp-&gt;caller, <span class="enscript-keyword">sizeof</span>(uint32_t));
		}

		<span class="enscript-keyword">if</span>(kr != KERN_SUCCESS) {
			currPC = 0ULL;
			<span class="enscript-keyword">break</span>;
		}

		currPC = (uint64_t) tmpWord;    <span class="enscript-comment">// promote 32 bit address
</span>
        <span class="enscript-comment">/* 
         * retrive contents of the frame pointer and advance to the next stack
         * frame if it's valid 
         */</span>
        prevFP = 0;
		<span class="enscript-keyword">if</span>(supervisor) {
			kr = chudxnu_kern_read(&amp;tmpWord, (vm_offset_t)&amp;fp-&gt;prev, <span class="enscript-keyword">sizeof</span>(uint32_t));
		} <span class="enscript-keyword">else</span> {
			kr = chudxnu_task_read(task, &amp;tmpWord, (vm_offset_t)&amp;fp-&gt;prev, <span class="enscript-keyword">sizeof</span>(uint32_t));
		}
		prevFP = (uint64_t) tmpWord;    <span class="enscript-comment">// promote 32 bit address
</span>
        <span class="enscript-keyword">if</span>(prevFP) {
            frames[ct++] = chudxnu_vm_unslide(currPC, supervisor);
            prevPC = currPC;
        }
        <span class="enscript-keyword">if</span>(prevFP &lt; currFP) {
            <span class="enscript-keyword">break</span>;
        } <span class="enscript-keyword">else</span> {
            currFP = prevFP;
        }	
	}

	*start_idx = ct;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">do_backtrace64</span>(
	task_t task,
	thread_t thread,
	x86_saved_state64_t *regs, 
	uint64_t *frames,
	mach_msg_type_number_t *start_idx,
	mach_msg_type_number_t max_idx,
	boolean_t supervisor)
{
	uint64_t currPC = regs-&gt;isf.rip;
	uint64_t currFP = regs-&gt;rbp;
	uint64_t prevPC = 0ULL;
	uint64_t prevFP = 0ULL;
	uint64_t kernStackMin = (uint64_t)thread-&gt;kernel_stack;
    uint64_t kernStackMax = (uint64_t)kernStackMin + kernel_stack_size;
	mach_msg_type_number_t ct = *start_idx;
	kern_return_t kr = KERN_FAILURE;

	<span class="enscript-keyword">if</span>(*start_idx &gt;= max_idx)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;	<span class="enscript-comment">// no frames traced
</span>	
	frames[ct++] = chudxnu_vm_unslide(currPC, supervisor);

	<span class="enscript-comment">// build a backtrace of this 32 bit state.
</span>	<span class="enscript-keyword">while</span>(VALID_STACK_ADDRESS64(supervisor, currFP, kernStackMin, kernStackMax)) {
		<span class="enscript-comment">// this is the address where caller lives in the user thread
</span>		uint64_t caller = currFP + <span class="enscript-keyword">sizeof</span>(uint64_t);

        <span class="enscript-keyword">if</span>(!currFP) {
            currPC = 0;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span>(ct &gt;= max_idx) {
			*start_idx = ct;
            <span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
        }

		<span class="enscript-comment">/* read our caller */</span>
		<span class="enscript-keyword">if</span>(supervisor) {
			kr = chudxnu_kern_read(&amp;currPC, (vm_offset_t)caller, <span class="enscript-keyword">sizeof</span>(uint64_t));
		} <span class="enscript-keyword">else</span> {
			kr = chudxnu_task_read(task, &amp;currPC, caller, <span class="enscript-keyword">sizeof</span>(uint64_t));
		}

		<span class="enscript-keyword">if</span>(kr != KERN_SUCCESS) {
			currPC = 0ULL;
			<span class="enscript-keyword">break</span>;
		}

        <span class="enscript-comment">/* 
         * retrive contents of the frame pointer and advance to the next stack
         * frame if it's valid 
         */</span>
        prevFP = 0;
		<span class="enscript-keyword">if</span>(supervisor) {
			kr = chudxnu_kern_read(&amp;prevFP, (vm_offset_t)currFP, <span class="enscript-keyword">sizeof</span>(uint64_t));
		} <span class="enscript-keyword">else</span> {
			kr = chudxnu_task_read(task, &amp;prevFP, currFP, <span class="enscript-keyword">sizeof</span>(uint64_t));
		}

        <span class="enscript-keyword">if</span>(VALID_STACK_ADDRESS64(supervisor, prevFP, kernStackMin, kernStackMax)) {
            frames[ct++] = chudxnu_vm_unslide(currPC, supervisor);
            prevPC = currPC;
        }
        <span class="enscript-keyword">if</span>(prevFP &lt; currFP) {
            <span class="enscript-keyword">break</span>;
        } <span class="enscript-keyword">else</span> {
            currFP = prevFP;
        }	
	}

	*start_idx = ct;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">do_kernel_backtrace</span>(
	thread_t thread,
	<span class="enscript-type">struct</span> x86_kernel_state *regs, 
	uint64_t *frames,
	mach_msg_type_number_t *start_idx,
	mach_msg_type_number_t max_idx)
{
	uint64_t kernStackMin = (uint64_t)thread-&gt;kernel_stack;
    uint64_t kernStackMax = (uint64_t)kernStackMin + kernel_stack_size;
	mach_msg_type_number_t ct = *start_idx;
	kern_return_t kr = KERN_FAILURE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
	uint64_t currPC = 0ULL;
	uint64_t currFP = 0ULL;
	uint64_t prevPC = 0ULL;
	uint64_t prevFP = 0ULL;
	<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;currPC, (vm_offset_t)&amp;(regs-&gt;k_rip), <span class="enscript-keyword">sizeof</span>(uint64_t))) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
	<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;currFP, (vm_offset_t)&amp;(regs-&gt;k_rbp), <span class="enscript-keyword">sizeof</span>(uint64_t))) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
#<span class="enscript-reference">else</span>
	uint32_t currPC = 0U;
	uint32_t currFP = 0U;
	uint32_t prevPC = 0U;
	uint32_t prevFP = 0U;
	<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;currPC, (vm_offset_t)&amp;(regs-&gt;k_eip), <span class="enscript-keyword">sizeof</span>(uint32_t))) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
	<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;currFP, (vm_offset_t)&amp;(regs-&gt;k_ebp), <span class="enscript-keyword">sizeof</span>(uint32_t))) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span>(*start_idx &gt;= max_idx)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;	<span class="enscript-comment">// no frames traced
</span>	
	<span class="enscript-keyword">if</span>(!currPC) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	frames[ct++] = chudxnu_vm_unslide((uint64_t)currPC, 1);

	<span class="enscript-comment">// build a backtrace of this kernel state
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">while</span>(VALID_STACK_ADDRESS64(TRUE, currFP, kernStackMin, kernStackMax)) {
		<span class="enscript-comment">// this is the address where caller lives in the user thread
</span>		uint64_t caller = currFP + <span class="enscript-keyword">sizeof</span>(uint64_t);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">while</span>(VALID_STACK_ADDRESS(TRUE, currFP, kernStackMin, kernStackMax)) {
		uint32_t caller = (uint32_t)currFP + <span class="enscript-keyword">sizeof</span>(uint32_t);
#<span class="enscript-reference">endif</span>

        <span class="enscript-keyword">if</span>(!currFP || !currPC) {
            currPC = 0;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span>(ct &gt;= max_idx) {
			*start_idx = ct;
            <span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
        }

		<span class="enscript-comment">/* read our caller */</span>
		kr = chudxnu_kern_read(&amp;currPC, (vm_offset_t)caller, <span class="enscript-keyword">sizeof</span>(currPC));

		<span class="enscript-keyword">if</span>(kr != KERN_SUCCESS || !currPC) {
			currPC = 0UL;
			<span class="enscript-keyword">break</span>;
		}

        <span class="enscript-comment">/* 
         * retrive contents of the frame pointer and advance to the next stack
         * frame if it's valid 
         */</span>
        prevFP = 0;
		kr = chudxnu_kern_read(&amp;prevFP, (vm_offset_t)currFP, <span class="enscript-keyword">sizeof</span>(currPC));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
        <span class="enscript-keyword">if</span>(VALID_STACK_ADDRESS64(TRUE, prevFP, kernStackMin, kernStackMax)) {
#<span class="enscript-reference">else</span>
        <span class="enscript-keyword">if</span>(VALID_STACK_ADDRESS(TRUE, prevFP, kernStackMin, kernStackMax)) {
#<span class="enscript-reference">endif</span>
            frames[ct++] = chudxnu_vm_unslide((uint64_t)currPC, 1);
            prevPC = currPC;
        }
        <span class="enscript-keyword">if</span>(prevFP &lt;= currFP) {
            <span class="enscript-keyword">break</span>;
        } <span class="enscript-keyword">else</span> {
            currFP = prevFP;
        }	
	}

	*start_idx = ct;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span>
kern_return_t <span class="enscript-function-name">chudxnu_thread_get_callstack64_internal</span>(
	thread_t		thread,
	uint64_t		*callstack,
	mach_msg_type_number_t	*count,
	boolean_t		user_only,
	boolean_t		kern_only)
{
	kern_return_t kr = KERN_FAILURE;
    task_t task = thread-&gt;task;
    uint64_t currPC = 0ULL;
	boolean_t supervisor = FALSE;
    mach_msg_type_number_t bufferIndex = 0;
    mach_msg_type_number_t bufferMaxIndex = *count;
	x86_saved_state_t *tagged_regs = NULL;		<span class="enscript-comment">// kernel register state
</span>	x86_saved_state64_t *regs64 = NULL;
	x86_saved_state32_t *regs32 = NULL;
	x86_saved_state32_t *u_regs32 = NULL;
	x86_saved_state64_t *u_regs64 = NULL;
	<span class="enscript-type">struct</span> x86_kernel_state *kregs = NULL;

	<span class="enscript-keyword">if</span>(ml_at_interrupt_context()) {
		
		<span class="enscript-keyword">if</span>(user_only) {
			<span class="enscript-comment">/* can't backtrace user state on interrupt stack. */</span>
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}

		<span class="enscript-comment">/* backtracing at interrupt context? */</span>
		 <span class="enscript-keyword">if</span>(thread == current_thread() &amp;&amp; current_cpu_datap()-&gt;cpu_int_state) {
			<span class="enscript-comment">/* 
			 * Locate the registers for the interrupted thread, assuming it is
			 * current_thread(). 
			 */</span>
			tagged_regs = current_cpu_datap()-&gt;cpu_int_state;
			
			<span class="enscript-keyword">if</span>(is_saved_state64(tagged_regs)) {
				<span class="enscript-comment">/* 64 bit registers */</span>
				regs64 = saved_state64(tagged_regs);
				supervisor = ((regs64-&gt;isf.cs &amp; SEL_PL) != SEL_PL_U);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 32 bit registers */</span>
				regs32 = saved_state32(tagged_regs);
				supervisor = ((regs32-&gt;cs &amp; SEL_PL) != SEL_PL_U);
			}
		} 
	}

	<span class="enscript-keyword">if</span>(!ml_at_interrupt_context() &amp;&amp; kernel_task == task) {

		<span class="enscript-keyword">if</span>(!thread-&gt;kernel_stack) {
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}

		<span class="enscript-comment">// Kernel thread not at interrupt context
</span>		kregs = (<span class="enscript-type">struct</span> x86_kernel_state *)NULL;

		<span class="enscript-comment">// nofault read of the thread-&gt;kernel_stack pointer
</span>		<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;kregs, (vm_offset_t)&amp;(thread-&gt;kernel_stack), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *))) {
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}

		<span class="enscript-comment">// Adjust to find the saved kernel state
</span>		kregs = STACK_IKS((vm_offset_t)(uintptr_t)kregs);

		supervisor = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(!tagged_regs) {
		<span class="enscript-comment">/* 
		 * not at interrupt context, or tracing a different thread than
		 * current_thread() at interrupt context 
		 */</span>
		tagged_regs = USER_STATE(thread);
		<span class="enscript-keyword">if</span>(is_saved_state64(tagged_regs)) {
			<span class="enscript-comment">/* 64 bit registers */</span>
			regs64 = saved_state64(tagged_regs);
			supervisor = ((regs64-&gt;isf.cs &amp; SEL_PL) != SEL_PL_U); 
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 32 bit registers */</span>
			regs32 = saved_state32(tagged_regs);
			supervisor = ((regs32-&gt;cs &amp; SEL_PL) != SEL_PL_U);
		}
	}

	*count = 0; 

	<span class="enscript-keyword">if</span>(supervisor) {
		<span class="enscript-comment">// the caller only wants a user callstack.
</span>		<span class="enscript-keyword">if</span>(user_only) {
			<span class="enscript-comment">// bail - we've only got kernel state
</span>			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// regs32(64) is not in supervisor mode.
</span>		u_regs32 = regs32;
		u_regs64 = regs64;
		regs32 = NULL;
		regs64 = NULL;
	}

	<span class="enscript-keyword">if</span> (user_only) {
		<span class="enscript-comment">/* we only want to backtrace the user mode */</span>
		<span class="enscript-keyword">if</span>(!(u_regs32 || u_regs64)) {
			<span class="enscript-comment">/* no user state to look at */</span>
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
	}

	<span class="enscript-comment">/* 
	 * Order of preference for top of stack:
	 * 64 bit kernel state (not likely)
	 * 32 bit kernel state
	 * 64 bit user land state
	 * 32 bit user land state
	 */</span>

	<span class="enscript-keyword">if</span>(kregs) {
		<span class="enscript-comment">/*
		 * nofault read of the registers from the kernel stack (as they can
		 * disappear on the fly).
		 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
		<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;currPC, (vm_offset_t)&amp;(kregs-&gt;k_rip), <span class="enscript-keyword">sizeof</span>(uint64_t))) {
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
#<span class="enscript-reference">else</span>
		uint32_t tmp;
		<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;tmp, (vm_offset_t)&amp;(kregs-&gt;k_eip), <span class="enscript-keyword">sizeof</span>(uint32_t))) {
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
		currPC = (uint64_t)tmp;
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(regs64) {
		currPC = regs64-&gt;isf.rip;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(regs32) {
		currPC = (uint64_t) regs32-&gt;eip;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(u_regs64) {
		currPC = u_regs64-&gt;isf.rip;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(u_regs32) {
		currPC = (uint64_t) u_regs32-&gt;eip;
	}
	
	<span class="enscript-keyword">if</span>(!currPC) {
		<span class="enscript-comment">/* no top of the stack, bail out */</span>
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	bufferIndex = 0;
		
	<span class="enscript-keyword">if</span>(bufferMaxIndex &lt; 1) {
		*count = 0;
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	<span class="enscript-comment">/* backtrace kernel */</span>
	<span class="enscript-keyword">if</span>(kregs) {
		addr64_t address = 0ULL;
		size_t size = 0UL;

		<span class="enscript-comment">// do the backtrace
</span>		kr = do_kernel_backtrace(thread, kregs, callstack, &amp;bufferIndex, bufferMaxIndex);

		<span class="enscript-comment">// and do a nofault read of (r|e)sp
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
		uint64_t rsp = 0ULL;
		size = <span class="enscript-keyword">sizeof</span>(uint64_t);
		
		<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;address, (vm_offset_t)&amp;(kregs-&gt;k_rsp), size)) {
			address = 0ULL;
		}
#<span class="enscript-reference">else</span>
		uint32_t rsp = 0ULL, tmp = 0ULL;
		size = <span class="enscript-keyword">sizeof</span>(uint32_t);

		<span class="enscript-keyword">if</span>(KERN_SUCCESS != chudxnu_kern_read(&amp;tmp, (vm_offset_t)&amp;(kregs-&gt;k_esp), size)) {
			address = 0ULL;
		} <span class="enscript-keyword">else</span> {
			address = (addr64_t)tmp;
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span>(address &amp;&amp; KERN_SUCCESS == chudxnu_kern_read(&amp;rsp, (vm_offset_t)address, size) &amp;&amp; bufferIndex &lt; bufferMaxIndex) {
			callstack[bufferIndex++] = (uint64_t)rsp;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(regs64) {
		uint64_t rsp = 0ULL;

		<span class="enscript-comment">// backtrace the 64bit side.
</span>		kr = do_backtrace64(task, thread, regs64, callstack, &amp;bufferIndex,
		                    bufferMaxIndex - 1, TRUE);

		<span class="enscript-keyword">if</span>(KERN_SUCCESS == chudxnu_kern_read(&amp;rsp, (vm_offset_t) regs64-&gt;isf.rsp, <span class="enscript-keyword">sizeof</span>(uint64_t)) &amp;&amp; 
			bufferIndex &lt; bufferMaxIndex) {
			callstack[bufferIndex++] = rsp;
		}

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(regs32) {
		uint32_t esp = 0UL;

		<span class="enscript-comment">// backtrace the 32bit side.
</span>		kr = do_backtrace32(task, thread, regs32, callstack, &amp;bufferIndex,
		                    bufferMaxIndex - 1, TRUE);
		
		<span class="enscript-keyword">if</span>(KERN_SUCCESS == chudxnu_kern_read(&amp;esp, (vm_offset_t) regs32-&gt;uesp, <span class="enscript-keyword">sizeof</span>(uint32_t)) &amp;&amp; 
			bufferIndex &lt; bufferMaxIndex) {
			callstack[bufferIndex++] = (uint64_t) esp;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(u_regs64 &amp;&amp; !kern_only) {
		<span class="enscript-comment">/* backtrace user land */</span>
		uint64_t rsp = 0ULL;
		
		kr = do_backtrace64(task, thread, u_regs64, callstack, &amp;bufferIndex,
		                    bufferMaxIndex - 1, FALSE);

		<span class="enscript-keyword">if</span>(KERN_SUCCESS == chudxnu_task_read(task, &amp;rsp, (addr64_t) u_regs64-&gt;isf.rsp, <span class="enscript-keyword">sizeof</span>(uint64_t)) &amp;&amp; 
			bufferIndex &lt; bufferMaxIndex) {
			callstack[bufferIndex++] = rsp;
		}

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(u_regs32 &amp;&amp; !kern_only) {
		uint32_t esp = 0UL;
		
		kr = do_backtrace32(task, thread, u_regs32, callstack, &amp;bufferIndex,
		                    bufferMaxIndex - 1, FALSE);

		<span class="enscript-keyword">if</span>(KERN_SUCCESS == chudxnu_task_read(task, &amp;esp, (addr64_t) u_regs32-&gt;uesp, <span class="enscript-keyword">sizeof</span>(uint32_t)) &amp;&amp; 
			bufferIndex &lt; bufferMaxIndex) {
			callstack[bufferIndex++] = (uint64_t) esp;
		}
	}

    *count = bufferIndex;
    <span class="enscript-keyword">return</span> kr;
}

__private_extern__
kern_return_t <span class="enscript-function-name">chudxnu_thread_get_callstack64_kperf</span>(
	thread_t		thread,
	uint64_t		*callstack,
	mach_msg_type_number_t	*count,
	boolean_t		is_user)
{
	<span class="enscript-keyword">return</span> chudxnu_thread_get_callstack64_internal(thread, callstack, count, is_user, !is_user);
}

__private_extern__
kern_return_t <span class="enscript-function-name">chudxnu_thread_get_callstack64</span>(
	thread_t		thread,
	uint64_t		*callstack,
	mach_msg_type_number_t	*count,
	boolean_t		user_only)
{
	<span class="enscript-keyword">return</span> chudxnu_thread_get_callstack64_internal(thread, callstack, count, user_only, 0);
}

</pre>
<hr />
</body></html>