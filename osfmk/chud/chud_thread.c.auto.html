<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>chud_thread.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">chud_thread.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu_private.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kpc.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPERF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/kperf.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// include the correct file to find real_ncpus
</span>#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#	<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>	
#<span class="enscript-reference">else</span>
<span class="enscript-comment">// fall back on declaring it extern.  The linker will sort us out.
</span><span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> real_ncpus;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Mask for supported options
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_CHUD_BIND_OPT_MASK</span> (-1UL)

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">thread</span> <span class="enscript-variable-name">binding</span> ****
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * This method will bind a given thread to the requested CPU starting at the
 * next time quantum.  If the thread is the current thread, this method will
 * force a thread_block().  The result is that if you call this method on the
 * current thread, you will be on the requested CPU when this method returns.
 */</span>
__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_bind_thread</span>(thread_t thread, <span class="enscript-type">int</span> cpu, __unused <span class="enscript-type">int</span> options)
{
    processor_t proc = NULL;

	<span class="enscript-keyword">if</span>(cpu &lt; 0 || (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)cpu &gt;= real_ncpus) <span class="enscript-comment">// sanity check
</span>		<span class="enscript-keyword">return</span> KERN_FAILURE;

	<span class="enscript-comment">// temporary restriction until after phase 2 of the scheduler
</span>	<span class="enscript-keyword">if</span>(thread != current_thread())
		<span class="enscript-keyword">return</span> KERN_FAILURE; 
	
	proc = cpu_to_processor(cpu);

	<span class="enscript-comment">/* 
	 * Potentially racey, but mainly to prevent bind to shutdown
	 * processor.
	 */</span>
	<span class="enscript-keyword">if</span>(proc &amp;&amp; !(proc-&gt;state == PROCESSOR_OFF_LINE) &amp;&amp;
			!(proc-&gt;state == PROCESSOR_SHUTDOWN)) {
		
		thread_bind(proc);

		<span class="enscript-comment">/*
		 * If we're trying to bind the current thread, and
		 * we're not on the target cpu, and not at interrupt
		 * context, block the current thread to force a
		 * reschedule on the target CPU.
		 */</span>
		<span class="enscript-keyword">if</span>(thread == current_thread() &amp;&amp; 
			!ml_at_interrupt_context() &amp;&amp; cpu_number() != cpu) {
			(<span class="enscript-type">void</span>)thread_block(THREAD_CONTINUE_NULL);
		}
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
    <span class="enscript-keyword">return</span> KERN_FAILURE;
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_unbind_thread</span>(thread_t thread, __unused <span class="enscript-type">int</span> options)
{
	<span class="enscript-keyword">if</span>(thread == current_thread())
		thread_bind(PROCESSOR_NULL);
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

__private_extern__ boolean_t
<span class="enscript-function-name">chudxnu_thread_get_idle</span>(thread_t thread) {
	<span class="enscript-comment">/* 
	 * Instantaneous snapshot of the idle state of
	 * a given thread.
	 *
	 * Should be called only on an interrupted or 
	 * suspended thread to avoid a race.
	 */</span>
	<span class="enscript-keyword">return</span> ((thread-&gt;state &amp; TH_IDLE) == TH_IDLE);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">chudxnu_thread_get_scheduler_state</span>(thread_t thread) {
	<span class="enscript-comment">/* 
	 * Instantaneous snapshot of the scheduler state of
	 * a given thread.
	 *
	 * MUST ONLY be called on an interrupted or 
	 * locked thread, to avoid a race.
	 */</span>
	
	<span class="enscript-type">int</span> state = 0;
	<span class="enscript-type">int</span> schedulerState = (<span class="enscript-type">volatile</span> <span class="enscript-type">int</span>)(thread-&gt;state);
	processor_t lastProcessor = (<span class="enscript-type">volatile</span> processor_t)(thread-&gt;last_processor);
	
	<span class="enscript-keyword">if</span> ((PROCESSOR_NULL != lastProcessor) &amp;&amp; (thread == lastProcessor-&gt;active_thread)) {
		state |= CHUDXNU_TS_RUNNING;
	}
		
	<span class="enscript-keyword">if</span> (schedulerState &amp; TH_RUN) {
		state |= CHUDXNU_TS_RUNNABLE;
	}
	
	<span class="enscript-keyword">if</span> (schedulerState &amp; TH_WAIT) {
		state |= CHUDXNU_TS_WAIT;
	}
	
	<span class="enscript-keyword">if</span> (schedulerState &amp; TH_UNINT) {
		state |= CHUDXNU_TS_UNINT;
	}
	
	<span class="enscript-keyword">if</span> (schedulerState &amp; TH_SUSP) {
		state |= CHUDXNU_TS_SUSP;
	}
	
	<span class="enscript-keyword">if</span> (schedulerState &amp; TH_TERMINATE) {
		state |= CHUDXNU_TS_TERMINATE;
	}	
	
	<span class="enscript-keyword">if</span> (schedulerState &amp; TH_IDLE) {
		state |= CHUDXNU_TS_IDLE;
	}
	
	<span class="enscript-keyword">return</span> state;
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">task</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">thread</span> <span class="enscript-variable-name">info</span> ****
#<span class="enscript-reference">endif</span>

__private_extern__ boolean_t
<span class="enscript-function-name">chudxnu_is_64bit_task</span>(task_t task)
{
	<span class="enscript-keyword">return</span> (task_has_64BitAddr(task));
}

<span class="enscript-comment">// an exact copy of task_threads() except no mig conversion at the end!
</span><span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">chudxnu_private_task_threads</span>(
	task_t			task,
	thread_act_array_t      *threads_out,
    	mach_msg_type_number_t  *count)
{
	mach_msg_type_number_t	actual;
	thread_t				*thread_list;
	thread_t				thread;
	vm_size_t				size, size_needed;
	<span class="enscript-type">void</span>					*addr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			i, j;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	size = 0; addr = NULL;

	<span class="enscript-keyword">for</span> (;;) {
		task_lock(task);
		<span class="enscript-keyword">if</span> (!task-&gt;active) {
			task_unlock(task);

			<span class="enscript-keyword">if</span> (size != 0)
				kfree(addr, size);

			<span class="enscript-keyword">return</span> (KERN_FAILURE);
		}

		actual = task-&gt;thread_count;

		<span class="enscript-comment">/* do we have the memory we need? */</span>
		size_needed = actual * <span class="enscript-keyword">sizeof</span> (mach_port_t);
		<span class="enscript-keyword">if</span> (size_needed &lt;= size)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* unlock the task and allocate more memory */</span>
		task_unlock(task);

		<span class="enscript-keyword">if</span> (size != 0)
			kfree(addr, size);

		assert(size_needed &gt; 0);
		size = size_needed;

		addr = kalloc(size);
		<span class="enscript-keyword">if</span> (addr == 0)
			<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
	}

	<span class="enscript-comment">/* OK, have memory and the task is locked &amp; active */</span>
	thread_list = (thread_t *)addr;

	i = j = 0;

	<span class="enscript-keyword">for</span> (thread = (thread_t)queue_first(&amp;task-&gt;threads); i &lt; actual;
				++i, thread = (thread_t)queue_next(&amp;thread-&gt;task_threads)) {
		thread_reference_internal(thread);
		thread_list[j++] = thread;
	}

	assert(queue_end(&amp;task-&gt;threads, (queue_entry_t)thread));

	actual = j;
	size_needed = actual * <span class="enscript-keyword">sizeof</span> (mach_port_t);

	<span class="enscript-comment">/* can unlock task now that we've got the thread refs */</span>
	task_unlock(task);

	<span class="enscript-keyword">if</span> (actual == 0) {
		<span class="enscript-comment">/* no threads, so return null pointer and deallocate memory */</span>

		*threads_out = NULL;
		*count = 0;

		<span class="enscript-keyword">if</span> (size != 0)
			kfree(addr, size);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* if we allocated too much, must copy */</span>

		<span class="enscript-keyword">if</span> (size_needed &lt; size) {
			<span class="enscript-type">void</span> *newaddr;

			newaddr = kalloc(size_needed);
			<span class="enscript-keyword">if</span> (newaddr == 0) {
				<span class="enscript-keyword">for</span> (i = 0; i &lt; actual; ++i)
					thread_deallocate(thread_list[i]);
				kfree(addr, size);
				<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
			}

			bcopy(addr, newaddr, size_needed);
			kfree(addr, size);
			thread_list = (thread_t *)newaddr;
		}

		*threads_out = thread_list;
		*count = actual;
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_all_tasks</span>(
	task_array_t		*task_list,
	mach_msg_type_number_t	*count)
{
	<span class="enscript-keyword">return</span> processor_set_things(&amp;pset0, (<span class="enscript-type">void</span> **)task_list, count, PSET_THING_TASK);	
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_free_task_list</span>(
	task_array_t		*task_list,
	mach_msg_type_number_t	*count)
{
	vm_size_t size = (*count)*<span class="enscript-keyword">sizeof</span>(mach_port_t);
	<span class="enscript-type">void</span> *addr = *task_list;

	<span class="enscript-keyword">if</span>(addr) {
		<span class="enscript-type">int</span> i, maxCount = *count;
		<span class="enscript-keyword">for</span>(i=0; i&lt;maxCount; i++) {
			task_deallocate((*task_list)[i]);
		}		
		kfree(addr, size);
		*task_list = NULL;
		*count = 0;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
}
__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_all_threads</span>(
	thread_array_t		*thread_list,
	mach_msg_type_number_t	*count)
{
	<span class="enscript-keyword">return</span> processor_set_things(&amp;pset0, (<span class="enscript-type">void</span> **)thread_list, count, PSET_THING_THREAD);
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_task_threads</span>(
	task_t task,
	thread_array_t *thread_list,
	mach_msg_type_number_t *count)
{
	<span class="enscript-keyword">return</span> chudxnu_private_task_threads(task, thread_list, count);
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_free_thread_list</span>(
	thread_array_t	*thread_list,
	mach_msg_type_number_t	*count)
{
	vm_size_t size = (*count)*<span class="enscript-keyword">sizeof</span>(mach_port_t);
	<span class="enscript-type">void</span> *addr = *thread_list;

	<span class="enscript-keyword">if</span>(addr) {
		<span class="enscript-type">int</span> i, maxCount = *count;
		<span class="enscript-keyword">for</span>(i=0; i&lt;maxCount; i++) {
			thread_deallocate((*thread_list)[i]);
		}		
		kfree(addr, size);
		*thread_list = NULL;
		*count = 0;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
}

__private_extern__ task_t
<span class="enscript-function-name">chudxnu_current_task</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> current_task();
}

__private_extern__ thread_t
<span class="enscript-function-name">chudxnu_current_thread</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> current_thread();
}

__private_extern__ task_t
<span class="enscript-function-name">chudxnu_task_for_thread</span>(thread_t thread)
{
    <span class="enscript-keyword">return</span> get_threadtask(thread);
}

__private_extern__ kern_return_t
<span class="enscript-function-name">chudxnu_thread_info</span>(
	thread_t thread,
	thread_flavor_t flavor,
	thread_info_t thread_info_out,
	mach_msg_type_number_t *thread_info_count)
{
	<span class="enscript-keyword">return</span> thread_info(thread, flavor, thread_info_out, thread_info_count);
}


<span class="enscript-comment">/* thread marking stuff */</span>

__private_extern__ boolean_t 
<span class="enscript-function-name">chudxnu_thread_get_marked</span>(thread_t thread) 
{
	<span class="enscript-keyword">if</span>(thread)
		<span class="enscript-keyword">return</span> ((thread-&gt;t_chud &amp; T_CHUD_MARKED) != 0);
	<span class="enscript-keyword">return</span> FALSE;
}

__private_extern__ boolean_t
<span class="enscript-function-name">chudxnu_thread_set_marked</span>(thread_t thread, boolean_t new_value)
{
	boolean_t old_val;

	<span class="enscript-keyword">if</span>(thread) {
		<span class="enscript-keyword">if</span>(new_value) {
			<span class="enscript-comment">// set the marked bit
</span>			old_val = OSBitOrAtomic(T_CHUD_MARKED,  &amp;(thread-&gt;t_chud));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// clear the marked bit
</span>			old_val = OSBitAndAtomic(~T_CHUD_MARKED,  &amp;(thread-&gt;t_chud));
		}
		<span class="enscript-keyword">return</span> (old_val &amp; T_CHUD_MARKED) == T_CHUD_MARKED;
	}
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/* XXX: good thing this code is experimental... */</span>

<span class="enscript-comment">/* external handler */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*chudxnu_thread_ast_handler)(thread_t);
<span class="enscript-function-name">void</span> (*chudxnu_thread_ast_handler)(thread_t) = NULL;

<span class="enscript-comment">/* AST callback to dispatch to AppleProfile */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">chudxnu_thread_ast</span>(thread_t);
<span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_thread_ast</span>(thread_t thread)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPC</span>
	<span class="enscript-comment">/* check for PMC work */</span>
	kpc_thread_ast_handler(thread);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPERF</span>
	<span class="enscript-comment">/* check for kperf work */</span>
	kperf_thread_ast_handler(thread);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* atomicness for kdebug events */</span>
	<span class="enscript-type">void</span> (*handler)(thread_t) = chudxnu_thread_ast_handler;
	<span class="enscript-keyword">if</span>( handler )
		handler( thread );

	thread-&gt;t_chud = 0;
}



<span class="enscript-comment">/* Get and set bits on the thread and trigger an AST handler */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">chudxnu_set_thread_ast</span>( thread_t thread );
<span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_set_thread_ast</span>( thread_t thread )
{
	<span class="enscript-comment">/* FIXME: only call this on current thread from an interrupt handler for now... */</span>
	<span class="enscript-keyword">if</span>( thread != current_thread() )
		panic( <span class="enscript-string">&quot;unsafe AST set&quot;</span> );

	act_set_kperf(thread);
}

<span class="enscript-comment">/* get and set the thread bits */</span>
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">chudxnu_get_thread_bits</span>( thread_t thread );
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">chudxnu_set_thread_bits</span>( thread_t thread, uint32_t bits );

uint32_t
<span class="enscript-function-name">chudxnu_get_thread_bits</span>( thread_t thread )
{
	<span class="enscript-keyword">return</span> thread-&gt;t_chud;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_set_thread_bits</span>( thread_t thread, uint32_t bits )
{
	thread-&gt;t_chud = bits;
}

<span class="enscript-comment">/* get and set thread dirty bits. so CHUD can track whether the thread
 * has been dispatched since it last looked. caller must hold the
 * thread lock
 */</span>
boolean_t
<span class="enscript-function-name">chudxnu_thread_get_dirty</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span>( thread-&gt;c_switch != thread-&gt;chud_c_switch )
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">chudxnu_thread_set_dirty</span>(thread_t thread, boolean_t makedirty)
{
	<span class="enscript-keyword">if</span>( makedirty )
		thread-&gt;chud_c_switch = thread-&gt;c_switch - 1;
	<span class="enscript-keyword">else</span>
		thread-&gt;chud_c_switch = thread-&gt;c_switch;
}
</pre>
<hr />
</body></html>