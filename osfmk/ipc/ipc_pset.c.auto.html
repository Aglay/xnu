<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_pset.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_pset.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	ipc/ipc_pset.c
 *	Author:	Rich Draves
 *	Date:	1989
 *
 *	Functions to manipulate IPC port sets.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_mqueue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_pset.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_right.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>

<span class="enscript-comment">/*
 *	Routine:	ipc_pset_alloc
 *	Purpose:
 *		Allocate a port set.
 *	Conditions:
 *		Nothing locked.  If successful, the port set is returned
 *		locked.  (The caller doesn't have a reference.)
 *	Returns:
 *		KERN_SUCCESS		The port set is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NO_SPACE		No room for an entry in the space.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_pset_alloc</span>(
	ipc_space_t		space,
	mach_port_name_t	*namep,
	ipc_pset_t		*psetp)
{
	ipc_pset_t pset;
	mach_port_name_t name;
	kern_return_t kr;
	uint64_t reserved_link;

	reserved_link = waitq_link_reserve(NULL);

	kr = ipc_object_alloc(space, IOT_PORT_SET,
			      MACH_PORT_TYPE_PORT_SET, 0,
			      &amp;name, (ipc_object_t *) &amp;pset);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		waitq_link_release(reserved_link);
		<span class="enscript-keyword">return</span> kr;
	}
	<span class="enscript-comment">/* pset and space are locked */</span>

	pset-&gt;ips_local_name = name;
	ipc_mqueue_init(&amp;pset-&gt;ips_messages, TRUE <span class="enscript-comment">/* set */</span>, &amp;reserved_link);
	is_write_unlock(space);

	waitq_link_release(reserved_link);

	*namep = name;
	*psetp = pset;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_pset_alloc_name
 *	Purpose:
 *		Allocate a port set, with a specific name.
 *	Conditions:
 *		Nothing locked.  If successful, the port set is returned
 *		locked.  (The caller doesn't have a reference.)
 *	Returns:
 *		KERN_SUCCESS		The port set is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NAME_EXISTS	The name already denotes a right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_pset_alloc_name</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_pset_t		*psetp)
{
	ipc_pset_t pset;
	kern_return_t kr;
	uint64_t reserved_link;


	reserved_link = waitq_link_reserve(NULL);

	kr = ipc_object_alloc_name(space, IOT_PORT_SET,
				   MACH_PORT_TYPE_PORT_SET, 0,
				   name, (ipc_object_t *) &amp;pset);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		waitq_link_release(reserved_link);
		<span class="enscript-keyword">return</span> kr;
	}
	<span class="enscript-comment">/* pset is locked */</span>

	pset-&gt;ips_local_name = name;
	ipc_mqueue_init(&amp;pset-&gt;ips_messages, TRUE <span class="enscript-comment">/* set */</span>, &amp;reserved_link);

	waitq_link_release(reserved_link);

	*psetp = pset;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_pset_member
 *	Purpose:
 *		Checks to see if a port is a member of a pset
 *	Conditions:
 *		Both port and port set are locked.
 *		The port must be active.
 */</span>
boolean_t
<span class="enscript-function-name">ipc_pset_member</span>(
	ipc_pset_t	pset,
	ipc_port_t	port)
{
	assert(ip_active(port));

	<span class="enscript-keyword">return</span> (ipc_mqueue_member(&amp;port-&gt;ip_messages, &amp;pset-&gt;ips_messages));
}


<span class="enscript-comment">/*
 *	Routine:	ipc_pset_add
 *	Purpose:
 *		Puts a port into a port set.
 *	Conditions:
 *		Both port and port set are locked and active.
 *		The owner of the port set is also receiver for the port.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_pset_add</span>(
	ipc_pset_t	  pset,
	ipc_port_t	  port,
	uint64_t	 *reserved_link,
	uint64_t	 *reserved_prepost)
{
	kern_return_t kr;

	assert(ips_active(pset));
	assert(ip_active(port));
	
	kr = ipc_mqueue_add(&amp;port-&gt;ip_messages, &amp;pset-&gt;ips_messages,
			    reserved_link, reserved_prepost);

	<span class="enscript-keyword">return</span> kr;
}



<span class="enscript-comment">/*
 *	Routine:	ipc_pset_remove
 *	Purpose:
 *		Removes a port from a port set.
 *		The port set loses a reference.
 *	Conditions:
 *		Both port and port set are locked.
 *		The port must be active.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_pset_remove</span>(
	ipc_pset_t	  pset,
	ipc_port_t	  port)
{
	kern_return_t kr;

	assert(ip_active(port));
	
	<span class="enscript-keyword">if</span> (port-&gt;ip_in_pset == 0)
		<span class="enscript-keyword">return</span> KERN_NOT_IN_SET;

	kr = ipc_mqueue_remove(&amp;port-&gt;ip_messages, &amp;pset-&gt;ips_messages);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_pset_remove_from_all
 *	Purpose:
 *		Removes a port from all it's port sets.
 *	Conditions:
 *		port is locked and active.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_pset_remove_from_all</span>(
	ipc_port_t	port)
{
	assert(ip_active(port));
	
	<span class="enscript-keyword">if</span> (port-&gt;ip_in_pset == 0)
		<span class="enscript-keyword">return</span> KERN_NOT_IN_SET;

	<span class="enscript-comment">/* 
	 * Remove the port's mqueue from all sets
	 */</span>
	ipc_mqueue_remove_from_all(&amp;port-&gt;ip_messages);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_pset_destroy
 *	Purpose:
 *		Destroys a port_set.
 *	Conditions:
 *		The port_set is locked and alive.
 *		The caller has a reference, which is consumed.
 *		Afterwards, the port_set is unlocked and dead.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_pset_destroy</span>(
	ipc_pset_t	pset)
{
	spl_t		s;

	assert(ips_active(pset));

	pset-&gt;ips_object.io_bits &amp;= ~IO_BITS_ACTIVE;

	<span class="enscript-comment">/*
	 * remove all the member message queues
	 * AND remove this message queue from any containing sets
	 */</span>
	ipc_mqueue_remove_all(&amp;pset-&gt;ips_messages);
	
	<span class="enscript-comment">/*
	 * Set all waiters on the portset running to
	 * discover the change.
	 */</span>
	s = splsched();
	imq_lock(&amp;pset-&gt;ips_messages);
	ipc_mqueue_changed(&amp;pset-&gt;ips_messages);
	imq_unlock(&amp;pset-&gt;ips_messages);
	splx(s);

	ipc_mqueue_deinit(&amp;pset-&gt;ips_messages);

	ips_unlock(pset);
	ips_release(pset);       <span class="enscript-comment">/* consume the ref our caller gave us */</span>
}

<span class="enscript-comment">/* Kqueue EVFILT_MACHPORT support */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>      <span class="enscript-function-name">filt_machportattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_machportdetach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_machport(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">filt_machporttouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev, <span class="enscript-type">long</span> type);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-function-name">filt_machportpeek</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">struct</span> filterops machport_filtops = {
        .f_attach = filt_machportattach,
        .f_detach = filt_machportdetach,
        .f_event = filt_machport,
        .f_touch = filt_machporttouch,
	.f_peek = filt_machportpeek,
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_machportattach</span>(
        <span class="enscript-type">struct</span> knote *kn)
{
        mach_port_name_t        name = (mach_port_name_t)kn-&gt;kn_kevent.ident;
        uint64_t                wq_link_id = waitq_link_reserve(NULL);
        ipc_pset_t              pset = IPS_NULL;
        <span class="enscript-type">int</span>                     result = ENOSYS;
        kern_return_t           kr;

        kr = ipc_object_translate(current_space(), name,
                                  MACH_PORT_RIGHT_PORT_SET,
                                  (ipc_object_t *)&amp;pset);
        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		waitq_link_release(wq_link_id);
                <span class="enscript-keyword">return</span> (kr == KERN_INVALID_NAME ? ENOENT : ENOTSUP);
        }
        <span class="enscript-comment">/* We've got a lock on pset */</span>

	<span class="enscript-comment">/* 
	 * Bind the portset wait queue directly to knote/kqueue.
	 * This allows us to just use wait_queue foo to effect a wakeup,
	 * rather than having to call knote() from the Mach code on each
	 * message.
	 */</span>
	result = knote_link_waitq(kn, &amp;pset-&gt;ips_messages.imq_wait_queue, &amp;wq_link_id);
	<span class="enscript-keyword">if</span> (result == 0) {
		waitq_link_release(wq_link_id);
		<span class="enscript-comment">/* keep a reference for the knote */</span>
		kn-&gt;kn_ptr.p_pset = pset; 
		ips_reference(pset);
		ips_unlock(pset);
		<span class="enscript-keyword">return</span> 0;
	}

	ips_unlock(pset);
	waitq_link_release(wq_link_id);
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_machportdetach</span>(
        <span class="enscript-type">struct</span> knote *kn)
{
        ipc_pset_t              pset = kn-&gt;kn_ptr.p_pset;

	<span class="enscript-comment">/*
	 * Unlink the portset wait queue from knote/kqueue,
	 * and release our reference on the portset.
	 */</span>
	ips_lock(pset);
	(<span class="enscript-type">void</span>)knote_unlink_waitq(kn, &amp;pset-&gt;ips_messages.imq_wait_queue);
	kn-&gt;kn_ptr.p_pset = IPS_NULL;
	ips_unlock(pset);
	ips_release(pset);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_machport</span>(
        <span class="enscript-type">struct</span> knote *kn,
        __unused <span class="enscript-type">long</span> hint)
{
        mach_port_name_t        name = (mach_port_name_t)kn-&gt;kn_kevent.ident;
        ipc_pset_t              pset = IPS_NULL;
	wait_result_t		wresult;
	thread_t		self = current_thread();
        kern_return_t           kr;
	mach_msg_option_t	option;
	mach_msg_size_t		size;

	<span class="enscript-comment">/* never called from below */</span>
	assert(hint == 0);

	<span class="enscript-comment">/*
	 * called from user context. Have to validate the
	 * name.  If it changed, we have an EOF situation.
	 */</span>
	kr = ipc_object_translate(current_space(), name,
				  MACH_PORT_RIGHT_PORT_SET,
				  (ipc_object_t *)&amp;pset);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS || pset != kn-&gt;kn_ptr.p_pset || !ips_active(pset)) {
		kn-&gt;kn_data = 0;
		kn-&gt;kn_flags |= (EV_EOF | EV_ONESHOT);
		<span class="enscript-keyword">if</span> (pset != IPS_NULL) {
			ips_unlock(pset);
		}
		<span class="enscript-keyword">return</span>(1);
        }

	<span class="enscript-comment">/* just use the reference from here on out */</span>
	ips_reference(pset);
	ips_unlock(pset); 

	<span class="enscript-comment">/*
	 * Only honor supported receive options. If no options are
	 * provided, just force a MACH_RCV_TOO_LARGE to detect the
	 * name of the port and sizeof the waiting message.
	 */</span>
	option = kn-&gt;kn_sfflags &amp; (MACH_RCV_MSG|MACH_RCV_LARGE|MACH_RCV_LARGE_IDENTITY|
				   MACH_RCV_TRAILER_MASK|MACH_RCV_VOUCHER);
	<span class="enscript-keyword">if</span> (option &amp; MACH_RCV_MSG) {
		self-&gt;ith_msg_addr = (mach_vm_address_t) kn-&gt;kn_ext[0];
		size = (mach_msg_size_t)kn-&gt;kn_ext[1];
	} <span class="enscript-keyword">else</span> {
		option = MACH_RCV_LARGE;
		self-&gt;ith_msg_addr = 0;
		size = 0;
	}

	<span class="enscript-comment">/*
	 * Set up to receive a message or the notification of a
	 * too large message.  But never allow this call to wait.
	 * If the user provided aditional options, like trailer
	 * options, pass those through here.  But we don't support
	 * scatter lists through this interface.
	 */</span>
	self-&gt;ith_object = (ipc_object_t)pset;
	self-&gt;ith_msize = size;
	self-&gt;ith_option = option;
	self-&gt;ith_receiver_name = MACH_PORT_NULL;
	self-&gt;ith_continuation = NULL;
	option |= MACH_RCV_TIMEOUT; <span class="enscript-comment">// never wait
</span>	self-&gt;ith_state = MACH_RCV_IN_PROGRESS;

	wresult = ipc_mqueue_receive_on_thread(
			&amp;pset-&gt;ips_messages,
			option,
			size, <span class="enscript-comment">/* max_size */</span>
			0, <span class="enscript-comment">/* immediate timeout */</span>
			THREAD_INTERRUPTIBLE,
			self);
	assert(wresult == THREAD_NOT_WAITING);
	assert(self-&gt;ith_state != MACH_RCV_IN_PROGRESS);

	<span class="enscript-comment">/*
	 * If we timed out, just release the reference on the
	 * portset and return zero.
	 */</span>
	<span class="enscript-keyword">if</span> (self-&gt;ith_state == MACH_RCV_TIMED_OUT) {
		ips_release(pset);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/*
	 * If we weren't attempting to receive a message
	 * directly, we need to return the port name in
	 * the kevent structure.
	 */</span>
	<span class="enscript-keyword">if</span> ((option &amp; MACH_RCV_MSG) != MACH_RCV_MSG) {
		assert(self-&gt;ith_state == MACH_RCV_TOO_LARGE);
		assert(self-&gt;ith_kmsg == IKM_NULL);
		kn-&gt;kn_data = self-&gt;ith_receiver_name;
		ips_release(pset);
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-comment">/*
	 * Attempt to receive the message directly, returning
	 * the results in the fflags field.
	 */</span>
	assert(option &amp; MACH_RCV_MSG);
	kn-&gt;kn_ext[1] = self-&gt;ith_msize;
	kn-&gt;kn_data = MACH_PORT_NULL;
	kn-&gt;kn_fflags = mach_msg_receive_results();
	<span class="enscript-comment">/* kmsg and pset reference consumed */</span>

	<span class="enscript-comment">/*
	 * if the user asked for the identity of ports containing a
	 * a too-large message, return it in the data field (as we
	 * do for messages we didn't try to receive).
	 */</span>
        <span class="enscript-keyword">if</span> ((kn-&gt;kn_fflags == MACH_RCV_TOO_LARGE) &amp;&amp;
	    (option &amp; MACH_RCV_LARGE_IDENTITY))
	    kn-&gt;kn_data = self-&gt;ith_receiver_name;

	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_machporttouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev, <span class="enscript-type">long</span> type)
{
        <span class="enscript-keyword">switch</span> (type) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_REGISTER</span>:
                kn-&gt;kn_sfflags = kev-&gt;fflags;
                kn-&gt;kn_sdata = kev-&gt;data;
		kn-&gt;kn_ext[0] = kev-&gt;ext[0];
		kn-&gt;kn_ext[1] = kev-&gt;ext[1];
                <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_PROCESS</span>:
                *kev = kn-&gt;kn_kevent;
                <span class="enscript-keyword">if</span> (kn-&gt;kn_flags &amp; EV_CLEAR) {
			kn-&gt;kn_data = 0;
			kn-&gt;kn_fflags = 0;
		}
                <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
                panic(<span class="enscript-string">&quot;filt_machporttouch() - invalid type (%ld)&quot;</span>, type);
                <span class="enscript-keyword">break</span>;
        }
}

<span class="enscript-comment">/*
 * Peek to see if the portset associated with the knote has any
 * events. This pre-hook is called when a filter uses the stay-
 * on-queue mechanism (as the knote_link_waitq mechanism
 * does).
 *
 * This is called with the kqueue that the knote belongs to still
 * locked (thus holding a reference on the knote, but restricting
 * also restricting our ability to take other locks).
 *
 * Just peek at the pre-post status of the portset's wait queue
 * to determine if it has anything interesting.  We can do it
 * without holding the lock, as it is just a snapshot in time
 * (if this is used as part of really waiting for events, we
 * will catch changes in this status when the event gets posted
 * up to the knote's kqueue).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span>
<span class="enscript-function-name">filt_machportpeek</span>(<span class="enscript-type">struct</span> knote *kn)
{
        ipc_pset_t              pset = kn-&gt;kn_ptr.p_pset;
	ipc_mqueue_t		set_mq = &amp;pset-&gt;ips_messages;

	<span class="enscript-keyword">return</span> (ipc_mqueue_set_peek(set_mq));
}
</pre>
<hr />
</body></html>