<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_right.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_right.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 * Copyright (c) 2005-2006 SPARTA, Inc.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	ipc/ipc_right.c
 *	Author:	Rich Draves
 *	Date:	1989
 *
 *	Functions to manipulate IPC capabilities.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_hash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_pset.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_right.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_table.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_importance.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>

<span class="enscript-comment">/* Allow IPC to generate mach port guard exceptions */</span>
<span class="enscript-type">extern</span> kern_return_t
<span class="enscript-function-name">mach_port_guard_exception</span>(
	mach_port_name_t	name,
	uint64_t		inguard,
	uint64_t		portguard,
	<span class="enscript-type">unsigned</span>		reason);
<span class="enscript-comment">/*
 *	Routine:	ipc_right_lookup_write
 *	Purpose:
 *		Finds an entry in a space, given the name.
 *	Conditions:
 *		Nothing locked.  If successful, the space is write-locked.
 *	Returns:
 *		KERN_SUCCESS		Found an entry.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	Name doesn't exist in space.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_lookup_write</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		*entryp)
{
	ipc_entry_t entry;

	assert(space != IS_NULL);

	is_write_lock(space);

	<span class="enscript-keyword">if</span> (!is_active(space)) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
	}

	<span class="enscript-keyword">if</span> ((entry = ipc_entry_lookup(space, name)) == IE_NULL) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}

	*entryp = entry;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_lookup_two_write
 *	Purpose:
 *		Like ipc_right_lookup except that it returns two
 *		entries for two different names that were looked
 *		up under the same space lock.
 *	Conditions:
 *		Nothing locked.  If successful, the space is write-locked.
 *	Returns:
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	Name doesn't exist in space.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_lookup_two_write</span>(
	ipc_space_t		space,
	mach_port_name_t	name1,
	ipc_entry_t		*entryp1,
	mach_port_name_t	name2,
	ipc_entry_t		*entryp2)
{
	ipc_entry_t entry1;
	ipc_entry_t entry2;

	assert(space != IS_NULL);

	is_write_lock(space);

	<span class="enscript-keyword">if</span> (!is_active(space)) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
	}

	<span class="enscript-keyword">if</span> ((entry1 = ipc_entry_lookup(space, name1)) == IE_NULL) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}
	<span class="enscript-keyword">if</span> ((entry2 = ipc_entry_lookup(space, name2)) == IE_NULL) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}
	*entryp1 = entry1;
	*entryp2 = entry2;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_reverse
 *	Purpose:
 *		Translate (space, object) -&gt; (name, entry).
 *		Only finds send/receive rights.
 *		Returns TRUE if an entry is found; if so,
 *		the object is locked and active.
 *	Conditions:
 *		The space must be locked (read or write) and active.
 *		Nothing else locked.
 */</span>

boolean_t
<span class="enscript-function-name">ipc_right_reverse</span>(
	ipc_space_t		space,
	ipc_object_t		object,
	mach_port_name_t	*namep,
	ipc_entry_t		*entryp)
{
	ipc_port_t port;
	mach_port_name_t name;
	ipc_entry_t entry;

	<span class="enscript-comment">/* would switch on io_otype to handle multiple types of object */</span>

	assert(is_active(space));
	assert(io_otype(object) == IOT_PORT);

	port = (ipc_port_t) object;

	ip_lock(port);
	<span class="enscript-keyword">if</span> (!ip_active(port)) {
		ip_unlock(port);

		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">if</span> (port-&gt;ip_receiver == space) {
		name = port-&gt;ip_receiver_name;
		assert(name != MACH_PORT_NULL);

		entry = ipc_entry_lookup(space, name);

		assert(entry != IE_NULL);
		assert(entry-&gt;ie_bits &amp; MACH_PORT_TYPE_RECEIVE);
		assert(port == (ipc_port_t) entry-&gt;ie_object);

		*namep = name;
		*entryp = entry;
		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-keyword">if</span> (ipc_hash_lookup(space, (ipc_object_t) port, namep, entryp)) {
		assert((entry = *entryp) != IE_NULL);
		assert(IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_SEND);
		assert(port == (ipc_port_t) entry-&gt;ie_object);

		<span class="enscript-keyword">return</span> TRUE;
	}

	ip_unlock(port);
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_dnrequest
 *	Purpose:
 *		Make a dead-name request, returning the previously
 *		registered send-once right.  If notify is IP_NULL,
 *		just cancels the previously registered request.
 *
 *	Conditions:
 *		Nothing locked.  May allocate memory.
 *		Only consumes/returns refs if successful.
 *	Returns:
 *		KERN_SUCCESS		Made/canceled dead-name request.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	Name doesn't exist in space.
 *		KERN_INVALID_RIGHT	Name doesn't denote port/dead rights.
 *		KERN_INVALID_ARGUMENT	Name denotes dead name, but
 *			immediate is FALSE or notify is IP_NULL.
 *		KERN_UREFS_OVERFLOW	Name denotes dead name, but
 *			generating immediate notif. would overflow urefs.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_request_alloc</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	boolean_t		immediate,
	boolean_t		send_possible,
	ipc_port_t		notify,
	ipc_port_t		*previousp)
{
	ipc_port_request_index_t prev_request;
	ipc_port_t previous = IP_NULL;
	ipc_entry_t entry;
	kern_return_t kr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	boolean_t needboost = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">for</span> (;;) {
		ipc_port_t port = IP_NULL;

		kr = ipc_right_lookup_write(space, name, &amp;entry);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;

		<span class="enscript-comment">/* space is write-locked and active */</span>
		
		prev_request = entry-&gt;ie_request;

		<span class="enscript-comment">/* if nothing to do or undo, we're done */</span>
		<span class="enscript-keyword">if</span> (notify == IP_NULL &amp;&amp; prev_request == IE_REQ_NONE) {
			is_write_unlock(space);
			*previousp = IP_NULL;
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}

		<span class="enscript-comment">/* see if the entry is of proper type for requests */</span>
		<span class="enscript-keyword">if</span> (entry-&gt;ie_bits &amp; MACH_PORT_TYPE_PORT_RIGHTS) {
			ipc_port_request_index_t new_request;

			port = (ipc_port_t) entry-&gt;ie_object;
			assert(port != IP_NULL);

			<span class="enscript-keyword">if</span> (!ipc_right_check(space, port, name, entry)) {
				<span class="enscript-comment">/* port is locked and active */</span>

				<span class="enscript-comment">/* if no new request, just cancel previous */</span>
				<span class="enscript-keyword">if</span> (notify == IP_NULL) {
					<span class="enscript-keyword">if</span> (prev_request != IE_REQ_NONE)
						previous = ipc_port_request_cancel(port, name, prev_request);
					ip_unlock(port);
					entry-&gt;ie_request = IE_REQ_NONE;
					ipc_entry_modified(space, name, entry);
					is_write_unlock(space);
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/*
				 * send-once rights, kernel objects, and non-full other queues
				 * fire immediately (if immediate specified).
				 */</span>
				<span class="enscript-keyword">if</span> (send_possible &amp;&amp; immediate &amp;&amp;
				    ((entry-&gt;ie_bits &amp; MACH_PORT_TYPE_SEND_ONCE) ||
				     port-&gt;ip_receiver == ipc_space_kernel || !ip_full(port))) {
					<span class="enscript-keyword">if</span> (prev_request != IE_REQ_NONE)
						previous = ipc_port_request_cancel(port, name, prev_request);
					ip_unlock(port);
					entry-&gt;ie_request = IE_REQ_NONE;
					ipc_entry_modified(space, name, entry);
					is_write_unlock(space);

					ipc_notify_send_possible(notify, name);
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/*
				 * If there is a previous request, free it.  Any subsequent
				 * allocation cannot fail, thus assuring an atomic swap.
				 */</span>
				<span class="enscript-keyword">if</span> (prev_request != IE_REQ_NONE)
					previous = ipc_port_request_cancel(port, name, prev_request);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
				kr = ipc_port_request_alloc(port, name, notify,
							    send_possible, immediate,
							    &amp;new_request, &amp;needboost);
#<span class="enscript-reference">else</span>
				kr = ipc_port_request_alloc(port, name, notify,
							    send_possible, immediate,
							    &amp;new_request);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
				<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
					assert(previous == IP_NULL);
					is_write_unlock(space);

					kr = ipc_port_request_grow(port, ITS_SIZE_NONE);
					<span class="enscript-comment">/* port is unlocked */</span>

					<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
						<span class="enscript-keyword">return</span> kr;

					<span class="enscript-keyword">continue</span>;
				}


				assert(new_request != IE_REQ_NONE);
				entry-&gt;ie_request = new_request;
				ipc_entry_modified(space, name, entry);
				is_write_unlock(space);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
				<span class="enscript-keyword">if</span> (needboost == TRUE) {
					<span class="enscript-keyword">if</span> (ipc_port_importance_delta(port, 1) == FALSE)
						ip_unlock(port);
				} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
					ip_unlock(port);

				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/* entry may have changed to dead-name by ipc_right_check() */</span>

		}

		<span class="enscript-comment">/* treat send_possible requests as immediate w.r.t. dead-name */</span>
		<span class="enscript-keyword">if</span> ((send_possible || immediate) &amp;&amp; notify != IP_NULL &amp;&amp;
		    (entry-&gt;ie_bits &amp; MACH_PORT_TYPE_DEAD_NAME)) {
			mach_port_urefs_t urefs = IE_BITS_UREFS(entry-&gt;ie_bits);

			assert(urefs &gt; 0);

			<span class="enscript-keyword">if</span> (MACH_PORT_UREFS_OVERFLOW(urefs, 1)) {
				is_write_unlock(space);
				<span class="enscript-keyword">if</span> (port != IP_NULL)
					ip_release(port);
				<span class="enscript-keyword">return</span> KERN_UREFS_OVERFLOW;
			}

			(entry-&gt;ie_bits)++; <span class="enscript-comment">/* increment urefs */</span>
			ipc_entry_modified(space, name, entry);
			is_write_unlock(space);

			<span class="enscript-keyword">if</span> (port != IP_NULL)
				ip_release(port);

			ipc_notify_dead_name(notify, name);
			previous = IP_NULL;
			<span class="enscript-keyword">break</span>;
		}

		is_write_unlock(space);

		<span class="enscript-keyword">if</span> (port != IP_NULL)
			ip_release(port);

		<span class="enscript-keyword">if</span> (entry-&gt;ie_bits &amp; MACH_PORT_TYPE_PORT_OR_DEAD)
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	*previousp = previous;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_request_cancel
 *	Purpose:
 *		Cancel a notification request and return the send-once right.
 *		Afterwards, entry-&gt;ie_request == 0.
 *	Conditions:
 *		The space must be write-locked; the port must be locked.
 *		The port must be active; the space doesn't have to be.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_right_request_cancel</span>(
	__unused ipc_space_t		space,
	ipc_port_t			port,
	mach_port_name_t		name,
	ipc_entry_t			entry)
{
	ipc_port_t previous;

	assert(ip_active(port));
	assert(port == (ipc_port_t) entry-&gt;ie_object);

	<span class="enscript-keyword">if</span> (entry-&gt;ie_request == IE_REQ_NONE)
		<span class="enscript-keyword">return</span> IP_NULL;

	previous = ipc_port_request_cancel(port, name, entry-&gt;ie_request);
	entry-&gt;ie_request = IE_REQ_NONE;
	ipc_entry_modified(space, name, entry);
	<span class="enscript-keyword">return</span> previous;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_inuse
 *	Purpose:
 *		Check if an entry is being used.
 *		Returns TRUE if it is.
 *	Conditions:
 *		The space is write-locked and active.
 *		It is unlocked if the entry is inuse.
 */</span>

boolean_t
<span class="enscript-function-name">ipc_right_inuse</span>(
	ipc_space_t			space,
	__unused mach_port_name_t	name,
	ipc_entry_t			entry)
{
	<span class="enscript-keyword">if</span> (IE_BITS_TYPE(entry-&gt;ie_bits) != MACH_PORT_TYPE_NONE) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> TRUE;
	}
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_check
 *	Purpose:
 *		Check if the port has died.  If it has,
 *		clean up the entry and return TRUE.
 *	Conditions:
 *		The space is write-locked; the port is not locked.
 *		If returns FALSE, the port is also locked and active.
 *		Otherwise, entry is converted to a dead name.
 *
 *		Caller is responsible for a reference to port if it
 *		had died (returns TRUE).
 */</span>

boolean_t
<span class="enscript-function-name">ipc_right_check</span>(
	ipc_space_t		space,
	ipc_port_t		port,
	mach_port_name_t	name,
	ipc_entry_t		entry)
{
	ipc_entry_bits_t bits;

	assert(is_active(space));
	assert(port == (ipc_port_t) entry-&gt;ie_object);

	ip_lock(port);
	<span class="enscript-keyword">if</span> (ip_active(port))
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-comment">/* this was either a pure send right or a send-once right */</span>

	bits = entry-&gt;ie_bits;
	assert((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0);
	assert(IE_BITS_UREFS(bits) &gt; 0);

	<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND) {
                assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND);
		assert(IE_BITS_UREFS(bits) &gt; 0);
		assert(port-&gt;ip_srights &gt; 0);
		port-&gt;ip_srights--;
        } <span class="enscript-keyword">else</span> {
                assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);
                assert(IE_BITS_UREFS(bits) == 1);
		assert(port-&gt;ip_sorights &gt; 0);
		port-&gt;ip_sorights--;
        }
	ip_unlock(port);

	<span class="enscript-comment">/*
	 * delete SEND rights from ipc hash.
	 */</span>

	<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) != 0) {
		ipc_hash_delete(space, (ipc_object_t)port, name, entry);
	}

	<span class="enscript-comment">/* convert entry to dead name */</span>
	bits = (bits &amp;~ IE_BITS_TYPE_MASK) | MACH_PORT_TYPE_DEAD_NAME;
	
	<span class="enscript-comment">/*
	 * If there was a notification request outstanding on this
	 * name, and the port went dead, that notification
	 * must already be on its way up from the port layer.
	 *
	 * Add the reference that the notification carries. It
	 * is done here, and not in the notification delivery,
	 * because the latter doesn't have a space reference and
	 * trying to actually move a send-right reference would
	 * get short-circuited into a MACH_PORT_DEAD by IPC. Since
	 * all calls that deal with the right eventually come
	 * through here, it has the same result.
	 *
	 * Once done, clear the request index so we only account
	 * for it once.
	 */</span>
	<span class="enscript-keyword">if</span> (entry-&gt;ie_request != IE_REQ_NONE) {
		<span class="enscript-keyword">if</span> (ipc_port_request_type(port, name, entry-&gt;ie_request) != 0) {
			assert(IE_BITS_UREFS(bits) &lt; MACH_PORT_UREFS_MAX);
			bits++;	
		}
		entry-&gt;ie_request = IE_REQ_NONE; 
	}
	entry-&gt;ie_bits = bits;
	entry-&gt;ie_object = IO_NULL;
	ipc_entry_modified(space, name, entry);
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_terminate
 *	Purpose:
 *		Cleans up an entry in a terminated space.
 *		The entry isn't deallocated or removed
 *		from reverse hash tables.
 *	Conditions:
 *		The space is dead and unlocked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_right_terminate</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry)
{
	ipc_entry_bits_t bits;
	mach_port_type_t type;

	bits = entry-&gt;ie_bits;
	type = IE_BITS_TYPE(bits);

	assert(!is_active(space));

	<span class="enscript-comment">/*
	 *	IE_BITS_COMPAT/ipc_right_dncancel doesn't have this
	 *	problem, because we check that the port is active.  If
	 *	we didn't cancel IE_BITS_COMPAT, ipc_port_destroy
	 *	would still work, but dead space refs would accumulate
	 *	in ip_dnrequests.  They would use up slots in
	 *	ip_dnrequests and keep the spaces from being freed.
	 */</span>

	<span class="enscript-keyword">switch</span> (type) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_DEAD_NAME</span>:
		assert(entry-&gt;ie_request == IE_REQ_NONE);
		assert(entry-&gt;ie_object == IO_NULL);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_PORT_SET</span>: {
		ipc_pset_t pset = (ipc_pset_t) entry-&gt;ie_object;

		assert(entry-&gt;ie_request == IE_REQ_NONE);
		assert(pset != IPS_NULL);

		ips_lock(pset);
		assert(ips_active(pset));
		ipc_pset_destroy(pset); <span class="enscript-comment">/* consumes ref, unlocks */</span>
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_RECEIVE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_RECEIVE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_ONCE</span>: {
		ipc_port_t port = (ipc_port_t) entry-&gt;ie_object;
		ipc_port_t request;
		ipc_port_t nsrequest = IP_NULL;
		mach_port_mscount_t mscount = 0;

		assert(port != IP_NULL);
		ip_lock(port);

		<span class="enscript-keyword">if</span> (!ip_active(port)) {
			ip_unlock(port);
			ip_release(port);
			<span class="enscript-keyword">break</span>;
		}

		request = ipc_right_request_cancel_macro(space, port, 
					name, entry);

		<span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE_SEND) {
			assert(port-&gt;ip_srights &gt; 0);
			<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0
			    ) {
				nsrequest = port-&gt;ip_nsrequest;
				<span class="enscript-keyword">if</span> (nsrequest != IP_NULL) {
					port-&gt;ip_nsrequest = IP_NULL;
					mscount = port-&gt;ip_mscount;
				}
			}
		}

		<span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE_RECEIVE) {
			assert(port-&gt;ip_receiver_name == name);
			assert(port-&gt;ip_receiver == space);

			ipc_port_clear_receiver(port);
			ipc_port_destroy(port); <span class="enscript-comment">/* consumes our ref, unlocks */</span>

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE_SEND_ONCE) {
			assert(port-&gt;ip_sorights &gt; 0);
			ip_unlock(port);

			ipc_notify_send_once(port); <span class="enscript-comment">/* consumes our ref */</span>
		} <span class="enscript-keyword">else</span> {
			assert(port-&gt;ip_receiver != space);

			ip_unlock(port);
			ip_release(port);			
		}

		<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
			ipc_notify_no_senders(nsrequest, mscount);

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_right_terminate: strange type - 0x%x&quot;</span>, type);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_destroy
 *	Purpose:
 *		Destroys an entry in a space.
 *	Conditions:
 *		The space is write-locked (returns unlocked).
 *		The space must be active.
 *	Returns:
 *		KERN_SUCCESS		The entry was destroyed.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_destroy</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	boolean_t		check_guard,
	uint64_t		guard)
{
	ipc_entry_bits_t bits;
	mach_port_type_t type;

	bits = entry-&gt;ie_bits;
	entry-&gt;ie_bits &amp;= ~IE_BITS_TYPE_MASK;
	type = IE_BITS_TYPE(bits);

	assert(is_active(space));

	<span class="enscript-keyword">switch</span> (type) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_DEAD_NAME</span>:
		assert(entry-&gt;ie_request == IE_REQ_NONE);
		assert(entry-&gt;ie_object == IO_NULL);

		ipc_entry_dealloc(space, name, entry);
		is_write_unlock(space);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_PORT_SET</span>: {
		ipc_pset_t pset = (ipc_pset_t) entry-&gt;ie_object;

		assert(entry-&gt;ie_request == IE_REQ_NONE);
		assert(pset != IPS_NULL);

		entry-&gt;ie_object = IO_NULL;
		ipc_entry_dealloc(space, name, entry);

		ips_lock(pset);
		is_write_unlock(space);

		assert(ips_active(pset));
		ipc_pset_destroy(pset); <span class="enscript-comment">/* consumes ref, unlocks */</span>
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_RECEIVE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_RECEIVE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_ONCE</span>: {
		ipc_port_t port = (ipc_port_t) entry-&gt;ie_object;
		ipc_port_t nsrequest = IP_NULL;
		mach_port_mscount_t mscount = 0;
		ipc_port_t request;

		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (type == MACH_PORT_TYPE_SEND)
			ipc_hash_delete(space, (ipc_object_t) port,
					name, entry);

		ip_lock(port);

		<span class="enscript-keyword">if</span> (!ip_active(port)) {
			assert((type &amp; MACH_PORT_TYPE_RECEIVE) == 0);
			ip_unlock(port);
			entry-&gt;ie_request = IE_REQ_NONE;
			entry-&gt;ie_object = IO_NULL;
			ipc_entry_dealloc(space, name, entry);
			is_write_unlock(space);
			ip_release(port);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* For receive rights, check for guarding */</span>
		<span class="enscript-keyword">if</span> ((type &amp; MACH_PORT_TYPE_RECEIVE) &amp;&amp;
		    (check_guard) &amp;&amp; (port-&gt;ip_guarded) &amp;&amp;
		    (guard != port-&gt;ip_context)) {
			<span class="enscript-comment">/* Guard Violation */</span>
			uint64_t portguard = port-&gt;ip_context;
			ip_unlock(port);
			is_write_unlock(space);
			<span class="enscript-comment">/* Raise mach port guard exception */</span>
			mach_port_guard_exception(name, 0, portguard, kGUARD_EXC_DESTROY);
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;		
		}


		request = ipc_right_request_cancel_macro(space, port, name, entry);

		entry-&gt;ie_object = IO_NULL;
		ipc_entry_dealloc(space, name, entry);
		is_write_unlock(space);

		<span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE_SEND) {
			assert(port-&gt;ip_srights &gt; 0);
			<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0) {
				nsrequest = port-&gt;ip_nsrequest;
				<span class="enscript-keyword">if</span> (nsrequest != IP_NULL) {
					port-&gt;ip_nsrequest = IP_NULL;
					mscount = port-&gt;ip_mscount;
				}
			}
		}

		<span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE_RECEIVE) {
			assert(ip_active(port));
			assert(port-&gt;ip_receiver == space);

			ipc_port_clear_receiver(port);
			ipc_port_destroy(port); <span class="enscript-comment">/* consumes our ref, unlocks */</span>

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE_SEND_ONCE) {
			assert(port-&gt;ip_sorights &gt; 0);
			ip_unlock(port);

			ipc_notify_send_once(port); <span class="enscript-comment">/* consumes our ref */</span>
		} <span class="enscript-keyword">else</span> {
			assert(port-&gt;ip_receiver != space);

			ip_unlock(port);
			ip_release(port);
		}

		<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
			ipc_notify_no_senders(nsrequest, mscount);

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);


		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_right_destroy: strange type&quot;</span>);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_dealloc
 *	Purpose:
 *		Releases a send/send-once/dead-name user ref.
 *		Like ipc_right_delta with a delta of -1,
 *		but looks at the entry to determine the right.
 *	Conditions:
 *		The space is write-locked, and is unlocked upon return.
 *		The space must be active.
 *	Returns:
 *		KERN_SUCCESS		A user ref was released.
 *		KERN_INVALID_RIGHT	Entry has wrong type.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_dealloc</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry)
{
	ipc_port_t port = IP_NULL;
	ipc_entry_bits_t bits;
	mach_port_type_t type;

	bits = entry-&gt;ie_bits;
	type = IE_BITS_TYPE(bits);


	assert(is_active(space));

	<span class="enscript-keyword">switch</span> (type) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_DEAD_NAME</span>: {
	    <span class="enscript-reference">dead_name</span>:

		assert(IE_BITS_UREFS(bits) &gt; 0);
		assert(entry-&gt;ie_request == IE_REQ_NONE);
		assert(entry-&gt;ie_object == IO_NULL);

		<span class="enscript-keyword">if</span> (IE_BITS_UREFS(bits) == 1) {
			ipc_entry_dealloc(space, name, entry);
		} <span class="enscript-keyword">else</span> {
			entry-&gt;ie_bits = bits-1; <span class="enscript-comment">/* decrement urefs */</span>
			ipc_entry_modified(space, name, entry);
		}
		is_write_unlock(space);

		<span class="enscript-comment">/* release any port that got converted to dead name below */</span>
		<span class="enscript-keyword">if</span> (port != IP_NULL)
			ip_release(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_ONCE</span>: {
		ipc_port_t request;

		assert(IE_BITS_UREFS(bits) == 1);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {

			bits = entry-&gt;ie_bits;
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dead_name</span>;     <span class="enscript-comment">/* it will release port */</span>
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		assert(port-&gt;ip_sorights &gt; 0);

		request = ipc_right_request_cancel_macro(space, port, name, entry);
		ip_unlock(port);

		entry-&gt;ie_object = IO_NULL;
		ipc_entry_dealloc(space, name, entry);

		is_write_unlock(space);

		ipc_notify_send_once(port);

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND</span>: {
		ipc_port_t request = IP_NULL;
		ipc_port_t nsrequest = IP_NULL;
		mach_port_mscount_t mscount =  0;


		assert(IE_BITS_UREFS(bits) &gt; 0);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
			bits = entry-&gt;ie_bits;
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dead_name</span>;     <span class="enscript-comment">/* it will release port */</span>
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		assert(port-&gt;ip_srights &gt; 0);

		<span class="enscript-keyword">if</span> (IE_BITS_UREFS(bits) == 1) {
			<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0) {
				nsrequest = port-&gt;ip_nsrequest;
				<span class="enscript-keyword">if</span> (nsrequest != IP_NULL) {
					port-&gt;ip_nsrequest = IP_NULL;
					mscount = port-&gt;ip_mscount;
				}
			}

			request = ipc_right_request_cancel_macro(space, port,
							     name, entry);
			ipc_hash_delete(space, (ipc_object_t) port,
					name, entry);

			ip_unlock(port);
			entry-&gt;ie_object = IO_NULL;
			ipc_entry_dealloc(space, name, entry);
			is_write_unlock(space);
			ip_release(port);

		} <span class="enscript-keyword">else</span> {
			ip_unlock(port);			
			entry-&gt;ie_bits = bits-1; <span class="enscript-comment">/* decrement urefs */</span>
			ipc_entry_modified(space, name, entry);
			is_write_unlock(space);
		}
		

		<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
			ipc_notify_no_senders(nsrequest, mscount);

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_RECEIVE</span>: {
		ipc_port_t nsrequest = IP_NULL;
		mach_port_mscount_t mscount = 0;

		assert(IE_BITS_UREFS(bits) &gt; 0);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == name);
		assert(port-&gt;ip_receiver == space);
		assert(port-&gt;ip_srights &gt; 0);

		<span class="enscript-keyword">if</span> (IE_BITS_UREFS(bits) == 1) {
			<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0) {
				nsrequest = port-&gt;ip_nsrequest;
				<span class="enscript-keyword">if</span> (nsrequest != IP_NULL) {
					port-&gt;ip_nsrequest = IP_NULL;
					mscount = port-&gt;ip_mscount;
				}
			}

			entry-&gt;ie_bits = bits &amp;~ (IE_BITS_UREFS_MASK |
						  MACH_PORT_TYPE_SEND);
		} <span class="enscript-keyword">else</span>
			entry-&gt;ie_bits = bits-1; <span class="enscript-comment">/* decrement urefs */</span>

		ip_unlock(port);

		ipc_entry_modified(space, name, entry);
		is_write_unlock(space);

		<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
			ipc_notify_no_senders(nsrequest, mscount);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_delta
 *	Purpose:
 *		Modifies the user-reference count for a right.
 *		May deallocate the right, if the count goes to zero.
 *	Conditions:
 *		The space is write-locked, and is unlocked upon return.
 *		The space must be active.
 *	Returns:
 *		KERN_SUCCESS		Count was modified.
 *		KERN_INVALID_RIGHT	Entry has wrong type.
 *		KERN_INVALID_VALUE	Bad delta for the right.
 *		KERN_UREFS_OVERFLOW	OK delta, except would overflow.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_delta</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_port_right_t	right,
	mach_port_delta_t	delta)
{
	ipc_port_t port = IP_NULL;
	ipc_entry_bits_t bits;

	bits = entry-&gt;ie_bits;


<span class="enscript-comment">/*
 *	The following is used (for case MACH_PORT_RIGHT_DEAD_NAME) in the
 *	switch below. It is used to keep track of those cases (in DIPC)
 *	where we have postponed the dropping of a port reference. Since
 *	the dropping of the reference could cause the port to disappear
 *	we postpone doing so when we are holding the space lock.
 */</span>

	assert(is_active(space));
	assert(right &lt; MACH_PORT_RIGHT_NUMBER);

	<span class="enscript-comment">/* Rights-specific restrictions and operations. */</span>

	<span class="enscript-keyword">switch</span> (right) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_PORT_SET</span>: {
		ipc_pset_t pset;

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_PORT_SET) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_PORT_SET);
		assert(IE_BITS_UREFS(bits) == 0);
		assert(entry-&gt;ie_request == IE_REQ_NONE);

		<span class="enscript-keyword">if</span> (delta == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">success</span>;

		<span class="enscript-keyword">if</span> (delta != -1)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;

		pset = (ipc_pset_t) entry-&gt;ie_object;
		assert(pset != IPS_NULL);

		entry-&gt;ie_object = IO_NULL;
		ipc_entry_dealloc(space, name, entry);

		ips_lock(pset);
		assert(ips_active(pset));
		is_write_unlock(space);

		ipc_pset_destroy(pset); <span class="enscript-comment">/* consumes ref, unlocks */</span>
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_RECEIVE</span>: {
		ipc_port_t request = IP_NULL;

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		<span class="enscript-keyword">if</span> (delta == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">success</span>;

		<span class="enscript-keyword">if</span> (delta != -1)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-comment">/*
		 *	The port lock is needed for ipc_right_dncancel;
		 *	otherwise, we wouldn't have to take the lock
		 *	until just before dropping the space lock.
		 */</span>

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == name);
		assert(port-&gt;ip_receiver == space);
		
		<span class="enscript-comment">/* Mach Port Guard Checking */</span>
		<span class="enscript-keyword">if</span>(port-&gt;ip_guarded) {
			uint64_t portguard = port-&gt;ip_context;
			ip_unlock(port);
			is_write_unlock(space);
			<span class="enscript-comment">/* Raise mach port guard exception */</span>
			mach_port_guard_exception(name, 0, portguard, kGUARD_EXC_MOD_REFS);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">guard_failure</span>;
		}
	
		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND) {
			assert(IE_BITS_TYPE(bits) ==
					MACH_PORT_TYPE_SEND_RECEIVE);
			assert(IE_BITS_UREFS(bits) &gt; 0);
			assert(IE_BITS_UREFS(bits) &lt; MACH_PORT_UREFS_MAX);
			assert(port-&gt;ip_srights &gt; 0);

			<span class="enscript-keyword">if</span> (port-&gt;ip_pdrequest != NULL) {
				<span class="enscript-comment">/*
				 * Since another task has requested a
				 * destroy notification for this port, it
				 * isn't actually being destroyed - the receive
				 * right is just being moved to another task.
				 * Since we still have one or more send rights,
				 * we need to record the loss of the receive
				 * right and enter the remaining send right
				 * into the hash table.
				 */</span>
				ipc_entry_modified(space, name, entry);
				entry-&gt;ie_bits &amp;= ~MACH_PORT_TYPE_RECEIVE;
				ipc_hash_insert(space, (ipc_object_t) port,
				    name, entry);
				ip_reference(port);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 *	The remaining send right turns into a
				 *	dead name.  Notice we don't decrement
				 *	ip_srights, generate a no-senders notif,
				 *	or use ipc_right_dncancel, because the
				 *	port is destroyed &quot;first&quot;.
				 */</span>
				bits &amp;= ~IE_BITS_TYPE_MASK;
				bits |= MACH_PORT_TYPE_DEAD_NAME;
				<span class="enscript-keyword">if</span> (entry-&gt;ie_request) {
					entry-&gt;ie_request = IE_REQ_NONE;
					bits++;
				}
				entry-&gt;ie_bits = bits;
				entry-&gt;ie_object = IO_NULL;
				ipc_entry_modified(space, name, entry);
			}
		} <span class="enscript-keyword">else</span> {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_RECEIVE);
			assert(IE_BITS_UREFS(bits) == 0);

			request = ipc_right_request_cancel_macro(space, port,
							     name, entry);
			entry-&gt;ie_object = IO_NULL;
			ipc_entry_dealloc(space, name, entry);
		}
		is_write_unlock(space);

		ipc_port_clear_receiver(port);
		ipc_port_destroy(port);	<span class="enscript-comment">/* consumes ref, unlocks */</span>

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_SEND_ONCE</span>: {
		ipc_port_t request;

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_ONCE) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);
		assert(IE_BITS_UREFS(bits) == 1);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
			assert(!(entry-&gt;ie_bits &amp; MACH_PORT_TYPE_SEND_ONCE));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		assert(port-&gt;ip_sorights &gt; 0);

		<span class="enscript-keyword">if</span> ((delta &gt; 0) || (delta &lt; -1)) {
			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;
		}

		<span class="enscript-keyword">if</span> (delta == 0) {
			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">success</span>;
		}

		request = ipc_right_request_cancel_macro(space, port, name, entry);
		ip_unlock(port);

		entry-&gt;ie_object = IO_NULL;
		ipc_entry_dealloc(space, name, entry);

		is_write_unlock(space);

		ipc_notify_send_once(port);

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_DEAD_NAME</span>: {
		ipc_port_t relport = IP_NULL;
		mach_port_urefs_t urefs;

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) {

			port = (ipc_port_t) entry-&gt;ie_object;
			assert(port != IP_NULL);

			<span class="enscript-keyword">if</span> (!ipc_right_check(space, port, name, entry)) {
				<span class="enscript-comment">/* port is locked and active */</span>
				ip_unlock(port);
				port = IP_NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
			}
			bits = entry-&gt;ie_bits;
			relport = port;
			port = IP_NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_DEAD_NAME) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
		assert(IE_BITS_UREFS(bits) &gt; 0);
		assert(entry-&gt;ie_object == IO_NULL);
		assert(entry-&gt;ie_request == IE_REQ_NONE);

		urefs = IE_BITS_UREFS(bits);
		<span class="enscript-keyword">if</span> (MACH_PORT_UREFS_UNDERFLOW(urefs, delta))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;
		<span class="enscript-keyword">if</span> (MACH_PORT_UREFS_OVERFLOW(urefs, delta))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">urefs_overflow</span>;

		<span class="enscript-keyword">if</span> ((urefs + delta) == 0) {
			ipc_entry_dealloc(space, name, entry);
		} <span class="enscript-keyword">else</span> {
			entry-&gt;ie_bits = bits + delta;
			ipc_entry_modified(space, name, entry);
		}
		is_write_unlock(space);

		<span class="enscript-keyword">if</span> (relport != IP_NULL)
			ip_release(relport);

		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_SEND</span>: {
		mach_port_urefs_t urefs;
		ipc_port_t request = IP_NULL;
		ipc_port_t nsrequest = IP_NULL;
		mach_port_mscount_t mscount = 0;

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		<span class="enscript-comment">/* maximum urefs for send is MACH_PORT_UREFS_MAX-1 */</span>

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
			assert((entry-&gt;ie_bits &amp; MACH_PORT_TYPE_SEND) == 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		assert(port-&gt;ip_srights &gt; 0);

		urefs = IE_BITS_UREFS(bits);
		<span class="enscript-keyword">if</span> (MACH_PORT_UREFS_UNDERFLOW(urefs, delta)) {
			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;
		}
		<span class="enscript-keyword">if</span> (MACH_PORT_UREFS_OVERFLOW(urefs+1, delta)) {
			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">urefs_overflow</span>;
		}

		<span class="enscript-keyword">if</span> ((urefs + delta) == 0) {
			<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0) {
				nsrequest = port-&gt;ip_nsrequest;
				<span class="enscript-keyword">if</span> (nsrequest != IP_NULL) {
					port-&gt;ip_nsrequest = IP_NULL;
					mscount = port-&gt;ip_mscount;
				}
			}

			<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_RECEIVE) {
				assert(port-&gt;ip_receiver_name == name);
				assert(port-&gt;ip_receiver == space);
				ip_unlock(port);				
				assert(IE_BITS_TYPE(bits) ==
						MACH_PORT_TYPE_SEND_RECEIVE);

				entry-&gt;ie_bits = bits &amp;~ (IE_BITS_UREFS_MASK|
						       MACH_PORT_TYPE_SEND);
				ipc_entry_modified(space, name, entry);
			} <span class="enscript-keyword">else</span> {
				assert(IE_BITS_TYPE(bits) ==
						MACH_PORT_TYPE_SEND);

				request = ipc_right_request_cancel_macro(space, port,
								     name, entry);
				ipc_hash_delete(space, (ipc_object_t) port,
						name, entry);

				ip_unlock(port);
				ip_release(port);

				entry-&gt;ie_object = IO_NULL;
				ipc_entry_dealloc(space, name, entry);
			}
		} <span class="enscript-keyword">else</span> {
			ip_unlock(port);
			entry-&gt;ie_bits = bits + delta;
			ipc_entry_modified(space, name, entry);
		}

		is_write_unlock(space);

		<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
			ipc_notify_no_senders(nsrequest, mscount);

		<span class="enscript-keyword">if</span> (request != IP_NULL)
			ipc_notify_port_deleted(request, name);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_right_delta: strange right&quot;</span>);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;

    <span class="enscript-reference">success</span>:
	is_write_unlock(space);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;

    <span class="enscript-reference">invalid_right</span>:
	is_write_unlock(space);
	<span class="enscript-keyword">if</span> (port != IP_NULL)
		ip_release(port);
	<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

    <span class="enscript-reference">invalid_value</span>:
	is_write_unlock(space);
	<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

    <span class="enscript-reference">urefs_overflow</span>:
	is_write_unlock(space);
	<span class="enscript-keyword">return</span> KERN_UREFS_OVERFLOW;
	
    <span class="enscript-reference">guard_failure</span>:
	<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;		
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_destruct
 *	Purpose:
 *		Deallocates the receive right and modifies the	
 *		user-reference count for the send rights as requested.
 *	Conditions:
 *		The space is write-locked, and is unlocked upon return.
 *		The space must be active.
 *	Returns:
 *		KERN_SUCCESS		Count was modified.
 *		KERN_INVALID_RIGHT	Entry has wrong type.
 *		KERN_INVALID_VALUE	Bad delta for the right.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_destruct</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_port_delta_t	srdelta,
	uint64_t		guard)
{
	ipc_port_t port = IP_NULL;
	ipc_entry_bits_t bits;

	mach_port_urefs_t urefs;
	ipc_port_t request = IP_NULL;
	ipc_port_t nsrequest = IP_NULL;
	mach_port_mscount_t mscount = 0;

	bits = entry-&gt;ie_bits;
	
	assert(is_active(space));

	<span class="enscript-keyword">if</span> (((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0) ||
	    (srdelta &amp;&amp; ((bits &amp; MACH_PORT_TYPE_SEND) == 0))) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	<span class="enscript-keyword">if</span> (srdelta &gt; 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;

	port = (ipc_port_t) entry-&gt;ie_object;
	assert(port != IP_NULL);
	
	ip_lock(port);
	assert(ip_active(port));
	assert(port-&gt;ip_receiver_name == name);
	assert(port-&gt;ip_receiver == space);

	<span class="enscript-comment">/* Mach Port Guard Checking */</span>
	<span class="enscript-keyword">if</span>(port-&gt;ip_guarded &amp;&amp; (guard != port-&gt;ip_context)) {
		uint64_t portguard = port-&gt;ip_context;
		ip_unlock(port);
		is_write_unlock(space);
		mach_port_guard_exception(name, 0, portguard, kGUARD_EXC_DESTROY);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/*
	 * First reduce the send rights as requested and
	 * adjust the entry-&gt;ie_bits accordingly. The
	 * ipc_entry_modified() call is made once the receive
	 * right is destroyed too.
	 */</span>

	<span class="enscript-keyword">if</span> (srdelta) {
		
		assert(port-&gt;ip_srights &gt; 0);

		urefs = IE_BITS_UREFS(bits);
		<span class="enscript-comment">/*
		 * Since we made sure that srdelta is negative,
		 * the check for urefs overflow is not required.
		 */</span>
		<span class="enscript-keyword">if</span> (MACH_PORT_UREFS_UNDERFLOW(urefs, srdelta)) {
			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_value</span>;
		}
		<span class="enscript-keyword">if</span> ((urefs + srdelta) == 0) {
			<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0) {
				nsrequest = port-&gt;ip_nsrequest;
				<span class="enscript-keyword">if</span> (nsrequest != IP_NULL) {
					port-&gt;ip_nsrequest = IP_NULL;
					mscount = port-&gt;ip_mscount;
				}
			}
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_RECEIVE);
			entry-&gt;ie_bits = bits &amp;~ (IE_BITS_UREFS_MASK|
					       MACH_PORT_TYPE_SEND);
		} <span class="enscript-keyword">else</span> {
			entry-&gt;ie_bits = bits + srdelta;
		}
	}

	<span class="enscript-comment">/*
	 * Now destroy the receive right. Update space and
	 * entry accordingly.
	 */</span>

	bits = entry-&gt;ie_bits;
	<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND) {
		assert(IE_BITS_UREFS(bits) &gt; 0);
		assert(IE_BITS_UREFS(bits) &lt; MACH_PORT_UREFS_MAX);

		<span class="enscript-keyword">if</span> (port-&gt;ip_pdrequest != NULL) {
			<span class="enscript-comment">/*
			 * Since another task has requested a
			 * destroy notification for this port, it
			 * isn't actually being destroyed - the receive
			 * right is just being moved to another task.
			 * Since we still have one or more send rights,
			 * we need to record the loss of the receive
			 * right and enter the remaining send right
			 * into the hash table.
			 */</span>
			ipc_entry_modified(space, name, entry);
			entry-&gt;ie_bits &amp;= ~MACH_PORT_TYPE_RECEIVE;
			ipc_hash_insert(space, (ipc_object_t) port,
			    name, entry);
			ip_reference(port);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 *	The remaining send right turns into a
			 *	dead name.  Notice we don't decrement
			 *	ip_srights, generate a no-senders notif,
			 *	or use ipc_right_dncancel, because the
			 *	port is destroyed &quot;first&quot;.
			 */</span>
			bits &amp;= ~IE_BITS_TYPE_MASK;
			bits |= MACH_PORT_TYPE_DEAD_NAME;
			<span class="enscript-keyword">if</span> (entry-&gt;ie_request) {
				entry-&gt;ie_request = IE_REQ_NONE;
				bits++;
			}
			entry-&gt;ie_bits = bits;
			entry-&gt;ie_object = IO_NULL;
			ipc_entry_modified(space, name, entry);
		}
	} <span class="enscript-keyword">else</span> {
		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_RECEIVE);
		assert(IE_BITS_UREFS(bits) == 0);
		request = ipc_right_request_cancel_macro(space, port,
						     name, entry);
		entry-&gt;ie_object = IO_NULL;
		ipc_entry_dealloc(space, name, entry);
	}

	<span class="enscript-comment">/* Unlock space */</span>
	is_write_unlock(space);

	<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
		ipc_notify_no_senders(nsrequest, mscount);

	ipc_port_clear_receiver(port);
	ipc_port_destroy(port);	<span class="enscript-comment">/* consumes ref, unlocks */</span>

	<span class="enscript-keyword">if</span> (request != IP_NULL)
		ipc_notify_port_deleted(request, name);
	
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
	
    <span class="enscript-reference">invalid_value</span>:
	is_write_unlock(space);
	<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

}


<span class="enscript-comment">/*
 *	Routine:	ipc_right_info
 *	Purpose:
 *		Retrieves information about the right.
 *	Conditions:
 *		The space is active and write-locked.
 *	        The space is unlocked upon return.
 *	Returns:
 *		KERN_SUCCESS		Retrieved info
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_info</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_port_type_t	*typep,
	mach_port_urefs_t	*urefsp)
{
	ipc_port_t port;
	ipc_entry_bits_t bits;
	mach_port_type_t type = 0;
	ipc_port_request_index_t request;

	bits = entry-&gt;ie_bits;
	request = entry-&gt;ie_request;
	port = (ipc_port_t) entry-&gt;ie_object;

	<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_RECEIVE) {
		assert(IP_VALID(port));

		<span class="enscript-keyword">if</span> (request != IE_REQ_NONE) {
			ip_lock(port);
			assert(ip_active(port));
			type |= ipc_port_request_type(port, name, request);
			ip_unlock(port);
		}
		is_write_unlock(space);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) {
		<span class="enscript-comment">/*
		 * validate port is still alive - if so, get request
		 * types while we still have it locked.  Otherwise,
		 * recapture the (now dead) bits.
		 */</span>
		<span class="enscript-keyword">if</span> (!ipc_right_check(space, port, name, entry)) {
			<span class="enscript-keyword">if</span> (request != IE_REQ_NONE)
				type |= ipc_port_request_type(port, name, request);
			ip_unlock(port);
			is_write_unlock(space);
		} <span class="enscript-keyword">else</span> {
			bits = entry-&gt;ie_bits;
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
			is_write_unlock(space);
			ip_release(port);
		}
	} <span class="enscript-keyword">else</span> {
		is_write_unlock(space);
	}

	type |= IE_BITS_TYPE(bits);

	*typep = type;
	*urefsp = IE_BITS_UREFS(bits);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_copyin_check
 *	Purpose:
 *		Check if a subsequent ipc_right_copyin would succeed.
 *	Conditions:
 *		The space is locked (read or write) and active.
 */</span>

boolean_t
<span class="enscript-function-name">ipc_right_copyin_check</span>(
	__assert_only ipc_space_t	space,
	__unused mach_port_name_t	name,
	ipc_entry_t			entry,
	mach_msg_type_name_t		msgt_name)
{
	ipc_entry_bits_t bits;
	ipc_port_t port;

	bits= entry-&gt;ie_bits;
	assert(is_active(space));

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND</span>:
		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">return</span> FALSE;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND_ONCE</span>:
		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">return</span> FALSE;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_RECEIVE</span>:
		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">return</span> FALSE;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_COPY_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND_ONCE</span>: {

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == 0)
			<span class="enscript-keyword">return</span> FALSE;

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-comment">/*
		 * active status peek to avoid checks that will be skipped
		 * on copyin for dead ports.  Lock not held, so will not be
		 * atomic (but once dead, there's no going back).
		 */</span>
		<span class="enscript-keyword">if</span> (!ip_active(port)) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (msgt_name == MACH_MSG_TYPE_MOVE_SEND_ONCE) {
			<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_ONCE) == 0)
				<span class="enscript-keyword">return</span> FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == 0)
				<span class="enscript-keyword">return</span> FALSE;
		}

		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_right_copyin_check: strange rights&quot;</span>);
	}

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_copyin
 *	Purpose:
 *		Copyin a capability from a space.
 *		If successful, the caller gets a ref
 *		for the resulting object, unless it is IO_DEAD,
 *		and possibly a send-once right which should
 *		be used in a port-deleted notification.
 *
 *		If deadok is not TRUE, the copyin operation
 *		will fail instead of producing IO_DEAD.
 *
 *		The entry is never deallocated (except
 *		when KERN_INVALID_NAME), so the caller
 *		should deallocate the entry if its type
 *		is MACH_PORT_TYPE_NONE.
 *	Conditions:
 *		The space is write-locked and active.
 *	Returns:
 *		KERN_SUCCESS		Acquired an object, possibly IO_DEAD.
 *		KERN_INVALID_RIGHT	Name doesn't denote correct right.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_copyin</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_msg_type_name_t	msgt_name,
	boolean_t		deadok,
	ipc_object_t		*objectp,
	ipc_port_t		*sorightp,
	ipc_port_t		*releasep,
	<span class="enscript-type">int</span>			*assertcntp)
{
	ipc_entry_bits_t bits;
	ipc_port_t port;

	*releasep = IP_NULL;
	*assertcntp = 0;

	bits = entry-&gt;ie_bits;

	assert(is_active(space));

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND</span>: {

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == name);
		assert(port-&gt;ip_receiver == space);

		port-&gt;ip_mscount++;
		port-&gt;ip_srights++;
		ip_reference(port);
		ip_unlock(port);

		*objectp = (ipc_object_t) port;
		*sorightp = IP_NULL;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND_ONCE</span>: {

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == name);
		assert(port-&gt;ip_receiver == space);

		port-&gt;ip_sorights++;
		ip_reference(port);
		ip_unlock(port);

		*objectp = (ipc_object_t) port;
		*sorightp = IP_NULL;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_RECEIVE</span>: {
		ipc_port_t request = IP_NULL;

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == name);
		assert(port-&gt;ip_receiver == space);

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND) {
			assert(IE_BITS_TYPE(bits) ==
					MACH_PORT_TYPE_SEND_RECEIVE);
			assert(IE_BITS_UREFS(bits) &gt; 0);
			assert(port-&gt;ip_srights &gt; 0);

			ipc_hash_insert(space, (ipc_object_t) port,
					name, entry);
			ip_reference(port);
		} <span class="enscript-keyword">else</span> {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_RECEIVE);
			assert(IE_BITS_UREFS(bits) == 0);

			request = ipc_right_request_cancel_macro(space, port,
							     name, entry);
			entry-&gt;ie_object = IO_NULL;
		}
		entry-&gt;ie_bits = bits &amp;~ MACH_PORT_TYPE_RECEIVE;
		ipc_entry_modified(space, name, entry);

		ipc_port_clear_receiver(port);
		port-&gt;ip_receiver_name = MACH_PORT_NULL;
		port-&gt;ip_destination = IP_NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		<span class="enscript-comment">/*
		 * Account for boosts the current task is going to lose when
		 * copying this right in.  Tempowner ports have either not
		 * been accounting to any task (and therefore are already in
		 * &quot;limbo&quot; state w.r.t. assertions) or to some other specific
		 * task. As we have no way to drop the latter task's assertions
		 * here, We'll deduct those when we enqueue it on its
		 * destination port (see ipc_port_check_circularity()).
		 */</span>
		<span class="enscript-keyword">if</span> (port-&gt;ip_tempowner == 0) {
			assert(IIT_NULL == port-&gt;ip_imp_task);

			<span class="enscript-comment">/* ports in limbo have to be tempowner */</span>
			port-&gt;ip_tempowner = 1;
			*assertcntp = port-&gt;ip_impcount;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		ip_unlock(port);

		*objectp = (ipc_object_t) port;
		*sorightp = request;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_COPY_SEND</span>: {

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">copy_dead</span>;

		<span class="enscript-comment">/* allow for dead send-once rights */</span>

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		assert(IE_BITS_UREFS(bits) &gt; 0);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
			bits = entry-&gt;ie_bits;
			*releasep = port;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">copy_dead</span>;
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == 0) {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);
			assert(port-&gt;ip_sorights &gt; 0);

			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
		}

		assert(port-&gt;ip_srights &gt; 0);

		port-&gt;ip_srights++;
		ip_reference(port);
		ip_unlock(port);

		*objectp = (ipc_object_t) port;
		*sorightp = IP_NULL;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND</span>: {
		ipc_port_t request = IP_NULL;

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">move_dead</span>;

		<span class="enscript-comment">/* allow for dead send-once rights */</span>

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		assert(IE_BITS_UREFS(bits) &gt; 0);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
			bits = entry-&gt;ie_bits;
			*releasep = port;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">move_dead</span>;
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == 0) {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);
			assert(port-&gt;ip_sorights &gt; 0);

			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
		}

		assert(port-&gt;ip_srights &gt; 0);

		<span class="enscript-keyword">if</span> (IE_BITS_UREFS(bits) == 1) {
			<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_RECEIVE) {
				assert(port-&gt;ip_receiver_name == name);
				assert(port-&gt;ip_receiver == space);
				assert(IE_BITS_TYPE(bits) ==
						MACH_PORT_TYPE_SEND_RECEIVE);

				ip_reference(port);
			} <span class="enscript-keyword">else</span> {
				assert(IE_BITS_TYPE(bits) ==
						MACH_PORT_TYPE_SEND);

				request = ipc_right_request_cancel_macro(space, port,
								     name, entry);
				ipc_hash_delete(space, (ipc_object_t) port,
						name, entry);
				entry-&gt;ie_object = IO_NULL;
			}
			entry-&gt;ie_bits = bits &amp;~
				(IE_BITS_UREFS_MASK|MACH_PORT_TYPE_SEND);
		} <span class="enscript-keyword">else</span> {
			port-&gt;ip_srights++;
			ip_reference(port);
			entry-&gt;ie_bits = bits-1; <span class="enscript-comment">/* decrement urefs */</span>
		}
		ipc_entry_modified(space, name, entry);
		ip_unlock(port);

		*objectp = (ipc_object_t) port;
		*sorightp = request;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND_ONCE</span>: {
		ipc_port_t request;

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">move_dead</span>;

		<span class="enscript-comment">/* allow for dead send rights */</span>

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

		assert(IE_BITS_UREFS(bits) &gt; 0);

		port = (ipc_port_t) entry-&gt;ie_object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
			bits = entry-&gt;ie_bits;
			*releasep = port;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">move_dead</span>;
		}
		<span class="enscript-comment">/* port is locked and active */</span>

		<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_ONCE) == 0) {
			assert(bits &amp; MACH_PORT_TYPE_SEND);
			assert(port-&gt;ip_srights &gt; 0);

			ip_unlock(port);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
		}

		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);
		assert(IE_BITS_UREFS(bits) == 1);
		assert(port-&gt;ip_sorights &gt; 0);

		request = ipc_right_request_cancel_macro(space, port, name, entry);
		ip_unlock(port);

		entry-&gt;ie_object = IO_NULL;
		entry-&gt;ie_bits = bits &amp;~
			(IE_BITS_UREFS_MASK | MACH_PORT_TYPE_SEND_ONCE);
		ipc_entry_modified(space, name, entry);
		*objectp = (ipc_object_t) port;
		*sorightp = request;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
	    <span class="enscript-reference">invalid_right</span>:
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;

    <span class="enscript-reference">copy_dead</span>:
	assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
	assert(IE_BITS_UREFS(bits) &gt; 0);
	assert(entry-&gt;ie_request == IE_REQ_NONE);
	assert(entry-&gt;ie_object == 0);

	<span class="enscript-keyword">if</span> (!deadok)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

	*objectp = IO_DEAD;
	*sorightp = IP_NULL;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;

    <span class="enscript-reference">move_dead</span>:
	assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
	assert(IE_BITS_UREFS(bits) &gt; 0);
	assert(entry-&gt;ie_request == IE_REQ_NONE);
	assert(entry-&gt;ie_object == 0);

	<span class="enscript-keyword">if</span> (!deadok)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

	<span class="enscript-keyword">if</span> (IE_BITS_UREFS(bits) == 1) {
		bits &amp;= ~MACH_PORT_TYPE_DEAD_NAME;
	}
	entry-&gt;ie_bits = bits-1; <span class="enscript-comment">/* decrement urefs */</span>
	ipc_entry_modified(space, name, entry);
	*objectp = IO_DEAD;
	*sorightp = IP_NULL;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;

}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_copyin_undo
 *	Purpose:
 *		Undoes the effects of an ipc_right_copyin
 *		of a send/send-once right that is dead.
 *		(Object is either IO_DEAD or a dead port.)
 *	Conditions:
 *		The space is write-locked and active.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_right_copyin_undo</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_msg_type_name_t	msgt_name,
	ipc_object_t		object,
	ipc_port_t		soright)
{
	ipc_entry_bits_t bits;

	bits = entry-&gt;ie_bits;

	assert(is_active(space));

	assert((msgt_name == MACH_MSG_TYPE_MOVE_SEND) ||
	       (msgt_name == MACH_MSG_TYPE_COPY_SEND) ||
	       (msgt_name == MACH_MSG_TYPE_MOVE_SEND_ONCE));

	<span class="enscript-keyword">if</span> (soright != IP_NULL) {
		assert((msgt_name == MACH_MSG_TYPE_MOVE_SEND) ||
		       (msgt_name == MACH_MSG_TYPE_MOVE_SEND_ONCE));
		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_NONE);
		assert(object != IO_DEAD);

		entry-&gt;ie_bits = ((bits &amp;~ IE_BITS_RIGHT_MASK) |
				  MACH_PORT_TYPE_DEAD_NAME | 2);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IE_BITS_TYPE(bits) == MACH_PORT_TYPE_NONE) {
		assert((msgt_name == MACH_MSG_TYPE_MOVE_SEND) ||
		       (msgt_name == MACH_MSG_TYPE_MOVE_SEND_ONCE));

		entry-&gt;ie_bits = ((bits &amp;~ IE_BITS_RIGHT_MASK) |
				  MACH_PORT_TYPE_DEAD_NAME | 1);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME) {
		assert(object == IO_DEAD);
		assert(IE_BITS_UREFS(bits) &gt; 0);

		<span class="enscript-keyword">if</span> (msgt_name != MACH_MSG_TYPE_COPY_SEND) {
			assert(IE_BITS_UREFS(bits) &lt; MACH_PORT_UREFS_MAX);
			entry-&gt;ie_bits = bits+1; <span class="enscript-comment">/* increment urefs */</span>
		}
	} <span class="enscript-keyword">else</span> {
		assert((msgt_name == MACH_MSG_TYPE_MOVE_SEND) ||
		       (msgt_name == MACH_MSG_TYPE_COPY_SEND));
		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND);
		assert(object != IO_DEAD);
		assert(entry-&gt;ie_object == object);
		assert(IE_BITS_UREFS(bits) &gt; 0);

		<span class="enscript-keyword">if</span> (msgt_name != MACH_MSG_TYPE_COPY_SEND) {
			assert(IE_BITS_UREFS(bits) &lt; MACH_PORT_UREFS_MAX-1);
			entry-&gt;ie_bits = bits+1; <span class="enscript-comment">/* increment urefs */</span>
		}

		<span class="enscript-comment">/*
		 *	May as well convert the entry to a dead name.
		 *	(Or if it is a compat entry, destroy it.)
		 */</span>

		(<span class="enscript-type">void</span>) ipc_right_check(space, (ipc_port_t) object,
				       name, entry);
		<span class="enscript-comment">/* object is dead so it is not locked */</span>
	}
	ipc_entry_modified(space, name, entry);
	<span class="enscript-comment">/* release the reference acquired by copyin */</span>

	<span class="enscript-keyword">if</span> (object != IO_DEAD)
		io_release(object);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_copyin_two_move_sends
 *	Purpose:
 *		Like ipc_right_copyin with MACH_MSG_TYPE_MOVE_SEND
 *		and deadok == FALSE, except that this moves two
 *		send rights at once.
 *	Conditions:
 *		The space is write-locked and active.
 *		The object is returned with two refs/send rights.
 *	Returns:
 *		KERN_SUCCESS		Acquired an object.
 *		KERN_INVALID_RIGHT	Name doesn't denote correct right.
 */</span>
<span class="enscript-type">static</span>
kern_return_t
<span class="enscript-function-name">ipc_right_copyin_two_move_sends</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	ipc_object_t		*objectp,
	ipc_port_t		*sorightp,
	ipc_port_t		*releasep)
{
	ipc_entry_bits_t bits;
	mach_port_urefs_t urefs;
	ipc_port_t port;
	ipc_port_t request = IP_NULL;

	*releasep = IP_NULL;

	assert(is_active(space));

	bits = entry-&gt;ie_bits;

	<span class="enscript-keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

	urefs = IE_BITS_UREFS(bits);
	<span class="enscript-keyword">if</span> (urefs &lt; 2)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;

	port = (ipc_port_t) entry-&gt;ie_object;
	assert(port != IP_NULL);

	<span class="enscript-keyword">if</span> (ipc_right_check(space, port, name, entry)) {
		*releasep = port;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid_right</span>;
	}
	<span class="enscript-comment">/* port is locked and active */</span>

	assert(port-&gt;ip_srights &gt; 0);

	<span class="enscript-keyword">if</span> (urefs == 2) {
		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_RECEIVE) {
			assert(port-&gt;ip_receiver_name == name);
			assert(port-&gt;ip_receiver == space);
			assert(IE_BITS_TYPE(bits) ==
					MACH_PORT_TYPE_SEND_RECEIVE);

			port-&gt;ip_srights++;
			ip_reference(port);
			ip_reference(port);
		} <span class="enscript-keyword">else</span> {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND);

			request = ipc_right_request_cancel_macro(space, port,
							     name, entry);

			port-&gt;ip_srights++;
			ip_reference(port);
			ipc_hash_delete(space, (ipc_object_t) port,
					name, entry);
			entry-&gt;ie_object = IO_NULL;
		}
		entry-&gt;ie_bits = bits &amp;~ (IE_BITS_UREFS_MASK|MACH_PORT_TYPE_SEND);
	} <span class="enscript-keyword">else</span> {
		port-&gt;ip_srights += 2;
		ip_reference(port);
		ip_reference(port);
		entry-&gt;ie_bits = bits-2; <span class="enscript-comment">/* decrement urefs */</span>
	}
	ipc_entry_modified(space, name, entry);

	ip_unlock(port);

	*objectp = (ipc_object_t) port;
	*sorightp = request;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;

    <span class="enscript-reference">invalid_right</span>:
	<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_right_copyin_two
 *	Purpose:
 *		Like ipc_right_copyin with two dispositions,
 *		each of which results in a send or send-once right,
 *		and deadok = FALSE.
 *	Conditions:
 *		The space is write-locked and active.
 *		The object is returned with two refs/rights.
 *	Returns:
 *		KERN_SUCCESS		Acquired an object.
 *		KERN_INVALID_RIGHT	Name doesn't denote correct right(s).
 *		KERN_INVALID_CAPABILITY	Name doesn't denote correct right for msgt_two.
 */</span>
kern_return_t
<span class="enscript-function-name">ipc_right_copyin_two</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_msg_type_name_t	msgt_one,
	mach_msg_type_name_t	msgt_two,
	ipc_object_t		*objectp,
	ipc_port_t		*sorightp,
	ipc_port_t		*releasep)
{
	kern_return_t kr;
	<span class="enscript-type">int</span> assertcnt = 0;

	assert(MACH_MSG_TYPE_PORT_ANY_SEND(msgt_one));
	assert(MACH_MSG_TYPE_PORT_ANY_SEND(msgt_two));
	

	<span class="enscript-comment">/*
	 * Pre-validate the second disposition is possible all by itself.
	 */</span>
	<span class="enscript-keyword">if</span> (!ipc_right_copyin_check(space, name, entry, msgt_two)) {
		<span class="enscript-keyword">return</span> KERN_INVALID_CAPABILITY;
	}

	<span class="enscript-comment">/*
	 *	This is a little tedious to make atomic, because
	 *	there are 25 combinations of valid dispositions.
	 *	However, most are easy.
	 */</span>

	<span class="enscript-comment">/*
	 *	If either is move-sonce, then there must be an error.
	 */</span>
	<span class="enscript-keyword">if</span> (msgt_one == MACH_MSG_TYPE_MOVE_SEND_ONCE ||
	    msgt_two == MACH_MSG_TYPE_MOVE_SEND_ONCE) {
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	<span class="enscript-keyword">if</span> ((msgt_one == MACH_MSG_TYPE_MAKE_SEND) ||
	    (msgt_one == MACH_MSG_TYPE_MAKE_SEND_ONCE) ||
	    (msgt_two == MACH_MSG_TYPE_MAKE_SEND) ||
	    (msgt_two == MACH_MSG_TYPE_MAKE_SEND_ONCE)) {
		<span class="enscript-comment">/*
		 *	One of the dispositions needs a receive right.
		 *
		 *	If the copyin below succeeds, we know the receive
		 *	right is there (because the pre-validation of
		 *	the second disposition already succeeded in our
		 *	caller).
		 *
		 *	Hence the port is not in danger of dying.
		 */</span>
		ipc_object_t object_two;

		kr = ipc_right_copyin(space, name, entry,
				      msgt_one, FALSE,
				      objectp, sorightp, releasep,
				      &amp;assertcnt);
		assert(assertcnt == 0);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-keyword">return</span> kr;
		}

		assert(IO_VALID(*objectp));
		assert(*sorightp == IP_NULL);
		assert(*releasep == IP_NULL);

		<span class="enscript-comment">/*
		 *	Now copyin the second (previously validated)
		 *	disposition.  The result can't be a dead port,
		 *	as no valid disposition can make us lose our
		 *	receive right.
		 */</span>
		kr = ipc_right_copyin(space, name, entry,
				      msgt_two, FALSE,
				      &amp;object_two, sorightp, releasep,
				      &amp;assertcnt);
		assert(assertcnt == 0);
		assert(kr == KERN_SUCCESS);
		assert(*sorightp == IP_NULL);
		assert(*releasep == IP_NULL);
		assert(object_two == *objectp);
		assert(entry-&gt;ie_bits &amp; MACH_PORT_TYPE_RECEIVE);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((msgt_one == MACH_MSG_TYPE_MOVE_SEND) &amp;&amp;
		   (msgt_two == MACH_MSG_TYPE_MOVE_SEND)) {
		<span class="enscript-comment">/*
		 *	This is an easy case.  Just use our
		 *	handy-dandy special-purpose copyin call
		 *	to get two send rights for the price of one.
		 */</span>
		kr = ipc_right_copyin_two_move_sends(space, name, entry,
						     objectp, sorightp, 
						     releasep);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-keyword">return</span> kr;
		}

	} <span class="enscript-keyword">else</span> {
		mach_msg_type_name_t msgt_name;

		<span class="enscript-comment">/*
		 *	Must be either a single move-send and a
		 *	copy-send, or two copy-send dispositions.
		 *	Use the disposition with the greatest side
		 *	effects for the actual copyin - then just
		 *	duplicate the send right you get back.
		 */</span>
		<span class="enscript-keyword">if</span> (msgt_one == MACH_MSG_TYPE_MOVE_SEND ||
		    msgt_two == MACH_MSG_TYPE_MOVE_SEND) {
			msgt_name = MACH_MSG_TYPE_MOVE_SEND;
		} <span class="enscript-keyword">else</span> {
			msgt_name = MACH_MSG_TYPE_COPY_SEND;
		}

		kr = ipc_right_copyin(space, name, entry,
				      msgt_name, FALSE,
				      objectp, sorightp, releasep,
				      &amp;assertcnt);
		assert(assertcnt == 0);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-keyword">return</span> kr;
		}

		<span class="enscript-comment">/*
		 *	Copy the right we got back.  If it is dead now,
		 *	that's OK.  Neither right will be usable to send
		 *	a message anyway.
		 */</span>
		(<span class="enscript-type">void</span>)ipc_port_copy_send((ipc_port_t)*objectp);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_right_copyout
 *	Purpose:
 *		Copyout a capability to a space.
 *		If successful, consumes a ref for the object.
 *
 *		Always succeeds when given a newly-allocated entry,
 *		because user-reference overflow isn't a possibility.
 *
 *		If copying out the object would cause the user-reference
 *		count in the entry to overflow, and overflow is TRUE,
 *		then instead the user-reference count is left pegged
 *		to its maximum value and the copyout succeeds anyway.
 *	Conditions:
 *		The space is write-locked and active.
 *		The object is locked and active.
 *		The object is unlocked; the space isn't.
 *	Returns:
 *		KERN_SUCCESS		Copied out capability.
 *		KERN_UREFS_OVERFLOW	User-refs would overflow;
 *			guaranteed not to happen with a fresh entry
 *			or if overflow=TRUE was specified.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_copyout</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_entry_t		entry,
	mach_msg_type_name_t	msgt_name,
	boolean_t		overflow,
	ipc_object_t		object)
{
	ipc_entry_bits_t bits;
	ipc_port_t port;

	bits = entry-&gt;ie_bits;

	assert(IO_VALID(object));
	assert(io_otype(object) == IOT_PORT);
	assert(io_active(object));
	assert(entry-&gt;ie_object == object);

	port = (ipc_port_t) object;

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND_ONCE</span>:
		
		assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_NONE);
		assert(port-&gt;ip_sorights &gt; 0);

		<span class="enscript-comment">/* transfer send-once right and ref to entry */</span>
		ip_unlock(port);

		entry-&gt;ie_bits = bits | (MACH_PORT_TYPE_SEND_ONCE | 1);
		ipc_entry_modified(space, name, entry);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND</span>:
		assert(port-&gt;ip_srights &gt; 0);

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND) {
			mach_port_urefs_t urefs = IE_BITS_UREFS(bits);

			assert(port-&gt;ip_srights &gt; 1);
			assert(urefs &gt; 0);
			assert(urefs &lt; MACH_PORT_UREFS_MAX);

			<span class="enscript-keyword">if</span> (urefs+1 == MACH_PORT_UREFS_MAX) {
				<span class="enscript-keyword">if</span> (overflow) {
					<span class="enscript-comment">/* leave urefs pegged to maximum */</span>

					port-&gt;ip_srights--;
					ip_unlock(port);
					ip_release(port);
					<span class="enscript-keyword">return</span> KERN_SUCCESS;
				}

				ip_unlock(port);
				<span class="enscript-keyword">return</span> KERN_UREFS_OVERFLOW;
			}
			port-&gt;ip_srights--;
			ip_unlock(port);
			ip_release(port);
			
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_RECEIVE) {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_RECEIVE);
			assert(IE_BITS_UREFS(bits) == 0);

			<span class="enscript-comment">/* transfer send right to entry */</span>
			ip_unlock(port);
			ip_release(port);
			
		} <span class="enscript-keyword">else</span> {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_NONE);
			assert(IE_BITS_UREFS(bits) == 0);

			<span class="enscript-comment">/* transfer send right and ref to entry */</span>
			ip_unlock(port);

			<span class="enscript-comment">/* entry is locked holding ref, so can use port */</span>

			ipc_hash_insert(space, (ipc_object_t) port,
					name, entry);
		}

		entry-&gt;ie_bits = (bits | MACH_PORT_TYPE_SEND) + 1;
		ipc_entry_modified(space, name, entry);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_RECEIVE</span>: {
		ipc_port_t dest;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		natural_t assertcnt = port-&gt;ip_impcount;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		assert(port-&gt;ip_mscount == 0);
		assert(port-&gt;ip_receiver_name == MACH_PORT_NULL);
		dest = port-&gt;ip_destination;

		port-&gt;ip_receiver_name = name;
		port-&gt;ip_receiver = space;

		assert((bits &amp; MACH_PORT_TYPE_RECEIVE) == 0);

		<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND) {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND);
			assert(IE_BITS_UREFS(bits) &gt; 0);
			assert(port-&gt;ip_srights &gt; 0);

			ip_unlock(port);
			ip_release(port);

			<span class="enscript-comment">/* entry is locked holding ref, so can use port */</span>

			ipc_hash_delete(space, (ipc_object_t) port,
					name, entry);
		} <span class="enscript-keyword">else</span> {
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_NONE);
			assert(IE_BITS_UREFS(bits) == 0);

			<span class="enscript-comment">/* transfer ref to entry */</span>
			ip_unlock(port);
		}
		entry-&gt;ie_bits = bits | MACH_PORT_TYPE_RECEIVE;
		ipc_entry_modified(space, name, entry);

		<span class="enscript-keyword">if</span> (dest != IP_NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
			<span class="enscript-comment">/*
			 * Deduct the assertion counts we contributed to
			 * the old destination port.  They've already
			 * been reflected into the task as a result of
			 * getting enqueued.
			 */</span>
			ip_lock(dest);
			ipc_port_impcount_delta(dest, 0 - assertcnt, IP_NULL);
			ip_unlock(dest);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
			ip_release(dest);
		}
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_right_copyout: strange rights&quot;</span>);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_right_rename
 *	Purpose:
 *		Transfer an entry from one name to another.
 *		The old entry is deallocated.
 *	Conditions:
 *		The space is write-locked and active.
 *		The new entry is unused.  Upon return,
 *		the space is unlocked.
 *	Returns:
 *		KERN_SUCCESS		Moved entry to new name.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_right_rename</span>(
	ipc_space_t		space,
	mach_port_name_t	oname,
	ipc_entry_t		oentry,
	mach_port_name_t	nname,
	ipc_entry_t		nentry)
{
	ipc_port_request_index_t request = oentry-&gt;ie_request;
	ipc_entry_bits_t bits = oentry-&gt;ie_bits;
	ipc_object_t object = oentry-&gt;ie_object;
	ipc_port_t release_port = IP_NULL;

	assert(is_active(space));
	assert(oname != nname);

	<span class="enscript-comment">/*
	 *	If IE_BITS_COMPAT, we can't allow the entry to be renamed
	 *	if the port is dead.  (This would foil ipc_port_destroy.)
	 *	Instead we should fail because oentry shouldn't exist.
	 *	Note IE_BITS_COMPAT implies ie_request != 0.
	 */</span>

	<span class="enscript-keyword">if</span> (request != IE_REQ_NONE) {
		ipc_port_t port;

		assert(bits &amp; MACH_PORT_TYPE_PORT_RIGHTS);
		port = (ipc_port_t) object;
		assert(port != IP_NULL);

		<span class="enscript-keyword">if</span> (ipc_right_check(space, port, oname, oentry)) {
			request = IE_REQ_NONE;
			object = IO_NULL;
			bits = oentry-&gt;ie_bits;
			release_port = port;
			assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_DEAD_NAME);
			assert(oentry-&gt;ie_request == IE_REQ_NONE);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* port is locked and active */</span>

			ipc_port_request_rename(port, request, oname, nname);
			ip_unlock(port);
			oentry-&gt;ie_request = IE_REQ_NONE;
		}
	}

	<span class="enscript-comment">/* initialize nentry before letting ipc_hash_insert see it */</span>

	assert((nentry-&gt;ie_bits &amp; IE_BITS_RIGHT_MASK) == 0);
	nentry-&gt;ie_bits |= bits &amp; IE_BITS_RIGHT_MASK;
	nentry-&gt;ie_request = request;
	nentry-&gt;ie_object = object;

	<span class="enscript-keyword">switch</span> (IE_BITS_TYPE(bits)) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND</span>: {
		ipc_port_t port;

		port = (ipc_port_t) object;
		assert(port != IP_NULL);

		<span class="enscript-comment">/* remember, there are no other share entries possible */</span>
		<span class="enscript-comment">/* or we can't do the rename.  Therefore we do not need */</span>
		<span class="enscript-comment">/* to check the other subspaces */</span>
	  	ipc_hash_delete(space, (ipc_object_t) port, oname, oentry);
		ipc_hash_insert(space, (ipc_object_t) port, nname, nentry);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_RECEIVE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_RECEIVE</span>: {
		ipc_port_t port;

		port = (ipc_port_t) object;
		assert(port != IP_NULL);

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == oname);
		assert(port-&gt;ip_receiver == space);

		port-&gt;ip_receiver_name = nname;
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_PORT_SET</span>: {
		ipc_pset_t pset;

		pset = (ipc_pset_t) object;
		assert(pset != IPS_NULL);

		ips_lock(pset);
		assert(ips_active(pset));
		assert(pset-&gt;ips_local_name == oname);

		pset-&gt;ips_local_name = nname;
		ips_unlock(pset);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_SEND_ONCE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TYPE_DEAD_NAME</span>:
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_right_rename: strange rights&quot;</span>);
	}

	assert(oentry-&gt;ie_request == IE_REQ_NONE);
	oentry-&gt;ie_object = IO_NULL;
	ipc_entry_dealloc(space, oname, oentry);
	ipc_entry_modified(space, nname, nentry);
	is_write_unlock(space);

	<span class="enscript-keyword">if</span> (release_port != IP_NULL)
		ip_release(release_port);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}
</pre>
<hr />
</body></html>