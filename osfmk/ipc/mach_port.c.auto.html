<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mach_port.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mach_port.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 * Copyright (c) 2005-2006 SPARTA, Inc.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	ipc/mach_port.c
 *	Author:	Rich Draves
 *	Date: 	1989
 *
 *	Exported kernel calls.  See mach/mach_port.defs.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_rt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_port_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_pset.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_right.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_kmsg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_importance.h&gt;</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Forward declarations
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mach_port_names_helper</span>(
	ipc_port_timestamp_t	timestamp,
	ipc_entry_t		entry,
	mach_port_name_t	name,
	mach_port_name_t	*names,
	mach_port_type_t	*types,
	ipc_entry_num_t		*actualp);

<span class="enscript-type">void</span> <span class="enscript-function-name">mach_port_gst_helper</span>(
	ipc_pset_t		pset,
	ipc_entry_num_t		maxnames,
	mach_port_name_t	*names,
	ipc_entry_num_t		*actualp);


kern_return_t
<span class="enscript-function-name">mach_port_guard_exception</span>(
	mach_port_name_t	name,
	uint64_t		inguard,
	uint64_t		portguard,
	<span class="enscript-type">unsigned</span>		reason);

<span class="enscript-comment">/* Needs port locked */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mach_port_get_status_helper</span>(
	ipc_port_t		port,
	mach_port_status_t	*status);

<span class="enscript-comment">/* Zeroed template of qos flags */</span>

<span class="enscript-type">static</span> mach_port_qos_t	qos_template;

<span class="enscript-comment">/*
 *	Routine:	mach_port_names_helper
 *	Purpose:
 *		A helper function for mach_port_names.
 *
 *	Conditions:
 *		Space containing entry is [at least] read-locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">mach_port_names_helper</span>(
	ipc_port_timestamp_t	timestamp,
	ipc_entry_t		entry,
	mach_port_name_t	name,
	mach_port_name_t	*names,
	mach_port_type_t	*types,
	ipc_entry_num_t		*actualp)
{
	ipc_entry_bits_t bits;
	ipc_port_request_index_t request;
	mach_port_type_t type = 0;
	ipc_entry_num_t actual;
	ipc_port_t port;

	bits = entry-&gt;ie_bits;
	request = entry-&gt;ie_request;
	__IGNORE_WCASTALIGN(port = (ipc_port_t) entry-&gt;ie_object);

	<span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_RECEIVE) {
		assert(IP_VALID(port));

		<span class="enscript-keyword">if</span> (request != IE_REQ_NONE) {
			ip_lock(port);
			assert(ip_active(port));
			type |= ipc_port_request_type(port, name, request);
			ip_unlock(port);
		}

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) {
		mach_port_type_t reqtype;

		assert(IP_VALID(port));
		ip_lock(port);

		reqtype = (request != IE_REQ_NONE) ?
			  ipc_port_request_type(port, name, request) : 0;
		
		<span class="enscript-comment">/*
		 * If the port is alive, or was alive when the mach_port_names
		 * started, then return that fact.  Otherwise, pretend we found
		 * a dead name entry.
		 */</span>
		<span class="enscript-keyword">if</span> (ip_active(port) || IP_TIMESTAMP_ORDER(timestamp, port-&gt;ip_timestamp)) {
			type |= reqtype;
		} <span class="enscript-keyword">else</span> {
			bits &amp;= ~(IE_BITS_TYPE_MASK);
			bits |= MACH_PORT_TYPE_DEAD_NAME;
			<span class="enscript-comment">/* account for additional reference for dead-name notification */</span>
			<span class="enscript-keyword">if</span> (reqtype != 0)
				bits++;
		}
		ip_unlock(port);
	}

	type |= IE_BITS_TYPE(bits);

	actual = *actualp;
	names[actual] = name;
	types[actual] = type;
	*actualp = actual+1;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_names [kernel call]
 *	Purpose:
 *		Retrieves a list of the rights present in the space,
 *		along with type information.  (Same as returned
 *		by mach_port_type.)  The names are returned in
 *		no particular order, but they (and the type info)
 *		are an accurate snapshot of the space.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Arrays of names and types returned.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_names</span>(
	ipc_space_t		space,
	mach_port_name_t	**namesp,
	mach_msg_type_number_t	*namesCnt,
	mach_port_type_t	**typesp,
	mach_msg_type_number_t	*typesCnt)
{
	ipc_entry_t table;
	ipc_entry_num_t tsize;
	mach_port_index_t index;
	ipc_entry_num_t actual;	<span class="enscript-comment">/* this many names */</span>
	ipc_port_timestamp_t timestamp;	<span class="enscript-comment">/* logical time of this operation */</span>
	mach_port_name_t *names;
	mach_port_type_t *types;
	kern_return_t kr;

	vm_size_t size;		<span class="enscript-comment">/* size of allocated memory */</span>
	vm_offset_t addr1;	<span class="enscript-comment">/* allocated memory, for names */</span>
	vm_offset_t addr2;	<span class="enscript-comment">/* allocated memory, for types */</span>
	vm_map_copy_t memory1;	<span class="enscript-comment">/* copied-in memory, for names */</span>
	vm_map_copy_t memory2;	<span class="enscript-comment">/* copied-in memory, for types */</span>

	<span class="enscript-comment">/* safe simplifying assumption */</span>
	assert_static(<span class="enscript-keyword">sizeof</span>(mach_port_name_t) == <span class="enscript-keyword">sizeof</span>(mach_port_type_t));

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	size = 0;

	<span class="enscript-keyword">for</span> (;;) {
		ipc_entry_num_t bound;
		vm_size_t size_needed;

		is_read_lock(space);
		<span class="enscript-keyword">if</span> (!is_active(space)) {
			is_read_unlock(space);
			<span class="enscript-keyword">if</span> (size != 0) {
				kmem_free(ipc_kernel_map, addr1, size);
				kmem_free(ipc_kernel_map, addr2, size);
			}
			<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
		}

		<span class="enscript-comment">/* upper bound on number of names in the space */</span>
		bound = space-&gt;is_table_size;
		size_needed = vm_map_round_page(
			(bound * <span class="enscript-keyword">sizeof</span>(mach_port_name_t)),
			VM_MAP_PAGE_MASK(ipc_kernel_map));

		<span class="enscript-keyword">if</span> (size_needed &lt;= size)
			<span class="enscript-keyword">break</span>;

		is_read_unlock(space);

		<span class="enscript-keyword">if</span> (size != 0) {
			kmem_free(ipc_kernel_map, addr1, size);
			kmem_free(ipc_kernel_map, addr2, size);
		}
		size = size_needed;

		kr = vm_allocate(ipc_kernel_map, &amp;addr1, size, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IPC));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

		kr = vm_allocate(ipc_kernel_map, &amp;addr2, size, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IPC));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			kmem_free(ipc_kernel_map, addr1, size);
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
		}

		<span class="enscript-comment">/* can't fault while we hold locks */</span>

		kr = vm_map_wire(
			ipc_kernel_map,
			vm_map_trunc_page(addr1,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr1 + size,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			VM_PROT_READ|VM_PROT_WRITE|VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_IPC),
			FALSE);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			kmem_free(ipc_kernel_map, addr1, size);
			kmem_free(ipc_kernel_map, addr2, size);
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
		}

		kr = vm_map_wire(
			ipc_kernel_map,
			vm_map_trunc_page(addr2,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr2 + size,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			VM_PROT_READ|VM_PROT_WRITE|VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_IPC),
			FALSE);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			kmem_free(ipc_kernel_map, addr1, size);
			kmem_free(ipc_kernel_map, addr2, size);
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
		}

	}
	<span class="enscript-comment">/* space is read-locked and active */</span>

	names = (mach_port_name_t *) addr1;
	types = (mach_port_type_t *) addr2;
	actual = 0;

	timestamp = ipc_port_timestamp();

	table = space-&gt;is_table;
	tsize = space-&gt;is_table_size;

	<span class="enscript-keyword">for</span> (index = 0; index &lt; tsize; index++) {
		ipc_entry_t entry = &amp;table[index];
		ipc_entry_bits_t bits = entry-&gt;ie_bits;

		<span class="enscript-keyword">if</span> (IE_BITS_TYPE(bits) != MACH_PORT_TYPE_NONE) {
			mach_port_name_t name;

			name = MACH_PORT_MAKE(index, IE_BITS_GEN(bits));
			mach_port_names_helper(timestamp, entry, name, names,
					       types, &amp;actual);
		}
	}

	is_read_unlock(space);

	<span class="enscript-keyword">if</span> (actual == 0) {
		memory1 = VM_MAP_COPY_NULL;
		memory2 = VM_MAP_COPY_NULL;

		<span class="enscript-keyword">if</span> (size != 0) {
			kmem_free(ipc_kernel_map, addr1, size);
			kmem_free(ipc_kernel_map, addr2, size);
		}
	} <span class="enscript-keyword">else</span> {
		vm_size_t size_used;
		vm_size_t vm_size_used;

		size_used = actual * <span class="enscript-keyword">sizeof</span>(mach_port_name_t);
		vm_size_used =
			vm_map_round_page(size_used,
					  VM_MAP_PAGE_MASK(ipc_kernel_map));

		<span class="enscript-comment">/*
		 *	Make used memory pageable and get it into
		 *	copied-in form.  Free any unused memory.
		 */</span>

		kr = vm_map_unwire(
			ipc_kernel_map,
			vm_map_trunc_page(addr1,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr1 + vm_size_used,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			FALSE);
		assert(kr == KERN_SUCCESS);

		kr = vm_map_unwire(
			ipc_kernel_map,
			vm_map_trunc_page(addr2,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			vm_map_round_page(addr2 + vm_size_used,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			FALSE);
		assert(kr == KERN_SUCCESS);

		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)addr1,
				   (vm_map_size_t)size_used, TRUE, &amp;memory1);
		assert(kr == KERN_SUCCESS);

		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)addr2,
				   (vm_map_size_t)size_used, TRUE, &amp;memory2);
		assert(kr == KERN_SUCCESS);

		<span class="enscript-keyword">if</span> (vm_size_used != size) {
			kmem_free(ipc_kernel_map,
				  addr1 + vm_size_used, size - vm_size_used);
			kmem_free(ipc_kernel_map,
				  addr2 + vm_size_used, size - vm_size_used);
		}
	}

	*namesp = (mach_port_name_t *) memory1;
	*namesCnt = actual;
	*typesp = (mach_port_type_t *) memory2;
	*typesCnt = actual;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_type [kernel call]
 *	Purpose:
 *		Retrieves the type of a right in the space.
 *		The type is a bitwise combination of one or more
 *		of the following type bits:
 *			MACH_PORT_TYPE_SEND
 *			MACH_PORT_TYPE_RECEIVE
 *			MACH_PORT_TYPE_SEND_ONCE
 *			MACH_PORT_TYPE_PORT_SET
 *			MACH_PORT_TYPE_DEAD_NAME
 *		In addition, the following pseudo-type bits may be present:
 *			MACH_PORT_TYPE_DNREQUEST
 *				A dead-name notification is requested.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Type is returned.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_type</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_type_t	*typep)
{
	mach_port_urefs_t urefs;
	ipc_entry_t entry;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (name == MACH_PORT_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;

	<span class="enscript-keyword">if</span> (name == MACH_PORT_DEAD) {
		*typep = MACH_PORT_TYPE_DEAD_NAME;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* space is write-locked and active */</span>
	kr = ipc_right_info(space, name, entry, typep, &amp;urefs);
	<span class="enscript-comment">/* space is unlocked */</span>

#<span class="enscript-reference">if</span> 1
        <span class="enscript-comment">/* JMM - workaround rdar://problem/9121297 (CF being too picky on these bits). */</span>
        *typep &amp;= ~(MACH_PORT_TYPE_SPREQUEST | MACH_PORT_TYPE_SPREQUEST_DELAYED);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_rename [kernel call]
 *	Purpose:
 *		Changes the name denoting a right,
 *		from oname to nname.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The right is renamed.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The oname doesn't denote a right.
 *		KERN_INVALID_VALUE	The nname isn't a legal name.
 *		KERN_NAME_EXISTS	The nname already denotes a right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *
 *      This interface is obsolete and always returns
 *      KERN_NOT_SUPPORTED.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_rename</span>(
	__unused ipc_space_t		space,
	__unused mach_port_name_t	oname,
	__unused mach_port_name_t	nname)
{
	<span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
}


<span class="enscript-comment">/*
 *	Routine:	mach_port_allocate_name [kernel call]
 *	Purpose:
 *		Allocates a right in a space, using a specific name
 *		for the new right.  Possible rights:
 *			MACH_PORT_RIGHT_RECEIVE
 *			MACH_PORT_RIGHT_PORT_SET
 *			MACH_PORT_RIGHT_DEAD_NAME
 *
 *		A new port (allocated with MACH_PORT_RIGHT_RECEIVE)
 *		has no extant send or send-once rights and no queued
 *		messages.  Its queue limit is MACH_PORT_QLIMIT_DEFAULT
 *		and its make-send count is 0.  It is not a member of
 *		a port set.  It has no registered no-senders or
 *		port-destroyed notification requests.
 *
 *		A new port set has no members.
 *
 *		A new dead name has one user reference.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The right is allocated.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	The name isn't a legal name.
 *		KERN_INVALID_VALUE	&quot;right&quot; isn't a legal kind of right.
 *		KERN_NAME_EXISTS	The name already denotes a right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *
 *	Restrictions on name allocation:  NT bits are reserved by kernel,
 *	must be set on any chosen name.  Can't do this at all in kernel
 *	loaded server.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_allocate_name</span>(
	ipc_space_t		space,
	mach_port_right_t	right,
	mach_port_name_t	name)
{
	kern_return_t		kr;
	mach_port_qos_t		qos = qos_template;

	qos.name = TRUE;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

	kr = mach_port_allocate_full (space, right, MACH_PORT_NULL,
					&amp;qos, &amp;name);
	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_allocate [kernel call]
 *	Purpose:
 *		Allocates a right in a space.  Like mach_port_allocate_name,
 *		except that the implementation picks a name for the right.
 *		The name may be any legal name in the space that doesn't
 *		currently denote a right.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The right is allocated.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	&quot;right&quot; isn't a legal kind of right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *		KERN_NO_SPACE		No room in space for another right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_allocate</span>(
	ipc_space_t		space,
	mach_port_right_t	right,
	mach_port_name_t	*namep)
{
	kern_return_t		kr;
	mach_port_qos_t		qos = qos_template;

	kr = mach_port_allocate_full (space, right, MACH_PORT_NULL,
					&amp;qos, namep);
	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_allocate_qos [kernel call]
 *	Purpose:
 *		Allocates a right, with qos options, in a space.  Like 
 *		mach_port_allocate_name, except that the implementation 
 *		picks a name for the right. The name may be any legal name 
 *		in the space that doesn't currently denote a right.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The right is allocated.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	&quot;right&quot; isn't a legal kind of right.
 *		KERN_INVALID_ARGUMENT   The qos request was invalid.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *		KERN_NO_SPACE		No room in space for another right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_allocate_qos</span>(
	ipc_space_t		space,
	mach_port_right_t	right,
	mach_port_qos_t		*qosp,
	mach_port_name_t	*namep)
{
	kern_return_t		kr;

	<span class="enscript-keyword">if</span> (qosp-&gt;name)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	kr = mach_port_allocate_full (space, right, MACH_PORT_NULL,
					qosp, namep);
	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_allocate_full [kernel call]
 *	Purpose:
 *		Allocates a right in a space.  Supports all of the
 *		special cases, such as specifying a subsystem,
 *		a specific name, a real-time port, etc.
 *		The name may be any legal name in the space that doesn't
 *		currently denote a right.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The right is allocated.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	&quot;right&quot; isn't a legal kind of right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *		KERN_NO_SPACE		No room in space for another right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_allocate_full</span>(
	ipc_space_t		space,
	mach_port_right_t	right,
	mach_port_t		proto,
	mach_port_qos_t		*qosp,
	mach_port_name_t	*namep)
{
	ipc_kmsg_t		kmsg = IKM_NULL;
	kern_return_t		kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_TASK);

	<span class="enscript-keyword">if</span> (proto != MACH_PORT_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	<span class="enscript-keyword">if</span> (qosp-&gt;name) {
		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID (*namep))
			<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);
	}

	<span class="enscript-keyword">if</span> (qosp-&gt;prealloc) {
		<span class="enscript-keyword">if</span> (qosp-&gt;len &gt; MACH_MSG_SIZE_MAX - MAX_TRAILER_SIZE) {
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
		} <span class="enscript-keyword">else</span> {
			mach_msg_size_t size = qosp-&gt;len + MAX_TRAILER_SIZE;

			<span class="enscript-keyword">if</span> (right != MACH_PORT_RIGHT_RECEIVE)
				<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

			kmsg = (ipc_kmsg_t)ipc_kmsg_prealloc(size);
			<span class="enscript-keyword">if</span> (kmsg == IKM_NULL)
				<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
		}
	}

	<span class="enscript-keyword">switch</span> (right) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_RECEIVE</span>:
	    {
		ipc_port_t	port;

		<span class="enscript-keyword">if</span> (qosp-&gt;name)
			kr = ipc_port_alloc_name(space, *namep, &amp;port);
		<span class="enscript-keyword">else</span>
			kr = ipc_port_alloc(space, namep, &amp;port);
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
			<span class="enscript-keyword">if</span> (kmsg != IKM_NULL) 
				ipc_kmsg_set_prealloc(kmsg, port);

			ip_unlock(port);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kmsg != IKM_NULL)
			ipc_kmsg_free(kmsg);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_PORT_SET</span>:
	    {
		ipc_pset_t	pset;

		<span class="enscript-keyword">if</span> (qosp-&gt;name)
			kr = ipc_pset_alloc_name(space, *namep, &amp;pset);
		<span class="enscript-keyword">else</span>
			kr = ipc_pset_alloc(space, namep, &amp;pset);
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
			ips_unlock(pset);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_DEAD_NAME</span>:
		kr = ipc_object_alloc_dead(space, namep);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		kr = KERN_INVALID_VALUE;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_destroy [kernel call]
 *	Purpose:
 *		Cleans up and destroys all rights denoted by a name
 *		in a space.  The destruction of a receive right
 *		destroys the port, unless a port-destroyed request
 *		has been made for it; the destruction of a port-set right
 *		destroys the port set.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The name is destroyed.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_destroy</span>(
	ipc_space_t		space,
	mach_port_name_t	name)
{
	ipc_entry_t entry;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked and active */</span>

	kr = ipc_right_destroy(space, name, entry, TRUE, 0); <span class="enscript-comment">/* unlocks space */</span>
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_deallocate [kernel call]
 *	Purpose:
 *		Deallocates a user reference from a send right,
 *		send-once right, or a dead-name right.  May
 *		deallocate the right, if this is the last uref,
 *		and destroy the name, if it doesn't denote
 *		other rights.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The uref is deallocated.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	The right isn't correct.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_deallocate</span>(
	ipc_space_t		space,
	mach_port_name_t	name)
{
	ipc_entry_t entry;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked */</span>

	kr = ipc_right_dealloc(space, name, entry); <span class="enscript-comment">/* unlocks space */</span>
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_get_refs [kernel call]
 *	Purpose:
 *		Retrieves the number of user references held by a right.
 *		Receive rights, port-set rights, and send-once rights
 *		always have one user reference.  Returns zero if the
 *		name denotes a right, but not the queried right.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Number of urefs returned.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	&quot;right&quot; isn't a legal value.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_get_refs</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_right_t	right,
	mach_port_urefs_t	*urefsp)
{
	mach_port_type_t type;
	mach_port_urefs_t urefs;
	ipc_entry_t entry;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (right &gt;= MACH_PORT_RIGHT_NUMBER)
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
	  	<span class="enscript-keyword">if</span> (right == MACH_PORT_RIGHT_SEND ||
		    right == MACH_PORT_RIGHT_SEND_ONCE) {
			*urefsp = 1;
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		}
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}

	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* space is write-locked and active */</span>
	kr = ipc_right_info(space, name, entry, &amp;type, &amp;urefs);
	<span class="enscript-comment">/* space is unlocked */</span>

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;	

	<span class="enscript-keyword">if</span> (type &amp; MACH_PORT_TYPE(right))
		<span class="enscript-keyword">switch</span> (right) {
		    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_SEND_ONCE</span>:
			assert(urefs == 1);
			<span class="enscript-comment">/* fall-through */</span>

		    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_PORT_SET</span>:
		    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_RECEIVE</span>:
			*urefsp = 1;
			<span class="enscript-keyword">break</span>;

		    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_DEAD_NAME</span>:
		    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RIGHT_SEND</span>:
			assert(urefs &gt; 0);
			*urefsp = urefs;
			<span class="enscript-keyword">break</span>;

		    <span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;mach_port_get_refs: strange rights&quot;</span>);
		}
	<span class="enscript-keyword">else</span>
		*urefsp = 0;

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_mod_refs
 *	Purpose:
 *		Modifies the number of user references held by a right.
 *		The resulting number of user references must be non-negative.
 *		If it is zero, the right is deallocated.  If the name
 *		doesn't denote other rights, it is destroyed.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Modified number of urefs.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	&quot;right&quot; isn't a legal value.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote specified right.
 *		KERN_INVALID_VALUE	Impossible modification to urefs.
 *		KERN_UREFS_OVERFLOW	Urefs would overflow.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_mod_refs</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_right_t	right,
	mach_port_delta_t	delta)
{
	ipc_entry_t entry;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (right &gt;= MACH_PORT_RIGHT_NUMBER)
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
		<span class="enscript-keyword">if</span> (right == MACH_PORT_RIGHT_SEND ||
		    right == MACH_PORT_RIGHT_SEND_ONCE)
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}

	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked and active */</span>

	kr = ipc_right_delta(space, name, entry, right, delta);	<span class="enscript-comment">/* unlocks */</span>
	<span class="enscript-keyword">return</span> kr;
}


<span class="enscript-comment">/*
 *	Routine:	mach_port_peek [kernel call]
 *	Purpose:
 *		Peek at the message queue for the specified receive
 *		right and return info about a message in the queue.
 *
 *		On input, seqnop points to a sequence number value
 *		to match the message being peeked. If zero is specified
 *		as the seqno, the first message in the queue will be
 *		peeked.
 *
 *		Only the following trailer types are currently supported:
 *			MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)
 *
 *				or'ed with one of these element types:
 *			MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_NULL)
 *			MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SEQNO)
 *			MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER)
 *			MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AUDIT)
 *
 *		On input, the value pointed to by trailer_sizep must be
 *		large enough to hold the requested trailer size.
 *
 *		The message sequence number, id, size, requested trailer info
 *		and requested trailer size are returned in their respective
 *		output parameters upon success.
 *
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Matching message found, out parameters set.
 *		KERN_INVALID_TASK	The space is null or dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote receive rights.
 *		KERN_INVALID_VALUE	The input parameter values are out of bounds.
 *		KERN_FAILURE		The requested message was not found.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_peek</span>(
	ipc_space_t			space,
	mach_port_name_t		name,
	mach_msg_trailer_type_t 	trailer_type,
	mach_port_seqno_t		*seqnop,
	mach_msg_size_t			*msg_sizep,
	mach_msg_id_t			*msg_idp,
	mach_msg_trailer_info_t 	trailer_infop,
	mach_msg_type_number_t		*trailer_sizep)
{
	ipc_port_t port;
	kern_return_t kr;
	boolean_t found;
	mach_msg_max_trailer_t max_trailer;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	<span class="enscript-comment">/*
	 * We don't allow anything greater than the audit trailer - to avoid
	 * leaking the context pointer and to avoid variable-sized context issues.
	 */</span>
	<span class="enscript-keyword">if</span> (GET_RCV_ELEMENTS(trailer_type) &gt; MACH_RCV_TRAILER_AUDIT ||
	    REQUESTED_TRAILER_SIZE(TRUE, trailer_type) &gt; *trailer_sizep) 
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

	*trailer_sizep = REQUESTED_TRAILER_SIZE(TRUE, trailer_type);

	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* Port locked and active */</span>

	found = ipc_mqueue_peek(&amp;port-&gt;ip_messages, seqnop,
				msg_sizep, msg_idp, &amp;max_trailer);
	ip_unlock(port);

	<span class="enscript-keyword">if</span> (found != TRUE)
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	max_trailer.msgh_seqno = *seqnop;
	memcpy(trailer_infop, &amp;max_trailer, *trailer_sizep);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_set_mscount [kernel call]
 *	Purpose:
 *		Changes a receive right's make-send count.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Set make-send count.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote receive rights.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_set_mscount</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_mscount_t	mscount)
{
	ipc_port_t port;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* port is locked and active */</span>

	ipc_port_set_mscount(port, mscount);

	ip_unlock(port);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_set_seqno [kernel call]
 *	Purpose:
 *		Changes a receive right's sequence number.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Set sequence number.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote receive rights.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_set_seqno</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_seqno_t	seqno)
{
	ipc_port_t port;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* port is locked and active */</span>

	ipc_mqueue_set_seqno(&amp;port-&gt;ip_messages, seqno);

	ip_unlock(port);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_get_context [kernel call]
 *	Purpose:
 *		Returns a receive right's context pointer.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Set context pointer.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote receive rights.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_get_context</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_vm_address_t	*context)
{
	ipc_port_t port;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* Port locked and active */</span>

	<span class="enscript-comment">/* For strictly guarded ports, return empty context (which acts as guard) */</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_strict_guard)
		*context = 0;
	<span class="enscript-keyword">else</span>
		*context = port-&gt;ip_context;

	ip_unlock(port);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	mach_port_set_context [kernel call]
 *	Purpose:
 *		Changes a receive right's context pointer.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Set context pointer.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote receive rights.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_set_context</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_vm_address_t	context)
{
	ipc_port_t port;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* port is locked and active */</span>
	<span class="enscript-keyword">if</span>(port-&gt;ip_strict_guard) {
		uint64_t portguard = port-&gt;ip_context;
		ip_unlock(port);
		<span class="enscript-comment">/* For strictly guarded ports, disallow overwriting context; Raise Exception */</span>
		mach_port_guard_exception(name, context, portguard, kGUARD_EXC_SET_CONTEXT);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	port-&gt;ip_context = context;

	ip_unlock(port);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	mach_port_get_set_status [kernel call]
 *	Purpose:
 *		Retrieves a list of members in a port set.
 *		Returns the space's name for each receive right member.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Retrieved list of members.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote a port set.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_get_set_status</span>(
	ipc_space_t			space,
	mach_port_name_t		name,
	mach_port_name_t		**members,
	mach_msg_type_number_t		*membersCnt)
{
	ipc_entry_num_t actual;		<span class="enscript-comment">/* this many members */</span>
	ipc_entry_num_t maxnames;	<span class="enscript-comment">/* space for this many members */</span>
	kern_return_t kr;

	vm_size_t size;		<span class="enscript-comment">/* size of allocated memory */</span>
	vm_offset_t addr;	<span class="enscript-comment">/* allocated memory */</span>
	vm_map_copy_t memory;	<span class="enscript-comment">/* copied-in memory */</span>

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	size = VM_MAP_PAGE_SIZE(ipc_kernel_map);	<span class="enscript-comment">/* initial guess */</span>

	<span class="enscript-keyword">for</span> (;;) {
		mach_port_name_t *names;
		ipc_object_t psobj;
		ipc_pset_t pset;

		kr = vm_allocate(ipc_kernel_map, &amp;addr, size, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IPC));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

		<span class="enscript-comment">/* can't fault while we hold locks */</span>

		kr = vm_map_wire(ipc_kernel_map, addr, addr + size,
				     VM_PROT_READ|VM_PROT_WRITE|VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_IPC), FALSE);
		assert(kr == KERN_SUCCESS);

		kr = ipc_object_translate(space, name, MACH_PORT_RIGHT_PORT_SET, &amp;psobj);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			kmem_free(ipc_kernel_map, addr, size);
			<span class="enscript-keyword">return</span> kr;
		}

		<span class="enscript-comment">/* just use a portset reference from here on out */</span>
		__IGNORE_WCASTALIGN(pset = (ipc_pset_t) psobj);
		ips_reference(pset);
		ips_unlock(pset); 

		names = (mach_port_name_t *) addr;
		maxnames = (ipc_entry_num_t)(size / <span class="enscript-keyword">sizeof</span>(mach_port_name_t));

		ipc_mqueue_set_gather_member_names(space, &amp;pset-&gt;ips_messages, maxnames, names, &amp;actual);

		<span class="enscript-comment">/* release the portset reference */</span>
		ips_release(pset);

		<span class="enscript-keyword">if</span> (actual &lt;= maxnames)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* didn't have enough memory; allocate more */</span>
		kmem_free(ipc_kernel_map, addr, size);
		size = vm_map_round_page(
			(actual * <span class="enscript-keyword">sizeof</span>(mach_port_name_t)),
			 VM_MAP_PAGE_MASK(ipc_kernel_map)) +
			VM_MAP_PAGE_SIZE(ipc_kernel_map);
	}

	<span class="enscript-keyword">if</span> (actual == 0) {
		memory = VM_MAP_COPY_NULL;

		kmem_free(ipc_kernel_map, addr, size);
	} <span class="enscript-keyword">else</span> {
		vm_size_t size_used;
		vm_size_t vm_size_used;

		size_used = actual * <span class="enscript-keyword">sizeof</span>(mach_port_name_t);
		vm_size_used = vm_map_round_page(
			size_used,
			VM_MAP_PAGE_MASK(ipc_kernel_map));

		<span class="enscript-comment">/*
		 *	Make used memory pageable and get it into
		 *	copied-in form.  Free any unused memory.
		 */</span>

		kr = vm_map_unwire(
			ipc_kernel_map,
			vm_map_trunc_page(addr,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)), 
			vm_map_round_page(addr + vm_size_used,
					  VM_MAP_PAGE_MASK(ipc_kernel_map)),
			FALSE);
		assert(kr == KERN_SUCCESS);

		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)addr,
				   (vm_map_size_t)size_used, TRUE, &amp;memory);
		assert(kr == KERN_SUCCESS);

		<span class="enscript-keyword">if</span> (vm_size_used != size)
			kmem_free(ipc_kernel_map,
				  addr + vm_size_used, size - vm_size_used);
	}

	*members = (mach_port_name_t *) memory;
	*membersCnt = actual;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_move_member [kernel call]
 *	Purpose:
 *		If after is MACH_PORT_NULL, removes member
 *		from the port set it is in.  Otherwise, adds
 *		member to after, removing it from any set
 *		it might already be in.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Moved the port.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	Member didn't denote a right.
 *		KERN_INVALID_RIGHT	Member didn't denote a receive right.
 *		KERN_INVALID_NAME	After didn't denote a right.
 *		KERN_INVALID_RIGHT	After didn't denote a port set right.
 *		KERN_NOT_IN_SET
 *			After is MACH_PORT_NULL and Member isn't in a port set.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_move_member</span>(
	ipc_space_t		space,
	mach_port_name_t	member,
	mach_port_name_t	after)
{
	ipc_entry_t entry;
	ipc_port_t port;
	ipc_pset_t nset;
	kern_return_t kr;
	uint64_t wq_link_id = 0;
	uint64_t wq_reserved_prepost = 0;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(member))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	<span class="enscript-keyword">if</span> (after == MACH_PORT_DEAD) {
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (after == MACH_PORT_NULL) {
		wq_link_id = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * We reserve both a link, and
		 * enough prepost objects to complete
		 * the set move atomically - we can't block
		 * while we're holding the space lock, and
		 * the ipc_pset_add calls ipc_mqueue_add
		 * which may have to prepost this port onto
		 * this set.
		 */</span>
		wq_link_id = waitq_link_reserve(NULL);
		wq_reserved_prepost = waitq_prepost_reserve(NULL, 10,
							    WAITQ_DONT_LOCK,
							    NULL);
	}

	kr = ipc_right_lookup_read(space, member, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* space is read-locked and active */</span>

	<span class="enscript-keyword">if</span> ((entry-&gt;ie_bits &amp; MACH_PORT_TYPE_RECEIVE) == 0) {
		is_read_unlock(space);
		kr = KERN_INVALID_RIGHT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	__IGNORE_WCASTALIGN(port = (ipc_port_t) entry-&gt;ie_object);
	assert(port != IP_NULL);

	<span class="enscript-keyword">if</span> (after == MACH_PORT_NULL)
		nset = IPS_NULL;
	<span class="enscript-keyword">else</span> {
		entry = ipc_entry_lookup(space, after);
		<span class="enscript-keyword">if</span> (entry == IE_NULL) {
			is_read_unlock(space);
			kr = KERN_INVALID_NAME;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-keyword">if</span> ((entry-&gt;ie_bits &amp; MACH_PORT_TYPE_PORT_SET) == 0) {
			is_read_unlock(space);
			kr = KERN_INVALID_RIGHT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		__IGNORE_WCASTALIGN(nset = (ipc_pset_t) entry-&gt;ie_object);
		assert(nset != IPS_NULL);
	}
	ip_lock(port);
	ipc_pset_remove_from_all(port);

	<span class="enscript-keyword">if</span> (nset != IPS_NULL) {
		ips_lock(nset);
		kr = ipc_pset_add(nset, port, &amp;wq_link_id, &amp;wq_reserved_prepost);
		ips_unlock(nset);
	}
	ip_unlock(port);
	is_read_unlock(space);

 <span class="enscript-reference">done</span>:

	<span class="enscript-comment">/*
	 * on success the ipc_pset_add() will consume the wq_link_id
	 * value (resetting it to 0), so this function is always safe to call.
	 */</span>
	waitq_link_release(wq_link_id);
	waitq_prepost_release_reserve(wq_reserved_prepost);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_request_notification [kernel call]
 *	Purpose:
 *		Requests a notification.  The caller supplies
 *		a send-once right for the notification to use,
 *		and the call returns the previously registered
 *		send-once right, if any.  Possible types:
 *
 *		MACH_NOTIFY_PORT_DESTROYED
 *			Requests a port-destroyed notification
 *			for a receive right.  Sync should be zero.
 *		MACH_NOTIFY_NO_SENDERS
 *			Requests a no-senders notification for a
 *			receive right.  If there are currently no
 *			senders, sync is less than or equal to the
 *			current make-send count, and a send-once right
 *			is supplied, then an immediate no-senders
 *			notification is generated.
 *		MACH_NOTIFY_DEAD_NAME
 *			Requests a dead-name notification for a send
 *			or receive right.  If the name is already a
 *			dead name, sync is non-zero, and a send-once
 *			right is supplied, then an immediate dead-name
 *			notification is generated.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Requested a notification.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	Bad id value.
 *		KERN_INVALID_NAME	Name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote appropriate right.
 *		KERN_INVALID_CAPABILITY	The notify port is dead.
 *	MACH_NOTIFY_PORT_DESTROYED:
 *		KERN_INVALID_VALUE	Sync isn't zero.
 *	MACH_NOTIFY_DEAD_NAME:
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *		KERN_INVALID_ARGUMENT	Name denotes dead name, but
 *			sync is zero or notify is IP_NULL.
 *		KERN_UREFS_OVERFLOW	Name denotes dead name, but
 *			generating immediate notif. would overflow urefs.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_request_notification</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_msg_id_t		id,
	mach_port_mscount_t	sync,
	ipc_port_t		notify,
	ipc_port_t		*previousp)
{
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (notify == IP_DEAD)
		<span class="enscript-keyword">return</span> KERN_INVALID_CAPABILITY;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">NOTYET</span>
	<span class="enscript-comment">/*
	 *	Requesting notifications on RPC ports is an error.
	 */</span>
	{
		ipc_port_t port;
		ipc_entry_t entry;	

		kr = ipc_right_lookup_write(space, name, &amp;entry);	
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;

		port = (ipc_port_t) entry-&gt;ie_object;

		<span class="enscript-keyword">if</span> (port-&gt;ip_subsystem != NULL) {
			is_write_unlock(space);
			panic(<span class="enscript-string">&quot;mach_port_request_notification: on RPC port!!&quot;</span>); 
			<span class="enscript-keyword">return</span> KERN_INVALID_CAPABILITY;
		}
		is_write_unlock(space);
	}
#<span class="enscript-reference">endif</span> 	<span class="enscript-comment">/* NOTYET */</span>


	<span class="enscript-keyword">switch</span> (id) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_NOTIFY_PORT_DESTROYED</span>: {
		ipc_port_t port, previous;

		<span class="enscript-keyword">if</span> (sync != 0)
			<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

		kr = ipc_port_translate_receive(space, name, &amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-comment">/* port is locked and active */</span>

		ipc_port_pdrequest(port, notify, &amp;previous);
		<span class="enscript-comment">/* port is unlocked */</span>

		*previousp = previous;
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_NOTIFY_NO_SENDERS</span>: {
		ipc_port_t port;

		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

		kr = ipc_port_translate_receive(space, name, &amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-comment">/* port is locked and active */</span>

		ipc_port_nsrequest(port, sync, notify, previousp);
		<span class="enscript-comment">/* port is unlocked */</span>
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_NOTIFY_SEND_POSSIBLE</span>:

	    	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
	      		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}

		kr = ipc_right_request_alloc(space, name, sync != 0,
					     TRUE, notify, previousp);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_NOTIFY_DEAD_NAME</span>:

	    	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
			<span class="enscript-comment">/*
			 * Already dead.
			 * Should do immediate delivery check -
			 * will do that in the near future.
			 */</span>
	      		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}

		kr = ipc_right_request_alloc(space, name, sync != 0,
					     FALSE, notify, previousp);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_insert_right [kernel call]
 *	Purpose:
 *		Inserts a right into a space, as if the space
 *		voluntarily received the right in a message,
 *		except that the right gets the specified name.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Inserted the right.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	The name isn't a legal name.
 *		KERN_NAME_EXISTS	The name already denotes a right.
 *		KERN_INVALID_VALUE	Message doesn't carry a port right.
 *		KERN_INVALID_CAPABILITY	Port is null or dead.
 *		KERN_UREFS_OVERFLOW	Urefs limit would be exceeded.
 *		KERN_RIGHT_EXISTS	Space has rights under another name.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_insert_right</span>(
	ipc_space_t			space,
	mach_port_name_t		name,
	ipc_port_t			poly,
	mach_msg_type_name_t		polyPoly)
{
	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name) ||
	    !MACH_MSG_TYPE_PORT_ANY_RIGHT(polyPoly))
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

	<span class="enscript-keyword">if</span> (!IO_VALID((ipc_object_t) poly))
		<span class="enscript-keyword">return</span> KERN_INVALID_CAPABILITY;

	<span class="enscript-keyword">return</span> ipc_object_copyout_name(space, (ipc_object_t) poly, 
				       polyPoly, FALSE, name);
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_extract_right [kernel call]
 *	Purpose:
 *		Extracts a right from a space, as if the space
 *		voluntarily sent the right to the caller.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Extracted the right.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_VALUE	Requested type isn't a port right.
 *		KERN_INVALID_NAME	Name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote appropriate right.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_extract_right</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_msg_type_name_t	msgt_name,
	ipc_port_t		*poly,
	mach_msg_type_name_t	*polyPoly)
{
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_MSG_TYPE_PORT_ANY(msgt_name))
		<span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
		<span class="enscript-comment">/*
		 * really should copy out a dead name, if it is a send or
		 * send-once right being copied, but instead return an
		 * error for now.
		 */</span>
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	kr = ipc_object_copyin(space, name, msgt_name, (ipc_object_t *) poly);

	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
		*polyPoly = ipc_object_copyin_type(msgt_name);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_get_status_helper [helper]
 *	Purpose:
 *		Populates a mach_port_status_t structure with
 *		port information.
 *	Conditions:
 *		Port needs to be locked
 *	Returns:
 *		None.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mach_port_get_status_helper</span>(
	ipc_port_t		port,
	mach_port_status_t	*statusp)
{
	spl_t s;

	s = splsched();
	imq_lock(&amp;port-&gt;ip_messages);
	<span class="enscript-comment">/* don't leak set IDs, just indicate that the port is in one or not */</span>
	statusp-&gt;mps_pset = !!(port-&gt;ip_in_pset);
	statusp-&gt;mps_seqno = port-&gt;ip_messages.imq_seqno;
	statusp-&gt;mps_qlimit = port-&gt;ip_messages.imq_qlimit;
	statusp-&gt;mps_msgcount = port-&gt;ip_messages.imq_msgcount;
	imq_unlock(&amp;port-&gt;ip_messages);
	splx(s);
	
	statusp-&gt;mps_mscount = port-&gt;ip_mscount;
	statusp-&gt;mps_sorights = port-&gt;ip_sorights;
	statusp-&gt;mps_srights = port-&gt;ip_srights &gt; 0;
	statusp-&gt;mps_pdrequest = port-&gt;ip_pdrequest != IP_NULL;
	statusp-&gt;mps_nsrequest = port-&gt;ip_nsrequest != IP_NULL;
	statusp-&gt;mps_flags = 0;
	<span class="enscript-keyword">if</span> (port-&gt;ip_impdonation) {
		statusp-&gt;mps_flags |= MACH_PORT_STATUS_FLAG_IMP_DONATION;
		<span class="enscript-keyword">if</span> (port-&gt;ip_tempowner) {
			statusp-&gt;mps_flags |= MACH_PORT_STATUS_FLAG_TEMPOWNER;
			<span class="enscript-keyword">if</span> (IIT_NULL != port-&gt;ip_imp_task) {
				statusp-&gt;mps_flags |= MACH_PORT_STATUS_FLAG_TASKPTR;
			}
		}
	}
	<span class="enscript-keyword">if</span> (port-&gt;ip_guarded) {
		statusp-&gt;mps_flags |= MACH_PORT_STATUS_FLAG_GUARDED;
		<span class="enscript-keyword">if</span> (port-&gt;ip_strict_guard) {
			statusp-&gt;mps_flags |= MACH_PORT_STATUS_FLAG_STRICT_GUARD;
		}
	}
	<span class="enscript-keyword">return</span>;
}



kern_return_t
<span class="enscript-function-name">mach_port_get_attributes</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	<span class="enscript-type">int</span>			flavor,
        mach_port_info_t	info,
        mach_msg_type_number_t	*count)
{
	ipc_port_t port;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

        <span class="enscript-keyword">switch</span> (flavor) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_LIMITS_INFO</span>: {
                mach_port_limits_t *lp = (mach_port_limits_t *)info;

                <span class="enscript-keyword">if</span> (*count &lt; MACH_PORT_LIMITS_INFO_COUNT)
                        <span class="enscript-keyword">return</span> KERN_FAILURE;

                <span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
			*count = 0;
			<span class="enscript-keyword">break</span>;
		}
			
                kr = ipc_port_translate_receive(space, name, &amp;port);
                <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
                        <span class="enscript-keyword">return</span> kr;
                <span class="enscript-comment">/* port is locked and active */</span>

                lp-&gt;mpl_qlimit = port-&gt;ip_messages.imq_qlimit;
                *count = MACH_PORT_LIMITS_INFO_COUNT;
                ip_unlock(port);
                <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_RECEIVE_STATUS</span>: {
		mach_port_status_t *statusp = (mach_port_status_t *)info;
		
		<span class="enscript-keyword">if</span> (*count &lt; MACH_PORT_RECEIVE_STATUS_COUNT)
			<span class="enscript-keyword">return</span> KERN_FAILURE;

		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

		kr = ipc_port_translate_receive(space, name, &amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-comment">/* port is locked and active */</span>
		mach_port_get_status_helper(port, statusp);
		*count = MACH_PORT_RECEIVE_STATUS_COUNT;
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_DNREQUESTS_SIZE</span>: {
		ipc_port_request_t	table;
		
                <span class="enscript-keyword">if</span> (*count &lt; MACH_PORT_DNREQUESTS_SIZE_COUNT)
                        <span class="enscript-keyword">return</span> KERN_FAILURE;

		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
			*(<span class="enscript-type">int</span> *)info = 0;
			<span class="enscript-keyword">break</span>;
		}

                kr = ipc_port_translate_receive(space, name, &amp;port);
                <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
                        <span class="enscript-keyword">return</span> kr;
                <span class="enscript-comment">/* port is locked and active */</span>
		
		table = port-&gt;ip_requests;
		<span class="enscript-keyword">if</span> (table == IPR_NULL)
			*(<span class="enscript-type">int</span> *)info = 0;
		<span class="enscript-keyword">else</span>
			*(<span class="enscript-type">int</span> *)info = table-&gt;ipr_size-&gt;its_size;
                *count = MACH_PORT_DNREQUESTS_SIZE_COUNT;
                ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_INFO_EXT</span>: {
		mach_port_info_ext_t *mp_info = (mach_port_info_ext_t *)info;
		<span class="enscript-keyword">if</span> (*count &lt; MACH_PORT_INFO_EXT_COUNT)
			<span class="enscript-keyword">return</span> KERN_FAILURE;
			
		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
		
		kr = ipc_port_translate_receive(space, name, &amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-comment">/* port is locked and active */</span>
		mach_port_get_status_helper(port, &amp;mp_info-&gt;mpie_status);
		mp_info-&gt;mpie_boost_cnt = port-&gt;ip_impcount;
		*count = MACH_PORT_INFO_EXT_COUNT;
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	}

        <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
                <span class="enscript-comment">/*NOTREACHED*/</span>
        }                

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">mach_port_set_attributes</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	<span class="enscript-type">int</span>			flavor,
        mach_port_info_t	info,
        mach_msg_type_number_t	count)
{
	ipc_port_t port;
	kern_return_t kr;
        
	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

        <span class="enscript-keyword">switch</span> (flavor) {
                
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_LIMITS_INFO</span>: {
                mach_port_limits_t *mplp = (mach_port_limits_t *)info;
                
                <span class="enscript-keyword">if</span> (count &lt; MACH_PORT_LIMITS_INFO_COUNT)
                        <span class="enscript-keyword">return</span> KERN_FAILURE;
                
                <span class="enscript-keyword">if</span> (mplp-&gt;mpl_qlimit &gt; MACH_PORT_QLIMIT_MAX)
                        <span class="enscript-keyword">return</span> KERN_INVALID_VALUE;

		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

                kr = ipc_port_translate_receive(space, name, &amp;port);
                <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
                        <span class="enscript-keyword">return</span> kr;
                <span class="enscript-comment">/* port is locked and active */</span>

                ipc_mqueue_set_qlimit(&amp;port-&gt;ip_messages, mplp-&gt;mpl_qlimit);
                ip_unlock(port);
                <span class="enscript-keyword">break</span>;
        }
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_DNREQUESTS_SIZE</span>: {
                <span class="enscript-keyword">if</span> (count &lt; MACH_PORT_DNREQUESTS_SIZE_COUNT)
                        <span class="enscript-keyword">return</span> KERN_FAILURE;

		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
                
                kr = ipc_port_translate_receive(space, name, &amp;port);
                <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
                        <span class="enscript-keyword">return</span> kr;
                <span class="enscript-comment">/* port is locked and active */</span>
		
		kr = ipc_port_request_grow(port, *(<span class="enscript-type">int</span> *)info);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_TEMPOWNER</span>:
		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

		ipc_importance_task_t release_imp_task = IIT_NULL;
		natural_t assertcnt = 0;

		kr = ipc_port_translate_receive(space, name, &amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;
		<span class="enscript-comment">/* port is locked and active */</span>

		<span class="enscript-comment">/* 
		 * don't allow temp-owner importance donation if user
		 * associated it with a kobject already (timer, host_notify target).
		 */</span>
		<span class="enscript-keyword">if</span> (is_ipc_kobject(ip_kotype(port))) {
			ip_unlock(port);
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}

		<span class="enscript-keyword">if</span> (port-&gt;ip_tempowner != 0) {
			<span class="enscript-keyword">if</span> (IIT_NULL != port-&gt;ip_imp_task) {
				release_imp_task = port-&gt;ip_imp_task;
				port-&gt;ip_imp_task = IIT_NULL;
				assertcnt = port-&gt;ip_impcount;
			}
		} <span class="enscript-keyword">else</span> {
			assertcnt = port-&gt;ip_impcount;
		}

		port-&gt;ip_impdonation = 1;
		port-&gt;ip_tempowner = 1;
		ip_unlock(port);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		<span class="enscript-comment">/* drop assertions from previous destination task */</span>
		<span class="enscript-keyword">if</span> (release_imp_task != IIT_NULL) {
			assert(ipc_importance_task_is_any_receiver_type(release_imp_task));
			<span class="enscript-keyword">if</span> (assertcnt &gt; 0)
				ipc_importance_task_drop_internal_assertion(release_imp_task, assertcnt);
			ipc_importance_task_release(release_imp_task);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (assertcnt &gt; 0) {
			release_imp_task = current_task()-&gt;task_imp_base;
			<span class="enscript-keyword">if</span> (release_imp_task != IIT_NULL &amp;&amp;
			    ipc_importance_task_is_any_receiver_type(release_imp_task)) {
				ipc_importance_task_drop_internal_assertion(release_imp_task, assertcnt);
			}
		}
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> (release_imp_task != IIT_NULL)
			ipc_importance_task_release(release_imp_task);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_DENAP_RECEIVER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_PORT_IMPORTANCE_RECEIVER</span>:
		<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
			<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

		kr = ipc_port_translate_receive(space, name, &amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;

		<span class="enscript-comment">/* 
		 * don't allow importance donation if user associated
		 * it with a kobject already (timer, host_notify target).
		 */</span>
		<span class="enscript-keyword">if</span> (is_ipc_kobject(ip_kotype(port))) {
			ip_unlock(port);
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}

		<span class="enscript-comment">/* port is locked and active */</span>
		port-&gt;ip_impdonation = 1;
		ip_unlock(port);

		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

        <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
                <span class="enscript-comment">/*NOTREACHED*/</span>
        }
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_insert_member [kernel call]
 *	Purpose:
 *		Add the receive right, specified by name, to
 *		a portset.
 *		The port cannot already be a member of the set.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Moved the port.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	name didn't denote a right.
 *		KERN_INVALID_RIGHT	name didn't denote a receive right.
 *		KERN_INVALID_NAME	pset_name didn't denote a right.
 *		KERN_INVALID_RIGHT	pset_name didn't denote a portset right.
 *		KERN_ALREADY_IN_SET	name was already a member of pset.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_insert_member</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_name_t	psname)
{
	ipc_object_t obj;
	ipc_object_t psobj;
	kern_return_t kr;
	uint64_t wq_link_id;
	uint64_t wq_reserved_prepost;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name) || !MACH_PORT_VALID(psname))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	wq_link_id = waitq_link_reserve(NULL);
	wq_reserved_prepost = waitq_prepost_reserve(NULL, 10,
						    WAITQ_DONT_LOCK, NULL);

	kr = ipc_object_translate_two(space, 
				      name, MACH_PORT_RIGHT_RECEIVE, &amp;obj,
				      psname, MACH_PORT_RIGHT_PORT_SET, &amp;psobj);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-comment">/* obj and psobj are locked (and were locked in that order) */</span>
	assert(psobj != IO_NULL);
	assert(obj != IO_NULL);

	__IGNORE_WCASTALIGN(kr = ipc_pset_add((ipc_pset_t)psobj, (ipc_port_t)obj,
					    &amp;wq_link_id, &amp;wq_reserved_prepost));

	io_unlock(psobj);
	io_unlock(obj);

 <span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* on success, wq_link_id is reset to 0, so this is always safe */</span>
	waitq_link_release(wq_link_id);
	waitq_prepost_release_reserve(wq_reserved_prepost);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_extract_member [kernel call]
 *	Purpose:
 *		Remove a port from one portset that it is a member of.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Moved the port.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	Member didn't denote a right.
 *		KERN_INVALID_RIGHT	Member didn't denote a receive right.
 *		KERN_INVALID_NAME	After didn't denote a right.
 *		KERN_INVALID_RIGHT	After didn't denote a port set right.
 *		KERN_NOT_IN_SET
 *			After is MACH_PORT_NULL and Member isn't in a port set.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_extract_member</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_name_t	psname)
{
	ipc_object_t psobj;
	ipc_object_t obj;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name) || !MACH_PORT_VALID(psname))
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;

	kr = ipc_object_translate_two(space, 
				      name, MACH_PORT_RIGHT_RECEIVE, &amp;obj,
				      psname, MACH_PORT_RIGHT_PORT_SET, &amp;psobj);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* obj and psobj are both locked (and were locked in that order) */</span>
	assert(psobj != IO_NULL);
	assert(obj != IO_NULL);

	__IGNORE_WCASTALIGN(kr = ipc_pset_remove((ipc_pset_t)psobj, (ipc_port_t)obj));

	io_unlock(psobj);
	io_unlock(obj);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	task_set_port_space:
 *
 *	Set port name space of task to specified size.
 */</span>
kern_return_t
<span class="enscript-function-name">task_set_port_space</span>(
 	ipc_space_t	space,
 	<span class="enscript-type">int</span>		table_entries)
{
	kern_return_t kr;
	
	is_write_lock(space);

	<span class="enscript-keyword">if</span> (!is_active(space)) {
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
	}

	kr = ipc_entry_grow_table(space, table_entries);
	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
		is_write_unlock(space);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_guard_locked [helper routine]
 *	Purpose:
 *		Sets a new guard for a locked port.
 *	Conditions:
 *		Port Locked.
 *	Returns:
 *		KERN_SUCCESS		Port Guarded.
 *		KERN_INVALID_ARGUMENT	Port already contains a context/guard.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">mach_port_guard_locked</span>(
	ipc_port_t		port,
	uint64_t		guard,
	boolean_t		strict)
{
	<span class="enscript-keyword">if</span> (port-&gt;ip_context)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	port-&gt;ip_context = guard;
	port-&gt;ip_guarded = 1;
	port-&gt;ip_strict_guard = (strict)?1:0;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_unguard_locked [helper routine]
 *	Purpose:
 *		Removes guard for a locked port.
 *	Conditions:
 *		Port Locked.
 *	Returns:
 *		KERN_SUCCESS		Port Unguarded.
 *		KERN_INVALID_ARGUMENT	Port is either unguarded already or guard mismatch.
 *					This also raises a EXC_GUARD exception.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">mach_port_unguard_locked</span>(
	ipc_port_t		port,
	mach_port_name_t	name,
	uint64_t		guard)
{
	<span class="enscript-comment">/* Port locked and active */</span>
	<span class="enscript-keyword">if</span> (!port-&gt;ip_guarded) {
		<span class="enscript-comment">/* Port already unguarded; Raise exception */</span>
		mach_port_guard_exception(name, guard, 0, kGUARD_EXC_UNGUARDED);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">if</span> (port-&gt;ip_context != guard) {
		<span class="enscript-comment">/* Incorrect guard; Raise exception */</span>
		mach_port_guard_exception(name, guard, port-&gt;ip_context, kGUARD_EXC_INCORRECT_GUARD);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	port-&gt;ip_context = 0;
	port-&gt;ip_guarded = port-&gt;ip_strict_guard = 0;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	mach_port_guard_exception [helper routine]
 *	Purpose:
 *		Marks the thread with AST_GUARD for mach port guard violation.
 *		Also saves exception info in thread structure.
 *	Conditions:
 *		None.
 *	Returns:
 *		KERN_FAILURE		Thread marked with AST_GUARD.
 */</span>
kern_return_t
<span class="enscript-function-name">mach_port_guard_exception</span>(
	mach_port_name_t	name,
	uint64_t		inguard,
	uint64_t		portguard,
	<span class="enscript-type">unsigned</span>		reason)
{
	thread_t t = current_thread();
	uint64_t code, subcode;

	<span class="enscript-comment">/* Log exception info to syslog */</span>
	printf( <span class="enscript-string">&quot;Mach Port Guard Exception - &quot;</span>
	        <span class="enscript-string">&quot;Thread: 0x%x, &quot;</span>
		<span class="enscript-string">&quot;Port Name: 0x%x, &quot;</span>
		<span class="enscript-string">&quot;Expected Guard: 0x%x, &quot;</span>
		<span class="enscript-string">&quot;Received Guard: 0x%x\n&quot;</span>,
		(<span class="enscript-type">unsigned</span>)t,
		(<span class="enscript-type">unsigned</span>)name,
		(<span class="enscript-type">unsigned</span>)portguard,
		(<span class="enscript-type">unsigned</span>)inguard);

	<span class="enscript-comment">/*
	 * EXC_GUARD namespace for mach ports
	 *
	 *
	 * Mach Port guards use the exception codes like
	 *
	 * code:			
	 * +----------------------------------------------------------------+
	 * |[63:61] GUARD_TYPE_MACH_PORT | [60:32] flavor | [31:0] port name|
	 * +----------------------------------------------------------------+
	 *
	 * subcode:
	 * +----------------------------------------------------------------+
	 * |       [63:0] guard value                                       |
	 * +----------------------------------------------------------------+
	 */</span>

	code =  (((uint64_t)GUARD_TYPE_MACH_PORT) &lt;&lt; 61) |
		(((uint64_t)reason) &lt;&lt; 32) |
		((uint64_t)name);
	subcode = (uint64_t)(portguard);

	t-&gt;guard_exc_info.code = code;
	t-&gt;guard_exc_info.subcode = subcode;
	
	<span class="enscript-comment">/* Mark thread with AST_GUARD */</span>
	thread_guard_violation(t, GUARD_TYPE_MACH_PORT);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}


<span class="enscript-comment">/*
 *	Routine:	mach_port_guard_ast
 *	Purpose:
 *		Raises an exception for mach port guard violation.
 *	Conditions:
 *		None.
 *	Returns:
 *		None.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">mach_port_guard_ast</span>(thread_t t)
{
	<span class="enscript-comment">/* Raise an EXC_GUARD exception */</span>
	task_exception_notify(EXC_GUARD, t-&gt;guard_exc_info.code, t-&gt;guard_exc_info.subcode);

	<span class="enscript-comment">/* Terminate task which caused the exception */</span>
	task_bsdtask_kill(current_task());
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_construct [kernel call]
 *	Purpose:
 *		Constructs a mach port with the provided set of options.
 *	Conditions:
 *		None.
 *	Returns:
 *		KERN_SUCCESS		The right is allocated.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 *		KERN_NO_SPACE		No room in space for another right.
 *		KERN_FAILURE		Illegal option values requested.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_construct</span>(
	ipc_space_t		space,
	mach_port_options_t	*options,
	uint64_t		context,
	mach_port_name_t	*name)
{
	kern_return_t		kr;
	ipc_port_t		port;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_TASK);

	<span class="enscript-comment">/* Allocate a new port in the IPC space */</span>
	kr = ipc_port_alloc(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	
	<span class="enscript-comment">/* Port locked and active */</span>
	<span class="enscript-keyword">if</span> (options-&gt;flags &amp; MPO_CONTEXT_AS_GUARD) {
		kr = mach_port_guard_locked(port, (uint64_t) context, (options-&gt;flags &amp; MPO_STRICT));
		<span class="enscript-comment">/* A newly allocated and locked port should always be guarded successfully */</span>
		assert(kr == KERN_SUCCESS);
	} <span class="enscript-keyword">else</span> {
		port-&gt;ip_context = context;
	}
	
	<span class="enscript-comment">/* Unlock port */</span>
	ip_unlock(port);

	<span class="enscript-comment">/* Set port attributes as requested */</span>

	<span class="enscript-keyword">if</span> (options-&gt;flags &amp; MPO_QLIMIT) {
		kr = mach_port_set_attributes(space, *name, MACH_PORT_LIMITS_INFO,
					      (mach_port_info_t)&amp;options-&gt;mpl, <span class="enscript-keyword">sizeof</span>(options-&gt;mpl)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;	
	}

	<span class="enscript-keyword">if</span> (options-&gt;flags &amp; MPO_TEMPOWNER) {
		kr = mach_port_set_attributes(space, *name, MACH_PORT_TEMPOWNER, NULL, 0);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	<span class="enscript-keyword">if</span> (options-&gt;flags &amp; MPO_IMPORTANCE_RECEIVER) {
		kr = mach_port_set_attributes(space, *name, MACH_PORT_IMPORTANCE_RECEIVER, NULL, 0);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	<span class="enscript-keyword">if</span> (options-&gt;flags &amp; MPO_DENAP_RECEIVER) {
		kr = mach_port_set_attributes(space, *name, MACH_PORT_DENAP_RECEIVER, NULL, 0);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	<span class="enscript-keyword">if</span> (options-&gt;flags &amp; MPO_INSERT_SEND_RIGHT) {
		kr = ipc_object_copyin(space, *name, MACH_MSG_TYPE_MAKE_SEND, (ipc_object_t *)&amp;port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

		kr = mach_port_insert_right(space, *name, port, MACH_MSG_TYPE_PORT_SEND);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;

<span class="enscript-reference">cleanup</span>:
	<span class="enscript-comment">/* Attempt to destroy port. If its already destroyed by some other thread, we're done */</span>
	(<span class="enscript-type">void</span>) mach_port_destruct(space, *name, 0, context);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_destruct [kernel call]
 *	Purpose:
 *		Destroys a mach port with appropriate guard
 *	Conditions:
 *		None.
 *	Returns:
 *		KERN_SUCCESS		The name is destroyed.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	The right isn't correct.
 *		KERN_INVALID_VALUE	The delta for send right is incorrect.
 *		KERN_INVALID_ARGUMENT	Port is either unguarded already or guard mismatch.
 *					This also raises a EXC_GUARD exception.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_port_destruct</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_delta_t	srdelta,
	uint64_t		guard)
{
	kern_return_t		kr;
	ipc_entry_t		entry;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;

	<span class="enscript-comment">/* Remove reference for receive right */</span>
	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked and active */</span>
	kr = ipc_right_destruct(space, name, entry, srdelta, guard);	<span class="enscript-comment">/* unlocks */</span>

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_port_guard [kernel call]
 *	Purpose:
 *		Guard a mach port with specified guard value.
 *		The context field of the port is used as the guard.
 *	Conditions:
 *		None.
 *	Returns:
 *		KERN_SUCCESS		The name is destroyed.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	The right isn't correct.
 *		KERN_INVALID_ARGUMENT	Port already contains a context/guard.
 */</span>
kern_return_t
<span class="enscript-function-name">mach_port_guard</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	uint64_t		guard,
	boolean_t		strict)
{
	kern_return_t		kr;
	ipc_port_t		port;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;

	<span class="enscript-comment">/* Guard can be applied only to receive rights */</span>
	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* Port locked and active */</span>
	kr = mach_port_guard_locked(port, guard, strict);
	ip_unlock(port);

	<span class="enscript-keyword">return</span> kr;

}

<span class="enscript-comment">/*
 *	Routine:	mach_port_unguard [kernel call]
 *	Purpose:
 *		Unguard a mach port with specified guard value.
 *	Conditions:
 *		None.
 *	Returns:
 *		KERN_SUCCESS		The name is destroyed.
 *		KERN_INVALID_TASK	The space is null.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	The right isn't correct.
 *		KERN_INVALID_ARGUMENT	Port is either unguarded already or guard mismatch.
 *					This also raises a EXC_GUARD exception.
 */</span>
kern_return_t
<span class="enscript-function-name">mach_port_unguard</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	uint64_t		guard)
{
	
	kern_return_t		kr;
	ipc_port_t		port;

	<span class="enscript-keyword">if</span> (space == IS_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name))
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;

	kr = ipc_port_translate_receive(space, name, &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* Port locked and active */</span>
	kr = mach_port_unguard_locked(port, name, guard);
	ip_unlock(port);
	<span class="enscript-keyword">return</span> kr;
}

</pre>
<hr />
</body></html>