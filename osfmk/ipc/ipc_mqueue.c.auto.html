<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_mqueue.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_mqueue.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	ipc/ipc_mqueue.c
 *	Author:	Rich Draves
 *	Date:	1989
 *
 *	Functions to manipulate IPC message queues.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2006 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
    

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_mig.h&gt;</span>	<span class="enscript-comment">/* XXX - for mach_msg_receive_continue */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_mqueue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_kmsg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_pset.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> ipc_mqueue_full;		<span class="enscript-comment">/* address is event for queue space */</span>
<span class="enscript-type">int</span> ipc_mqueue_rcv;		<span class="enscript-comment">/* address is event for message arrival */</span>

<span class="enscript-comment">/* forward declarations */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">ipc_mqueue_receive_results</span>(wait_result_t result);

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_init
 *	Purpose:
 *		Initialize a newly-allocated message queue.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_init</span>(
	ipc_mqueue_t	mqueue,
	boolean_t	is_set,
	uint64_t	*reserved_link)
{
	<span class="enscript-keyword">if</span> (is_set) {
		waitq_set_init(&amp;mqueue-&gt;imq_set_queue,
			       SYNC_POLICY_FIFO|SYNC_POLICY_PREPOST|SYNC_POLICY_DISABLE_IRQ,
			       reserved_link);
	} <span class="enscript-keyword">else</span> {
		waitq_init(&amp;mqueue-&gt;imq_wait_queue, SYNC_POLICY_FIFO|SYNC_POLICY_DISABLE_IRQ);
		ipc_kmsg_queue_init(&amp;mqueue-&gt;imq_messages);
		mqueue-&gt;imq_seqno = 0;
		mqueue-&gt;imq_msgcount = 0;
		mqueue-&gt;imq_qlimit = MACH_PORT_QLIMIT_DEFAULT;
		mqueue-&gt;imq_fullwaiters = FALSE;
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ipc_mqueue_deinit</span>(
	ipc_mqueue_t		mqueue)
{
	boolean_t is_set = imq_is_set(mqueue);

	<span class="enscript-keyword">if</span> (is_set)
		waitq_set_deinit(&amp;mqueue-&gt;imq_set_queue);
	<span class="enscript-keyword">else</span>
		waitq_deinit(&amp;mqueue-&gt;imq_wait_queue);
}

<span class="enscript-comment">/*
 *	Routine:	imq_reserve_and_lock
 *	Purpose:
 *		Atomically lock an ipc_mqueue_t object and reserve
 *		an appropriate number of prepost linkage objects for
 *		use in wakeup operations.
 *	Conditions:
 *		mq is unlocked
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">imq_reserve_and_lock</span>(ipc_mqueue_t mq, uint64_t *reserved_prepost, spl_t *spl)
{
	*reserved_prepost = waitq_prepost_reserve(&amp;mq-&gt;imq_wait_queue, 0,
						  WAITQ_KEEP_LOCKED, spl);

}


<span class="enscript-comment">/*
 *	Routine:	imq_release_and_unlock
 *	Purpose:
 *		Unlock an ipc_mqueue_t object, re-enable interrupts,
 *		and release any unused prepost object reservations.
 *	Conditions:
 *		mq is locked
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">imq_release_and_unlock</span>(ipc_mqueue_t mq, uint64_t reserved_prepost, spl_t spl)
{
	assert(imq_held(mq));
	waitq_unlock(&amp;mq-&gt;imq_wait_queue);
	splx(spl);
	waitq_prepost_release_reserve(reserved_prepost);
}


<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_member
 *	Purpose:
 *		Indicate whether the (port) mqueue is a member of
 *		this portset's mqueue.  We do this by checking
 *		whether the portset mqueue's waitq is an member of
 *		the port's mqueue waitq.
 *	Conditions:
 *		the portset's mqueue is not already a member
 *		this may block while allocating linkage structures.
 */</span>

boolean_t
<span class="enscript-function-name">ipc_mqueue_member</span>(
	ipc_mqueue_t		port_mqueue,
	ipc_mqueue_t		set_mqueue)
{
	<span class="enscript-type">struct</span> waitq *port_waitq = &amp;port_mqueue-&gt;imq_wait_queue;
	<span class="enscript-type">struct</span> waitq_set *set_waitq = &amp;set_mqueue-&gt;imq_set_queue;

	<span class="enscript-keyword">return</span> waitq_member(port_waitq, set_waitq);

}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_remove
 *	Purpose:
 *		Remove the association between the queue and the specified
 *		set message queue.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_mqueue_remove</span>(
	ipc_mqueue_t	  mqueue,
	ipc_mqueue_t	  set_mqueue)
{
	<span class="enscript-type">struct</span> waitq *mq_waitq = &amp;mqueue-&gt;imq_wait_queue;
	<span class="enscript-type">struct</span> waitq_set *set_waitq = &amp;set_mqueue-&gt;imq_set_queue;

	<span class="enscript-keyword">return</span> waitq_unlink(mq_waitq, set_waitq);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_remove_from_all
 *	Purpose:
 *		Remove the mqueue from all the sets it is a member of
 *	Conditions:
 *		Nothing locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_remove_from_all</span>(ipc_mqueue_t	mqueue)
{
	<span class="enscript-type">struct</span> waitq *mq_waitq = &amp;mqueue-&gt;imq_wait_queue;

	waitq_unlink_all(mq_waitq);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_remove_all
 *	Purpose:
 *		Remove all the member queues from the specified set.
 *		Also removes the queue from any containing sets.
 *	Conditions:
 *		Nothing locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_remove_all</span>(ipc_mqueue_t	mqueue)
{
	<span class="enscript-type">struct</span> waitq_set *mq_setq = &amp;mqueue-&gt;imq_set_queue;
	waitq_set_unlink_all(mq_setq);
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_add
 *	Purpose:
 *		Associate the portset's mqueue with the port's mqueue.
 *		This has to be done so that posting the port will wakeup
 *		a portset waiter.  If there are waiters on the portset
 *		mqueue and messages on the port mqueue, try to match them
 *		up now.
 *	Conditions:
 *		May block.
 */</span>
kern_return_t
<span class="enscript-function-name">ipc_mqueue_add</span>(
	ipc_mqueue_t	port_mqueue,
	ipc_mqueue_t	set_mqueue,
	uint64_t	*reserved_link,
	uint64_t	*reserved_prepost)
{
	<span class="enscript-type">struct</span> waitq     *port_waitq = &amp;port_mqueue-&gt;imq_wait_queue;
	<span class="enscript-type">struct</span> waitq_set *set_waitq = &amp;set_mqueue-&gt;imq_set_queue;
	ipc_kmsg_queue_t kmsgq;
	ipc_kmsg_t       kmsg, next;
	kern_return_t	 kr;
	spl_t		 s;

	assert(reserved_link &amp;&amp; *reserved_link != 0);

	s = splsched();
	imq_lock(port_mqueue);

	<span class="enscript-comment">/*
	 * The link operation is now under the same lock-hold as
	 * message iteration and thread wakeup, but doesn't have to be...
	 */</span>
	kr = waitq_link(port_waitq, set_waitq, WAITQ_ALREADY_LOCKED, reserved_link);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		imq_unlock(port_mqueue);
		splx(s);
		<span class="enscript-keyword">return</span> kr;
	}

	<span class="enscript-comment">/*
	 * Now that the set has been added to the port, there may be
	 * messages queued on the port and threads waiting on the set
	 * waitq.  Lets get them together.
	 */</span>
	kmsgq = &amp;port_mqueue-&gt;imq_messages;
	<span class="enscript-keyword">for</span> (kmsg = ipc_kmsg_queue_first(kmsgq);
	     kmsg != IKM_NULL;
	     kmsg = next) {
		next = ipc_kmsg_queue_next(kmsgq, kmsg);

		<span class="enscript-keyword">for</span> (;;) {
			thread_t th;
			mach_msg_size_t msize;
			spl_t th_spl;

			th = waitq_wakeup64_identity_locked(
						port_waitq,
						IPC_MQUEUE_RECEIVE,
						THREAD_AWAKENED, &amp;th_spl,
						reserved_prepost, WAITQ_KEEP_LOCKED);
			<span class="enscript-comment">/* waitq/mqueue still locked, thread locked */</span>

			<span class="enscript-keyword">if</span> (th == THREAD_NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">leave</span>;

			<span class="enscript-comment">/*
			 * If the receiver waited with a facility not directly
			 * related to Mach messaging, then it isn't prepared to get
			 * handed the message directly.  Just set it running, and
			 * go look for another thread that can.
			 */</span>
			<span class="enscript-keyword">if</span> (th-&gt;ith_state != MACH_RCV_IN_PROGRESS) {
				  thread_unlock(th);
				  splx(th_spl);
				  <span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * Found a receiver. see if they can handle the message
			 * correctly (the message is not too large for them, or
			 * they didn't care to be informed that the message was
			 * too large).  If they can't handle it, take them off
			 * the list and let them go back and figure it out and
			 * just move onto the next.
			 */</span>
			msize = ipc_kmsg_copyout_size(kmsg, th-&gt;map);
			<span class="enscript-keyword">if</span> (th-&gt;ith_msize &lt;
					(msize + REQUESTED_TRAILER_SIZE(thread_is_64bit(th), th-&gt;ith_option))) {
				th-&gt;ith_state = MACH_RCV_TOO_LARGE;
				th-&gt;ith_msize = msize;
				<span class="enscript-keyword">if</span> (th-&gt;ith_option &amp; MACH_RCV_LARGE) {
					<span class="enscript-comment">/*
					 * let him go without message
					 */</span>
					th-&gt;ith_receiver_name = port_mqueue-&gt;imq_receiver_name;
					th-&gt;ith_kmsg = IKM_NULL;
					th-&gt;ith_seqno = 0;
					thread_unlock(th);
					splx(th_spl);
					<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* find another thread */</span>
				}
			} <span class="enscript-keyword">else</span> {
				th-&gt;ith_state = MACH_MSG_SUCCESS;
			}

			<span class="enscript-comment">/*
			 * This thread is going to take this message,
			 * so give it to him.
			 */</span>
			ipc_kmsg_rmqueue(kmsgq, kmsg);
			ipc_mqueue_release_msgcount(port_mqueue, IMQ_NULL);

			th-&gt;ith_kmsg = kmsg;
			th-&gt;ith_seqno = port_mqueue-&gt;imq_seqno++;
			thread_unlock(th);
			splx(th_spl);
			<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* go to next message */</span>
		}
	}
 <span class="enscript-reference">leave</span>:
	imq_unlock(port_mqueue);
	splx(s);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_changed
 *	Purpose:
 *		Wake up receivers waiting in a message queue.
 *	Conditions:
 *		The message queue is locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_changed</span>(
	ipc_mqueue_t		mqueue)
{
	waitq_wakeup64_all_locked(&amp;mqueue-&gt;imq_wait_queue,
				  IPC_MQUEUE_RECEIVE,
				  THREAD_RESTART,
				  NULL,
				  WAITQ_ALL_PRIORITIES,
				  WAITQ_KEEP_LOCKED);
}


		

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_send
 *	Purpose:
 *		Send a message to a message queue.  The message holds a reference
 *		for the destination port for this message queue in the 
 *		msgh_remote_port field.
 *
 *		If unsuccessful, the caller still has possession of
 *		the message and must do something with it.  If successful,
 *		the message is queued, given to a receiver, or destroyed.
 *	Conditions:
 *		mqueue is locked.
 *	Returns:
 *		MACH_MSG_SUCCESS	The message was accepted.
 *		MACH_SEND_TIMED_OUT	Caller still has message.
 *		MACH_SEND_INTERRUPTED	Caller still has message.
 */</span>
mach_msg_return_t
<span class="enscript-function-name">ipc_mqueue_send</span>(
	ipc_mqueue_t		mqueue,
	ipc_kmsg_t		kmsg,
	mach_msg_option_t	option,
	mach_msg_timeout_t	send_timeout,
	spl_t			s)
{
	<span class="enscript-type">int</span> wresult;

	<span class="enscript-comment">/*
	 *  Don't block if:
	 *	1) We're under the queue limit.
	 *	2) Caller used the MACH_SEND_ALWAYS internal option.
	 *	3) Message is sent to a send-once right.
	 */</span>
	<span class="enscript-keyword">if</span> (!imq_full(mqueue) ||
	    (!imq_full_kernel(mqueue) &amp;&amp; 
	     ((option &amp; MACH_SEND_ALWAYS) ||
	      (MACH_MSGH_BITS_REMOTE(kmsg-&gt;ikm_header-&gt;msgh_bits) ==
	       MACH_MSG_TYPE_PORT_SEND_ONCE)))) {
		mqueue-&gt;imq_msgcount++;
		assert(mqueue-&gt;imq_msgcount &gt; 0);
		imq_unlock(mqueue);
		splx(s);
	} <span class="enscript-keyword">else</span> {
		thread_t cur_thread = current_thread();
		uint64_t deadline;

		<span class="enscript-comment">/* 
		 * We have to wait for space to be granted to us.
		 */</span>
		<span class="enscript-keyword">if</span> ((option &amp; MACH_SEND_TIMEOUT) &amp;&amp; (send_timeout == 0)) {
			imq_unlock(mqueue);
			splx(s);
			<span class="enscript-keyword">return</span> MACH_SEND_TIMED_OUT;
		}
		<span class="enscript-keyword">if</span> (imq_full_kernel(mqueue)) {
			imq_unlock(mqueue);
			splx(s);
			<span class="enscript-keyword">return</span> MACH_SEND_NO_BUFFER;
		}
		mqueue-&gt;imq_fullwaiters = TRUE;
		thread_lock(cur_thread);
		<span class="enscript-keyword">if</span> (option &amp; MACH_SEND_TIMEOUT)
			clock_interval_to_deadline(send_timeout, 1000*NSEC_PER_USEC, &amp;deadline);
		<span class="enscript-keyword">else</span>
			deadline = 0;
		wresult = waitq_assert_wait64_locked(
						&amp;mqueue-&gt;imq_wait_queue,
						IPC_MQUEUE_FULL,
						THREAD_ABORTSAFE,
						TIMEOUT_URGENCY_USER_NORMAL,
						deadline, TIMEOUT_NO_LEEWAY,
						cur_thread);
		thread_unlock(cur_thread);
		imq_unlock(mqueue);
		splx(s);
		
		<span class="enscript-keyword">if</span> (wresult == THREAD_WAITING) {
			wresult = thread_block(THREAD_CONTINUE_NULL);
			counter(c_ipc_mqueue_send_block++);
		}
		
		<span class="enscript-keyword">switch</span> (wresult) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_AWAKENED</span>:
			<span class="enscript-comment">/* 
			 * we can proceed - inherited msgcount from waker
			 * or the message queue has been destroyed and the msgcount
			 * has been reset to zero (will detect in ipc_mqueue_post()).
			 */</span>
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_TIMED_OUT</span>:
			assert(option &amp; MACH_SEND_TIMEOUT);
			<span class="enscript-keyword">return</span> MACH_SEND_TIMED_OUT;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_INTERRUPTED</span>:
			<span class="enscript-keyword">return</span> MACH_SEND_INTERRUPTED;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_RESTART</span>:
			<span class="enscript-comment">/* mqueue is being destroyed */</span>
			<span class="enscript-keyword">return</span> MACH_SEND_INVALID_DEST;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;ipc_mqueue_send&quot;</span>);
		}
	}

	ipc_mqueue_post(mqueue, kmsg);
	<span class="enscript-keyword">return</span> MACH_MSG_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_release_msgcount
 *	Purpose:
 *		Release a message queue reference in the case where we
 *		found a waiter.
 *
 *	Conditions:
 *		The message queue is locked.
 *		The message corresponding to this reference is off the queue.
 *		There is no need to pass reserved preposts because this will
 *		never prepost to anyone
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_release_msgcount</span>(ipc_mqueue_t port_mq, ipc_mqueue_t set_mq)
{
	(<span class="enscript-type">void</span>)set_mq;
	assert(imq_held(port_mq));
	assert(port_mq-&gt;imq_msgcount &gt; 1 || ipc_kmsg_queue_empty(&amp;port_mq-&gt;imq_messages));

	port_mq-&gt;imq_msgcount--;

	<span class="enscript-keyword">if</span> (!imq_full(port_mq) &amp;&amp; port_mq-&gt;imq_fullwaiters) {
		<span class="enscript-comment">/*
		 * boost the priority of the awoken thread
		 * (WAITQ_PROMOTE_PRIORITY) to ensure it uses
		 * the message queue slot we've just reserved.
		 *
		 * NOTE: this will never prepost
		 */</span>
		<span class="enscript-keyword">if</span> (waitq_wakeup64_one_locked(&amp;port_mq-&gt;imq_wait_queue,
					      IPC_MQUEUE_FULL,
					      THREAD_AWAKENED,
					      NULL,
					      WAITQ_PROMOTE_PRIORITY,
					      WAITQ_KEEP_LOCKED) != KERN_SUCCESS) {
			port_mq-&gt;imq_fullwaiters = FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* gave away our slot - add reference back */</span>
			port_mq-&gt;imq_msgcount++;
		}
	}

	<span class="enscript-keyword">if</span> (ipc_kmsg_queue_empty(&amp;port_mq-&gt;imq_messages)) {
		<span class="enscript-comment">/* no more msgs: invalidate the port's prepost object */</span>
		waitq_clear_prepost_locked(&amp;port_mq-&gt;imq_wait_queue, NULL);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_post
 *	Purpose:
 *		Post a message to a waiting receiver or enqueue it.  If a
 *		receiver is waiting, we can release our reserved space in
 *		the message queue.
 *
 *	Conditions:
 *		mqueue is unlocked
 *		If we need to queue, our space in the message queue is reserved.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_post</span>(
	<span class="enscript-type">register</span> ipc_mqueue_t 	mqueue,
	<span class="enscript-type">register</span> ipc_kmsg_t		kmsg)
{
	spl_t s;
	uint64_t reserved_prepost = 0;

	<span class="enscript-comment">/*
	 *	While the msg queue	is locked, we have control of the
	 *  kmsg, so the ref in	it for the port is still good.
	 *
	 *	Check for a receiver for the message.
	 */</span>
	imq_reserve_and_lock(mqueue, &amp;reserved_prepost, &amp;s);
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">struct</span> waitq *waitq = &amp;mqueue-&gt;imq_wait_queue;
		spl_t th_spl;
		thread_t receiver;
		mach_msg_size_t msize;

		receiver = waitq_wakeup64_identity_locked(waitq,
							  IPC_MQUEUE_RECEIVE,
							  THREAD_AWAKENED,
							  &amp;th_spl,
							  &amp;reserved_prepost,
							  WAITQ_KEEP_LOCKED);
		<span class="enscript-comment">/* waitq still locked, thread locked */</span>

		<span class="enscript-keyword">if</span> (receiver == THREAD_NULL) {
			
			<span class="enscript-comment">/* 
			 * no receivers; queue kmsg if space still reserved.
			 */</span>
			<span class="enscript-keyword">if</span> (mqueue-&gt;imq_msgcount &gt; 0) {
				ipc_kmsg_enqueue_macro(&amp;mqueue-&gt;imq_messages, kmsg);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * Otherwise, the message queue must belong to an inactive
			 * port, so just destroy the message and pretend it was posted.
			 */</span>
			<span class="enscript-comment">/* clear the waitq boost we may have been given */</span>
			waitq_clear_promotion_locked(waitq, current_thread());
			imq_release_and_unlock(mqueue, reserved_prepost, s);
			ipc_kmsg_destroy(kmsg);
			current_task()-&gt;messages_sent++;
			<span class="enscript-keyword">return</span>;
		}
	
		<span class="enscript-comment">/*
		 * If the receiver waited with a facility not directly
		 * related to Mach messaging, then it isn't prepared to get
		 * handed the message directly.  Just set it running, and
		 * go look for another thread that can.
		 */</span>
		<span class="enscript-keyword">if</span> (receiver-&gt;ith_state != MACH_RCV_IN_PROGRESS) {
				  thread_unlock(receiver);
				  splx(th_spl);
				  <span class="enscript-keyword">continue</span>;
		}

	
		<span class="enscript-comment">/*
		 * We found a waiting thread.
		 * If the message is too large or the scatter list is too small
		 * the thread we wake up will get that as its status.
		 */</span>
		msize =	ipc_kmsg_copyout_size(kmsg, receiver-&gt;map);
		<span class="enscript-keyword">if</span> (receiver-&gt;ith_msize &lt;
				(msize + REQUESTED_TRAILER_SIZE(thread_is_64bit(receiver), receiver-&gt;ith_option))) {
			receiver-&gt;ith_msize = msize;
			receiver-&gt;ith_state = MACH_RCV_TOO_LARGE;
		} <span class="enscript-keyword">else</span> {
			receiver-&gt;ith_state = MACH_MSG_SUCCESS;
		}

		<span class="enscript-comment">/*
		 * If there is no problem with the upcoming receive, or the
		 * receiver thread didn't specifically ask for special too
		 * large error condition, go ahead and select it anyway.
		 */</span>
		<span class="enscript-keyword">if</span> ((receiver-&gt;ith_state == MACH_MSG_SUCCESS) ||
		    !(receiver-&gt;ith_option &amp; MACH_RCV_LARGE)) {

			receiver-&gt;ith_kmsg = kmsg;
			receiver-&gt;ith_seqno = mqueue-&gt;imq_seqno++;
			thread_unlock(receiver);
			splx(th_spl);

			<span class="enscript-comment">/* we didn't need our reserved spot in the queue */</span>
			ipc_mqueue_release_msgcount(mqueue, IMQ_NULL);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * Otherwise, this thread needs to be released to run
		 * and handle its error without getting the message.  We
		 * need to go back and pick another one.
		 */</span>
		receiver-&gt;ith_receiver_name = mqueue-&gt;imq_receiver_name;
		receiver-&gt;ith_kmsg = IKM_NULL;
		receiver-&gt;ith_seqno = 0;
		thread_unlock(receiver);
		splx(th_spl);
	}

	<span class="enscript-comment">/* clear the waitq boost we may have been given */</span>
	waitq_clear_promotion_locked(&amp;mqueue-&gt;imq_wait_queue, current_thread());
	imq_release_and_unlock(mqueue, reserved_prepost, s);
	
	current_task()-&gt;messages_sent++;
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/* static */</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_receive_results</span>(wait_result_t saved_wait_result)
{
	thread_t     		self = current_thread();
	mach_msg_option_t	option = self-&gt;ith_option;

	<span class="enscript-comment">/*
	 * why did we wake up?
	 */</span>
	<span class="enscript-keyword">switch</span> (saved_wait_result) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_TIMED_OUT</span>:
		self-&gt;ith_state = MACH_RCV_TIMED_OUT;
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_INTERRUPTED</span>:
		self-&gt;ith_state = MACH_RCV_INTERRUPTED;
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_RESTART</span>:
		<span class="enscript-comment">/* something bad happened to the port/set */</span>
		self-&gt;ith_state = MACH_RCV_PORT_CHANGED;
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_AWAKENED</span>:
		<span class="enscript-comment">/*
		 * We do not need to go select a message, somebody
		 * handed us one (or a too-large indication).
		 */</span>
		<span class="enscript-keyword">switch</span> (self-&gt;ith_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_RCV_SCATTER_SMALL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_RCV_TOO_LARGE</span>:
			<span class="enscript-comment">/*
			 * Somebody tried to give us a too large
			 * message. If we indicated that we cared,
			 * then they only gave us the indication,
			 * otherwise they gave us the indication
			 * AND the message anyway.
			 */</span>
			<span class="enscript-keyword">if</span> (option &amp; MACH_RCV_LARGE) {
				<span class="enscript-keyword">return</span>;
			}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_SUCCESS</span>:
			<span class="enscript-keyword">return</span>;

		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;ipc_mqueue_receive_results: strange ith_state&quot;</span>);
		}

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_mqueue_receive_results: strange wait_result&quot;</span>);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_receive_continue</span>(
	__unused <span class="enscript-type">void</span> *param,
	wait_result_t wresult)
{
	ipc_mqueue_receive_results(wresult);
	mach_msg_receive_continue();  <span class="enscript-comment">/* hard-coded for now */</span>
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_receive
 *	Purpose:
 *		Receive a message from a message queue.
 *
 *		If continuation is non-zero, then we might discard
 *		our kernel stack when we block.  We will continue
 *		after unblocking by executing continuation.
 *
 *		If resume is true, then we are resuming a receive
 *		operation after a blocked receive discarded our stack.
 *	Conditions:
 *		Our caller must hold a reference for the port or port set
 *		to which this queue belongs, to keep the queue
 *		from being deallocated.
 *
 *		The kmsg is returned with clean header fields
 *		and with the circular bit turned off.
 *	Returns:
 *		MACH_MSG_SUCCESS	Message returned in kmsgp.
 *		MACH_RCV_TOO_LARGE	Message size returned in kmsgp.
 *		MACH_RCV_TIMED_OUT	No message obtained.
 *		MACH_RCV_INTERRUPTED	No message obtained.
 *		MACH_RCV_PORT_DIED	Port/set died; no message.
 *		MACH_RCV_PORT_CHANGED	Port moved into set; no msg.
 *
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_receive</span>(
	ipc_mqueue_t            mqueue,
	mach_msg_option_t       option,
	mach_msg_size_t         max_size,
	mach_msg_timeout_t      rcv_timeout,
	<span class="enscript-type">int</span>                     interruptible)
{
	wait_result_t           wresult;
        thread_t                self = current_thread();
        
        wresult = ipc_mqueue_receive_on_thread(mqueue, option, max_size,
                                               rcv_timeout, interruptible,
                                               self);
        <span class="enscript-keyword">if</span> (wresult == THREAD_NOT_WAITING)
                <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (wresult == THREAD_WAITING) {
		counter((interruptible == THREAD_ABORTSAFE) ? 
			c_ipc_mqueue_receive_block_user++ :
			c_ipc_mqueue_receive_block_kernel++);

		<span class="enscript-keyword">if</span> (self-&gt;ith_continuation)
			thread_block(ipc_mqueue_receive_continue);
			<span class="enscript-comment">/* NOTREACHED */</span>

		wresult = thread_block(THREAD_CONTINUE_NULL);
	}
	ipc_mqueue_receive_results(wresult);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mqueue_process_prepost_receive</span>(<span class="enscript-type">void</span> *ctx, <span class="enscript-type">struct</span> waitq *waitq,
					  <span class="enscript-type">struct</span> waitq_set *wqset)
{
	ipc_mqueue_t     port_mq, *pmq_ptr;

	(<span class="enscript-type">void</span>)wqset;
	port_mq = (ipc_mqueue_t)waitq;

	<span class="enscript-comment">/*
	 * If there are no messages on this queue, skip it and remove
	 * it from the prepost list
	 */</span>
	<span class="enscript-keyword">if</span> (ipc_kmsg_queue_empty(&amp;port_mq-&gt;imq_messages))
		<span class="enscript-keyword">return</span> WQ_ITERATE_INVALIDATE_CONTINUE;

	<span class="enscript-comment">/*
	 * There are messages waiting on this port.
	 * Instruct the prepost iteration logic to break, but keep the
	 * waitq locked.
	 */</span>
	pmq_ptr = (ipc_mqueue_t *)ctx;
	<span class="enscript-keyword">if</span> (pmq_ptr)
		*pmq_ptr = port_mq;
	<span class="enscript-keyword">return</span> WQ_ITERATE_BREAK_KEEP_LOCKED;
}

wait_result_t
<span class="enscript-function-name">ipc_mqueue_receive_on_thread</span>(
        ipc_mqueue_t            mqueue,
	mach_msg_option_t       option,
	mach_msg_size_t         max_size,
	mach_msg_timeout_t      rcv_timeout,
	<span class="enscript-type">int</span>                     interruptible,
	thread_t                thread)
{
	wait_result_t           wresult;
	uint64_t		deadline;
	spl_t                   s;

	s = splsched();
	imq_lock(mqueue);
	<span class="enscript-comment">/* no need to reserve anything: we never prepost to anyone */</span>
	
	<span class="enscript-keyword">if</span> (imq_is_set(mqueue)) {
		ipc_mqueue_t port_mq = IMQ_NULL;
		spl_t set_spl;

		(<span class="enscript-type">void</span>)waitq_set_iterate_preposts(&amp;mqueue-&gt;imq_set_queue,
						 &amp;port_mq,
						 mqueue_process_prepost_receive,
						 &amp;set_spl);

		<span class="enscript-keyword">if</span> (port_mq != IMQ_NULL) {
			<span class="enscript-comment">/*
			 * We get here if there is at least one message
			 * waiting on port_mq. We have instructed the prepost
			 * iteration logic to leave both the port_mq and the
			 * set mqueue locked.
			 *
			 * TODO: previously, we would place this port at the
			 *       back of the prepost list...
			 */</span>
			imq_unlock(mqueue);

			<span class="enscript-comment">/* TODO: if/when port mqueues become non irq safe,
			 *       we won't need this spl, and we should be
			 *       able to call splx(s) (if that's even
			 *       necessary).
			 * For now, we've still disabled interrupts via
			 * imq_reserve_and_lock();
			 */</span>
			splx(set_spl);

			<span class="enscript-comment">/*
			 * Continue on to handling the message with just
			 * the port mqueue locked.
			 */</span>
			ipc_mqueue_select_on_thread(port_mq, mqueue, option,
						    max_size, thread);

			imq_unlock(port_mq);
			splx(s);
			<span class="enscript-keyword">return</span> THREAD_NOT_WAITING;
		}
	} <span class="enscript-keyword">else</span> {
		ipc_kmsg_queue_t kmsgs;

		<span class="enscript-comment">/*
		 * Receive on a single port. Just try to get the messages.
		 */</span>
	  	kmsgs = &amp;mqueue-&gt;imq_messages;
		<span class="enscript-keyword">if</span> (ipc_kmsg_queue_first(kmsgs) != IKM_NULL) {
			ipc_mqueue_select_on_thread(mqueue, IMQ_NULL, option,
						    max_size, thread);
			imq_unlock(mqueue);
			splx(s);
			<span class="enscript-keyword">return</span> THREAD_NOT_WAITING;
		}
	}
	
	<span class="enscript-comment">/*
	 * Looks like we'll have to block.  The mqueue we will
	 * block on (whether the set's or the local port's) is
	 * still locked.
	 */</span>
	<span class="enscript-keyword">if</span> (option &amp; MACH_RCV_TIMEOUT) {
		<span class="enscript-keyword">if</span> (rcv_timeout == 0) {
			imq_unlock(mqueue);
			splx(s);
			thread-&gt;ith_state = MACH_RCV_TIMED_OUT;
			<span class="enscript-keyword">return</span> THREAD_NOT_WAITING;
		}
	}

	<span class="enscript-comment">/* NOTE: need splsched() here if mqueue no longer needs irq disabled */</span>
	thread_lock(thread);
	thread-&gt;ith_state = MACH_RCV_IN_PROGRESS;
	thread-&gt;ith_option = option;
	thread-&gt;ith_msize = max_size;

	<span class="enscript-keyword">if</span> (option &amp; MACH_RCV_TIMEOUT)
		clock_interval_to_deadline(rcv_timeout, 1000*NSEC_PER_USEC, &amp;deadline);
	<span class="enscript-keyword">else</span>
		deadline = 0;

	wresult = waitq_assert_wait64_locked(&amp;mqueue-&gt;imq_wait_queue,
					     IPC_MQUEUE_RECEIVE,
					     interruptible,
					     TIMEOUT_URGENCY_USER_NORMAL,
					     deadline,
					     TIMEOUT_NO_LEEWAY,
					     thread);
	<span class="enscript-comment">/* preposts should be detected above, not here */</span>
	<span class="enscript-keyword">if</span> (wresult == THREAD_AWAKENED)
		panic(<span class="enscript-string">&quot;ipc_mqueue_receive_on_thread: sleep walking&quot;</span>);

	thread_unlock(thread);
	imq_unlock(mqueue);
	splx(s);
	<span class="enscript-keyword">return</span> wresult;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_select_on_thread
 *	Purpose:
 *		A receiver discovered that there was a message on the queue
 *		before he had to block.  Pick the message off the queue and
 *		&quot;post&quot; it to thread.
 *	Conditions:
 *		mqueue locked.
 *              thread not locked.
 *		There is a message.
 *		No need to reserve prepost objects - it will never prepost
 *
 *	Returns:
 *		MACH_MSG_SUCCESS	Actually selected a message for ourselves.
 *		MACH_RCV_TOO_LARGE  May or may not have pull it, but it is large
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_select_on_thread</span>(
	ipc_mqueue_t		port_mq,
	ipc_mqueue_t		set_mq,
	mach_msg_option_t	option,
	mach_msg_size_t		max_size,
	thread_t                thread)
{
	ipc_kmsg_t kmsg;
	mach_msg_return_t mr = MACH_MSG_SUCCESS;
	mach_msg_size_t rcv_size;

	<span class="enscript-comment">/*
	 * Do some sanity checking of our ability to receive
	 * before pulling the message off the queue.
	 */</span>
	kmsg = ipc_kmsg_queue_first(&amp;port_mq-&gt;imq_messages);
	assert(kmsg != IKM_NULL);

	<span class="enscript-comment">/*
	 * If we really can't receive it, but we had the
	 * MACH_RCV_LARGE option set, then don't take it off
	 * the queue, instead return the appropriate error
	 * (and size needed).
	 */</span>
	rcv_size = ipc_kmsg_copyout_size(kmsg, thread-&gt;map);
	<span class="enscript-keyword">if</span> (rcv_size + REQUESTED_TRAILER_SIZE(thread_is_64bit(thread), option) &gt; max_size) {
		mr = MACH_RCV_TOO_LARGE;
		<span class="enscript-keyword">if</span> (option &amp; MACH_RCV_LARGE) {
			thread-&gt;ith_receiver_name = port_mq-&gt;imq_receiver_name;
			thread-&gt;ith_kmsg = IKM_NULL;
			thread-&gt;ith_msize = rcv_size;
			thread-&gt;ith_seqno = 0;
			thread-&gt;ith_state = mr;
			<span class="enscript-keyword">return</span>;
		}
	}

	ipc_kmsg_rmqueue_first_macro(&amp;port_mq-&gt;imq_messages, kmsg);
	ipc_mqueue_release_msgcount(port_mq, set_mq);
	thread-&gt;ith_seqno = port_mq-&gt;imq_seqno++;
	thread-&gt;ith_kmsg = kmsg;
	thread-&gt;ith_state = mr;

	current_task()-&gt;messages_received++;
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_peek
 *	Purpose:
 *		Peek at a (non-set) message queue to see if it has a message
 *		matching the sequence number provided (if zero, then the
 *		first message in the queue) and return vital info about the
 *		message.
 *
 *	Conditions:
 *		Locks may be held by callers, so this routine cannot block.
 *		Caller holds reference on the message queue.
 */</span>
<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">ipc_mqueue_peek</span>(ipc_mqueue_t mq,
                mach_port_seqno_t * seqnop,
                mach_msg_size_t * msg_sizep,
                mach_msg_id_t * msg_idp,
                mach_msg_max_trailer_t * msg_trailerp)
{
	ipc_kmsg_queue_t kmsgq;
	ipc_kmsg_t kmsg;
	mach_port_seqno_t seqno, msgoff;
	<span class="enscript-type">int</span> res = 0;
	spl_t s;

	assert(!imq_is_set(mq));

	s = splsched();
	imq_lock(mq);

	seqno = 0;
	<span class="enscript-keyword">if</span> (seqnop != NULL)
		seqno = *seqnop;

	<span class="enscript-keyword">if</span> (seqno == 0) {
		seqno = mq-&gt;imq_seqno;
		msgoff = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (seqno &gt;= mq-&gt;imq_seqno &amp;&amp; 
		   seqno &lt; mq-&gt;imq_seqno + mq-&gt;imq_msgcount) {
		msgoff = seqno - mq-&gt;imq_seqno;
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* look for the message that would match that seqno */</span>
	kmsgq = &amp;mq-&gt;imq_messages;
	kmsg = ipc_kmsg_queue_first(kmsgq);
	<span class="enscript-keyword">while</span> (msgoff-- &amp;&amp; kmsg != IKM_NULL) {
		kmsg = ipc_kmsg_queue_next(kmsgq, kmsg);
	}
	<span class="enscript-keyword">if</span> (kmsg == IKM_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* found one - return the requested info */</span>
	<span class="enscript-keyword">if</span> (seqnop != NULL)
		*seqnop = seqno;
	<span class="enscript-keyword">if</span> (msg_sizep != NULL)
		*msg_sizep = kmsg-&gt;ikm_header-&gt;msgh_size;
	<span class="enscript-keyword">if</span> (msg_idp != NULL)
		*msg_idp = kmsg-&gt;ikm_header-&gt;msgh_id;
	<span class="enscript-keyword">if</span> (msg_trailerp != NULL)
		memcpy(msg_trailerp, 
		       (mach_msg_max_trailer_t *)((vm_offset_t)kmsg-&gt;ikm_header +
						  round_msg(kmsg-&gt;ikm_header-&gt;msgh_size)),
		       <span class="enscript-keyword">sizeof</span>(mach_msg_max_trailer_t));
	res = 1;

 <span class="enscript-reference">out</span>:
	imq_unlock(mq);
	splx(s);
	<span class="enscript-keyword">return</span> res;
}


<span class="enscript-comment">/*
 * peek at the contained port message queues, break prepost iteration as soon
 * as we spot a message on one of the message queues referenced by the set's
 * prepost list.  No need to lock each message queue, as only the head of each
 * queue is checked. If a message wasn't there before we entered here, no need
 * to find it (if we do, great).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mqueue_peek_iterator</span>(<span class="enscript-type">void</span> *ctx, <span class="enscript-type">struct</span> waitq *waitq,
				<span class="enscript-type">struct</span> waitq_set *wqset)
{
	ipc_mqueue_t port_mq = (ipc_mqueue_t)waitq;
	ipc_kmsg_queue_t kmsgs = &amp;port_mq-&gt;imq_messages;

	(<span class="enscript-type">void</span>)ctx;
	(<span class="enscript-type">void</span>)wqset;
		
	<span class="enscript-keyword">if</span> (ipc_kmsg_queue_first(kmsgs) != IKM_NULL)
		<span class="enscript-keyword">return</span> WQ_ITERATE_BREAK; <span class="enscript-comment">/* break out of the prepost iteration */</span>

	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_set_peek
 *	Purpose:
 *		Peek at a message queue set to see if it has any ports
 *		with messages.
 *
 *	Conditions:
 *		Locks may be held by callers, so this routine cannot block.
 *		Caller holds reference on the message queue.
 */</span>
<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">ipc_mqueue_set_peek</span>(ipc_mqueue_t mq)
{
	spl_t s;
	<span class="enscript-type">int</span> ret;

	assert(imq_is_set(mq));

	s = splsched();
	imq_lock(mq);

	ret = waitq_set_iterate_preposts(&amp;mq-&gt;imq_set_queue, NULL,
					 mqueue_peek_iterator, NULL);

	imq_unlock(mq);
	splx(s);
	<span class="enscript-keyword">return</span> (ret == WQ_ITERATE_BREAK);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_set_gather_member_names
 *	Purpose:
 *		Discover all ports which are members of a given port set.
 *		Because the waitq linkage mechanism was redesigned to save
 *		significan amounts of memory, it no longer keeps back-pointers
 *		from a port set to a port. Therefore, we must iterate over all
 *		ports within a given IPC space and individually query them to
 *		see if they are members of the given set. Port names of ports
 *		found to be members of the given set will be gathered into the
 *		provided 'names' array.  Actual returned names are limited to
 *		maxnames entries, but we keep counting the actual number of
 *		members to let the caller decide to retry if necessary.
 *
 *	Conditions:
 *		Locks may be held by callers, so this routine cannot block.
 *		Caller holds reference on the message queue (via port set).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_set_gather_member_names</span>(
	ipc_space_t space,
	ipc_mqueue_t set_mq,
	ipc_entry_num_t maxnames,
	mach_port_name_t *names,
	ipc_entry_num_t *actualp)
{
	ipc_entry_t table;
	ipc_entry_num_t tsize;
	<span class="enscript-type">struct</span> waitq_set *wqset;
	ipc_entry_num_t actual = 0;

	assert(set_mq != IMQ_NULL);
	wqset = &amp;set_mq-&gt;imq_set_queue;

	assert(space != IS_NULL);
	is_read_lock(space);
	<span class="enscript-keyword">if</span> (!is_active(space)) {
		is_read_unlock(space);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (!waitq_set_is_valid(wqset)) {
		is_read_unlock(space);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	table = space-&gt;is_table;
	tsize = space-&gt;is_table_size;
	<span class="enscript-keyword">for</span> (ipc_entry_num_t idx = 0; idx &lt; tsize; idx++) {
		ipc_entry_t entry = &amp;table[idx];

		<span class="enscript-comment">/* only receive rights can be members of port sets */</span>
		<span class="enscript-keyword">if</span> ((entry-&gt;ie_bits &amp; MACH_PORT_TYPE_RECEIVE) != MACH_PORT_TYPE_NONE) {
			__IGNORE_WCASTALIGN(ipc_port_t port = (ipc_port_t)entry-&gt;ie_object);
			ipc_mqueue_t mq = &amp;port-&gt;ip_messages;

			assert(IP_VALID(port));
			<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
			    waitq_member(&amp;mq-&gt;imq_wait_queue, wqset)) {
				<span class="enscript-keyword">if</span> (actual &lt; maxnames)
					names[actual] = mq-&gt;imq_receiver_name;
				actual++;
			}
		}
	}

	is_read_unlock(space);

<span class="enscript-reference">out</span>:
	*actualp = actual;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_destroy
 *	Purpose:
 *		Destroy a (non-set) message queue.
 *		Set any blocked senders running.
 *	   	Destroy the kmsgs in the queue.
 *	Conditions:
 *		Nothing locked.
 *		Receivers were removed when the receive right was &quot;changed&quot;
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_destroy</span>(
	ipc_mqueue_t	mqueue)
{
	ipc_kmsg_queue_t kmqueue;
	ipc_kmsg_t kmsg;
	boolean_t reap = FALSE;
	spl_t s;

	assert(!imq_is_set(mqueue));

	s = splsched();
	imq_lock(mqueue);

	<span class="enscript-comment">/*
	 *	rouse all blocked senders
	 *	(don't boost anyone - we're tearing this queue down)
	 *	(never preposts)
	 */</span>
	mqueue-&gt;imq_fullwaiters = FALSE;
	waitq_wakeup64_all_locked(&amp;mqueue-&gt;imq_wait_queue,
				  IPC_MQUEUE_FULL,
				  THREAD_RESTART,
				  NULL,
				  WAITQ_ALL_PRIORITIES,
				  WAITQ_KEEP_LOCKED);

	<span class="enscript-comment">/*
	 * Move messages from the specified queue to the per-thread
	 * clean/drain queue while we have the mqueue lock.
	 */</span>
	kmqueue = &amp;mqueue-&gt;imq_messages;
	<span class="enscript-keyword">while</span> ((kmsg = ipc_kmsg_dequeue(kmqueue)) != IKM_NULL) {
		boolean_t first;
		first = ipc_kmsg_delayed_destroy(kmsg);
		<span class="enscript-keyword">if</span> (first)
			reap = first;
	}

	<span class="enscript-comment">/*
	 * Wipe out message count, both for messages about to be
	 * reaped and for reserved space for (previously) woken senders.
	 * This is the indication to them that their reserved space is gone
	 * (the mqueue was destroyed).
	 */</span>
	mqueue-&gt;imq_msgcount = 0;

	<span class="enscript-comment">/* clear out any preposting we may have done */</span>
	waitq_clear_prepost_locked(&amp;mqueue-&gt;imq_wait_queue, &amp;s);

	imq_unlock(mqueue);
	splx(s);

	<span class="enscript-comment">/*
	 * assert that we're destroying a queue that's not a
	 * member of any other queue
	 */</span>
	assert(mqueue-&gt;imq_wait_queue.waitq_prepost_id == 0);
	assert(mqueue-&gt;imq_wait_queue.waitq_set_id == 0);


	<span class="enscript-comment">/*
	 * Destroy the messages we enqueued if we aren't nested
	 * inside some other attempt to drain the same queue.
	 */</span>
	<span class="enscript-keyword">if</span> (reap)
		ipc_kmsg_reap_delayed();
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_set_qlimit
 *	Purpose:
 *		Changes a message queue limit; the maximum number
 *		of messages which may be queued.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_set_qlimit</span>(
	 ipc_mqueue_t			mqueue,
	 mach_port_msgcount_t	qlimit)
{
	 spl_t s;

	 assert(qlimit &lt;= MACH_PORT_QLIMIT_MAX);

	 <span class="enscript-comment">/* wake up senders allowed by the new qlimit */</span>
	 s = splsched();
	 imq_lock(mqueue);
	 <span class="enscript-keyword">if</span> (qlimit &gt; mqueue-&gt;imq_qlimit) {
		 mach_port_msgcount_t i, wakeup;

		 <span class="enscript-comment">/* caution: wakeup, qlimit are unsigned */</span>
		 wakeup = qlimit - mqueue-&gt;imq_qlimit;

		 <span class="enscript-keyword">for</span> (i = 0; i &lt; wakeup; i++) {
			<span class="enscript-comment">/*
			 * boost the priority of the awoken thread
			 * (WAITQ_PROMOTE_PRIORITY) to ensure it uses
			 * the message queue slot we've just reserved.
			 *
			 * NOTE: this will never prepost
			 */</span>
			<span class="enscript-keyword">if</span> (waitq_wakeup64_one_locked(&amp;mqueue-&gt;imq_wait_queue,
						      IPC_MQUEUE_FULL,
						      THREAD_AWAKENED,
						      NULL,
						      WAITQ_PROMOTE_PRIORITY,
						      WAITQ_KEEP_LOCKED) == KERN_NOT_WAITING) {
				mqueue-&gt;imq_fullwaiters = FALSE;
				<span class="enscript-keyword">break</span>;
			}
			mqueue-&gt;imq_msgcount++;  <span class="enscript-comment">/* give it to the awakened thread */</span>
		 }
	}
	mqueue-&gt;imq_qlimit = qlimit;
	imq_unlock(mqueue);
	splx(s);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_set_seqno
 *	Purpose:
 *		Changes an mqueue's sequence number.
 *	Conditions:
 *		Caller holds a reference to the queue's containing object.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_mqueue_set_seqno</span>(
	ipc_mqueue_t		mqueue,
	mach_port_seqno_t	seqno)
{
	spl_t s;

	s = splsched();
	imq_lock(mqueue);
	mqueue-&gt;imq_seqno = seqno;
	imq_unlock(mqueue);
	splx(s);
}


<span class="enscript-comment">/*
 *	Routine:	ipc_mqueue_copyin
 *	Purpose:
 *		Convert a name in a space to a message queue.
 *	Conditions:
 *		Nothing locked.  If successful, the caller gets a ref for
 *		for the object.	This ref ensures the continued existence of
 *		the queue.
 *	Returns:
 *		MACH_MSG_SUCCESS	Found a message queue.
 *		MACH_RCV_INVALID_NAME	The space is dead.
 *		MACH_RCV_INVALID_NAME	The name doesn't denote a right.
 *		MACH_RCV_INVALID_NAME
 *			The denoted right is not receive or port set.
 *		MACH_RCV_IN_SET		Receive right is a member of a set.
 */</span>

mach_msg_return_t
<span class="enscript-function-name">ipc_mqueue_copyin</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_mqueue_t		*mqueuep,
	ipc_object_t		*objectp)
{
	ipc_entry_t entry;
	ipc_object_t object;
	ipc_mqueue_t mqueue;

	is_read_lock(space);
	<span class="enscript-keyword">if</span> (!is_active(space)) {
		is_read_unlock(space);
		<span class="enscript-keyword">return</span> MACH_RCV_INVALID_NAME;
	}

	entry = ipc_entry_lookup(space, name);
	<span class="enscript-keyword">if</span> (entry == IE_NULL) {
		is_read_unlock(space);
		<span class="enscript-keyword">return</span> MACH_RCV_INVALID_NAME;
	}

	object = entry-&gt;ie_object;

	<span class="enscript-keyword">if</span> (entry-&gt;ie_bits &amp; MACH_PORT_TYPE_RECEIVE) {
		ipc_port_t port;

		__IGNORE_WCASTALIGN(port = (ipc_port_t) object);
		assert(port != IP_NULL);

		ip_lock(port);
		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == name);
		assert(port-&gt;ip_receiver == space);
		is_read_unlock(space);
		mqueue = &amp;port-&gt;ip_messages;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (entry-&gt;ie_bits &amp; MACH_PORT_TYPE_PORT_SET) {
		ipc_pset_t pset;

		__IGNORE_WCASTALIGN(pset = (ipc_pset_t) object);
		assert(pset != IPS_NULL);

		ips_lock(pset);
		assert(ips_active(pset));
		assert(pset-&gt;ips_local_name == name);
		is_read_unlock(space);

		mqueue = &amp;pset-&gt;ips_messages;
	} <span class="enscript-keyword">else</span> {
		is_read_unlock(space);
		<span class="enscript-keyword">return</span> MACH_RCV_INVALID_NAME;
	}

	<span class="enscript-comment">/*
	 *	At this point, the object is locked and active,
	 *	the space is unlocked, and mqueue is initialized.
	 */</span>

	io_reference(object);
	io_unlock(object);

	*objectp = object;
	*mqueuep = mqueue;
	<span class="enscript-keyword">return</span> MACH_MSG_SUCCESS;
}
</pre>
<hr />
</body></html>