<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_object.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_object.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 * Copyright (c) 2005-2006 SPARTA, Inc.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	ipc/ipc_object.c
 *	Author:	Rich Draves
 *	Date:	1989
 *
 *	Functions to manipulate IPC objects.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_rt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_importance.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_hash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_right.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_pset.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>

zone_t ipc_object_zones[IOT_NUMBER];

<span class="enscript-comment">/*
 *	Routine:	ipc_object_reference
 *	Purpose:
 *		Take a reference to an object.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_object_reference</span>(
	ipc_object_t	object)
{
	io_reference(object);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_release
 *	Purpose:
 *		Release a reference to an object.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_object_release</span>(
	ipc_object_t	object)
{
	io_release(object);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_translate
 *	Purpose:
 *		Look up an object in a space.
 *	Conditions:
 *		Nothing locked before.  If successful, the object
 *		is returned locked.  The caller doesn't get a ref.
 *	Returns:
 *		KERN_SUCCESS		Object returned locked.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	The name doesn't denote a right.
 *		KERN_INVALID_RIGHT	Name doesn't denote the correct right.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_translate</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_port_right_t	right,
	ipc_object_t		*objectp)
{
	ipc_entry_t entry;
	ipc_object_t object;
	kern_return_t kr;

	kr = ipc_right_lookup_read(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is read-locked and active */</span>

	<span class="enscript-keyword">if</span> ((entry-&gt;ie_bits &amp; MACH_PORT_TYPE(right)) == MACH_PORT_TYPE_NONE) {
		is_read_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	object = entry-&gt;ie_object;
	assert(object != IO_NULL);

	io_lock(object);
	is_read_unlock(space);

	*objectp = object;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_translate_two
 *	Purpose:
 *		Look up two objects in a space.
 *	Conditions:
 *		Nothing locked before.  If successful, the objects
 *		are returned locked.  The caller doesn't get a ref.
 *	Returns:
 *		KERN_SUCCESS		Objects returned locked.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	A name doesn't denote a right.
 *		KERN_INVALID_RIGHT	A name doesn't denote the correct right.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_translate_two</span>(
	ipc_space_t		space,
	mach_port_name_t	name1,
	mach_port_right_t	right1,
	ipc_object_t		*objectp1,
	mach_port_name_t	name2,
	mach_port_right_t	right2,
	ipc_object_t		*objectp2)
{
	ipc_entry_t entry1;
	ipc_entry_t entry2;
	ipc_object_t object;
	kern_return_t kr;

	kr = ipc_right_lookup_two_read(space, name1, &amp;entry1, name2, &amp;entry2);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is read-locked and active */</span>

	<span class="enscript-keyword">if</span> ((entry1-&gt;ie_bits &amp; MACH_PORT_TYPE(right1)) == MACH_PORT_TYPE_NONE) {
		is_read_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	<span class="enscript-keyword">if</span> ((entry2-&gt;ie_bits &amp; MACH_PORT_TYPE(right2)) == MACH_PORT_TYPE_NONE) {
		is_read_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_RIGHT;
	}

	object = entry1-&gt;ie_object;
	assert(object != IO_NULL);
	io_lock(object);
	*objectp1 = object;

	object = entry2-&gt;ie_object;
	assert(object != IO_NULL);
	io_lock(object);
	*objectp2 = object;

	is_read_unlock(space);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_alloc_dead
 *	Purpose:
 *		Allocate a dead-name entry.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The dead name is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NO_SPACE		No room for an entry in the space.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_alloc_dead</span>(
	ipc_space_t		space,
	mach_port_name_t	*namep)
{
	ipc_entry_t entry;
	kern_return_t kr;

	kr = ipc_entry_alloc(space, namep, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked */</span>

	<span class="enscript-comment">/* null object, MACH_PORT_TYPE_DEAD_NAME, 1 uref */</span>

	assert(entry-&gt;ie_object == IO_NULL);
	entry-&gt;ie_bits |= MACH_PORT_TYPE_DEAD_NAME | 1;
	ipc_entry_modified(space, *namep, entry);
	is_write_unlock(space);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_alloc_dead_name
 *	Purpose:
 *		Allocate a dead-name entry, with a specific name.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		The dead name is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NAME_EXISTS	The name already denotes a right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_alloc_dead_name</span>(
	ipc_space_t		space,
	mach_port_name_t	name)
{
	ipc_entry_t entry;
	kern_return_t kr;

	kr = ipc_entry_alloc_name(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked */</span>

	<span class="enscript-keyword">if</span> (ipc_right_inuse(space, name, entry))
		<span class="enscript-keyword">return</span> KERN_NAME_EXISTS;

	<span class="enscript-comment">/* null object, MACH_PORT_TYPE_DEAD_NAME, 1 uref */</span>

	assert(entry-&gt;ie_object == IO_NULL);
	entry-&gt;ie_bits |= MACH_PORT_TYPE_DEAD_NAME | 1;
	ipc_entry_modified(space, name, entry);
	is_write_unlock(space);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_alloc
 *	Purpose:
 *		Allocate an object.
 *	Conditions:
 *		Nothing locked.  If successful, the object is returned locked.
 *		The space is write locked on successful return. 
 *		The caller doesn't get a reference for the object.
 *	Returns:
 *		KERN_SUCCESS		The object is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NO_SPACE		No room for an entry in the space.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_alloc</span>(
	ipc_space_t		space,
	ipc_object_type_t	otype,
	mach_port_type_t	type,
	mach_port_urefs_t	urefs,
	mach_port_name_t	*namep,
	ipc_object_t		*objectp)
{
	ipc_object_t object;
	ipc_entry_t entry;
	kern_return_t kr;

	assert(otype &lt; IOT_NUMBER);
	assert((type &amp; MACH_PORT_TYPE_ALL_RIGHTS) == type);
	assert(type != MACH_PORT_TYPE_NONE);
	assert(urefs &lt;= MACH_PORT_UREFS_MAX);

	object = io_alloc(otype);
	<span class="enscript-keyword">if</span> (object == IO_NULL)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

	<span class="enscript-keyword">if</span> (otype == IOT_PORT) {
		ipc_port_t port = (ipc_port_t)object;

		bzero((<span class="enscript-type">char</span> *)port, <span class="enscript-keyword">sizeof</span>(*port));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (otype == IOT_PORT_SET) {
		ipc_pset_t pset = (ipc_pset_t)object;

		bzero((<span class="enscript-type">char</span> *)pset, <span class="enscript-keyword">sizeof</span>(*pset));
	}

	io_lock_init(object);
	*namep = CAST_MACH_PORT_TO_NAME(object);
	kr = ipc_entry_alloc(space, namep, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		io_free(otype, object);
		<span class="enscript-keyword">return</span> kr;
	}
	<span class="enscript-comment">/* space is write-locked */</span>

	entry-&gt;ie_bits |= type | urefs;
	entry-&gt;ie_object = object;
	ipc_entry_modified(space, *namep, entry);

	io_lock(object);

	object-&gt;io_references = 1; <span class="enscript-comment">/* for entry, not caller */</span>
	object-&gt;io_bits = io_makebits(TRUE, otype, 0);

	*objectp = object;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_alloc_name
 *	Purpose:
 *		Allocate an object, with a specific name.
 *	Conditions:
 *		Nothing locked.  If successful, the object is returned locked.
 *		The caller doesn't get a reference for the object.
 *	Returns:
 *		KERN_SUCCESS		The object is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NAME_EXISTS	The name already denotes a right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_alloc_name</span>(
	ipc_space_t		space,
	ipc_object_type_t	otype,
	mach_port_type_t	type,
	mach_port_urefs_t	urefs,
	mach_port_name_t	name,
	ipc_object_t		*objectp)
{
	ipc_object_t object;
	ipc_entry_t entry;
	kern_return_t kr;

	assert(otype &lt; IOT_NUMBER);
	assert((type &amp; MACH_PORT_TYPE_ALL_RIGHTS) == type);
	assert(type != MACH_PORT_TYPE_NONE);
	assert(urefs &lt;= MACH_PORT_UREFS_MAX);

	object = io_alloc(otype);
	<span class="enscript-keyword">if</span> (object == IO_NULL)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

	<span class="enscript-keyword">if</span> (otype == IOT_PORT) {
		ipc_port_t port = (ipc_port_t)object;

		bzero((<span class="enscript-type">char</span> *)port, <span class="enscript-keyword">sizeof</span>(*port));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (otype == IOT_PORT_SET) {
		ipc_pset_t pset = (ipc_pset_t)object;

		bzero((<span class="enscript-type">char</span> *)pset, <span class="enscript-keyword">sizeof</span>(*pset));
	}

	io_lock_init(object);
	kr = ipc_entry_alloc_name(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		io_free(otype, object);
		<span class="enscript-keyword">return</span> kr;
	}
	<span class="enscript-comment">/* space is write-locked */</span>

	<span class="enscript-keyword">if</span> (ipc_right_inuse(space, name, entry)) {
		io_free(otype, object);
		<span class="enscript-keyword">return</span> KERN_NAME_EXISTS;
	}

	entry-&gt;ie_bits |= type | urefs;
	entry-&gt;ie_object = object;
	ipc_entry_modified(space, name, entry);

	io_lock(object);
	is_write_unlock(space);

	object-&gt;io_references = 1; <span class="enscript-comment">/* for entry, not caller */</span>
	object-&gt;io_bits = io_makebits(TRUE, otype, 0);

	*objectp = object;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_copyin_type
 *	Purpose:
 *		Convert a send type name to a received type name.
 */</span>

mach_msg_type_name_t
<span class="enscript-function-name">ipc_object_copyin_type</span>(
	mach_msg_type_name_t	msgt_name)
{
	<span class="enscript-keyword">switch</span> (msgt_name) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_RECEIVE</span>:
		<span class="enscript-keyword">return</span> MACH_MSG_TYPE_PORT_RECEIVE;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND_ONCE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND_ONCE</span>:
		<span class="enscript-keyword">return</span> MACH_MSG_TYPE_PORT_SEND_ONCE;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_COPY_SEND</span>:
		<span class="enscript-keyword">return</span> MACH_MSG_TYPE_PORT_SEND;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_DISPOSE_RECEIVE</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_DISPOSE_SEND</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_DISPOSE_SEND_ONCE</span>:
		<span class="enscript-comment">/* fall thru */</span>
	    <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> MACH_MSG_TYPE_PORT_NONE;
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_copyin
 *	Purpose:
 *		Copyin a capability from a space.
 *		If successful, the caller gets a ref
 *		for the resulting object, unless it is IO_DEAD.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Acquired an object, possibly IO_DEAD.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_NAME	Name doesn't exist in space.
 *		KERN_INVALID_RIGHT	Name doesn't denote correct right.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_copyin</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_msg_type_name_t	msgt_name,
	ipc_object_t		*objectp)
{
	ipc_entry_t entry;
	ipc_port_t soright;
	ipc_port_t release_port;
	kern_return_t kr;
	<span class="enscript-type">int</span> assertcnt = 0;

	<span class="enscript-comment">/*
	 *	Could first try a read lock when doing
	 *	MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND,
	 *	and MACH_MSG_TYPE_MAKE_SEND_ONCE.
	 */</span>

	kr = ipc_right_lookup_write(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked and active */</span>

	release_port = IP_NULL;
	kr = ipc_right_copyin(space, name, entry,
			      msgt_name, TRUE,
			      objectp, &amp;soright,
			      &amp;release_port,
			      &amp;assertcnt);
	<span class="enscript-keyword">if</span> (IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE)
		ipc_entry_dealloc(space, name, entry);
	is_write_unlock(space);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">if</span> (0 &lt; assertcnt &amp;&amp; ipc_importance_task_is_any_receiver_type(current_task()-&gt;task_imp_base)) {
		ipc_importance_task_drop_internal_assertion(current_task()-&gt;task_imp_base, assertcnt);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">if</span> (release_port != IP_NULL)
		ip_release(release_port);

	<span class="enscript-keyword">if</span> ((kr == KERN_SUCCESS) &amp;&amp; (soright != IP_NULL))
		ipc_notify_port_deleted(soright, name);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_copyin_from_kernel
 *	Purpose:
 *		Copyin a naked capability from the kernel.
 *
 *		MACH_MSG_TYPE_MOVE_RECEIVE
 *			The receiver must be ipc_space_kernel
 *			or the receive right must already be in limbo.
 *			Consumes the naked receive right.
 *		MACH_MSG_TYPE_COPY_SEND
 *			A naked send right must be supplied.
 *			The port gains a reference, and a send right
 *			if the port is still active.
 *		MACH_MSG_TYPE_MAKE_SEND
 *			The receiver must be ipc_space_kernel.
 *			The port gains a reference and a send right.
 *		MACH_MSG_TYPE_MOVE_SEND
 *			Consumes a naked send right.
 *		MACH_MSG_TYPE_MAKE_SEND_ONCE
 *			The port gains a reference and a send-once right.
 *			Receiver also be the caller of device subsystem,
 *			so no assertion.
 *		MACH_MSG_TYPE_MOVE_SEND_ONCE
 *			Consumes a naked send-once right.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_object_copyin_from_kernel</span>(
	ipc_object_t		object,
	mach_msg_type_name_t	msgt_name)
{
	assert(IO_VALID(object));

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_RECEIVE</span>: {
		ipc_port_t port = (ipc_port_t) object;

		ip_lock(port);
		assert(ip_active(port));
		<span class="enscript-keyword">if</span> (port-&gt;ip_destination != IP_NULL) {
			assert(port-&gt;ip_receiver == ipc_space_kernel);

			<span class="enscript-comment">/* relevant part of ipc_port_clear_receiver */</span>
			ipc_port_set_mscount(port, 0);

			port-&gt;ip_receiver_name = MACH_PORT_NULL;
			port-&gt;ip_destination = IP_NULL;
		}
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_COPY_SEND</span>: {
		ipc_port_t port = (ipc_port_t) object;

		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port)) {
			assert(port-&gt;ip_srights &gt; 0);
			port-&gt;ip_srights++;
		}
		ip_reference(port);
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND</span>: {
		ipc_port_t port = (ipc_port_t) object;

		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port)) {
			assert(port-&gt;ip_receiver_name != MACH_PORT_NULL);
			assert(port-&gt;ip_receiver == ipc_space_kernel);
			port-&gt;ip_mscount++;
		}

		port-&gt;ip_srights++;
		ip_reference(port);
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND</span>: {
		<span class="enscript-comment">/* move naked send right into the message */</span>
		assert(((ipc_port_t)object)-&gt;ip_srights);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND_ONCE</span>: {
		ipc_port_t port = (ipc_port_t) object;

		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port)) {
			assert(port-&gt;ip_receiver_name != MACH_PORT_NULL);
		}
		port-&gt;ip_sorights++;
		ip_reference(port);
		ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND_ONCE</span>: {
		<span class="enscript-comment">/* move naked send-once right into the message */</span>
	    	assert(((ipc_port_t)object)-&gt;ip_sorights);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_object_copyin_from_kernel: strange rights&quot;</span>);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_destroy
 *	Purpose:
 *		Destroys a naked capability.
 *		Consumes a ref for the object.
 *
 *		A receive right should be in limbo or in transit.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_object_destroy</span>(
	ipc_object_t		object,
	mach_msg_type_name_t	msgt_name)
{
	assert(IO_VALID(object));
	assert(io_otype(object) == IOT_PORT);

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND</span>:
		ipc_port_release_send((ipc_port_t) object);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND_ONCE</span>:
		ipc_notify_send_once((ipc_port_t) object);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_RECEIVE</span>:
		ipc_port_release_receive((ipc_port_t) object);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_object_destroy: strange rights&quot;</span>);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_destroy_dest
 *	Purpose:
 *		Destroys a naked capability for the destination of
 *		of a message. Consumes a ref for the object.
 *
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_object_destroy_dest</span>(
	ipc_object_t		object,
	mach_msg_type_name_t	msgt_name)
{
	assert(IO_VALID(object));
	assert(io_otype(object) == IOT_PORT);

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND</span>:
		ipc_port_release_send((ipc_port_t) object);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND_ONCE</span>:
		<span class="enscript-keyword">if</span> (io_active(object) &amp;&amp; 
		    !ip_full_kernel((ipc_port_t) object))
			ipc_notify_send_once((ipc_port_t) object);
		<span class="enscript-keyword">else</span>
			ipc_port_release_sonce((ipc_port_t) object);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_object_destroy_dest: strange rights&quot;</span>);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_copyout
 *	Purpose:
 *		Copyout a capability, placing it into a space.
 *		If successful, consumes a ref for the object.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Copied out object, consumed ref.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_CAPABILITY	The object is dead.
 *		KERN_NO_SPACE		No room in space for another right.
 *		KERN_RESOURCE_SHORTAGE	No memory available.
 *		KERN_UREFS_OVERFLOW	Urefs limit exceeded
 *			and overflow wasn't specified.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_copyout</span>(
	ipc_space_t		space,
	ipc_object_t		object,
	mach_msg_type_name_t	msgt_name,
	boolean_t		overflow,
	mach_port_name_t	*namep)
{
	mach_port_name_t name;
	ipc_entry_t entry;
	kern_return_t kr;

	assert(IO_VALID(object));
	assert(io_otype(object) == IOT_PORT);

	is_write_lock(space);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (!is_active(space)) {
			is_write_unlock(space);
			<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
		}

		<span class="enscript-keyword">if</span> ((msgt_name != MACH_MSG_TYPE_PORT_SEND_ONCE) &amp;&amp;
		    ipc_right_reverse(space, object, &amp;name, &amp;entry)) { 
			<span class="enscript-comment">/* object is locked and active */</span>

			assert(entry-&gt;ie_bits &amp; MACH_PORT_TYPE_SEND_RECEIVE);
			<span class="enscript-keyword">break</span>;
		}

		name = CAST_MACH_PORT_TO_NAME(object);
		kr = ipc_entry_get(space, &amp;name, &amp;entry);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-comment">/* unlocks/locks space, so must start again */</span>

			kr = ipc_entry_grow_table(space, ITS_SIZE_NONE);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
				<span class="enscript-keyword">return</span> kr; <span class="enscript-comment">/* space is unlocked */</span>

			<span class="enscript-keyword">continue</span>;
		}

		assert(IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE);
		assert(entry-&gt;ie_object == IO_NULL);

		io_lock(object);
		<span class="enscript-keyword">if</span> (!io_active(object)) {
			io_unlock(object);
			ipc_entry_dealloc(space, name, entry);
			is_write_unlock(space);
			<span class="enscript-keyword">return</span> KERN_INVALID_CAPABILITY;
		}

		entry-&gt;ie_object = object;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* space is write-locked and active, object is locked and active */</span>

	kr = ipc_right_copyout(space, name, entry,
			       msgt_name, overflow, object);

	<span class="enscript-comment">/* object is unlocked */</span>
	is_write_unlock(space);

	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
		*namep = name;
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_copyout_name
 *	Purpose:
 *		Copyout a capability, placing it into a space.
 *		The specified name is used for the capability.
 *		If successful, consumes a ref for the object.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Copied out object, consumed ref.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_INVALID_CAPABILITY	The object is dead.
 *		KERN_RESOURCE_SHORTAGE	No memory available.
 *		KERN_UREFS_OVERFLOW	Urefs limit exceeded
 *			and overflow wasn't specified.
 *		KERN_RIGHT_EXISTS	Space has rights under another name.
 *		KERN_NAME_EXISTS	Name is already used.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_copyout_name</span>(
	ipc_space_t		space,
	ipc_object_t		object,
	mach_msg_type_name_t	msgt_name,
	boolean_t		overflow,
	mach_port_name_t	name)
{
	mach_port_name_t oname;
	ipc_entry_t oentry;
	ipc_entry_t entry;
	kern_return_t kr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-type">int</span> assertcnt = 0;
	ipc_importance_task_t task_imp = IIT_NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	assert(IO_VALID(object));
	assert(io_otype(object) == IOT_PORT);

	kr = ipc_entry_alloc_name(space, name, &amp;entry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-comment">/* space is write-locked and active */</span>

	<span class="enscript-keyword">if</span> ((msgt_name != MACH_MSG_TYPE_PORT_SEND_ONCE) &amp;&amp;
	    ipc_right_reverse(space, object, &amp;oname, &amp;oentry)) {
		<span class="enscript-comment">/* object is locked and active */</span>

		<span class="enscript-keyword">if</span> (name != oname) {
			io_unlock(object);

			<span class="enscript-keyword">if</span> (IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE)
				ipc_entry_dealloc(space, name, entry);

			is_write_unlock(space);
			<span class="enscript-keyword">return</span> KERN_RIGHT_EXISTS;
		}

		assert(entry == oentry);
		assert(entry-&gt;ie_bits &amp; MACH_PORT_TYPE_SEND_RECEIVE);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ipc_right_inuse(space, name, entry))
			<span class="enscript-keyword">return</span> KERN_NAME_EXISTS;

		assert(IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE);
		assert(entry-&gt;ie_object == IO_NULL);

		io_lock(object);
		<span class="enscript-keyword">if</span> (!io_active(object)) {
			io_unlock(object);
			ipc_entry_dealloc(space, name, entry);
			is_write_unlock(space);
			<span class="enscript-keyword">return</span> KERN_INVALID_CAPABILITY;
		}

		entry-&gt;ie_object = object;
	}

	<span class="enscript-comment">/* space is write-locked and active, object is locked and active */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/*
	 * We are slamming a receive right into the space, without
	 * first having been enqueued on a port destined there.  So,
	 * we have to arrange to boost the task appropriately if this
	 * port has assertions (and the task wants them).
	 */</span>
	<span class="enscript-keyword">if</span> (msgt_name == MACH_MSG_TYPE_PORT_RECEIVE) {
		ipc_port_t port = (ipc_port_t)object;

		<span class="enscript-keyword">if</span> (space-&gt;is_task != TASK_NULL) {
			task_imp = space-&gt;is_task-&gt;task_imp_base;
			<span class="enscript-keyword">if</span> (ipc_importance_task_is_any_receiver_type(task_imp)) {
				assertcnt = port-&gt;ip_impcount;
				ipc_importance_task_reference(task_imp);
			}
		}

		<span class="enscript-comment">/* take port out of limbo */</span>
		assert(port-&gt;ip_tempowner != 0);
		port-&gt;ip_tempowner = 0;
	}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	kr = ipc_right_copyout(space, name, entry,
			       msgt_name, overflow, object);

	<span class="enscript-comment">/* object is unlocked */</span>
	is_write_unlock(space);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/*
	 * Add the assertions to the task that we captured before
	 */</span>
	<span class="enscript-keyword">if</span> (task_imp != IIT_NULL) {
		ipc_importance_task_hold_internal_assertion(task_imp, assertcnt);
		ipc_importance_task_release(task_imp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_copyout_dest
 *	Purpose:
 *		Translates/consumes the destination right of a message.
 *		This is unlike normal copyout because the right is consumed
 *		in a funny way instead of being given to the receiving space.
 *		The receiver gets his name for the port, if he has receive
 *		rights, otherwise MACH_PORT_NULL.
 *	Conditions:
 *		The object is locked and active.  Nothing else locked.
 *		The object is unlocked and loses a reference.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_object_copyout_dest</span>(
	ipc_space_t		space,
	ipc_object_t		object,
	mach_msg_type_name_t	msgt_name,
	mach_port_name_t	*namep)
{
	mach_port_name_t name;

	assert(IO_VALID(object));
	assert(io_active(object));

	io_release(object);

	<span class="enscript-comment">/*
	 *	If the space is the receiver/owner of the object,
	 *	then we quietly consume the right and return
	 *	the space's name for the object.  Otherwise
	 *	we destroy the right and return MACH_PORT_NULL.
	 */</span>

	<span class="enscript-keyword">switch</span> (msgt_name) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND</span>: {
		ipc_port_t port = (ipc_port_t) object;
		ipc_port_t nsrequest = IP_NULL;
		mach_port_mscount_t mscount;

		<span class="enscript-keyword">if</span> (port-&gt;ip_receiver == space)
			name = port-&gt;ip_receiver_name;
		<span class="enscript-keyword">else</span>
			name = MACH_PORT_NULL;

		assert(port-&gt;ip_srights &gt; 0);
		<span class="enscript-keyword">if</span> (--port-&gt;ip_srights == 0 &amp;&amp;
		    port-&gt;ip_nsrequest != IP_NULL) {
			nsrequest = port-&gt;ip_nsrequest;
			port-&gt;ip_nsrequest = IP_NULL;
			mscount = port-&gt;ip_mscount;
			ip_unlock(port);
			ipc_notify_no_senders(nsrequest, mscount);
		} <span class="enscript-keyword">else</span>
			ip_unlock(port);
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_PORT_SEND_ONCE</span>: {
		ipc_port_t port = (ipc_port_t) object;

		assert(port-&gt;ip_sorights &gt; 0);

		<span class="enscript-keyword">if</span> (port-&gt;ip_receiver == space) {
			<span class="enscript-comment">/* quietly consume the send-once right */</span>

			port-&gt;ip_sorights--;
			name = port-&gt;ip_receiver_name;
			ip_unlock(port);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 *	A very bizarre case.  The message
			 *	was received, but before this copyout
			 *	happened the space lost receive rights.
			 *	We can't quietly consume the soright
			 *	out from underneath some other task,
			 *	so generate a send-once notification.
			 */</span>

			ip_reference(port); <span class="enscript-comment">/* restore ref */</span>
			ip_unlock(port);

			ipc_notify_send_once(port);
			name = MACH_PORT_NULL;
		}

		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipc_object_copyout_dest: strange rights&quot;</span>);
		name = MACH_PORT_DEAD;
	}

	*namep = name;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_object_rename
 *	Purpose:
 *		Rename an entry in a space.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Renamed the entry.
 *		KERN_INVALID_TASK	The space was dead.
 *		KERN_INVALID_NAME	oname didn't denote an entry.
 *		KERN_NAME_EXISTS	nname already denoted an entry.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate new entry.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_object_rename</span>(
	ipc_space_t		space,
	mach_port_name_t	oname,
	mach_port_name_t	nname)
{
	ipc_entry_t oentry, nentry;
	kern_return_t kr;
	
	kr = ipc_entry_alloc_name(space, nname, &amp;nentry);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* space is write-locked and active */</span>

	<span class="enscript-keyword">if</span> (ipc_right_inuse(space, nname, nentry)) {
		<span class="enscript-comment">/* space is unlocked */</span>
		<span class="enscript-keyword">return</span> KERN_NAME_EXISTS;
	}

	<span class="enscript-comment">/* don't let ipc_entry_lookup see the uninitialized new entry */</span>

	<span class="enscript-keyword">if</span> ((oname == nname) ||
	    ((oentry = ipc_entry_lookup(space, oname)) == IE_NULL)) {
		ipc_entry_dealloc(space, nname, nentry);
		is_write_unlock(space);
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}

	kr = ipc_right_rename(space, oname, oentry, nname, nentry);
	<span class="enscript-comment">/* space is unlocked */</span>
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	Check whether the object is a port if so, free it.  But
 *	keep track of that fact.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">io_free</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	otype,
	ipc_object_t	object)
{
	ipc_port_t	port;

	<span class="enscript-keyword">if</span> (otype == IOT_PORT) {
		port = (ipc_port_t) object;
		ipc_port_finalize(port);
	}
	io_lock_destroy(object);
	zfree(ipc_object_zones[otype], object);
}
</pre>
<hr />
</body></html>