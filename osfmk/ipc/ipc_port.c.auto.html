<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_port.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_port.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	ipc/ipc_port.c
 *	Author:	Rich Draves
 *	Date:	1989
 *
 *	Functions to manipulate IPC ports.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_pset.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_kmsg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_mqueue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_table.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_importance.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

<span class="enscript-function-name">decl_lck_spin_data</span>(,	ipc_port_multiple_lock_data)
ipc_port_timestamp_t	ipc_port_timestamp_data;
<span class="enscript-type">int</span> ipc_portbt;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-type">void</span>	ipc_port_init_debug(
		ipc_port_t	port,
		uintptr_t	*callstack,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	callstack_max);

<span class="enscript-type">void</span>	ipc_port_callstack_init_debug(
		uintptr_t	*callstack,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	callstack_max);
	
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_release</span>(ipc_port_t port)
{
	ip_release(port);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_reference</span>(ipc_port_t port)
{
	ip_reference(port);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_timestamp
 *	Purpose:
 *		Retrieve a timestamp value.
 */</span>

ipc_port_timestamp_t
<span class="enscript-function-name">ipc_port_timestamp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> OSIncrementAtomic(&amp;ipc_port_timestamp_data);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_request_alloc
 *	Purpose:
 *		Try to allocate a request slot.
 *		If successful, returns the request index.
 *		Otherwise returns zero.
 *	Conditions:
 *		The port is locked and active.
 *	Returns:
 *		KERN_SUCCESS		A request index was found.
 *		KERN_NO_SPACE		No index allocated.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
kern_return_t
<span class="enscript-function-name">ipc_port_request_alloc</span>(
	ipc_port_t			port,
	mach_port_name_t		name,
	ipc_port_t			soright,
	boolean_t			send_possible,
	boolean_t			immediate,
	ipc_port_request_index_t	*indexp,
	boolean_t			*importantp)
#<span class="enscript-reference">else</span>
kern_return_t
<span class="enscript-function-name">ipc_port_request_alloc</span>(
	ipc_port_t			port,
	mach_port_name_t		name,
	ipc_port_t			soright,
	boolean_t			send_possible,
	boolean_t			immediate,
	ipc_port_request_index_t	*indexp)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
{
	ipc_port_request_t ipr, table;
	ipc_port_request_index_t index;
	uintptr_t mask = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	*importantp = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	assert(ip_active(port));
	assert(name != MACH_PORT_NULL);
	assert(soright != IP_NULL);

	table = port-&gt;ip_requests;

	<span class="enscript-keyword">if</span> (table == IPR_NULL)
		<span class="enscript-keyword">return</span> KERN_NO_SPACE;

	index = table-&gt;ipr_next;
	<span class="enscript-keyword">if</span> (index == 0)
		<span class="enscript-keyword">return</span> KERN_NO_SPACE;

	ipr = &amp;table[index];
	assert(ipr-&gt;ipr_name == MACH_PORT_NULL);

	table-&gt;ipr_next = ipr-&gt;ipr_next;
	ipr-&gt;ipr_name = name;
	
	<span class="enscript-keyword">if</span> (send_possible) {
		mask |= IPR_SOR_SPREQ_MASK;
		<span class="enscript-keyword">if</span> (immediate) {
			mask |= IPR_SOR_SPARM_MASK;
			<span class="enscript-keyword">if</span> (port-&gt;ip_sprequests == 0) {
				port-&gt;ip_sprequests = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
				<span class="enscript-comment">/* TODO: Live importance support in send-possible */</span>
				<span class="enscript-keyword">if</span> (port-&gt;ip_impdonation != 0 &amp;&amp;
				    port-&gt;ip_spimportant == 0 &amp;&amp;
				    (task_is_importance_donor(current_task()))) {
					port-&gt;ip_spimportant = 1;
					*importantp = TRUE;
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERTANCE */</span>
			}
		}
	}
	ipr-&gt;ipr_soright = IPR_SOR_MAKE(soright, mask);

	*indexp = index;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_request_grow
 *	Purpose:
 *		Grow a port's table of requests.
 *	Conditions:
 *		The port must be locked and active.
 *		Nothing else locked; will allocate memory.
 *		Upon return the port is unlocked.
 *	Returns:
 *		KERN_SUCCESS		Grew the table.
 *		KERN_SUCCESS		Somebody else grew the table.
 *		KERN_SUCCESS		The port died.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate new table.
 *		KERN_NO_SPACE		Couldn't grow to desired size
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_port_request_grow</span>(
	ipc_port_t		port,
	ipc_table_elems_t 	target_size)
{
	ipc_table_size_t its;
	ipc_port_request_t otable, ntable;

	assert(ip_active(port));

	otable = port-&gt;ip_requests;
	<span class="enscript-keyword">if</span> (otable == IPR_NULL)
		its = &amp;ipc_table_requests[0];
	<span class="enscript-keyword">else</span>
		its = otable-&gt;ipr_size + 1;

	<span class="enscript-keyword">if</span> (target_size != ITS_SIZE_NONE) {
		<span class="enscript-keyword">if</span> ((otable != IPR_NULL) &amp;&amp;
		    (target_size &lt;= otable-&gt;ipr_size-&gt;its_size)) {
			ip_unlock(port);
			<span class="enscript-keyword">return</span> KERN_SUCCESS;
	        }
		<span class="enscript-keyword">while</span> ((its-&gt;its_size) &amp;&amp; (its-&gt;its_size &lt; target_size)) {
			its++;
		}
		<span class="enscript-keyword">if</span> (its-&gt;its_size == 0) {
			ip_unlock(port);
			<span class="enscript-keyword">return</span> KERN_NO_SPACE;
		}
	}

	ip_reference(port);
	ip_unlock(port);

	<span class="enscript-keyword">if</span> ((its-&gt;its_size == 0) ||
	    ((ntable = it_requests_alloc(its)) == IPR_NULL)) {
		ip_release(port);
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	ip_lock(port);

	<span class="enscript-comment">/*
	 *	Check that port is still active and that nobody else
	 *	has slipped in and grown the table on us.  Note that
	 *	just checking if the current table pointer == otable
	 *	isn't sufficient; must check ipr_size.
	 */</span>

	<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp; (port-&gt;ip_requests == otable) &amp;&amp;
	    ((otable == IPR_NULL) || (otable-&gt;ipr_size+1 == its))) {
		ipc_table_size_t oits;
		ipc_table_elems_t osize, nsize;
		ipc_port_request_index_t free, i;

		<span class="enscript-comment">/* copy old table to new table */</span>

		<span class="enscript-keyword">if</span> (otable != IPR_NULL) {
			oits = otable-&gt;ipr_size;
			osize = oits-&gt;its_size;
			free = otable-&gt;ipr_next;

			(<span class="enscript-type">void</span>) memcpy((<span class="enscript-type">void</span> *)(ntable + 1),
			      (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(otable + 1),
			      (osize - 1) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipc_port_request));
		} <span class="enscript-keyword">else</span> {
			osize = 1;
			oits = 0;
			free = 0;
		}

		nsize = its-&gt;its_size;
		assert(nsize &gt; osize);

		<span class="enscript-comment">/* add new elements to the new table's free list */</span>

		<span class="enscript-keyword">for</span> (i = osize; i &lt; nsize; i++) {
			ipc_port_request_t ipr = &amp;ntable[i];

			ipr-&gt;ipr_name = MACH_PORT_NULL;
			ipr-&gt;ipr_next = free;
			free = i;
		}

		ntable-&gt;ipr_next = free;
		ntable-&gt;ipr_size = its;
		port-&gt;ip_requests = ntable;
		ip_unlock(port);
		ip_release(port);

		<span class="enscript-keyword">if</span> (otable != IPR_NULL) {
			it_requests_free(oits, otable);
	        }
	} <span class="enscript-keyword">else</span> {
		ip_unlock(port);
		ip_release(port);
		it_requests_free(its, ntable);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}
 
<span class="enscript-comment">/*
 *	Routine:	ipc_port_request_sparm
 *	Purpose:
 *		Arm delayed send-possible request.
 *	Conditions:
 *		The port must be locked and active.
 *
 *		Returns TRUE if the request was armed
 *		(or armed with importance in that version).
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
boolean_t
<span class="enscript-function-name">ipc_port_request_sparm</span>(
	ipc_port_t			port,
	__assert_only mach_port_name_t	name,
	ipc_port_request_index_t	index,
	mach_msg_option_t		option)
#<span class="enscript-reference">else</span>
boolean_t
<span class="enscript-function-name">ipc_port_request_sparm</span>(
	ipc_port_t			port,
	__assert_only mach_port_name_t	name,
	ipc_port_request_index_t	index)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
{
	<span class="enscript-keyword">if</span> (index != IE_REQ_NONE) {
		ipc_port_request_t ipr, table;

		assert(ip_active(port));
	
		table = port-&gt;ip_requests;
		assert(table != IPR_NULL);

		ipr = &amp;table[index];
		assert(ipr-&gt;ipr_name == name);

		<span class="enscript-keyword">if</span> (IPR_SOR_SPREQ(ipr-&gt;ipr_soright)) {
			ipr-&gt;ipr_soright = IPR_SOR_MAKE(ipr-&gt;ipr_soright, IPR_SOR_SPARM_MASK);
			port-&gt;ip_sprequests = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
			<span class="enscript-keyword">if</span> (((option &amp; MACH_SEND_NOIMPORTANCE) == 0) &amp;&amp;
			    (port-&gt;ip_impdonation != 0) &amp;&amp;
			    (port-&gt;ip_spimportant == 0) &amp;&amp;
			    (((option &amp; MACH_SEND_IMPORTANCE) != 0) ||
			     (task_is_importance_donor(current_task())))) {
				port-&gt;ip_spimportant = 1;
				<span class="enscript-keyword">return</span> TRUE;
			}
#<span class="enscript-reference">else</span>
			<span class="enscript-keyword">return</span> TRUE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
		} 
	}
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_request_type
 *	Purpose:
 *		Determine the type(s) of port requests enabled for a name.
 *	Conditions:
 *		The port must be locked or inactive (to avoid table growth).
 *		The index must not be IE_REQ_NONE and for the name in question.
 */</span>
mach_port_type_t
<span class="enscript-function-name">ipc_port_request_type</span>(
	ipc_port_t			port,
	__assert_only mach_port_name_t	name,
	ipc_port_request_index_t	index)
{
	ipc_port_request_t ipr, table;
	mach_port_type_t type = 0;

	table = port-&gt;ip_requests;
	assert (table != IPR_NULL);

	assert(index != IE_REQ_NONE);
	ipr = &amp;table[index];
	assert(ipr-&gt;ipr_name == name);

	<span class="enscript-keyword">if</span> (IP_VALID(IPR_SOR_PORT(ipr-&gt;ipr_soright))) {
		type |= MACH_PORT_TYPE_DNREQUEST;

		<span class="enscript-keyword">if</span> (IPR_SOR_SPREQ(ipr-&gt;ipr_soright)) {
			type |= MACH_PORT_TYPE_SPREQUEST;

			<span class="enscript-keyword">if</span> (!IPR_SOR_SPARMED(ipr-&gt;ipr_soright)) {
				type |= MACH_PORT_TYPE_SPREQUEST_DELAYED;
			}
		}
	}
	<span class="enscript-keyword">return</span> type;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_request_cancel
 *	Purpose:
 *		Cancel a dead-name/send-possible request and return the send-once right.
 *	Conditions:
 *		The port must be locked and active.
 *		The index must not be IPR_REQ_NONE and must correspond with name.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_request_cancel</span>(
	ipc_port_t			port,
	__assert_only mach_port_name_t	name,
	ipc_port_request_index_t	index)
{
	ipc_port_request_t ipr, table;
	ipc_port_t request = IP_NULL;

	assert(ip_active(port));
	table = port-&gt;ip_requests;
	assert(table != IPR_NULL);

	assert (index != IE_REQ_NONE);
	ipr = &amp;table[index];
	assert(ipr-&gt;ipr_name == name);
	request = IPR_SOR_PORT(ipr-&gt;ipr_soright);

	<span class="enscript-comment">/* return ipr to the free list inside the table */</span>
	ipr-&gt;ipr_name = MACH_PORT_NULL;
	ipr-&gt;ipr_next = table-&gt;ipr_next;
	table-&gt;ipr_next = index;

	<span class="enscript-keyword">return</span> request;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_pdrequest
 *	Purpose:
 *		Make a port-deleted request, returning the
 *		previously registered send-once right.
 *		Just cancels the previous request if notify is IP_NULL.
 *	Conditions:
 *		The port is locked and active.  It is unlocked.
 *		Consumes a ref for notify (if non-null), and
 *		returns previous with a ref (if non-null).
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_pdrequest</span>(
	ipc_port_t	port,
	ipc_port_t	notify,
	ipc_port_t	*previousp)
{
	ipc_port_t previous;

	assert(ip_active(port));

	previous = port-&gt;ip_pdrequest;
	port-&gt;ip_pdrequest = notify;
	ip_unlock(port);

	*previousp = previous;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_nsrequest
 *	Purpose:
 *		Make a no-senders request, returning the
 *		previously registered send-once right.
 *		Just cancels the previous request if notify is IP_NULL.
 *	Conditions:
 *		The port is locked and active.  It is unlocked.
 *		Consumes a ref for notify (if non-null), and
 *		returns previous with a ref (if non-null).
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_nsrequest</span>(
	ipc_port_t		port,
	mach_port_mscount_t	sync,
	ipc_port_t		notify,
	ipc_port_t		*previousp)
{
	ipc_port_t previous;
	mach_port_mscount_t mscount;

	assert(ip_active(port));

	previous = port-&gt;ip_nsrequest;
	mscount = port-&gt;ip_mscount;

	<span class="enscript-keyword">if</span> ((port-&gt;ip_srights == 0) &amp;&amp; (sync &lt;= mscount) &amp;&amp;
	    (notify != IP_NULL)) {
		port-&gt;ip_nsrequest = IP_NULL;
		ip_unlock(port);
		ipc_notify_no_senders(notify, mscount);
	} <span class="enscript-keyword">else</span> {
		port-&gt;ip_nsrequest = notify;
		ip_unlock(port);
	}

	*previousp = previous;
}


<span class="enscript-comment">/*
 *	Routine:	ipc_port_clear_receiver
 *	Purpose:
 *		Prepares a receive right for transmission/destruction.
 *	Conditions:
 *		The port is locked and active.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_clear_receiver</span>(
	ipc_port_t	port)
{
	spl_t		s;

	assert(ip_active(port));

	<span class="enscript-comment">/*
	 * pull ourselves from any sets.
	 */</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_in_pset != 0) {
		ipc_pset_remove_from_all(port);
		assert(port-&gt;ip_in_pset == 0);
	}

	<span class="enscript-comment">/*
	 * Send anyone waiting on the port's queue directly away.
	 * Also clear the mscount and seqno.
	 */</span>
	s = splsched();
	imq_lock(&amp;port-&gt;ip_messages);
	ipc_mqueue_changed(&amp;port-&gt;ip_messages);
	ipc_port_set_mscount(port, 0);
	port-&gt;ip_messages.imq_seqno = 0;
	port-&gt;ip_context = port-&gt;ip_guarded = port-&gt;ip_strict_guard = 0;
	imq_unlock(&amp;port-&gt;ip_messages);
	splx(s);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_init
 *	Purpose:
 *		Initializes a newly-allocated port.
 *		Doesn't touch the ip_object fields.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_init</span>(
	ipc_port_t		port,
	ipc_space_t		space,
	mach_port_name_t	name)
{
	<span class="enscript-comment">/* port-&gt;ip_kobject doesn't have to be initialized */</span>

	port-&gt;ip_receiver = space;
	port-&gt;ip_receiver_name = name;

	port-&gt;ip_mscount = 0;
	port-&gt;ip_srights = 0;
	port-&gt;ip_sorights = 0;

	port-&gt;ip_nsrequest = IP_NULL;
	port-&gt;ip_pdrequest = IP_NULL;
	port-&gt;ip_requests = IPR_NULL;

	port-&gt;ip_premsg = IKM_NULL;
	port-&gt;ip_context = 0;

	port-&gt;ip_sprequests  = 0;
	port-&gt;ip_spimportant = 0;
	port-&gt;ip_impdonation = 0;
	port-&gt;ip_tempowner   = 0;

	port-&gt;ip_guarded      = 0;
	port-&gt;ip_strict_guard = 0;
	port-&gt;ip_impcount    = 0;

	port-&gt;ip_reserved    = 0;

	ipc_mqueue_init(&amp;port-&gt;ip_messages,
			FALSE <span class="enscript-comment">/* !set */</span>, NULL <span class="enscript-comment">/* no reserved link */</span>);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_alloc
 *	Purpose:
 *		Allocate a port.
 *	Conditions:
 *		Nothing locked.  If successful, the port is returned
 *		locked.  (The caller doesn't have a reference.)
 *	Returns:
 *		KERN_SUCCESS		The port is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NO_SPACE		No room for an entry in the space.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_port_alloc</span>(
	ipc_space_t		space,
	mach_port_name_t	*namep,
	ipc_port_t		*portp)
{
	ipc_port_t port;
	mach_port_name_t name;
	kern_return_t kr;

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_ASSERT</span>
	uintptr_t buf[IP_CALLSTACK_MAX];
	ipc_port_callstack_init_debug(&amp;buf[0], IP_CALLSTACK_MAX);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>
	    
	kr = ipc_object_alloc(space, IOT_PORT,
			      MACH_PORT_TYPE_RECEIVE, 0,
			      &amp;name, (ipc_object_t *) &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* port and space are locked */</span>
	ipc_port_init(port, space, name);

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_ASSERT</span>
	ipc_port_init_debug(port, &amp;buf[0], IP_CALLSTACK_MAX);
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT */</span>

	<span class="enscript-comment">/* unlock space after init */</span>
	is_write_unlock(space);

	*namep = name;
	*portp = port;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_alloc_name
 *	Purpose:
 *		Allocate a port, with a specific name.
 *	Conditions:
 *		Nothing locked.  If successful, the port is returned
 *		locked.  (The caller doesn't have a reference.)
 *	Returns:
 *		KERN_SUCCESS		The port is allocated.
 *		KERN_INVALID_TASK	The space is dead.
 *		KERN_NAME_EXISTS	The name already denotes a right.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">ipc_port_alloc_name</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	ipc_port_t		*portp)
{
	ipc_port_t port;
	kern_return_t kr;

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_ASSERT</span>
	uintptr_t buf[IP_CALLSTACK_MAX];
	ipc_port_callstack_init_debug(&amp;buf[0], IP_CALLSTACK_MAX);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>	

	kr = ipc_object_alloc_name(space, IOT_PORT,
				   MACH_PORT_TYPE_RECEIVE, 0,
				   name, (ipc_object_t *) &amp;port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/* port is locked */</span>

	ipc_port_init(port, space, name);

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_ASSERT</span>
	ipc_port_init_debug(port, &amp;buf[0], IP_CALLSTACK_MAX);
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT */</span>	

	*portp = port;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * 	Routine:	ipc_port_spnotify
 *	Purpose:
 *		Generate send-possible port notifications.
 *	Conditions:
 *		Nothing locked, reference held on port.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_spnotify</span>(
	ipc_port_t	port)
{
	ipc_port_request_index_t index = 0;
	ipc_table_elems_t size = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	boolean_t dropassert = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-comment">/*
	 * If the port has no send-possible request
	 * armed, don't bother to lock the port.
	 */</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_sprequests == 0)
		<span class="enscript-keyword">return</span>;

	ip_lock(port);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_spimportant != 0) {
		port-&gt;ip_spimportant = 0;
		<span class="enscript-keyword">if</span> (ipc_port_impcount_delta(port, -1, IP_NULL) == -1) {
			dropassert = TRUE;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">if</span> (port-&gt;ip_sprequests == 0) {
		ip_unlock(port);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	port-&gt;ip_sprequests = 0;

<span class="enscript-reference">revalidate</span>:
	<span class="enscript-keyword">if</span> (ip_active(port)) {
		ipc_port_request_t requests;

		<span class="enscript-comment">/* table may change each time port unlocked (reload) */</span>
		requests = port-&gt;ip_requests;
		assert(requests != IPR_NULL);

		<span class="enscript-comment">/*
		 * no need to go beyond table size when first
		 * we entered - those are future notifications.
		 */</span>
		<span class="enscript-keyword">if</span> (size == 0)
			size = requests-&gt;ipr_size-&gt;its_size;

		<span class="enscript-comment">/* no need to backtrack either */</span>
		<span class="enscript-keyword">while</span> (++index &lt; size) {
			ipc_port_request_t ipr = &amp;requests[index];
			mach_port_name_t name = ipr-&gt;ipr_name;
			ipc_port_t soright = IPR_SOR_PORT(ipr-&gt;ipr_soright);
			boolean_t armed = IPR_SOR_SPARMED(ipr-&gt;ipr_soright);

			<span class="enscript-keyword">if</span> (MACH_PORT_VALID(name) &amp;&amp; armed &amp;&amp; IP_VALID(soright)) {
				<span class="enscript-comment">/* claim send-once right - slot still inuse */</span>
				ipr-&gt;ipr_soright = IP_NULL;
				ip_unlock(port);

				ipc_notify_send_possible(soright, name);

				ip_lock(port);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">revalidate</span>;
			}
		}
	}
	ip_unlock(port);
<span class="enscript-reference">out</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">if</span> (dropassert == TRUE &amp;&amp; ipc_importance_task_is_any_receiver_type(current_task()-&gt;task_imp_base)) {
		<span class="enscript-comment">/* drop internal assertion */</span>
		ipc_importance_task_drop_internal_assertion(current_task()-&gt;task_imp_base, 1);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * 	Routine:	ipc_port_dnnotify
 *	Purpose:
 *		Generate dead name notifications for
 *		all outstanding dead-name and send-
 *		possible requests.
 *	Conditions:
 *		Nothing locked.
 *		Port must be inactive.
 *		Reference held on port.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_dnnotify</span>(
	ipc_port_t	port)
{
	ipc_port_request_t requests = port-&gt;ip_requests;

	assert(!ip_active(port));
	<span class="enscript-keyword">if</span> (requests != IPR_NULL) {
		ipc_table_size_t its = requests-&gt;ipr_size;
		ipc_table_elems_t size = its-&gt;its_size;
		ipc_port_request_index_t index;
		<span class="enscript-keyword">for</span> (index = 1; index &lt; size; index++) {
			ipc_port_request_t ipr = &amp;requests[index];
			mach_port_name_t name = ipr-&gt;ipr_name;
			ipc_port_t soright = IPR_SOR_PORT(ipr-&gt;ipr_soright);

			<span class="enscript-keyword">if</span> (MACH_PORT_VALID(name) &amp;&amp; IP_VALID(soright)) {
				ipc_notify_dead_name(soright, name);
			}
		}
	}
}


<span class="enscript-comment">/*
 *	Routine:	ipc_port_destroy
 *	Purpose:
 *		Destroys a port.  Cleans up queued messages.
 *
 *		If the port has a backup, it doesn't get destroyed,
 *		but is sent in a port-destroyed notification to the backup.
 *	Conditions:
 *		The port is locked and alive; nothing else locked.
 *		The caller has a reference, which is consumed.
 *		Afterwards, the port is unlocked and dead.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_destroy</span>(
	ipc_port_t	port)
{
	ipc_port_t pdrequest, nsrequest;
	ipc_mqueue_t mqueue;
	ipc_kmsg_t kmsg;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t release_imp_task = IIT_NULL;
	thread_t self = current_thread();
	boolean_t top = (self-&gt;ith_assertions == 0);
	natural_t assertcnt = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	assert(ip_active(port));
	<span class="enscript-comment">/* port-&gt;ip_receiver_name is garbage */</span>
	<span class="enscript-comment">/* port-&gt;ip_receiver/port-&gt;ip_destination is garbage */</span>
	assert(port-&gt;ip_in_pset == 0);
	assert(port-&gt;ip_mscount == 0);

	<span class="enscript-comment">/* check for a backup port */</span>
	pdrequest = port-&gt;ip_pdrequest;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/* determine how many assertions to drop and from whom */</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_tempowner != 0) {
		assert(top);
		release_imp_task = port-&gt;ip_imp_task;
		<span class="enscript-keyword">if</span> (IIT_NULL != release_imp_task) {
			port-&gt;ip_imp_task = IIT_NULL;
			assertcnt = port-&gt;ip_impcount;
		}
		<span class="enscript-comment">/* Otherwise, nothing to drop */</span>
	} <span class="enscript-keyword">else</span> {
		assertcnt = port-&gt;ip_impcount;
		<span class="enscript-keyword">if</span> (pdrequest != IP_NULL)
			<span class="enscript-comment">/* mark in limbo for the journey */</span>
			port-&gt;ip_tempowner = 1;
	}

	<span class="enscript-keyword">if</span> (top)
		self-&gt;ith_assertions = assertcnt;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">if</span> (pdrequest != IP_NULL) {
		<span class="enscript-comment">/* we assume the ref for pdrequest */</span>
		port-&gt;ip_pdrequest = IP_NULL;

		<span class="enscript-comment">/* make port be in limbo */</span>
		port-&gt;ip_receiver_name = MACH_PORT_NULL;
		port-&gt;ip_destination = IP_NULL;
		ip_unlock(port);

		<span class="enscript-comment">/* consumes our refs for port and pdrequest */</span>
		ipc_notify_port_destroyed(pdrequest, port);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_assertions</span>;
	}

	<span class="enscript-comment">/* once port is dead, we don't need to keep it locked */</span>

	port-&gt;ip_object.io_bits &amp;= ~IO_BITS_ACTIVE;
	port-&gt;ip_timestamp = ipc_port_timestamp();
	nsrequest = port-&gt;ip_nsrequest;

	<span class="enscript-comment">/*
	 * If the port has a preallocated message buffer and that buffer
	 * is not inuse, free it.  If it has an inuse one, then the kmsg
	 * free will detect that we freed the association and it can free it
	 * like a normal buffer.
	 */</span>
	<span class="enscript-keyword">if</span> (IP_PREALLOC(port)) {
		ipc_port_t inuse_port;

		kmsg = port-&gt;ip_premsg;
		assert(kmsg != IKM_NULL);
		inuse_port = ikm_prealloc_inuse_port(kmsg);
		IP_CLEAR_PREALLOC(port, kmsg);
		ip_unlock(port);
		<span class="enscript-keyword">if</span> (inuse_port != IP_NULL) {
			assert(inuse_port == port);
		} <span class="enscript-keyword">else</span> {
			ipc_kmsg_free(kmsg);
		}
	} <span class="enscript-keyword">else</span> {
		ip_unlock(port);
	}

	<span class="enscript-comment">/* throw away no-senders request */</span>
	<span class="enscript-keyword">if</span> (nsrequest != IP_NULL)
		ipc_notify_send_once(nsrequest); <span class="enscript-comment">/* consumes ref */</span>

	<span class="enscript-comment">/* destroy any queued messages */</span>
	mqueue = &amp;port-&gt;ip_messages;
	ipc_mqueue_destroy(mqueue);

	<span class="enscript-comment">/* cleanup waitq related resources */</span>
	ipc_mqueue_deinit(mqueue);

	<span class="enscript-comment">/* generate dead-name notifications */</span>
	ipc_port_dnnotify(port);

	ipc_kobject_destroy(port);

	ip_release(port); <span class="enscript-comment">/* consume caller's ref */</span>

 <span class="enscript-reference">drop_assertions</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">if</span> (release_imp_task != IIT_NULL) {
		<span class="enscript-keyword">if</span> (assertcnt &gt; 0) {
			assert(top);
			self-&gt;ith_assertions = 0;
			assert(ipc_importance_task_is_any_receiver_type(release_imp_task));
			ipc_importance_task_drop_internal_assertion(release_imp_task, assertcnt);
		}
		ipc_importance_task_release(release_imp_task);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (assertcnt &gt; 0) {
		<span class="enscript-keyword">if</span> (top) {
			self-&gt;ith_assertions = 0;
			release_imp_task = current_task()-&gt;task_imp_base;
			<span class="enscript-keyword">if</span> (ipc_importance_task_is_any_receiver_type(release_imp_task)) {
				ipc_importance_task_drop_internal_assertion(release_imp_task, assertcnt);
			}
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_check_circularity
 *	Purpose:
 *		Check if queueing &quot;port&quot; in a message for &quot;dest&quot;
 *		would create a circular group of ports and messages.
 *
 *		If no circularity (FALSE returned), then &quot;port&quot;
 *		is changed from &quot;in limbo&quot; to &quot;in transit&quot;.
 *
 *		That is, we want to set port-&gt;ip_destination == dest,
 *		but guaranteeing that this doesn't create a circle
 *		port-&gt;ip_destination-&gt;ip_destination-&gt;... == port
 *
 *		Additionally, if port was successfully changed to &quot;in transit&quot;,
 *		propagate boost assertions from the &quot;in limbo&quot; port to all
 *		the ports in the chain, and, if the destination task accepts
 *		boosts, to the destination task.
 *
 *	Conditions:
 *		No ports locked.  References held for &quot;port&quot; and &quot;dest&quot;.
 */</span>

boolean_t
<span class="enscript-function-name">ipc_port_check_circularity</span>(
	ipc_port_t	port,
	ipc_port_t	dest)
{
	ipc_port_t base;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t imp_task = IIT_NULL;
	ipc_importance_task_t release_imp_task = IIT_NULL;
	<span class="enscript-type">int</span> assertcnt = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	assert(port != IP_NULL);
	assert(dest != IP_NULL);

	<span class="enscript-keyword">if</span> (port == dest)
		<span class="enscript-keyword">return</span> TRUE;
	base = dest;

	<span class="enscript-comment">/*
	 *	First try a quick check that can run in parallel.
	 *	No circularity if dest is not in transit.
	 */</span>

	ip_lock(port);
	<span class="enscript-keyword">if</span> (ip_lock_try(dest)) {
		<span class="enscript-keyword">if</span> (!ip_active(dest) ||
		    (dest-&gt;ip_receiver_name != MACH_PORT_NULL) ||
		    (dest-&gt;ip_destination == IP_NULL))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">not_circular</span>;

		<span class="enscript-comment">/* dest is in transit; further checking necessary */</span>

		ip_unlock(dest);
	}
	ip_unlock(port);

	ipc_port_multiple_lock(); <span class="enscript-comment">/* massive serialization */</span>

	<span class="enscript-comment">/*
	 *	Search for the end of the chain (a port not in transit),
	 *	acquiring locks along the way.
	 */</span>

	<span class="enscript-keyword">for</span> (;;) {
		ip_lock(base);

		<span class="enscript-keyword">if</span> (!ip_active(base) ||
		    (base-&gt;ip_receiver_name != MACH_PORT_NULL) ||
		    (base-&gt;ip_destination == IP_NULL))
			<span class="enscript-keyword">break</span>;

		base = base-&gt;ip_destination;
	}

	<span class="enscript-comment">/* all ports in chain from dest to base, inclusive, are locked */</span>

	<span class="enscript-keyword">if</span> (port == base) {
		<span class="enscript-comment">/* circularity detected! */</span>

		ipc_port_multiple_unlock();

		<span class="enscript-comment">/* port (== base) is in limbo */</span>

		assert(ip_active(port));
		assert(port-&gt;ip_receiver_name == MACH_PORT_NULL);
		assert(port-&gt;ip_destination == IP_NULL);

		<span class="enscript-keyword">while</span> (dest != IP_NULL) {
			ipc_port_t next;

			<span class="enscript-comment">/* dest is in transit or in limbo */</span>

			assert(ip_active(dest));
			assert(dest-&gt;ip_receiver_name == MACH_PORT_NULL);

			next = dest-&gt;ip_destination;
			ip_unlock(dest);
			dest = next;
		}

		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-comment">/*
	 *	The guarantee:  lock port while the entire chain is locked.
	 *	Once port is locked, we can take a reference to dest,
	 *	add port to the chain, and unlock everything.
	 */</span>

	ip_lock(port);
	ipc_port_multiple_unlock();

    <span class="enscript-reference">not_circular</span>:

	<span class="enscript-comment">/* port is in limbo */</span>

	assert(ip_active(port));
	assert(port-&gt;ip_receiver_name == MACH_PORT_NULL);
	assert(port-&gt;ip_destination == IP_NULL);

	ip_reference(dest);
	port-&gt;ip_destination = dest;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/* must have been in limbo or still bound to a task */</span>
	assert(port-&gt;ip_tempowner != 0);

	<span class="enscript-comment">/*
	 * We delayed dropping assertions from a specific task.
	 * Cache that info now (we'll drop assertions and the
	 * task reference below).
	 */</span>
	release_imp_task = port-&gt;ip_imp_task;
	<span class="enscript-keyword">if</span> (IIT_NULL != release_imp_task) {
		port-&gt;ip_imp_task = IIT_NULL;
	}
	assertcnt = port-&gt;ip_impcount;

	<span class="enscript-comment">/* take the port out of limbo w.r.t. assertions */</span>
	port-&gt;ip_tempowner = 0;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-comment">/* now unlock chain */</span>

	ip_unlock(port);

	<span class="enscript-keyword">for</span> (;;) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		<span class="enscript-comment">/* every port along chain track assertions behind it */</span>
		dest-&gt;ip_impcount += assertcnt;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		<span class="enscript-keyword">if</span> (dest == base)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* port is in transit */</span>

		assert(ip_active(dest));
		assert(dest-&gt;ip_receiver_name == MACH_PORT_NULL);
		assert(dest-&gt;ip_destination != IP_NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		assert(dest-&gt;ip_tempowner == 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		port = dest-&gt;ip_destination;
		ip_unlock(dest);
		dest = port;
	}

	<span class="enscript-comment">/* base is not in transit */</span>
	assert(!ip_active(base) ||
	       (base-&gt;ip_receiver_name != MACH_PORT_NULL) ||
	       (base-&gt;ip_destination == IP_NULL));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/*
	 * Find the task to boost (if any).
	 * We will boost &quot;through&quot; ports that don't know
	 * about inheritance to deliver receive rights that
	 * do.
	 */</span>
	<span class="enscript-keyword">if</span> (ip_active(base) &amp;&amp; (assertcnt &gt; 0)) {
		<span class="enscript-keyword">if</span> (base-&gt;ip_tempowner != 0) {
			<span class="enscript-keyword">if</span> (IIT_NULL != base-&gt;ip_imp_task) {
				<span class="enscript-comment">/* specified tempowner task */</span>
				imp_task = base-&gt;ip_imp_task;
				assert(ipc_importance_task_is_any_receiver_type(imp_task));
			}
			<span class="enscript-comment">/* otherwise don't boost current task */</span>

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (base-&gt;ip_receiver_name != MACH_PORT_NULL) {
			ipc_space_t space = base-&gt;ip_receiver;

			<span class="enscript-comment">/* only spaces with boost-accepting tasks */</span>
			<span class="enscript-keyword">if</span> (space-&gt;is_task != TASK_NULL &amp;&amp;
			    ipc_importance_task_is_any_receiver_type(space-&gt;is_task-&gt;task_imp_base))
				imp_task = space-&gt;is_task-&gt;task_imp_base;
		}

		<span class="enscript-comment">/* take reference before unlocking base */</span>
		<span class="enscript-keyword">if</span> (imp_task != IIT_NULL) {
			ipc_importance_task_reference(imp_task);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	ip_unlock(base);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/*
	 * Transfer assertions now that the ports are unlocked.
	 * Avoid extra overhead if transferring to/from the same task.
	 */</span>
	boolean_t transfer_assertions = (imp_task != release_imp_task) ? TRUE : FALSE;

	<span class="enscript-keyword">if</span> (imp_task != IIT_NULL) {
		<span class="enscript-keyword">if</span> (transfer_assertions)
			ipc_importance_task_hold_internal_assertion(imp_task, assertcnt);
		ipc_importance_task_release(imp_task);
		imp_task = IIT_NULL;
	}

	<span class="enscript-keyword">if</span> (release_imp_task != IIT_NULL) {
		<span class="enscript-keyword">if</span> (transfer_assertions)
			ipc_importance_task_drop_internal_assertion(release_imp_task, assertcnt);
		ipc_importance_task_release(release_imp_task);
		release_imp_task = IIT_NULL;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_impcount_delta
 *	Purpose:
 *		Adjust only the importance count associated with a port.
 *		If there are any adjustments to be made to receiver task,
 *		those are handled elsewhere.
 *
 *		For now, be defensive during deductions to make sure the
 *		impcount for the port doesn't underflow zero.  This will
 *		go away when the port boost addition is made atomic (see
 *		note in ipc_port_importance_delta()).
 *	Conditions:
 *		The port is referenced and locked.
 *		Nothing else is locked.
 */</span>
mach_port_delta_t
<span class="enscript-function-name">ipc_port_impcount_delta</span>(
	ipc_port_t        port,
	mach_port_delta_t delta,
	ipc_port_t        __unused base)
{
	mach_port_delta_t absdelta; 

	<span class="enscript-keyword">if</span> (!ip_active(port)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* adding/doing nothing is easy */</span>
	<span class="enscript-keyword">if</span> (delta &gt;= 0) {
		port-&gt;ip_impcount += delta;
		<span class="enscript-keyword">return</span> delta;
	}

	absdelta = 0 - delta;		
	<span class="enscript-comment">//assert(port-&gt;ip_impcount &gt;= absdelta);
</span>	<span class="enscript-comment">/* if we have enough to deduct, we're done */</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_impcount &gt;= absdelta) {
		port-&gt;ip_impcount -= absdelta;
		<span class="enscript-keyword">return</span> delta;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (port-&gt;ip_receiver_name != MACH_PORT_NULL) {
		task_t target_task = port-&gt;ip_receiver-&gt;is_task;
		ipc_importance_task_t target_imp = target_task-&gt;task_imp_base;
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *target_procname;
		<span class="enscript-type">int</span> target_pid;

		<span class="enscript-keyword">if</span> (target_imp != IIT_NULL) {
			target_procname = target_imp-&gt;iit_procname;
			target_pid = target_imp-&gt;iit_bsd_pid;
		} <span class="enscript-keyword">else</span> {
			target_procname = <span class="enscript-string">&quot;unknown&quot;</span>;
			target_pid = -1;
		}
		printf(<span class="enscript-string">&quot;Over-release of importance assertions for port 0x%x receiver pid %d (%s), &quot;</span>
		       <span class="enscript-string">&quot;dropping %d assertion(s) but port only has %d remaining.\n&quot;</span>,
		       port-&gt;ip_receiver_name, 
		       target_imp-&gt;iit_bsd_pid, target_imp-&gt;iit_procname,
		       absdelta, port-&gt;ip_impcount);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (base != IP_NULL) {
		task_t target_task = base-&gt;ip_receiver-&gt;is_task;
		ipc_importance_task_t target_imp = target_task-&gt;task_imp_base;
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *target_procname;
		<span class="enscript-type">int</span> target_pid;

		<span class="enscript-keyword">if</span> (target_imp != IIT_NULL) {
			target_procname = target_imp-&gt;iit_procname;
			target_pid = target_imp-&gt;iit_bsd_pid;
		} <span class="enscript-keyword">else</span> {
			target_procname = <span class="enscript-string">&quot;unknown&quot;</span>;
			target_pid = -1;
		}
		printf(<span class="enscript-string">&quot;Over-release of importance assertions for port %p &quot;</span>
		       <span class="enscript-string">&quot;enqueued on port 0x%x with receiver pid %d (%s), &quot;</span>
		       <span class="enscript-string">&quot;dropping %d assertion(s) but port only has %d remaining.\n&quot;</span>,
		       port, base-&gt;ip_receiver_name, 
		       target_imp-&gt;iit_bsd_pid, target_imp-&gt;iit_procname,
		       absdelta, port-&gt;ip_impcount);
	}
#<span class="enscript-reference">endif</span>
	delta = 0 - port-&gt;ip_impcount;
	port-&gt;ip_impcount = 0;
	<span class="enscript-keyword">return</span> delta;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_importance_delta_internal
 *	Purpose:
 *		Adjust the importance count through the given port.
 *		If the port is in transit, apply the delta throughout
 *		the chain. Determine if the there is a task at the
 *		base of the chain that wants/needs to be adjusted,
 *		and if so, apply the delta.
 *	Conditions:
 *		The port is referenced and locked on entry.
 *		Nothing else is locked.
 *		The lock may be dropped on exit.
 *		Returns TRUE if lock was dropped.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>

boolean_t
<span class="enscript-function-name">ipc_port_importance_delta_internal</span>(
	ipc_port_t 		port,
	mach_port_delta_t	*deltap,
	ipc_importance_task_t	*imp_task)
{
	ipc_port_t next, base;
	boolean_t dropped = FALSE;

	*imp_task = IIT_NULL;

	<span class="enscript-keyword">if</span> (*deltap == 0)
		<span class="enscript-keyword">return</span> FALSE;

	base = port;

	<span class="enscript-comment">/* if port is in transit, have to search for end of chain */</span>
	<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
	    port-&gt;ip_destination != IP_NULL &amp;&amp;
	    port-&gt;ip_receiver_name == MACH_PORT_NULL) {

		dropped = TRUE;

		ip_unlock(port);
		ipc_port_multiple_lock(); <span class="enscript-comment">/* massive serialization */</span>
		ip_lock(base);

		<span class="enscript-keyword">while</span>(ip_active(base) &amp;&amp;
		      base-&gt;ip_destination != IP_NULL &amp;&amp;
		      base-&gt;ip_receiver_name == MACH_PORT_NULL) {

			base = base-&gt;ip_destination;
			ip_lock(base);
		}
		ipc_port_multiple_unlock();
	}

	<span class="enscript-comment">/* unlock down to the base, adding a boost at each level */</span>
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-comment">/*
		 * JMM TODO - because of the port unlock to grab the multiple lock
		 * above, a subsequent drop of importance could race and beat
		 * the &quot;previous&quot; increase - causing the port impcount to go
		 * negative briefly.  The defensive deduction performed by
		 * ipc_port_impcount_delta() defeats that, and therefore can
		 * cause an importance leak once the increase finally arrives.
		 *
		 * Need to rework the importance delta logic to be more like
		 * ipc_importance_inherit_from() where it locks all it needs in
		 * one pass to avoid any lock drops - to keep that race from
		 * ever occuring.
		 */</span>
		*deltap = ipc_port_impcount_delta(port, *deltap, base);

		<span class="enscript-keyword">if</span> (port == base) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* port is in transit */</span>
		assert(port-&gt;ip_tempowner == 0);
		next = port-&gt;ip_destination;
		ip_unlock(port);
		port = next;
	}

	<span class="enscript-comment">/* find the task (if any) to boost according to the base */</span>
	<span class="enscript-keyword">if</span> (ip_active(base)) {
		<span class="enscript-keyword">if</span> (base-&gt;ip_tempowner != 0) {
			<span class="enscript-keyword">if</span> (IIT_NULL != base-&gt;ip_imp_task)
				*imp_task = base-&gt;ip_imp_task;
			<span class="enscript-comment">/* otherwise don't boost */</span>

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (base-&gt;ip_receiver_name != MACH_PORT_NULL) {
			ipc_space_t space = base-&gt;ip_receiver;

			<span class="enscript-comment">/* only spaces with boost-accepting tasks */</span>
			<span class="enscript-keyword">if</span> (space-&gt;is_task != TASK_NULL &amp;&amp;
			    ipc_importance_task_is_any_receiver_type(space-&gt;is_task-&gt;task_imp_base)) {
				*imp_task = space-&gt;is_task-&gt;task_imp_base;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Only the base is locked.  If we have to hold or drop task
	 * importance assertions, we'll have to drop that lock as well.
	 */</span>
	<span class="enscript-keyword">if</span> (*imp_task != IIT_NULL) {
		<span class="enscript-comment">/* take a reference before unlocking base */</span>
		ipc_importance_task_reference(*imp_task);
	}

	<span class="enscript-keyword">if</span> (dropped == TRUE) {
		ip_unlock(base);
	}

	<span class="enscript-keyword">return</span> dropped;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

<span class="enscript-comment">/*
 *	Routine:	ipc_port_importance_delta
 *	Purpose:
 *		Adjust the importance count through the given port.
 *		If the port is in transit, apply the delta throughout
 *		the chain.
 *
 *		If there is a task at the base of the chain that wants/needs
 *		to be adjusted, apply the delta.
 *	Conditions:
 *		The port is referenced and locked on entry.
 *		Nothing else is locked.
 *		The lock may be dropped on exit.
 *		Returns TRUE if lock was dropped.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>

boolean_t
<span class="enscript-function-name">ipc_port_importance_delta</span>(
	ipc_port_t 		port,
	mach_port_delta_t	delta)
{
	ipc_importance_task_t imp_task = IIT_NULL;
	boolean_t dropped;

	dropped = ipc_port_importance_delta_internal(port, &amp;delta, &amp;imp_task);

	<span class="enscript-keyword">if</span> (IIT_NULL == imp_task)
		<span class="enscript-keyword">return</span> dropped;

	<span class="enscript-keyword">if</span> (!dropped) {
		dropped = TRUE;
		ip_unlock(port);
	}

	assert(ipc_importance_task_is_any_receiver_type(imp_task));

	<span class="enscript-keyword">if</span> (delta &gt; 0)
		ipc_importance_task_hold_internal_assertion(imp_task, delta);
	<span class="enscript-keyword">else</span>
		ipc_importance_task_drop_internal_assertion(imp_task, -delta);

	ipc_importance_task_release(imp_task);
	<span class="enscript-keyword">return</span> dropped;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

<span class="enscript-comment">/*
 *	Routine:	ipc_port_lookup_notify
 *	Purpose:
 *		Make a send-once notify port from a receive right.
 *		Returns IP_NULL if name doesn't denote a receive right.
 *	Conditions:
 *		The space must be locked (read or write) and active.
 *  		Being the active space, we can rely on thread server_id
 *		context to give us the proper server level sub-order
 *		within the space.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_lookup_notify</span>(
	ipc_space_t		space,
	mach_port_name_t	name)
{
	ipc_port_t port;
	ipc_entry_t entry;

	assert(is_active(space));

	entry = ipc_entry_lookup(space, name);
	<span class="enscript-keyword">if</span> (entry == IE_NULL)
		<span class="enscript-keyword">return</span> IP_NULL;
	<span class="enscript-keyword">if</span> ((entry-&gt;ie_bits &amp; MACH_PORT_TYPE_RECEIVE) == 0)
		<span class="enscript-keyword">return</span> IP_NULL;

	__IGNORE_WCASTALIGN(port = (ipc_port_t) entry-&gt;ie_object);
	assert(port != IP_NULL);

	ip_lock(port);
	assert(ip_active(port));
	assert(port-&gt;ip_receiver_name == name);
	assert(port-&gt;ip_receiver == space);

	ip_reference(port);
	port-&gt;ip_sorights++;
	ip_unlock(port);

	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_make_send_locked
 *	Purpose:
 *		Make a naked send right from a receive right.
 *
 *	Conditions:
 *		port locked and active.
 */</span>
ipc_port_t
<span class="enscript-function-name">ipc_port_make_send_locked</span>(
	ipc_port_t	port)
{
	assert(ip_active(port));
	port-&gt;ip_mscount++;
	port-&gt;ip_srights++;
	ip_reference(port);
	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_make_send
 *	Purpose:
 *		Make a naked send right from a receive right.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_make_send</span>(
	ipc_port_t	port)
{
	
	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span> port;

	ip_lock(port);
	<span class="enscript-keyword">if</span> (ip_active(port)) {
		port-&gt;ip_mscount++;
		port-&gt;ip_srights++;
		ip_reference(port);
		ip_unlock(port);
		<span class="enscript-keyword">return</span> port;
	}
	ip_unlock(port);
	<span class="enscript-keyword">return</span> IP_DEAD;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_copy_send
 *	Purpose:
 *		Make a naked send right from another naked send right.
 *			IP_NULL		-&gt; IP_NULL
 *			IP_DEAD		-&gt; IP_DEAD
 *			dead port	-&gt; IP_DEAD
 *			live port	-&gt; port + ref
 *	Conditions:
 *		Nothing locked except possibly a space.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_copy_send</span>(
	ipc_port_t	port)
{
	ipc_port_t sright;

	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span> port;

	ip_lock(port);
	<span class="enscript-keyword">if</span> (ip_active(port)) {
		assert(port-&gt;ip_srights &gt; 0);

		ip_reference(port);
		port-&gt;ip_srights++;
		sright = port;
	} <span class="enscript-keyword">else</span>
		sright = IP_DEAD;
	ip_unlock(port);

	<span class="enscript-keyword">return</span> sright;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_copyout_send
 *	Purpose:
 *		Copyout a naked send right (possibly null/dead),
 *		or if that fails, destroy the right.
 *	Conditions:
 *		Nothing locked.
 */</span>

mach_port_name_t
<span class="enscript-function-name">ipc_port_copyout_send</span>(
	ipc_port_t	sright,
	ipc_space_t	space)
{
	mach_port_name_t name;

	<span class="enscript-keyword">if</span> (IP_VALID(sright)) {
		kern_return_t kr;

		kr = ipc_object_copyout(space, (ipc_object_t) sright,
					MACH_MSG_TYPE_PORT_SEND, TRUE, &amp;name);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			ipc_port_release_send(sright);

			<span class="enscript-keyword">if</span> (kr == KERN_INVALID_CAPABILITY)
				name = MACH_PORT_DEAD;
			<span class="enscript-keyword">else</span>
				name = MACH_PORT_NULL;
		}
	} <span class="enscript-keyword">else</span>
		name = CAST_MACH_PORT_TO_NAME(sright);

	<span class="enscript-keyword">return</span> name;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_release_send
 *	Purpose:
 *		Release a naked send right.
 *		Consumes a ref for the port.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_release_send</span>(
	ipc_port_t	port)
{
	ipc_port_t nsrequest = IP_NULL;
	mach_port_mscount_t mscount;

	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span>;

	ip_lock(port);

	assert(port-&gt;ip_srights &gt; 0);
	port-&gt;ip_srights--;

	<span class="enscript-keyword">if</span> (!ip_active(port)) {
		ip_unlock(port);
		ip_release(port);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (port-&gt;ip_srights == 0 &amp;&amp;
	    port-&gt;ip_nsrequest != IP_NULL) {
		nsrequest = port-&gt;ip_nsrequest;
		port-&gt;ip_nsrequest = IP_NULL;
		mscount = port-&gt;ip_mscount;
		ip_unlock(port);
		ip_release(port);
		ipc_notify_no_senders(nsrequest, mscount);
	} <span class="enscript-keyword">else</span> {
		ip_unlock(port);
		ip_release(port);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_make_sonce_locked
 *	Purpose:
 *		Make a naked send-once right from a receive right.
 *	Conditions:
 *		The port is locked and active.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_make_sonce_locked</span>(
	ipc_port_t	port)
{
	assert(ip_active(port));
	port-&gt;ip_sorights++;
	ip_reference(port);
	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_make_sonce
 *	Purpose:
 *		Make a naked send-once right from a receive right.
 *	Conditions:
 *		The port is not locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_make_sonce</span>(
	ipc_port_t	port)
{
	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span> port;

	ip_lock(port);
	<span class="enscript-keyword">if</span> (ip_active(port)) {
		port-&gt;ip_sorights++;
		ip_reference(port);
		ip_unlock(port);
		<span class="enscript-keyword">return</span> port;
	}
	ip_unlock(port);
	<span class="enscript-keyword">return</span> IP_DEAD;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_release_sonce
 *	Purpose:
 *		Release a naked send-once right.
 *		Consumes a ref for the port.
 *
 *		In normal situations, this is never used.
 *		Send-once rights are only consumed when
 *		a message (possibly a send-once notification)
 *		is sent to them.
 *	Conditions:
 *		Nothing locked except possibly a space.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_release_sonce</span>(
	ipc_port_t	port)
{
	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span>;

	ip_lock(port);

	assert(port-&gt;ip_sorights &gt; 0);

	port-&gt;ip_sorights--;

	ip_unlock(port);
	ip_release(port);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_release_receive
 *	Purpose:
 *		Release a naked (in limbo or in transit) receive right.
 *		Consumes a ref for the port; destroys the port.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_release_receive</span>(
	ipc_port_t	port)
{
	ipc_port_t dest;

	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span>;

	ip_lock(port);
	assert(ip_active(port));
	assert(port-&gt;ip_receiver_name == MACH_PORT_NULL);
	dest = port-&gt;ip_destination;

	ipc_port_destroy(port); <span class="enscript-comment">/* consumes ref, unlocks */</span>

	<span class="enscript-keyword">if</span> (dest != IP_NULL)
		ip_release(dest);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_alloc_special
 *	Purpose:
 *		Allocate a port in a special space.
 *		The new port is returned with one ref.
 *		If unsuccessful, IP_NULL is returned.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">ipc_port_alloc_special</span>(
	ipc_space_t	space)
{
	ipc_port_t port;

	__IGNORE_WCASTALIGN(port = (ipc_port_t) io_alloc(IOT_PORT));
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		<span class="enscript-keyword">return</span> IP_NULL;

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_ASSERT</span>
	uintptr_t buf[IP_CALLSTACK_MAX];
	ipc_port_callstack_init_debug(&amp;buf[0], IP_CALLSTACK_MAX);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>	

	bzero((<span class="enscript-type">char</span> *)port, <span class="enscript-keyword">sizeof</span>(*port));
	io_lock_init(&amp;port-&gt;ip_object);
	port-&gt;ip_references = 1;
	port-&gt;ip_object.io_bits = io_makebits(TRUE, IOT_PORT, 0);

	ipc_port_init(port, space, 1);

#<span class="enscript-reference">if</span>     <span class="enscript-variable-name">MACH_ASSERT</span>
	ipc_port_init_debug(port, &amp;buf[0], IP_CALLSTACK_MAX);
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* MACH_ASSERT */</span>		

	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_dealloc_special
 *	Purpose:
 *		Deallocate a port in a special space.
 *		Consumes one ref for the port.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_dealloc_special</span>(
	ipc_port_t			port,
	__assert_only ipc_space_t	space)
{
	ip_lock(port);
	assert(ip_active(port));
<span class="enscript-comment">//	assert(port-&gt;ip_receiver_name != MACH_PORT_NULL);
</span>	assert(port-&gt;ip_receiver == space);

	<span class="enscript-comment">/*
	 *	We clear ip_receiver_name and ip_receiver to simplify
	 *	the ipc_space_kernel check in ipc_mqueue_send.
	 */</span>

	port-&gt;ip_receiver_name = MACH_PORT_NULL;
	port-&gt;ip_receiver = IS_NULL;

	<span class="enscript-comment">/* relevant part of ipc_port_clear_receiver */</span>
	ipc_port_set_mscount(port, 0);
	port-&gt;ip_messages.imq_seqno = 0;

	ipc_port_destroy(port);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_finalize
 *	Purpose:
 *		Called on last reference deallocate to
 *		free any remaining data associated with the
 *		port.
 *	Conditions:
 *		Nothing locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_finalize</span>(
	ipc_port_t		port)
{
	ipc_port_request_t requests = port-&gt;ip_requests;

	assert(!ip_active(port));
	<span class="enscript-keyword">if</span> (requests != IPR_NULL) {
		ipc_table_size_t its = requests-&gt;ipr_size;
		it_requests_free(its, requests);
		port-&gt;ip_requests = IPR_NULL;
	}

	ipc_mqueue_deinit(&amp;port-&gt;ip_messages);
	
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>
	ipc_port_track_dealloc(port);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>

<span class="enscript-comment">/*
 *	Keep a list of all allocated ports.
 *	Allocation is intercepted via ipc_port_init;
 *	deallocation is intercepted via io_free.
 */</span>
#<span class="enscript-reference">if</span> 0
queue_head_t	port_alloc_queue;
lck_spin_t	port_alloc_queue_lock;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>	port_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>	port_count_warning = 20000;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>	port_timestamp = 0;

<span class="enscript-type">void</span>		db_port_stack_trace(
			ipc_port_t	port);
<span class="enscript-type">void</span>		db_ref(
			<span class="enscript-type">int</span>		refs);
<span class="enscript-type">int</span>		db_port_walk(
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	verbose,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	display,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ref_search,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ref_target);

<span class="enscript-comment">/*
 *	Initialize global state needed for run-time
 *	port debugging.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_debug_init</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> 0
	queue_init(&amp;port_alloc_queue);
	lck_spin_init(&amp;port_alloc_queue_lock, &amp;ipc_lck_grp, &amp;ipc_lck_attr);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;ipc_portbt&quot;</span>, &amp;ipc_portbt, <span class="enscript-keyword">sizeof</span> (ipc_portbt)))
		ipc_portbt = 0;
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_pid</span>(<span class="enscript-type">struct</span> proc*);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>

<span class="enscript-comment">/*
 *	Initialize all of the debugging state in a port.
 *	Insert the port into a global list of all allocated ports.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_init_debug</span>(
	ipc_port_t	port,
	uintptr_t 	*callstack,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	callstack_max)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;

	port-&gt;ip_thread = current_thread();
	port-&gt;ip_timetrack = port_timestamp++;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; callstack_max; ++i)
		port-&gt;ip_callstack[i] = callstack[i];	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IP_NSPARES; ++i)
		port-&gt;ip_spares[i] = 0;	

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	task_t task = current_task();
	<span class="enscript-keyword">if</span> (task != TASK_NULL) {
		<span class="enscript-type">struct</span> proc* proc = (<span class="enscript-type">struct</span> proc*) get_bsdtask_info(task);
		<span class="enscript-keyword">if</span> (proc)
			port-&gt;ip_spares[0] = proc_pid(proc);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>

#<span class="enscript-reference">if</span> 0
	lck_spin_lock(&amp;port_alloc_queue_lock);
	++port_count;
	<span class="enscript-keyword">if</span> (port_count_warning &gt; 0 &amp;&amp; port_count &gt;= port_count_warning)
		assert(port_count &lt; port_count_warning);
	queue_enter(&amp;port_alloc_queue, port, ipc_port_t, ip_port_links);
	lck_spin_unlock(&amp;port_alloc_queue_lock);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 *	Routine:	ipc_port_callstack_init_debug
 *	Purpose:
 *		Calls the machine-dependent routine to
 *		fill in an array with up to IP_CALLSTACK_MAX
 *		levels of return pc information
 *	Conditions:
 *		May block (via copyin)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_callstack_init_debug</span>(
	uintptr_t	*callstack,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	callstack_max)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;

	<span class="enscript-comment">/* guarantee the callstack is initialized */</span>
	<span class="enscript-keyword">for</span> (i=0; i &lt; callstack_max; i++)
		callstack[i] = 0;	

	<span class="enscript-keyword">if</span> (ipc_portbt)
		machine_callstack(callstack, callstack_max);
}

<span class="enscript-comment">/*
 *	Remove a port from the queue of allocated ports.
 *	This routine should be invoked JUST prior to
 *	deallocating the actual memory occupied by the port.
 */</span>
#<span class="enscript-reference">if</span> 1
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_track_dealloc</span>(
	__unused ipc_port_t	port)
{
}
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_port_track_dealloc</span>(
	ipc_port_t		port)
{
	lck_spin_lock(&amp;port_alloc_queue_lock);
	assert(port_count &gt; 0);
	--port_count;
	queue_remove(&amp;port_alloc_queue, port, ipc_port_t, ip_port_links);
	lck_spin_unlock(&amp;port_alloc_queue_lock);
}
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>
</pre>
<hr />
</body></html>