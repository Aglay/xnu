<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>lapic_native.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">lapic_native.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/lapic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/postcode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_threads.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tsc.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_check.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MP_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAUSE</span>		delay(1000000)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)	kprintf(x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PAUSE</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MP_DEBUG */</span>

lapic_ops_table_t	*lapic_ops;	<span class="enscript-comment">/* Lapic operations switch */</span>

<span class="enscript-type">static</span> vm_map_offset_t	lapic_pbase;	<span class="enscript-comment">/* Physical base memory-mapped regs */</span>
<span class="enscript-type">static</span> vm_offset_t	lapic_vbase;	<span class="enscript-comment">/* Virtual base memory-mapped regs */</span>

<span class="enscript-type">static</span> i386_intr_func_t	lapic_intr_func[LAPIC_FUNC_TABLE_SIZE];

<span class="enscript-comment">/* TRUE if local APIC was enabled by the OS not by the BIOS */</span>
<span class="enscript-type">static</span> boolean_t lapic_os_enabled = FALSE;

<span class="enscript-type">static</span> boolean_t lapic_errors_masked = FALSE;
<span class="enscript-type">static</span> uint64_t lapic_last_master_error = 0;
<span class="enscript-type">static</span> uint64_t lapic_error_time_threshold = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> lapic_master_error_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> lapic_error_count_threshold = 5;
<span class="enscript-type">static</span> boolean_t lapic_dont_panic = FALSE;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MP_DEBUG</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_cpu_map_dump</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>	i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_CPUS; i++) {
		<span class="enscript-keyword">if</span> (cpu_to_lapic[i] == -1)
			<span class="enscript-keyword">continue</span>;
		kprintf(<span class="enscript-string">&quot;cpu_to_lapic[%d]: %d\n&quot;</span>,
			i, cpu_to_lapic[i]);
	}
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_LAPICIDS; i++) {
		<span class="enscript-keyword">if</span> (lapic_to_cpu[i] == -1)
			<span class="enscript-keyword">continue</span>;
		kprintf(<span class="enscript-string">&quot;lapic_to_cpu[%d]: %d\n&quot;</span>,
			i, lapic_to_cpu[i]);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MP_DEBUG */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">legacy_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>		result;
	vm_map_entry_t	entry;
	vm_map_offset_t lapic_vbase64;
	<span class="enscript-comment">/* Establish a map to the local apic */</span>

	<span class="enscript-keyword">if</span> (lapic_vbase == 0) {
		lapic_vbase64 = (vm_offset_t)vm_map_min(kernel_map);
		result = vm_map_find_space(kernel_map,
					   &amp;lapic_vbase64,
					   round_page(LAPIC_SIZE), 0,
					   VM_MAKE_TAG(VM_KERN_MEMORY_IOKIT), &amp;entry);
		<span class="enscript-comment">/* Convert 64-bit vm_map_offset_t to &quot;pointer sized&quot; vm_offset_t
		 */</span>
		lapic_vbase = (vm_offset_t) lapic_vbase64;
		<span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
			panic(<span class="enscript-string">&quot;legacy_init: vm_map_find_entry FAILED (err=%d)&quot;</span>, result);
		}
		vm_map_unlock(kernel_map);

		<span class="enscript-comment">/*
		 * Map in the local APIC non-cacheable, as recommended by Intel
		 * in section 8.4.1 of the &quot;System Programming Guide&quot;.
		 * In fact, this is redundant because EFI will have assigned an
		 * MTRR physical range containing the local APIC's MMIO space as
		 * UC and this will override the default PAT setting.
		 */</span>
		pmap_enter(pmap_kernel(),
				lapic_vbase,
				(ppnum_t) i386_btop(lapic_pbase),
				VM_PROT_READ|VM_PROT_WRITE,
				VM_PROT_NONE,
				VM_WIMG_IO,
				TRUE);
	}

	<span class="enscript-comment">/*
	 * Set flat delivery model, logical processor id
	 * This should already be the default set.
	 */</span>
	LAPIC_WRITE(DFR, LAPIC_DFR_FLAT);
	LAPIC_WRITE(LDR, (get_cpu_number()) &lt;&lt; LAPIC_LDR_SHIFT);
}


<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">legacy_read</span>(lapic_register_t reg)
{
	<span class="enscript-keyword">return</span>  *LAPIC_MMIO(reg);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">legacy_write</span>(lapic_register_t reg, uint32_t value)
{
	*LAPIC_MMIO(reg) = value;
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">legacy_read_icr</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (((uint64_t)*LAPIC_MMIO(ICRD)) &lt;&lt; 32) | ((uint64_t)*LAPIC_MMIO(ICR));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">legacy_write_icr</span>(uint32_t dst, uint32_t cmd)
{
	*LAPIC_MMIO(ICRD) = dst &lt;&lt; LAPIC_ICRD_DEST_SHIFT;
	*LAPIC_MMIO(ICR) = cmd;
}

<span class="enscript-type">static</span> lapic_ops_table_t legacy_ops = {
	legacy_init,
	legacy_read,
	legacy_write,
	legacy_read_icr,
	legacy_write_icr
};

<span class="enscript-type">static</span>	boolean_t is_x2apic = FALSE;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x2apic_init</span>(<span class="enscript-type">void</span>)
{
	uint32_t	lo;
	uint32_t	hi;

	rdmsr(MSR_IA32_APIC_BASE, lo, hi);
	<span class="enscript-keyword">if</span> ((lo &amp; MSR_IA32_APIC_BASE_EXTENDED) == 0)  {
		lo |= MSR_IA32_APIC_BASE_EXTENDED;
		wrmsr(MSR_IA32_APIC_BASE, lo, hi);
		kprintf(<span class="enscript-string">&quot;x2APIC mode enabled\n&quot;</span>);
	}
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">x2apic_read</span>(lapic_register_t reg)
{
	uint32_t	lo;
	uint32_t	hi;

	rdmsr(LAPIC_MSR(reg), lo, hi);
	<span class="enscript-keyword">return</span> lo;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x2apic_write</span>(lapic_register_t reg, uint32_t value)
{
	wrmsr(LAPIC_MSR(reg), value, 0);
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">x2apic_read_icr</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> rdmsr64(LAPIC_MSR(ICR));;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x2apic_write_icr</span>(uint32_t dst, uint32_t cmd)
{
	  wrmsr(LAPIC_MSR(ICR), cmd, dst);
}

<span class="enscript-type">static</span> lapic_ops_table_t x2apic_ops = {
	x2apic_init,
	x2apic_read,
	x2apic_write,
	x2apic_read_icr,
	x2apic_write_icr
};

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_init</span>(<span class="enscript-type">void</span>)
{
	uint32_t	lo;
	uint32_t	hi;
	boolean_t	is_boot_processor;
	boolean_t	is_lapic_enabled;

	<span class="enscript-comment">/* Examine the local APIC state */</span>
	rdmsr(MSR_IA32_APIC_BASE, lo, hi);
	is_boot_processor = (lo &amp; MSR_IA32_APIC_BASE_BSP) != 0;
	is_lapic_enabled  = (lo &amp; MSR_IA32_APIC_BASE_ENABLE) != 0;
	is_x2apic         = (lo &amp; MSR_IA32_APIC_BASE_EXTENDED) != 0;
	lapic_pbase = (lo &amp;  MSR_IA32_APIC_BASE_BASE);
	kprintf(<span class="enscript-string">&quot;MSR_IA32_APIC_BASE 0x%llx %s %s mode %s\n&quot;</span>, lapic_pbase,
		is_lapic_enabled ? <span class="enscript-string">&quot;enabled&quot;</span> : <span class="enscript-string">&quot;disabled&quot;</span>,
		is_x2apic ? <span class="enscript-string">&quot;extended&quot;</span> : <span class="enscript-string">&quot;legacy&quot;</span>,
		is_boot_processor ? <span class="enscript-string">&quot;BSP&quot;</span> : <span class="enscript-string">&quot;AP&quot;</span>);
	<span class="enscript-keyword">if</span> (!is_boot_processor || !is_lapic_enabled)
		panic(<span class="enscript-string">&quot;Unexpected local APIC state\n&quot;</span>);

	<span class="enscript-comment">/*
	 * If x2APIC is available and not already enabled, enable it.
	 * Unless overriden by boot-arg.
	 */</span>
	<span class="enscript-keyword">if</span> (!is_x2apic &amp;&amp; (cpuid_features() &amp; CPUID_FEATURE_x2APIC)) {
		PE_parse_boot_argn(<span class="enscript-string">&quot;-x2apic&quot;</span>, &amp;is_x2apic, <span class="enscript-keyword">sizeof</span>(is_x2apic));
		kprintf(<span class="enscript-string">&quot;x2APIC supported %s be enabled\n&quot;</span>,
			is_x2apic ? <span class="enscript-string">&quot;and will&quot;</span> : <span class="enscript-string">&quot;but will not&quot;</span>);
	}

	lapic_ops = is_x2apic ? &amp;x2apic_ops : &amp;legacy_ops;

	LAPIC_INIT();

	kprintf(<span class="enscript-string">&quot;ID: 0x%x LDR: 0x%x\n&quot;</span>, LAPIC_READ(ID), LAPIC_READ(LDR));
	<span class="enscript-keyword">if</span> ((LAPIC_READ(VERSION)&amp;LAPIC_VERSION_MASK) &lt; 0x14) {
		panic(<span class="enscript-string">&quot;Local APIC version 0x%x, 0x14 or more expected\n&quot;</span>,
			(LAPIC_READ(VERSION)&amp;LAPIC_VERSION_MASK));
	}

	<span class="enscript-comment">/* Set up the lapic_id &lt;-&gt; cpu_number map and add this boot processor */</span>
	lapic_cpu_map_init();
	lapic_cpu_map((LAPIC_READ(ID)&gt;&gt;LAPIC_ID_SHIFT)&amp;LAPIC_ID_MASK, 0);
	current_cpu_datap()-&gt;cpu_phys_number = cpu_to_lapic[0];
	kprintf(<span class="enscript-string">&quot;Boot cpu local APIC id 0x%x\n&quot;</span>, cpu_to_lapic[0]);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lapic_esr_read</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* write-read register */</span>
	LAPIC_WRITE(ERROR_STATUS, 0);
	<span class="enscript-keyword">return</span> LAPIC_READ(ERROR_STATUS);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">lapic_esr_clear</span>(<span class="enscript-type">void</span>)
{
	LAPIC_WRITE(ERROR_STATUS, 0);
	LAPIC_WRITE(ERROR_STATUS, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *DM_str[8] = {
	<span class="enscript-string">&quot;Fixed&quot;</span>,
	<span class="enscript-string">&quot;Lowest Priority&quot;</span>,
	<span class="enscript-string">&quot;Invalid&quot;</span>,
	<span class="enscript-string">&quot;Invalid&quot;</span>,
	<span class="enscript-string">&quot;NMI&quot;</span>,
	<span class="enscript-string">&quot;Reset&quot;</span>,
	<span class="enscript-string">&quot;Invalid&quot;</span>,
	<span class="enscript-string">&quot;ExtINT&quot;</span>};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *TMR_str[] = {
	<span class="enscript-string">&quot;OneShot&quot;</span>,
	<span class="enscript-string">&quot;Periodic&quot;</span>,
	<span class="enscript-string">&quot;TSC-Deadline&quot;</span>,
	<span class="enscript-string">&quot;Illegal&quot;</span>
};

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_dump</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>	i;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BOOL</span>(a) ((a)?<span class="enscript-string">' '</span>:<span class="enscript-string">'!'</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VEC</span>(lvt) \
	LAPIC_READ(lvt)&amp;LAPIC_LVT_VECTOR_MASK
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DS</span>(lvt)	\
	(LAPIC_READ(lvt)&amp;LAPIC_LVT_DS_PENDING)?<span class="enscript-string">&quot; SendPending&quot;</span> : <span class="enscript-string">&quot;Idle&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DM</span>(lvt) \
	DM_str[(LAPIC_READ(lvt)&gt;&gt;LAPIC_LVT_DM_SHIFT)&amp;LAPIC_LVT_DM_MASK]
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MASK</span>(lvt) \
	BOOL(LAPIC_READ(lvt)&amp;LAPIC_LVT_MASKED)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TM</span>(lvt) \
	(LAPIC_READ(lvt)&amp;LAPIC_LVT_TM_LEVEL)? <span class="enscript-string">&quot;Level&quot;</span> : <span class="enscript-string">&quot;Edge&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP</span>(lvt) \
	(LAPIC_READ(lvt)&amp;LAPIC_LVT_IP_PLRITY_LOW)? <span class="enscript-string">&quot;Low &quot;</span> : <span class="enscript-string">&quot;High&quot;</span>

	kprintf(<span class="enscript-string">&quot;LAPIC %d at %p version 0x%x\n&quot;</span>, 
		(LAPIC_READ(ID)&gt;&gt;LAPIC_ID_SHIFT)&amp;LAPIC_ID_MASK,
		(<span class="enscript-type">void</span> *) lapic_vbase,
		LAPIC_READ(VERSION)&amp;LAPIC_VERSION_MASK);
	kprintf(<span class="enscript-string">&quot;Priorities: Task 0x%x  Arbitration 0x%x  Processor 0x%x\n&quot;</span>,
		LAPIC_READ(TPR)&amp;LAPIC_TPR_MASK,
		LAPIC_READ(APR)&amp;LAPIC_APR_MASK,
		LAPIC_READ(PPR)&amp;LAPIC_PPR_MASK);
	kprintf(<span class="enscript-string">&quot;Destination Format 0x%x Logical Destination 0x%x\n&quot;</span>,
		is_x2apic ? 0 : LAPIC_READ(DFR)&gt;&gt;LAPIC_DFR_SHIFT,
		LAPIC_READ(LDR)&gt;&gt;LAPIC_LDR_SHIFT);
	kprintf(<span class="enscript-string">&quot;%cEnabled %cFocusChecking SV 0x%x\n&quot;</span>,
		BOOL(LAPIC_READ(SVR)&amp;LAPIC_SVR_ENABLE),
		BOOL(!(LAPIC_READ(SVR)&amp;LAPIC_SVR_FOCUS_OFF)),
		LAPIC_READ(SVR) &amp; LAPIC_SVR_MASK);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
	<span class="enscript-keyword">if</span> (mca_is_cmci_present())
		kprintf(<span class="enscript-string">&quot;LVT_CMCI:    Vector 0x%02x [%s] %s %cmasked\n&quot;</span>,
			VEC(LVT_CMCI),
			DM(LVT_CMCI),
			DS(LVT_CMCI),
			MASK(LVT_CMCI));
#<span class="enscript-reference">endif</span>
	kprintf(<span class="enscript-string">&quot;LVT_TIMER:   Vector 0x%02x %s %cmasked %s\n&quot;</span>,
		VEC(LVT_TIMER),
		DS(LVT_TIMER),
		MASK(LVT_TIMER),
		TMR_str[(LAPIC_READ(LVT_TIMER) &gt;&gt; LAPIC_LVT_TMR_SHIFT)
                                               &amp;  LAPIC_LVT_TMR_MASK]);
	kprintf(<span class="enscript-string">&quot;  Initial Count: 0x%08x \n&quot;</span>, LAPIC_READ(TIMER_INITIAL_COUNT));
	kprintf(<span class="enscript-string">&quot;  Current Count: 0x%08x \n&quot;</span>, LAPIC_READ(TIMER_CURRENT_COUNT));
	kprintf(<span class="enscript-string">&quot;  Divide Config: 0x%08x \n&quot;</span>, LAPIC_READ(TIMER_DIVIDE_CONFIG));
	kprintf(<span class="enscript-string">&quot;LVT_PERFCNT: Vector 0x%02x [%s] %s %cmasked\n&quot;</span>,
		VEC(LVT_PERFCNT),
		DM(LVT_PERFCNT),
		DS(LVT_PERFCNT),
		MASK(LVT_PERFCNT));
	kprintf(<span class="enscript-string">&quot;LVT_THERMAL: Vector 0x%02x [%s] %s %cmasked\n&quot;</span>,
		VEC(LVT_THERMAL),
		DM(LVT_THERMAL),
		DS(LVT_THERMAL),
		MASK(LVT_THERMAL));
	kprintf(<span class="enscript-string">&quot;LVT_LINT0:   Vector 0x%02x [%s][%s][%s] %s %cmasked\n&quot;</span>,
		VEC(LVT_LINT0),
		DM(LVT_LINT0),
		TM(LVT_LINT0),
		IP(LVT_LINT0),
		DS(LVT_LINT0),
		MASK(LVT_LINT0));
	kprintf(<span class="enscript-string">&quot;LVT_LINT1:   Vector 0x%02x [%s][%s][%s] %s %cmasked\n&quot;</span>,
		VEC(LVT_LINT1),
		DM(LVT_LINT1),
		TM(LVT_LINT1),
		IP(LVT_LINT1),
		DS(LVT_LINT1),
		MASK(LVT_LINT1));
	kprintf(<span class="enscript-string">&quot;LVT_ERROR:   Vector 0x%02x %s %cmasked\n&quot;</span>,
		VEC(LVT_ERROR),
		DS(LVT_ERROR),
		MASK(LVT_ERROR));
	kprintf(<span class="enscript-string">&quot;ESR: %08x \n&quot;</span>, lapic_esr_read());
	kprintf(<span class="enscript-string">&quot;       &quot;</span>);
	<span class="enscript-keyword">for</span>(i=0xf; i&gt;=0; i--)
		kprintf(<span class="enscript-string">&quot;%x%x%x%x&quot;</span>,i,i,i,i);
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
	kprintf(<span class="enscript-string">&quot;TMR: 0x&quot;</span>);
	<span class="enscript-keyword">for</span>(i=7; i&gt;=0; i--)
		kprintf(<span class="enscript-string">&quot;%08x&quot;</span>,LAPIC_READ_OFFSET(TMR_BASE, i));
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
	kprintf(<span class="enscript-string">&quot;IRR: 0x&quot;</span>);
	<span class="enscript-keyword">for</span>(i=7; i&gt;=0; i--)
		kprintf(<span class="enscript-string">&quot;%08x&quot;</span>,LAPIC_READ_OFFSET(IRR_BASE, i));
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
	kprintf(<span class="enscript-string">&quot;ISR: 0x&quot;</span>);
	<span class="enscript-keyword">for</span>(i=7; i &gt;= 0; i--)
		kprintf(<span class="enscript-string">&quot;%08x&quot;</span>,LAPIC_READ_OFFSET(ISR_BASE, i));
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
}

boolean_t
<span class="enscript-function-name">lapic_probe</span>(<span class="enscript-type">void</span>)
{
	uint32_t	lo;
	uint32_t	hi;

	<span class="enscript-keyword">if</span> (cpuid_features() &amp; CPUID_FEATURE_APIC)
		<span class="enscript-keyword">return</span> TRUE;

	<span class="enscript-keyword">if</span> (cpuid_family() == 6 || cpuid_family() == 15) {
		<span class="enscript-comment">/*
		 * Mobile Pentiums:
		 * There may be a local APIC which wasn't enabled by BIOS.
		 * So we try to enable it explicitly.
		 */</span>
		rdmsr(MSR_IA32_APIC_BASE, lo, hi);
		lo &amp;= ~MSR_IA32_APIC_BASE_BASE;
		lo |= MSR_IA32_APIC_BASE_ENABLE | LAPIC_START;
		lo |= MSR_IA32_APIC_BASE_ENABLE;
		wrmsr(MSR_IA32_APIC_BASE, lo, hi);

		<span class="enscript-comment">/*
		 * Re-initialize cpu features info and re-check.
		 */</span>
		cpuid_set_info();
		<span class="enscript-comment">/* We expect this codepath will never be traversed
		 * due to EFI enabling the APIC. Reducing the APIC
		 * interrupt base dynamically is not supported.
		 */</span>
		<span class="enscript-keyword">if</span> (cpuid_features() &amp; CPUID_FEATURE_APIC) {
			printf(<span class="enscript-string">&quot;Local APIC discovered and enabled\n&quot;</span>);
			lapic_os_enabled = TRUE;
			lapic_interrupt_base = LAPIC_REDUCED_INTERRUPT_BASE;
			<span class="enscript-keyword">return</span> TRUE;
		}
	}

	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_shutdown</span>(<span class="enscript-type">void</span>)
{
	uint32_t lo;
	uint32_t hi;
	uint32_t value;

	<span class="enscript-comment">/* Shutdown if local APIC was enabled by OS */</span>
	<span class="enscript-keyword">if</span> (lapic_os_enabled == FALSE)
		<span class="enscript-keyword">return</span>;

	mp_disable_preemption();

	<span class="enscript-comment">/* ExtINT: masked */</span>
	<span class="enscript-keyword">if</span> (get_cpu_number() == master_cpu) {
		value = LAPIC_READ(LVT_LINT0);
		value |= LAPIC_LVT_MASKED;
		LAPIC_WRITE(LVT_LINT0, value);
	}

	<span class="enscript-comment">/* Error: masked */</span>
	LAPIC_WRITE(LVT_ERROR, LAPIC_READ(LVT_ERROR) | LAPIC_LVT_MASKED);

	<span class="enscript-comment">/* Timer: masked */</span>
	LAPIC_WRITE(LVT_TIMER, LAPIC_READ(LVT_TIMER) | LAPIC_LVT_MASKED);

	<span class="enscript-comment">/* Perfmon: masked */</span>
	LAPIC_WRITE(LVT_PERFCNT, LAPIC_READ(LVT_PERFCNT) | LAPIC_LVT_MASKED);

	<span class="enscript-comment">/* APIC software disabled */</span>
	LAPIC_WRITE(SVR, LAPIC_READ(SVR) &amp; ~LAPIC_SVR_ENABLE);

	<span class="enscript-comment">/* Bypass the APIC completely and update cpu features */</span>
	rdmsr(MSR_IA32_APIC_BASE, lo, hi);
	lo &amp;= ~MSR_IA32_APIC_BASE_ENABLE;
	wrmsr(MSR_IA32_APIC_BASE, lo, hi);
	cpuid_set_info();

	mp_enable_preemption();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_configure</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>	value;

	<span class="enscript-keyword">if</span> (lapic_error_time_threshold == 0 &amp;&amp; cpu_number() == 0) {
		nanoseconds_to_absolutetime(NSEC_PER_SEC &gt;&gt; 2, &amp;lapic_error_time_threshold);
		<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;lapic_dont_panic&quot;</span>, &amp;lapic_dont_panic, <span class="enscript-keyword">sizeof</span>(lapic_dont_panic))) {
			lapic_dont_panic = FALSE;
		}
	}

	<span class="enscript-comment">/* Accept all */</span>
	LAPIC_WRITE(TPR, 0);

	LAPIC_WRITE(SVR, LAPIC_VECTOR(SPURIOUS) | LAPIC_SVR_ENABLE);

	<span class="enscript-comment">/* ExtINT */</span>
	<span class="enscript-keyword">if</span> (get_cpu_number() == master_cpu) {
		value = LAPIC_READ(LVT_LINT0);
		value &amp;= ~LAPIC_LVT_MASKED;
		value |= LAPIC_LVT_DM_EXTINT;
		LAPIC_WRITE(LVT_LINT0, value);
	}

	<span class="enscript-comment">/* Timer: unmasked, one-shot */</span>
	LAPIC_WRITE(LVT_TIMER, LAPIC_VECTOR(TIMER));

	<span class="enscript-comment">/* Perfmon: unmasked */</span>
	LAPIC_WRITE(LVT_PERFCNT, LAPIC_VECTOR(PERFCNT));

	<span class="enscript-comment">/* Thermal: unmasked */</span>
	LAPIC_WRITE(LVT_THERMAL, LAPIC_VECTOR(THERMAL));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
	<span class="enscript-comment">/* CMCI, if available */</span>
	<span class="enscript-keyword">if</span> (mca_is_cmci_present())
		LAPIC_WRITE(LVT_CMCI, LAPIC_VECTOR(CMCI));
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (((cpu_number() == master_cpu) &amp;&amp; lapic_errors_masked == FALSE) ||
		(cpu_number() != master_cpu)) {
		lapic_esr_clear();
		LAPIC_WRITE(LVT_ERROR, LAPIC_VECTOR(ERROR));
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_set_timer</span>(
	boolean_t		interrupt_unmasked,
	lapic_timer_mode_t	mode,
	lapic_timer_divide_t	divisor,
	lapic_timer_count_t	initial_count)
{
	uint32_t	timer_vector;

	mp_disable_preemption();
	timer_vector = LAPIC_READ(LVT_TIMER);
	timer_vector &amp;= ~(LAPIC_LVT_MASKED|LAPIC_LVT_PERIODIC);;
	timer_vector |= interrupt_unmasked ? 0 : LAPIC_LVT_MASKED;
	timer_vector |= (mode == periodic) ? LAPIC_LVT_PERIODIC : 0;
	LAPIC_WRITE(LVT_TIMER, timer_vector);
	LAPIC_WRITE(TIMER_DIVIDE_CONFIG, divisor);
	LAPIC_WRITE(TIMER_INITIAL_COUNT, initial_count);
	mp_enable_preemption();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_config_timer</span>(
	boolean_t		interrupt_unmasked,
	lapic_timer_mode_t	mode,
	lapic_timer_divide_t	divisor)
{
	uint32_t	timer_vector;

	mp_disable_preemption();
	timer_vector = LAPIC_READ(LVT_TIMER);
	timer_vector &amp;= ~(LAPIC_LVT_MASKED |
			  LAPIC_LVT_PERIODIC |
			  LAPIC_LVT_TSC_DEADLINE);
	timer_vector |= interrupt_unmasked ? 0 : LAPIC_LVT_MASKED;
	timer_vector |= (mode == periodic) ? LAPIC_LVT_PERIODIC : 0;
	LAPIC_WRITE(LVT_TIMER, timer_vector);
	LAPIC_WRITE(TIMER_DIVIDE_CONFIG, divisor);
	mp_enable_preemption();
}

<span class="enscript-comment">/*
 * Configure TSC-deadline timer mode. The lapic interrupt is always unmasked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_config_tsc_deadline_timer</span>(<span class="enscript-type">void</span>)
{
	uint32_t	timer_vector;

	DBG(<span class="enscript-string">&quot;lapic_config_tsc_deadline_timer()\n&quot;</span>);
	mp_disable_preemption();
	timer_vector = LAPIC_READ(LVT_TIMER);
	timer_vector &amp;= ~(LAPIC_LVT_MASKED |
			  LAPIC_LVT_PERIODIC);
	timer_vector |= LAPIC_LVT_TSC_DEADLINE;
	LAPIC_WRITE(LVT_TIMER, timer_vector);

	<span class="enscript-comment">/* Serialize writes per Intel OSWG */</span>
	<span class="enscript-keyword">do</span> {
		lapic_set_tsc_deadline_timer(rdtsc64() + (1ULL&lt;&lt;32));
	} <span class="enscript-keyword">while</span> (lapic_get_tsc_deadline_timer() == 0);
	lapic_set_tsc_deadline_timer(0);

	mp_enable_preemption();
	DBG(<span class="enscript-string">&quot;lapic_config_tsc_deadline_timer() done\n&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_set_timer_fast</span>(
	lapic_timer_count_t	initial_count)
{
	LAPIC_WRITE(LVT_TIMER, LAPIC_READ(LVT_TIMER) &amp; ~LAPIC_LVT_MASKED);
	LAPIC_WRITE(TIMER_INITIAL_COUNT, initial_count);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_set_tsc_deadline_timer</span>(uint64_t deadline)
{
	<span class="enscript-comment">/* Don't bother disarming: wrmsr64(MSR_IA32_TSC_DEADLINE, 0); */</span>
	wrmsr64(MSR_IA32_TSC_DEADLINE, deadline);
}

uint64_t
<span class="enscript-function-name">lapic_get_tsc_deadline_timer</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> rdmsr64(MSR_IA32_TSC_DEADLINE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_get_timer</span>(
	lapic_timer_mode_t	*mode,
	lapic_timer_divide_t	*divisor,
	lapic_timer_count_t	*initial_count,
	lapic_timer_count_t	*current_count)
{
	mp_disable_preemption();
	<span class="enscript-keyword">if</span> (mode)
		*mode = (LAPIC_READ(LVT_TIMER) &amp; LAPIC_LVT_PERIODIC) ?
				periodic : one_shot;
	<span class="enscript-keyword">if</span> (divisor)
		*divisor = LAPIC_READ(TIMER_DIVIDE_CONFIG) &amp; LAPIC_TIMER_DIVIDE_MASK;
	<span class="enscript-keyword">if</span> (initial_count)
		*initial_count = LAPIC_READ(TIMER_INITIAL_COUNT);
	<span class="enscript-keyword">if</span> (current_count)
		*current_count = LAPIC_READ(TIMER_CURRENT_COUNT);
	mp_enable_preemption();
} 

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">_lapic_end_of_interrupt</span>(<span class="enscript-type">void</span>)
{
	LAPIC_WRITE(EOI, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_end_of_interrupt</span>(<span class="enscript-type">void</span>)
{
	_lapic_end_of_interrupt();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">lapic_unmask_perfcnt_interrupt</span>(<span class="enscript-type">void</span>) {
	LAPIC_WRITE(LVT_PERFCNT, LAPIC_VECTOR(PERFCNT));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">lapic_set_perfcnt_interrupt_mask</span>(boolean_t mask) {
	uint32_t m = (mask ? LAPIC_LVT_MASKED : 0);
	LAPIC_WRITE(LVT_PERFCNT, LAPIC_VECTOR(PERFCNT) | m);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_set_intr_func</span>(<span class="enscript-type">int</span> vector, i386_intr_func_t func)
{
	<span class="enscript-keyword">if</span> (vector &gt; lapic_interrupt_base)
		vector -= lapic_interrupt_base;

	<span class="enscript-keyword">switch</span> (vector) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_NMI_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_INTERPROCESSOR_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_TIMER_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_THERMAL_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_PERFCNT_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_CMCI_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_PM_INTERRUPT</span>:
		lapic_intr_func[vector] = func;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;lapic_set_intr_func(%d,%p) invalid vector\n&quot;</span>,
			vector, func);
	}
}

<span class="enscript-type">void</span>	lapic_set_pmi_func(i386_intr_func_t func) {
	lapic_set_intr_func(LAPIC_VECTOR(PERFCNT), func);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">lapic_interrupt</span>(<span class="enscript-type">int</span> interrupt_num, x86_saved_state_t *state)
{
	<span class="enscript-type">int</span>	retval = 0;
	<span class="enscript-type">int</span> 	esr = -1;

	interrupt_num -= lapic_interrupt_base;
	<span class="enscript-keyword">if</span> (interrupt_num &lt; 0) {
		<span class="enscript-keyword">if</span> (interrupt_num == (LAPIC_NMI_INTERRUPT - lapic_interrupt_base) &amp;&amp;
		    lapic_intr_func[LAPIC_NMI_INTERRUPT] != NULL) {
			retval = (*lapic_intr_func[LAPIC_NMI_INTERRUPT])(state);
			<span class="enscript-keyword">return</span> retval;
		}
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">switch</span>(interrupt_num) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_TIMER_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_THERMAL_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_INTERPROCESSOR_INTERRUPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_PM_INTERRUPT</span>:
		<span class="enscript-keyword">if</span> (lapic_intr_func[interrupt_num] != NULL)
			(<span class="enscript-type">void</span>) (*lapic_intr_func[interrupt_num])(state);
		_lapic_end_of_interrupt();
		retval = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_PERFCNT_INTERRUPT</span>:
		<span class="enscript-comment">/* If a function has been registered, invoke it.  Otherwise,
		 * pass up to IOKit.
		 */</span>
		<span class="enscript-keyword">if</span> (lapic_intr_func[interrupt_num] != NULL) {
			(<span class="enscript-type">void</span>) (*lapic_intr_func[interrupt_num])(state);
			<span class="enscript-comment">/* Unmask the interrupt since we don't expect legacy users
			 * to be responsible for it.
			 */</span>
			lapic_unmask_perfcnt_interrupt();
			_lapic_end_of_interrupt();
			retval = 1;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_CMCI_INTERRUPT</span>:
		<span class="enscript-keyword">if</span> (lapic_intr_func[interrupt_num] != NULL)
			(<span class="enscript-type">void</span>) (*lapic_intr_func[interrupt_num])(state);
		<span class="enscript-comment">/* return 0 for plaform expert to handle */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_ERROR_INTERRUPT</span>:
		<span class="enscript-comment">/* We treat error interrupts on APs as fatal.
		 * The current interrupt steering scheme directs most
		 * external interrupts to the BSP (HPET interrupts being
		 * a notable exception); hence, such an error
		 * on an AP may signify LVT corruption (with &quot;may&quot; being
		 * the operative word). On the BSP, we adopt a more
		 * lenient approach, in the interests of enhancing
		 * debuggability and reducing fragility.
		 * If &quot;lapic_error_count_threshold&quot; error interrupts
		 * occur within &quot;lapic_error_time_threshold&quot; absolute
		 * time units, we mask the error vector and log. The
		 * error interrupts themselves are likely
		 * side effects of issues which are beyond the purview of
		 * the local APIC interrupt handler, however. The Error
		 * Status Register value (the illegal destination
		 * vector code is one observed in practice) indicates
		 * the immediate cause of the error.
		 */</span>
		esr = lapic_esr_read();
		lapic_dump();

		<span class="enscript-keyword">if</span> ((debug_boot_arg &amp;&amp; (lapic_dont_panic == FALSE)) ||
			cpu_number() != master_cpu) {
			panic(<span class="enscript-string">&quot;Local APIC error, ESR: %d\n&quot;</span>, esr);
		}

		<span class="enscript-keyword">if</span> (cpu_number() == master_cpu) {
			uint64_t abstime = mach_absolute_time();
			<span class="enscript-keyword">if</span> ((abstime - lapic_last_master_error) &lt; lapic_error_time_threshold) {
				<span class="enscript-keyword">if</span> (lapic_master_error_count++ &gt; lapic_error_count_threshold) {
					lapic_errors_masked = TRUE;
					LAPIC_WRITE(LVT_ERROR, LAPIC_READ(LVT_ERROR) | LAPIC_LVT_MASKED);
					printf(<span class="enscript-string">&quot;Local APIC: errors masked\n&quot;</span>);
				}
			}
			<span class="enscript-keyword">else</span> {
				lapic_last_master_error = abstime;
				lapic_master_error_count = 0;
			}
			printf(<span class="enscript-string">&quot;Local APIC error on master CPU, ESR: %d, error count this run: %d\n&quot;</span>, esr, lapic_master_error_count);
		}

		_lapic_end_of_interrupt();
		retval = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_SPURIOUS_INTERRUPT</span>:
		kprintf(<span class="enscript-string">&quot;SPIV\n&quot;</span>);
		<span class="enscript-comment">/* No EOI required here */</span>
		retval = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_PMC_SW_INTERRUPT</span>: 
		{
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LAPIC_KICK_INTERRUPT</span>:
		_lapic_end_of_interrupt();
		retval = 1;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_smm_restore</span>(<span class="enscript-type">void</span>)
{
	boolean_t state;

	<span class="enscript-keyword">if</span> (lapic_os_enabled == FALSE)
		<span class="enscript-keyword">return</span>;

	state = ml_set_interrupts_enabled(FALSE);

 	<span class="enscript-keyword">if</span> (LAPIC_ISR_IS_SET(LAPIC_REDUCED_INTERRUPT_BASE, TIMER)) {
		<span class="enscript-comment">/*
		 * Bogus SMI handler enables interrupts but does not know about
		 * local APIC interrupt sources. When APIC timer counts down to
		 * zero while in SMM, local APIC will end up waiting for an EOI
		 * but no interrupt was delivered to the OS.
 		 */</span>
		_lapic_end_of_interrupt();

		<span class="enscript-comment">/*
		 * timer is one-shot, trigger another quick countdown to trigger
		 * another timer interrupt.
		 */</span>
		<span class="enscript-keyword">if</span> (LAPIC_READ(TIMER_CURRENT_COUNT) == 0) {
			LAPIC_WRITE(TIMER_INITIAL_COUNT, 1);
		}

		kprintf(<span class="enscript-string">&quot;lapic_smm_restore\n&quot;</span>);
	}

	ml_set_interrupts_enabled(state);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_send_ipi</span>(<span class="enscript-type">int</span> cpu, <span class="enscript-type">int</span> vector)
{
	boolean_t	state;

	<span class="enscript-keyword">if</span> (vector &lt; lapic_interrupt_base)
		vector += lapic_interrupt_base;

	state = ml_set_interrupts_enabled(FALSE);

	<span class="enscript-comment">/* Wait for pending outgoing send to complete */</span>
	<span class="enscript-keyword">while</span> (LAPIC_READ_ICR() &amp; LAPIC_ICR_DS_PENDING) {
		cpu_pause();
	}

	LAPIC_WRITE_ICR(cpu_to_lapic[cpu], vector | LAPIC_ICR_DM_FIXED);

	(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(state);
}

<span class="enscript-comment">/*
 * The following interfaces are privately exported to AICPM.
 */</span>

boolean_t
<span class="enscript-function-name">lapic_is_interrupt_pending</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>		i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i += 1) {
		<span class="enscript-keyword">if</span> ((LAPIC_READ_OFFSET(IRR_BASE, i) != 0) ||
		    (LAPIC_READ_OFFSET(ISR_BASE, i) != 0))
			<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

boolean_t
<span class="enscript-function-name">lapic_is_interrupting</span>(uint8_t vector)
{
	<span class="enscript-type">int</span>		i;
	<span class="enscript-type">int</span>		bit;
	uint32_t	irr;
	uint32_t	isr;

	i = vector / 32;
	bit = 1 &lt;&lt; (vector % 32);

	irr = LAPIC_READ_OFFSET(IRR_BASE, i);
	isr = LAPIC_READ_OFFSET(ISR_BASE, i);

	<span class="enscript-keyword">if</span> ((irr | isr) &amp; bit)
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_interrupt_counts</span>(uint64_t intrs[256])
{
	<span class="enscript-type">int</span>		i;
	<span class="enscript-type">int</span>		j;
	<span class="enscript-type">int</span>		bit;
	uint32_t	irr;
	uint32_t	isr;

	<span class="enscript-keyword">if</span> (intrs == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i += 1) {
		irr = LAPIC_READ_OFFSET(IRR_BASE, i);
		isr = LAPIC_READ_OFFSET(ISR_BASE, i);

		<span class="enscript-keyword">if</span> ((isr | irr) == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">for</span> (j = (i == 0) ? 16 : 0; j &lt; 32; j += 1) {
			bit = (32 * i) + j;
			<span class="enscript-keyword">if</span> ((isr | irr) &amp; (1 &lt;&lt; j))
				intrs[bit] += 1;
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_disable_timer</span>(<span class="enscript-type">void</span>)
{
	uint32_t	lvt_timer;

	<span class="enscript-comment">/*
         * If we're in deadline timer mode,
	 * simply clear the deadline timer, otherwise
	 * mask the timer interrupt and clear the countdown.
         */</span>
	lvt_timer = LAPIC_READ(LVT_TIMER);
	<span class="enscript-keyword">if</span> (lvt_timer &amp; LAPIC_LVT_TSC_DEADLINE) {
		wrmsr64(MSR_IA32_TSC_DEADLINE, 0);
	} <span class="enscript-keyword">else</span> {
		LAPIC_WRITE(LVT_TIMER, lvt_timer | LAPIC_LVT_MASKED);
		LAPIC_WRITE(TIMER_INITIAL_COUNT, 0);
		lvt_timer = LAPIC_READ(LVT_TIMER);
	}
}

<span class="enscript-comment">/* SPI returning the CMCI vector */</span>
uint8_t
<span class="enscript-function-name">lapic_get_cmci_vector</span>(<span class="enscript-type">void</span>)
{
	uint8_t	cmci_vector = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
	<span class="enscript-comment">/* CMCI, if available */</span>
	<span class="enscript-keyword">if</span> (mca_is_cmci_present())
		cmci_vector = LAPIC_VECTOR(CMCI);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> cmci_vector;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lapic_trigger_MC</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>
<span class="enscript-function-name">lapic_trigger_MC</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* A 64-bit access to any register will do it. */</span>
	<span class="enscript-type">volatile</span> uint64_t dummy = *(<span class="enscript-type">volatile</span> uint64_t *) (<span class="enscript-type">volatile</span> <span class="enscript-type">void</span> *) LAPIC_MMIO(ID);
	dummy++;
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>