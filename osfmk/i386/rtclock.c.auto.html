<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>rtclock.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">rtclock.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>

<span class="enscript-comment">/*
 *	File:		i386/rtclock.c
 *	Purpose:	Routines for handling the machine dependent
 *			real-time clock. Historically, this clock is
 *			generated by the Intel 8254 Programmable Interval
 *			Timer, but local apic timers are now used for
 *			this purpose with the master time reference being
 *			the cpu clock counted by the timestamp MSR.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host_notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/macro_help.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>		<span class="enscript-comment">/* for kernel_map */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;architecture/i386/pio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_threads.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/commpage.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tsc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/rtclock_protos.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UI_CPUFREQ_ROUNDING_FACTOR</span>	10000000

<span class="enscript-type">int</span>		rtclock_init(<span class="enscript-type">void</span>);

uint64_t	tsc_rebase_abs_time = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	rtc_set_timescale(uint64_t cycles);
<span class="enscript-type">static</span> uint64_t	rtc_export_speed(uint64_t cycles);

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_timer_start</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * Force a complete re-evaluation of timer deadlines.
	 */</span>
	x86_lcpu()-&gt;rtcDeadline = EndOfAllTime;
	timer_resync_deadlines();
}

<span class="enscript-type">static</span> inline uint32_t
<span class="enscript-function-name">_absolutetime_to_microtime</span>(uint64_t abstime, clock_sec_t *secs, clock_usec_t *microsecs)
{
	uint32_t remain;
	*secs = abstime / (uint64_t)NSEC_PER_SEC;
	remain = (uint32_t)(abstime % (uint64_t)NSEC_PER_SEC);
	*microsecs = remain / NSEC_PER_USEC;
	<span class="enscript-keyword">return</span> remain;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">_absolutetime_to_nanotime</span>(uint64_t abstime, clock_sec_t *secs, clock_usec_t *nanosecs)
{
	*secs = abstime / (uint64_t)NSEC_PER_SEC;
	*nanosecs = (clock_usec_t)(abstime % (uint64_t)NSEC_PER_SEC);
}

<span class="enscript-comment">/*
 * Nanotime/mach_absolutime_time
 * -----------------------------
 * The timestamp counter (TSC) - which counts cpu clock cycles and can be read
 * efficiently by the kernel and in userspace - is the reference for all timing.
 * The cpu clock rate is platform-dependent and may stop or be reset when the
 * processor is napped/slept.  As a result, nanotime is the software abstraction
 * used to maintain a monotonic clock, adjusted from an outside reference as needed.
 *
 * The kernel maintains nanotime information recording:
 * 	- the ratio of tsc to nanoseconds
 *	  with this ratio expressed as a 32-bit scale and shift
 *	  (power of 2 divider);
 *	- { tsc_base, ns_base } pair of corresponding timestamps.
 *
 * The tuple {tsc_base, ns_base, scale, shift} is exported in the commpage 
 * for the userspace nanotime routine to read.
 *
 * All of the routines which update the nanotime data are non-reentrant.  This must
 * be guaranteed by the caller.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_nanotime_set_commpage</span>(pal_rtc_nanotime_t *rntp)
{
	commpage_set_nanotime(rntp-&gt;tsc_base, rntp-&gt;ns_base, rntp-&gt;scale, rntp-&gt;shift);
}

<span class="enscript-comment">/*
 * rtc_nanotime_init:
 *
 * Intialize the nanotime info from the base time.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">_rtc_nanotime_init</span>(pal_rtc_nanotime_t *rntp, uint64_t base)
{
	uint64_t	tsc = rdtsc64();

	_pal_rtc_nanotime_store(tsc, base, rntp-&gt;scale, rntp-&gt;shift, rntp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_nanotime_init</span>(uint64_t base)
{
	_rtc_nanotime_init(&amp;pal_rtc_nanotime_info, base);
	rtc_nanotime_set_commpage(&amp;pal_rtc_nanotime_info);
}

<span class="enscript-comment">/*
 * rtc_nanotime_init_commpage:
 *
 * Call back from the commpage initialization to
 * cause the commpage data to be filled in once the
 * commpages have been created.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_nanotime_init_commpage</span>(<span class="enscript-type">void</span>)
{
	spl_t			s = splclock();

	rtc_nanotime_set_commpage(&amp;pal_rtc_nanotime_info);
	splx(s);
}

<span class="enscript-comment">/*
 * rtc_nanotime_read:
 *
 * Returns the current nanotime value, accessable from any
 * context.
 */</span>
<span class="enscript-type">static</span> inline uint64_t
<span class="enscript-function-name">rtc_nanotime_read</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>	_rtc_nanotime_read(&amp;pal_rtc_nanotime_info);
}

<span class="enscript-comment">/*
 * rtc_clock_napped:
 *
 * Invoked from power management when we exit from a low C-State (&gt;= C4)
 * and the TSC has stopped counting.  The nanotime data is updated according
 * to the provided value which represents the new value for nanotime.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_clock_napped</span>(uint64_t base, uint64_t tsc_base)
{
	pal_rtc_nanotime_t	*rntp = &amp;pal_rtc_nanotime_info;
	uint64_t	oldnsecs;
	uint64_t	newnsecs;
	uint64_t	tsc;

	assert(!ml_get_interrupts_enabled());
	tsc = rdtsc64();
	oldnsecs = rntp-&gt;ns_base + _rtc_tsc_to_nanoseconds(tsc - rntp-&gt;tsc_base, rntp);
	newnsecs = base + _rtc_tsc_to_nanoseconds(tsc - tsc_base, rntp);
	
	<span class="enscript-comment">/*
	 * Only update the base values if time using the new base values
	 * is later than the time using the old base values.
	 */</span>
	<span class="enscript-keyword">if</span> (oldnsecs &lt; newnsecs) {
	    _pal_rtc_nanotime_store(tsc_base, base, rntp-&gt;scale, rntp-&gt;shift, rntp);
	    rtc_nanotime_set_commpage(rntp);
	}
}

<span class="enscript-comment">/*
 * Invoked from power management to correct the SFLM TSC entry drift problem:
 * a small delta is added to the tsc_base.  This is equivalent to nudgin time
 * backwards.  We require this to be on the order of a TSC quantum which won't
 * cause callers of mach_absolute_time() to see time going backwards!
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_clock_adjust</span>(uint64_t tsc_base_delta)
{
    pal_rtc_nanotime_t	*rntp = &amp;pal_rtc_nanotime_info;

    assert(!ml_get_interrupts_enabled());
    assert(tsc_base_delta &lt; 100ULL);	<span class="enscript-comment">/* i.e. it's small */</span>
    _rtc_nanotime_adjust(tsc_base_delta, rntp);
    rtc_nanotime_set_commpage(rntp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_clock_stepping</span>(__unused uint32_t new_frequency,
		   __unused uint32_t old_frequency)
{
	panic(<span class="enscript-string">&quot;rtc_clock_stepping unsupported&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_clock_stepped</span>(__unused uint32_t new_frequency,
		  __unused uint32_t old_frequency)
{
	panic(<span class="enscript-string">&quot;rtc_clock_stepped unsupported&quot;</span>);
}

<span class="enscript-comment">/*
 * rtc_sleep_wakeup:
 *
 * Invoked from power management when we have awoken from a sleep (S3)
 * and the TSC has been reset, or from Deep Idle (S0) sleep when the TSC
 * has progressed.  The nanotime data is updated based on the passed-in value.
 *
 * The caller must guarantee non-reentrancy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_sleep_wakeup</span>(
	uint64_t		base)
{
    	<span class="enscript-comment">/* Set fixed configuration for lapic timers */</span>
	rtc_timer-&gt;rtc_config();

	<span class="enscript-comment">/*
	 * Reset nanotime.
	 * The timestamp counter will have been reset
	 * but nanotime (uptime) marches onward.
	 */</span>
	rtc_nanotime_init(base);
}

<span class="enscript-comment">/*
 * rtclock_early_init() is called very early at boot to
 * establish mach_absolute_time() and set it to zero.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtclock_early_init</span>(<span class="enscript-type">void</span>)
{
	assert(tscFreq);
	rtc_set_timescale(tscFreq);
}

<span class="enscript-comment">/*
 * Initialize the real-time clock device.
 * In addition, various variables used to support the clock are initialized.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rtclock_init</span>(<span class="enscript-type">void</span>)
{
	uint64_t	cycles;

	assert(!ml_get_interrupts_enabled());

	<span class="enscript-keyword">if</span> (cpu_number() == master_cpu) {

		assert(tscFreq);

		<span class="enscript-comment">/*
		 * Adjust and set the exported cpu speed.
		 */</span>
		cycles = rtc_export_speed(tscFreq);

		<span class="enscript-comment">/*
		 * Set min/max to actual.
		 * ACPI may update these later if speed-stepping is detected.
		 */</span>
		gPEClockFrequencyInfo.cpu_frequency_min_hz = cycles;
		gPEClockFrequencyInfo.cpu_frequency_max_hz = cycles;

		rtc_timer_init();
		clock_timebase_init();
		ml_init_lock_timeout();
		ml_init_delay_spin_threshold(10);
	}

    	<span class="enscript-comment">/* Set fixed configuration for lapic timers */</span>
	rtc_timer-&gt;rtc_config();
	rtc_timer_start();

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">// utility routine 
</span><span class="enscript-comment">// Code to calculate how many processor cycles are in a second...
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtc_set_timescale</span>(uint64_t cycles)
{
	pal_rtc_nanotime_t	*rntp = &amp;pal_rtc_nanotime_info;
	uint32_t    shift = 0;
    
	<span class="enscript-comment">/* the &quot;scale&quot; factor will overflow unless cycles&gt;SLOW_TSC_THRESHOLD */</span>
    
	<span class="enscript-keyword">while</span> ( cycles &lt;= SLOW_TSC_THRESHOLD) {
		shift++;
		cycles &lt;&lt;= 1;
	}
	
	rntp-&gt;scale = (uint32_t)(((uint64_t)NSEC_PER_SEC &lt;&lt; 32) / cycles);

	rntp-&gt;shift = shift;

	<span class="enscript-comment">/*
	 * On some platforms, the TSC is not reset at warm boot. But the
	 * rebase time must be relative to the current boot so we can't use
	 * mach_absolute_time(). Instead, we convert the TSC delta since boot
	 * to nanoseconds.
	 */</span>
	<span class="enscript-keyword">if</span> (tsc_rebase_abs_time == 0)
		tsc_rebase_abs_time = _rtc_tsc_to_nanoseconds(
						rdtsc64() - tsc_at_boot, rntp);

	rtc_nanotime_init(0);
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">rtc_export_speed</span>(uint64_t cyc_per_sec)
{
	pal_rtc_nanotime_t	*rntp = &amp;pal_rtc_nanotime_info;
	uint64_t	cycles;

	<span class="enscript-keyword">if</span> (rntp-&gt;shift != 0 )
		printf(<span class="enscript-string">&quot;Slow TSC, rtc_nanotime.shift == %d\n&quot;</span>, rntp-&gt;shift);
    
	<span class="enscript-comment">/* Round: */</span>
        cycles = ((cyc_per_sec + (UI_CPUFREQ_ROUNDING_FACTOR/2))
			/ UI_CPUFREQ_ROUNDING_FACTOR)
				* UI_CPUFREQ_ROUNDING_FACTOR;

	<span class="enscript-comment">/*
	 * Set current measured speed.
	 */</span>
        <span class="enscript-keyword">if</span> (cycles &gt;= 0x100000000ULL) {
            gPEClockFrequencyInfo.cpu_clock_rate_hz = 0xFFFFFFFFUL;
        } <span class="enscript-keyword">else</span> {
            gPEClockFrequencyInfo.cpu_clock_rate_hz = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)cycles;
        }
        gPEClockFrequencyInfo.cpu_frequency_hz = cycles;

	kprintf(<span class="enscript-string">&quot;[RTCLOCK] frequency %llu (%llu)\n&quot;</span>, cycles, cyc_per_sec);
	<span class="enscript-keyword">return</span>(cycles);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_system_microtime</span>(
	clock_sec_t			*secs,
	clock_usec_t		*microsecs)
{
	uint64_t	now = rtc_nanotime_read();

	_absolutetime_to_microtime(now, secs, microsecs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_system_nanotime</span>(
	clock_sec_t			*secs,
	clock_nsec_t		*nanosecs)
{
	uint64_t	now = rtc_nanotime_read();

	_absolutetime_to_nanotime(now, secs, nanosecs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_gettimeofday_set_commpage</span>(
	uint64_t				abstime,
	uint64_t				epoch,
	uint64_t				offset,
	clock_sec_t				*secs,
	clock_usec_t			*microsecs)
{
	uint64_t	now = abstime + offset;
	uint32_t	remain;

	remain = _absolutetime_to_microtime(now, secs, microsecs);

	*secs += (clock_sec_t)epoch;

	commpage_set_timestamp(abstime - remain, *secs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_timebase_info</span>(
	mach_timebase_info_t	info)
{
	info-&gt;numer = info-&gt;denom =  1;
}	

<span class="enscript-comment">/*
 * Real-time clock device interrupt.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtclock_intr</span>(
	x86_saved_state_t	*tregs)
{
        uint64_t	rip;
	boolean_t	user_mode = FALSE;

	assert(get_preemption_level() &gt; 0);
	assert(!ml_get_interrupts_enabled());

	<span class="enscript-keyword">if</span> (is_saved_state64(tregs) == TRUE) {
	        x86_saved_state64_t	*regs;
		  
		regs = saved_state64(tregs);

		<span class="enscript-keyword">if</span> (regs-&gt;isf.cs &amp; 0x03)
			user_mode = TRUE;
		rip = regs-&gt;isf.rip;
	} <span class="enscript-keyword">else</span> {
	        x86_saved_state32_t	*regs;

		regs = saved_state32(tregs);

		<span class="enscript-keyword">if</span> (regs-&gt;cs &amp; 0x03)
		        user_mode = TRUE;
		rip = regs-&gt;eip;
	}

	<span class="enscript-comment">/* call the generic etimer */</span>
	timer_intr(user_mode, rip);
}


<span class="enscript-comment">/*
 *	Request timer pop from the hardware 
 */</span>

uint64_t
<span class="enscript-function-name">setPop</span>(uint64_t time)
{
	uint64_t	now;
	uint64_t	pop;

	<span class="enscript-comment">/* 0 and EndOfAllTime are special-cases for &quot;clear the timer&quot; */</span>
	<span class="enscript-keyword">if</span> (time == 0 || time == EndOfAllTime ) {
		time = EndOfAllTime;
		now = 0;
		pop = rtc_timer-&gt;rtc_set(0, 0);
	} <span class="enscript-keyword">else</span> {
		now = rtc_nanotime_read();	<span class="enscript-comment">/* The time in nanoseconds */</span>
		pop = rtc_timer-&gt;rtc_set(time, now);
	}

	<span class="enscript-comment">/* Record requested and actual deadlines set */</span>
	x86_lcpu()-&gt;rtcDeadline = time;
	x86_lcpu()-&gt;rtcPop	= pop;

	<span class="enscript-keyword">return</span> pop - now;
}

uint64_t
<span class="enscript-function-name">mach_absolute_time</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> rtc_nanotime_read();
}

uint64_t
<span class="enscript-function-name">mach_approximate_time</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> rtc_nanotime_read();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_interval_to_absolutetime_interval</span>(
	uint32_t		interval,
	uint32_t		scale_factor,
	uint64_t		*result)
{
	*result = (uint64_t)interval * scale_factor;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">absolutetime_to_microtime</span>(
	uint64_t			abstime,
	clock_sec_t			*secs,
	clock_usec_t		*microsecs)
{
	_absolutetime_to_microtime(abstime, secs, microsecs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nanotime_to_absolutetime</span>(
	clock_sec_t			secs,
	clock_nsec_t		nanosecs,
	uint64_t			*result)
{
	*result = ((uint64_t)secs * NSEC_PER_SEC) + nanosecs;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">absolutetime_to_nanoseconds</span>(
	uint64_t		abstime,
	uint64_t		*result)
{
	*result = abstime;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nanoseconds_to_absolutetime</span>(
	uint64_t		nanoseconds,
	uint64_t		*result)
{
	*result = nanoseconds;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_delay_until</span>(
	uint64_t interval,
	uint64_t		deadline)
{
	(<span class="enscript-type">void</span>)interval;
	<span class="enscript-keyword">while</span> (mach_absolute_time() &lt; deadline) {
		cpu_pause();
	} 
}
</pre>
<hr />
</body></html>