<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Diagnostics.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">Diagnostics.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2005-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/*
 * @APPLE_FREE_COPYRIGHT@
 */</span>

<span class="enscript-comment">/*
 *	Author: Bill Angell, Apple
 *	Date:	10/auht-five
 *
 *	Random diagnostics, augmented Derek Kumar 2011
 *
 *
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/processor_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/video_console.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/Diagnostics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tsc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/syscall_sw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PERMIT_PERMCHECK</span> (0)

diagWork        dgWork;
uint64_t        lastRuptClear = 0ULL;
boolean_t	diag_pmc_enabled = FALSE;
<span class="enscript-type">void</span> <span class="enscript-function-name">cpu_powerstats</span>(<span class="enscript-type">void</span> *);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	uint64_t caperf;
	uint64_t cmperf;
	uint64_t ccres[6];
	uint64_t crtimes[CPU_RTIME_BINS];
	uint64_t citimes[CPU_ITIME_BINS];
	uint64_t crtime_total;
	uint64_t citime_total;
	uint64_t cpu_idle_exits;
	uint64_t cpu_insns;
	uint64_t cpu_ucc;
	uint64_t cpu_urc;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DIAG_ALL_PMCS</span>
	uint64_t gpmcs[4];
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAG_ALL_PMCS */</span>
} core_energy_stat_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	uint64_t pkes_version;
	uint64_t pkg_cres[2][7];
	uint64_t pkg_power_unit;
	uint64_t pkg_energy;
	uint64_t pp0_energy;
	uint64_t pp1_energy;
	uint64_t ddr_energy;
	uint64_t llc_flushed_cycles;
	uint64_t ring_ratio_instantaneous;
	uint64_t IA_frequency_clipping_cause;
	uint64_t GT_frequency_clipping_cause;
	uint64_t pkg_idle_exits;
	uint64_t pkg_rtimes[CPU_RTIME_BINS];
	uint64_t pkg_itimes[CPU_ITIME_BINS];
	uint64_t mbus_delay_time;
	uint64_t mint_delay_time;
	uint32_t ncpus;
	core_energy_stat_t cest[];
} pkg_energy_statistics_t;


<span class="enscript-type">int</span> 
<span class="enscript-function-name">diagCall64</span>(x86_saved_state_t * state)
{
	uint64_t	curpos, i, j;
	uint64_t	selector, data;
	uint64_t	currNap, durNap;
	x86_saved_state64_t	*regs;
	boolean_t 	diagflag;
	uint32_t	rval = 0;

	assert(is_saved_state64(state));
	regs = saved_state64(state);

	diagflag = ((dgWork.dgFlags &amp; enaDiagSCs) != 0);
	selector = regs-&gt;rdi;

	<span class="enscript-keyword">switch</span> (selector) {	<span class="enscript-comment">/* Select the routine */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">dgRuptStat</span>:	<span class="enscript-comment">/* Suck Interruption statistics */</span>
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(TRUE);
		data = regs-&gt;rsi; <span class="enscript-comment">/* Get the number of processors */</span>

		<span class="enscript-keyword">if</span> (data == 0) { <span class="enscript-comment">/* If no location is specified for data, clear all
				  * counts
				  */</span>
			<span class="enscript-keyword">for</span> (i = 0; i &lt; real_ncpus; i++) {	<span class="enscript-comment">/* Cycle through
								 * processors */</span>
				<span class="enscript-keyword">for</span> (j = 0; j &lt; 256; j++)
					cpu_data_ptr[i]-&gt;cpu_hwIntCnt[j] = 0;
			}

			lastRuptClear = mach_absolute_time();	<span class="enscript-comment">/* Get the time of clear */</span>
			rval = 1;	<span class="enscript-comment">/* Normal return */</span>
			(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(FALSE);
			<span class="enscript-keyword">break</span>;
		}

		(<span class="enscript-type">void</span>) copyout((<span class="enscript-type">char</span> *) &amp;real_ncpus, data, <span class="enscript-keyword">sizeof</span>(real_ncpus));	<span class="enscript-comment">/* Copy out number of
										 * processors */</span>
		currNap = mach_absolute_time();	<span class="enscript-comment">/* Get the time now */</span>
		durNap = currNap - lastRuptClear;	<span class="enscript-comment">/* Get the last interval
							 * duration */</span>
		<span class="enscript-keyword">if</span> (durNap == 0)
			durNap = 1;	<span class="enscript-comment">/* This is a very short time, make it
					 * bigger */</span>

		curpos = data + <span class="enscript-keyword">sizeof</span>(real_ncpus);	<span class="enscript-comment">/* Point to the next
							 * available spot */</span>

		<span class="enscript-keyword">for</span> (i = 0; i &lt; real_ncpus; i++) {	<span class="enscript-comment">/* Move 'em all out */</span>
			(<span class="enscript-type">void</span>) copyout((<span class="enscript-type">char</span> *) &amp;durNap, curpos, 8);	<span class="enscript-comment">/* Copy out the time
									 * since last clear */</span>
			(<span class="enscript-type">void</span>) copyout((<span class="enscript-type">char</span> *) &amp;cpu_data_ptr[i]-&gt;cpu_hwIntCnt, curpos + 8, 256 * <span class="enscript-keyword">sizeof</span>(uint32_t));	<span class="enscript-comment">/* Copy out interrupt
															 * data for this
															 * processor */</span>
			curpos = curpos + (256 * <span class="enscript-keyword">sizeof</span>(uint32_t) + 8);	<span class="enscript-comment">/* Point to next out put
									 * slot */</span>
		}
		rval = 1;
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(FALSE);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">dgPowerStat</span>:
	{
		uint32_t c2l = 0, c2h = 0, c3l = 0, c3h = 0, c6l = 0, c6h = 0, c7l = 0, c7h = 0;
		uint32_t pkg_unit_l = 0, pkg_unit_h = 0, pkg_ecl = 0, pkg_ech = 0;

		pkg_energy_statistics_t pkes;
		core_energy_stat_t cest;

		bzero(&amp;pkes, <span class="enscript-keyword">sizeof</span>(pkes));
		bzero(&amp;cest, <span class="enscript-keyword">sizeof</span>(cest));

		pkes.pkes_version = 1ULL;
		rdmsr_carefully(MSR_IA32_PKG_C2_RESIDENCY, &amp;c2l, &amp;c2h);
		rdmsr_carefully(MSR_IA32_PKG_C3_RESIDENCY, &amp;c3l, &amp;c3h);
		rdmsr_carefully(MSR_IA32_PKG_C6_RESIDENCY, &amp;c6l, &amp;c6h);
		rdmsr_carefully(MSR_IA32_PKG_C7_RESIDENCY, &amp;c7l, &amp;c7h);

		pkes.pkg_cres[0][0] = ((uint64_t)c2h &lt;&lt; 32) | c2l;
		pkes.pkg_cres[0][1] = ((uint64_t)c3h &lt;&lt; 32) | c3l;
		pkes.pkg_cres[0][2] = ((uint64_t)c6h &lt;&lt; 32) | c6l;
		pkes.pkg_cres[0][3] = ((uint64_t)c7h &lt;&lt; 32) | c7l;

		uint64_t c8r = ~0ULL, c9r = ~0ULL, c10r = ~0ULL;

		rdmsr64_carefully(MSR_IA32_PKG_C8_RESIDENCY, &amp;c8r);
		rdmsr64_carefully(MSR_IA32_PKG_C9_RESIDENCY, &amp;c9r);
		rdmsr64_carefully(MSR_IA32_PKG_C10_RESIDENCY, &amp;c10r);

		pkes.pkg_cres[0][4] = c8r;
		pkes.pkg_cres[0][5] = c9r;
		pkes.pkg_cres[0][6] = c10r;

		pkes.ddr_energy = ~0ULL;
		rdmsr64_carefully(MSR_IA32_DDR_ENERGY_STATUS, &amp;pkes.ddr_energy);
		pkes.llc_flushed_cycles = ~0ULL;
		rdmsr64_carefully(MSR_IA32_LLC_FLUSHED_RESIDENCY_TIMER, &amp;pkes.llc_flushed_cycles);

		pkes.ring_ratio_instantaneous = ~0ULL;
		rdmsr64_carefully(MSR_IA32_RING_PERF_STATUS, &amp;pkes.ring_ratio_instantaneous);

		pkes.IA_frequency_clipping_cause = ~0ULL;

		uint32_t ia_perf_limits = MSR_IA32_IA_PERF_LIMIT_REASONS;

		rdmsr64_carefully(ia_perf_limits, &amp;pkes.IA_frequency_clipping_cause);

		pkes.GT_frequency_clipping_cause = ~0ULL;
		rdmsr64_carefully(MSR_IA32_GT_PERF_LIMIT_REASONS, &amp;pkes.GT_frequency_clipping_cause);

		rdmsr_carefully(MSR_IA32_PKG_POWER_SKU_UNIT, &amp;pkg_unit_l, &amp;pkg_unit_h);
		rdmsr_carefully(MSR_IA32_PKG_ENERGY_STATUS, &amp;pkg_ecl, &amp;pkg_ech);
		pkes.pkg_power_unit = ((uint64_t)pkg_unit_h &lt;&lt; 32) | pkg_unit_l;
		pkes.pkg_energy = ((uint64_t)pkg_ech &lt;&lt; 32) | pkg_ecl;

		rdmsr_carefully(MSR_IA32_PP0_ENERGY_STATUS, &amp;pkg_ecl, &amp;pkg_ech);
		pkes.pp0_energy = ((uint64_t)pkg_ech &lt;&lt; 32) | pkg_ecl;

		rdmsr_carefully(MSR_IA32_PP1_ENERGY_STATUS, &amp;pkg_ecl, &amp;pkg_ech);
		pkes.pp1_energy = ((uint64_t)pkg_ech &lt;&lt; 32) | pkg_ecl;

		pkes.pkg_idle_exits = current_cpu_datap()-&gt;lcpu.package-&gt;package_idle_exits;
		pkes.ncpus = real_ncpus;

		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(TRUE);

		copyout(&amp;pkes, regs-&gt;rsi, <span class="enscript-keyword">sizeof</span>(pkes));
		curpos = regs-&gt;rsi + <span class="enscript-keyword">sizeof</span>(pkes);

		mp_cpus_call(CPUMASK_ALL, ASYNC, cpu_powerstats, NULL);
		
		<span class="enscript-keyword">for</span> (i = 0; i &lt; real_ncpus; i++) {
			(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(FALSE);

			cest.caperf = cpu_data_ptr[i]-&gt;cpu_aperf;
			cest.cmperf = cpu_data_ptr[i]-&gt;cpu_mperf;
			cest.ccres[0] = cpu_data_ptr[i]-&gt;cpu_c3res;
			cest.ccres[1] = cpu_data_ptr[i]-&gt;cpu_c6res;
			cest.ccres[2] = cpu_data_ptr[i]-&gt;cpu_c7res;

			bcopy(&amp;cpu_data_ptr[i]-&gt;cpu_rtimes[0], &amp;cest.crtimes[0], <span class="enscript-keyword">sizeof</span>(cest.crtimes));
			bcopy(&amp;cpu_data_ptr[i]-&gt;cpu_itimes[0], &amp;cest.citimes[0], <span class="enscript-keyword">sizeof</span>(cest.citimes));

			cest.citime_total = cpu_data_ptr[i]-&gt;cpu_itime_total;
			cest.crtime_total = cpu_data_ptr[i]-&gt;cpu_rtime_total;
 			cest.cpu_idle_exits = cpu_data_ptr[i]-&gt;cpu_idle_exits;
 			cest.cpu_insns = cpu_data_ptr[i]-&gt;cpu_cur_insns;
 			cest.cpu_ucc = cpu_data_ptr[i]-&gt;cpu_cur_ucc;
 			cest.cpu_urc = cpu_data_ptr[i]-&gt;cpu_cur_urc;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAG_ALL_PMCS</span>
			bcopy(&amp;cpu_data_ptr[i]-&gt;cpu_gpmcs[0], &amp;cest.gpmcs[0], <span class="enscript-keyword">sizeof</span>(cest.gpmcs));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAG_ALL_PMCS */</span>
 			(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(TRUE);

			copyout(&amp;cest, curpos, <span class="enscript-keyword">sizeof</span>(cest));
			curpos += <span class="enscript-keyword">sizeof</span>(cest);
		}
		rval = 1;
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(FALSE);
	}
		<span class="enscript-keyword">break</span>;
 	<span class="enscript-keyword">case</span> <span class="enscript-reference">dgEnaPMC</span>:
 	{
 		boolean_t enable = TRUE;
		uint32_t cpuinfo[4];
		<span class="enscript-comment">/* Require architectural PMC v2 or higher, corresponding to
		 * Merom+, or equivalent virtualised facility.
		 */</span>
		do_cpuid(0xA, &amp;cpuinfo[0]);
		<span class="enscript-keyword">if</span> ((cpuinfo[0] &amp; 0xFF) &gt;= 2) {
			mp_cpus_call(CPUMASK_ALL, ASYNC, cpu_pmc_control, &amp;enable);
			diag_pmc_enabled = TRUE;
		}
 		rval = 1;
 	}
 	<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">dgGzallocTest</span>:
	{
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(TRUE);
		<span class="enscript-keyword">if</span> (diagflag) {
			<span class="enscript-type">unsigned</span> *ptr = (<span class="enscript-type">unsigned</span> *)kalloc(1024);
			kfree(ptr, 1024);
			*ptr = 0x42;
		}
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(FALSE);
	}
	<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PERMIT_PERMCHECK</span>	
	<span class="enscript-keyword">case</span>	<span class="enscript-reference">dgPermCheck</span>:
	{
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(TRUE);
		<span class="enscript-keyword">if</span> (diagflag)
			rval = pmap_permissions_verify(kernel_pmap, kernel_map, 0, ~0ULL);
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(FALSE);
	}
 		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PERMIT_PERMCHECK */</span>
	<span class="enscript-reference">default</span>:		<span class="enscript-comment">/* Handle invalid ones */</span>
		rval = 0;	<span class="enscript-comment">/* Return an exception */</span>
	}

	regs-&gt;rax = rval;

	assert(ml_get_interrupts_enabled() == FALSE);
	<span class="enscript-keyword">return</span> rval;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpu_powerstats</span>(__unused <span class="enscript-type">void</span> *arg) {
	cpu_data_t *cdp = current_cpu_datap();
	__unused <span class="enscript-type">int</span> cnum = cdp-&gt;cpu_number;
	uint32_t cl = 0, ch = 0, mpl = 0, mph = 0, apl = 0, aph = 0;

	rdmsr_carefully(MSR_IA32_MPERF, &amp;mpl, &amp;mph);
	rdmsr_carefully(MSR_IA32_APERF, &amp;apl, &amp;aph);

	cdp-&gt;cpu_mperf = ((uint64_t)mph &lt;&lt; 32) | mpl;
	cdp-&gt;cpu_aperf = ((uint64_t)aph &lt;&lt; 32) | apl;

	uint64_t ctime = mach_absolute_time();
	cdp-&gt;cpu_rtime_total += ctime - cdp-&gt;cpu_ixtime;
	cdp-&gt;cpu_ixtime = ctime;

	rdmsr_carefully(MSR_IA32_CORE_C3_RESIDENCY, &amp;cl, &amp;ch);
	cdp-&gt;cpu_c3res = ((uint64_t)ch &lt;&lt; 32) | cl;

	rdmsr_carefully(MSR_IA32_CORE_C6_RESIDENCY, &amp;cl, &amp;ch);
	cdp-&gt;cpu_c6res = ((uint64_t)ch &lt;&lt; 32) | cl;

	rdmsr_carefully(MSR_IA32_CORE_C7_RESIDENCY, &amp;cl, &amp;ch);
	cdp-&gt;cpu_c7res = ((uint64_t)ch &lt;&lt; 32) | cl;

	<span class="enscript-keyword">if</span> (diag_pmc_enabled) {
		uint64_t insns = read_pmc(FIXED_PMC0);
		uint64_t ucc = read_pmc(FIXED_PMC1);
		uint64_t urc = read_pmc(FIXED_PMC2);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAG_ALL_PMCS</span>
		<span class="enscript-type">int</span> i;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++) {
			cdp-&gt;cpu_gpmcs[i] = read_pmc(i);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAG_ALL_PMCS */</span>
		cdp-&gt;cpu_cur_insns = insns;
		cdp-&gt;cpu_cur_ucc = ucc;
		cdp-&gt;cpu_cur_urc = urc;
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpu_pmc_control</span>(<span class="enscript-type">void</span> *enablep) {
	boolean_t enable = *(boolean_t *)enablep;
	cpu_data_t	*cdp = current_cpu_datap();

	<span class="enscript-keyword">if</span> (enable) {
		wrmsr64(0x38F, 0x70000000FULL);
		wrmsr64(0x38D, 0x333);
		set_cr4(get_cr4() | CR4_PCE);

	} <span class="enscript-keyword">else</span> {
		wrmsr64(0x38F, 0);
		wrmsr64(0x38D, 0);
		set_cr4((get_cr4() &amp; ~CR4_PCE));
	}
	cdp-&gt;cpu_fixed_pmcs_enabled = enable;
}
</pre>
<hr />
</body></html>