<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>locks_i386.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">locks_i386.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 *	File:	kern/lock.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Locking primitives implementation
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/xpr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span> <span class="enscript-comment">/* machine_timeout_suspended() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/branch_predicates.h&gt;</span>

<span class="enscript-comment">/*
 * We need only enough declarations from the BSD-side to be able to
 * test if our probe is active, and to call __dtrace_probe().  Setting
 * NEED_DTRACE_DEFS gets a local copy of those definitions pulled in.
 */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NEED_DTRACE_DEFS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;../bsd/sys/lockstat.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_RW_LCK_EXCLUSIVE_CODE</span>	0x100
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_RW_LCK_EXCLUSIVE1_CODE</span>	0x101
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_RW_LCK_SHARED_CODE</span>		0x102
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_RW_LCK_SH_TO_EX_CODE</span>	0x103
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_RW_LCK_SH_TO_EX1_CODE</span>	0x104
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_RW_LCK_EX_TO_SH_CODE</span>	0x105

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_EX_WRITER_SPIN_CODE</span>	0x106
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_EX_WRITER_WAIT_CODE</span>	0x107
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_EX_READER_SPIN_CODE</span>	0x108
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_EX_READER_WAIT_CODE</span>	0x109
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_SHARED_SPIN_CODE</span>	0x110
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_SHARED_WAIT_CODE</span>	0x111
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_SH_TO_EX_SPIN_CODE</span>	0x112
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_RW_LCK_SH_TO_EX_WAIT_CODE</span>	0x113


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ANY_LOCK_DEBUG</span>	(USLOCK_DEBUG || LOCK_DEBUG || MUTEX_DEBUG)

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> LcksOpts=0;

<span class="enscript-comment">/* Forwards */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">USLOCK_DEBUG</span>
<span class="enscript-comment">/*
 *	Perform simple lock checks.
 */</span>
<span class="enscript-type">int</span>	uslock_check = 1;
<span class="enscript-type">int</span>	max_lock_loops	= 100000000;
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">extern</span> , printf_lock)
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">extern</span> , panic_lock)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USLOCK_DEBUG */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> not_in_kdp;

<span class="enscript-comment">/*
 *	We often want to know the addresses of the callers
 *	of the various lock routines.  However, this information
 *	is only used for debugging and statistics.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">void</span>	*pc_t;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INVALID_PC</span>	((void *) VM_MAX_KERNEL_ADDRESS)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INVALID_THREAD</span>	((void *) VM_MAX_KERNEL_ADDRESS)
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ANY_LOCK_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OBTAIN_PC</span>(pc)	((pc) = GET_RETURN_PC())
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DECL_PC</span>(pc)	pc_t pc;
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* ANY_LOCK_DEBUG */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DECL_PC</span>(pc)
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">lint</span>
<span class="enscript-comment">/*
 *	Eliminate lint complaints about unused local pc variables.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OBTAIN_PC</span>(pc)	++pc
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* lint */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OBTAIN_PC</span>(pc)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* lint */</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USLOCK_DEBUG */</span>


<span class="enscript-comment">/*
 *	Portable lock package implementation of usimple_locks.
 */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">USLOCK_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">USLDBG</span>(stmt)	stmt
<span class="enscript-type">void</span>		usld_lock_init(usimple_lock_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>);
<span class="enscript-type">void</span>		usld_lock_pre(usimple_lock_t, pc_t);
<span class="enscript-type">void</span>		usld_lock_post(usimple_lock_t, pc_t);
<span class="enscript-type">void</span>		usld_unlock(usimple_lock_t, pc_t);
<span class="enscript-type">void</span>		usld_lock_try_pre(usimple_lock_t, pc_t);
<span class="enscript-type">void</span>		usld_lock_try_post(usimple_lock_t, pc_t);
<span class="enscript-type">int</span>		usld_lock_common_checks(usimple_lock_t, <span class="enscript-type">char</span> *);
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* USLOCK_DEBUG */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">USLDBG</span>(stmt)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USLOCK_DEBUG */</span>


<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">lck_rw_grab_want</span>(lck_rw_t *lck);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">lck_rw_grab_shared</span>(lck_rw_t *lck);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">lck_rw_held_read_or_upgrade</span>(lck_rw_t *lck);


<span class="enscript-comment">/*
 * Forward definitions
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">lck_rw_lock_shared_gen</span>(
	lck_rw_t	*lck);

<span class="enscript-type">void</span> <span class="enscript-function-name">lck_rw_lock_exclusive_gen</span>(
	lck_rw_t	*lck);

boolean_t <span class="enscript-function-name">lck_rw_lock_shared_to_exclusive_success</span>(
	lck_rw_t	*lck);

boolean_t <span class="enscript-function-name">lck_rw_lock_shared_to_exclusive_failure</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">int</span>		prior_lock_state);

<span class="enscript-type">void</span> <span class="enscript-function-name">lck_rw_lock_exclusive_to_shared_gen</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">int</span>		prior_lock_state);

lck_rw_type_t <span class="enscript-function-name">lck_rw_done_gen</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">int</span>		prior_lock_state);

<span class="enscript-type">void</span> <span class="enscript-function-name">lck_rw_clear_promotions_x86</span>(thread_t thread);

<span class="enscript-comment">/*
 *      Routine:        lck_spin_alloc_init
 */</span>
lck_spin_t *
<span class="enscript-function-name">lck_spin_alloc_init</span>(
	lck_grp_t	*grp,
	lck_attr_t	*attr)
{
	lck_spin_t	*lck;

	<span class="enscript-keyword">if</span> ((lck = (lck_spin_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_spin_t))) != 0)
		lck_spin_init(lck, grp, attr);

	<span class="enscript-keyword">return</span>(lck);
}

<span class="enscript-comment">/*
 *      Routine:        lck_spin_free
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_spin_free</span>(
	lck_spin_t	*lck,
	lck_grp_t	*grp)
{
	lck_spin_destroy(lck, grp);
	kfree(lck, <span class="enscript-keyword">sizeof</span>(lck_spin_t));
}

<span class="enscript-comment">/*
 *      Routine:        lck_spin_init
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_spin_init</span>(
	lck_spin_t	*lck,
	lck_grp_t	*grp,
	__unused lck_attr_t	*attr)
{
	usimple_lock_init((usimple_lock_t) lck, 0);
	lck_grp_reference(grp);
	lck_grp_lckcnt_incr(grp, LCK_TYPE_SPIN);
}

<span class="enscript-comment">/*
 *      Routine:        lck_spin_destroy
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_spin_destroy</span>(
	lck_spin_t	*lck,
	lck_grp_t	*grp)
{
	<span class="enscript-keyword">if</span> (lck-&gt;interlock == LCK_SPIN_TAG_DESTROYED)
		<span class="enscript-keyword">return</span>;
	lck-&gt;interlock = LCK_SPIN_TAG_DESTROYED;
	lck_grp_lckcnt_decr(grp, LCK_TYPE_SPIN);
	lck_grp_deallocate(grp);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *      Routine:        lck_spin_lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_spin_lock</span>(
	lck_spin_t	*lck)
{
	usimple_lock((usimple_lock_t) lck);
}

<span class="enscript-comment">/*
 *      Routine:        lck_spin_unlock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_spin_unlock</span>(
	lck_spin_t	*lck)
{
	usimple_unlock((usimple_lock_t) lck);
}


<span class="enscript-comment">/*
 *      Routine:        lck_spin_try_lock
 */</span>
boolean_t
<span class="enscript-function-name">lck_spin_try_lock</span>(
	lck_spin_t	*lck)
{
	<span class="enscript-keyword">return</span>((boolean_t)usimple_lock_try((usimple_lock_t) lck));
}

<span class="enscript-comment">/*
 *      Routine: kdp_lck_spin_is_acquired
 *      NOT SAFE: To be used only by kernel debugger to avoid deadlock.
 *      Returns: TRUE if lock is acquired.
 */</span>
boolean_t
<span class="enscript-function-name">kdp_lck_spin_is_acquired</span>(lck_spin_t *lck) {
	<span class="enscript-keyword">if</span> (not_in_kdp) {
		panic(<span class="enscript-string">&quot;panic: spinlock acquired check done outside of kernel debugger&quot;</span>);
	}
	<span class="enscript-keyword">return</span> (lck-&gt;interlock != 0)? TRUE : FALSE;
}

<span class="enscript-comment">/*
 *	Initialize a usimple_lock.
 *
 *	No change in preemption state.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usimple_lock_init</span>(
	usimple_lock_t	l,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>	tag)
{
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">MACHINE_SIMPLE_LOCK</span>
	USLDBG(usld_lock_init(l, tag));
	hw_lock_init(&amp;l-&gt;interlock);
#<span class="enscript-reference">else</span>
	simple_lock_init((simple_lock_t)l,tag);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">volatile</span> uint32_t spinlock_owner_cpu = ~0;
<span class="enscript-type">volatile</span> usimple_lock_t spinlock_timed_out;

uint32_t <span class="enscript-function-name">spinlock_timeout_NMI</span>(uintptr_t thread_addr) {
	uint64_t deadline;
	uint32_t i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; real_ncpus; i++) {
		<span class="enscript-keyword">if</span> ((uintptr_t)cpu_data_ptr[i]-&gt;cpu_active_thread == thread_addr) {
			spinlock_owner_cpu = i;
			<span class="enscript-keyword">if</span> ((uint32_t) cpu_number() == i)
				<span class="enscript-keyword">break</span>;
			cpu_datap(i)-&gt;cpu_NMI_acknowledged = FALSE;
			cpu_NMI_interrupt(i);
			deadline = mach_absolute_time() + (LockTimeOut * 2);
			<span class="enscript-keyword">while</span> (mach_absolute_time() &lt; deadline &amp;&amp; cpu_datap(i)-&gt;cpu_NMI_acknowledged == FALSE)
				cpu_pause();
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> spinlock_owner_cpu;
}

<span class="enscript-comment">/*
 *	Acquire a usimple_lock.
 *
 *	Returns with preemption disabled.  Note
 *	that the hw_lock routines are responsible for
 *	maintaining preemption state.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usimple_lock</span>(
	usimple_lock_t	l)
{
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">MACHINE_SIMPLE_LOCK</span>
	DECL_PC(pc);

	OBTAIN_PC(pc);
	USLDBG(usld_lock_pre(l, pc));

	<span class="enscript-keyword">if</span>(__improbable(hw_lock_to(&amp;l-&gt;interlock, LockTimeOutTSC) == 0))	{
		boolean_t uslock_acquired = FALSE;
		<span class="enscript-keyword">while</span> (machine_timeout_suspended()) {
			enable_preemption();
			<span class="enscript-keyword">if</span> ((uslock_acquired = hw_lock_to(&amp;l-&gt;interlock, LockTimeOutTSC)))
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (uslock_acquired == FALSE) {
			uint32_t lock_cpu;
			uintptr_t lowner = (uintptr_t)l-&gt;interlock.lock_data;
			spinlock_timed_out = l;
			lock_cpu = spinlock_timeout_NMI(lowner);
			panic(<span class="enscript-string">&quot;Spinlock acquisition timed out: lock=%p, lock owner thread=0x%lx, current_thread: %p, lock owner active on CPU 0x%x, current owner: 0x%lx&quot;</span>, l, lowner,  current_thread(), lock_cpu, (uintptr_t)l-&gt;interlock.lock_data);
		}
	}
	USLDBG(usld_lock_post(l, pc));
#<span class="enscript-reference">else</span>
	simple_lock((simple_lock_t)l);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 *	Release a usimple_lock.
 *
 *	Returns with preemption enabled.  Note
 *	that the hw_lock routines are responsible for
 *	maintaining preemption state.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usimple_unlock</span>(
	usimple_lock_t	l)
{
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">MACHINE_SIMPLE_LOCK</span>
	DECL_PC(pc);

	OBTAIN_PC(pc);
	USLDBG(usld_unlock(l, pc));
	hw_lock_unlock(&amp;l-&gt;interlock);
#<span class="enscript-reference">else</span>
	simple_unlock_rwmb((simple_lock_t)l);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 *	Conditionally acquire a usimple_lock.
 *
 *	On success, returns with preemption disabled.
 *	On failure, returns with preemption in the same state
 *	as when first invoked.  Note that the hw_lock routines
 *	are responsible for maintaining preemption state.
 *
 *	XXX No stats are gathered on a miss; I preserved this
 *	behavior from the original assembly-language code, but
 *	doesn't it make sense to log misses?  XXX
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">usimple_lock_try</span>(
	usimple_lock_t	l)
{
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">MACHINE_SIMPLE_LOCK</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	success;
	DECL_PC(pc);

	OBTAIN_PC(pc);
	USLDBG(usld_lock_try_pre(l, pc));
	<span class="enscript-keyword">if</span> ((success = hw_lock_try(&amp;l-&gt;interlock))) {
		USLDBG(usld_lock_try_post(l, pc));
	}
	<span class="enscript-keyword">return</span> success;
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">return</span>(simple_lock_try((simple_lock_t)l));
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">USLOCK_DEBUG</span>
<span class="enscript-comment">/*
 *	States of a usimple_lock.  The default when initializing
 *	a usimple_lock is setting it up for debug checking.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">USLOCK_CHECKED</span>		0x0001		<span class="enscript-comment">/* lock is being checked */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">USLOCK_TAKEN</span>		0x0002		<span class="enscript-comment">/* lock has been taken */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">USLOCK_INIT</span>		0xBAA0		<span class="enscript-comment">/* lock has been initialized */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">USLOCK_INITIALIZED</span>	(USLOCK_INIT|USLOCK_CHECKED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">USLOCK_CHECKING</span>(l)	(uslock_check &amp;&amp;			\
				 ((l)-&gt;debug.state &amp; USLOCK_CHECKED))

<span class="enscript-comment">/*
 *	Trace activities of a particularly interesting lock.
 */</span>
<span class="enscript-type">void</span>	usl_trace(usimple_lock_t, <span class="enscript-type">int</span>, pc_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);


<span class="enscript-comment">/*
 *	Initialize the debugging information contained
 *	in a usimple_lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usld_lock_init</span>(
	usimple_lock_t	l,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>	tag)
{
	<span class="enscript-keyword">if</span> (l == USIMPLE_LOCK_NULL)
		panic(<span class="enscript-string">&quot;lock initialization:  null lock pointer&quot;</span>);
	l-&gt;lock_type = USLOCK_TAG;
	l-&gt;debug.state = uslock_check ? USLOCK_INITIALIZED : 0;
	l-&gt;debug.lock_cpu = l-&gt;debug.unlock_cpu = 0;
	l-&gt;debug.lock_pc = l-&gt;debug.unlock_pc = INVALID_PC;
	l-&gt;debug.lock_thread = l-&gt;debug.unlock_thread = INVALID_THREAD;
	l-&gt;debug.duration[0] = l-&gt;debug.duration[1] = 0;
	l-&gt;debug.unlock_cpu = l-&gt;debug.unlock_cpu = 0;
	l-&gt;debug.unlock_pc = l-&gt;debug.unlock_pc = INVALID_PC;
	l-&gt;debug.unlock_thread = l-&gt;debug.unlock_thread = INVALID_THREAD;
}


<span class="enscript-comment">/*
 *	These checks apply to all usimple_locks, not just
 *	those with USLOCK_CHECKED turned on.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">usld_lock_common_checks</span>(
	usimple_lock_t	l,
	<span class="enscript-type">char</span>		*caller)
{
	<span class="enscript-keyword">if</span> (l == USIMPLE_LOCK_NULL)
		panic(<span class="enscript-string">&quot;%s:  null lock pointer&quot;</span>, caller);
	<span class="enscript-keyword">if</span> (l-&gt;lock_type != USLOCK_TAG)
		panic(<span class="enscript-string">&quot;%s:  %p is not a usimple lock, 0x%x&quot;</span>, caller, l, l-&gt;lock_type);
	<span class="enscript-keyword">if</span> (!(l-&gt;debug.state &amp; USLOCK_INIT))
		panic(<span class="enscript-string">&quot;%s:  %p is not an initialized lock, 0x%x&quot;</span>, caller, l, l-&gt;debug.state);
	<span class="enscript-keyword">return</span> USLOCK_CHECKING(l);
}


<span class="enscript-comment">/*
 *	Debug checks on a usimple_lock just before attempting
 *	to acquire it.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usld_lock_pre</span>(
	usimple_lock_t	l,
	pc_t		pc)
{
	<span class="enscript-type">char</span>	caller[] = <span class="enscript-string">&quot;usimple_lock&quot;</span>;


	<span class="enscript-keyword">if</span> (!usld_lock_common_checks(l, caller))
		<span class="enscript-keyword">return</span>;

<span class="enscript-comment">/*
 *	Note that we have a weird case where we are getting a lock when we are]
 *	in the process of putting the system to sleep. We are running with no
 *	current threads, therefore we can't tell if we are trying to retake a lock
 *	we have or someone on the other processor has it.  Therefore we just
 *	ignore this test if the locking thread is 0.
 */</span>

	<span class="enscript-keyword">if</span> ((l-&gt;debug.state &amp; USLOCK_TAKEN) &amp;&amp; l-&gt;debug.lock_thread &amp;&amp;
	    l-&gt;debug.lock_thread == (<span class="enscript-type">void</span> *) current_thread()) {
		printf(<span class="enscript-string">&quot;%s:  lock %p already locked (at %p) by&quot;</span>,
		      caller, l, l-&gt;debug.lock_pc);
		printf(<span class="enscript-string">&quot; current thread %p (new attempt at pc %p)\n&quot;</span>,
		       l-&gt;debug.lock_thread, pc);
		panic(<span class="enscript-string">&quot;%s&quot;</span>, caller);
	}
	mp_disable_preemption();
	usl_trace(l, cpu_number(), pc, caller);
	mp_enable_preemption();
}


<span class="enscript-comment">/*
 *	Debug checks on a usimple_lock just after acquiring it.
 *
 *	Pre-emption has been disabled at this point,
 *	so we are safe in using cpu_number.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usld_lock_post</span>(
	usimple_lock_t	l,
	pc_t		pc)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	mycpu;
	<span class="enscript-type">char</span>	caller[] = <span class="enscript-string">&quot;successful usimple_lock&quot;</span>;


	<span class="enscript-keyword">if</span> (!usld_lock_common_checks(l, caller))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!((l-&gt;debug.state &amp; ~USLOCK_TAKEN) == USLOCK_INITIALIZED))
		panic(<span class="enscript-string">&quot;%s:  lock %p became uninitialized&quot;</span>,
		      caller, l);
	<span class="enscript-keyword">if</span> ((l-&gt;debug.state &amp; USLOCK_TAKEN))
		panic(<span class="enscript-string">&quot;%s:  lock 0x%p became TAKEN by someone else&quot;</span>,
		      caller, l);

	mycpu = cpu_number();
	l-&gt;debug.lock_thread = (<span class="enscript-type">void</span> *)current_thread();
	l-&gt;debug.state |= USLOCK_TAKEN;
	l-&gt;debug.lock_pc = pc;
	l-&gt;debug.lock_cpu = mycpu;

	usl_trace(l, mycpu, pc, caller);
}


<span class="enscript-comment">/*
 *	Debug checks on a usimple_lock just before
 *	releasing it.  Note that the caller has not
 *	yet released the hardware lock.
 *
 *	Preemption is still disabled, so there's
 *	no problem using cpu_number.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usld_unlock</span>(
	usimple_lock_t	l,
	pc_t		pc)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	mycpu;
	<span class="enscript-type">char</span>	caller[] = <span class="enscript-string">&quot;usimple_unlock&quot;</span>;


	<span class="enscript-keyword">if</span> (!usld_lock_common_checks(l, caller))
		<span class="enscript-keyword">return</span>;

	mycpu = cpu_number();

	<span class="enscript-keyword">if</span> (!(l-&gt;debug.state &amp; USLOCK_TAKEN))
		panic(<span class="enscript-string">&quot;%s:  lock 0x%p hasn't been taken&quot;</span>,
		      caller, l);
	<span class="enscript-keyword">if</span> (l-&gt;debug.lock_thread != (<span class="enscript-type">void</span> *) current_thread())
		panic(<span class="enscript-string">&quot;%s:  unlocking lock 0x%p, owned by thread %p&quot;</span>,
		      caller, l, l-&gt;debug.lock_thread);
	<span class="enscript-keyword">if</span> (l-&gt;debug.lock_cpu != mycpu) {
		printf(<span class="enscript-string">&quot;%s:  unlocking lock 0x%p on cpu 0x%x&quot;</span>,
		       caller, l, mycpu);
		printf(<span class="enscript-string">&quot; (acquired on cpu 0x%x)\n&quot;</span>, l-&gt;debug.lock_cpu);
		panic(<span class="enscript-string">&quot;%s&quot;</span>, caller);
	}
	usl_trace(l, mycpu, pc, caller);

	l-&gt;debug.unlock_thread = l-&gt;debug.lock_thread;
	l-&gt;debug.lock_thread = INVALID_PC;
	l-&gt;debug.state &amp;= ~USLOCK_TAKEN;
	l-&gt;debug.unlock_pc = pc;
	l-&gt;debug.unlock_cpu = mycpu;
}


<span class="enscript-comment">/*
 *	Debug checks on a usimple_lock just before
 *	attempting to acquire it.
 *
 *	Preemption isn't guaranteed to be disabled.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usld_lock_try_pre</span>(
	usimple_lock_t	l,
	pc_t		pc)
{
	<span class="enscript-type">char</span>	caller[] = <span class="enscript-string">&quot;usimple_lock_try&quot;</span>;

	<span class="enscript-keyword">if</span> (!usld_lock_common_checks(l, caller))
		<span class="enscript-keyword">return</span>;
	mp_disable_preemption();
	usl_trace(l, cpu_number(), pc, caller);
	mp_enable_preemption();
}


<span class="enscript-comment">/*
 *	Debug checks on a usimple_lock just after
 *	successfully attempting to acquire it.
 *
 *	Preemption has been disabled by the
 *	lock acquisition attempt, so it's safe
 *	to use cpu_number.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">usld_lock_try_post</span>(
	usimple_lock_t	l,
	pc_t		pc)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	mycpu;
	<span class="enscript-type">char</span>	caller[] = <span class="enscript-string">&quot;successful usimple_lock_try&quot;</span>;

	<span class="enscript-keyword">if</span> (!usld_lock_common_checks(l, caller))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!((l-&gt;debug.state &amp; ~USLOCK_TAKEN) == USLOCK_INITIALIZED))
		panic(<span class="enscript-string">&quot;%s:  lock 0x%p became uninitialized&quot;</span>,
		      caller, l);
	<span class="enscript-keyword">if</span> ((l-&gt;debug.state &amp; USLOCK_TAKEN))
		panic(<span class="enscript-string">&quot;%s:  lock 0x%p became TAKEN by someone else&quot;</span>,
		      caller, l);

	mycpu = cpu_number();
	l-&gt;debug.lock_thread = (<span class="enscript-type">void</span> *) current_thread();
	l-&gt;debug.state |= USLOCK_TAKEN;
	l-&gt;debug.lock_pc = pc;
	l-&gt;debug.lock_cpu = mycpu;

	usl_trace(l, mycpu, pc, caller);
}


<span class="enscript-comment">/*
 *	For very special cases, set traced_lock to point to a
 *	specific lock of interest.  The result is a series of
 *	XPRs showing lock operations on that lock.  The lock_seq
 *	value is used to show the order of those operations.
 */</span>
usimple_lock_t		traced_lock;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		lock_seq;

<span class="enscript-type">void</span>
<span class="enscript-function-name">usl_trace</span>(
	usimple_lock_t	l,
	<span class="enscript-type">int</span>		mycpu,
	pc_t		pc,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *	op_name)
{
	<span class="enscript-keyword">if</span> (traced_lock == l) {
		XPR(XPR_SLOCK,
		    <span class="enscript-string">&quot;seq %d, cpu %d, %s @ %x\n&quot;</span>,
		    (uintptr_t) lock_seq, (uintptr_t) mycpu,
		    (uintptr_t) op_name, (uintptr_t) pc, 0);
		lock_seq++;
	}
}


#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* USLOCK_DEBUG */</span>

<span class="enscript-comment">/*
 *      Routine:        lck_rw_alloc_init
 */</span>
lck_rw_t *
<span class="enscript-function-name">lck_rw_alloc_init</span>(
	lck_grp_t	*grp,
	lck_attr_t	*attr) {
	lck_rw_t	*lck;

	<span class="enscript-keyword">if</span> ((lck = (lck_rw_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_rw_t))) != 0) {
		bzero(lck, <span class="enscript-keyword">sizeof</span>(lck_rw_t));
		lck_rw_init(lck, grp, attr);
	}

	<span class="enscript-keyword">return</span>(lck);
}

<span class="enscript-comment">/*
 *      Routine:        lck_rw_free
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_free</span>(
	lck_rw_t	*lck,
	lck_grp_t	*grp) {
	lck_rw_destroy(lck, grp);
	kfree(lck, <span class="enscript-keyword">sizeof</span>(lck_rw_t));
}

<span class="enscript-comment">/*
 *      Routine:        lck_rw_init
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_init</span>(
	lck_rw_t	*lck,
	lck_grp_t	*grp,
	lck_attr_t	*attr)
{
	lck_attr_t	*lck_attr = (attr != LCK_ATTR_NULL) ?
					attr : &amp;LockDefaultLckAttr;

	hw_lock_byte_init(&amp;lck-&gt;lck_rw_interlock);
	lck-&gt;lck_rw_want_write = FALSE;
	lck-&gt;lck_rw_want_upgrade = FALSE;
	lck-&gt;lck_rw_shared_count = 0;
	lck-&gt;lck_rw_can_sleep = TRUE;
	lck-&gt;lck_r_waiting = lck-&gt;lck_w_waiting = 0;
	lck-&gt;lck_rw_tag = 0;
	lck-&gt;lck_rw_priv_excl = ((lck_attr-&gt;lck_attr_val &amp;
				LCK_ATTR_RW_SHARED_PRIORITY) == 0);

	lck_grp_reference(grp);
	lck_grp_lckcnt_incr(grp, LCK_TYPE_RW);
}

<span class="enscript-comment">/*
 *      Routine:        lck_rw_destroy
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_destroy</span>(
	lck_rw_t	*lck,
	lck_grp_t	*grp)
{
	<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_tag == LCK_RW_TAG_DESTROYED)
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_LDEBUG</span>
	lck_rw_assert(lck, LCK_RW_ASSERT_NOTHELD);
#<span class="enscript-reference">endif</span>
	lck-&gt;lck_rw_tag = LCK_RW_TAG_DESTROYED;
	lck_grp_lckcnt_decr(grp, LCK_TYPE_RW);
	lck_grp_deallocate(grp);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 *	Sleep locks.  These use the same data structure and algorithm
 *	as the spin locks, but the process sleeps while it is waiting
 *	for the lock.  These work on uniprocessor systems.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DECREMENTER_TIMEOUT</span> 1000000

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RW_LOCK_READER_EVENT</span>(x)		\
		((event_t) (((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*) (x)) + (offsetof(lck_rw_t, lck_rw_tag))))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RW_LOCK_WRITER_EVENT</span>(x)		\
		((event_t) (((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*) (x)) + (offsetof(lck_rw_t, lck_rw_pad8))))

<span class="enscript-comment">/*
 * We disable interrupts while holding the RW interlock to prevent an
 * interrupt from exacerbating hold time.
 * Hence, local helper functions lck_interlock_lock()/lck_interlock_unlock().
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">lck_interlock_lock</span>(lck_rw_t *lck)
{
	boolean_t	istate;

	istate = ml_set_interrupts_enabled(FALSE);	
	hw_lock_byte_lock(&amp;lck-&gt;lck_rw_interlock);

	<span class="enscript-keyword">return</span> istate;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lck_interlock_unlock</span>(lck_rw_t *lck, boolean_t istate)
{               
	hw_lock_byte_unlock(&amp;lck-&gt;lck_rw_interlock);
	ml_set_interrupts_enabled(istate);
}

<span class="enscript-comment">/*
 * This inline is used when busy-waiting for an rw lock.
 * If interrupts were disabled when the lock primitive was called,
 * we poll the IPI handler for pending tlb flushes.
 * XXX This is a hack to avoid deadlocking on the pmap_system_lock.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_lock_pause</span>(boolean_t interrupts_enabled)
{
	<span class="enscript-keyword">if</span> (!interrupts_enabled)
		handle_pending_TLB_flushes();
	cpu_pause();
}


<span class="enscript-comment">/*
 * compute the deadline to spin against when
 * waiting for a change of state on a lck_rw_t
 */</span>
<span class="enscript-type">static</span> inline uint64_t
<span class="enscript-function-name">lck_rw_deadline_for_spin</span>(lck_rw_t *lck)
{
	<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_can_sleep) {
		<span class="enscript-keyword">if</span> (lck-&gt;lck_r_waiting || lck-&gt;lck_w_waiting || lck-&gt;lck_rw_shared_count &gt; machine_info.max_cpus) {
			<span class="enscript-comment">/*
			 * there are already threads waiting on this lock... this
			 * implies that they have spun beyond their deadlines waiting for 
			 * the desired state to show up so we will not bother spinning at this time...
			 *   or
			 * the current number of threads sharing this lock exceeds our capacity to run them
			 * concurrently and since all states we're going to spin for require the rw_shared_count
			 * to be at 0, we'll not bother spinning since the latency for this to happen is
			 * unpredictable...
			 */</span>
			<span class="enscript-keyword">return</span> (mach_absolute_time());
		}
		<span class="enscript-keyword">return</span> (mach_absolute_time() + MutexSpin);
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (mach_absolute_time() + (100000LL * 1000000000LL));
}


<span class="enscript-comment">/*
 *      Routine:        lck_rw_lock_exclusive
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_lock_exclusive_gen</span>(
	lck_rw_t	*lck)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);
	uint64_t	deadline = 0;
	<span class="enscript-type">int</span>		slept = 0;
	<span class="enscript-type">int</span>		gotlock = 0;
	<span class="enscript-type">int</span>		lockheld = 0;
	wait_result_t	res = 0;
	boolean_t	istate = -1;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	boolean_t dtrace_ls_initialized = FALSE;
	boolean_t dtrace_rwl_excl_spin, dtrace_rwl_excl_block, dtrace_ls_enabled= FALSE;
	uint64_t wait_interval = 0;
	<span class="enscript-type">int</span> readers_at_sleep = 0;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 *	Try to acquire the lck_rw_want_write bit.
	 */</span>
	<span class="enscript-keyword">while</span> ( !lck_rw_grab_want(lck)) {

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (dtrace_ls_initialized == FALSE) {
			dtrace_ls_initialized = TRUE;
			dtrace_rwl_excl_spin = (lockstat_probemap[LS_LCK_RW_LOCK_EXCL_SPIN] != 0);
			dtrace_rwl_excl_block = (lockstat_probemap[LS_LCK_RW_LOCK_EXCL_BLOCK] != 0);
			dtrace_ls_enabled = dtrace_rwl_excl_spin || dtrace_rwl_excl_block;
			<span class="enscript-keyword">if</span> (dtrace_ls_enabled) {
				<span class="enscript-comment">/*
				 * Either sleeping or spinning is happening,
				 *  start a timing of our delay interval now.
				 */</span>
				readers_at_sleep = lck-&gt;lck_rw_shared_count;
				wait_interval = mach_absolute_time();
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (istate == -1)
			istate = ml_get_interrupts_enabled();

		deadline = lck_rw_deadline_for_spin(lck);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_WRITER_SPIN_CODE) | DBG_FUNC_START, trace_lck, 0, 0, 0, 0);
		
		<span class="enscript-keyword">while</span> (((gotlock = lck_rw_grab_want(lck)) == 0) &amp;&amp; mach_absolute_time() &lt; deadline)
			lck_rw_lock_pause(istate);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_WRITER_SPIN_CODE) | DBG_FUNC_END, trace_lck, 0, 0, gotlock, 0);

		<span class="enscript-keyword">if</span> (gotlock)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/*
		 * if we get here, the deadline has expired w/o us
		 * being able to grab the lock exclusively
		 * check to see if we're allowed to do a thread_block
		 */</span>
		<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_can_sleep) {

			istate = lck_interlock_lock(lck);

			<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_want_write) {

				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_WRITER_WAIT_CODE) | DBG_FUNC_START, trace_lck, 0, 0, 0, 0);

				lck-&gt;lck_w_waiting = TRUE;

				res = assert_wait(RW_LOCK_WRITER_EVENT(lck), THREAD_UNINT);
				lck_interlock_unlock(lck, istate);

				<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
					res = thread_block(THREAD_CONTINUE_NULL);
					slept++;
				}
				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_WRITER_WAIT_CODE) | DBG_FUNC_END, trace_lck, res, slept, 0, 0);
			} <span class="enscript-keyword">else</span> {
				lck-&gt;lck_rw_want_write = TRUE;
				lck_interlock_unlock(lck, istate);
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	<span class="enscript-comment">/*
	 * Wait for readers (and upgrades) to finish...
	 * the test for these conditions must be done simultaneously with
	 * a check of the interlock not being held since
	 * the rw_shared_count will drop to 0 first and then want_upgrade
	 * will be set to 1 in the shared_to_exclusive scenario... those
	 * adjustments are done behind the interlock and represent an
	 * atomic change in state and must be considered as such
	 * however, once we see the read count at 0, the want_upgrade not set
	 * and the interlock not held, we are safe to proceed
	 */</span>
	<span class="enscript-keyword">while</span> (lck_rw_held_read_or_upgrade(lck)) {

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-comment">/*
		 * Either sleeping or spinning is happening, start
		 * a timing of our delay interval now.  If we set it
		 * to -1 we don't have accurate data so we cannot later
		 * decide to record a dtrace spin or sleep event.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_ls_initialized == FALSE) {
			dtrace_ls_initialized = TRUE;
			dtrace_rwl_excl_spin = (lockstat_probemap[LS_LCK_RW_LOCK_EXCL_SPIN] != 0);
			dtrace_rwl_excl_block = (lockstat_probemap[LS_LCK_RW_LOCK_EXCL_BLOCK] != 0);
			dtrace_ls_enabled = dtrace_rwl_excl_spin || dtrace_rwl_excl_block;
			<span class="enscript-keyword">if</span> (dtrace_ls_enabled) {
				<span class="enscript-comment">/*
				 * Either sleeping or spinning is happening,
				 *  start a timing of our delay interval now.
				 */</span>
				readers_at_sleep = lck-&gt;lck_rw_shared_count;
				wait_interval = mach_absolute_time();
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (istate == -1)
			istate = ml_get_interrupts_enabled();

		deadline = lck_rw_deadline_for_spin(lck);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_READER_SPIN_CODE) | DBG_FUNC_START, trace_lck, 0, 0, 0, 0);

		<span class="enscript-keyword">while</span> ((lockheld = lck_rw_held_read_or_upgrade(lck)) &amp;&amp; mach_absolute_time() &lt; deadline)
			lck_rw_lock_pause(istate);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_READER_SPIN_CODE) | DBG_FUNC_END, trace_lck, 0, 0, lockheld, 0);

		<span class="enscript-keyword">if</span> ( !lockheld)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/*
		 * if we get here, the deadline has expired w/o us
		 * being able to grab the lock exclusively
		 * check to see if we're allowed to do a thread_block
		 */</span>
		<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_can_sleep) {

			istate = lck_interlock_lock(lck);

			<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_shared_count != 0 || lck-&gt;lck_rw_want_upgrade) {
				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_READER_WAIT_CODE) | DBG_FUNC_START, trace_lck, 0, 0, 0, 0);

				lck-&gt;lck_w_waiting = TRUE;

				res = assert_wait(RW_LOCK_WRITER_EVENT(lck), THREAD_UNINT);
				lck_interlock_unlock(lck, istate);

				<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
					res = thread_block(THREAD_CONTINUE_NULL);
					slept++;
				}
				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_READER_WAIT_CODE) | DBG_FUNC_END, trace_lck, res, slept, 0, 0);
			} <span class="enscript-keyword">else</span> {
				lck_interlock_unlock(lck, istate);
				<span class="enscript-comment">/*
				 * must own the lock now, since we checked for
				 * readers or upgrade owner behind the interlock
				 * no need for a call to 'lck_rw_held_read_or_upgrade'
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
		}
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * Decide what latencies we suffered that are Dtrace events.
	 * If we have set wait_interval, then we either spun or slept.
	 * At least we get out from under the interlock before we record
	 * which is the best we can do here to minimize the impact
	 * of the tracing.
	 * If we have set wait_interval to -1, then dtrace was not enabled when we
	 * started sleeping/spinning so we don't record this event.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_ls_enabled == TRUE) {
		<span class="enscript-keyword">if</span> (slept == 0) {
			LOCKSTAT_RECORD2(LS_LCK_RW_LOCK_EXCL_SPIN, lck,
			    mach_absolute_time() - wait_interval, 1);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * For the blocking case, we also record if when we blocked
			 * it was held for read or write, and how many readers.
			 * Notice that above we recorded this before we dropped
			 * the interlock so the count is accurate.
			 */</span>
			LOCKSTAT_RECORD4(LS_LCK_RW_LOCK_EXCL_BLOCK, lck,
			    mach_absolute_time() - wait_interval, 1,
			    (readers_at_sleep == 0 ? 1 : 0), readers_at_sleep);
		}
	}
	LOCKSTAT_RECORD(LS_LCK_RW_LOCK_EXCL_ACQUIRE, lck, 1);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 *      Routine:        lck_rw_done_gen
 *
 *	called from the assembly language wrapper...
 *	prior_lock_state is the value in the 1st
 * 	word of the lock at the time of a successful
 *	atomic compare and exchange with the new value...
 * 	it represents the state of the lock before we
 *	decremented the rw_shared_count or cleared either
 * 	rw_want_upgrade or rw_want_write and
 *	the lck_x_waiting bits...  since the wrapper
 * 	routine has already changed the state atomically, 
 *	we just need to decide if we should
 *	wake up anyone and what value to return... we do
 *	this by examining the state of the lock before
 *	we changed it
 */</span>
lck_rw_type_t
<span class="enscript-function-name">lck_rw_done_gen</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">int</span>		prior_lock_state)
{
	lck_rw_t	*fake_lck;
	lck_rw_type_t	lock_type;
	thread_t	thread;
	uint32_t	rwlock_count;

	<span class="enscript-comment">/*
	 * prior_lock state is a snapshot of the 1st word of the
	 * lock in question... we'll fake up a pointer to it
	 * and carefully not access anything beyond whats defined
	 * in the first word of a lck_rw_t
	 */</span>
	fake_lck = (lck_rw_t *)&amp;prior_lock_state;

	<span class="enscript-keyword">if</span> (fake_lck-&gt;lck_rw_shared_count &lt;= 1) {
		<span class="enscript-keyword">if</span> (fake_lck-&gt;lck_w_waiting)
			thread_wakeup(RW_LOCK_WRITER_EVENT(lck));

		<span class="enscript-keyword">if</span> (!(fake_lck-&gt;lck_rw_priv_excl &amp;&amp; fake_lck-&gt;lck_w_waiting) &amp;&amp; fake_lck-&gt;lck_r_waiting)
			thread_wakeup(RW_LOCK_READER_EVENT(lck));
	}
	<span class="enscript-keyword">if</span> (fake_lck-&gt;lck_rw_shared_count)
		lock_type = LCK_RW_TYPE_SHARED;
	<span class="enscript-keyword">else</span>
		lock_type = LCK_RW_TYPE_EXCLUSIVE;

	<span class="enscript-comment">/* Check if dropping the lock means that we need to unpromote */</span>
	thread = current_thread();
	rwlock_count = thread-&gt;rwlock_count--;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_LDEBUG</span>
	<span class="enscript-keyword">if</span> (rwlock_count == 0) {
		panic(<span class="enscript-string">&quot;rw lock count underflow for thread %p&quot;</span>, thread);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((rwlock_count == 1 <span class="enscript-comment">/* field now 0 */</span>) &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED)) {
		<span class="enscript-comment">/* sched_flags checked without lock, but will be rechecked while clearing */</span>
		lck_rw_clear_promotion(thread);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	LOCKSTAT_RECORD(LS_LCK_RW_DONE_RELEASE, lck, lock_type == LCK_RW_TYPE_SHARED ? 0 : 1);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span>(lock_type);
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_unlock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_unlock</span>(
	lck_rw_t	*lck,
	lck_rw_type_t	lck_rw_type)
{
	<span class="enscript-keyword">if</span> (lck_rw_type == LCK_RW_TYPE_SHARED)
		lck_rw_unlock_shared(lck);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lck_rw_type == LCK_RW_TYPE_EXCLUSIVE)
		lck_rw_unlock_exclusive(lck);
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;lck_rw_unlock(): Invalid RW lock type: %d\n&quot;</span>, lck_rw_type);
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_unlock_shared
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_unlock_shared</span>(
	lck_rw_t	*lck)
{
	lck_rw_type_t	ret;

	ret = lck_rw_done(lck);

	<span class="enscript-keyword">if</span> (ret != LCK_RW_TYPE_SHARED)
		panic(<span class="enscript-string">&quot;lck_rw_unlock(): lock held in mode: %d\n&quot;</span>, ret);
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_unlock_exclusive
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_unlock_exclusive</span>(
	lck_rw_t	*lck)
{
	lck_rw_type_t	ret;

	ret = lck_rw_done(lck);

	<span class="enscript-keyword">if</span> (ret != LCK_RW_TYPE_EXCLUSIVE)
		panic(<span class="enscript-string">&quot;lck_rw_unlock_exclusive(): lock held in mode: %d\n&quot;</span>, ret);
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_lock</span>(
	lck_rw_t	*lck,
	lck_rw_type_t	lck_rw_type)
{
	<span class="enscript-keyword">if</span> (lck_rw_type == LCK_RW_TYPE_SHARED)
		lck_rw_lock_shared(lck);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lck_rw_type == LCK_RW_TYPE_EXCLUSIVE)
		lck_rw_lock_exclusive(lck);
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;lck_rw_lock(): Invalid RW lock type: %x\n&quot;</span>, lck_rw_type);
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_lock_shared_gen
 *	Function:
 *		assembly fast path code has determined that this lock
 *		is held exclusively... this is where we spin/block
 *		until we can acquire the lock in the shared mode
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_lock_shared_gen</span>(
	lck_rw_t	*lck)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);
	uint64_t	deadline = 0;
	<span class="enscript-type">int</span>		gotlock = 0;
	<span class="enscript-type">int</span>		slept = 0;
	wait_result_t	res = 0;
	boolean_t	istate = -1;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	uint64_t wait_interval = 0;
	<span class="enscript-type">int</span> readers_at_sleep = 0;
	boolean_t dtrace_ls_initialized = FALSE;
	boolean_t dtrace_rwl_shared_spin, dtrace_rwl_shared_block, dtrace_ls_enabled = FALSE;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">while</span> ( !lck_rw_grab_shared(lck)) {

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (dtrace_ls_initialized == FALSE) {
			dtrace_ls_initialized = TRUE;
			dtrace_rwl_shared_spin = (lockstat_probemap[LS_LCK_RW_LOCK_SHARED_SPIN] != 0);
			dtrace_rwl_shared_block = (lockstat_probemap[LS_LCK_RW_LOCK_SHARED_BLOCK] != 0);
			dtrace_ls_enabled = dtrace_rwl_shared_spin || dtrace_rwl_shared_block;
			<span class="enscript-keyword">if</span> (dtrace_ls_enabled) {
				<span class="enscript-comment">/*
				 * Either sleeping or spinning is happening,
				 *  start a timing of our delay interval now.
				 */</span>
				readers_at_sleep = lck-&gt;lck_rw_shared_count;
				wait_interval = mach_absolute_time();
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (istate == -1)
			istate = ml_get_interrupts_enabled();

		deadline = lck_rw_deadline_for_spin(lck);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SHARED_SPIN_CODE) | DBG_FUNC_START,
			     trace_lck, lck-&gt;lck_rw_want_write, lck-&gt;lck_rw_want_upgrade, 0, 0);

		<span class="enscript-keyword">while</span> (((gotlock = lck_rw_grab_shared(lck)) == 0) &amp;&amp; mach_absolute_time() &lt; deadline)
			lck_rw_lock_pause(istate);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SHARED_SPIN_CODE) | DBG_FUNC_END,
			     trace_lck, lck-&gt;lck_rw_want_write, lck-&gt;lck_rw_want_upgrade, gotlock, 0);

		<span class="enscript-keyword">if</span> (gotlock)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/*
		 * if we get here, the deadline has expired w/o us
		 * being able to grab the lock for read
		 * check to see if we're allowed to do a thread_block
		 */</span>
		<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_can_sleep) {

			istate = lck_interlock_lock(lck);

			<span class="enscript-keyword">if</span> ((lck-&gt;lck_rw_want_write || lck-&gt;lck_rw_want_upgrade) &amp;&amp;
			    ((lck-&gt;lck_rw_shared_count == 0) || lck-&gt;lck_rw_priv_excl)) {

				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SHARED_WAIT_CODE) | DBG_FUNC_START,
					     trace_lck, lck-&gt;lck_rw_want_write, lck-&gt;lck_rw_want_upgrade, 0, 0);

				lck-&gt;lck_r_waiting = TRUE;

				res = assert_wait(RW_LOCK_READER_EVENT(lck), THREAD_UNINT);
				lck_interlock_unlock(lck, istate);

				<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
					res = thread_block(THREAD_CONTINUE_NULL);
					slept++;
				}
				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SHARED_WAIT_CODE) | DBG_FUNC_END,
					     trace_lck, res, slept, 0, 0);
			} <span class="enscript-keyword">else</span> {
				lck-&gt;lck_rw_shared_count++;
				lck_interlock_unlock(lck, istate);
				<span class="enscript-keyword">break</span>;
			}
		}
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-keyword">if</span> (dtrace_ls_enabled == TRUE) {
		<span class="enscript-keyword">if</span> (slept == 0) {
			LOCKSTAT_RECORD2(LS_LCK_RW_LOCK_SHARED_SPIN, lck, mach_absolute_time() - wait_interval, 0);
		} <span class="enscript-keyword">else</span> {
			LOCKSTAT_RECORD4(LS_LCK_RW_LOCK_SHARED_BLOCK, lck,
			    mach_absolute_time() - wait_interval, 0,
			    (readers_at_sleep == 0 ? 1 : 0), readers_at_sleep);
		}
	}
	LOCKSTAT_RECORD(LS_LCK_RW_LOCK_SHARED_ACQUIRE, lck, 0);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_lock_shared_to_exclusive_failure
 *	Function:
 *		assembly fast path code has already dropped our read
 *		count and determined that someone else owns 'lck_rw_want_upgrade'
 *		if 'lck_rw_shared_count' == 0, its also already dropped 'lck_w_waiting'
 *		all we need to do here is determine if a wakeup is needed
 */</span>
boolean_t
<span class="enscript-function-name">lck_rw_lock_shared_to_exclusive_failure</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">int</span>		prior_lock_state)
{
	lck_rw_t	*fake_lck;
	thread_t	thread = current_thread();
	uint32_t	rwlock_count;

	<span class="enscript-comment">/* Check if dropping the lock means that we need to unpromote */</span>
	rwlock_count = thread-&gt;rwlock_count--;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_LDEBUG</span>
	<span class="enscript-keyword">if</span> (rwlock_count == 0) {
		panic(<span class="enscript-string">&quot;rw lock count underflow for thread %p&quot;</span>, thread);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((rwlock_count == 1 <span class="enscript-comment">/* field now 0 */</span>) &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED)) {
		<span class="enscript-comment">/* sched_flags checked without lock, but will be rechecked while clearing */</span>
		lck_rw_clear_promotion(thread);
	}

	<span class="enscript-comment">/*
	 * prior_lock state is a snapshot of the 1st word of the
	 * lock in question... we'll fake up a pointer to it
	 * and carefully not access anything beyond whats defined
	 * in the first word of a lck_rw_t
	 */</span>
	fake_lck = (lck_rw_t *)&amp;prior_lock_state;

	<span class="enscript-keyword">if</span> (fake_lck-&gt;lck_w_waiting &amp;&amp; fake_lck-&gt;lck_rw_shared_count == 1) {
		<span class="enscript-comment">/*
		 *	Someone else has requested upgrade.
		 *	Since we've released the read lock, wake
		 *	him up if he's blocked waiting
		 */</span>
		thread_wakeup(RW_LOCK_WRITER_EVENT(lck));
	}
	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SH_TO_EX_CODE) | DBG_FUNC_NONE,
		     VM_KERNEL_UNSLIDE_OR_PERM(lck), lck-&gt;lck_rw_shared_count, lck-&gt;lck_rw_want_upgrade, 0, 0);

	<span class="enscript-keyword">return</span> (FALSE);
}


<span class="enscript-comment">/*
 *	Routine:	lck_rw_lock_shared_to_exclusive_failure
 *	Function:
 *		assembly fast path code has already dropped our read
 *		count and successfully acquired 'lck_rw_want_upgrade'
 *		we just need to wait for the rest of the readers to drain
 *		and then we can return as the exclusive holder of this lock
 */</span>
boolean_t
<span class="enscript-function-name">lck_rw_lock_shared_to_exclusive_success</span>(
	lck_rw_t	*lck)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);
	uint64_t	deadline = 0;
	<span class="enscript-type">int</span>		slept = 0;
	<span class="enscript-type">int</span>		still_shared = 0;
	wait_result_t	res;
	boolean_t	istate = -1;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	uint64_t wait_interval = 0;
	<span class="enscript-type">int</span> readers_at_sleep = 0;
	boolean_t dtrace_ls_initialized = FALSE;
	boolean_t dtrace_rwl_shared_to_excl_spin, dtrace_rwl_shared_to_excl_block, dtrace_ls_enabled = FALSE;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">while</span> (lck-&gt;lck_rw_shared_count != 0) {

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (dtrace_ls_initialized == FALSE) {
			dtrace_ls_initialized = TRUE;
			dtrace_rwl_shared_to_excl_spin = (lockstat_probemap[LS_LCK_RW_LOCK_SHARED_TO_EXCL_SPIN] != 0);
			dtrace_rwl_shared_to_excl_block = (lockstat_probemap[LS_LCK_RW_LOCK_SHARED_TO_EXCL_BLOCK] != 0);
			dtrace_ls_enabled = dtrace_rwl_shared_to_excl_spin || dtrace_rwl_shared_to_excl_block;
			<span class="enscript-keyword">if</span> (dtrace_ls_enabled) {
				<span class="enscript-comment">/*
				 * Either sleeping or spinning is happening,
				 *  start a timing of our delay interval now.
				 */</span>
				readers_at_sleep = lck-&gt;lck_rw_shared_count;
				wait_interval = mach_absolute_time();
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (istate == -1)
			istate = ml_get_interrupts_enabled();

		deadline = lck_rw_deadline_for_spin(lck);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SH_TO_EX_SPIN_CODE) | DBG_FUNC_START,
			     trace_lck, lck-&gt;lck_rw_shared_count, 0, 0, 0);

		<span class="enscript-keyword">while</span> ((still_shared = lck-&gt;lck_rw_shared_count) &amp;&amp; mach_absolute_time() &lt; deadline)
			lck_rw_lock_pause(istate);

		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SH_TO_EX_SPIN_CODE) | DBG_FUNC_END,
			     trace_lck, lck-&gt;lck_rw_shared_count, 0, 0, 0);

		<span class="enscript-keyword">if</span> ( !still_shared)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/*
		 * if we get here, the deadline has expired w/o
		 * the rw_shared_count having drained to 0
		 * check to see if we're allowed to do a thread_block
		 */</span>
		<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_can_sleep) {
			
			istate = lck_interlock_lock(lck);
			
			<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_shared_count != 0) {
				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SH_TO_EX_WAIT_CODE) | DBG_FUNC_START,
					     trace_lck, lck-&gt;lck_rw_shared_count, 0, 0, 0);

				lck-&gt;lck_w_waiting = TRUE;

				res = assert_wait(RW_LOCK_WRITER_EVENT(lck), THREAD_UNINT);
				lck_interlock_unlock(lck, istate);

				<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
					res = thread_block(THREAD_CONTINUE_NULL);
					slept++;
				}
				KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_SH_TO_EX_WAIT_CODE) | DBG_FUNC_END,
					     trace_lck, res, slept, 0, 0);
			} <span class="enscript-keyword">else</span> {
				lck_interlock_unlock(lck, istate);
				<span class="enscript-keyword">break</span>;
			}
		}
	}
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * We infer whether we took the sleep/spin path above by checking readers_at_sleep.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_ls_enabled == TRUE) {
		<span class="enscript-keyword">if</span> (slept == 0) {
			LOCKSTAT_RECORD2(LS_LCK_RW_LOCK_SHARED_TO_EXCL_SPIN, lck, mach_absolute_time() - wait_interval, 0);
		} <span class="enscript-keyword">else</span> {
			LOCKSTAT_RECORD4(LS_LCK_RW_LOCK_SHARED_TO_EXCL_BLOCK, lck,
			    mach_absolute_time() - wait_interval, 1,
			    (readers_at_sleep == 0 ? 1 : 0), readers_at_sleep);
		}
	}
	LOCKSTAT_RECORD(LS_LCK_RW_LOCK_SHARED_TO_EXCL_UPGRADE, lck, 1);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (TRUE);
}


<span class="enscript-comment">/*
 *      Routine:        lck_rw_lock_exclusive_to_shared
 * 	Function:
 *		assembly fast path has already dropped
 *		our exclusive state and bumped lck_rw_shared_count
 *		all we need to do here is determine if anyone
 *		needs to be awakened.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_lock_exclusive_to_shared_gen</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">int</span>		prior_lock_state)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);
	lck_rw_t		*fake_lck;

	<span class="enscript-comment">/*
	 * prior_lock state is a snapshot of the 1st word of the
	 * lock in question... we'll fake up a pointer to it
	 * and carefully not access anything beyond whats defined
	 * in the first word of a lck_rw_t
	 */</span>
	fake_lck = (lck_rw_t *)&amp;prior_lock_state;

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_TO_SH_CODE) | DBG_FUNC_START,
			     trace_lck, fake_lck-&gt;lck_rw_want_write, fake_lck-&gt;lck_rw_want_upgrade, 0, 0);

	<span class="enscript-comment">/*
	 * don't wake up anyone waiting to take the lock exclusively
	 * since we hold a read count... when the read count drops to 0,
	 * the writers will be woken.
	 *
	 * wake up any waiting readers if we don't have any writers waiting,
	 * or the lock is NOT marked as rw_priv_excl (writers have privilege)
	 */</span>
	<span class="enscript-keyword">if</span> (!(fake_lck-&gt;lck_rw_priv_excl &amp;&amp; fake_lck-&gt;lck_w_waiting) &amp;&amp; fake_lck-&gt;lck_r_waiting)
		thread_wakeup(RW_LOCK_READER_EVENT(lck));

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_RW_LCK_EX_TO_SH_CODE) | DBG_FUNC_END,
			     trace_lck, lck-&gt;lck_rw_want_write, lck-&gt;lck_rw_want_upgrade, lck-&gt;lck_rw_shared_count, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	LOCKSTAT_RECORD(LS_LCK_RW_LOCK_EXCL_TO_SHARED_DOWNGRADE, lck, 0);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 *      Routine:        lck_rw_try_lock
 */</span>
boolean_t
<span class="enscript-function-name">lck_rw_try_lock</span>(
	lck_rw_t	*lck,
	lck_rw_type_t	lck_rw_type)
{
	<span class="enscript-keyword">if</span> (lck_rw_type == LCK_RW_TYPE_SHARED)
		<span class="enscript-keyword">return</span>(lck_rw_try_lock_shared(lck));
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lck_rw_type == LCK_RW_TYPE_EXCLUSIVE)
		<span class="enscript-keyword">return</span>(lck_rw_try_lock_exclusive(lck));
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;lck_rw_try_lock(): Invalid rw lock type: %x\n&quot;</span>, lck_rw_type);
	<span class="enscript-keyword">return</span>(FALSE);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_assert</span>(
	lck_rw_t	*lck,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	type)
{
	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_RW_ASSERT_SHARED</span>:
		<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_shared_count != 0) {
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_RW_ASSERT_EXCLUSIVE</span>:
		<span class="enscript-keyword">if</span> ((lck-&gt;lck_rw_want_write ||
		     lck-&gt;lck_rw_want_upgrade) &amp;&amp;
		    lck-&gt;lck_rw_shared_count == 0) {
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_RW_ASSERT_HELD</span>:
		<span class="enscript-keyword">if</span> (lck-&gt;lck_rw_want_write ||
		    lck-&gt;lck_rw_want_upgrade ||
		    lck-&gt;lck_rw_shared_count != 0) {
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_RW_ASSERT_NOTHELD</span>:
		<span class="enscript-keyword">if</span> (!(lck-&gt;lck_rw_want_write ||
			  lck-&gt;lck_rw_want_upgrade ||
			  lck-&gt;lck_rw_shared_count != 0)) {
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	panic(<span class="enscript-string">&quot;rw lock (%p)%s held (mode=%u), first word %08x\n&quot;</span>, lck, (type == LCK_RW_ASSERT_NOTHELD ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot; not&quot;</span>), type, *(uint32_t *)lck);
}

<span class="enscript-comment">/* On return to userspace, this routine is called if the rwlock_count is somehow imbalanced */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_rw_clear_promotions_x86</span>(thread_t thread)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_LDEBUG</span>
	<span class="enscript-comment">/* It's fatal to leave a RW lock locked and return to userspace */</span>
	panic(<span class="enscript-string">&quot;%u rw lock(s) held on return to userspace for thread %p&quot;</span>, thread-&gt;rwlock_count, thread);
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/* Paper over the issue */</span>
	thread-&gt;rwlock_count = 0;
	lck_rw_clear_promotion(thread);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 * Routine: kdp_lck_rw_lock_is_acquired_exclusive
 * NOT SAFE: To be used only by kernel debugger to avoid deadlock.
 */</span>
boolean_t
<span class="enscript-function-name">kdp_lck_rw_lock_is_acquired_exclusive</span>(lck_rw_t *lck) {
	<span class="enscript-keyword">if</span> (not_in_kdp) {
		panic(<span class="enscript-string">&quot;panic: rw lock exclusive check done outside of kernel debugger&quot;</span>);
	}
	<span class="enscript-keyword">return</span> ((lck-&gt;lck_rw_want_upgrade || lck-&gt;lck_rw_want_write) &amp;&amp; (lck-&gt;lck_rw_shared_count == 0)) ? TRUE : FALSE;
}


#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MUTEX_ZONE</span>
<span class="enscript-type">extern</span> zone_t lck_mtx_zone;
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*
 *      Routine:        lck_mtx_alloc_init
 */</span>
lck_mtx_t *
<span class="enscript-function-name">lck_mtx_alloc_init</span>(
	lck_grp_t	*grp,
	lck_attr_t	*attr)
{
	lck_mtx_t	*lck;
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MUTEX_ZONE</span>
	<span class="enscript-keyword">if</span> ((lck = (lck_mtx_t *)zalloc(lck_mtx_zone)) != 0)
		lck_mtx_init(lck, grp, attr);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> ((lck = (lck_mtx_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_mtx_t))) != 0)
		lck_mtx_init(lck, grp, attr);
#<span class="enscript-reference">endif</span>		
	<span class="enscript-keyword">return</span>(lck);
}

<span class="enscript-comment">/*
 *      Routine:        lck_mtx_free
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_free</span>(
	lck_mtx_t	*lck,
	lck_grp_t	*grp)
{
	lck_mtx_destroy(lck, grp);
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MUTEX_ZONE</span>
	zfree(lck_mtx_zone, lck);
#<span class="enscript-reference">else</span>
	kfree(lck, <span class="enscript-keyword">sizeof</span>(lck_mtx_t));
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 *      Routine:        lck_mtx_ext_init
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_ext_init</span>(
	lck_mtx_ext_t	*lck,
	lck_grp_t	*grp,
	lck_attr_t	*attr)
{
	bzero((<span class="enscript-type">void</span> *)lck, <span class="enscript-keyword">sizeof</span>(lck_mtx_ext_t));

	<span class="enscript-keyword">if</span> ((attr-&gt;lck_attr_val) &amp; LCK_ATTR_DEBUG) {
		lck-&gt;lck_mtx_deb.type = MUTEX_TAG;
		lck-&gt;lck_mtx_attr |= LCK_MTX_ATTR_DEBUG;
	}

	lck-&gt;lck_mtx_grp = grp;

	<span class="enscript-keyword">if</span> (grp-&gt;lck_grp_attr &amp; LCK_GRP_ATTR_STAT)
		lck-&gt;lck_mtx_attr |= LCK_MTX_ATTR_STAT;

	lck-&gt;lck_mtx.lck_mtx_is_ext = 1;
	lck-&gt;lck_mtx.lck_mtx_sw.lck_mtxd.lck_mtxd_pad32 = 0xFFFFFFFF;
}

<span class="enscript-comment">/*
 *      Routine:        lck_mtx_init
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_init</span>(
	lck_mtx_t	*lck,
	lck_grp_t	*grp,
	lck_attr_t	*attr)
{
	lck_mtx_ext_t	*lck_ext;
	lck_attr_t	*lck_attr;

	<span class="enscript-keyword">if</span> (attr != LCK_ATTR_NULL)
		lck_attr = attr;
	<span class="enscript-keyword">else</span>
		lck_attr = &amp;LockDefaultLckAttr;

	<span class="enscript-keyword">if</span> ((lck_attr-&gt;lck_attr_val) &amp; LCK_ATTR_DEBUG) {
		<span class="enscript-keyword">if</span> ((lck_ext = (lck_mtx_ext_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_mtx_ext_t))) != 0) {
			lck_mtx_ext_init(lck_ext, grp, lck_attr);	
			lck-&gt;lck_mtx_tag = LCK_MTX_TAG_INDIRECT;
			lck-&gt;lck_mtx_ptr = lck_ext;
		}
	} <span class="enscript-keyword">else</span> {
		lck-&gt;lck_mtx_owner = 0;
		lck-&gt;lck_mtx_state = 0;
	}
	lck-&gt;lck_mtx_sw.lck_mtxd.lck_mtxd_pad32 = 0xFFFFFFFF;
	lck_grp_reference(grp);
	lck_grp_lckcnt_incr(grp, LCK_TYPE_MTX);
}

<span class="enscript-comment">/*
 *      Routine:        lck_mtx_init_ext
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_init_ext</span>(
	lck_mtx_t	*lck,
	lck_mtx_ext_t	*lck_ext,
	lck_grp_t	*grp,
	lck_attr_t	*attr)
{
	lck_attr_t	*lck_attr;

	<span class="enscript-keyword">if</span> (attr != LCK_ATTR_NULL)
		lck_attr = attr;
	<span class="enscript-keyword">else</span>
		lck_attr = &amp;LockDefaultLckAttr;

	<span class="enscript-keyword">if</span> ((lck_attr-&gt;lck_attr_val) &amp; LCK_ATTR_DEBUG) {
		lck_mtx_ext_init(lck_ext, grp, lck_attr);
		lck-&gt;lck_mtx_tag = LCK_MTX_TAG_INDIRECT;
		lck-&gt;lck_mtx_ptr = lck_ext;
	} <span class="enscript-keyword">else</span> {
		lck-&gt;lck_mtx_owner = 0;
		lck-&gt;lck_mtx_state = 0;
	}
	lck-&gt;lck_mtx_sw.lck_mtxd.lck_mtxd_pad32 = 0xFFFFFFFF;

	lck_grp_reference(grp);
	lck_grp_lckcnt_incr(grp, LCK_TYPE_MTX);
}

<span class="enscript-comment">/*
 *      Routine:        lck_mtx_destroy
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_destroy</span>(
	lck_mtx_t	*lck,
	lck_grp_t	*grp)
{
	boolean_t lck_is_indirect;
	
	<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag == LCK_MTX_TAG_DESTROYED)
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_LDEBUG</span>
	lck_mtx_assert(lck, LCK_MTX_ASSERT_NOTOWNED);
#<span class="enscript-reference">endif</span>
	lck_is_indirect = (lck-&gt;lck_mtx_tag == LCK_MTX_TAG_INDIRECT);

	lck_mtx_lock_mark_destroyed(lck);

	<span class="enscript-keyword">if</span> (lck_is_indirect)
		kfree(lck-&gt;lck_mtx_ptr, <span class="enscript-keyword">sizeof</span>(lck_mtx_ext_t));
	lck_grp_lckcnt_decr(grp, LCK_TYPE_MTX);
	lck_grp_deallocate(grp);
	<span class="enscript-keyword">return</span>;
}


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_LCK_WAIT_CODE</span>		0x20
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_LCK_WAKEUP_CODE</span>		0x21
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_LCK_SPIN_CODE</span>		0x22
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_LCK_ACQUIRE_CODE</span>	0x23
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LCK_MTX_LCK_DEMOTE_CODE</span>		0x24


<span class="enscript-comment">/*
 * Routine: 	lck_mtx_unlock_wakeup_x86
 *
 * Invoked on unlock when there is 
 * contention (i.e. the assembly routine sees that
 * that mutex-&gt;lck_mtx_waiters != 0 or 
 * that mutex-&gt;lck_mtx_promoted != 0...
 *
 * neither the mutex or interlock is held
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_unlock_wakeup_x86</span> (
	lck_mtx_t	*mutex,
	<span class="enscript-type">int</span>		prior_lock_state)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(mutex);
	lck_mtx_t		fake_lck;

	<span class="enscript-comment">/*
	 * prior_lock state is a snapshot of the 2nd word of the
	 * lock in question... we'll fake up a lock with the bits
	 * copied into place and carefully not access anything
	 * beyond whats defined in the second word of a lck_mtx_t
	 */</span>
	fake_lck.lck_mtx_state = prior_lock_state;

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_WAKEUP_CODE) | DBG_FUNC_START,
		     trace_lck, fake_lck.lck_mtx_promoted, fake_lck.lck_mtx_waiters, fake_lck.lck_mtx_pri, 0);

	<span class="enscript-keyword">if</span> (__probable(fake_lck.lck_mtx_waiters)) {
		<span class="enscript-keyword">if</span> (fake_lck.lck_mtx_waiters &gt; 1)
			thread_wakeup_one_with_pri(LCK_MTX_EVENT(mutex), fake_lck.lck_mtx_pri);
		<span class="enscript-keyword">else</span>
			thread_wakeup_one(LCK_MTX_EVENT(mutex));
	}

	<span class="enscript-keyword">if</span> (__improbable(fake_lck.lck_mtx_promoted)) {
		thread_t	thread = current_thread();


		KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_DEMOTE_CODE) | DBG_FUNC_NONE,
			     thread_tid(thread), thread-&gt;promotions, thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED, 0, 0);

		<span class="enscript-keyword">if</span> (thread-&gt;promotions &gt; 0) {
			spl_t	s = splsched();

			thread_lock(thread);

			<span class="enscript-keyword">if</span> (--thread-&gt;promotions == 0 &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED)) {

				thread-&gt;sched_flags &amp;= ~TH_SFLAG_PROMOTED;

				<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED) {
					<span class="enscript-comment">/* Thread still has a RW lock promotion */</span>
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK) {
					KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_DEMOTE) | DBG_FUNC_NONE,
							      thread-&gt;sched_pri, DEPRESSPRI, 0, trace_lck, 0);

					set_sched_pri(thread, DEPRESSPRI);
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (thread-&gt;base_pri &lt; thread-&gt;sched_pri) {
						KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_DEMOTE) | DBG_FUNC_NONE,
								      thread-&gt;sched_pri, thread-&gt;base_pri, 0, trace_lck, 0);

						thread_recompute_sched_pri(thread, FALSE);
					}
				}
			}
			thread_unlock(thread);
			splx(s);
		}
	}
	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_WAKEUP_CODE) | DBG_FUNC_END,
		     trace_lck, 0, mutex-&gt;lck_mtx_waiters, 0, 0);
}


<span class="enscript-comment">/*
 * Routine: 	lck_mtx_lock_acquire_x86
 *
 * Invoked on acquiring the mutex when there is
 * contention (i.e. the assembly routine sees that
 * that mutex-&gt;lck_mtx_waiters != 0 or 
 * thread-&gt;was_promoted_on_wakeup != 0)...
 *
 * mutex is owned...  interlock is held... preemption is disabled
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_lock_acquire_x86</span>(
	lck_mtx_t	*mutex)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(mutex);
	thread_t		thread;
	integer_t		priority;
	spl_t			s;

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_ACQUIRE_CODE) | DBG_FUNC_START,
		     trace_lck, thread-&gt;was_promoted_on_wakeup, mutex-&gt;lck_mtx_waiters, mutex-&gt;lck_mtx_pri, 0);

	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_waiters)
		priority = mutex-&gt;lck_mtx_pri;
	<span class="enscript-keyword">else</span>
		priority = 0;

	thread = (thread_t)mutex-&gt;lck_mtx_owner;	<span class="enscript-comment">/* faster then current_thread() */</span>

	<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &lt; priority || thread-&gt;was_promoted_on_wakeup) {

		KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_PROMOTE) | DBG_FUNC_NONE,
				      thread-&gt;sched_pri, priority, thread-&gt;was_promoted_on_wakeup, trace_lck, 0);

		s = splsched();
		thread_lock(thread);

		<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &lt; priority) {
			<span class="enscript-comment">/* Do not promote past promotion ceiling */</span>
			assert(priority &lt;= MAXPRI_PROMOTE);
			set_sched_pri(thread, priority);
		}
		<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_promoted == 0) {
			mutex-&gt;lck_mtx_promoted = 1;
			
			thread-&gt;promotions++;
			thread-&gt;sched_flags |= TH_SFLAG_PROMOTED;
		}
		thread-&gt;was_promoted_on_wakeup = 0;
		
		thread_unlock(thread);
		splx(s);
	}
	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_ACQUIRE_CODE) | DBG_FUNC_END,
		     trace_lck, 0, mutex-&gt;lck_mtx_waiters, 0, 0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lck_mtx_interlock_try_lock</span>(lck_mtx_t *mutex, boolean_t *istate)
{
	<span class="enscript-type">int</span>		retval;

	*istate = ml_set_interrupts_enabled(FALSE);
	retval = lck_mtx_ilk_try_lock(mutex);

	<span class="enscript-keyword">if</span> (retval == 0)
		ml_set_interrupts_enabled(*istate);

	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_interlock_unlock</span>(lck_mtx_t *mutex, boolean_t istate)
{               
	lck_mtx_ilk_unlock(mutex);
	ml_set_interrupts_enabled(istate);
}


<span class="enscript-comment">/*
 * Routine: 	lck_mtx_lock_spinwait_x86
 *
 * Invoked trying to acquire a mutex when there is contention but
 * the holder is running on another processor. We spin for up to a maximum
 * time waiting for the lock to be released.
 *
 * Called with the interlock unlocked.
 * returns 0 if mutex acquired
 * returns 1 if we spun
 * returns 2 if we didn't spin due to the holder not running
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lck_mtx_lock_spinwait_x86</span>(
	lck_mtx_t	*mutex)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(mutex);
	thread_t	holder;
	uint64_t	overall_deadline;
	uint64_t	check_owner_deadline;
	uint64_t	cur_time;
	<span class="enscript-type">int</span>		retval = 1;
	<span class="enscript-type">int</span>		loopcount = 0;

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_SPIN_CODE) | DBG_FUNC_START,
		     trace_lck, VM_KERNEL_UNSLIDE_OR_PERM(mutex-&gt;lck_mtx_owner), mutex-&gt;lck_mtx_waiters, 0, 0);

	cur_time = mach_absolute_time();
	overall_deadline = cur_time + MutexSpin;
	check_owner_deadline = cur_time;

	<span class="enscript-comment">/*
	 * Spin while:
	 *   - mutex is locked, and
	 *   - its locked as a spin lock, and
	 *   - owner is running on another processor, and
	 *   - owner (processor) is not idling, and
	 *   - we haven't spun for long enough.
	 */</span>
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (__probable(lck_mtx_lock_grab_mutex(mutex))) {
			retval = 0;
			<span class="enscript-keyword">break</span>;
		}
		cur_time = mach_absolute_time();

		<span class="enscript-keyword">if</span> (cur_time &gt;= overall_deadline)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (cur_time &gt;= check_owner_deadline &amp;&amp; mutex-&gt;lck_mtx_owner) {
			boolean_t	istate;

			<span class="enscript-keyword">if</span> (lck_mtx_interlock_try_lock(mutex, &amp;istate)) {

				<span class="enscript-keyword">if</span> ((holder = (thread_t) mutex-&gt;lck_mtx_owner) != NULL) {

					<span class="enscript-keyword">if</span> ( !(holder-&gt;machine.specFlags &amp; OnProc) ||
					     (holder-&gt;state &amp; TH_IDLE)) {

						lck_mtx_interlock_unlock(mutex, istate);

						<span class="enscript-keyword">if</span> (loopcount == 0)
							retval = 2;
						<span class="enscript-keyword">break</span>;
					}
				}
				lck_mtx_interlock_unlock(mutex, istate);

				check_owner_deadline = cur_time + (MutexSpin / 4);
			}
		}
		cpu_pause();

		loopcount++;

	} <span class="enscript-keyword">while</span> (TRUE);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * We've already kept a count via overall_deadline of how long we spun.
	 * If dtrace is active, then we compute backwards to decide how
	 * long we spun.
	 *
	 * Note that we record a different probe id depending on whether
	 * this is a direct or indirect mutex.  This allows us to 
	 * penalize only lock groups that have debug/stats enabled
	 * with dtrace processing if desired.
	 */</span>
	<span class="enscript-keyword">if</span> (__probable(mutex-&gt;lck_mtx_is_ext == 0)) {
		LOCKSTAT_RECORD(LS_LCK_MTX_LOCK_SPIN, mutex,
			mach_absolute_time() - (overall_deadline - MutexSpin));
	} <span class="enscript-keyword">else</span> {
		LOCKSTAT_RECORD(LS_LCK_MTX_EXT_LOCK_SPIN, mutex,
			mach_absolute_time() - (overall_deadline - MutexSpin));
	}
	<span class="enscript-comment">/* The lockstat acquire event is recorded by the assembly code beneath us. */</span>
#<span class="enscript-reference">endif</span>

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_SPIN_CODE) | DBG_FUNC_END,
		     trace_lck, VM_KERNEL_UNSLIDE_OR_PERM(mutex-&gt;lck_mtx_owner), mutex-&gt;lck_mtx_waiters, retval, 0);

	<span class="enscript-keyword">return</span> retval;
}



<span class="enscript-comment">/*
 * Routine: 	lck_mtx_lock_wait_x86
 *
 * Invoked in order to wait on contention.
 *
 * Called with the interlock locked and
 * preemption disabled...  
 * returns it unlocked and with preemption enabled
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_lock_wait_x86</span> (
	lck_mtx_t	*mutex)
{
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(mutex);
	thread_t	self = current_thread();
	thread_t	holder;
	integer_t	priority;
	spl_t		s;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	uint64_t	sleep_start = 0;

	<span class="enscript-keyword">if</span> (lockstat_probemap[LS_LCK_MTX_LOCK_BLOCK] || lockstat_probemap[LS_LCK_MTX_EXT_LOCK_BLOCK]) {
		sleep_start = mach_absolute_time();
	}
#<span class="enscript-reference">endif</span>
	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_WAIT_CODE) | DBG_FUNC_START,
		     trace_lck, VM_KERNEL_UNSLIDE_OR_PERM(mutex-&gt;lck_mtx_owner), mutex-&gt;lck_mtx_waiters, mutex-&gt;lck_mtx_pri, 0);

	priority = self-&gt;sched_pri;

	<span class="enscript-keyword">if</span> (priority &lt; self-&gt;base_pri)
		priority = self-&gt;base_pri;
	<span class="enscript-keyword">if</span> (priority &lt; BASEPRI_DEFAULT)
		priority = BASEPRI_DEFAULT;

	<span class="enscript-comment">/* Do not promote past promotion ceiling */</span>
	priority = MIN(priority, MAXPRI_PROMOTE);

	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_waiters == 0 || priority &gt; mutex-&gt;lck_mtx_pri)
		mutex-&gt;lck_mtx_pri = priority;
	mutex-&gt;lck_mtx_waiters++;

	<span class="enscript-keyword">if</span> ( (holder = (thread_t)mutex-&gt;lck_mtx_owner) &amp;&amp;
	     holder-&gt;sched_pri &lt; mutex-&gt;lck_mtx_pri ) {
		s = splsched();
		thread_lock(holder);

		<span class="enscript-comment">/* holder priority may have been bumped by another thread
		 * before thread_lock was taken
		 */</span>
		<span class="enscript-keyword">if</span> (holder-&gt;sched_pri &lt; mutex-&gt;lck_mtx_pri) {
			KERNEL_DEBUG_CONSTANT(
				MACHDBG_CODE(DBG_MACH_SCHED, MACH_PROMOTE) | DBG_FUNC_NONE,
				holder-&gt;sched_pri, priority, thread_tid(holder), trace_lck, 0);
			<span class="enscript-comment">/* Assert that we're not altering the priority of a
			 * thread above the MAXPRI_PROMOTE band
			 */</span>
			assert(holder-&gt;sched_pri &lt; MAXPRI_PROMOTE);
			set_sched_pri(holder, priority);
			
			<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_promoted == 0) {
				holder-&gt;promotions++;
				holder-&gt;sched_flags |= TH_SFLAG_PROMOTED;
				
				mutex-&gt;lck_mtx_promoted = 1;
			}
		}
		thread_unlock(holder);
		splx(s);
	}
	assert_wait(LCK_MTX_EVENT(mutex), THREAD_UNINT);

	lck_mtx_ilk_unlock(mutex);

	thread_block(THREAD_CONTINUE_NULL);

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_WAIT_CODE) | DBG_FUNC_END,
		     trace_lck, VM_KERNEL_UNSLIDE_OR_PERM(mutex-&gt;lck_mtx_owner), mutex-&gt;lck_mtx_waiters, mutex-&gt;lck_mtx_pri, 0);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * Record the Dtrace lockstat probe for blocking, block time
	 * measured from when we were entered.
	 */</span>
	<span class="enscript-keyword">if</span> (sleep_start) {
		<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_is_ext == 0) {
			LOCKSTAT_RECORD(LS_LCK_MTX_LOCK_BLOCK, mutex,
			    mach_absolute_time() - sleep_start);
		} <span class="enscript-keyword">else</span> {
			LOCKSTAT_RECORD(LS_LCK_MTX_EXT_LOCK_BLOCK, mutex,
			    mach_absolute_time() - sleep_start);
		}
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 *      Routine: kdp_lck_mtx_lock_spin_is_acquired
 *      NOT SAFE: To be used only by kernel debugger to avoid deadlock.
 *      Returns: TRUE if lock is acquired.
 */</span>
boolean_t
<span class="enscript-function-name">kdp_lck_mtx_lock_spin_is_acquired</span>(lck_mtx_t	*lck)
{
	<span class="enscript-keyword">if</span> (not_in_kdp) {
		panic(<span class="enscript-string">&quot;panic: kdp_lck_mtx_lock_spin_is_acquired called outside of kernel debugger&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_sw.lck_mtxd.lck_mtxd_ilocked || lck-&gt;lck_mtx_sw.lck_mtxd.lck_mtxd_mlocked) {
		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-keyword">return</span> FALSE;
}

</pre>
<hr />
</body></html>