<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ucode.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ucode.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 *  ucode.c
 *
 *  Microcode updater interface sysctl
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/ucode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>			// mp_broadcast
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cpu_number.h&gt;</span> // cpu_number
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>  // boot-args

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IA32_BIOS_UPDT_TRIG</span> (0x79) <span class="enscript-comment">/* microcode update trigger MSR */</span>

<span class="enscript-type">struct</span> intel_ucupdate *global_update = NULL;

<span class="enscript-comment">/* Exceute the actual update! */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">update_microcode</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* SDM Example 9-8 code shows that we load the
	 * address of the UpdateData within the microcode blob,
	 * not the address of the header.
	 */</span>
	wrmsr64(IA32_BIOS_UPDT_TRIG, (uint64_t)(uintptr_t)&amp;global_update-&gt;data);
}

<span class="enscript-comment">/* locks */</span>
<span class="enscript-type">static</span> lck_grp_attr_t *ucode_slock_grp_attr = NULL;
<span class="enscript-type">static</span> lck_grp_t *ucode_slock_grp = NULL;
<span class="enscript-type">static</span> lck_attr_t *ucode_slock_attr = NULL;
<span class="enscript-type">static</span> lck_spin_t *ucode_slock = NULL;

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">register_locks</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* already allocated? */</span>
	<span class="enscript-keyword">if</span> (ucode_slock_grp_attr &amp;&amp; ucode_slock_grp &amp;&amp; ucode_slock_attr &amp;&amp; ucode_slock)
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	<span class="enscript-comment">/* allocate lock group attribute and group */</span>
	<span class="enscript-keyword">if</span> (!(ucode_slock_grp_attr = lck_grp_attr_alloc_init()))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nomem_out</span>;

	lck_grp_attr_setstat(ucode_slock_grp_attr);

	<span class="enscript-keyword">if</span> (!(ucode_slock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;uccode_lock&quot;</span>, ucode_slock_grp_attr)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nomem_out</span>;

	<span class="enscript-comment">/* Allocate lock attribute */</span>
	<span class="enscript-keyword">if</span> (!(ucode_slock_attr = lck_attr_alloc_init()))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nomem_out</span>;

	<span class="enscript-comment">/* Allocate the spin lock */</span>
	<span class="enscript-comment">/* We keep one global spin-lock. We could have one per update
	 * request... but srsly, why would you update microcode like that?
	 */</span>
	<span class="enscript-keyword">if</span> (!(ucode_slock = lck_spin_alloc_init(ucode_slock_grp, ucode_slock_attr)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nomem_out</span>;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;

<span class="enscript-reference">nomem_out</span>:
	<span class="enscript-comment">/* clean up */</span>
	<span class="enscript-keyword">if</span> (ucode_slock)
		lck_spin_free(ucode_slock, ucode_slock_grp);
	<span class="enscript-keyword">if</span> (ucode_slock_attr)
		lck_attr_free(ucode_slock_attr);
	<span class="enscript-keyword">if</span> (ucode_slock_grp)
		lck_grp_free(ucode_slock_grp);
	<span class="enscript-keyword">if</span> (ucode_slock_grp_attr)
		lck_grp_attr_free(ucode_slock_grp_attr);

	<span class="enscript-keyword">return</span> KERN_NO_SPACE;
}

<span class="enscript-comment">/* Copy in an update */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copyin_update</span>(uint64_t inaddr)
{
	<span class="enscript-type">struct</span> intel_ucupdate update_header;
	<span class="enscript-type">struct</span> intel_ucupdate *update;
	vm_size_t size;
	kern_return_t ret;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* Copy in enough header to peek at the size */</span>
	error = copyin((user_addr_t)inaddr, (<span class="enscript-type">void</span> *)&amp;update_header, <span class="enscript-keyword">sizeof</span>(update_header));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/* Get the actual, alleged size */</span>
	size = update_header.total_size;

	<span class="enscript-comment">/* huge bogus piece of data that somehow made it through? */</span>
	<span class="enscript-keyword">if</span> (size &gt;= 1024 * 1024)
		<span class="enscript-keyword">return</span> ENOMEM;

	<span class="enscript-comment">/* Old microcodes? */</span>
	<span class="enscript-keyword">if</span> (size == 0)
		size = 2048; <span class="enscript-comment">/* default update size; see SDM */</span>

	<span class="enscript-comment">/*
	 * create the buffer for the update
	 * It need only be aligned to 16-bytes, according to the SDM.
	 * This also wires it down
	 */</span>
	ret = kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;update, size, VM_KERN_MEMORY_OSFMK);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> ENOMEM;

	<span class="enscript-comment">/* Copy it in */</span>
	error = copyin((user_addr_t)inaddr, (<span class="enscript-type">void</span>*)update, size);
	<span class="enscript-keyword">if</span> (error) {
		kmem_free(kernel_map, (vm_offset_t)update, size);
		<span class="enscript-keyword">return</span> error;
	}

	global_update = update;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * This is called once by every CPU on a wake from sleep/hibernate
 * and is meant to re-apply a microcode update that got lost
 * by sleeping.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ucode_update_wake</span>()
{
	<span class="enscript-keyword">if</span> (global_update) {
		kprintf(<span class="enscript-string">&quot;ucode: Re-applying update after wake (CPU #%d)\n&quot;</span>, cpu_number());
		update_microcode();
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEBUG</span>
	} <span class="enscript-keyword">else</span> {
		kprintf(<span class="enscript-string">&quot;ucode: No update to apply (CPU #%d)\n&quot;</span>, cpu_number());
#<span class="enscript-reference">endif</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cpu_update</span>(__unused <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-comment">/* grab the lock */</span>
	lck_spin_lock(ucode_slock);

	<span class="enscript-comment">/* execute the update */</span>
	update_microcode();

	<span class="enscript-comment">/* release the lock */</span>
	lck_spin_unlock(ucode_slock);
}

<span class="enscript-comment">/* Farm an update out to all CPUs */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">xcpu_update</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (register_locks() != KERN_SUCCESS)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Get all CPUs to perform the update */</span>
	mp_broadcast(cpu_update, NULL);

	<span class="enscript-comment">/* Update the cpuid info */</span>
	cpuid_set_info();

}

<span class="enscript-comment">/*
 * sysctl function
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ucode_interface</span>(uint64_t addr)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> arg[16]; 

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-x&quot;</span>, arg, <span class="enscript-keyword">sizeof</span> (arg))) {
		printf(<span class="enscript-string">&quot;ucode: no updates in safe mode\n&quot;</span>);
		<span class="enscript-keyword">return</span> EPERM;
	}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/*
	 * Userland may only call this once per boot. Anything else
	 * would not make sense (all updates are cumulative), and also
	 * leak memory, because we don't free previous updates.
	 */</span>
	<span class="enscript-keyword">if</span> (global_update)
		<span class="enscript-keyword">return</span> EPERM;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Get the whole microcode */</span>
	error = copyin_update(addr);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/* Farm out the updates */</span>
	xcpu_update();

	<span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>