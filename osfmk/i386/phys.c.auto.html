<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>phys.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">phys.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_rt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/eflags.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/seg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/user_ldt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>

<span class="enscript-comment">/*
 *	pmap_zero_page zeros the specified (machine independent) page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_zero_page</span>(
       ppnum_t pn)
{
	assert(pn != vm_page_fictitious_addr);
	assert(pn != vm_page_guard_addr);
	bzero_phys((addr64_t)i386_ptob(pn), PAGE_SIZE);
}

<span class="enscript-comment">/*
 *	pmap_zero_part_page
 *	zeros the specified (machine independent) part of a page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_zero_part_page</span>(
	ppnum_t         pn,
	vm_offset_t     offset,
	vm_size_t       len)
{
	assert(pn != vm_page_fictitious_addr);
	assert(pn != vm_page_guard_addr);
	assert(offset + len &lt;= PAGE_SIZE);
	bzero_phys((addr64_t)(i386_ptob(pn) + offset), (uint32_t)len);
}

<span class="enscript-comment">/*
 *	pmap_copy_page copies the specified (machine independent) pages.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_copy_part_page</span>(
	ppnum_t 	psrc,
	vm_offset_t	src_offset,
	ppnum_t	        pdst,
	vm_offset_t	dst_offset,
	vm_size_t	len)
{
        pmap_paddr_t src, dst;

	assert(psrc != vm_page_fictitious_addr);
	assert(pdst != vm_page_fictitious_addr);
	assert(psrc != vm_page_guard_addr);
	assert(pdst != vm_page_guard_addr);

	src = i386_ptob(psrc);
	dst = i386_ptob(pdst);

	assert((((uintptr_t)dst &amp; PAGE_MASK) + dst_offset + len) &lt;= PAGE_SIZE);
	assert((((uintptr_t)src &amp; PAGE_MASK) + src_offset + len) &lt;= PAGE_SIZE);

	bcopy_phys((addr64_t)src + (src_offset &amp; INTEL_OFFMASK),
		   (addr64_t)dst + (dst_offset &amp; INTEL_OFFMASK),
		   len);
}

<span class="enscript-comment">/*
 *      pmap_copy_part_lpage copies part of a virtually addressed page 
 *      to a physically addressed page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_copy_part_lpage</span>(
	__unused vm_offset_t 	src,
	__unused ppnum_t 	pdst,
	__unused vm_offset_t	dst_offset,
	__unused vm_size_t	len)
{

	assert(pdst != vm_page_fictitious_addr);
	assert(pdst != vm_page_guard_addr);
	assert((dst_offset + len) &lt;= PAGE_SIZE);

}

<span class="enscript-comment">/*
 *      pmap_copy_part_rpage copies part of a physically addressed page 
 *      to a virtually addressed page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_copy_part_rpage</span>(
	__unused ppnum_t	        psrc,
	__unused vm_offset_t	src_offset,
	__unused vm_offset_t	dst,
	__unused vm_size_t	len)
{

	assert(psrc != vm_page_fictitious_addr);
	assert(psrc != vm_page_guard_addr);
	assert((src_offset + len) &lt;= PAGE_SIZE);

}

<span class="enscript-comment">/*
 *	kvtophys(addr)
 *
 *	Convert a kernel virtual address to a physical address
 */</span>
addr64_t
<span class="enscript-function-name">kvtophys</span>(
	vm_offset_t addr)
{
	pmap_paddr_t pa;

	pa = ((pmap_paddr_t)pmap_find_phys(kernel_pmap, addr)) &lt;&lt; INTEL_PGSHIFT;
	<span class="enscript-keyword">if</span> (pa)
		pa |= (addr &amp; INTEL_OFFMASK);

	<span class="enscript-keyword">return</span> ((addr64_t)pa);
}

<span class="enscript-type">extern</span> pt_entry_t *debugger_ptep;
<span class="enscript-type">extern</span> vm_map_offset_t debugger_window_kva;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">_bcopy</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, vm_size_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">_bcopy2</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">_bcopy4</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">_bcopy8</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);

__private_extern__ <span class="enscript-type">int</span> ml_copy_phys(addr64_t src64, addr64_t dst64, vm_size_t bytes) {
	<span class="enscript-type">void</span> *src, *dst;
	<span class="enscript-type">int</span> err = 0;

	mp_disable_preemption();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	mapwindow_t *src_map, *dst_map;
	<span class="enscript-comment">/* We rely on MTRRs here */</span>
	src_map = pmap_get_mapwindow((pt_entry_t)(INTEL_PTE_VALID | ((pmap_paddr_t)src64 &amp; PG_FRAME) | INTEL_PTE_REF));
	dst_map = pmap_get_mapwindow((pt_entry_t)(INTEL_PTE_VALID | INTEL_PTE_RW | ((pmap_paddr_t)dst64 &amp; PG_FRAME) | INTEL_PTE_REF | INTEL_PTE_MOD));
	src = (<span class="enscript-type">void</span> *) ((uintptr_t)src_map-&gt;prv_CADDR | ((uint32_t)src64 &amp; INTEL_OFFMASK));
	dst = (<span class="enscript-type">void</span> *) ((uintptr_t)dst_map-&gt;prv_CADDR | ((uint32_t)dst64 &amp; INTEL_OFFMASK));
#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	addr64_t debug_pa = 0;

	<span class="enscript-comment">/* If either destination or source are outside the
	 * physical map, establish a physical window onto the target frame.
	 */</span>
	assert(physmap_enclosed(src64) || physmap_enclosed(dst64));

	<span class="enscript-keyword">if</span> (physmap_enclosed(src64) == FALSE) {
		src = (<span class="enscript-type">void</span> *)(debugger_window_kva | (src64 &amp; INTEL_OFFMASK));
		dst = PHYSMAP_PTOV(dst64);
		debug_pa = src64 &amp; PG_FRAME;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (physmap_enclosed(dst64) == FALSE) {
		src = PHYSMAP_PTOV(src64);
		dst = (<span class="enscript-type">void</span> *)(debugger_window_kva | (dst64 &amp; INTEL_OFFMASK));
		debug_pa = dst64 &amp; PG_FRAME;
	} <span class="enscript-keyword">else</span> {
		src = PHYSMAP_PTOV(src64);
		dst = PHYSMAP_PTOV(dst64);
	}
	<span class="enscript-comment">/* DRK: debugger only routine, we don't bother checking for an
	 * identical mapping.
	 */</span>
	<span class="enscript-keyword">if</span> (debug_pa) {
		<span class="enscript-keyword">if</span> (debugger_window_kva == 0)
			panic(<span class="enscript-string">&quot;%s: invoked in non-debug mode&quot;</span>, __FUNCTION__);
		<span class="enscript-comment">/* Establish a cache-inhibited physical window; some platforms
		 * may not cover arbitrary ranges with MTRRs
		 */</span>
		pmap_store_pte(debugger_ptep, debug_pa | INTEL_PTE_NCACHE | INTEL_PTE_RW | INTEL_PTE_REF| INTEL_PTE_MOD | INTEL_PTE_VALID);
		flush_tlb_raw();
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
		kprintf(<span class="enscript-string">&quot;Remapping debugger physical window at %p to 0x%llx\n&quot;</span>, (<span class="enscript-type">void</span> *)debugger_window_kva, debug_pa);
#<span class="enscript-reference">endif</span>
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* ensure we stay within a page */</span>
	<span class="enscript-keyword">if</span> (((((uint32_t)src64 &amp; (I386_PGBYTES-1)) + bytes) &gt; I386_PGBYTES) || ((((uint32_t)dst64 &amp; (I386_PGBYTES-1)) + bytes) &gt; I386_PGBYTES) ) {
	        panic(<span class="enscript-string">&quot;ml_copy_phys spans pages, src: 0x%llx, dst: 0x%llx&quot;</span>, src64, dst64);
	}

	<span class="enscript-comment">/*
	 * For device register access from the debugger,
	 * 2-byte/16-bit, 4-byte/32-bit and 8-byte/64-bit copies are handled
	 * by assembly routines ensuring the required access widths.
	 * 1-byte and other copies are handled by the regular _bcopy.
	 */</span>
	<span class="enscript-keyword">switch</span> (bytes) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		err = _bcopy2(src, dst);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		err = _bcopy4(src, dst);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
		err = _bcopy8(src, dst);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	<span class="enscript-reference">default</span>:
		err = _bcopy(src, dst, bytes);
		<span class="enscript-keyword">break</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	pmap_put_mapwindow(src_map);
	pmap_put_mapwindow(dst_map);
#<span class="enscript-reference">endif</span>
	mp_enable_preemption();

	<span class="enscript-keyword">return</span> err;
}
</pre>
<hr />
</body></html>