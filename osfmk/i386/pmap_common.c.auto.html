<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pmap_common.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pmap_common.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap_internal.h&gt;</span>


<span class="enscript-comment">/*
 *	Each entry in the pv_head_table is locked by a bit in the
 *	pv_lock_table.  The lock bits are accessed by the physical
 *	address of the page they lock.
 */</span>

<span class="enscript-type">char</span>	*pv_lock_table;		<span class="enscript-comment">/* pointer to array of bits */</span>
<span class="enscript-type">char</span>    *pv_hash_lock_table;

pv_rooted_entry_t	pv_head_table;		<span class="enscript-comment">/* array of entries, one per
						 * page */</span>
uint32_t			pv_hashed_free_count = 0;
uint32_t			pv_hashed_kern_free_count = 0;

pmap_pagetable_corruption_record_t pmap_pagetable_corruption_records[PMAP_PAGETABLE_CORRUPTION_MAX_LOG];
uint32_t pmap_pagetable_corruption_incidents;
uint64_t pmap_pagetable_corruption_last_abstime = (~(0ULL) &gt;&gt; 1);
uint64_t pmap_pagetable_corruption_interval_abstime;
thread_call_t 	pmap_pagetable_corruption_log_call;
<span class="enscript-type">static</span> thread_call_data_t 	pmap_pagetable_corruption_log_call_data;
boolean_t pmap_pagetable_corruption_timeout = FALSE;

<span class="enscript-type">volatile</span> uint32_t	mappingrecurse = 0;

uint32_t  pv_hashed_low_water_mark, pv_hashed_kern_low_water_mark, pv_hashed_alloc_chunk, pv_hashed_kern_alloc_chunk;

thread_t mapping_replenish_thread;
event_t	mapping_replenish_event, pmap_user_pv_throttle_event;

uint64_t pmap_pv_throttle_stat, pmap_pv_throttled_waiters;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pmap_cache_attributes</span>(ppnum_t pn) {
	<span class="enscript-keyword">if</span> (pmap_get_cache_attributes(pn, FALSE) &amp; INTEL_PTE_NCACHE)
	        <span class="enscript-keyword">return</span> (VM_WIMG_IO);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (VM_WIMG_COPYBACK);
}

<span class="enscript-type">void</span>	pmap_set_cache_attributes(ppnum_t pn, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cacheattr) {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> current, template = 0;
	<span class="enscript-type">int</span> pai;

	<span class="enscript-keyword">if</span> (cacheattr &amp; VM_MEM_NOT_CACHEABLE) {
		<span class="enscript-keyword">if</span>(!(cacheattr &amp; VM_MEM_GUARDED))
			template |= PHYS_PTA;
		template |= PHYS_NCACHE;
	}

	pmap_intr_assert();

	assert((pn != vm_page_fictitious_addr) &amp;&amp; (pn != vm_page_guard_addr));

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (!IS_MANAGED_PAGE(pai)) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* override cache attributes for this phys page
	 * Does not walk through existing mappings to adjust,
	 * assumes page is disconnected
	 */</span>

	LOCK_PVH(pai);

	pmap_update_cache_attributes_locked(pn, template);

	current = pmap_phys_attributes[pai] &amp; PHYS_CACHEABILITY_MASK;
	pmap_phys_attributes[pai] &amp;= ~PHYS_CACHEABILITY_MASK;
	pmap_phys_attributes[pai] |= template;

	UNLOCK_PVH(pai);

	<span class="enscript-keyword">if</span> ((template &amp; PHYS_NCACHE) &amp;&amp; !(current &amp; PHYS_NCACHE)) {
		pmap_sync_page_attributes_phys(pn);
	}
}

<span class="enscript-type">unsigned</span>	pmap_get_cache_attributes(ppnum_t pn, boolean_t is_ept) {
	<span class="enscript-keyword">if</span> (last_managed_page == 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (!IS_MANAGED_PAGE(ppn_to_pai(pn)))
	    <span class="enscript-keyword">return</span> PTE_NCACHE(is_ept);

	<span class="enscript-comment">/*
	 * The cache attributes are read locklessly for efficiency.
	 */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> attr = pmap_phys_attributes[ppn_to_pai(pn)];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> template = 0;

	<span class="enscript-comment">/*
	 * The PTA bit is currently unsupported for EPT PTEs.
	 */</span>
	<span class="enscript-keyword">if</span> ((attr &amp; PHYS_PTA) &amp;&amp; !is_ept)
		template |= INTEL_PTE_PTA;

	<span class="enscript-comment">/*
	 * If the page isn't marked as NCACHE, the default for EPT entries
	 * is WB.
	 */</span>
	<span class="enscript-keyword">if</span> (attr &amp; PHYS_NCACHE)
		template |= PTE_NCACHE(is_ept);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_ept)
		template |= INTEL_EPT_WB;

	<span class="enscript-keyword">return</span> template;
}

boolean_t 
<span class="enscript-function-name">pmap_has_managed_page</span>(ppnum_t first, ppnum_t last)
{
	ppnum_t   pn;
    boolean_t result;

    assert(last_managed_page);
    assert(first &lt;= last);

    <span class="enscript-keyword">for</span> (result = FALSE, pn = first; 
    	!result 
    	  &amp;&amp; (pn &lt;= last)
    	  &amp;&amp; (pn &lt;= last_managed_page); 
    	 pn++)
    {
    	result = (0 != (pmap_phys_attributes[pn] &amp; PHYS_MANAGED));
    }

	<span class="enscript-keyword">return</span> (result);
}

boolean_t
<span class="enscript-function-name">pmap_is_noencrypt</span>(ppnum_t pn)
{
	<span class="enscript-type">int</span>		pai;

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (!IS_MANAGED_PAGE(pai))
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (pmap_phys_attributes[pai] &amp; PHYS_NOENCRYPT)
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">return</span> (FALSE);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_set_noencrypt</span>(ppnum_t pn)
{
	<span class="enscript-type">int</span>		pai;

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (IS_MANAGED_PAGE(pai)) {
		LOCK_PVH(pai);

		pmap_phys_attributes[pai] |= PHYS_NOENCRYPT;

		UNLOCK_PVH(pai);
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_clear_noencrypt</span>(ppnum_t pn)
{
	<span class="enscript-type">int</span>		pai;

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (IS_MANAGED_PAGE(pai)) {
		<span class="enscript-comment">/*
		 * synchronization at VM layer prevents PHYS_NOENCRYPT
		 * from changing state, so we don't need the lock to inspect
		 */</span>
		<span class="enscript-keyword">if</span> (pmap_phys_attributes[pai] &amp; PHYS_NOENCRYPT) {
			LOCK_PVH(pai);

			pmap_phys_attributes[pai] &amp;= ~PHYS_NOENCRYPT;

			UNLOCK_PVH(pai);
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">compute_pmap_gc_throttle</span>(<span class="enscript-type">void</span> *arg __unused)
{
	
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_lock_phys_page</span>(ppnum_t pn)
{
	<span class="enscript-type">int</span>		pai;

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (IS_MANAGED_PAGE(pai)) {
		LOCK_PVH(pai);
	} <span class="enscript-keyword">else</span>
		simple_lock(&amp;phys_backup_lock);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_unlock_phys_page</span>(ppnum_t pn)
{
	<span class="enscript-type">int</span>		pai;

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (IS_MANAGED_PAGE(pai)) {
		UNLOCK_PVH(pai);
	} <span class="enscript-keyword">else</span>
		simple_unlock(&amp;phys_backup_lock);
}



__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_pagetable_corruption_msg_log</span>(<span class="enscript-type">int</span> (*log_func)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * fmt, ...)__printflike(1,2)) {
	<span class="enscript-keyword">if</span> (pmap_pagetable_corruption_incidents &gt; 0) {
		<span class="enscript-type">int</span> i, e = MIN(pmap_pagetable_corruption_incidents, PMAP_PAGETABLE_CORRUPTION_MAX_LOG);
		(*log_func)(<span class="enscript-string">&quot;%u pagetable corruption incident(s) detected, timeout: %u\n&quot;</span>, pmap_pagetable_corruption_incidents, pmap_pagetable_corruption_timeout);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; e; i++) {
			(*log_func)(<span class="enscript-string">&quot;Incident 0x%x, reason: 0x%x, action: 0x%x, time: 0x%llx\n&quot;</span>, pmap_pagetable_corruption_records[i].incident,  pmap_pagetable_corruption_records[i].reason, pmap_pagetable_corruption_records[i].action, pmap_pagetable_corruption_records[i].abstime);
		}
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_pagetable_corruption_log_setup</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">if</span> (pmap_pagetable_corruption_log_call == NULL) {
		nanotime_to_absolutetime(PMAP_PAGETABLE_CORRUPTION_INTERVAL, 0, &amp;pmap_pagetable_corruption_interval_abstime);
		thread_call_setup(&amp;pmap_pagetable_corruption_log_call_data,
		    (thread_call_func_t) pmap_pagetable_corruption_msg_log,
		    (thread_call_param_t) &amp;printf);
		pmap_pagetable_corruption_log_call = &amp;pmap_pagetable_corruption_log_call_data;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mapping_free_prime</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span>		i;
	pv_hashed_entry_t	pvh_e;
	pv_hashed_entry_t	pvh_eh;
	pv_hashed_entry_t	pvh_et;
	<span class="enscript-type">int</span>			pv_cnt;

	<span class="enscript-comment">/* Scale based on DRAM size */</span>
	pv_hashed_low_water_mark = MAX(PV_HASHED_LOW_WATER_MARK_DEFAULT, ((uint32_t)(sane_size &gt;&gt; 30)) * 2000);
	pv_hashed_low_water_mark = MIN(pv_hashed_low_water_mark, 16000);
	<span class="enscript-comment">/* Alterable via sysctl */</span>
	pv_hashed_kern_low_water_mark = MAX(PV_HASHED_KERN_LOW_WATER_MARK_DEFAULT, ((uint32_t)(sane_size &gt;&gt; 30)) * 1000);
	pv_hashed_kern_low_water_mark = MIN(pv_hashed_kern_low_water_mark, 16000);
	pv_hashed_kern_alloc_chunk = PV_HASHED_KERN_ALLOC_CHUNK_INITIAL;
	pv_hashed_alloc_chunk = PV_HASHED_ALLOC_CHUNK_INITIAL;

	pv_cnt = 0;
	pvh_eh = pvh_et = PV_HASHED_ENTRY_NULL;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (5 * PV_HASHED_ALLOC_CHUNK_INITIAL); i++) {
		pvh_e = (pv_hashed_entry_t) zalloc(pv_hashed_list_zone);

		pvh_e-&gt;qlink.next = (queue_entry_t)pvh_eh;
		pvh_eh = pvh_e;

		<span class="enscript-keyword">if</span> (pvh_et == PV_HASHED_ENTRY_NULL)
		        pvh_et = pvh_e;
		pv_cnt++;
	}
	PV_HASHED_FREE_LIST(pvh_eh, pvh_et, pv_cnt);

	pv_cnt = 0;
	pvh_eh = pvh_et = PV_HASHED_ENTRY_NULL;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PV_HASHED_KERN_ALLOC_CHUNK_INITIAL; i++) {
		pvh_e = (pv_hashed_entry_t) zalloc(pv_hashed_list_zone);

		pvh_e-&gt;qlink.next = (queue_entry_t)pvh_eh;
		pvh_eh = pvh_e;

		<span class="enscript-keyword">if</span> (pvh_et == PV_HASHED_ENTRY_NULL)
		        pvh_et = pvh_e;
		pv_cnt++;
	}
	PV_HASHED_KERN_FREE_LIST(pvh_eh, pvh_et, pv_cnt);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mapping_replenish</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">mapping_adjust</span>(<span class="enscript-type">void</span>) {
	kern_return_t mres;

	pmap_pagetable_corruption_log_setup();

	mres = kernel_thread_start_priority((thread_continue_t)mapping_replenish, NULL, MAXPRI_KERNEL, &amp;mapping_replenish_thread);
	<span class="enscript-keyword">if</span> (mres != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;pmap: mapping_replenish_thread creation failed&quot;</span>);
	}
	thread_deallocate(mapping_replenish_thread);
}

<span class="enscript-type">unsigned</span> pmap_mapping_thread_wakeups;	
<span class="enscript-type">unsigned</span> pmap_kernel_reserve_replenish_stat;
<span class="enscript-type">unsigned</span> pmap_user_reserve_replenish_stat;
<span class="enscript-type">unsigned</span> pmap_kern_reserve_alloc_stat;

<span class="enscript-type">void</span> <span class="enscript-function-name">mapping_replenish</span>(<span class="enscript-type">void</span>)
{
	pv_hashed_entry_t	pvh_e;
	pv_hashed_entry_t	pvh_eh;
	pv_hashed_entry_t	pvh_et;
	<span class="enscript-type">int</span>			pv_cnt;
	<span class="enscript-type">unsigned</span>             	i;

	<span class="enscript-comment">/* We qualify for VM privileges...*/</span>
	current_thread()-&gt;options |= TH_OPT_VMPRIV;

	<span class="enscript-keyword">for</span> (;;) {

		<span class="enscript-keyword">while</span> (pv_hashed_kern_free_count &lt; pv_hashed_kern_low_water_mark) {
			pv_cnt = 0;
			pvh_eh = pvh_et = PV_HASHED_ENTRY_NULL;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; pv_hashed_kern_alloc_chunk; i++) {
				pvh_e = (pv_hashed_entry_t) zalloc(pv_hashed_list_zone);
				pvh_e-&gt;qlink.next = (queue_entry_t)pvh_eh;
				pvh_eh = pvh_e;

				<span class="enscript-keyword">if</span> (pvh_et == PV_HASHED_ENTRY_NULL)
					pvh_et = pvh_e;
				pv_cnt++;
			}
			pmap_kernel_reserve_replenish_stat += pv_cnt;
			PV_HASHED_KERN_FREE_LIST(pvh_eh, pvh_et, pv_cnt);
		}

		pv_cnt = 0;
		pvh_eh = pvh_et = PV_HASHED_ENTRY_NULL;

		<span class="enscript-keyword">if</span> (pv_hashed_free_count &lt; pv_hashed_low_water_mark) {
			<span class="enscript-keyword">for</span> (i = 0; i &lt; pv_hashed_alloc_chunk; i++) {
				pvh_e = (pv_hashed_entry_t) zalloc(pv_hashed_list_zone);

				pvh_e-&gt;qlink.next = (queue_entry_t)pvh_eh;
				pvh_eh = pvh_e;

				<span class="enscript-keyword">if</span> (pvh_et == PV_HASHED_ENTRY_NULL)
					pvh_et = pvh_e;
				pv_cnt++;
			}
			pmap_user_reserve_replenish_stat += pv_cnt;
			PV_HASHED_FREE_LIST(pvh_eh, pvh_et, pv_cnt);
		}
<span class="enscript-comment">/* Wake threads throttled while the kernel reserve was being replenished.
 */</span>
		<span class="enscript-keyword">if</span> (pmap_pv_throttled_waiters) {
			pmap_pv_throttled_waiters = 0;
			thread_wakeup(&amp;pmap_user_pv_throttle_event);
		}
		<span class="enscript-comment">/* Check if the kernel pool has been depleted since the
		 * first pass, to reduce refill latency.
		 */</span>
		<span class="enscript-keyword">if</span> (pv_hashed_kern_free_count &lt; pv_hashed_kern_low_water_mark)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* Block sans continuation to avoid yielding kernel stack */</span>
		assert_wait(&amp;mapping_replenish_event, THREAD_UNINT);
		mappingrecurse = 0;
		thread_block(THREAD_CONTINUE_NULL);
		pmap_mapping_thread_wakeups++;
	}
}

<span class="enscript-comment">/*
 *	Set specified attribute bits.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">phys_attribute_set</span>(
	ppnum_t		pn,
	<span class="enscript-type">int</span>		bits)
{
	<span class="enscript-type">int</span>		pai;

	pmap_intr_assert();
	assert(pn != vm_page_fictitious_addr);
	<span class="enscript-keyword">if</span> (pn == vm_page_guard_addr)
		<span class="enscript-keyword">return</span>;

	pai = ppn_to_pai(pn);

	<span class="enscript-keyword">if</span> (!IS_MANAGED_PAGE(pai)) {
		<span class="enscript-comment">/* Not a managed page.  */</span>
		<span class="enscript-keyword">return</span>;
	}

	LOCK_PVH(pai);
	pmap_phys_attributes[pai] |= bits;
	UNLOCK_PVH(pai);
}

<span class="enscript-comment">/*
 *	Set the modify bit on the specified physical page.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_set_modify</span>(ppnum_t pn)
{
	phys_attribute_set(pn, PHYS_MODIFIED);
}

<span class="enscript-comment">/*
 *	Clear the modify bits on the specified physical page.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_clear_modify</span>(ppnum_t pn)
{
	phys_attribute_clear(pn, PHYS_MODIFIED, 0, NULL);
}

<span class="enscript-comment">/*
 *	pmap_is_modified:
 *
 *	Return whether or not the specified physical page is modified
 *	by any physical maps.
 */</span>

boolean_t
<span class="enscript-function-name">pmap_is_modified</span>(ppnum_t pn)
{
	<span class="enscript-keyword">if</span> (phys_attribute_test(pn, PHYS_MODIFIED))
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-keyword">return</span> FALSE;
}


<span class="enscript-comment">/*
 *	pmap_clear_reference:
 *
 *	Clear the reference bit on the specified physical page.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_clear_reference</span>(ppnum_t pn)
{
	phys_attribute_clear(pn, PHYS_REFERENCED, 0, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_set_reference</span>(ppnum_t pn)
{
	phys_attribute_set(pn, PHYS_REFERENCED);
}

<span class="enscript-comment">/*
 *	pmap_is_referenced:
 *
 *	Return whether or not the specified physical page is referenced
 *	by any physical maps.
 */</span>

boolean_t
<span class="enscript-function-name">pmap_is_referenced</span>(ppnum_t pn)
{
        <span class="enscript-keyword">if</span> (phys_attribute_test(pn, PHYS_REFERENCED))
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-keyword">return</span> FALSE;
}


<span class="enscript-comment">/*
 * pmap_get_refmod(phys)
 *  returns the referenced and modified bits of the specified
 *  physical page.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pmap_get_refmod</span>(ppnum_t pn)
{
        <span class="enscript-type">int</span>		refmod;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	retval = 0;

	refmod = phys_attribute_test(pn, PHYS_MODIFIED | PHYS_REFERENCED);

	<span class="enscript-keyword">if</span> (refmod &amp; PHYS_MODIFIED)
	        retval |= VM_MEM_MODIFIED;
	<span class="enscript-keyword">if</span> (refmod &amp; PHYS_REFERENCED)
	        retval |= VM_MEM_REFERENCED;

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_clear_refmod_options</span>(ppnum_t pn, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mask, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> options, <span class="enscript-type">void</span> *arg)
{
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  x86Mask;

        x86Mask = (   ((mask &amp;   VM_MEM_MODIFIED)?   PHYS_MODIFIED : 0)
		      | ((mask &amp; VM_MEM_REFERENCED)? PHYS_REFERENCED : 0));

        phys_attribute_clear(pn, x86Mask, options, arg);
}

<span class="enscript-comment">/*
 * pmap_clear_refmod(phys, mask)
 *  clears the referenced and modified bits as specified by the mask
 *  of the specified physical page.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_clear_refmod</span>(ppnum_t pn, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mask)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  x86Mask;

	x86Mask = (   ((mask &amp;   VM_MEM_MODIFIED)?   PHYS_MODIFIED : 0)
	            | ((mask &amp; VM_MEM_REFERENCED)? PHYS_REFERENCED : 0));

	phys_attribute_clear(pn, x86Mask, 0, NULL);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pmap_disconnect</span>(ppnum_t pa)
{
	<span class="enscript-keyword">return</span> (pmap_disconnect_options(pa, 0, NULL));
}

<span class="enscript-comment">/*
 *	Routine:
 *		pmap_disconnect_options
 *
 *	Function:
 *		Disconnect all mappings for this page and return reference and change status
 *		in generic format.
 *
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pmap_disconnect_options</span>(ppnum_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> options, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">unsigned</span> refmod, vmrefmod = 0;

	pmap_page_protect_options(pa, 0, options, arg);		<span class="enscript-comment">/* disconnect the page */</span>

	pmap_assert(pa != vm_page_fictitious_addr);
	<span class="enscript-keyword">if</span> ((pa == vm_page_guard_addr) || !IS_MANAGED_PAGE(pa) || (options &amp; PMAP_OPTIONS_NOREFMOD))
		<span class="enscript-keyword">return</span> 0;
	refmod = pmap_phys_attributes[pa] &amp; (PHYS_MODIFIED | PHYS_REFERENCED);
	
	<span class="enscript-keyword">if</span> (refmod &amp; PHYS_MODIFIED)
	        vmrefmod |= VM_MEM_MODIFIED;
	<span class="enscript-keyword">if</span> (refmod &amp; PHYS_REFERENCED)
	        vmrefmod |= VM_MEM_REFERENCED;

	<span class="enscript-keyword">return</span> vmrefmod;
}
</pre>
<hr />
</body></html>