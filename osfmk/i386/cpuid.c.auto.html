<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>cpuid.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">cpuid.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>

<span class="enscript-type">static</span>	boolean_t	cpuid_dbg
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				  = TRUE;
#<span class="enscript-reference">else</span>
				  = FALSE;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)			\
	<span class="enscript-keyword">do</span> {				\
		<span class="enscript-keyword">if</span> (cpuid_dbg)		\
			kprintf(x);	\
	} <span class="enscript-keyword">while</span> (0)			\

#<span class="enscript-reference">define</span> <span class="enscript-function-name">min</span>(a,b) ((a) &lt; (b) ? (a) : (b))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">quad</span>(hi,lo)	(((uint64_t)(hi)) &lt;&lt; 32 | (lo))

<span class="enscript-comment">/* Only for 32bit values */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit32</span>(n)		(1U &lt;&lt; (n))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bitmask32</span>(h,l)		((bit32(h)|(bit32(h)-1)) &amp; ~(bit32(l)-1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bitfield32</span>(x,h,l)	((((x) &amp; bitmask32(h,l)) &gt;&gt; l))

<span class="enscript-comment">/*
 * Leaf 2 cache descriptor encodings.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	_NULL_,		<span class="enscript-comment">/* NULL (empty) descriptor */</span>
	CACHE,		<span class="enscript-comment">/* Cache */</span>
	TLB,		<span class="enscript-comment">/* TLB */</span>
	STLB,		<span class="enscript-comment">/* Shared second-level unified TLB */</span>
	PREFETCH	<span class="enscript-comment">/* Prefetch size */</span>
} cpuid_leaf2_desc_type_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	NA,		<span class="enscript-comment">/* Not Applicable */</span>
	FULLY,		<span class="enscript-comment">/* Fully-associative */</span>	
	TRACE,		<span class="enscript-comment">/* Trace Cache (P4 only) */</span>
	INST,		<span class="enscript-comment">/* Instruction TLB */</span>
	DATA,		<span class="enscript-comment">/* Data TLB */</span>
	DATA0,		<span class="enscript-comment">/* Data TLB, 1st level */</span>
	DATA1,		<span class="enscript-comment">/* Data TLB, 2nd level */</span>
	L1,		<span class="enscript-comment">/* L1 (unified) cache */</span>
	L1_INST,	<span class="enscript-comment">/* L1 Instruction cache */</span>
	L1_DATA,	<span class="enscript-comment">/* L1 Data cache */</span>
	L2,		<span class="enscript-comment">/* L2 (unified) cache */</span>
	L3,		<span class="enscript-comment">/* L3 (unified) cache */</span>
	L2_2LINESECTOR,	<span class="enscript-comment">/* L2 (unified) cache with 2 lines per sector */</span>
	L3_2LINESECTOR,	<span class="enscript-comment">/* L3(unified) cache with 2 lines per sector */</span>
	SMALL,		<span class="enscript-comment">/* Small page TLB */</span>
	LARGE,		<span class="enscript-comment">/* Large page TLB */</span>
	BOTH		<span class="enscript-comment">/* Small and Large page TLB */</span>
} cpuid_leaf2_qualifier_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cpuid_cache_descriptor {
	uint8_t		value;		<span class="enscript-comment">/* descriptor code */</span>
	uint8_t		type;		<span class="enscript-comment">/* cpuid_leaf2_desc_type_t */</span>
	uint8_t		level;		<span class="enscript-comment">/* level of cache/TLB hierachy */</span>
	uint8_t		ways;		<span class="enscript-comment">/* wayness of cache */</span>
	uint16_t	size;		<span class="enscript-comment">/* cachesize or TLB pagesize */</span> 
	uint16_t	entries;	<span class="enscript-comment">/* number of TLB entries or linesize */</span>
} cpuid_cache_descriptor_t;

<span class="enscript-comment">/*
 * These multipliers are used to encode 1*K .. 64*M in a 16 bit size field 
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">K</span>	(1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M</span>	(1024)

<span class="enscript-comment">/*
 * Intel cache descriptor table:
 */</span>
<span class="enscript-type">static</span> cpuid_cache_descriptor_t intel_cpuid_leaf2_descriptor_table[] = {
<span class="enscript-comment">//	-------------------------------------------------------
</span><span class="enscript-comment">//	value	type	level		ways	size	entries
</span><span class="enscript-comment">//	-------------------------------------------------------
</span>	{ 0x00,	_NULL_,	NA,		NA,	NA,	NA  },
	{ 0x01,	TLB,	INST,		4,	SMALL,	32  },	
	{ 0x02,	TLB,	INST,		FULLY,	LARGE,	2   },	
	{ 0x03,	TLB,	DATA,		4,	SMALL,	64  },	
	{ 0x04,	TLB,	DATA,		4,	LARGE,	8   },	
	{ 0x05,	TLB,	DATA1,		4,	LARGE,	32  },	
	{ 0x06,	CACHE,	L1_INST,	4,	8*K,	32  },
	{ 0x08,	CACHE,	L1_INST,	4,	16*K,	32  },
	{ 0x09,	CACHE,	L1_INST,	4,	32*K,	64  },
	{ 0x0A,	CACHE,	L1_DATA,	2,	8*K,	32  },
	{ 0x0B,	TLB,	INST,		4,	LARGE,	4   },	
	{ 0x0C,	CACHE,	L1_DATA,	4,	16*K,	32  },
	{ 0x0D,	CACHE,	L1_DATA,	4,	16*K,	64  },
	{ 0x0E,	CACHE,	L1_DATA,	6,	24*K,	64  },
	{ 0x21,	CACHE,	L2,		8,	256*K,	64  },
	{ 0x22,	CACHE,	L3_2LINESECTOR,	4,	512*K,	64  },
	{ 0x23,	CACHE,	L3_2LINESECTOR, 8,	1*M,	64  },
	{ 0x25,	CACHE,	L3_2LINESECTOR,	8,	2*M,	64  },
	{ 0x29,	CACHE,	L3_2LINESECTOR, 8,	4*M,	64  },
	{ 0x2C,	CACHE,	L1_DATA,	8,	32*K,	64  },
	{ 0x30,	CACHE,	L1_INST,	8,	32*K,	64  },
	{ 0x40,	CACHE,	L2,		NA,	0,	NA  },
	{ 0x41,	CACHE,	L2,		4,	128*K,	32  },
	{ 0x42,	CACHE,	L2,		4,	256*K,	32  },
	{ 0x43,	CACHE,	L2,		4,	512*K,	32  },
	{ 0x44,	CACHE,	L2,		4,	1*M,	32  },
	{ 0x45,	CACHE,	L2,		4,	2*M,	32  },
	{ 0x46,	CACHE,	L3,		4,	4*M,	64  },
	{ 0x47,	CACHE,	L3,		8,	8*M,	64  },
	{ 0x48,	CACHE,	L2,		12, 	3*M,	64  },
	{ 0x49,	CACHE,	L2,		16,	4*M,	64  },
	{ 0x4A,	CACHE,	L3,		12, 	6*M,	64  },
	{ 0x4B,	CACHE,	L3,		16,	8*M,	64  },
	{ 0x4C,	CACHE,	L3,		12, 	12*M,	64  },
	{ 0x4D,	CACHE,	L3,		16,	16*M,	64  },
	{ 0x4E,	CACHE,	L2,		24,	6*M,	64  },
	{ 0x4F,	TLB,	INST,		NA,	SMALL,	32  },	
	{ 0x50,	TLB,	INST,		NA,	BOTH,	64  },	
	{ 0x51,	TLB,	INST,		NA,	BOTH,	128 },	
	{ 0x52,	TLB,	INST,		NA,	BOTH,	256 },	
	{ 0x55,	TLB,	INST,		FULLY,	BOTH,	7   },	
	{ 0x56,	TLB,	DATA0,		4,	LARGE,	16  },	
	{ 0x57,	TLB,	DATA0,		4,	SMALL,	16  },	
	{ 0x59,	TLB,	DATA0,		FULLY,	SMALL,	16  },	
	{ 0x5A,	TLB,	DATA0,		4,	LARGE,	32  },	
	{ 0x5B,	TLB,	DATA,		NA,	BOTH,	64  },	
	{ 0x5C,	TLB,	DATA,		NA,	BOTH,	128 },	
	{ 0x5D,	TLB,	DATA,		NA,	BOTH,	256 },	
	{ 0x60,	CACHE,	L1,		16*K,	8,	64  },
	{ 0x61,	CACHE,	L1,		4,	8*K,	64  },
	{ 0x62,	CACHE,	L1,		4,	16*K,	64  },
	{ 0x63,	CACHE,	L1,		4,	32*K,	64  },
	{ 0x70,	CACHE,	TRACE,		8,	12*K,	NA  },
	{ 0x71,	CACHE,	TRACE,		8,	16*K,	NA  },
	{ 0x72,	CACHE,	TRACE,		8,	32*K,	NA  },
	{ 0x76,	TLB,	INST,		NA,	BOTH,	8   },
	{ 0x78,	CACHE,	L2,		4,	1*M,	64  },
	{ 0x79,	CACHE,	L2_2LINESECTOR,	8,	128*K,	64  },
	{ 0x7A,	CACHE,	L2_2LINESECTOR,	8,	256*K,	64  },
	{ 0x7B,	CACHE,	L2_2LINESECTOR,	8,	512*K,	64  },
	{ 0x7C,	CACHE,	L2_2LINESECTOR,	8,	1*M,	64  },
	{ 0x7D,	CACHE,	L2,		8,	2*M,	64  },
	{ 0x7F,	CACHE,	L2,		2,	512*K,	64  },
	{ 0x80,	CACHE,	L2,		8,	512*K,	64  },
	{ 0x82,	CACHE,	L2,		8,	256*K,	32  },
	{ 0x83,	CACHE,	L2,		8,	512*K,	32  },
	{ 0x84,	CACHE,	L2,		8,	1*M,	32  },
	{ 0x85,	CACHE,	L2,		8,	2*M,	32  },
	{ 0x86,	CACHE,	L2,		4,	512*K,	64  },
	{ 0x87,	CACHE,	L2,		8,	1*M,	64  },
	{ 0xB0,	TLB,	INST,		4,	SMALL,	128 },	
	{ 0xB1,	TLB,	INST,		4,	LARGE,	8   },	
	{ 0xB2,	TLB,	INST,		4,	SMALL,	64  },	
	{ 0xB3,	TLB,	DATA,		4,	SMALL,	128 },	
	{ 0xB4,	TLB,	DATA1,		4,	SMALL,	256 },	
	{ 0xB5,	TLB,	DATA1,		8,	SMALL,	64  },	
	{ 0xB6,	TLB,	DATA1,		8,	SMALL,	128 },	
	{ 0xBA,	TLB,	DATA1,		4,	BOTH,	64  },	
	{ 0xC1,	STLB,	DATA1,		8,	SMALL,	1024},	
	{ 0xCA,	STLB,	DATA1,		4,	SMALL,	512 },	
	{ 0xD0,	CACHE,	L3,		4,	512*K,	64  },	
	{ 0xD1,	CACHE,	L3,		4,	1*M,	64  },	
	{ 0xD2,	CACHE,	L3,		4,	2*M,	64  },	
	{ 0xD3,	CACHE,	L3,		4,	4*M,	64  },	
	{ 0xD4,	CACHE,	L3,		4,	8*M,	64  },	
	{ 0xD6,	CACHE,	L3,		8,	1*M,	64  },	
	{ 0xD7,	CACHE,	L3,		8,	2*M,	64  },	
	{ 0xD8,	CACHE,	L3,		8,	4*M,	64  },	
	{ 0xD9,	CACHE,	L3,		8,	8*M,	64  },	
	{ 0xDA,	CACHE,	L3,		8,	12*M,	64  },	
	{ 0xDC,	CACHE,	L3,		12, 	1536*K,	64  },	
	{ 0xDD,	CACHE,	L3,		12, 	3*M,	64  },	
	{ 0xDE,	CACHE,	L3,		12, 	6*M,	64  },	
	{ 0xDF,	CACHE,	L3,		12,	12*M,	64  },	
	{ 0xE0,	CACHE,	L3,		12,	18*M,	64  },	
	{ 0xE2,	CACHE,	L3,		16,	2*M,	64  },	
	{ 0xE3,	CACHE,	L3,		16,	4*M,	64  },	
	{ 0xE4,	CACHE,	L3,		16,	8*M,	64  },	
	{ 0xE5,	CACHE,	L3,		16,	16*M,	64  },	
	{ 0xE6,	CACHE,	L3,		16,	24*M,	64  },	
	{ 0xF0,	PREFETCH, NA,		NA,	64,	NA  },	
	{ 0xF1,	PREFETCH, NA,		NA,	128,	NA  },	
	{ 0xFF,	CACHE,  NA,		NA,	0,	NA  }	
};
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INTEL_LEAF2_DESC_NUM</span> (sizeof(intel_cpuid_leaf2_descriptor_table) / \
				<span class="enscript-keyword">sizeof</span>(cpuid_cache_descriptor_t))

<span class="enscript-type">static</span> inline cpuid_cache_descriptor_t *
<span class="enscript-function-name">cpuid_leaf2_find</span>(uint8_t value)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; INTEL_LEAF2_DESC_NUM; i++)
		<span class="enscript-keyword">if</span> (intel_cpuid_leaf2_descriptor_table[i].value == value)
			<span class="enscript-keyword">return</span> &amp;intel_cpuid_leaf2_descriptor_table[i];
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * CPU identification routines.
 */</span>

<span class="enscript-type">static</span> i386_cpu_info_t	cpuid_cpu_info;
<span class="enscript-type">static</span> i386_cpu_info_t	*cpuid_cpu_infop = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cpuid_fn</span>(uint32_t selector, uint32_t *result)
{
	do_cpuid(selector, result);
	DBG(<span class="enscript-string">&quot;cpuid_fn(0x%08x) eax:0x%08x ebx:0x%08x ecx:0x%08x edx:0x%08x\n&quot;</span>,
		selector, result[0], result[1], result[2], result[3]);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cache_type_str[LCACHE_MAX] = {
	<span class="enscript-string">&quot;Lnone&quot;</span>, <span class="enscript-string">&quot;L1I&quot;</span>, <span class="enscript-string">&quot;L1D&quot;</span>, <span class="enscript-string">&quot;L2U&quot;</span>, <span class="enscript-string">&quot;L3U&quot;</span>
};

<span class="enscript-comment">/* this function is Intel-specific */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_set_cache_info</span>( i386_cpu_info_t * info_p )
{
	uint32_t	cpuid_result[4];
	uint32_t	reg[4];
	uint32_t	index;
	uint32_t	linesizes[LCACHE_MAX];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	j;
	boolean_t	cpuid_deterministic_supported = FALSE;

	DBG(<span class="enscript-string">&quot;cpuid_set_cache_info(%p)\n&quot;</span>, info_p);

	bzero( linesizes, <span class="enscript-keyword">sizeof</span>(linesizes) );

	<span class="enscript-comment">/* Get processor cache descriptor info using leaf 2.  We don't use
	 * this internally, but must publish it for KEXTs.
	 */</span>
	cpuid_fn(2, cpuid_result);
	<span class="enscript-keyword">for</span> (j = 0; j &lt; 4; j++) {
		<span class="enscript-keyword">if</span> ((cpuid_result[j] &gt;&gt; 31) == 1) 	<span class="enscript-comment">/* bit31 is validity */</span>
			<span class="enscript-keyword">continue</span>;
		((uint32_t *) info_p-&gt;cache_info)[j] = cpuid_result[j];
	}
	<span class="enscript-comment">/* first byte gives number of cpuid calls to get all descriptors */</span>
	<span class="enscript-keyword">for</span> (i = 1; i &lt; info_p-&gt;cache_info[0]; i++) {
		<span class="enscript-keyword">if</span> (i*16 &gt; <span class="enscript-keyword">sizeof</span>(info_p-&gt;cache_info))
			<span class="enscript-keyword">break</span>;
		cpuid_fn(2, cpuid_result);
		<span class="enscript-keyword">for</span> (j = 0; j &lt; 4; j++) {
			<span class="enscript-keyword">if</span> ((cpuid_result[j] &gt;&gt; 31) == 1) 
				<span class="enscript-keyword">continue</span>;
			((uint32_t *) info_p-&gt;cache_info)[4*i+j] =
				cpuid_result[j];
		}
	}

	<span class="enscript-comment">/*
	 * Get cache info using leaf 4, the &quot;deterministic cache parameters.&quot;
	 * Most processors Mac OS X supports implement this flavor of CPUID.
	 * Loop over each cache on the processor.
	 */</span>
	cpuid_fn(0, cpuid_result);
	<span class="enscript-keyword">if</span> (cpuid_result[eax] &gt;= 4)
		cpuid_deterministic_supported = TRUE;

	<span class="enscript-keyword">for</span> (index = 0; cpuid_deterministic_supported; index++) {
		cache_type_t	type = Lnone;
		uint32_t	cache_type;
		uint32_t	cache_level;
		uint32_t	cache_sharing;
		uint32_t	cache_linesize;
		uint32_t	cache_sets;
		uint32_t	cache_associativity;
		uint32_t	cache_size;
		uint32_t	cache_partitions;
		uint32_t	colors;
		
		reg[eax] = 4;		<span class="enscript-comment">/* cpuid request 4 */</span>
		reg[ecx] = index;	<span class="enscript-comment">/* index starting at 0 */</span>
		cpuid(reg);
		DBG(<span class="enscript-string">&quot;cpuid(4) index=%d eax=0x%x\n&quot;</span>, index, reg[eax]);
		cache_type = bitfield32(reg[eax], 4, 0);
		<span class="enscript-keyword">if</span> (cache_type == 0)
			<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* no more caches */</span>
		cache_level  		= bitfield32(reg[eax],  7,  5);
		cache_sharing	 	= bitfield32(reg[eax], 25, 14) + 1;
		info_p-&gt;cpuid_cores_per_package 
					= bitfield32(reg[eax], 31, 26) + 1;
		cache_linesize		= bitfield32(reg[ebx], 11,  0) + 1;
		cache_partitions	= bitfield32(reg[ebx], 21, 12) + 1;
		cache_associativity	= bitfield32(reg[ebx], 31, 22) + 1;
		cache_sets 		= bitfield32(reg[ecx], 31,  0) + 1;
				
		<span class="enscript-comment">/* Map type/levels returned by CPUID into cache_type_t */</span>
		<span class="enscript-keyword">switch</span> (cache_level) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			type = cache_type == 1 ? L1D :
			       cache_type == 2 ? L1I :
						 Lnone;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			type = cache_type == 3 ? L2U :
						 Lnone;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			type = cache_type == 3 ? L3U :
						 Lnone;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			type = Lnone;
		}
		
		<span class="enscript-comment">/* The total size of a cache is:
		 *	( linesize * sets * associativity * partitions )
		 */</span>
		<span class="enscript-keyword">if</span> (type != Lnone) {
			cache_size = cache_linesize * cache_sets *
				     cache_associativity * cache_partitions;
			info_p-&gt;cache_size[type] = cache_size;
			info_p-&gt;cache_sharing[type] = cache_sharing;
			info_p-&gt;cache_partitions[type] = cache_partitions;
			linesizes[type] = cache_linesize;

			DBG(<span class="enscript-string">&quot; cache_size[%s]      : %d\n&quot;</span>,
			    cache_type_str[type], cache_size);
			DBG(<span class="enscript-string">&quot; cache_sharing[%s]   : %d\n&quot;</span>,
			    cache_type_str[type], cache_sharing);
			DBG(<span class="enscript-string">&quot; cache_partitions[%s]: %d\n&quot;</span>,
			    cache_type_str[type], cache_partitions);

			<span class="enscript-comment">/*
			 * Overwrite associativity determined via
			 * CPUID.0x80000006 -- this leaf is more
			 * accurate
			 */</span>
			<span class="enscript-keyword">if</span> (type == L2U)
				info_p-&gt;cpuid_cache_L2_associativity = cache_associativity;

			<span class="enscript-comment">/* Compute the number of page colors for this cache,
			 * which is:
			 *	( linesize * sets ) / page_size
			 *
			 * To help visualize this, consider two views of a
			 * physical address.  To the cache, it is composed
			 * of a line offset, a set selector, and a tag.
			 * To VM, it is composed of a page offset, a page
			 * color, and other bits in the pageframe number:
			 *
			 *           +-----------------+---------+--------+
			 *  cache:   |       tag       |   set   | offset |
			 *           +-----------------+---------+--------+
			 *
			 *           +-----------------+-------+----------+
			 *  VM:      |    don't care   | color | pg offset|
			 *           +-----------------+-------+----------+
			 *
			 * The color is those bits in (set+offset) not covered
			 * by the page offset.
			 */</span>
			 colors = ( cache_linesize * cache_sets ) &gt;&gt; 12;
			 
			 <span class="enscript-keyword">if</span> ( colors &gt; vm_cache_geometry_colors )
				vm_cache_geometry_colors = colors;
		}
	} 
	DBG(<span class="enscript-string">&quot; vm_cache_geometry_colors: %d\n&quot;</span>, vm_cache_geometry_colors);
	
	<span class="enscript-comment">/*
	 * If deterministic cache parameters are not available, use
	 * something else
	 */</span>
	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_cores_per_package == 0) {
		info_p-&gt;cpuid_cores_per_package = 1;

		<span class="enscript-comment">/* cpuid define in 1024 quantities */</span>
		info_p-&gt;cache_size[L2U] = info_p-&gt;cpuid_cache_size * 1024;
		info_p-&gt;cache_sharing[L2U] = 1;
		info_p-&gt;cache_partitions[L2U] = 1;

		linesizes[L2U] = info_p-&gt;cpuid_cache_linesize;

		DBG(<span class="enscript-string">&quot; cache_size[L2U]      : %d\n&quot;</span>,
		    info_p-&gt;cache_size[L2U]);
		DBG(<span class="enscript-string">&quot; cache_sharing[L2U]   : 1\n&quot;</span>);
		DBG(<span class="enscript-string">&quot; cache_partitions[L2U]: 1\n&quot;</span>);
		DBG(<span class="enscript-string">&quot; linesizes[L2U]       : %d\n&quot;</span>,
		    info_p-&gt;cpuid_cache_linesize);
	}
	
	<span class="enscript-comment">/*
	 * What linesize to publish?  We use the L2 linesize if any,
	 * else the L1D.
	 */</span>
	<span class="enscript-keyword">if</span> ( linesizes[L2U] )
		info_p-&gt;cache_linesize = linesizes[L2U];
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (linesizes[L1D])
		info_p-&gt;cache_linesize = linesizes[L1D];
	<span class="enscript-keyword">else</span> panic(<span class="enscript-string">&quot;no linesize&quot;</span>);
	DBG(<span class="enscript-string">&quot; cache_linesize    : %d\n&quot;</span>, info_p-&gt;cache_linesize);

	<span class="enscript-comment">/*
	 * Extract and publish TLB information from Leaf 2 descriptors.
	 */</span>
	DBG(<span class="enscript-string">&quot; %ld leaf2 descriptors:\n&quot;</span>, <span class="enscript-keyword">sizeof</span>(info_p-&gt;cache_info));
	<span class="enscript-keyword">for</span> (i = 1; i &lt; <span class="enscript-keyword">sizeof</span>(info_p-&gt;cache_info); i++) {
		cpuid_cache_descriptor_t	*descp;
		<span class="enscript-type">int</span>				id;
		<span class="enscript-type">int</span>				level;
		<span class="enscript-type">int</span>				page;

		DBG(<span class="enscript-string">&quot; 0x%02x&quot;</span>, info_p-&gt;cache_info[i]);
		descp = cpuid_leaf2_find(info_p-&gt;cache_info[i]);
		<span class="enscript-keyword">if</span> (descp == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">switch</span> (descp-&gt;type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TLB</span>:
			page = (descp-&gt;size == SMALL) ? TLB_SMALL : TLB_LARGE;
			<span class="enscript-comment">/* determine I or D: */</span>
			<span class="enscript-keyword">switch</span> (descp-&gt;level) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">INST</span>:
				id = TLB_INST;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DATA</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DATA0</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DATA1</span>:
				id = TLB_DATA;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* determine level: */</span>
			<span class="enscript-keyword">switch</span> (descp-&gt;level) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DATA1</span>:
				level = 1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				level = 0;
			}
			info_p-&gt;cpuid_tlb[id][page][level] = descp-&gt;entries;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">STLB</span>:
			info_p-&gt;cpuid_stlb = descp-&gt;entries;
		}
	}
	DBG(<span class="enscript-string">&quot;\n&quot;</span>);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_set_generic_info</span>(i386_cpu_info_t *info_p)
{
	uint32_t	reg[4];
        <span class="enscript-type">char</span>            str[128], *p;

	DBG(<span class="enscript-string">&quot;cpuid_set_generic_info(%p)\n&quot;</span>, info_p);

	<span class="enscript-comment">/* do cpuid 0 to get vendor */</span>
	cpuid_fn(0, reg);
	info_p-&gt;cpuid_max_basic = reg[eax];
	bcopy((<span class="enscript-type">char</span> *)&amp;reg[ebx], &amp;info_p-&gt;cpuid_vendor[0], 4); <span class="enscript-comment">/* ug */</span>
	bcopy((<span class="enscript-type">char</span> *)&amp;reg[ecx], &amp;info_p-&gt;cpuid_vendor[8], 4);
	bcopy((<span class="enscript-type">char</span> *)&amp;reg[edx], &amp;info_p-&gt;cpuid_vendor[4], 4);
	info_p-&gt;cpuid_vendor[12] = 0;

	<span class="enscript-comment">/* get extended cpuid results */</span>
	cpuid_fn(0x80000000, reg);
	info_p-&gt;cpuid_max_ext = reg[eax];

	<span class="enscript-comment">/* check to see if we can get brand string */</span>
	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_ext &gt;= 0x80000004) {
		<span class="enscript-comment">/*
		 * The brand string 48 bytes (max), guaranteed to
		 * be NUL terminated.
		 */</span>
		cpuid_fn(0x80000002, reg);
		bcopy((<span class="enscript-type">char</span> *)reg, &amp;str[0], 16);
		cpuid_fn(0x80000003, reg);
		bcopy((<span class="enscript-type">char</span> *)reg, &amp;str[16], 16);
		cpuid_fn(0x80000004, reg);
		bcopy((<span class="enscript-type">char</span> *)reg, &amp;str[32], 16);
		<span class="enscript-keyword">for</span> (p = str; *p != <span class="enscript-string">'\0'</span>; p++) {
			<span class="enscript-keyword">if</span> (*p != <span class="enscript-string">' '</span>) <span class="enscript-keyword">break</span>;
		}
		strlcpy(info_p-&gt;cpuid_brand_string,
			p, <span class="enscript-keyword">sizeof</span>(info_p-&gt;cpuid_brand_string));

                <span class="enscript-keyword">if</span> (!strncmp(info_p-&gt;cpuid_brand_string, CPUID_STRING_UNKNOWN,
			     min(<span class="enscript-keyword">sizeof</span>(info_p-&gt;cpuid_brand_string),
				 strlen(CPUID_STRING_UNKNOWN) + 1))) {
                    <span class="enscript-comment">/*
                     * This string means we have a firmware-programmable brand string,
                     * and the firmware couldn't figure out what sort of CPU we have.
                     */</span>
                    info_p-&gt;cpuid_brand_string[0] = <span class="enscript-string">'\0'</span>;
                }
	}
    
	<span class="enscript-comment">/* Get cache and addressing info. */</span>
	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_ext &gt;= 0x80000006) {
		uint32_t assoc;
		cpuid_fn(0x80000006, reg);
		info_p-&gt;cpuid_cache_linesize   = bitfield32(reg[ecx], 7, 0);
		assoc = bitfield32(reg[ecx],15,12);
		<span class="enscript-comment">/*
		 * L2 associativity is encoded, though in an insufficiently
		 * descriptive fashion, e.g. 24-way is mapped to 16-way.
		 * Represent a fully associative cache as 0xFFFF.
		 * Overwritten by associativity as determined via CPUID.4
		 * if available.
		 */</span>
		<span class="enscript-keyword">if</span> (assoc == 6)
			assoc = 8;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (assoc == 8)
			assoc = 16;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (assoc == 0xF)
			assoc = 0xFFFF;
		info_p-&gt;cpuid_cache_L2_associativity = assoc;
		info_p-&gt;cpuid_cache_size       = bitfield32(reg[ecx],31,16);
		cpuid_fn(0x80000008, reg);
		info_p-&gt;cpuid_address_bits_physical =
						 bitfield32(reg[eax], 7, 0);
		info_p-&gt;cpuid_address_bits_virtual =
						 bitfield32(reg[eax],15, 8);
	}

	<span class="enscript-comment">/*
	 * Get processor signature and decode
	 * and bracket this with the approved procedure for reading the
	 * the microcode version number a.k.a. signature a.k.a. BIOS ID
	 */</span>
	wrmsr64(MSR_IA32_BIOS_SIGN_ID, 0);
	cpuid_fn(1, reg);
	info_p-&gt;cpuid_microcode_version =
		(uint32_t) (rdmsr64(MSR_IA32_BIOS_SIGN_ID) &gt;&gt; 32);
	info_p-&gt;cpuid_signature = reg[eax];
	info_p-&gt;cpuid_stepping  = bitfield32(reg[eax],  3,  0);
	info_p-&gt;cpuid_model     = bitfield32(reg[eax],  7,  4);
	info_p-&gt;cpuid_family    = bitfield32(reg[eax], 11,  8);
	info_p-&gt;cpuid_type      = bitfield32(reg[eax], 13, 12);
	info_p-&gt;cpuid_extmodel  = bitfield32(reg[eax], 19, 16);
	info_p-&gt;cpuid_extfamily = bitfield32(reg[eax], 27, 20);
	info_p-&gt;cpuid_brand     = bitfield32(reg[ebx],  7,  0);
	info_p-&gt;cpuid_features  = quad(reg[ecx], reg[edx]);

	<span class="enscript-comment">/* Get &quot;processor flag&quot;; necessary for microcode update matching */</span>
	info_p-&gt;cpuid_processor_flag = (rdmsr64(MSR_IA32_PLATFORM_ID)&gt;&gt; 50) &amp; 0x7;

	<span class="enscript-comment">/* Fold extensions into family/model */</span>
	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_family == 0x0f)
		info_p-&gt;cpuid_family += info_p-&gt;cpuid_extfamily;
	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_family == 0x0f || info_p-&gt;cpuid_family == 0x06)
		info_p-&gt;cpuid_model += (info_p-&gt;cpuid_extmodel &lt;&lt; 4);

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_features &amp; CPUID_FEATURE_HTT)
		info_p-&gt;cpuid_logical_per_package =
				bitfield32(reg[ebx], 23, 16);
	<span class="enscript-keyword">else</span>
		info_p-&gt;cpuid_logical_per_package = 1;

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_ext &gt;= 0x80000001) {
		cpuid_fn(0x80000001, reg);
		info_p-&gt;cpuid_extfeatures =
				quad(reg[ecx], reg[edx]);
	}

	DBG(<span class="enscript-string">&quot; max_basic           : %d\n&quot;</span>, info_p-&gt;cpuid_max_basic);
	DBG(<span class="enscript-string">&quot; max_ext             : 0x%08x\n&quot;</span>, info_p-&gt;cpuid_max_ext);
	DBG(<span class="enscript-string">&quot; vendor              : %s\n&quot;</span>, info_p-&gt;cpuid_vendor);
	DBG(<span class="enscript-string">&quot; brand_string        : %s\n&quot;</span>, info_p-&gt;cpuid_brand_string);
	DBG(<span class="enscript-string">&quot; signature           : 0x%08x\n&quot;</span>, info_p-&gt;cpuid_signature);
	DBG(<span class="enscript-string">&quot; stepping            : %d\n&quot;</span>, info_p-&gt;cpuid_stepping);
	DBG(<span class="enscript-string">&quot; model               : %d\n&quot;</span>, info_p-&gt;cpuid_model);
	DBG(<span class="enscript-string">&quot; family              : %d\n&quot;</span>, info_p-&gt;cpuid_family);
	DBG(<span class="enscript-string">&quot; type                : %d\n&quot;</span>, info_p-&gt;cpuid_type);
	DBG(<span class="enscript-string">&quot; extmodel            : %d\n&quot;</span>, info_p-&gt;cpuid_extmodel);
	DBG(<span class="enscript-string">&quot; extfamily           : %d\n&quot;</span>, info_p-&gt;cpuid_extfamily);
	DBG(<span class="enscript-string">&quot; brand               : %d\n&quot;</span>, info_p-&gt;cpuid_brand);
	DBG(<span class="enscript-string">&quot; features            : 0x%016llx\n&quot;</span>, info_p-&gt;cpuid_features);
	DBG(<span class="enscript-string">&quot; extfeatures         : 0x%016llx\n&quot;</span>, info_p-&gt;cpuid_extfeatures);
	DBG(<span class="enscript-string">&quot; logical_per_package : %d\n&quot;</span>, info_p-&gt;cpuid_logical_per_package);
	DBG(<span class="enscript-string">&quot; microcode_version   : 0x%08x\n&quot;</span>, info_p-&gt;cpuid_microcode_version);

	<span class="enscript-comment">/* Fold in the Invariant TSC feature bit, if present */</span>
	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_ext &gt;= 0x80000007) {
		cpuid_fn(0x80000007, reg);  
		info_p-&gt;cpuid_extfeatures |=
				reg[edx] &amp; (uint32_t)CPUID_EXTFEATURE_TSCI;
		DBG(<span class="enscript-string">&quot; extfeatures         : 0x%016llx\n&quot;</span>,
		    info_p-&gt;cpuid_extfeatures);
	}

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_basic &gt;= 0x5) {
		cpuid_mwait_leaf_t	*cmp = &amp;info_p-&gt;cpuid_mwait_leaf;

		<span class="enscript-comment">/*
		 * Extract the Monitor/Mwait Leaf info:
		 */</span>
		cpuid_fn(5, reg);
		cmp-&gt;linesize_min = reg[eax];
		cmp-&gt;linesize_max = reg[ebx];
		cmp-&gt;extensions   = reg[ecx];
		cmp-&gt;sub_Cstates  = reg[edx];
		info_p-&gt;cpuid_mwait_leafp = cmp;

		DBG(<span class="enscript-string">&quot; Monitor/Mwait Leaf:\n&quot;</span>);
		DBG(<span class="enscript-string">&quot;  linesize_min : %d\n&quot;</span>, cmp-&gt;linesize_min);
		DBG(<span class="enscript-string">&quot;  linesize_max : %d\n&quot;</span>, cmp-&gt;linesize_max);
		DBG(<span class="enscript-string">&quot;  extensions   : %d\n&quot;</span>, cmp-&gt;extensions);
		DBG(<span class="enscript-string">&quot;  sub_Cstates  : 0x%08x\n&quot;</span>, cmp-&gt;sub_Cstates);
	}

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_basic &gt;= 0x6) {
		cpuid_thermal_leaf_t	*ctp = &amp;info_p-&gt;cpuid_thermal_leaf;

		<span class="enscript-comment">/*
		 * The thermal and Power Leaf:
		 */</span>
		cpuid_fn(6, reg);
		ctp-&gt;sensor 		  = bitfield32(reg[eax], 0, 0);
		ctp-&gt;dynamic_acceleration = bitfield32(reg[eax], 1, 1);
		ctp-&gt;invariant_APIC_timer = bitfield32(reg[eax], 2, 2);
		ctp-&gt;core_power_limits    = bitfield32(reg[eax], 4, 4);
		ctp-&gt;fine_grain_clock_mod = bitfield32(reg[eax], 5, 5);
		ctp-&gt;package_thermal_intr = bitfield32(reg[eax], 6, 6);
		ctp-&gt;thresholds		  = bitfield32(reg[ebx], 3, 0);
		ctp-&gt;ACNT_MCNT		  = bitfield32(reg[ecx], 0, 0);
		ctp-&gt;hardware_feedback	  = bitfield32(reg[ecx], 1, 1);
		ctp-&gt;energy_policy	  = bitfield32(reg[ecx], 3, 3);
		info_p-&gt;cpuid_thermal_leafp = ctp;

		DBG(<span class="enscript-string">&quot; Thermal/Power Leaf:\n&quot;</span>);
		DBG(<span class="enscript-string">&quot;  sensor               : %d\n&quot;</span>, ctp-&gt;sensor);
		DBG(<span class="enscript-string">&quot;  dynamic_acceleration : %d\n&quot;</span>, ctp-&gt;dynamic_acceleration);
		DBG(<span class="enscript-string">&quot;  invariant_APIC_timer : %d\n&quot;</span>, ctp-&gt;invariant_APIC_timer);
		DBG(<span class="enscript-string">&quot;  core_power_limits    : %d\n&quot;</span>, ctp-&gt;core_power_limits);
		DBG(<span class="enscript-string">&quot;  fine_grain_clock_mod : %d\n&quot;</span>, ctp-&gt;fine_grain_clock_mod);
		DBG(<span class="enscript-string">&quot;  package_thermal_intr : %d\n&quot;</span>, ctp-&gt;package_thermal_intr);
		DBG(<span class="enscript-string">&quot;  thresholds           : %d\n&quot;</span>, ctp-&gt;thresholds);
		DBG(<span class="enscript-string">&quot;  ACNT_MCNT            : %d\n&quot;</span>, ctp-&gt;ACNT_MCNT);
		DBG(<span class="enscript-string">&quot;  ACNT2                : %d\n&quot;</span>, ctp-&gt;hardware_feedback);
		DBG(<span class="enscript-string">&quot;  energy_policy        : %d\n&quot;</span>, ctp-&gt;energy_policy);
	}

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_basic &gt;= 0xa) {
		cpuid_arch_perf_leaf_t	*capp = &amp;info_p-&gt;cpuid_arch_perf_leaf;

		<span class="enscript-comment">/*
		 * Architectural Performance Monitoring Leaf:
		 */</span>
		cpuid_fn(0xa, reg);
		capp-&gt;version	    = bitfield32(reg[eax],  7,  0);
		capp-&gt;number	    = bitfield32(reg[eax], 15,  8);
		capp-&gt;width	    = bitfield32(reg[eax], 23, 16);
		capp-&gt;events_number = bitfield32(reg[eax], 31, 24);
		capp-&gt;events	    = reg[ebx];
		capp-&gt;fixed_number  = bitfield32(reg[edx],  4,  0);
		capp-&gt;fixed_width   = bitfield32(reg[edx], 12,  5);
		info_p-&gt;cpuid_arch_perf_leafp = capp;

		DBG(<span class="enscript-string">&quot; Architectural Performance Monitoring Leaf:\n&quot;</span>);
		DBG(<span class="enscript-string">&quot;  version       : %d\n&quot;</span>, capp-&gt;version);
		DBG(<span class="enscript-string">&quot;  number        : %d\n&quot;</span>, capp-&gt;number);
		DBG(<span class="enscript-string">&quot;  width         : %d\n&quot;</span>, capp-&gt;width);
		DBG(<span class="enscript-string">&quot;  events_number : %d\n&quot;</span>, capp-&gt;events_number);
		DBG(<span class="enscript-string">&quot;  events        : %d\n&quot;</span>, capp-&gt;events);
		DBG(<span class="enscript-string">&quot;  fixed_number  : %d\n&quot;</span>, capp-&gt;fixed_number);
		DBG(<span class="enscript-string">&quot;  fixed_width   : %d\n&quot;</span>, capp-&gt;fixed_width);
	}

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_max_basic &gt;= 0xd) {
		cpuid_xsave_leaf_t	*xsp;
		<span class="enscript-comment">/*
		 * XSAVE Features:
		 */</span>
		xsp = &amp;info_p-&gt;cpuid_xsave_leaf[0];
		info_p-&gt;cpuid_xsave_leafp = xsp;
		xsp-&gt;extended_state[eax] = 0xd;
		xsp-&gt;extended_state[ecx] = 0;
		cpuid(xsp-&gt;extended_state);
		DBG(<span class="enscript-string">&quot; XSAVE Main leaf:\n&quot;</span>);
		DBG(<span class="enscript-string">&quot;  EAX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[eax]);
		DBG(<span class="enscript-string">&quot;  EBX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[ebx]);
		DBG(<span class="enscript-string">&quot;  ECX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[ecx]);
		DBG(<span class="enscript-string">&quot;  EDX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[edx]);

		xsp = &amp;info_p-&gt;cpuid_xsave_leaf[1];
		xsp-&gt;extended_state[eax] = 0xd;
		xsp-&gt;extended_state[ecx] = 1;
		cpuid(xsp-&gt;extended_state);
		DBG(<span class="enscript-string">&quot; XSAVE Sub-leaf1:\n&quot;</span>);
		DBG(<span class="enscript-string">&quot;  EAX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[eax]);
		DBG(<span class="enscript-string">&quot;  EBX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[ebx]);
		DBG(<span class="enscript-string">&quot;  ECX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[ecx]);
		DBG(<span class="enscript-string">&quot;  EDX           : 0x%x\n&quot;</span>, xsp-&gt;extended_state[edx]);

	}

	<span class="enscript-keyword">if</span> (info_p-&gt;cpuid_model &gt;= CPUID_MODEL_IVYBRIDGE) {
		<span class="enscript-comment">/*
		 * Leaf7 Features:
		 */</span>
		cpuid_fn(0x7, reg);
		info_p-&gt;cpuid_leaf7_features = quad(reg[ecx], reg[ebx]);

		DBG(<span class="enscript-string">&quot; Feature Leaf7:\n&quot;</span>);
		DBG(<span class="enscript-string">&quot;  EBX           : 0x%x\n&quot;</span>, reg[ebx]);
		DBG(<span class="enscript-string">&quot;  ECX           : 0x%x\n&quot;</span>, reg[ecx]);
	}
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">cpuid_set_cpufamily</span>(i386_cpu_info_t *info_p)
{
	uint32_t cpufamily = CPUFAMILY_UNKNOWN;

	<span class="enscript-keyword">switch</span> (info_p-&gt;cpuid_family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		<span class="enscript-keyword">switch</span> (info_p-&gt;cpuid_model) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">15</span>:
			cpufamily = CPUFAMILY_INTEL_MEROM;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">23</span>:
			cpufamily = CPUFAMILY_INTEL_PENRYN;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_NEHALEM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_FIELDS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_DALES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_NEHALEM_EX</span>:
			cpufamily = CPUFAMILY_INTEL_NEHALEM;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_DALES_32NM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_WESTMERE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_WESTMERE_EX</span>:
			cpufamily = CPUFAMILY_INTEL_WESTMERE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_SANDYBRIDGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_JAKETOWN</span>:
			cpufamily = CPUFAMILY_INTEL_SANDYBRIDGE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_IVYBRIDGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_IVYBRIDGE_EP</span>:
			cpufamily = CPUFAMILY_INTEL_IVYBRIDGE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_HASWELL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_HASWELL_EP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_HASWELL_ULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_CRYSTALWELL</span>:
			cpufamily = CPUFAMILY_INTEL_HASWELL;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_BROADWELL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUID_MODEL_BRYSTALWELL</span>:
			cpufamily = CPUFAMILY_INTEL_BROADWELL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	info_p-&gt;cpuid_cpufamily = cpufamily;
	DBG(<span class="enscript-string">&quot;cpuid_set_cpufamily(%p) returning 0x%x\n&quot;</span>, info_p, cpufamily);
	<span class="enscript-keyword">return</span> cpufamily;
}
<span class="enscript-comment">/*
 * Must be invoked either when executing single threaded, or with
 * independent synchronization.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_set_info</span>(<span class="enscript-type">void</span>)
{
	i386_cpu_info_t		*info_p = &amp;cpuid_cpu_info;
	boolean_t		enable_x86_64h = TRUE;

	cpuid_set_generic_info(info_p);

	<span class="enscript-comment">/* verify we are running on a supported CPU */</span>
	<span class="enscript-keyword">if</span> ((strncmp(CPUID_VID_INTEL, info_p-&gt;cpuid_vendor,
		     min(strlen(CPUID_STRING_UNKNOWN) + 1,
			 <span class="enscript-keyword">sizeof</span>(info_p-&gt;cpuid_vendor)))) ||
	   (cpuid_set_cpufamily(info_p) == CPUFAMILY_UNKNOWN))
		panic(<span class="enscript-string">&quot;Unsupported CPU&quot;</span>);

	info_p-&gt;cpuid_cpu_type = CPU_TYPE_X86;

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;-enable_x86_64h&quot;</span>, &amp;enable_x86_64h, <span class="enscript-keyword">sizeof</span>(enable_x86_64h))) {
		boolean_t		disable_x86_64h = FALSE;

		<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-disable_x86_64h&quot;</span>, &amp;disable_x86_64h, <span class="enscript-keyword">sizeof</span>(disable_x86_64h))) {
			enable_x86_64h = FALSE;
		}
	}

	<span class="enscript-keyword">if</span> (enable_x86_64h &amp;&amp;
	    ((info_p-&gt;cpuid_features &amp; CPUID_X86_64_H_FEATURE_SUBSET) == CPUID_X86_64_H_FEATURE_SUBSET) &amp;&amp;
	    ((info_p-&gt;cpuid_extfeatures &amp; CPUID_X86_64_H_EXTFEATURE_SUBSET) == CPUID_X86_64_H_EXTFEATURE_SUBSET) &amp;&amp;
	    ((info_p-&gt;cpuid_leaf7_features &amp; CPUID_X86_64_H_LEAF7_FEATURE_SUBSET) == CPUID_X86_64_H_LEAF7_FEATURE_SUBSET)) {
		info_p-&gt;cpuid_cpu_subtype = CPU_SUBTYPE_X86_64_H;
	} <span class="enscript-keyword">else</span> {
		info_p-&gt;cpuid_cpu_subtype = CPU_SUBTYPE_X86_ARCH1;
	}

	<span class="enscript-comment">/* Must be invoked after set_generic_info */</span>
	cpuid_set_cache_info(info_p);

	<span class="enscript-comment">/*
	 * Find the number of enabled cores and threads
	 * (which determines whether SMT/Hyperthreading is active).
	 */</span>
	<span class="enscript-keyword">switch</span> (info_p-&gt;cpuid_cpufamily) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUFAMILY_INTEL_MEROM</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUFAMILY_INTEL_PENRYN</span>:
		info_p-&gt;core_count   = info_p-&gt;cpuid_cores_per_package;
		info_p-&gt;thread_count = info_p-&gt;cpuid_logical_per_package;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CPUFAMILY_INTEL_WESTMERE</span>: {
		uint64_t msr = rdmsr64(MSR_CORE_THREAD_COUNT);
		info_p-&gt;core_count   = bitfield32((uint32_t)msr, 19, 16);
		info_p-&gt;thread_count = bitfield32((uint32_t)msr, 15,  0);
		<span class="enscript-keyword">break</span>;
		}
	<span class="enscript-reference">default</span>: {
		uint64_t msr = rdmsr64(MSR_CORE_THREAD_COUNT);
		info_p-&gt;core_count   = bitfield32((uint32_t)msr, 31, 16);
		info_p-&gt;thread_count = bitfield32((uint32_t)msr, 15,  0);
		<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (info_p-&gt;core_count == 0) {
		info_p-&gt;core_count   = info_p-&gt;cpuid_cores_per_package;
		info_p-&gt;thread_count = info_p-&gt;cpuid_logical_per_package;
	}
	DBG(<span class="enscript-string">&quot;cpuid_set_info():\n&quot;</span>);
	DBG(<span class="enscript-string">&quot;  core_count   : %d\n&quot;</span>, info_p-&gt;core_count);
	DBG(<span class="enscript-string">&quot;  thread_count : %d\n&quot;</span>, info_p-&gt;thread_count);
	DBG(<span class="enscript-string">&quot;       cpu_type: 0x%08x\n&quot;</span>, info_p-&gt;cpuid_cpu_type);
	DBG(<span class="enscript-string">&quot;    cpu_subtype: 0x%08x\n&quot;</span>, info_p-&gt;cpuid_cpu_subtype);

	info_p-&gt;cpuid_model_string = <span class="enscript-string">&quot;&quot;</span>; <span class="enscript-comment">/* deprecated */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> table {
	uint64_t	mask;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*name;
} feature_map[] = {
	{CPUID_FEATURE_FPU,       <span class="enscript-string">&quot;FPU&quot;</span>},
	{CPUID_FEATURE_VME,       <span class="enscript-string">&quot;VME&quot;</span>},
	{CPUID_FEATURE_DE,        <span class="enscript-string">&quot;DE&quot;</span>},
	{CPUID_FEATURE_PSE,       <span class="enscript-string">&quot;PSE&quot;</span>},
	{CPUID_FEATURE_TSC,       <span class="enscript-string">&quot;TSC&quot;</span>},
	{CPUID_FEATURE_MSR,       <span class="enscript-string">&quot;MSR&quot;</span>},
	{CPUID_FEATURE_PAE,       <span class="enscript-string">&quot;PAE&quot;</span>},
	{CPUID_FEATURE_MCE,       <span class="enscript-string">&quot;MCE&quot;</span>},
	{CPUID_FEATURE_CX8,       <span class="enscript-string">&quot;CX8&quot;</span>},
	{CPUID_FEATURE_APIC,      <span class="enscript-string">&quot;APIC&quot;</span>},
	{CPUID_FEATURE_SEP,       <span class="enscript-string">&quot;SEP&quot;</span>},
	{CPUID_FEATURE_MTRR,      <span class="enscript-string">&quot;MTRR&quot;</span>},
	{CPUID_FEATURE_PGE,       <span class="enscript-string">&quot;PGE&quot;</span>},
	{CPUID_FEATURE_MCA,       <span class="enscript-string">&quot;MCA&quot;</span>},
	{CPUID_FEATURE_CMOV,      <span class="enscript-string">&quot;CMOV&quot;</span>},
	{CPUID_FEATURE_PAT,       <span class="enscript-string">&quot;PAT&quot;</span>},
	{CPUID_FEATURE_PSE36,     <span class="enscript-string">&quot;PSE36&quot;</span>},
	{CPUID_FEATURE_PSN,       <span class="enscript-string">&quot;PSN&quot;</span>},
	{CPUID_FEATURE_CLFSH,     <span class="enscript-string">&quot;CLFSH&quot;</span>},
	{CPUID_FEATURE_DS,        <span class="enscript-string">&quot;DS&quot;</span>},
	{CPUID_FEATURE_ACPI,      <span class="enscript-string">&quot;ACPI&quot;</span>},
	{CPUID_FEATURE_MMX,       <span class="enscript-string">&quot;MMX&quot;</span>},
	{CPUID_FEATURE_FXSR,      <span class="enscript-string">&quot;FXSR&quot;</span>},
	{CPUID_FEATURE_SSE,       <span class="enscript-string">&quot;SSE&quot;</span>},
	{CPUID_FEATURE_SSE2,      <span class="enscript-string">&quot;SSE2&quot;</span>},
	{CPUID_FEATURE_SS,        <span class="enscript-string">&quot;SS&quot;</span>},
	{CPUID_FEATURE_HTT,       <span class="enscript-string">&quot;HTT&quot;</span>},
	{CPUID_FEATURE_TM,        <span class="enscript-string">&quot;TM&quot;</span>},
	{CPUID_FEATURE_PBE,       <span class="enscript-string">&quot;PBE&quot;</span>},
	{CPUID_FEATURE_SSE3,      <span class="enscript-string">&quot;SSE3&quot;</span>},
	{CPUID_FEATURE_PCLMULQDQ, <span class="enscript-string">&quot;PCLMULQDQ&quot;</span>},
	{CPUID_FEATURE_DTES64,    <span class="enscript-string">&quot;DTES64&quot;</span>},
	{CPUID_FEATURE_MONITOR,   <span class="enscript-string">&quot;MON&quot;</span>},
	{CPUID_FEATURE_DSCPL,     <span class="enscript-string">&quot;DSCPL&quot;</span>},
	{CPUID_FEATURE_VMX,       <span class="enscript-string">&quot;VMX&quot;</span>},
	{CPUID_FEATURE_SMX,       <span class="enscript-string">&quot;SMX&quot;</span>},
	{CPUID_FEATURE_EST,       <span class="enscript-string">&quot;EST&quot;</span>},
	{CPUID_FEATURE_TM2,       <span class="enscript-string">&quot;TM2&quot;</span>},
	{CPUID_FEATURE_SSSE3,     <span class="enscript-string">&quot;SSSE3&quot;</span>},
	{CPUID_FEATURE_CID,       <span class="enscript-string">&quot;CID&quot;</span>},
	{CPUID_FEATURE_FMA,       <span class="enscript-string">&quot;FMA&quot;</span>},
	{CPUID_FEATURE_CX16,      <span class="enscript-string">&quot;CX16&quot;</span>},
	{CPUID_FEATURE_xTPR,      <span class="enscript-string">&quot;TPR&quot;</span>},
	{CPUID_FEATURE_PDCM,      <span class="enscript-string">&quot;PDCM&quot;</span>},
	{CPUID_FEATURE_SSE4_1,    <span class="enscript-string">&quot;SSE4.1&quot;</span>},
	{CPUID_FEATURE_SSE4_2,    <span class="enscript-string">&quot;SSE4.2&quot;</span>},
	{CPUID_FEATURE_x2APIC,    <span class="enscript-string">&quot;x2APIC&quot;</span>},
	{CPUID_FEATURE_MOVBE,     <span class="enscript-string">&quot;MOVBE&quot;</span>},
	{CPUID_FEATURE_POPCNT,    <span class="enscript-string">&quot;POPCNT&quot;</span>},
	{CPUID_FEATURE_AES,       <span class="enscript-string">&quot;AES&quot;</span>},
	{CPUID_FEATURE_VMM,       <span class="enscript-string">&quot;VMM&quot;</span>},
	{CPUID_FEATURE_PCID,      <span class="enscript-string">&quot;PCID&quot;</span>},
	{CPUID_FEATURE_XSAVE,     <span class="enscript-string">&quot;XSAVE&quot;</span>},
	{CPUID_FEATURE_OSXSAVE,   <span class="enscript-string">&quot;OSXSAVE&quot;</span>},
	{CPUID_FEATURE_SEGLIM64,  <span class="enscript-string">&quot;SEGLIM64&quot;</span>},
	{CPUID_FEATURE_TSCTMR,    <span class="enscript-string">&quot;TSCTMR&quot;</span>},
	{CPUID_FEATURE_AVX1_0,    <span class="enscript-string">&quot;AVX1.0&quot;</span>},
	{CPUID_FEATURE_RDRAND,    <span class="enscript-string">&quot;RDRAND&quot;</span>},
	{CPUID_FEATURE_F16C,      <span class="enscript-string">&quot;F16C&quot;</span>},
	{0, 0}
},
extfeature_map[] = {
	{CPUID_EXTFEATURE_SYSCALL, <span class="enscript-string">&quot;SYSCALL&quot;</span>},
	{CPUID_EXTFEATURE_XD,      <span class="enscript-string">&quot;XD&quot;</span>},
	{CPUID_EXTFEATURE_1GBPAGE, <span class="enscript-string">&quot;1GBPAGE&quot;</span>},
	{CPUID_EXTFEATURE_EM64T,   <span class="enscript-string">&quot;EM64T&quot;</span>},
	{CPUID_EXTFEATURE_LAHF,    <span class="enscript-string">&quot;LAHF&quot;</span>},
	{CPUID_EXTFEATURE_LZCNT,   <span class="enscript-string">&quot;LZCNT&quot;</span>},
	{CPUID_EXTFEATURE_PREFETCHW, <span class="enscript-string">&quot;PREFETCHW&quot;</span>},
	{CPUID_EXTFEATURE_RDTSCP,  <span class="enscript-string">&quot;RDTSCP&quot;</span>},
	{CPUID_EXTFEATURE_TSCI,    <span class="enscript-string">&quot;TSCI&quot;</span>},
	{0, 0}

},
leaf7_feature_map[] = {
	{CPUID_LEAF7_FEATURE_SMEP,     <span class="enscript-string">&quot;SMEP&quot;</span>},
	{CPUID_LEAF7_FEATURE_ERMS,     <span class="enscript-string">&quot;ERMS&quot;</span>},
	{CPUID_LEAF7_FEATURE_RDWRFSGS, <span class="enscript-string">&quot;RDWRFSGS&quot;</span>},
	{CPUID_LEAF7_FEATURE_TSCOFF,   <span class="enscript-string">&quot;TSC_THREAD_OFFSET&quot;</span>},
	{CPUID_LEAF7_FEATURE_BMI1,     <span class="enscript-string">&quot;BMI1&quot;</span>},
	{CPUID_LEAF7_FEATURE_HLE,      <span class="enscript-string">&quot;HLE&quot;</span>},
	{CPUID_LEAF7_FEATURE_AVX2,     <span class="enscript-string">&quot;AVX2&quot;</span>},
	{CPUID_LEAF7_FEATURE_BMI2,     <span class="enscript-string">&quot;BMI2&quot;</span>},
	{CPUID_LEAF7_FEATURE_INVPCID,  <span class="enscript-string">&quot;INVPCID&quot;</span>},
	{CPUID_LEAF7_FEATURE_RTM,      <span class="enscript-string">&quot;RTM&quot;</span>},
	{CPUID_LEAF7_FEATURE_SMAP,     <span class="enscript-string">&quot;SMAP&quot;</span>},
	{CPUID_LEAF7_FEATURE_RDSEED,   <span class="enscript-string">&quot;RDSEED&quot;</span>},
	{CPUID_LEAF7_FEATURE_ADX,      <span class="enscript-string">&quot;ADX&quot;</span>},
	{0, 0}
};

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">cpuid_get_names</span>(<span class="enscript-type">struct</span> table *map, uint64_t bits, <span class="enscript-type">char</span> *buf, <span class="enscript-type">unsigned</span> buf_len)
{
	size_t	len = 0;
	<span class="enscript-type">char</span>	*p = buf;
	<span class="enscript-type">int</span>	i;

	<span class="enscript-keyword">for</span> (i = 0; map[i].mask != 0; i++) {
		<span class="enscript-keyword">if</span> ((bits &amp; map[i].mask) == 0)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (len &amp;&amp; ((size_t) (p - buf) &lt; (buf_len - 1)))
			*p++ = <span class="enscript-string">' '</span>;
		len = min(strlen(map[i].name), (size_t)((buf_len-1)-(p-buf)));
		<span class="enscript-keyword">if</span> (len == 0)
			<span class="enscript-keyword">break</span>;
		bcopy(map[i].name, p, len);
		p += len;
	}
	*p = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">return</span> buf;
}

i386_cpu_info_t	*
<span class="enscript-function-name">cpuid_info</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* Set-up the cpuid_info stucture lazily */</span>
	<span class="enscript-keyword">if</span> (cpuid_cpu_infop == NULL) {
		PE_parse_boot_argn(<span class="enscript-string">&quot;-cpuid&quot;</span>, &amp;cpuid_dbg, <span class="enscript-keyword">sizeof</span>(cpuid_dbg));
		cpuid_set_info();
		cpuid_cpu_infop = &amp;cpuid_cpu_info;
	}
	<span class="enscript-keyword">return</span> cpuid_cpu_infop;
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">cpuid_get_feature_names</span>(uint64_t features, <span class="enscript-type">char</span> *buf, <span class="enscript-type">unsigned</span> buf_len)
{
	<span class="enscript-keyword">return</span> cpuid_get_names(feature_map, features, buf, buf_len); 
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">cpuid_get_extfeature_names</span>(uint64_t extfeatures, <span class="enscript-type">char</span> *buf, <span class="enscript-type">unsigned</span> buf_len)
{
	<span class="enscript-keyword">return</span> cpuid_get_names(extfeature_map, extfeatures, buf, buf_len); 
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">cpuid_get_leaf7_feature_names</span>(uint64_t features, <span class="enscript-type">char</span> *buf, <span class="enscript-type">unsigned</span> buf_len)
{
	<span class="enscript-keyword">return</span> cpuid_get_names(leaf7_feature_map, features, buf, buf_len); 
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_feature_display</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*header)
{
       <span class="enscript-type">char</span>    buf[320];

	kprintf(<span class="enscript-string">&quot;%s: %s&quot;</span>, header,
		 cpuid_get_feature_names(cpuid_features(), buf, <span class="enscript-keyword">sizeof</span>(buf)));
	<span class="enscript-keyword">if</span> (cpuid_leaf7_features())
		kprintf(<span class="enscript-string">&quot; %s&quot;</span>, cpuid_get_leaf7_feature_names(
				cpuid_leaf7_features(), buf, <span class="enscript-keyword">sizeof</span>(buf)));
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
	<span class="enscript-keyword">if</span> (cpuid_features() &amp; CPUID_FEATURE_HTT) {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">s_if_plural</span>(n)	((n &gt; 1) ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>)
		kprintf(<span class="enscript-string">&quot;  HTT: %d core%s per package;&quot;</span>
			     <span class="enscript-string">&quot; %d logical cpu%s per package\n&quot;</span>,
			cpuid_cpu_infop-&gt;cpuid_cores_per_package,
			s_if_plural(cpuid_cpu_infop-&gt;cpuid_cores_per_package),
			cpuid_cpu_infop-&gt;cpuid_logical_per_package,
			s_if_plural(cpuid_cpu_infop-&gt;cpuid_logical_per_package));
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_extfeature_display</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*header)
{
	<span class="enscript-type">char</span>	buf[256];

	kprintf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, header,
		  cpuid_get_extfeature_names(cpuid_extfeatures(),
						buf, <span class="enscript-keyword">sizeof</span>(buf)));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_cpu_display</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*header)
{
    <span class="enscript-keyword">if</span> (cpuid_cpu_infop-&gt;cpuid_brand_string[0] != <span class="enscript-string">'\0'</span>) {
	kprintf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, header, cpuid_cpu_infop-&gt;cpuid_brand_string);
    }
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cpuid_family</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_info()-&gt;cpuid_family;
}

uint32_t
<span class="enscript-function-name">cpuid_cpufamily</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_info()-&gt;cpuid_cpufamily;
}

cpu_type_t
<span class="enscript-function-name">cpuid_cputype</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_info()-&gt;cpuid_cpu_type;
}

cpu_subtype_t
<span class="enscript-function-name">cpuid_cpusubtype</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_info()-&gt;cpuid_cpu_subtype;
}

uint64_t
<span class="enscript-function-name">cpuid_features</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> checked = 0;
	<span class="enscript-type">char</span>	fpu_arg[20] = { 0 };

	(<span class="enscript-type">void</span>) cpuid_info();
	<span class="enscript-keyword">if</span> (!checked) {
		    <span class="enscript-comment">/* check for boot-time fpu limitations */</span>
			<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;_fpu&quot;</span>, &amp;fpu_arg[0], <span class="enscript-keyword">sizeof</span> (fpu_arg))) {
				printf(<span class="enscript-string">&quot;limiting fpu features to: %s\n&quot;</span>, fpu_arg);
				<span class="enscript-keyword">if</span> (!strncmp(<span class="enscript-string">&quot;387&quot;</span>, fpu_arg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;387&quot;</span>)) || !strncmp(<span class="enscript-string">&quot;mmx&quot;</span>, fpu_arg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;mmx&quot;</span>))) {
					printf(<span class="enscript-string">&quot;no sse or sse2\n&quot;</span>);
					cpuid_cpu_infop-&gt;cpuid_features &amp;= ~(CPUID_FEATURE_SSE | CPUID_FEATURE_SSE2 | CPUID_FEATURE_FXSR);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncmp(<span class="enscript-string">&quot;sse&quot;</span>, fpu_arg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;sse&quot;</span>))) {
					printf(<span class="enscript-string">&quot;no sse2\n&quot;</span>);
					cpuid_cpu_infop-&gt;cpuid_features &amp;= ~(CPUID_FEATURE_SSE2);
				}
			}
			checked = 1;
	}
	<span class="enscript-keyword">return</span> cpuid_cpu_infop-&gt;cpuid_features;
}

uint64_t
<span class="enscript-function-name">cpuid_extfeatures</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_info()-&gt;cpuid_extfeatures;
}
 
uint64_t
<span class="enscript-function-name">cpuid_leaf7_features</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_info()-&gt;cpuid_leaf7_features;
}

<span class="enscript-type">static</span> i386_vmm_info_t	*_cpuid_vmm_infop = NULL;
<span class="enscript-type">static</span> i386_vmm_info_t	_cpuid_vmm_info;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cpuid_init_vmm_info</span>(i386_vmm_info_t *info_p)
{
	uint32_t	reg[4];
	uint32_t	max_vmm_leaf;

	bzero(info_p, <span class="enscript-keyword">sizeof</span>(*info_p));

	<span class="enscript-keyword">if</span> (!cpuid_vmm_present())
		<span class="enscript-keyword">return</span>;

	DBG(<span class="enscript-string">&quot;cpuid_init_vmm_info(%p)\n&quot;</span>, info_p);

	<span class="enscript-comment">/* do cpuid 0x40000000 to get VMM vendor */</span>
	cpuid_fn(0x40000000, reg);
	max_vmm_leaf = reg[eax];
	bcopy((<span class="enscript-type">char</span> *)&amp;reg[ebx], &amp;info_p-&gt;cpuid_vmm_vendor[0], 4);
	bcopy((<span class="enscript-type">char</span> *)&amp;reg[ecx], &amp;info_p-&gt;cpuid_vmm_vendor[4], 4);
	bcopy((<span class="enscript-type">char</span> *)&amp;reg[edx], &amp;info_p-&gt;cpuid_vmm_vendor[8], 4);
	info_p-&gt;cpuid_vmm_vendor[12] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (0 == strcmp(info_p-&gt;cpuid_vmm_vendor, CPUID_VMM_ID_VMWARE)) {
		<span class="enscript-comment">/* VMware identification string: kb.vmware.com/kb/1009458 */</span>
		info_p-&gt;cpuid_vmm_family = CPUID_VMM_FAMILY_VMWARE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (0 == strcmp(info_p-&gt;cpuid_vmm_vendor, CPUID_VMM_ID_PARALLELS)) {
		<span class="enscript-comment">/* Parallels identification string */</span>
		info_p-&gt;cpuid_vmm_family = CPUID_VMM_FAMILY_PARALLELS;
	} <span class="enscript-keyword">else</span> {
		info_p-&gt;cpuid_vmm_family = CPUID_VMM_FAMILY_UNKNOWN;
	}

	<span class="enscript-comment">/* VMM generic leaves: <a href="https://lkml.org/lkml/2008/10/1/246">https://lkml.org/lkml/2008/10/1/246</a> */</span>
	<span class="enscript-keyword">if</span> (max_vmm_leaf &gt;= 0x40000010) {
		cpuid_fn(0x40000010, reg);
		
		info_p-&gt;cpuid_vmm_tsc_frequency = reg[eax];
		info_p-&gt;cpuid_vmm_bus_frequency = reg[ebx];
	}

	DBG(<span class="enscript-string">&quot; vmm_vendor          : %s\n&quot;</span>, info_p-&gt;cpuid_vmm_vendor);
	DBG(<span class="enscript-string">&quot; vmm_family          : %u\n&quot;</span>, info_p-&gt;cpuid_vmm_family);
	DBG(<span class="enscript-string">&quot; vmm_bus_frequency   : %u\n&quot;</span>, info_p-&gt;cpuid_vmm_bus_frequency);
	DBG(<span class="enscript-string">&quot; vmm_tsc_frequency   : %u\n&quot;</span>, info_p-&gt;cpuid_vmm_tsc_frequency);
}

boolean_t
<span class="enscript-function-name">cpuid_vmm_present</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (cpuid_features() &amp; CPUID_FEATURE_VMM) ? TRUE : FALSE;
}

i386_vmm_info_t *
<span class="enscript-function-name">cpuid_vmm_info</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (_cpuid_vmm_infop == NULL) {
		cpuid_init_vmm_info(&amp;_cpuid_vmm_info);
		_cpuid_vmm_infop = &amp;_cpuid_vmm_info;
	}
	<span class="enscript-keyword">return</span> _cpuid_vmm_infop;
}

uint32_t
<span class="enscript-function-name">cpuid_vmm_family</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> cpuid_vmm_info()-&gt;cpuid_vmm_family;
}

</pre>
<hr />
</body></html>