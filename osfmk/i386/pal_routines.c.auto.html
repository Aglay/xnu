<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pal_routines.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pal_routines.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * file: pal_routines.c
 *       Platform Abstraction Layer routines for bare-metal i386 and x86_64
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/serial_io.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/lapic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>

<span class="enscript-comment">//#define PAL_DEBUG 1
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PAL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)       kprintf(<span class="enscript-string">&quot;PAL_DBG: &quot;</span> x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PAL_DEBUG */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *gPEEFIRuntimeServices;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *gPEEFISystemTable;

<span class="enscript-comment">/* nanotime conversion information */</span>
pal_rtc_nanotime_t pal_rtc_nanotime_info = {0,0,0,0,1,0};

<span class="enscript-comment">/* APIC kext may use this to access xnu internal state */</span>
<span class="enscript-type">struct</span> pal_apic_table *apic_table = NULL;

<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">static</span> , pal_efi_lock);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
<span class="enscript-type">static</span> pml4_entry_t IDPML4[PTE_PER_PAGE] __attribute__ ((aligned (4096)));
uint64_t	pal_efi_saved_cr0;
uint64_t	pal_efi_saved_cr3;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* Serial routines */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pal_serial_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> serial_init();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_serial_putc</span>(<span class="enscript-type">char</span> c)
{
	serial_putc(c);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pal_serial_getc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> serial_getc();
}


<span class="enscript-comment">/* Generic routines */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_i386_init</span>(<span class="enscript-type">void</span>)
{
    simple_lock_init(&amp;pal_efi_lock, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_get_control_registers</span>( pal_cr_t *cr0, pal_cr_t *cr2, 
			   pal_cr_t *cr3, pal_cr_t *cr4 )
{
	*cr0 = get_cr0();
	*cr2 = get_cr2();
	*cr3 = get_cr3_raw();
	*cr4 = get_cr4();
}


<span class="enscript-comment">/*
 * define functions below here to ensure we have symbols for these,
 * even though they're not used on this platform.
 */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">pal_dbg_page_fault</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_dbg_page_fault</span>( thread_t thread __unused,
		    user_addr_t vaddr __unused,
		    kern_return_t kr __unused )
{
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">pal_dbg_set_task_name</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_dbg_set_task_name</span>( task_t task __unused )
{
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">pal_set_signal_delivery</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_set_signal_delivery</span>(thread_t thread __unused)
{
}

<span class="enscript-comment">/* EFI thunks */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_pal_efi_call_in_64bit_mode_asm</span>(uint64_t func,
                                <span class="enscript-type">struct</span> pal_efi_registers *efi_reg,
                                <span class="enscript-type">void</span> *stack_contents,
                                size_t stack_contents_size);

kern_return_t
<span class="enscript-function-name">pal_efi_call_in_64bit_mode</span>(uint64_t func,
                           <span class="enscript-type">struct</span> pal_efi_registers *efi_reg,
                           <span class="enscript-type">void</span> *stack_contents,
                           size_t stack_contents_size, <span class="enscript-comment">/* 16-byte multiple */</span>
                           uint64_t *efi_status)
{
    DBG(<span class="enscript-string">&quot;pal_efi_call_in_64bit_mode(0x%016llx, %p, %p, %lu, %p)\n&quot;</span>,
        func, efi_reg, stack_contents, stack_contents_size, efi_status);

    <span class="enscript-keyword">if</span> (func == 0) {
        <span class="enscript-keyword">return</span> KERN_INVALID_ADDRESS;
    }

    <span class="enscript-keyword">if</span> ((efi_reg == NULL)
        || (stack_contents == NULL)
        || (stack_contents_size % 16 != 0)) {
        <span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
    }

    <span class="enscript-keyword">if</span> (!gPEEFISystemTable || !gPEEFIRuntimeServices) {
        <span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
    }

    <span class="enscript-keyword">if</span> (func &lt; VM_MIN_KERNEL_ADDRESS) {
        <span class="enscript-comment">/*
         * EFI Runtime Services must be mapped in our address
         * space at an appropriate location.
         */</span>
        <span class="enscript-keyword">return</span> KERN_INVALID_ADDRESS;
    }

    _pal_efi_call_in_64bit_mode_asm(func,
                                    efi_reg,
                                    stack_contents,
                                    stack_contents_size);

    *efi_status = efi_reg-&gt;rax;

    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_pal_efi_call_in_32bit_mode_asm</span>(uint32_t func,
                                <span class="enscript-type">struct</span> pal_efi_registers *efi_reg,
                                <span class="enscript-type">void</span> *stack_contents,
                                size_t stack_contents_size);

kern_return_t
<span class="enscript-function-name">pal_efi_call_in_32bit_mode</span>(uint32_t func,
                           <span class="enscript-type">struct</span> pal_efi_registers *efi_reg,
                           <span class="enscript-type">void</span> *stack_contents,
                           size_t stack_contents_size, <span class="enscript-comment">/* 16-byte multiple */</span>
                           uint32_t *efi_status)
{
    DBG(<span class="enscript-string">&quot;pal_efi_call_in_32bit_mode(0x%08x, %p, %p, %lu, %p)\n&quot;</span>,
	func, efi_reg, stack_contents, stack_contents_size, efi_status);

    <span class="enscript-keyword">if</span> (func == 0) {
        <span class="enscript-keyword">return</span> KERN_INVALID_ADDRESS;
    }

    <span class="enscript-keyword">if</span> ((efi_reg == NULL)
        || (stack_contents == NULL)
        || (stack_contents_size % 16 != 0)) {
        <span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
    }

    <span class="enscript-keyword">if</span> (!gPEEFISystemTable || !gPEEFIRuntimeServices) {
        <span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
    }

    DBG(<span class="enscript-string">&quot;pal_efi_call_in_32bit_mode() efi_reg:\n&quot;</span>);
    DBG(<span class="enscript-string">&quot;  rcx: 0x%016llx\n&quot;</span>, efi_reg-&gt;rcx);
    DBG(<span class="enscript-string">&quot;  rdx: 0x%016llx\n&quot;</span>, efi_reg-&gt;rdx);
    DBG(<span class="enscript-string">&quot;   r8: 0x%016llx\n&quot;</span>, efi_reg-&gt;r8);
    DBG(<span class="enscript-string">&quot;   r9: 0x%016llx\n&quot;</span>, efi_reg-&gt;r9);
    DBG(<span class="enscript-string">&quot;  rax: 0x%016llx\n&quot;</span>, efi_reg-&gt;rax);

    DBG(<span class="enscript-string">&quot;pal_efi_call_in_32bit_mode() stack:\n&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PAL_DEBUG</span>
    size_t i;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; stack_contents_size; i += <span class="enscript-keyword">sizeof</span>(uint32_t)) {
	uint32_t *p = (uint32_t *) ((uintptr_t)stack_contents + i);
	DBG(<span class="enscript-string">&quot;  %p: 0x%08x\n&quot;</span>, p, *p);
    } 
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
    <span class="enscript-comment">/*
     * Ensure no interruptions.
     * Taking a spinlock for serialization is technically unnecessary
     * because the EFIRuntime kext should serialize.
     */</span>
    boolean_t istate = ml_set_interrupts_enabled(FALSE);
    simple_lock(&amp;pal_efi_lock);

    <span class="enscript-comment">/*
     * Switch to special page tables with the entire high kernel space
     * double-mapped into the bottom 4GB.
     *
     * NB: We assume that all data passed exchanged with RuntimeServices is
     * located in the 4GB of KVA based at VM_MIN_ADDRESS. In particular, kexts
     * loaded the basement (below VM_MIN_ADDRESS) cannot pass static data.
     * Kernel stack and heap space is OK.
     */</span>
    MARK_CPU_IDLE(cpu_number());
    pal_efi_saved_cr3 = get_cr3_raw();
    pal_efi_saved_cr0 = get_cr0();
    IDPML4[KERNEL_PML4_INDEX] = IdlePML4[KERNEL_PML4_INDEX];
    IDPML4[0]		      = IdlePML4[KERNEL_PML4_INDEX];
    clear_ts();
    set_cr3_raw((uint64_t) ID_MAP_VTOP(IDPML4));
    
    swapgs();			<span class="enscript-comment">/* Save kernel's GS base */</span>

    <span class="enscript-comment">/* Set segment state ready for compatibility mode */</span>
    set_gs(NULL_SEG);
    set_fs(NULL_SEG);
    set_es(KERNEL_DS);
    set_ds(KERNEL_DS);
    set_ss(KERNEL_DS);

    _pal_efi_call_in_32bit_mode_asm(func,
                                    efi_reg,
                                    stack_contents,
                                    stack_contents_size);
    
    <span class="enscript-comment">/* Restore NULL segment state */</span>
    set_ss(NULL_SEG);
    set_es(NULL_SEG);
    set_ds(NULL_SEG);

    swapgs();			<span class="enscript-comment">/* Restore kernel's GS base */</span>

    <span class="enscript-comment">/* Restore the 64-bit user GS base we just destroyed */</span>
    wrmsr64(MSR_IA32_KERNEL_GS_BASE,
	    current_cpu_datap()-&gt;cpu_uber.cu_user_gs_base);

    <span class="enscript-comment">/* End of mapping games */</span>
    set_cr3_raw(pal_efi_saved_cr3);
    set_cr0(pal_efi_saved_cr0);
    MARK_CPU_ACTIVE(cpu_number());
    
    simple_unlock(&amp;pal_efi_lock);
    ml_set_interrupts_enabled(istate);
#<span class="enscript-reference">else</span>
    _pal_efi_call_in_32bit_mode_asm(func,
                                    efi_reg,
                                    stack_contents,
                                    stack_contents_size);
#<span class="enscript-reference">endif</span>

    *efi_status = (uint32_t)efi_reg-&gt;rax;
    DBG(<span class="enscript-string">&quot;pal_efi_call_in_32bit_mode() efi_status: 0x%x\n&quot;</span>, *efi_status);

    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/* wind-back a syscall instruction */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_syscall_restart</span>(thread_t thread __unused, x86_saved_state_t *state)
{
	<span class="enscript-comment">/* work out which flavour thread it is */</span>
	<span class="enscript-keyword">if</span>( is_saved_state32(state) )
	{
		x86_saved_state32_t	*regs32;
		regs32 = saved_state32(state);

		<span class="enscript-keyword">if</span> (regs32-&gt;cs == SYSENTER_CS || regs32-&gt;cs == SYSENTER_TF_CS)
			regs32-&gt;eip -= 5;
		<span class="enscript-keyword">else</span>
			regs32-&gt;eip -= 2;
	}
	<span class="enscript-keyword">else</span>
	{
		x86_saved_state64_t	*regs64;

		assert( is_saved_state64(state) );
		regs64 = saved_state64(state);

		<span class="enscript-comment">/* Only one instruction for 64-bit threads */</span>
		regs64-&gt;isf.rip -= 2;
	}

}

<span class="enscript-comment">/* Helper function to put the machine to sleep (or shutdown) */</span>

boolean_t
<span class="enscript-function-name">pal_machine_sleep</span>(uint8_t type_a __unused, uint8_t type_b __unused, uint32_t bit_position __unused, 
		uint32_t disable_mask __unused, uint32_t enable_mask __unused)
{
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/* shouldn't be used on native */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_get_kern_regs</span>( x86_saved_state_t *state )
{
	panic( <span class="enscript-string">&quot;pal_get_kern_regs called. state %p\n&quot;</span>, state );
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pal_preemption_assert</span>(<span class="enscript-type">void</span>)
{
}
</pre>
<hr />
</body></html>