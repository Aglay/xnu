<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>acpi.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">acpi.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_data.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MTRR</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mtrr.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/hv_support.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_VMX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx/vmx_cpu.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/ucode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/acpi.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/lapic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/serial_io.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_check.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tsc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/serial_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	acpi_sleep_cpu(acpi_sleep_callback, <span class="enscript-type">void</span> * refcon);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	acpi_wake_prot(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">IOCPURunPlatformQuiesceActions</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">IOCPURunPlatformActiveActions</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">IOCPURunPlatformHaltRestartActions</span>(uint32_t message);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> 	fpinit(<span class="enscript-type">void</span>);

vm_offset_t
<span class="enscript-function-name">acpi_install_wake_handler</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>
	install_real_mode_bootstrap(acpi_wake_prot);
	<span class="enscript-keyword">return</span> REAL_MODE_BOOTSTRAP_OFFSET;
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		save_kdebug_enable = 0;
<span class="enscript-type">static</span> uint64_t		acpi_sleep_abstime;
<span class="enscript-type">static</span> uint64_t		acpi_idle_abstime;
<span class="enscript-type">static</span> uint64_t		acpi_wake_abstime, acpi_wake_postrebase_abstime;
boolean_t		deep_idle_rebase = TRUE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
<span class="enscript-type">struct</span> acpi_hibernate_callback_data {
	acpi_sleep_callback func;
	<span class="enscript-type">void</span> *refcon;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> acpi_hibernate_callback_data acpi_hibernate_callback_data_t;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">acpi_hibernate</span>(<span class="enscript-type">void</span> *refcon)
{
	uint32_t mode;

	acpi_hibernate_callback_data_t *data =
		(acpi_hibernate_callback_data_t *)refcon;

	<span class="enscript-keyword">if</span> (current_cpu_datap()-&gt;cpu_hibernate) 
	{
		mode = hibernate_write_image();

		<span class="enscript-keyword">if</span>( mode == kIOHibernatePostWriteHalt )
		{
			<span class="enscript-comment">// off
</span>			HIBLOG(<span class="enscript-string">&quot;power off\n&quot;</span>);
			IOCPURunPlatformHaltRestartActions(kPEHaltCPU);
			<span class="enscript-keyword">if</span> (PE_halt_restart) (*PE_halt_restart)(kPEHaltCPU);
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( mode == kIOHibernatePostWriteRestart )
		{
			<span class="enscript-comment">// restart
</span>			HIBLOG(<span class="enscript-string">&quot;restart\n&quot;</span>);
			IOCPURunPlatformHaltRestartActions(kPERestartCPU);
			<span class="enscript-keyword">if</span> (PE_halt_restart) (*PE_halt_restart)(kPERestartCPU);
		}
		<span class="enscript-keyword">else</span>
		{
			<span class="enscript-comment">// sleep
</span>			HIBLOG(<span class="enscript-string">&quot;sleep\n&quot;</span>);
	
			<span class="enscript-comment">// should we come back via regular wake, set the state in memory.
</span>			cpu_datap(0)-&gt;cpu_hibernate = 0;			
		}

	}
	kdebug_enable = 0;

	IOCPURunPlatformQuiesceActions();

	acpi_sleep_abstime = mach_absolute_time();

	(data-&gt;func)(data-&gt;refcon);

	<span class="enscript-comment">/* should never get here! */</span>
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SLEEP */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			slave_pstart(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			hibernate_rebuild_vm_structs(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span>	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		wake_nkdbufs;

<span class="enscript-type">void</span>
<span class="enscript-function-name">acpi_sleep_kernel</span>(acpi_sleep_callback func, <span class="enscript-type">void</span> *refcon)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	acpi_hibernate_callback_data_t data;
#<span class="enscript-reference">endif</span>
	boolean_t did_hibernate;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	cpu;
	kern_return_t	rc;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	my_cpu;
	uint64_t	start;
	uint64_t	elapsed = 0;
	uint64_t	elapsed_trace_start = 0;

	kprintf(<span class="enscript-string">&quot;acpi_sleep_kernel hib=%d, cpu=%d\n&quot;</span>,
			current_cpu_datap()-&gt;cpu_hibernate, cpu_number());

    	<span class="enscript-comment">/* Get all CPUs to be in the &quot;off&quot; state */</span>
    	my_cpu = cpu_number();
	<span class="enscript-keyword">for</span> (cpu = 0; cpu &lt; real_ncpus; cpu += 1) {
	    	<span class="enscript-keyword">if</span> (cpu == my_cpu)
			<span class="enscript-keyword">continue</span>;
		rc = pmCPUExitHaltToOff(cpu);
		<span class="enscript-keyword">if</span> (rc != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;Error %d trying to transition CPU %d to OFF&quot;</span>,
			      rc, cpu);
	}

	<span class="enscript-comment">/* shutdown local APIC before passing control to firmware */</span>
	lapic_shutdown();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	data.func = func;
	data.refcon = refcon;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Save power management timer state */</span>
	pmTimerSave();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
	<span class="enscript-comment">/* Notify hypervisor that we are about to sleep */</span>
	hv_suspend();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_VMX</span>
	<span class="enscript-comment">/* 
	 * Turn off VT, otherwise switching to legacy mode will fail
	 */</span>
	vmx_suspend();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Enable FPU/SIMD unit for potential hibernate acceleration
	 */</span>
	clear_ts(); 

	KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 0) | DBG_FUNC_START, 0, 0, 0, 0, 0);

	save_kdebug_enable = kdebug_enable;
	kdebug_enable = 0;

	acpi_sleep_abstime = mach_absolute_time();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>
	<span class="enscript-comment">/*
	 * Save master CPU state and sleep platform.
	 * Will not return until platform is woken up,
	 * or if sleep failed.
	 */</span>
	uint64_t old_cr3 = x86_64_pre_sleep();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	acpi_sleep_cpu(acpi_hibernate, &amp;data);
#<span class="enscript-reference">else</span>
	acpi_sleep_cpu(func, refcon);
#<span class="enscript-reference">endif</span>

	start = mach_absolute_time();

	x86_64_post_sleep(old_cr3);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SLEEP */</span>

	<span class="enscript-comment">/* Reset UART if kprintf is enabled.
	 * However kprintf should not be used before rtc_sleep_wakeup()
	 * for compatibility with firewire kprintf.
	 */</span>

	<span class="enscript-keyword">if</span> (FALSE == disable_serial_output)
		pal_serial_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	<span class="enscript-keyword">if</span> (current_cpu_datap()-&gt;cpu_hibernate) {
		did_hibernate = TRUE;

	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> 
	{
		did_hibernate = FALSE;
	}

	<span class="enscript-comment">/* Re-enable mode (including 64-bit if applicable) */</span>
	cpu_mode_init(current_cpu_datap());

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
	<span class="enscript-comment">/* Re-enable machine check handling */</span>
	mca_cpu_init();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MTRR</span>
	<span class="enscript-comment">/* restore MTRR settings */</span>
	mtrr_update_cpu();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* update CPU microcode */</span>
	ucode_update_wake();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_VMX</span>
	<span class="enscript-comment">/* 
	 * Restore VT mode
	 */</span>
	vmx_resume();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MTRR</span>
	<span class="enscript-comment">/* set up PAT following boot processor power up */</span>
	pat_init();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Go through all of the CPUs and mark them as requiring
	 * a full restart.
	 */</span>
	pmMarkAllCPUsOff();


	<span class="enscript-comment">/* re-enable and re-init local apic (prior to starting timers) */</span>
	<span class="enscript-keyword">if</span> (lapic_probe())
		lapic_configure();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	hibernate_rebuild_vm_structs();
#<span class="enscript-reference">endif</span>

	elapsed += mach_absolute_time() - start;
	acpi_wake_abstime = mach_absolute_time();

	<span class="enscript-comment">/* let the realtime clock reset */</span>
	rtc_sleep_wakeup(acpi_sleep_abstime);
	acpi_wake_postrebase_abstime = mach_absolute_time();
	assert(mach_absolute_time() &gt;= acpi_sleep_abstime);

	kdebug_enable = save_kdebug_enable;

	<span class="enscript-keyword">if</span> (kdebug_enable == 0) {
		<span class="enscript-keyword">if</span> (wake_nkdbufs) {
			start = mach_absolute_time();
			start_kern_tracing(wake_nkdbufs, TRUE);
			elapsed_trace_start += mach_absolute_time() - start;
		}
	}
	start = mach_absolute_time();

	<span class="enscript-comment">/* Reconfigure FP/SIMD unit */</span>
	init_fpu();
	clear_ts();

	IOCPURunPlatformActiveActions();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	<span class="enscript-keyword">if</span> (did_hibernate) {
		elapsed += mach_absolute_time() - start;
		
		KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 2) | DBG_FUNC_START, elapsed, elapsed_trace_start, 0, 0, 0);
		hibernate_machine_init();
		KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 2) | DBG_FUNC_END, 0, 0, 0, 0, 0);

		current_cpu_datap()-&gt;cpu_hibernate = 0;

		KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 0) | DBG_FUNC_END, 0, 0, 0, 0, 0);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>
		KERNEL_DEBUG_CONSTANT(IOKDBG_CODE(DBG_HIBERNATE, 0) | DBG_FUNC_END, 0, 0, 0, 0, 0);

	<span class="enscript-comment">/* Restore power management register state */</span>
	pmCPUMarkRunning(current_cpu_datap());

	<span class="enscript-comment">/* Restore power management timer state */</span>
	pmTimerRestore();

	<span class="enscript-comment">/* Restart timer interrupts */</span>
	rtc_timer_start();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>

	kprintf(<span class="enscript-string">&quot;ret from acpi_sleep_cpu hib=%d\n&quot;</span>, did_hibernate);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>
	<span class="enscript-comment">/* Becase we don't save the bootstrap page, and we share it
	 * between sleep and mp slave init, we need to recreate it 
	 * after coming back from sleep or hibernate */</span>
	install_real_mode_bootstrap(slave_pstart);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * acpi_idle_kernel is called by the ACPI Platform kext to request the kernel
 * to idle the boot processor in the deepest C-state for S0 sleep. All slave
 * processors are expected already to have been offlined in the deepest C-state.
 *
 * The contract with ACPI is that although the kernel is called with interrupts
 * disabled, interrupts may need to be re-enabled to dismiss any pending timer
 * interrupt. However, the callback function will be called once this has
 * occurred and interrupts are guaranteed to be disabled at that time,
 * and to remain disabled during C-state entry, exit (wake) and return
 * from acpi_idle_kernel.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">acpi_idle_kernel</span>(acpi_sleep_callback func, <span class="enscript-type">void</span> *refcon)
{
	boolean_t	istate = ml_get_interrupts_enabled();
	
	kprintf(<span class="enscript-string">&quot;acpi_idle_kernel, cpu=%d, interrupts %s\n&quot;</span>,
		cpu_number(), istate ? <span class="enscript-string">&quot;enabled&quot;</span> : <span class="enscript-string">&quot;disabled&quot;</span>);

	assert(cpu_number() == master_cpu);

	<span class="enscript-comment">/*
	 * Effectively set the boot cpu offline.
	 * This will stop further deadlines being set.
	 */</span>
	cpu_datap(master_cpu)-&gt;cpu_running = FALSE;

	<span class="enscript-comment">/* Cancel any pending deadline */</span>
	setPop(0);
	<span class="enscript-keyword">while</span> (lapic_is_interrupting(LAPIC_TIMER_VECTOR)) {
		(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(TRUE);
		setPop(0);
		ml_set_interrupts_enabled(FALSE);
	}

	<span class="enscript-comment">/*
	 * Call back to caller to indicate that interrupts will remain
	 * disabled while we deep idle, wake and return.
	 */</span> 
	func(refcon);

	acpi_idle_abstime = mach_absolute_time();

	KERNEL_DEBUG_CONSTANT(
		MACHDBG_CODE(DBG_MACH_SCHED, MACH_DEEP_IDLE) | DBG_FUNC_START,
		acpi_idle_abstime, deep_idle_rebase, 0, 0, 0);

	<span class="enscript-comment">/*
	 * Disable tracing during S0-sleep
	 * unless overridden by sysctl -w tsc.deep_idle_rebase=0
	 */</span>
	<span class="enscript-keyword">if</span> (deep_idle_rebase) {
		save_kdebug_enable = kdebug_enable;
		kdebug_enable = 0;
	}

	<span class="enscript-comment">/*
	 * Call into power-management to enter the lowest C-state.
	 * Note when called on the boot processor this routine will
	 * return directly when awoken.
	 */</span>
	pmCPUHalt(PM_HALT_SLEEP);

	<span class="enscript-comment">/*
	 * Get wakeup time relative to the TSC which has progressed.
	 * Then rebase nanotime to reflect time not progressing over sleep
	 * - unless overriden so that tracing can occur during deep_idle.
	 */</span> 
	acpi_wake_abstime = mach_absolute_time();
	<span class="enscript-keyword">if</span> (deep_idle_rebase) {
		rtc_sleep_wakeup(acpi_idle_abstime);
		kdebug_enable = save_kdebug_enable;
	}
	acpi_wake_postrebase_abstime = mach_absolute_time();
	assert(mach_absolute_time() &gt;= acpi_idle_abstime);
	cpu_datap(master_cpu)-&gt;cpu_running = TRUE;

	KERNEL_DEBUG_CONSTANT(
		MACHDBG_CODE(DBG_MACH_SCHED, MACH_DEEP_IDLE) | DBG_FUNC_END,
		acpi_wake_abstime, acpi_wake_abstime - acpi_idle_abstime, 0, 0, 0);
 
	<span class="enscript-comment">/* Like S3 sleep, turn on tracing if trace_wake boot-arg is present */</span> 
	<span class="enscript-keyword">if</span> (kdebug_enable == 0) {
		<span class="enscript-keyword">if</span> (wake_nkdbufs)
			start_kern_tracing(wake_nkdbufs, TRUE);
	}

	IOCPURunPlatformActiveActions();

	<span class="enscript-comment">/* Restart timer interrupts */</span>
	rtc_timer_start();
}

<span class="enscript-type">extern</span> <span class="enscript-type">char</span> real_mode_bootstrap_end[];
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> real_mode_bootstrap_base[];

<span class="enscript-type">void</span>
<span class="enscript-function-name">install_real_mode_bootstrap</span>(<span class="enscript-type">void</span> *prot_entry)
{
	<span class="enscript-comment">/*
	 * Copy the boot entry code to the real-mode vector area REAL_MODE_BOOTSTRAP_OFFSET.
	 * This is in page 1 which has been reserved for this purpose by
	 * machine_startup() from the boot processor.
	 * The slave boot code is responsible for switching to protected
	 * mode and then jumping to the common startup, _start().
	 */</span>
	bcopy_phys(kvtophys((vm_offset_t) real_mode_bootstrap_base),
		   (addr64_t) REAL_MODE_BOOTSTRAP_OFFSET,
		   real_mode_bootstrap_end-real_mode_bootstrap_base);

	<span class="enscript-comment">/*
	 * Set the location at the base of the stack to point to the
	 * common startup entry.
	 */</span>
	ml_phys_write_word(
		PROT_MODE_START+REAL_MODE_BOOTSTRAP_OFFSET,
		(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)kvtophys((vm_offset_t)prot_entry));
	
	<span class="enscript-comment">/* Flush caches */</span>
	__asm__(<span class="enscript-string">&quot;wbinvd&quot;</span>);
}

boolean_t
<span class="enscript-function-name">ml_recent_wake</span>(<span class="enscript-type">void</span>) {
	uint64_t ctime = mach_absolute_time();
	assert(ctime &gt; acpi_wake_postrebase_abstime);
	<span class="enscript-keyword">return</span> ((ctime - acpi_wake_postrebase_abstime) &lt; 5 * NSEC_PER_SEC);
}
</pre>
<hr />
</body></html>