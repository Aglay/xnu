<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>bsd_i386.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">bsd_i386.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MACH_BSD</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_rt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_traps.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/syscall_sw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/eflags.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/user_ldt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machdep_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmparam.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/trap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/seg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/syscall_sw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;../bsd/sys/sysent.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	mach_kauth_cred_uthread_update(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">throttle_lowpri_io</span>(<span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> * <span class="enscript-function-name">find_user_regs</span>(thread_t);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_msr_exportmask</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_msr_nbits</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_msr_rbits</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * thread_userstack:
 *
 * Return the user stack pointer from the machine
 * dependent thread state info.
 */</span>
kern_return_t
<span class="enscript-function-name">thread_userstack</span>(
    __unused thread_t   thread,
    <span class="enscript-type">int</span>                 flavor,
    thread_state_t      tstate,
    __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>        count,
    mach_vm_offset_t    *user_stack,
	<span class="enscript-type">int</span>					*customstack
)
{
	<span class="enscript-keyword">if</span> (customstack)
		*customstack = 0;

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">x86_THREAD_STATE32</span>:
		{
			x86_thread_state32_t *state25;

			state25 = (x86_thread_state32_t *) tstate;

			<span class="enscript-keyword">if</span> (state25-&gt;esp) {
				*user_stack = state25-&gt;esp;
				<span class="enscript-keyword">if</span> (customstack)
					*customstack = 1;
			} <span class="enscript-keyword">else</span> {
				*user_stack = VM_USRSTACK32;
				<span class="enscript-keyword">if</span> (customstack)
					*customstack = 0;
			}
			<span class="enscript-keyword">break</span>;
		}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">x86_THREAD_STATE64</span>:
		{
			x86_thread_state64_t *state25;

			state25 = (x86_thread_state64_t *) tstate;

			<span class="enscript-keyword">if</span> (state25-&gt;rsp) {
				*user_stack = state25-&gt;rsp;
				<span class="enscript-keyword">if</span> (customstack)
					*customstack = 1;
			} <span class="enscript-keyword">else</span> {
				*user_stack = VM_USRSTACK64;
				<span class="enscript-keyword">if</span> (customstack)
					*customstack = 0;
			}
			<span class="enscript-keyword">break</span>;
		}

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * thread_userstackdefault:
 *
 * Return the default stack location for the
 * thread, if otherwise unknown.
 */</span>
kern_return_t
<span class="enscript-function-name">thread_userstackdefault</span>(
	thread_t thread,
	mach_vm_offset_t *default_user_stack)
{
	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		*default_user_stack = VM_USRSTACK64;
	} <span class="enscript-keyword">else</span> {
		*default_user_stack = VM_USRSTACK32;
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">thread_entrypoint</span>(
    __unused thread_t   thread,
    <span class="enscript-type">int</span>                 flavor,
    thread_state_t      tstate,
    __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>        count,
    mach_vm_offset_t    *entry_point
)
{ 
	<span class="enscript-comment">/*
	 * Set a default.
	 */</span>
	<span class="enscript-keyword">if</span> (*entry_point == 0)
		*entry_point = VM_MIN_ADDRESS;

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">x86_THREAD_STATE32</span>:
		{
			x86_thread_state32_t *state25;

			state25 = (i386_thread_state_t *) tstate;
			*entry_point = state25-&gt;eip ? state25-&gt;eip: VM_MIN_ADDRESS;
			<span class="enscript-keyword">break</span>;
		}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">x86_THREAD_STATE64</span>:
		{
			x86_thread_state64_t *state25;

			state25 = (x86_thread_state64_t *) tstate;
			*entry_point = state25-&gt;rip ? state25-&gt;rip: VM_MIN_ADDRESS64;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/* 
 * FIXME - thread_set_child
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">thread_set_child</span>(thread_t child, <span class="enscript-type">int</span> pid);
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_set_child</span>(thread_t child, <span class="enscript-type">int</span> pid)
{
	pal_register_cache_state(child, DIRTY);

	<span class="enscript-keyword">if</span> (thread_is_64bit(child)) {
		x86_saved_state64_t	*iss64;

		iss64 = USER_REGS64(child);

		iss64-&gt;rax = pid;
		iss64-&gt;rdx = 1;
		iss64-&gt;isf.rflags &amp;= ~EFL_CF;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*iss32;

		iss32 = USER_REGS32(child);

		iss32-&gt;eax = pid;
		iss32-&gt;edx = 1;
		iss32-&gt;efl &amp;= ~EFL_CF;
	}
}



<span class="enscript-comment">/*
 * System Call handling code
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">long</span> <span class="enscript-function-name">fuword</span>(vm_offset_t);



<span class="enscript-type">void</span>
<span class="enscript-function-name">machdep_syscall</span>(x86_saved_state_t *state)
{
	<span class="enscript-type">int</span>			args[machdep_call_count];
	<span class="enscript-type">int</span>			trapno;
	<span class="enscript-type">int</span>			nargs;
	<span class="enscript-type">const</span> machdep_call_t	*entry;
	x86_saved_state32_t	*regs;

	assert(is_saved_state32(state));
	regs = saved_state32(state);
    
	trapno = regs-&gt;eax;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_TRACE</span>
	kprintf(<span class="enscript-string">&quot;machdep_syscall(0x%08x) code=%d\n&quot;</span>, regs, trapno);
#<span class="enscript-reference">endif</span>

	DEBUG_KPRINT_SYSCALL_MDEP(
		<span class="enscript-string">&quot;machdep_syscall: trapno=%d\n&quot;</span>, trapno);

	<span class="enscript-keyword">if</span> (trapno &lt; 0 || trapno &gt;= machdep_call_count) {
		regs-&gt;eax = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)kern_invalid(NULL);

		thread_exception_return();
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	entry = &amp;machdep_call_table[trapno];
	nargs = entry-&gt;nargs;

	<span class="enscript-keyword">if</span> (nargs != 0) {
		<span class="enscript-keyword">if</span> (copyin((user_addr_t) regs-&gt;uesp + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>),
				(<span class="enscript-type">char</span> *) args, (nargs * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)))) {
			regs-&gt;eax = KERN_INVALID_ADDRESS;

			thread_exception_return();
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}
	<span class="enscript-keyword">switch</span> (nargs) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		regs-&gt;eax = (*entry-&gt;routine.args_0)();
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		regs-&gt;eax = (*entry-&gt;routine.args_1)(args[0]);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		regs-&gt;eax = (*entry-&gt;routine.args_2)(args[0],args[1]);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		<span class="enscript-keyword">if</span> (!entry-&gt;bsd_style)
			regs-&gt;eax = (*entry-&gt;routine.args_3)(args[0],args[1],args[2]);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span>	error;
			uint32_t	rval;

			error = (*entry-&gt;routine.args_bsd_3)(&amp;rval, args[0], args[1], args[2]);
			<span class="enscript-keyword">if</span> (error) {
				regs-&gt;eax = error;
				regs-&gt;efl |= EFL_CF;	<span class="enscript-comment">/* carry bit */</span>
			} <span class="enscript-keyword">else</span> {
				regs-&gt;eax = rval;
				regs-&gt;efl &amp;= ~EFL_CF;
			}
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		regs-&gt;eax = (*entry-&gt;routine.args_4)(args[0], args[1], args[2], args[3]);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;machdep_syscall: too many args&quot;</span>);
	}

	DEBUG_KPRINT_SYSCALL_MDEP(<span class="enscript-string">&quot;machdep_syscall: retval=%u\n&quot;</span>, regs-&gt;eax);

	throttle_lowpri_io(1);

	thread_exception_return();
	<span class="enscript-comment">/* NOTREACHED */</span>
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">machdep_syscall64</span>(x86_saved_state_t *state)
{
	<span class="enscript-type">int</span>			trapno;
	<span class="enscript-type">const</span> machdep_call_t	*entry;
	x86_saved_state64_t	*regs;

	assert(is_saved_state64(state));
	regs = saved_state64(state);
    
	trapno = (<span class="enscript-type">int</span>)(regs-&gt;rax &amp; SYSCALL_NUMBER_MASK);

	DEBUG_KPRINT_SYSCALL_MDEP(
		<span class="enscript-string">&quot;machdep_syscall64: trapno=%d\n&quot;</span>, trapno);

	<span class="enscript-keyword">if</span> (trapno &lt; 0 || trapno &gt;= machdep_call_count) {
		regs-&gt;rax = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)kern_invalid(NULL);

		thread_exception_return();
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	entry = &amp;machdep_call_table64[trapno];

	<span class="enscript-keyword">switch</span> (entry-&gt;nargs) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		regs-&gt;rax = (*entry-&gt;routine.args_0)();
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		regs-&gt;rax = (*entry-&gt;routine.args64_1)(regs-&gt;rdi);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		regs-&gt;rax = (*entry-&gt;routine.args64_2)(regs-&gt;rdi, regs-&gt;rsi);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;machdep_syscall64: too many args&quot;</span>);
	}

	DEBUG_KPRINT_SYSCALL_MDEP(<span class="enscript-string">&quot;machdep_syscall: retval=%llu\n&quot;</span>, regs-&gt;rax);

	throttle_lowpri_io(1);

	thread_exception_return();
	<span class="enscript-comment">/* NOTREACHED */</span>
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_BSD */</span>


<span class="enscript-type">typedef</span> <span class="enscript-function-name">kern_return_t</span> (*mach_call_t)(<span class="enscript-type">void</span> *);

<span class="enscript-type">struct</span> mach_call_args {
	syscall_arg_t arg1;
	syscall_arg_t arg2;
	syscall_arg_t arg3;
	syscall_arg_t arg4;
	syscall_arg_t arg5;
	syscall_arg_t arg6;
	syscall_arg_t arg7;
	syscall_arg_t arg8;
	syscall_arg_t arg9;
};

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">mach_call_arg_munger32</span>(uint32_t sp, <span class="enscript-type">struct</span> mach_call_args *args, <span class="enscript-type">const</span> mach_trap_t *trapp);


<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">mach_call_arg_munger32</span>(uint32_t sp, <span class="enscript-type">struct</span> mach_call_args *args, <span class="enscript-type">const</span> mach_trap_t *trapp)
{
	<span class="enscript-keyword">if</span> (copyin((user_addr_t)(sp + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)), (<span class="enscript-type">char</span> *)args, trapp-&gt;mach_trap_u32_words * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_REQUIRES_U32_MUNGING</span>
	trapp-&gt;mach_trap_arg_munge32(args);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">U32</span> <span class="enscript-variable-name">mach</span> <span class="enscript-variable-name">traps</span> <span class="enscript-variable-name">on</span> <span class="enscript-variable-name">x86_64</span> <span class="enscript-variable-name">kernel</span> <span class="enscript-variable-name">requires</span> <span class="enscript-variable-name">munging</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


__private_extern__ <span class="enscript-type">void</span> mach_call_munger(x86_saved_state_t *state);

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *mach_syscall_name_table[];

<span class="enscript-type">void</span>
<span class="enscript-function-name">mach_call_munger</span>(x86_saved_state_t *state)
{
	<span class="enscript-type">int</span> argc;
	<span class="enscript-type">int</span> call_number;
	mach_call_t mach_call;
	kern_return_t retval;
	<span class="enscript-type">struct</span> mach_call_args args = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	x86_saved_state32_t	*regs;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
	<span class="enscript-type">struct</span> uthread *ut = get_bsdthread_info(current_thread());

	uthread_reset_proc_refcount(ut);
#<span class="enscript-reference">endif</span>

	assert(is_saved_state32(state));
	regs = saved_state32(state);

	call_number = -(regs-&gt;eax);

	DEBUG_KPRINT_SYSCALL_MACH(
		<span class="enscript-string">&quot;mach_call_munger: code=%d(%s)\n&quot;</span>,
		call_number, mach_syscall_name_table[call_number]);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_TRACE</span>
	kprintf(<span class="enscript-string">&quot;mach_call_munger(0x%08x) code=%d\n&quot;</span>, regs, call_number);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (call_number &lt; 0 || call_number &gt;= mach_trap_count) {
		i386_exception(EXC_SYSCALL, call_number, 1);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	mach_call = (mach_call_t)mach_trap_table[call_number].mach_trap_function;

	<span class="enscript-keyword">if</span> (mach_call == (mach_call_t)kern_invalid) {
		DEBUG_KPRINT_SYSCALL_MACH(
			<span class="enscript-string">&quot;mach_call_munger: kern_invalid 0x%x\n&quot;</span>, regs-&gt;eax);
		i386_exception(EXC_SYSCALL, call_number, 1);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	argc = mach_trap_table[call_number].mach_trap_arg_count;
	<span class="enscript-keyword">if</span> (argc) {
		retval = mach_call_arg_munger32(regs-&gt;uesp, &amp;args,  &amp;mach_trap_table[call_number]);
		<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS) {
			regs-&gt;eax = retval;

			DEBUG_KPRINT_SYSCALL_MACH(
				<span class="enscript-string">&quot;mach_call_munger: retval=0x%x\n&quot;</span>, retval);

			thread_exception_return();
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	mach_kauth_cred_uthread_update();
#<span class="enscript-reference">endif</span>

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
		MACHDBG_CODE(DBG_MACH_EXCP_SC, (call_number)) | DBG_FUNC_START,
		args.arg1, args.arg2, args.arg3, args.arg4, 0);

	retval = mach_call(&amp;args);

	DEBUG_KPRINT_SYSCALL_MACH(<span class="enscript-string">&quot;mach_call_munger: retval=0x%x\n&quot;</span>, retval);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
		MACHDBG_CODE(DBG_MACH_EXCP_SC,(call_number)) | DBG_FUNC_END,
		retval, 0, 0, 0, 0);

	regs-&gt;eax = retval;

	throttle_lowpri_io(1);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
	<span class="enscript-keyword">if</span> (__improbable(uthread_get_proc_refcount(ut) != 0)) {
		panic(<span class="enscript-string">&quot;system call returned with uu_proc_refcount != 0&quot;</span>);
	}
#<span class="enscript-reference">endif</span>

	thread_exception_return();
	<span class="enscript-comment">/* NOTREACHED */</span>
}


__private_extern__ <span class="enscript-type">void</span> mach_call_munger64(x86_saved_state_t *regs);

<span class="enscript-type">void</span>
<span class="enscript-function-name">mach_call_munger64</span>(x86_saved_state_t *state)
{
	<span class="enscript-type">int</span> call_number;
	<span class="enscript-type">int</span> argc;
	mach_call_t mach_call;
	<span class="enscript-type">struct</span> mach_call_args args = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	x86_saved_state64_t	*regs;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
	<span class="enscript-type">struct</span> uthread *ut = get_bsdthread_info(current_thread());

	uthread_reset_proc_refcount(ut);
#<span class="enscript-reference">endif</span>

	assert(is_saved_state64(state));
	regs = saved_state64(state);

	call_number = (<span class="enscript-type">int</span>)(regs-&gt;rax &amp; SYSCALL_NUMBER_MASK);

	DEBUG_KPRINT_SYSCALL_MACH(
		<span class="enscript-string">&quot;mach_call_munger64: code=%d(%s)\n&quot;</span>,
		call_number, mach_syscall_name_table[call_number]);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
		MACHDBG_CODE(DBG_MACH_EXCP_SC,(call_number)) | DBG_FUNC_START,
		regs-&gt;rdi, regs-&gt;rsi, regs-&gt;rdx, regs-&gt;r10, 0);
	
	<span class="enscript-keyword">if</span> (call_number &lt; 0 || call_number &gt;= mach_trap_count) {
	        i386_exception(EXC_SYSCALL, regs-&gt;rax, 1);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	mach_call = (mach_call_t)mach_trap_table[call_number].mach_trap_function;

	<span class="enscript-keyword">if</span> (mach_call == (mach_call_t)kern_invalid) {
	        i386_exception(EXC_SYSCALL, regs-&gt;rax, 1);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	argc = mach_trap_table[call_number].mach_trap_arg_count;
	<span class="enscript-keyword">if</span> (argc) {
		<span class="enscript-type">int</span> args_in_regs = MIN(6, argc);

		memcpy(&amp;args.arg1, &amp;regs-&gt;rdi, args_in_regs * <span class="enscript-keyword">sizeof</span>(syscall_arg_t));

		<span class="enscript-keyword">if</span> (argc &gt; 6) {
	        <span class="enscript-type">int</span> copyin_count;

			assert(argc &lt;= 9);
			copyin_count = (argc - 6) * (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(syscall_arg_t);

	        <span class="enscript-keyword">if</span> (copyin((user_addr_t)(regs-&gt;isf.rsp + <span class="enscript-keyword">sizeof</span>(user_addr_t)), (<span class="enscript-type">char</span> *)&amp;args.arg7, copyin_count)) {
		        regs-&gt;rax = KERN_INVALID_ARGUMENT;
			
				thread_exception_return();
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
		}
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	mach_kauth_cred_uthread_update();
#<span class="enscript-reference">endif</span>

	regs-&gt;rax = (uint64_t)mach_call((<span class="enscript-type">void</span> *)&amp;args);
	
	DEBUG_KPRINT_SYSCALL_MACH( <span class="enscript-string">&quot;mach_call_munger64: retval=0x%llx\n&quot;</span>, regs-&gt;rax);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
		MACHDBG_CODE(DBG_MACH_EXCP_SC,(call_number)) | DBG_FUNC_END, 
		regs-&gt;rax, 0, 0, 0, 0);

	throttle_lowpri_io(1);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
	<span class="enscript-keyword">if</span> (__improbable(uthread_get_proc_refcount(ut) != 0)) {
		panic(<span class="enscript-string">&quot;system call returned with uu_proc_refcount != 0&quot;</span>);
	}
#<span class="enscript-reference">endif</span>

	thread_exception_return();
	<span class="enscript-comment">/* NOTREACHED */</span>
}


<span class="enscript-comment">/*
 * thread_setuserstack:
 *
 * Sets the user stack pointer into the machine
 * dependent thread state info.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_setuserstack</span>(
	thread_t	thread,
	mach_vm_address_t	user_stack)
{
	pal_register_cache_state(thread, DIRTY);
	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		x86_saved_state64_t	*iss64;

		iss64 = USER_REGS64(thread);

		iss64-&gt;isf.rsp = (uint64_t)user_stack;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*iss32;

		iss32 = USER_REGS32(thread);

		iss32-&gt;uesp = CAST_DOWN_EXPLICIT(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, user_stack);
	}
}

<span class="enscript-comment">/*
 * thread_adjuserstack:
 *
 * Returns the adjusted user stack pointer from the machine
 * dependent thread state info.  Used for small (&lt;2G) deltas.
 */</span>
uint64_t
<span class="enscript-function-name">thread_adjuserstack</span>(
	thread_t	thread,
	<span class="enscript-type">int</span>		adjust)
{
	pal_register_cache_state(thread, DIRTY);
	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		x86_saved_state64_t	*iss64;

		iss64 = USER_REGS64(thread);

		iss64-&gt;isf.rsp += adjust;

		<span class="enscript-keyword">return</span> iss64-&gt;isf.rsp;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*iss32;

		iss32 = USER_REGS32(thread);

		iss32-&gt;uesp += adjust;

		<span class="enscript-keyword">return</span> CAST_USER_ADDR_T(iss32-&gt;uesp);
	}
}

<span class="enscript-comment">/*
 * thread_setentrypoint:
 *
 * Sets the user PC into the machine
 * dependent thread state info.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_setentrypoint</span>(thread_t thread, mach_vm_address_t entry)
{
	pal_register_cache_state(thread, DIRTY);
	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		x86_saved_state64_t	*iss64;

		iss64 = USER_REGS64(thread);

		iss64-&gt;isf.rip = (uint64_t)entry;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*iss32;

		iss32 = USER_REGS32(thread);

		iss32-&gt;eip = CAST_DOWN_EXPLICIT(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, entry);
	}
}


kern_return_t
<span class="enscript-function-name">thread_setsinglestep</span>(thread_t thread, <span class="enscript-type">int</span> on)
{
	pal_register_cache_state(thread, DIRTY);
	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		x86_saved_state64_t	*iss64;

		iss64 = USER_REGS64(thread);

		<span class="enscript-keyword">if</span> (on)
			iss64-&gt;isf.rflags |= EFL_TF;
		<span class="enscript-keyword">else</span>
			iss64-&gt;isf.rflags &amp;= ~EFL_TF;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*iss32;

		iss32 = USER_REGS32(thread);

		<span class="enscript-keyword">if</span> (on) {
			iss32-&gt;efl |= EFL_TF;
			<span class="enscript-comment">/* Ensure IRET */</span>
			<span class="enscript-keyword">if</span> (iss32-&gt;cs == SYSENTER_CS)
				iss32-&gt;cs = SYSENTER_TF_CS;
		}
		<span class="enscript-keyword">else</span>
			iss32-&gt;efl &amp;= ~EFL_TF;
	}
	
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}



<span class="enscript-comment">/* XXX this should be a struct savearea so that CHUD will work better on x86 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">find_user_regs</span>(thread_t thread)
{
	pal_register_cache_state(thread, DIRTY);
	<span class="enscript-keyword">return</span> USER_STATE(thread);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">get_user_regs</span>(thread_t th)
{
	pal_register_cache_state(th, DIRTY);
	<span class="enscript-keyword">return</span>(USER_STATE(th));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-comment">/*
 * DTrace would like to have a peek at the kernel interrupt state, if available.
 * Based on osfmk/chud/i386/chud_thread_i386.c:chudxnu_thread_get_state(), which see.
 */</span>
x86_saved_state_t *<span class="enscript-function-name">find_kern_regs</span>(thread_t);

x86_saved_state_t *
<span class="enscript-function-name">find_kern_regs</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span> (thread == current_thread() &amp;&amp; 
		NULL != current_cpu_datap()-&gt;cpu_int_state &amp;&amp;
		!(USER_STATE(thread) == current_cpu_datap()-&gt;cpu_int_state &amp;&amp;
		  current_cpu_datap()-&gt;cpu_interrupt_level == 1)) {

		<span class="enscript-keyword">return</span> current_cpu_datap()-&gt;cpu_int_state;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> NULL;
	}
}

vm_offset_t <span class="enscript-function-name">dtrace_get_cpu_int_stack_top</span>(<span class="enscript-type">void</span>);

vm_offset_t
<span class="enscript-function-name">dtrace_get_cpu_int_stack_top</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> current_cpu_datap()-&gt;cpu_int_stack_top;
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>