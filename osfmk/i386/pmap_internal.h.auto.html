<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pmap_internal.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pmap_internal.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_I386_PMAP_INTERNAL_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_I386_PMAP_INTERNAL_</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/bit_routines.h&gt;</span>

<span class="enscript-comment">/*
 * pmap locking
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_LOCK</span>(pmap) {		\
	simple_lock(&amp;(pmap)-&gt;lock);	\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_UNLOCK</span>(pmap) {			\
	simple_unlock(&amp;(pmap)-&gt;lock);		\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_UPDATE_TLBS</span>(pmap, s, e)			\
	pmap_flush_tlbs(pmap, s, e, 0, NULL)


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PMAP_DELAY_TLB_FLUSH</span>		0x01

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_UPDATE_TLBS_DELAYED</span>(pmap, s, e, c)			\
	pmap_flush_tlbs(pmap, s, e, PMAP_DELAY_TLB_FLUSH, c)


#<span class="enscript-reference">define</span>	<span class="enscript-function-name">iswired</span>(pte)	((pte) &amp; INTEL_PTE_WIRED)

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">PMAP_TRACES</span>
<span class="enscript-type">extern</span>	boolean_t	pmap_trace;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_TRACE</span>(x,a,b,c,d,e)						\
	<span class="enscript-keyword">if</span> (pmap_trace) {						\
		KERNEL_DEBUG_CONSTANT(x,a,b,c,d,e);			\
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_TRACE</span>(x,a,b,c,d,e)	KERNEL_DEBUG(x,a,b,c,d,e)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PMAP_TRACES */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_TRACE_CONSTANT</span>(x,a,b,c,d,e)				\
	KERNEL_DEBUG_CONSTANT(x,a,b,c,d,e);				\

kern_return_t	pmap_expand_pml4(
			pmap_t		map,
			vm_map_offset_t	v,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> options);

kern_return_t	pmap_expand_pdpt(
			pmap_t		map,
			vm_map_offset_t	v,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> options);

<span class="enscript-type">void</span>		phys_attribute_set(
			ppnum_t		phys,
			<span class="enscript-type">int</span>		bits);

<span class="enscript-type">void</span>		pmap_set_reference(
			ppnum_t pn);

boolean_t	phys_page_exists(
			ppnum_t pn);

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_flush_tlbs</span>(pmap_t, vm_map_offset_t, vm_map_offset_t, <span class="enscript-type">int</span>, pmap_flush_context *);

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_update_cache_attributes_locked</span>(ppnum_t, <span class="enscript-type">unsigned</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> boolean_t cpu_64bit;

<span class="enscript-comment">/*
 *	Private data structures.
 */</span>

<span class="enscript-comment">/*
 *	For each vm_page_t, there is a list of all currently
 *	valid virtual mappings of that page.  An entry is
 *	a pv_rooted_entry_t; the list is the pv_table.
 *
 *      N.B.  with the new combo rooted/hashed scheme it is
 *      only possibly to remove individual non-rooted entries
 *      if they are found via the hashed chains as there is no
 *      way to unlink the singly linked hashed entries if navigated to
 *      via the queue list off the rooted entries.  Think of it as
 *      hash/walk/pull, keeping track of the prev pointer while walking
 *      the singly linked hash list.  All of this is to save memory and
 *      keep both types of pv_entries as small as possible.
 */</span>

<span class="enscript-comment">/*

PV HASHING Changes - JK 1/2007

Pve's establish physical to virtual mappings.  These are used for aliasing of a 
physical page to (potentially many) virtual addresses within pmaps. In the
previous implementation the structure of the pv_entries (each 16 bytes in size) was

typedef struct pv_entry {
    struct pv_entry_t    next;
    pmap_t                    pmap;
    vm_map_offset_t   va;
} *pv_entry_t;

An initial array of these is created at boot time, one per physical page of
memory, indexed by the physical page number. Additionally, a pool of entries
is created from a pv_zone to be used as needed by pmap_enter() when it is
creating new mappings.  Originally, we kept this pool around because the code
in pmap_enter() was unable to block if it needed an entry and none were
available - we'd panic.  Some time ago I restructured the pmap_enter() code
so that for user pmaps it can block while zalloc'ing a pv structure and restart,
removing a panic from the code (in the case of the kernel pmap we cannot block
and still panic, so, we keep a separate hot pool for use only on kernel pmaps).
The pool has not been removed since there is a large performance gain keeping
freed pv's around for reuse and not suffering the overhead of zalloc for every
new pv we need.

As pmap_enter() created new mappings it linked the new pve's for them off the
fixed pv array for that ppn (off the next pointer).  These pve's are accessed
for several operations, one of them being address space teardown. In that case,
we basically do this

	for (every page/pte in the space) {
		calc pve_ptr from the ppn in the pte
		for (every pv in the list for the ppn) {
			if (this pv is for this pmap/vaddr) {
				do housekeeping
				unlink/free the pv
			}
		}
	}

The problem arose when we were running, say 8000 (or even 2000) apache or
other processes and one or all terminate. The list hanging off each pv array
entry could have thousands of entries.  We were continuously linearly searching
each of these lists as we stepped through the address space we were tearing
down.  Because of the locks we hold, likely taking a cache miss for each node,
and interrupt disabling for MP issues the system became completely unresponsive
for many seconds while we did this.

Realizing that pve's are accessed in two distinct ways (linearly running the
list by ppn for operations like pmap_page_protect and finding and
modifying/removing a single pve as part of pmap_enter processing) has led to
modifying the pve structures and databases.

There are now two types of pve structures.  A &quot;rooted&quot; structure which is
basically the original structure accessed in an array by ppn, and a ''hashed''
structure accessed on a hash list via a hash of [pmap, vaddr]. These have been
designed with the two goals of minimizing wired memory and making the lookup of
a ppn faster.  Since a vast majority of pages in the system are not aliased
and hence represented by a single pv entry I've kept the rooted entry size as
small as possible because there is one of these dedicated for every physical
page of memory.  The hashed pve's are larger due to the addition of the hash
link and the ppn entry needed for matching while running the hash list to find
the entry we are looking for.  This way, only systems that have lots of
aliasing (like 2000+ httpd procs) will pay the extra memory price. Both
structures have the same first three fields allowing some simplification in
the code.

They have these shapes

typedef struct pv_rooted_entry {
	queue_head_t		qlink;
        vm_map_offset_t		va;
	pmap_t			pmap;
} *pv_rooted_entry_t;


typedef struct pv_hashed_entry {
	queue_head_t		qlink;
	vm_map_offset_t		va;
	pmap_t			pmap;
	ppnum_t 		ppn;
	struct pv_hashed_entry *nexth;
} *pv_hashed_entry_t;

The main flow difference is that the code is now aware of the rooted entry and
the hashed entries.  Code that runs the pv list still starts with the rooted
entry and then continues down the qlink onto the hashed entries.  Code that is
looking up a specific pv entry first checks the rooted entry and then hashes
and runs the hash list for the match. The hash list lengths are much smaller
than the original pv lists that contained all aliases for the specific ppn.

*/</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> pv_rooted_entry {
	<span class="enscript-comment">/* first three entries must match pv_hashed_entry_t */</span>
        queue_head_t		qlink;
	vm_map_offset_t		va;	<span class="enscript-comment">/* virtual address for mapping */</span>
	pmap_t			pmap;	<span class="enscript-comment">/* pmap where mapping lies */</span>
} *pv_rooted_entry_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PV_ROOTED_ENTRY_NULL</span>	((pv_rooted_entry_t) 0)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> pv_hashed_entry {
	<span class="enscript-comment">/* first three entries must match pv_rooted_entry_t */</span>
	queue_head_t		qlink;
	vm_map_offset_t		va;
	pmap_t			pmap;
	ppnum_t			ppn;
	<span class="enscript-type">struct</span> pv_hashed_entry	*nexth;
} *pv_hashed_entry_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PV_HASHED_ENTRY_NULL</span> ((pv_hashed_entry_t)0)

<span class="enscript-comment">//#define PV_DEBUG 1   /* uncomment to enable some PV debugging code */
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PV_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHK_NPVHASH</span>() if(0 == npvhashmask) panic(<span class="enscript-string">&quot;npvhash uninitialized&quot;</span>);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHK_NPVHASH</span>(x)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPVHASHBUCKETS</span> (4096)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPVHASHMASK</span> ((NPVHASHBUCKETS) - 1) <span class="enscript-comment">/* MUST BE 2^N - 1 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PV_HASHED_LOW_WATER_MARK_DEFAULT</span> 5000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PV_HASHED_KERN_LOW_WATER_MARK_DEFAULT</span> 2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PV_HASHED_ALLOC_CHUNK_INITIAL</span> 2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PV_HASHED_KERN_ALLOC_CHUNK_INITIAL</span> 200

<span class="enscript-type">extern</span> <span class="enscript-type">volatile</span> uint32_t	mappingrecurse;
<span class="enscript-type">extern</span> uint32_t  pv_hashed_low_water_mark, pv_hashed_kern_low_water_mark;

<span class="enscript-comment">/*
 * PV hash locking
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCK_PV_HASH</span>(hash)	lock_hash_hash(hash)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNLOCK_PV_HASH</span>(hash)	unlock_hash_hash(hash)
<span class="enscript-type">extern</span> uint32_t npvhashmask;
<span class="enscript-type">extern</span> pv_hashed_entry_t	*pv_hash_table;  <span class="enscript-comment">/* hash lists */</span>
<span class="enscript-type">extern</span> pv_hashed_entry_t	pv_hashed_free_list;
<span class="enscript-type">extern</span> pv_hashed_entry_t	pv_hashed_kern_free_list;
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">extern</span>, pv_hashed_free_list_lock)
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">extern</span>, pv_hashed_kern_free_list_lock)
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">extern</span>, pv_hash_table_lock)
<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">extern</span>, phys_backup_lock)

<span class="enscript-type">extern</span> zone_t		pv_hashed_list_zone;	<span class="enscript-comment">/* zone of pv_hashed_entry
						 * structures */</span>

<span class="enscript-type">extern</span> uint32_t		pv_hashed_free_count;
<span class="enscript-type">extern</span> uint32_t		pv_hashed_kern_free_count;
<span class="enscript-comment">/*
 *	Each entry in the pv_head_table is locked by a bit in the
 *	pv_lock_table.  The lock bits are accessed by the address of
 *	the frame they lock.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pv_lock_table_size</span>(n)	(((n)+BYTE_SIZE-1)/BYTE_SIZE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pv_hash_lock_table_size</span>(n)  (((n)+BYTE_SIZE-1)/BYTE_SIZE)
<span class="enscript-type">extern</span> <span class="enscript-type">char</span>		*pv_lock_table;		<span class="enscript-comment">/* pointer to array of bits */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">char</span>		*pv_hash_lock_table;
<span class="enscript-type">extern</span> pv_rooted_entry_t pv_head_table;	<span class="enscript-comment">/* array of entries, one per page */</span>

<span class="enscript-type">extern</span> event_t mapping_replenish_event;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>	PV_HASHED_ALLOC(pv_hashed_entry_t *pvh_ep) {
	pmap_assert(*pvh_ep == PV_HASHED_ENTRY_NULL);
	simple_lock(&amp;pv_hashed_free_list_lock);
	<span class="enscript-comment">/* If the kernel reserved pool is low, let non-kernel mappings allocate
	 * synchronously, possibly subject to a throttle.
	 */</span>
	<span class="enscript-keyword">if</span> ((pv_hashed_kern_free_count &gt; pv_hashed_kern_low_water_mark) &amp;&amp; ((*pvh_ep = pv_hashed_free_list) != 0)) {
		pv_hashed_free_list = (pv_hashed_entry_t)(*pvh_ep)-&gt;qlink.next;
		pv_hashed_free_count--;
	}

	simple_unlock(&amp;pv_hashed_free_list_lock);

	<span class="enscript-keyword">if</span> (pv_hashed_free_count &lt;= pv_hashed_low_water_mark) {
		<span class="enscript-keyword">if</span> (!mappingrecurse &amp;&amp; hw_compare_and_store(0,1, &amp;mappingrecurse))
			thread_wakeup(&amp;mapping_replenish_event);
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>	PV_HASHED_FREE_LIST(pv_hashed_entry_t pvh_eh, pv_hashed_entry_t pvh_et, <span class="enscript-type">int</span> pv_cnt) {
	simple_lock(&amp;pv_hashed_free_list_lock);
	pvh_et-&gt;qlink.next = (queue_entry_t)pv_hashed_free_list;
	pv_hashed_free_list = pvh_eh;
	pv_hashed_free_count += pv_cnt;
	simple_unlock(&amp;pv_hashed_free_list_lock);
}

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> pmap_kern_reserve_alloc_stat;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>	PV_HASHED_KERN_ALLOC(pv_hashed_entry_t *pvh_e) {
	pmap_assert(*pvh_e == PV_HASHED_ENTRY_NULL);
	simple_lock(&amp;pv_hashed_kern_free_list_lock);

	<span class="enscript-keyword">if</span> ((*pvh_e = pv_hashed_kern_free_list) != 0) {
		pv_hashed_kern_free_list = (pv_hashed_entry_t)(*pvh_e)-&gt;qlink.next;
		pv_hashed_kern_free_count--;
		pmap_kern_reserve_alloc_stat++;
	}

	simple_unlock(&amp;pv_hashed_kern_free_list_lock);

	<span class="enscript-keyword">if</span> (pv_hashed_kern_free_count &lt; pv_hashed_kern_low_water_mark) {
		<span class="enscript-keyword">if</span> (!mappingrecurse &amp;&amp; hw_compare_and_store(0,1, &amp;mappingrecurse))
			thread_wakeup(&amp;mapping_replenish_event);
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>	PV_HASHED_KERN_FREE_LIST(pv_hashed_entry_t pvh_eh, pv_hashed_entry_t pvh_et, <span class="enscript-type">int</span> pv_cnt) {
	simple_lock(&amp;pv_hashed_kern_free_list_lock);
	pvh_et-&gt;qlink.next = (queue_entry_t)pv_hashed_kern_free_list;
	pv_hashed_kern_free_list = pvh_eh;
	pv_hashed_kern_free_count += pv_cnt;
	simple_unlock(&amp;pv_hashed_kern_free_list_lock);
}

<span class="enscript-type">extern</span> uint64_t pmap_pv_throttle_stat, pmap_pv_throttled_waiters;
<span class="enscript-type">extern</span> event_t pmap_user_pv_throttle_event;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">pmap_pv_throttle</span>(__unused pmap_t p) {
	pmap_assert(p != kernel_pmap);
	<span class="enscript-comment">/* Apply throttle on non-kernel mappings */</span>
	<span class="enscript-keyword">if</span> (pv_hashed_kern_free_count &lt; (pv_hashed_kern_low_water_mark / 2)) {
		pmap_pv_throttle_stat++;
		<span class="enscript-comment">/* This doesn't need to be strictly accurate, merely a hint
		 * to eliminate the timeout when the reserve is replenished.
		 */</span>
		pmap_pv_throttled_waiters++;
		assert_wait_timeout(&amp;pmap_user_pv_throttle_event, THREAD_UNINT, 1, 1000 * NSEC_PER_USEC);
		thread_block(THREAD_CONTINUE_NULL);
	}
}

<span class="enscript-comment">/*
 *	Index into pv_head table, its lock bits, and the modify/reference and managed bits
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">pa_index</span>(pa)		(i386_btop(pa))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ppn_to_pai</span>(ppn)		((int)ppn)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">pai_to_pvh</span>(pai)		(&amp;pv_head_table[pai])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">lock_pvh_pai</span>(pai)	bit_lock(pai, (void *)pv_lock_table)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">unlock_pvh_pai</span>(pai)	bit_unlock(pai, (void *)pv_lock_table)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pvhash</span>(idx)		(&amp;pv_hash_table[idx])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">lock_hash_hash</span>(hash)	bit_lock(hash, (void *)pv_hash_lock_table)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">unlock_hash_hash</span>(hash)	bit_unlock(hash, (void *)pv_hash_lock_table)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_MANAGED_PAGE</span>(x)				\
	((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(x) &lt;= last_managed_page &amp;&amp;	\
	 (pmap_phys_attributes[x] &amp; PHYS_MANAGED))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_INTERNAL_PAGE</span>(x)			\
	(IS_MANAGED_PAGE(x) &amp;&amp; (pmap_phys_attributes[x] &amp; PHYS_INTERNAL))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_REUSABLE_PAGE</span>(x)			\
	(IS_MANAGED_PAGE(x) &amp;&amp; (pmap_phys_attributes[x] &amp; PHYS_REUSABLE))

<span class="enscript-comment">/*
 *	Physical page attributes.  Copy bits from PTE definition.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_MODIFIED</span>	INTEL_PTE_MOD	<span class="enscript-comment">/* page modified */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_REFERENCED</span>	INTEL_PTE_REF	<span class="enscript-comment">/* page referenced */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_MANAGED</span>	INTEL_PTE_VALID <span class="enscript-comment">/* page is managed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_NOENCRYPT</span>	INTEL_PTE_USER	<span class="enscript-comment">/* no need to encrypt this page in the hibernation image */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_NCACHE</span>	INTEL_PTE_NCACHE
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_PTA</span>	INTEL_PTE_PTA
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_CACHEABILITY_MASK</span> (INTEL_PTE_PTA | INTEL_PTE_NCACHE)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_INTERNAL</span>	INTEL_PTE_WTHRU	<span class="enscript-comment">/* page from internal object */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_REUSABLE</span>	INTEL_PTE_WRITE <span class="enscript-comment">/* page is &quot;reusable&quot; */</span>

<span class="enscript-type">extern</span> boolean_t	pmap_disable_kheap_nx;
<span class="enscript-type">extern</span> boolean_t	pmap_disable_kstack_nx;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_EXPAND_OPTIONS_NONE</span> (0x0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_EXPAND_OPTIONS_NOWAIT</span> (PMAP_OPTIONS_NOWAIT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_EXPAND_OPTIONS_NOENTER</span> (PMAP_OPTIONS_NOENTER)

<span class="enscript-comment">/*
 *	Amount of virtual memory mapped by one
 *	page-directory entry.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PDE_MAPPED_SIZE</span>		(pdetova(1))


<span class="enscript-comment">/*
 *	Locking and TLB invalidation
 */</span>

<span class="enscript-comment">/*
 *	Locking Protocols: (changed 2/2007 JK)
 *
 *	There are two structures in the pmap module that need locking:
 *	the pmaps themselves, and the per-page pv_lists (which are locked
 *	by locking the pv_lock_table entry that corresponds to the pv_head
 *	for the list in question.)  Most routines want to lock a pmap and
 *	then do operations in it that require pv_list locking -- however
 *	pmap_remove_all and pmap_copy_on_write operate on a physical page
 *	basis and want to do the locking in the reverse order, i.e. lock
 *	a pv_list and then go through all the pmaps referenced by that list.
 *
 *      The system wide pmap lock has been removed. Now, paths take a lock
 *      on the pmap before changing its 'shape' and the reverse order lockers
 *      (coming in by phys ppn) take a lock on the corresponding pv and then
 *      retest to be sure nothing changed during the window before they locked
 *      and can then run up/down the pv lists holding the list lock. This also
 *      lets the pmap layer run (nearly completely) interrupt enabled, unlike
 *      previously.
 */</span>

<span class="enscript-comment">/*
 * PV locking
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCK_PVH</span>(index)	{		\
	mp_disable_preemption();	\
	lock_pvh_pai(index);		\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNLOCK_PVH</span>(index) {		\
	unlock_pvh_pai(index);		\
	mp_enable_preemption();		\
}

<span class="enscript-type">extern</span> uint64_t pde_mapped_size;

<span class="enscript-type">extern</span> <span class="enscript-type">char</span>		*pmap_phys_attributes;
<span class="enscript-type">extern</span> ppnum_t		last_managed_page;

<span class="enscript-type">extern</span> ppnum_t	lowest_lo;
<span class="enscript-type">extern</span> ppnum_t	lowest_hi;
<span class="enscript-type">extern</span> ppnum_t	highest_hi;

<span class="enscript-comment">/*
 * when spinning through pmap_remove
 * ensure that we don't spend too much
 * time with preemption disabled.
 * I'm setting the current threshold
 * to 20us
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_PREEMPTION_LATENCY_NS</span> 20000
<span class="enscript-type">extern</span> uint64_t max_preemption_latency_tsc;

<span class="enscript-comment">/* #define DEBUGINTERRUPTS 1  uncomment to ensure pmap callers have interrupts enabled */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEBUGINTERRUPTS</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_intr_assert</span>() {							\
	<span class="enscript-keyword">if</span> (processor_avail_count &gt; 1 &amp;&amp; !ml_get_interrupts_enabled())		\
		panic(<span class="enscript-string">&quot;pmap interrupt assert %s, %d&quot;</span>,__FILE__, __LINE__);	\
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_intr_assert</span>()
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 		nx_enabled;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    inuse_ptepages_count;

<span class="enscript-type">static</span> inline uint32_t
<span class="enscript-function-name">pvhashidx</span>(pmap_t pmap, vm_map_offset_t va)
{
	uint32_t hashidx = ((uint32_t)(uintptr_t)pmap ^
		((uint32_t)(va &gt;&gt; PAGE_SHIFT) &amp; 0xFFFFFFFF)) &amp;
	       npvhashmask;
	    <span class="enscript-keyword">return</span> hashidx;
}


<span class="enscript-comment">/*
 * unlinks the pv_hashed_entry_t pvh from the singly linked hash chain.
 * properly deals with the anchor.
 * must be called with the hash locked, does not unlock it
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> 
<span class="enscript-function-name">pmap_pvh_unlink</span>(pv_hashed_entry_t pvh)
{
	pv_hashed_entry_t	curh;
	pv_hashed_entry_t	*pprevh;
	<span class="enscript-type">int</span>           		pvhash_idx;

	CHK_NPVHASH();
	pvhash_idx = pvhashidx(pvh-&gt;pmap, pvh-&gt;va);

	pprevh = pvhash(pvhash_idx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PV_DEBUG</span>
	<span class="enscript-keyword">if</span> (NULL == *pprevh)
		panic(<span class="enscript-string">&quot;pvh_unlink null anchor&quot;</span>); <span class="enscript-comment">/* JK DEBUG */</span>
#<span class="enscript-reference">endif</span>
	curh = *pprevh;

	<span class="enscript-keyword">while</span> (PV_HASHED_ENTRY_NULL != curh) {
		<span class="enscript-keyword">if</span> (pvh == curh)
			<span class="enscript-keyword">break</span>;
		pprevh = &amp;curh-&gt;nexth;
		curh = curh-&gt;nexth;
	}
	<span class="enscript-keyword">if</span> (PV_HASHED_ENTRY_NULL == curh) panic(<span class="enscript-string">&quot;pmap_pvh_unlink no pvh&quot;</span>);
	*pprevh = pvh-&gt;nexth;
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">pv_hash_add</span>(pv_hashed_entry_t	pvh_e,
	    pv_rooted_entry_t	pv_h)
{
	pv_hashed_entry_t       *hashp;
	<span class="enscript-type">int</span>                     pvhash_idx;

	CHK_NPVHASH();
	pvhash_idx = pvhashidx(pvh_e-&gt;pmap, pvh_e-&gt;va);
	LOCK_PV_HASH(pvhash_idx);
	insque(&amp;pvh_e-&gt;qlink, &amp;pv_h-&gt;qlink);
	hashp = pvhash(pvhash_idx);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PV_DEBUG</span>
	<span class="enscript-keyword">if</span> (NULL==hashp)
		panic(<span class="enscript-string">&quot;pv_hash_add(%p) null hash bucket&quot;</span>, pvh_e);
#<span class="enscript-reference">endif</span>
	pvh_e-&gt;nexth = *hashp;
	*hashp = pvh_e;
	UNLOCK_PV_HASH(pvhash_idx);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">pv_hash_remove</span>(pv_hashed_entry_t pvh_e)
{
	<span class="enscript-type">int</span>                     pvhash_idx;

	CHK_NPVHASH();
	pvhash_idx = pvhashidx(pvh_e-&gt;pmap,pvh_e-&gt;va);
	LOCK_PV_HASH(pvhash_idx);
	remque(&amp;pvh_e-&gt;qlink);
	pmap_pvh_unlink(pvh_e);
	UNLOCK_PV_HASH(pvhash_idx);
} 

<span class="enscript-type">static</span> inline boolean_t <span class="enscript-function-name">popcnt1</span>(uint64_t distance) {
	<span class="enscript-keyword">return</span> ((distance &amp; (distance - 1)) == 0);
}

<span class="enscript-comment">/*
 * Routines to handle suppression of/recovery from some forms of pagetable corruption
 * incidents observed in the field. These can be either software induced (wild
 * stores to the mapwindows where applicable, use after free errors
 * (typically of pages addressed physically), mis-directed DMAs etc., or due
 * to DRAM/memory hierarchy/interconnect errors. Given the theoretical rarity of these errors,
 * the recording mechanism is deliberately not MP-safe. The overarching goal is to
 * still assert on potential software races, but attempt recovery from incidents
 * identifiable as occurring due to issues beyond the control of the pmap module.
 * The latter includes single-bit errors and malformed pagetable entries.
 * We currently limit ourselves to recovery/suppression of one incident per
 * PMAP_PAGETABLE_CORRUPTION_INTERVAL seconds, and details of the incident
 * are logged.
 * Assertions are not suppressed if kernel debugging is enabled. (DRK 09)
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	PTE_VALID		= 0x0,
	PTE_INVALID		= 0x1,
	PTE_RSVD		= 0x2,
	PTE_SUPERVISOR		= 0x4,
	PTE_BITFLIP		= 0x8,
	PV_BITFLIP		= 0x10,
	PTE_INVALID_CACHEABILITY = 0x20
} pmap_pagetable_corruption_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	ROOT_PRESENT = 0,
	ROOT_ABSENT = 1
} pmap_pv_assertion_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	PMAP_ACTION_IGNORE	= 0x0,
	PMAP_ACTION_ASSERT	= 0x1,
	PMAP_ACTION_RETRY	= 0x2,
	PMAP_ACTION_RETRY_RELOCK = 0x4
} pmap_pagetable_corruption_action_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PMAP_PAGETABLE_CORRUPTION_INTERVAL</span> (6ULL * 3600ULL)
<span class="enscript-type">extern</span> uint64_t pmap_pagetable_corruption_interval_abstime;

<span class="enscript-type">extern</span> uint32_t pmap_pagetable_corruption_incidents;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PAGETABLE_CORRUPTION_MAX_LOG</span> (8)
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	pmap_pv_assertion_t incident;
	pmap_pagetable_corruption_t reason;
	pmap_pagetable_corruption_action_t action;
	pmap_t	pmap;
	vm_map_offset_t vaddr;
	pt_entry_t pte;
	ppnum_t ppn;
	pmap_t pvpmap;
	vm_map_offset_t pvva;
	uint64_t abstime;
} pmap_pagetable_corruption_record_t;

<span class="enscript-type">extern</span> pmap_pagetable_corruption_record_t pmap_pagetable_corruption_records[];
<span class="enscript-type">extern</span> uint64_t pmap_pagetable_corruption_last_abstime;
<span class="enscript-type">extern</span> thread_call_t 	pmap_pagetable_corruption_log_call;
<span class="enscript-type">extern</span> boolean_t pmap_pagetable_corruption_timeout;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_pagetable_corruption_log</span>(pmap_pv_assertion_t incident, pmap_pagetable_corruption_t suppress_reason, pmap_pagetable_corruption_action_t action, pmap_t pmap, vm_map_offset_t vaddr, pt_entry_t *ptep, ppnum_t ppn, pmap_t pvpmap, vm_map_offset_t pvva) {
	uint32_t pmap_pagetable_corruption_log_index;
	pmap_pagetable_corruption_log_index = pmap_pagetable_corruption_incidents++ % PMAP_PAGETABLE_CORRUPTION_MAX_LOG;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].incident = incident;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].reason = suppress_reason;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].action = action;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].pmap = pmap;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].vaddr = vaddr;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].pte = *ptep;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].ppn = ppn;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].pvpmap = pvpmap;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].pvva = pvva;
	pmap_pagetable_corruption_records[pmap_pagetable_corruption_log_index].abstime = mach_absolute_time();
	<span class="enscript-comment">/* Asynchronously log */</span>
	thread_call_enter(pmap_pagetable_corruption_log_call);
}

<span class="enscript-type">static</span> inline pmap_pagetable_corruption_action_t
<span class="enscript-function-name">pmap_classify_pagetable_corruption</span>(pmap_t pmap, vm_map_offset_t vaddr, ppnum_t *ppnp, pt_entry_t *ptep, pmap_pv_assertion_t incident) {
	pmap_pagetable_corruption_action_t	action = PMAP_ACTION_ASSERT;
	pmap_pagetable_corruption_t	suppress_reason = PTE_VALID;
	ppnum_t			suppress_ppn = 0;
	pt_entry_t cpte = *ptep;
	ppnum_t	cpn = pa_index(pte_to_pa(cpte));
	ppnum_t	ppn = *ppnp;
	pv_rooted_entry_t	pv_h = pai_to_pvh(ppn_to_pai(ppn));
	pv_rooted_entry_t	pv_e = pv_h;
	uint32_t	bitdex;
	pmap_t pvpmap = pv_h-&gt;pmap;
	vm_map_offset_t pvva = pv_h-&gt;va;
	boolean_t ppcd = FALSE;
	boolean_t is_ept;

	<span class="enscript-comment">/* Ideally, we'd consult the Mach VM here to definitively determine
	 * the nature of the mapping for this address space and address.
	 * As that would be a layering violation in this context, we
	 * use various heuristics to recover from single bit errors,
	 * malformed pagetable entries etc. These are not intended
	 * to be comprehensive.
	 */</span>

	<span class="enscript-comment">/* As a precautionary measure, mark A+D */</span>
	pmap_phys_attributes[ppn_to_pai(ppn)] |= (PHYS_MODIFIED | PHYS_REFERENCED);
	is_ept = is_ept_pmap(pmap);

	<span class="enscript-comment">/*
	 * Correct potential single bit errors in either (but not both) element
	 * of the PV
	 */</span>
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> ((popcnt1((uintptr_t)pv_e-&gt;pmap ^ (uintptr_t)pmap) &amp;&amp; pv_e-&gt;va == vaddr) ||
		    (pv_e-&gt;pmap == pmap &amp;&amp; popcnt1(pv_e-&gt;va ^ vaddr))) {
			pv_e-&gt;pmap = pmap;
			pv_e-&gt;va = vaddr;
			suppress_reason = PV_BITFLIP;
			action = PMAP_ACTION_RETRY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_cpc_exit</span>;
		}
	} <span class="enscript-keyword">while</span> (((pv_e = (pv_rooted_entry_t) queue_next(&amp;pv_e-&gt;qlink))) &amp;&amp; (pv_e != pv_h));

	<span class="enscript-comment">/* Discover root entries with a Hamming
	 * distance of 1 from the supplied
	 * physical page frame.
	 */</span>
	<span class="enscript-keyword">for</span> (bitdex = 0; bitdex &lt; (<span class="enscript-keyword">sizeof</span>(ppnum_t) &lt;&lt; 3); bitdex++) {
		ppnum_t npn = cpn ^ (ppnum_t) (1ULL &lt;&lt; bitdex);
		<span class="enscript-keyword">if</span> (IS_MANAGED_PAGE(npn)) {
			pv_rooted_entry_t npv_h = pai_to_pvh(ppn_to_pai(npn));
			<span class="enscript-keyword">if</span> (npv_h-&gt;va == vaddr &amp;&amp; npv_h-&gt;pmap == pmap) {
				suppress_reason = PTE_BITFLIP;
				suppress_ppn = npn;
				action = PMAP_ACTION_RETRY_RELOCK;
				UNLOCK_PVH(ppn_to_pai(ppn));
				*ppnp = npn;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_cpc_exit</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> (pmap == kernel_pmap) {
		action = PMAP_ACTION_ASSERT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_cpc_exit</span>;
	}

	<span class="enscript-comment">/*
	 * Check for malformed/inconsistent entries.
	 * The first check here isn't useful for EPT PTEs because INTEL_EPT_NCACHE == 0
	 */</span>
	<span class="enscript-keyword">if</span> (!is_ept &amp;&amp; ((cpte &amp; (INTEL_PTE_NCACHE | INTEL_PTE_WTHRU | INTEL_PTE_PTA)) ==  (INTEL_PTE_NCACHE | INTEL_PTE_WTHRU))) {
		action = PMAP_ACTION_IGNORE;
		suppress_reason = PTE_INVALID_CACHEABILITY;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cpte &amp; INTEL_PTE_RSVD) {
		action = PMAP_ACTION_IGNORE;
		suppress_reason = PTE_RSVD;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pmap != kernel_pmap) &amp;&amp; (!is_ept) &amp;&amp; ((cpte &amp; INTEL_PTE_USER) == 0)) {
		action = PMAP_ACTION_IGNORE;
		suppress_reason = PTE_SUPERVISOR;
	}
<span class="enscript-reference">pmap_cpc_exit</span>:
	PE_parse_boot_argn(<span class="enscript-string">&quot;-pmap_pagetable_corruption_deassert&quot;</span>, &amp;ppcd, <span class="enscript-keyword">sizeof</span>(ppcd));

	<span class="enscript-keyword">if</span> (debug_boot_arg &amp;&amp; !ppcd) {
		action = PMAP_ACTION_ASSERT;
	}

	<span class="enscript-keyword">if</span> ((mach_absolute_time() - pmap_pagetable_corruption_last_abstime) &lt; pmap_pagetable_corruption_interval_abstime) {
		action = PMAP_ACTION_ASSERT;
		pmap_pagetable_corruption_timeout = TRUE;
	}
	<span class="enscript-keyword">else</span>
	{
		pmap_pagetable_corruption_last_abstime = mach_absolute_time();
	}
	pmap_pagetable_corruption_log(incident, suppress_reason, action, pmap, vaddr, &amp;cpte, *ppnp, pvpmap, pvva);
	<span class="enscript-keyword">return</span> action;
}

<span class="enscript-comment">/*
 * Remove pv list entry.
 * Called with pv_head_table entry locked.
 * Returns pv entry to be freed (or NULL).
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-function-name">__attribute__</span>((always_inline)) pv_hashed_entry_t
<span class="enscript-function-name">pmap_pv_remove</span>(pmap_t		pmap,
	       vm_map_offset_t	vaddr,
    		ppnum_t		*ppnp,
		pt_entry_t	*pte) 
{
	pv_hashed_entry_t       pvh_e;
	pv_rooted_entry_t	pv_h;
	pv_hashed_entry_t	*pprevh;
	<span class="enscript-type">int</span>                     pvhash_idx;
	uint32_t                pv_cnt;
	ppnum_t			ppn;

<span class="enscript-reference">pmap_pv_remove_retry</span>:
	ppn = *ppnp;
	pvh_e = PV_HASHED_ENTRY_NULL;
	pv_h = pai_to_pvh(ppn_to_pai(ppn));

	<span class="enscript-keyword">if</span> (__improbable(pv_h-&gt;pmap == PMAP_NULL)) {
		pmap_pagetable_corruption_action_t pac = pmap_classify_pagetable_corruption(pmap, vaddr, ppnp, pte, ROOT_ABSENT);
		<span class="enscript-keyword">if</span> (pac == PMAP_ACTION_IGNORE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_pv_remove_exit</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pac == PMAP_ACTION_ASSERT)
			panic(<span class="enscript-string">&quot;Possible memory corruption: pmap_pv_remove(%p,0x%llx,0x%x, 0x%llx, %p, %p): null pv_list!&quot;</span>, pmap, vaddr, ppn, *pte, ppnp, pte);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pac == PMAP_ACTION_RETRY_RELOCK) {
			LOCK_PVH(ppn_to_pai(*ppnp));
			pmap_phys_attributes[ppn_to_pai(*ppnp)] |= (PHYS_MODIFIED | PHYS_REFERENCED);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_pv_remove_retry</span>;
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pac == PMAP_ACTION_RETRY)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_pv_remove_retry</span>;
	}

	<span class="enscript-keyword">if</span> (pv_h-&gt;va == vaddr &amp;&amp; pv_h-&gt;pmap == pmap) {
		<span class="enscript-comment">/*
	         * Header is the pv_rooted_entry.
		 * We can't free that. If there is a queued
	         * entry after this one we remove that
	         * from the ppn queue, we remove it from the hash chain
	         * and copy it to the rooted entry. Then free it instead.
	         */</span>
		pvh_e = (pv_hashed_entry_t) queue_next(&amp;pv_h-&gt;qlink);
		<span class="enscript-keyword">if</span> (pv_h != (pv_rooted_entry_t) pvh_e) {
			<span class="enscript-comment">/*
			 * Entry queued to root, remove this from hash
			 * and install as new root.
			 */</span>
			CHK_NPVHASH();
			pvhash_idx = pvhashidx(pvh_e-&gt;pmap, pvh_e-&gt;va);
			LOCK_PV_HASH(pvhash_idx);
			remque(&amp;pvh_e-&gt;qlink);
			pprevh = pvhash(pvhash_idx);
			<span class="enscript-keyword">if</span> (PV_HASHED_ENTRY_NULL == *pprevh) {
				panic(<span class="enscript-string">&quot;Possible memory corruption: pmap_pv_remove(%p,0x%llx,0x%x): &quot;</span>
				      <span class="enscript-string">&quot;empty hash, removing rooted&quot;</span>,
				      pmap, vaddr, ppn);
			}
			pmap_pvh_unlink(pvh_e);
			UNLOCK_PV_HASH(pvhash_idx);
			pv_h-&gt;pmap = pvh_e-&gt;pmap;
			pv_h-&gt;va = pvh_e-&gt;va;	<span class="enscript-comment">/* dispose of pvh_e */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* none queued after rooted */</span>
			pv_h-&gt;pmap = PMAP_NULL;
			pvh_e = PV_HASHED_ENTRY_NULL;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * not removing rooted pv. find it on hash chain, remove from
		 * ppn queue and hash chain and free it
		 */</span>
		CHK_NPVHASH();
		pvhash_idx = pvhashidx(pmap, vaddr);
		LOCK_PV_HASH(pvhash_idx);
		pprevh = pvhash(pvhash_idx);
		<span class="enscript-keyword">if</span> (PV_HASHED_ENTRY_NULL == *pprevh) {
			panic(<span class="enscript-string">&quot;Possible memory corruption: pmap_pv_remove(%p,0x%llx,0x%x, 0x%llx, %p): empty hash&quot;</span>,
			    pmap, vaddr, ppn, *pte, pte);
		}
		pvh_e = *pprevh;
		pmap_pv_hashlist_walks++;
		pv_cnt = 0;
		<span class="enscript-keyword">while</span> (PV_HASHED_ENTRY_NULL != pvh_e) {
			pv_cnt++;
			<span class="enscript-keyword">if</span> (pvh_e-&gt;pmap == pmap &amp;&amp;
			    pvh_e-&gt;va == vaddr &amp;&amp;
			    pvh_e-&gt;ppn == ppn)
				<span class="enscript-keyword">break</span>;
			pprevh = &amp;pvh_e-&gt;nexth;
			pvh_e = pvh_e-&gt;nexth;
		}

		<span class="enscript-keyword">if</span> (PV_HASHED_ENTRY_NULL == pvh_e) {
			pmap_pagetable_corruption_action_t pac = pmap_classify_pagetable_corruption(pmap, vaddr, ppnp, pte, ROOT_PRESENT);

			<span class="enscript-keyword">if</span> (pac == PMAP_ACTION_ASSERT)
				panic(<span class="enscript-string">&quot;Possible memory corruption: pmap_pv_remove(%p, 0x%llx, 0x%x, 0x%llx, %p, %p): pv not on hash, head: %p, 0x%llx&quot;</span>, pmap, vaddr, ppn, *pte, ppnp, pte, pv_h-&gt;pmap, pv_h-&gt;va);
			<span class="enscript-keyword">else</span> {
				UNLOCK_PV_HASH(pvhash_idx);
				<span class="enscript-keyword">if</span> (pac == PMAP_ACTION_RETRY_RELOCK) {
					LOCK_PVH(ppn_to_pai(*ppnp));
					pmap_phys_attributes[ppn_to_pai(*ppnp)] |= (PHYS_MODIFIED | PHYS_REFERENCED);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_pv_remove_retry</span>;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pac == PMAP_ACTION_RETRY) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_pv_remove_retry</span>;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pac == PMAP_ACTION_IGNORE) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">pmap_pv_remove_exit</span>;
				}
			}
		}

		pmap_pv_hashlist_cnts += pv_cnt;
		<span class="enscript-keyword">if</span> (pmap_pv_hashlist_max &lt; pv_cnt)
			pmap_pv_hashlist_max = pv_cnt;
		*pprevh = pvh_e-&gt;nexth;
		remque(&amp;pvh_e-&gt;qlink);
		UNLOCK_PV_HASH(pvhash_idx);
	}
<span class="enscript-reference">pmap_pv_remove_exit</span>:
	<span class="enscript-keyword">return</span> pvh_e;
}


<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 	pt_fake_zone_index;
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">PMAP_ZINFO_PALLOC</span>(pmap_t pmap, vm_size_t bytes)
{
	thread_t thr = current_thread();
	task_t task;
	zinfo_usage_t zinfo;

	pmap_ledger_credit(pmap, task_ledgers.tkm_private, bytes);

	<span class="enscript-keyword">if</span> (pt_fake_zone_index != -1 &amp;&amp; 
	    (task = thr-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
		OSAddAtomic64(bytes, (int64_t *)&amp;zinfo[pt_fake_zone_index].alloc);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">PMAP_ZINFO_PFREE</span>(pmap_t pmap, vm_size_t bytes)
{
	thread_t thr = current_thread();
	task_t task;
	zinfo_usage_t zinfo;

	pmap_ledger_debit(pmap, task_ledgers.tkm_private, bytes);

	<span class="enscript-keyword">if</span> (pt_fake_zone_index != -1 &amp;&amp; 
	    (task = thr-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
		OSAddAtomic64(bytes, (int64_t *)&amp;zinfo[pt_fake_zone_index].free);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">PMAP_ZINFO_SALLOC</span>(pmap_t pmap, vm_size_t bytes)
{
	pmap_ledger_credit(pmap, task_ledgers.tkm_shared, bytes);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">PMAP_ZINFO_SFREE</span>(pmap_t pmap, vm_size_t bytes)
{
	pmap_ledger_debit(pmap, task_ledgers.tkm_shared, bytes);
}

<span class="enscript-type">extern</span> boolean_t	pmap_initialized;<span class="enscript-comment">/* Has pmap_init completed? */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">valid_page</span>(x) (pmap_initialized &amp;&amp; pmap_valid_page(x))

<span class="enscript-comment">// XXX
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HIGH_MEM_BASE</span>  ((uint32_t)( -NBPDE) )  <span class="enscript-comment">/* shared gdt etc seg addr */</span> <span class="enscript-comment">/* XXX64 ?? */</span>
<span class="enscript-comment">// XXX
</span>

<span class="enscript-type">int</span>		phys_attribute_test(
			ppnum_t		phys,
			<span class="enscript-type">int</span>		bits);
<span class="enscript-type">void</span>		phys_attribute_clear(
			ppnum_t		phys,
			<span class="enscript-type">int</span>		bits,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	options,
	                <span class="enscript-type">void</span>		*arg);

<span class="enscript-comment">//#define PCID_DEBUG 1
</span>#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">PCID_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_pcid_log</span>(fmt, args...)					\
	<span class="enscript-keyword">do</span> {								\
		kprintf(fmt, ##args);					\
		printf(fmt, ##args);					\
	} <span class="enscript-keyword">while</span>(0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_pcid_log</span>(fmt, args...)
#<span class="enscript-reference">endif</span>
<span class="enscript-type">void</span>	pmap_pcid_configure(<span class="enscript-type">void</span>);


<span class="enscript-comment">/*
 * Atomic 64-bit compare and exchange of a page table entry.
 */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">pmap_cmpx_pte</span>(pt_entry_t *entryp, pt_entry_t old, pt_entry_t new)
{
	boolean_t		ret;

	<span class="enscript-comment">/*
	 * Load the old value into %rax
	 * Load the new value into another register
	 * Compare-exchange-quad at address entryp
	 * If the compare succeeds, the new value is stored, return TRUE.
	 * Otherwise, no swap is made, return FALSE.
	 */</span>
	asm <span class="enscript-type">volatile</span>(
		<span class="enscript-string">&quot;	lock; cmpxchgq %2,(%3)	\n\t&quot;</span>
		<span class="enscript-string">&quot;	setz	%%al		\n\t&quot;</span>
		<span class="enscript-string">&quot;	movzbl	%%al,%0&quot;</span>
		: <span class="enscript-string">&quot;=a&quot;</span> (ret)
		: <span class="enscript-string">&quot;a&quot;</span> (old),
		  <span class="enscript-string">&quot;r&quot;</span> (new),
		  <span class="enscript-string">&quot;r&quot;</span> (entryp)
		: <span class="enscript-string">&quot;memory&quot;</span>);
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">extern</span> uint32_t pmap_update_clear_pte_count;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">pmap_update_pte</span>(pt_entry_t *mptep, uint64_t pclear_bits, uint64_t pset_bits) {
	pt_entry_t npte, opte;
	<span class="enscript-keyword">do</span> {
		opte = *mptep;
		<span class="enscript-keyword">if</span> (__improbable(opte == 0)) {
			pmap_update_clear_pte_count++;
			<span class="enscript-keyword">break</span>;
		}
		npte = opte &amp; ~(pclear_bits);
		npte |= pset_bits;
	}	<span class="enscript-keyword">while</span> (!pmap_cmpx_pte(mptep, opte, npte));
}

#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-comment">/*
 * The single pml4 page per pmap is allocated at pmap create time and exists
 * for the duration of the pmap. we allocate this page in kernel vm.
 * this returns the address of the requested pml4 entry in the top level page.
 */</span>
<span class="enscript-type">static</span> inline
pml4_entry_t *
<span class="enscript-function-name">pmap64_pml4</span>(pmap_t pmap, vm_map_offset_t vaddr)
{
	<span class="enscript-keyword">if</span> (__improbable((vaddr &gt; 0x00007FFFFFFFFFFFULL) &amp;&amp;
		(vaddr &lt; 0xFFFF800000000000ULL))) {
		<span class="enscript-keyword">return</span> (NULL);
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">PMAP_ASSERT</span>
	<span class="enscript-keyword">return</span> PHYSMAP_PTOV(&amp;((pml4_entry_t *)pmap-&gt;pm_cr3)[(vaddr &gt;&gt; PML4SHIFT) &amp; (NPML4PG-1)]);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">return</span> &amp;pmap-&gt;pm_pml4[(vaddr &gt;&gt; PML4SHIFT) &amp; (NPML4PG-1)];
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Returns address of requested PDPT entry in the physmap.
 */</span>
<span class="enscript-type">static</span> inline pdpt_entry_t *
<span class="enscript-function-name">pmap64_pdpt</span>(pmap_t pmap, vm_map_offset_t vaddr)
{
	pml4_entry_t	newpf;
	pml4_entry_t	*pml4;
	boolean_t	is_ept;

	pml4 = pmap64_pml4(pmap, vaddr);
	is_ept = is_ept_pmap(pmap);

	<span class="enscript-keyword">if</span> (pml4 &amp;&amp; (*pml4 &amp; PTE_VALID_MASK(is_ept))) {
		newpf = *pml4 &amp; PG_FRAME;
		<span class="enscript-keyword">return</span> &amp;((pdpt_entry_t *) PHYSMAP_PTOV(newpf))
			[(vaddr &gt;&gt; PDPTSHIFT) &amp; (NPDPTPG-1)];
	}
	<span class="enscript-keyword">return</span> (NULL);
}
<span class="enscript-comment">/*
 * Returns the address of the requested PDE entry in the physmap.
 */</span>
<span class="enscript-type">static</span> inline pd_entry_t *
<span class="enscript-function-name">pmap64_pde</span>(pmap_t pmap, vm_map_offset_t vaddr)
{
	pdpt_entry_t	newpf;
	pdpt_entry_t	*pdpt;
	boolean_t	is_ept;

	pdpt = pmap64_pdpt(pmap, vaddr);
	is_ept = is_ept_pmap(pmap);

	<span class="enscript-keyword">if</span> (pdpt &amp;&amp; (*pdpt &amp; PTE_VALID_MASK(is_ept))) {
		newpf = *pdpt &amp; PG_FRAME;
		<span class="enscript-keyword">return</span> &amp;((pd_entry_t *) PHYSMAP_PTOV(newpf))
			[(vaddr &gt;&gt; PDSHIFT) &amp; (NPDPG-1)];
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> inline pd_entry_t     *
<span class="enscript-function-name">pmap_pde</span>(pmap_t m, vm_map_offset_t v)
{
	pd_entry_t     *pde;

	pde = pmap64_pde(m, v);

	<span class="enscript-keyword">return</span> pde;
}


<span class="enscript-comment">/*
 * return address of mapped pte for vaddr va in pmap pmap.
 *
 * In case the pde maps a superpage, return the pde, which, in this case
 * is the actual page table entry.
 */</span>
<span class="enscript-type">static</span> inline pt_entry_t *
<span class="enscript-function-name">pmap_pte</span>(pmap_t pmap, vm_map_offset_t vaddr)
{
	pd_entry_t	*pde;
	pd_entry_t	newpf;
	boolean_t	is_ept;

	assert(pmap);
	pde = pmap64_pde(pmap, vaddr);

	is_ept = is_ept_pmap(pmap);

	<span class="enscript-keyword">if</span> (pde &amp;&amp; (*pde &amp; PTE_VALID_MASK(is_ept))) {
		<span class="enscript-keyword">if</span> (*pde &amp; PTE_PS)
			<span class="enscript-keyword">return</span> pde;
		newpf = *pde &amp; PG_FRAME;
		<span class="enscript-keyword">return</span> &amp;((pt_entry_t *)PHYSMAP_PTOV(newpf))
			[i386_btop(vaddr) &amp; (ppnum_t)(NPTEPG-1)];
	}
	<span class="enscript-keyword">return</span> (NULL);
}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPRINTF</span>(x...)	kprintf(x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPRINTF</span>(x...)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _I386_PMAP_INTERNAL_ */</span>
</pre>
<hr />
</body></html>