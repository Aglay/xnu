<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>cpu_data.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">cpu_data.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 * 
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">I386_CPU_DATA</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">I386_CPU_DATA</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/pms.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/rtclock_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_topology.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_VMX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx/vmx_cpu.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

<span class="enscript-comment">/*
 * Data structures referenced (anonymously) from per-cpu data:
 */</span>
<span class="enscript-type">struct</span> cpu_cons_buffer;
<span class="enscript-type">struct</span> cpu_desc_table;
<span class="enscript-type">struct</span> mca_state;
<span class="enscript-type">struct</span> prngContext;

<span class="enscript-comment">/*
 * Data structures embedded in per-cpu data:
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> rtclock_timer {
	mpqueue_head_t		queue;
	uint64_t		deadline;
	uint64_t		when_set;
	boolean_t		has_expired;
} rtclock_timer_t;


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">struct</span> x86_64_tss	*cdi_ktss;
	<span class="enscript-type">struct</span> __attribute__((packed)) {
		uint16_t size;
		<span class="enscript-type">void</span> *ptr;
	} cdi_gdt, cdi_idt;
	<span class="enscript-type">struct</span> fake_descriptor	*cdi_ldt;
	vm_offset_t		cdi_sstk;
} cpu_desc_index_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	TASK_MAP_32BIT,			<span class="enscript-comment">/* 32-bit user, compatibility mode */</span> 
	TASK_MAP_64BIT,			<span class="enscript-comment">/* 64-bit user thread, shared space */</span> 
} task_map_t;


<span class="enscript-comment">/*
 * This structure is used on entry into the (uber-)kernel on syscall from
 * a 64-bit user. It contains the address of the machine state save area
 * for the current thread and a temporary place to save the user's rsp
 * before loading this address into rsp.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	addr64_t	cu_isf;		<span class="enscript-comment">/* thread-&gt;pcb-&gt;iss.isf */</span>
	uint64_t	cu_tmp;		<span class="enscript-comment">/* temporary scratch */</span>	
	addr64_t	cu_user_gs_base;
} cpu_uber_t;

<span class="enscript-type">typedef</span>	uint16_t	pcid_t;
<span class="enscript-type">typedef</span>	uint8_t		pcid_ref_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CPU_RTIME_BINS</span> (12)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CPU_ITIME_BINS</span> (CPU_RTIME_BINS)

<span class="enscript-comment">/*
 * Per-cpu data.
 *
 * Each processor has a per-cpu data area which is dereferenced through the
 * current_cpu_datap() macro. For speed, the %gs segment is based here, and
 * using this, inlines provides single-instruction access to frequently used
 * members - such as get_cpu_number()/cpu_number(), and get_active_thread()/
 * current_thread(). 
 * 
 * Cpu data owned by another processor can be accessed using the
 * cpu_datap(cpu_number) macro which uses the cpu_data_ptr[] array of per-cpu
 * pointers.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cpu_data
{
	<span class="enscript-type">struct</span> pal_cpu_data	cpu_pal_data;		<span class="enscript-comment">/* PAL-specific data */</span>
#<span class="enscript-reference">define</span>				<span class="enscript-variable-name">cpu_pd</span> cpu_pal_data	<span class="enscript-comment">/* convenience alias */</span>
	<span class="enscript-type">struct</span> cpu_data		*cpu_this;		<span class="enscript-comment">/* pointer to myself */</span>
	thread_t		cpu_active_thread;
	thread_t		cpu_nthread;
	<span class="enscript-type">volatile</span> <span class="enscript-type">int</span>		cpu_preemption_level;
	<span class="enscript-type">int</span>			cpu_number;		<span class="enscript-comment">/* Logical CPU */</span>
	<span class="enscript-type">void</span>			*cpu_int_state;		<span class="enscript-comment">/* interrupt state */</span>
	vm_offset_t		cpu_active_stack;	<span class="enscript-comment">/* kernel stack base */</span>
	vm_offset_t		cpu_kernel_stack;	<span class="enscript-comment">/* kernel stack top */</span>
	vm_offset_t		cpu_int_stack_top;
	<span class="enscript-type">int</span>			cpu_interrupt_level;
	<span class="enscript-type">int</span>			cpu_phys_number;	<span class="enscript-comment">/* Physical CPU */</span>
	cpu_id_t		cpu_id;			<span class="enscript-comment">/* Platform Expert */</span>
	<span class="enscript-type">volatile</span> <span class="enscript-type">int</span>		cpu_signals;		<span class="enscript-comment">/* IPI events */</span>
	<span class="enscript-type">volatile</span> <span class="enscript-type">int</span>		cpu_prior_signals;	<span class="enscript-comment">/* Last set of events,
							 * debugging
							 */</span>
	ast_t			cpu_pending_ast;
	<span class="enscript-type">volatile</span> <span class="enscript-type">int</span>		cpu_running;
	boolean_t		cpu_fixed_pmcs_enabled;
	rtclock_timer_t		rtclock_timer;
	<span class="enscript-type">volatile</span> addr64_t	cpu_active_cr3 __attribute((aligned(64)));
	<span class="enscript-type">union</span> {
		<span class="enscript-type">volatile</span> uint32_t cpu_tlb_invalid;
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">volatile</span> uint16_t cpu_tlb_invalid_local;
			<span class="enscript-type">volatile</span> uint16_t cpu_tlb_invalid_global;
		};
	};
	<span class="enscript-type">volatile</span> task_map_t	cpu_task_map;
	<span class="enscript-type">volatile</span> addr64_t	cpu_task_cr3;
	addr64_t		cpu_kernel_cr3;
	cpu_uber_t		cpu_uber;
	<span class="enscript-type">void</span>			*cpu_chud;
	<span class="enscript-type">void</span>			*cpu_console_buf;
	<span class="enscript-type">struct</span> x86_lcpu		lcpu;
	<span class="enscript-type">struct</span> processor	*cpu_processor;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	<span class="enscript-type">struct</span> cpu_pmap		*cpu_pmap;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> cpu_desc_table	*cpu_desc_tablep;
	<span class="enscript-type">struct</span> fake_descriptor	*cpu_ldtp;
	cpu_desc_index_t	cpu_desc_index;
	<span class="enscript-type">int</span>			cpu_ldt;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	vm_offset_t		cpu_copywindow_base;
	uint64_t		*cpu_copywindow_pdp;

	vm_offset_t		cpu_physwindow_base;
	uint64_t		*cpu_physwindow_ptep;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HWINTCNT_SIZE</span> 256
	uint32_t		cpu_hwIntCnt[HWINTCNT_SIZE];	<span class="enscript-comment">/* Interrupt counts */</span>
 	uint64_t		cpu_hwIntpexits[HWINTCNT_SIZE];
	uint64_t		cpu_hwIntcexits[HWINTCNT_SIZE];
	uint64_t		cpu_dr7; <span class="enscript-comment">/* debug control register */</span>
	uint64_t		cpu_int_event_time;	<span class="enscript-comment">/* intr entry/exit time */</span>
	pal_rtc_nanotime_t	*cpu_nanotime;		<span class="enscript-comment">/* Nanotime info */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPC</span>
	<span class="enscript-comment">/* double-buffered performance counter data */</span>
	uint64_t                *cpu_kpc_buf[2];
	<span class="enscript-comment">/* PMC shadow and reload value buffers */</span>
	uint64_t                *cpu_kpc_shadow;
	uint64_t                *cpu_kpc_reload;
#<span class="enscript-reference">endif</span>
	uint32_t		cpu_pmap_pcid_enabled;
	pcid_t			cpu_active_pcid;
	pcid_t			cpu_last_pcid;
	<span class="enscript-type">volatile</span> pcid_ref_t	*cpu_pmap_pcid_coherentp;
	<span class="enscript-type">volatile</span> pcid_ref_t	*cpu_pmap_pcid_coherentp_kernel;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PMAP_PCID_MAX_PCID</span>      (0x1000)
	pcid_t			cpu_pcid_free_hint;
	pcid_ref_t		cpu_pcid_refcounts[PMAP_PCID_MAX_PCID];
	pmap_t			cpu_pcid_last_pmap_dispatched[PMAP_PCID_MAX_PCID];
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">PCID_STATS</span>
	uint64_t		cpu_pmap_pcid_flushes;
	uint64_t		cpu_pmap_pcid_preserves;
#<span class="enscript-reference">endif</span>
	uint64_t		cpu_aperf;
	uint64_t		cpu_mperf;
	uint64_t		cpu_c3res;
	uint64_t		cpu_c6res;
	uint64_t		cpu_c7res;
	uint64_t		cpu_itime_total;
	uint64_t		cpu_rtime_total;
	uint64_t		cpu_ixtime;
	uint64_t                cpu_idle_exits;
 	uint64_t		cpu_rtimes[CPU_RTIME_BINS];
 	uint64_t		cpu_itimes[CPU_ITIME_BINS];
 	uint64_t		cpu_cur_insns;
 	uint64_t		cpu_cur_ucc;
 	uint64_t		cpu_cur_urc;
	uint64_t		cpu_gpmcs[4];
	uint64_t                cpu_max_observed_int_latency;
	<span class="enscript-type">int</span>                     cpu_max_observed_int_latency_vector;
	<span class="enscript-type">volatile</span> boolean_t	cpu_NMI_acknowledged;
	uint64_t		debugger_entry_time;
	uint64_t		debugger_ipi_time;
	<span class="enscript-comment">/* A separate nested interrupt stack flag, to account
	 * for non-nested interrupts arriving while on the interrupt stack
	 * Currently only occurs when AICPM enables interrupts on the
	 * interrupt stack during processor offlining.
	 */</span>
	uint32_t		cpu_nested_istack;
	uint32_t		cpu_nested_istack_events;
	x86_saved_state64_t	*cpu_fatal_trap_state;
	x86_saved_state64_t	*cpu_post_fatal_trap_state;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_VMX</span>
	vmx_cpu_t		cpu_vmx;		<span class="enscript-comment">/* wonderful world of virtualization */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
	<span class="enscript-type">struct</span> mca_state	*cpu_mca_state;		<span class="enscript-comment">/* State at MC fault */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> prngContext	*cpu_prng;		<span class="enscript-comment">/* PRNG's context */</span>
 	<span class="enscript-type">int</span>			cpu_type;
 	<span class="enscript-type">int</span>			cpu_subtype;
 	<span class="enscript-type">int</span>			cpu_threadtype;
 	boolean_t		cpu_iflag;
 	boolean_t		cpu_boot_complete;
 	<span class="enscript-type">int</span>			cpu_hibernate;
} cpu_data_t;

<span class="enscript-type">extern</span> cpu_data_t	*cpu_data_ptr[];  

<span class="enscript-comment">/* Macro to generate inline bodies to retrieve per-cpu data fields. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GS_RELATIVE</span> volatile __attribute__((address_space(256)))
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">offsetof</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">offsetof</span>(TYPE,MEMBER) __builtin_offsetof(TYPE,MEMBER)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_GET</span>(member,type)										\
	cpu_data_t GS_RELATIVE *cpu_data =							\
		(cpu_data_t GS_RELATIVE *)0UL;									\
	type ret;															\
	ret = cpu_data-&gt;member;												\
	<span class="enscript-keyword">return</span> ret;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_GET_INDEX</span>(member,index,type)							\
	cpu_data_t GS_RELATIVE *cpu_data =							\
		(cpu_data_t GS_RELATIVE *)0UL;									\
	type ret;															\
	ret = cpu_data-&gt;member[index];										\
	<span class="enscript-keyword">return</span> ret;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_SET</span>(member,value)										\
	cpu_data_t GS_RELATIVE *cpu_data =							\
		(cpu_data_t GS_RELATIVE *)0UL;									\
	cpu_data-&gt;member = value;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_XCHG</span>(member,value,type)								\
	cpu_data_t GS_RELATIVE *cpu_data =							\
		(cpu_data_t GS_RELATIVE *)0UL;									\
	type ret;															\
	ret = cpu_data-&gt;member;												\
	cpu_data-&gt;member = value;											\
	<span class="enscript-keyword">return</span> ret;

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !defined(__clang__) */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">offsetof</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">offsetof</span>(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* offsetof */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_GET</span>(member,type)					\
	type ret;							\
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;mov %%gs:%P1,%0&quot;</span>				\
		: <span class="enscript-string">&quot;=r&quot;</span> (ret)						\
		: <span class="enscript-string">&quot;i&quot;</span> (offsetof(cpu_data_t,member)));			\
	<span class="enscript-keyword">return</span> ret;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_GET_INDEX</span>(member,index,type)	\
	type ret;							\
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;mov %%gs:(%1),%0&quot;</span>				\
		: <span class="enscript-string">&quot;=r&quot;</span> (ret)						\
		: <span class="enscript-string">&quot;r&quot;</span> (offsetof(cpu_data_t,member[index])));			\
	<span class="enscript-keyword">return</span> ret;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_SET</span>(member,value)					\
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;mov %0,%%gs:%P1&quot;</span>				\
		:							\
		: <span class="enscript-string">&quot;r&quot;</span> (value), <span class="enscript-string">&quot;i&quot;</span> (offsetof(cpu_data_t,member)));

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_DATA_XCHG</span>(member,value,type)				\
	type ret;							\
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;xchg %0,%%gs:%P1&quot;</span>				\
		: <span class="enscript-string">&quot;=r&quot;</span> (ret)						\
		: <span class="enscript-string">&quot;i&quot;</span> (offsetof(cpu_data_t,member)), <span class="enscript-string">&quot;0&quot;</span> (value));	\
	<span class="enscript-keyword">return</span> ret;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(__clang__) */</span>

<span class="enscript-comment">/*
 * Everyone within the osfmk part of the kernel can use the fast
 * inline versions of these routines.  Everyone outside, must call
 * the real thing,
 */</span>
<span class="enscript-type">static</span> inline thread_t
<span class="enscript-function-name">get_active_thread</span>(<span class="enscript-type">void</span>)
{
	CPU_DATA_GET(cpu_active_thread,thread_t)
}
#<span class="enscript-reference">define</span> <span class="enscript-function-name">current_thread_fast</span>()		get_active_thread()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">current_thread</span>()		current_thread_fast()

#<span class="enscript-reference">define</span> <span class="enscript-function-name">cpu_mode_is64bit</span>()		TRUE

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">get_preemption_level</span>(<span class="enscript-type">void</span>)
{
	CPU_DATA_GET(cpu_preemption_level,<span class="enscript-type">int</span>)
}
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">get_interrupt_level</span>(<span class="enscript-type">void</span>)
{
	CPU_DATA_GET(cpu_interrupt_level,<span class="enscript-type">int</span>)
}
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">get_cpu_number</span>(<span class="enscript-type">void</span>)
{
	CPU_DATA_GET(cpu_number,<span class="enscript-type">int</span>)
}
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">get_cpu_phys_number</span>(<span class="enscript-type">void</span>)
{
	CPU_DATA_GET(cpu_phys_number,<span class="enscript-type">int</span>)
}


<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">disable_preemption</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang__</span>)
	cpu_data_t GS_RELATIVE *cpu_data = (cpu_data_t GS_RELATIVE *)0UL;
	cpu_data-&gt;cpu_preemption_level++;
#<span class="enscript-reference">else</span>
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;incl %%gs:%P0&quot;</span>
			:
			: <span class="enscript-string">&quot;i&quot;</span> (offsetof(cpu_data_t, cpu_preemption_level)));
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">enable_preemption</span>(<span class="enscript-type">void</span>)
{
	assert(get_preemption_level() &gt; 0);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang__</span>)
	cpu_data_t GS_RELATIVE *cpu_data = (cpu_data_t GS_RELATIVE *)0UL;
	<span class="enscript-keyword">if</span> (0 == --cpu_data-&gt;cpu_preemption_level)
		kernel_preempt_check();
#<span class="enscript-reference">else</span>
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;decl %%gs:%P0		\n\t&quot;</span>
			  <span class="enscript-string">&quot;jne 1f			\n\t&quot;</span>
			  <span class="enscript-string">&quot;call _kernel_preempt_check	\n\t&quot;</span>
			  <span class="enscript-string">&quot;1:&quot;</span>
			: <span class="enscript-comment">/* no outputs */</span>
			: <span class="enscript-string">&quot;i&quot;</span> (offsetof(cpu_data_t, cpu_preemption_level))
			: <span class="enscript-string">&quot;eax&quot;</span>, <span class="enscript-string">&quot;ecx&quot;</span>, <span class="enscript-string">&quot;edx&quot;</span>, <span class="enscript-string">&quot;cc&quot;</span>, <span class="enscript-string">&quot;memory&quot;</span>);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">enable_preemption_no_check</span>(<span class="enscript-type">void</span>)
{
	assert(get_preemption_level() &gt; 0);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang__</span>)
	cpu_data_t GS_RELATIVE *cpu_data = (cpu_data_t GS_RELATIVE *)0UL;
	cpu_data-&gt;cpu_preemption_level--;
#<span class="enscript-reference">else</span>
	__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;decl %%gs:%P0&quot;</span>
			: <span class="enscript-comment">/* no outputs */</span>
			: <span class="enscript-string">&quot;i&quot;</span> (offsetof(cpu_data_t, cpu_preemption_level))
			: <span class="enscript-string">&quot;cc&quot;</span>, <span class="enscript-string">&quot;memory&quot;</span>);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">mp_disable_preemption</span>(<span class="enscript-type">void</span>)
{
	disable_preemption();
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">mp_enable_preemption</span>(<span class="enscript-type">void</span>)
{
	enable_preemption();
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">mp_enable_preemption_no_check</span>(<span class="enscript-type">void</span>)
{
	enable_preemption_no_check();
}

<span class="enscript-type">static</span> inline cpu_data_t *
<span class="enscript-function-name">current_cpu_datap</span>(<span class="enscript-type">void</span>)
{
	CPU_DATA_GET(cpu_this, cpu_data_t *);
}

<span class="enscript-type">static</span> inline cpu_data_t *
<span class="enscript-function-name">cpu_datap</span>(<span class="enscript-type">int</span> cpu)
{
	<span class="enscript-keyword">return</span> cpu_data_ptr[cpu];
}

<span class="enscript-type">extern</span> cpu_data_t *<span class="enscript-function-name">cpu_data_alloc</span>(boolean_t is_boot_cpu);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cpu_data_realloc</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* I386_CPU_DATA */</span>
</pre>
<hr />
</body></html>