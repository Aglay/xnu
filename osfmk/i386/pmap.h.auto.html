<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pmap.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pmap.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/*
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>

<span class="enscript-comment">/*
 *	File:	pmap.h
 *
 *	Authors:  Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Machine-dependent structures for the physical map module.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_PMAP_MACHINE_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_PMAP_MACHINE_</span>	1

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">ASSEMBLER</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/branch_predicates.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pal_routines.h&gt;</span>

<span class="enscript-comment">/*
 *	Define the generic in terms of the specific
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INTEL_PGBYTES</span>		I386_PGBYTES
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PGSHIFT</span>		I386_PGSHIFT
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">intel_btop</span>(x)		i386_btop(x)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">intel_ptob</span>(x)		i386_ptob(x)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">intel_round_page</span>(x)	i386_round_page(x)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">intel_trunc_page</span>(x)	i386_trunc_page(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">trunc_intel_to_vm</span>(x)	trunc_i386_to_vm(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">round_intel_to_vm</span>(x)	round_i386_to_vm(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_to_intel</span>(x)		vm_to_i386(x)

<span class="enscript-comment">/*
 *	i386/i486/i860 Page Table Entry
 */</span>

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ASSEMBLER */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPGPTD</span>          4ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDESHIFT</span>        21ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTEMASK</span>         0x1ffULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTEINDX</span>         3ULL

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTESHIFT</span>        12ULL


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOW_4GB_MASK</span>	((vm_offset_t)0x00000000FFFFFFFFUL)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDESIZE</span>		sizeof(pd_entry_t) <span class="enscript-comment">/* for assembly files */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTESIZE</span>		sizeof(pt_entry_t) <span class="enscript-comment">/* for assembly files */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_OFFMASK</span>	(I386_PGBYTES - 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_LOFFMASK</span>	(I386_LPGBYTES - 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PG_FRAME</span>        0x000FFFFFFFFFF000ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPTEPG</span>          (PAGE_SIZE/(sizeof (pt_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPTDPG</span>          (PAGE_SIZE/(sizeof (pd_entry_t)))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBPTD</span>           (NPGPTD &lt;&lt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPDEPTD</span>         (NBPTD / (sizeof (pd_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPDEPG</span>          (PAGE_SIZE/(sizeof (pd_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBPDE</span>           (1ULL &lt;&lt; PDESHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDEMASK</span>         (NBPDE - 1)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTE_PER_PAGE</span>	512 <span class="enscript-comment">/* number of PTE's per page on any level */</span>

 <span class="enscript-comment">/* cleanly define parameters for all the page table levels */</span>
<span class="enscript-type">typedef</span> uint64_t        pml4_entry_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPML4PG</span>         (PAGE_SIZE/(sizeof (pml4_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PML4SHIFT</span>       39
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PML4PGSHIFT</span>     9
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBPML4</span>          (1ULL &lt;&lt; PML4SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PML4MASK</span>        (NBPML4-1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PML4_ENTRY_NULL</span> ((pml4_entry_t *) 0)

<span class="enscript-type">typedef</span> uint64_t        pdpt_entry_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPDPTPG</span>         (PAGE_SIZE/(sizeof (pdpt_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDPTSHIFT</span>       30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDPTPGSHIFT</span>     9
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBPDPT</span>          (1ULL &lt;&lt; PDPTSHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDPTMASK</span>        (NBPDPT-1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDPT_ENTRY_NULL</span> ((pdpt_entry_t *) 0)

<span class="enscript-type">typedef</span> uint64_t        pd_entry_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPDPG</span>           (PAGE_SIZE/(sizeof (pd_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDSHIFT</span>         21
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDPGSHIFT</span>       9
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBPD</span>            (1ULL &lt;&lt; PDSHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PDMASK</span>          (NBPD-1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PD_ENTRY_NULL</span>   ((pd_entry_t *) 0)

<span class="enscript-type">typedef</span> uint64_t        pt_entry_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPTPG</span>           (PAGE_SIZE/(sizeof (pt_entry_t)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTSHIFT</span>         12
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTPGSHIFT</span>       9
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBPT</span>            (1ULL &lt;&lt; PTSHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTMASK</span>          (NBPT-1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PT_ENTRY_NULL</span>	((pt_entry_t *) 0)

<span class="enscript-type">typedef</span> uint64_t  pmap_paddr_t;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_ASSERT</span> 1
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PMAP_ASSERT</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pmap_assert</span>(ex) ((ex) ? (void)0 : Assert(__FILE__, __LINE__, # ex))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_assert2</span>(ex, fmt, args...)					\
	<span class="enscript-keyword">do</span> {								\
		<span class="enscript-keyword">if</span> (!(ex)) {						\
			kprintf(<span class="enscript-string">&quot;Assertion %s failed (%s:%d, caller %p) &quot;</span> fmt , #ex, __FILE__, __LINE__, __builtin_return_address(0),  ##args); \
			panic(<span class="enscript-string">&quot;Assertion %s failed (%s:%d, caller %p) &quot;</span> fmt , #ex, __FILE__, __LINE__, __builtin_return_address(0),  ##args); 		\
		}							\
	} <span class="enscript-keyword">while</span>(0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_assert</span>(ex)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_assert2</span>(ex, fmt, args...)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* superpages */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPERPAGE_NBASEPAGES</span> 512
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPERPAGE_NBASEPAGES</span> 1	<span class="enscript-comment">/* we don't support superpages on i386 */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Atomic 64-bit store of a page table entry.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">pmap_store_pte</span>(pt_entry_t *entryp, pt_entry_t value)
{
	<span class="enscript-comment">/*
	 * In the 32-bit kernel a compare-and-exchange loop was
	 * required to provide atomicity. For K64, life is easier:
	 */</span>
	*entryp = value;
}

<span class="enscript-comment">/* in 64 bit spaces, the number of each type of page in the page tables */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPML4PGS</span>        (1ULL * (PAGE_SIZE/(sizeof (pml4_entry_t))))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPDPTPGS</span>        (NPML4PGS * (PAGE_SIZE/(sizeof (pdpt_entry_t))))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPDEPGS</span>         (NPDPTPGS * (PAGE_SIZE/(sizeof (pd_entry_t))))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPTEPGS</span>         (NPDEPGS * (PAGE_SIZE/(sizeof (pt_entry_t))))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_PML4_INDEX</span>		511
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_KEXTS_INDEX</span>	510	<span class="enscript-comment">/* Home of KEXTs - the basement */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_PHYSMAP_PML4_INDEX</span>	509	<span class="enscript-comment">/* virtual to physical map */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_BASE</span>		(0ULL - NBPML4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_BASEMENT</span>		(KERNEL_BASE - NBPML4)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_WIMG_COPYBACK</span>	VM_MEM_COHERENT
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_WIMG_COPYBACKLW</span>	VM_WIMG_COPYBACK
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_WIMG_DEFAULT</span>		VM_MEM_COHERENT
<span class="enscript-comment">/* ?? intel ?? */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_WIMG_IO</span>		(VM_MEM_COHERENT | 	\
				VM_MEM_NOT_CACHEABLE | VM_MEM_GUARDED)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_WIMG_WTHRU</span>		(VM_MEM_WRITE_THROUGH | VM_MEM_COHERENT | VM_MEM_GUARDED)
<span class="enscript-comment">/* write combining mode, aka store gather */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_WIMG_WCOMB</span>		(VM_MEM_NOT_CACHEABLE | VM_MEM_COHERENT) 
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_WIMG_INNERWBACK</span>	VM_MEM_COHERENT
<span class="enscript-comment">/*
 * Pte related macros
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KVADDR</span>(pmi, pdpi, pdi, pti)		  \
	 ((vm_offset_t)			  \
		((uint64_t) -1    &lt;&lt; 47)        | \
		((uint64_t)(pmi)  &lt;&lt; PML4SHIFT) | \
		((uint64_t)(pdpi) &lt;&lt; PDPTSHIFT) | \
		((uint64_t)(pdi)  &lt;&lt; PDESHIFT)  | \
		((uint64_t)(pti)  &lt;&lt; PTESHIFT))

<span class="enscript-comment">/*
 * Size of Kernel address space.  This is the number of page table pages
 * (4MB each) to use for the kernel.  256 pages == 1 Gigabyte.
 * This **MUST** be a multiple of 4 (eg: 252, 256, 260, etc).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KVA_PAGES</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KVA_PAGES</span>	1024
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NKPT</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NKPT</span>		500	<span class="enscript-comment">/* actual number of kernel page tables */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NKPDE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NKPDE</span>	(KVA_PAGES - 1)	<span class="enscript-comment">/* addressable number of page tables/pde's */</span>
#<span class="enscript-reference">endif</span>



<span class="enscript-comment">/*
 *	Convert address offset to page descriptor index
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pdptnum</span>(pmap, a) (((vm_offset_t)(a) &gt;&gt; PDPTSHIFT) &amp; PDPTMASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pdenum</span>(pmap, a)	(((vm_offset_t)(a) &gt;&gt; PDESHIFT) &amp; PDEMASK)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_INVALID_PDPTNUM</span> (~0ULL)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">pdeidx</span>(pmap, a)    (((a) &gt;&gt; PDSHIFT)   &amp; ((1ULL&lt;&lt;(48 - PDSHIFT)) -1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pdptidx</span>(pmap, a)   (((a) &gt;&gt; PDPTSHIFT) &amp; ((1ULL&lt;&lt;(48 - PDPTSHIFT)) -1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pml4idx</span>(pmap, a)   (((a) &gt;&gt; PML4SHIFT) &amp; ((1ULL&lt;&lt;(48 - PML4SHIFT)) -1))


<span class="enscript-comment">/*
 *	Convert page descriptor index to user virtual address
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pdetova</span>(a)	((vm_offset_t)(a) &lt;&lt; PDESHIFT)

<span class="enscript-comment">/*
 *	Convert address offset to page table index
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ptenum</span>(a)	(((vm_offset_t)(a) &gt;&gt; PTESHIFT) &amp; PTEMASK)

<span class="enscript-comment">/*
 *	Hardware pte bit definitions (to be used directly on the ptes
 *	without using the bit fields).
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_VALID</span>		0x00000001ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_WRITE</span>		0x00000002ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_RW</span>		0x00000002ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_USER</span>		0x00000004ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_WTHRU</span>		0x00000008ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_NCACHE</span> 	0x00000010ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_REF</span>		0x00000020ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_MOD</span>		0x00000040ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_PS</span>		0x00000080ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_PTA</span>		0x00000080ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_GLOBAL</span>	0x00000100ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_WIRED</span>		0x00000400ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PDPTE_NESTED</span>	0x00000800ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_PFN</span>		PG_FRAME

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_NX</span>		(1ULL &lt;&lt; 63)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_INVALID</span>       0
<span class="enscript-comment">/* This is conservative, but suffices */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_PTE_RSVD</span>		((1ULL &lt;&lt; 10) | (1ULL &lt;&lt; 11) | (0x1FFULL &lt;&lt; 54))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_COMPRESSED</span>	(1ULL &lt;&lt; 62) <span class="enscript-comment">/* marker, for invalid PTE only -- ignored by hardware for both regular/EPT entries*/</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pa_to_pte</span>(a)		((a) &amp; INTEL_PTE_PFN) <span class="enscript-comment">/* XXX */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pte_to_pa</span>(p)		((p) &amp; INTEL_PTE_PFN) <span class="enscript-comment">/* XXX */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pte_increment_pa</span>(p)	((p) += INTEL_OFFMASK+1)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">pte_kernel_rw</span>(p)          ((pt_entry_t)(pa_to_pte(p) | INTEL_PTE_VALID|INTEL_PTE_RW))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pte_kernel_ro</span>(p)          ((pt_entry_t)(pa_to_pte(p) | INTEL_PTE_VALID))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pte_user_rw</span>(p)            ((pt_entry_t)(pa_to_pte(p) | INTEL_PTE_VALID|INTEL_PTE_USER|INTEL_PTE_RW))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pte_user_ro</span>(p)            ((pt_entry_t)(pa_to_pte(p) | INTEL_PTE_VALID|INTEL_PTE_USER))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_INVEPT_SINGLE_CONTEXT</span>	1


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPTP_AD</span>		0x00000040ULL

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_READ</span>		0x00000001ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_WRITE</span> 	0x00000002ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_EX</span>		0x00000004ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_IPTA</span>		0x00000040ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_PS</span>		0x00000080ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_REF</span>		0x00000100ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_MOD</span>		0x00000200ULL

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_CACHE_MASK</span> 	0x00000038ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_NCACHE</span>	0x00000000ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_WC</span>		0x00000008ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_WTHRU</span> 	0x00000020ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_WP</span>    	0x00000028ULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTEL_EPT_WB</span>		0x00000030ULL

<span class="enscript-comment">/*
 * Routines to filter correct bits depending on the pmap type
 */</span>

<span class="enscript-type">static</span> inline pt_entry_t
<span class="enscript-function-name">pte_remove_ex</span>(pt_entry_t pte, boolean_t is_ept)
{
	<span class="enscript-keyword">if</span> (__probable(!is_ept)) {
		<span class="enscript-keyword">return</span> (pte | INTEL_PTE_NX);
	}

	<span class="enscript-keyword">return</span> (pte &amp; (~INTEL_EPT_EX));
}

<span class="enscript-type">static</span> inline pt_entry_t
<span class="enscript-function-name">pte_set_ex</span>(pt_entry_t pte, boolean_t is_ept)
{
	<span class="enscript-keyword">if</span> (__probable(!is_ept)) {
		<span class="enscript-keyword">return</span> (pte &amp; (~INTEL_PTE_NX));
	}

	<span class="enscript-keyword">return</span> (pte | INTEL_EPT_EX);
}

<span class="enscript-type">static</span> inline pt_entry_t
<span class="enscript-function-name">physmap_refmod_to_ept</span>(pt_entry_t physmap_pte)
{
	pt_entry_t ept_pte = 0;

	<span class="enscript-keyword">if</span> (physmap_pte &amp; INTEL_PTE_MOD) {
		ept_pte |= INTEL_EPT_MOD;
	}

	<span class="enscript-keyword">if</span> (physmap_pte &amp; INTEL_PTE_REF) {
		ept_pte |= INTEL_EPT_REF;
	}

	<span class="enscript-keyword">return</span> ept_pte;
}

<span class="enscript-type">static</span> inline pt_entry_t
<span class="enscript-function-name">ept_refmod_to_physmap</span>(pt_entry_t ept_pte)
{
	pt_entry_t physmap_pte = 0;

	assert((ept_pte &amp; ~(INTEL_EPT_REF | INTEL_EPT_MOD)) == 0);

	<span class="enscript-keyword">if</span> (ept_pte &amp; INTEL_EPT_REF) {
		physmap_pte |= INTEL_PTE_REF;
	}

	<span class="enscript-keyword">if</span> (ept_pte &amp; INTEL_EPT_MOD) {
		physmap_pte |= INTEL_PTE_MOD;
	}

	<span class="enscript-keyword">return</span> physmap_pte;
}

<span class="enscript-comment">/*
 * Note: Not all Intel processors support EPT referenced access and dirty bits.
 *	 During pmap_init() we check the VMX capability for the current hardware
 *	 and update this variable accordingly.
 */</span>
<span class="enscript-type">extern</span> boolean_t pmap_ept_support_ad;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_VALID_MASK</span>(is_ept)	((is_ept) ? (INTEL_EPT_READ | INTEL_EPT_WRITE | INTEL_EPT_EX) : INTEL_PTE_VALID)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_READ</span>(is_ept)	((is_ept) ? INTEL_EPT_READ : INTEL_PTE_VALID)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_WRITE</span>(is_ept)	((is_ept) ? INTEL_EPT_WRITE : INTEL_PTE_WRITE)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTE_PS</span>			INTEL_PTE_PS
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTE_COMPRESSED</span>		INTEL_COMPRESSED
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_NCACHE</span>(is_ept)	((is_ept) ? INTEL_EPT_NCACHE : INTEL_PTE_NCACHE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_WTHRU</span>(is_ept)	((is_ept) ? INTEL_EPT_WTHRU : INTEL_PTE_WTHRU)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_REF</span>(is_ept) 	((is_ept) ? INTEL_EPT_REF : INTEL_PTE_REF)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTE_MOD</span>(is_ept) 	((is_ept) ? INTEL_EPT_MOD : INTEL_PTE_MOD)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTE_WIRED</span>		INTEL_PTE_WIRED


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_DEFAULT_CACHE</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_INHIBIT_CACHE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_GUARDED_CACHE</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_ACTIVATE_CACHE</span>	4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_NO_GUARD_CACHE</span>	8

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">ASSEMBLER</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>

<span class="enscript-comment">/*
 * Address of current and alternate address space page table maps
 * and directories.
 */</span>

<span class="enscript-type">extern</span> pt_entry_t	*PTmap;
<span class="enscript-type">extern</span> pdpt_entry_t	*IdlePDPT;
<span class="enscript-type">extern</span> pml4_entry_t	*IdlePML4;
<span class="enscript-type">extern</span> boolean_t	no_shared_cr3;
<span class="enscript-type">extern</span> addr64_t		kernel64_cr3;
<span class="enscript-type">extern</span> pd_entry_t	*IdlePTD;	<span class="enscript-comment">/* physical addr of &quot;Idle&quot; state PTD */</span>

<span class="enscript-type">extern</span> uint64_t		pmap_pv_hashlist_walks;
<span class="enscript-type">extern</span> uint64_t		pmap_pv_hashlist_cnts;
<span class="enscript-type">extern</span> uint32_t		pmap_pv_hashlist_max;
<span class="enscript-type">extern</span> uint32_t		pmap_kernel_text_ps;



#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ID_MAP_VTOP</span>(x)	((void *)(((uint64_t)(x)) &amp; LOW_4GB_MASK))

<span class="enscript-type">extern</span>	uint64_t physmap_base, physmap_max;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NPHYSMAP</span> (MAX(K64_MAXMEM/GB + 4, 4))

<span class="enscript-type">static</span> inline boolean_t <span class="enscript-function-name">physmap_enclosed</span>(addr64_t a) {
	<span class="enscript-keyword">return</span> (a &lt; (NPHYSMAP * GB));
}

<span class="enscript-type">static</span>	inline <span class="enscript-type">void</span> * PHYSMAP_PTOV_check(<span class="enscript-type">void</span> *paddr) {
	uint64_t pvaddr = (uint64_t)paddr + physmap_base;

	<span class="enscript-keyword">if</span> (__improbable(pvaddr &gt;= physmap_max))
		panic(<span class="enscript-string">&quot;PHYSMAP_PTOV bounds exceeded, 0x%qx, 0x%qx, 0x%qx&quot;</span>,
		      pvaddr, physmap_base, physmap_max);

	<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *)pvaddr;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PHYSMAP_PTOV</span>(x)	(PHYSMAP_PTOV_check((void*) (x)))

<span class="enscript-comment">/*
 * For KASLR, we alias the master processor's IDT and GDT at fixed
 * virtual addresses to defeat SIDT/SGDT address leakage.
 * And non-boot processor's GDT aliases likewise (skipping LOWGLOBAL_ALIAS)
 * The low global vector page is mapped at a fixed alias also.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASTER_IDT_ALIAS</span>	(VM_MIN_KERNEL_ADDRESS + 0x0000)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MASTER_GDT_ALIAS</span>	(VM_MIN_KERNEL_ADDRESS + 0x1000)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOWGLOBAL_ALIAS</span>		(VM_MIN_KERNEL_ADDRESS + 0x2000)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_GDT_ALIAS</span>(_cpu)	(LOWGLOBAL_ALIAS + (0x1000*(_cpu)))

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*__x86_64__ */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>

<span class="enscript-comment">/*
 *	For each vm_page_t, there is a list of all currently
 *	valid virtual mappings of that page.  An entry is
 *	a pv_entry_t; the list is the pv_table.
 */</span>

<span class="enscript-type">struct</span> pmap {
	decl_simple_lock_data(,lock)	<span class="enscript-comment">/* lock on map */</span>
	pmap_paddr_t    pm_cr3;         <span class="enscript-comment">/* physical addr */</span>
	pmap_paddr_t	pm_eptp;	<span class="enscript-comment">/* EPTP */</span>
	boolean_t       pm_shared;
        pd_entry_t      *dirbase;        <span class="enscript-comment">/* page directory pointer */</span>
        vm_object_t     pm_obj;         <span class="enscript-comment">/* object to hold pde's */</span>
        task_map_t      pm_task_map;
        pdpt_entry_t    *pm_pdpt;       <span class="enscript-comment">/* KVA of 3rd level page */</span>
	pml4_entry_t    *pm_pml4;       <span class="enscript-comment">/* VKA of top level */</span>
	vm_object_t     pm_obj_pdpt;    <span class="enscript-comment">/* holds pdpt pages */</span>
	vm_object_t     pm_obj_pml4;    <span class="enscript-comment">/* holds pml4 pages */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PMAP_PCID_MAX_CPUS</span>	MAX_CPUS	<span class="enscript-comment">/* Must be a multiple of 8 */</span>
	pcid_t		pmap_pcid_cpus[PMAP_PCID_MAX_CPUS];
	<span class="enscript-type">volatile</span> uint8_t pmap_pcid_coherency_vector[PMAP_PCID_MAX_CPUS];
	<span class="enscript-type">struct</span> pmap_statistics	stats;	<span class="enscript-comment">/* map statistics */</span>
	<span class="enscript-type">int</span>		ref_count;	<span class="enscript-comment">/* reference count */</span>
        <span class="enscript-type">int</span>		nx_enabled;
	ledger_t	ledger;		<span class="enscript-comment">/* ledger tracking phys mappings */</span>
};

<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">is_ept_pmap</span>(pmap_t p)
{
	<span class="enscript-keyword">if</span> (__probable(p-&gt;pm_cr3 != 0)) {
		assert(p-&gt;pm_eptp == 0);
		<span class="enscript-keyword">return</span> FALSE;
	}

	assert(p-&gt;pm_eptp != 0);

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">hv_ept_pmap_create</span>(<span class="enscript-type">void</span> **ept_pmap, <span class="enscript-type">void</span> **eptp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PDPT_FIRST_WINDOW</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PDPT_NWINDOWS</span> 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PDE_FIRST_WINDOW</span> (PMAP_PDPT_NWINDOWS)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PDE_NWINDOWS</span> 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PTE_FIRST_WINDOW</span> (PMAP_PDE_FIRST_WINDOW + PMAP_PDE_NWINDOWS)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_PTE_NWINDOWS</span> 4

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_NWINDOWS_FIRSTFREE</span> (PMAP_PTE_FIRST_WINDOW + PMAP_PTE_NWINDOWS)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_WINDOW_SIZE</span> 8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_NWINDOWS</span> (PMAP_NWINDOWS_FIRSTFREE + PMAP_WINDOW_SIZE)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	pt_entry_t	*prv_CMAP;
	caddr_t		prv_CADDR;
} mapwindow_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cpu_pmap {
        <span class="enscript-type">int</span>                     pdpt_window_index;
        <span class="enscript-type">int</span>                     pde_window_index;
        <span class="enscript-type">int</span>                     pte_window_index;
	mapwindow_t		mapwindow[PMAP_NWINDOWS];
} cpu_pmap_t;


<span class="enscript-type">extern</span> mapwindow_t *<span class="enscript-function-name">pmap_get_mapwindow</span>(pt_entry_t pentry);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>         <span class="enscript-function-name">pmap_put_mapwindow</span>(mapwindow_t *map);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> pmap_memory_regions {
	ppnum_t base;		<span class="enscript-comment">/* first page of this region */</span>
	ppnum_t alloc_up;	<span class="enscript-comment">/* pages below this one have been &quot;stolen&quot; */</span>
	ppnum_t alloc_down;	<span class="enscript-comment">/* pages above this one have been &quot;stolen&quot; */</span>
	ppnum_t end;		<span class="enscript-comment">/* last page of this region */</span>
	uint32_t type;
	uint64_t attribute;
} pmap_memory_region_t;

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> pmap_memory_region_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> pmap_memory_region_current;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PMAP_MEMORY_REGIONS_SIZE</span> 128

<span class="enscript-type">extern</span> pmap_memory_region_t pmap_memory_regions[];
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap_pcid.h&gt;</span>

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">set_dirbase</span>(pmap_t tpmap, __unused thread_t thread, <span class="enscript-type">int</span> my_cpu) {
	<span class="enscript-type">int</span> ccpu = my_cpu;
	cpu_datap(ccpu)-&gt;cpu_task_cr3 = tpmap-&gt;pm_cr3;
	cpu_datap(ccpu)-&gt;cpu_task_map = tpmap-&gt;pm_task_map;
	<span class="enscript-comment">/*
	 * Switch cr3 if necessary
	 * - unless running with no_shared_cr3 debugging mode
	 *   and we're not on the kernel's cr3 (after pre-empted copyio)
	 */</span>
	<span class="enscript-keyword">if</span> (__probable(!no_shared_cr3)) {
		<span class="enscript-keyword">if</span> (get_cr3_base() != tpmap-&gt;pm_cr3) {
			<span class="enscript-keyword">if</span> (pmap_pcid_ncpus) {
				pmap_pcid_activate(tpmap, ccpu);
			}
			<span class="enscript-keyword">else</span>
				set_cr3_raw(tpmap-&gt;pm_cr3);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (get_cr3_base() != cpu_datap(ccpu)-&gt;cpu_kernel_cr3)
			set_cr3_raw(cpu_datap(ccpu)-&gt;cpu_kernel_cr3);
	}
}

<span class="enscript-comment">/*
 *	External declarations for PMAP_ACTIVATE.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		process_pmap_updates(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		pmap_update_interrupt(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 *	Machine dependent routines that are used only for i386/i486/i860.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-function-name">addr64_t</span>		(kvtophys)(
				vm_offset_t	addr);

<span class="enscript-type">extern</span> kern_return_t	pmap_expand(
				pmap_t		pmap,
				vm_map_offset_t	addr,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> options);
#<span class="enscript-reference">if</span>	!<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> pt_entry_t	*pmap_pte(
				<span class="enscript-type">struct</span> pmap	*pmap,
				vm_map_offset_t	addr);

<span class="enscript-type">extern</span> pd_entry_t	*pmap_pde(
				<span class="enscript-type">struct</span> pmap	*pmap,
				vm_map_offset_t	addr);

<span class="enscript-type">extern</span> pd_entry_t	*pmap64_pde(
				<span class="enscript-type">struct</span> pmap	*pmap,
				vm_map_offset_t	addr);

<span class="enscript-type">extern</span> pdpt_entry_t	*pmap64_pdpt(
				<span class="enscript-type">struct</span> pmap	*pmap,
				vm_map_offset_t	addr);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> vm_offset_t	pmap_map(
				vm_offset_t	virt,
				vm_map_offset_t	start,
				vm_map_offset_t	end,
				vm_prot_t	prot,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	flags);

<span class="enscript-type">extern</span> vm_offset_t	pmap_map_bd(
				vm_offset_t	virt,
				vm_map_offset_t	start,
				vm_map_offset_t	end,
				vm_prot_t	prot,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	flags);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		pmap_bootstrap(
				vm_offset_t	load_start,
				boolean_t	IA32e);

<span class="enscript-type">extern</span> boolean_t	pmap_valid_page(
				ppnum_t	pn);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		pmap_list_resident_pages(
				<span class="enscript-type">struct</span> pmap	*pmap,
				vm_offset_t	*listp,
				<span class="enscript-type">int</span>		space);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		x86_filter_TLB_coherency_interrupts(boolean_t);
<span class="enscript-comment">/*
 * Get cache attributes (as pagetable bits) for the specified phys page
 */</span>
<span class="enscript-type">extern</span>	<span class="enscript-type">unsigned</span>	pmap_get_cache_attributes(ppnum_t, boolean_t is_ept);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> cpu_pmap	*pmap_cpu_alloc(
				boolean_t	is_boot_cpu);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		pmap_cpu_free(
				<span class="enscript-type">struct</span> cpu_pmap	*cp);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		pmap_map_block(
				pmap_t pmap, 
				addr64_t va,
				ppnum_t pa,
				uint32_t size,
				vm_prot_t prot,
				<span class="enscript-type">int</span> attr,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
				
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">invalidate_icache</span>(vm_offset_t addr, <span class="enscript-type">unsigned</span> cnt, <span class="enscript-type">int</span> phys);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">flush_dcache</span>(vm_offset_t addr, <span class="enscript-type">unsigned</span> count, <span class="enscript-type">int</span> phys);
<span class="enscript-type">extern</span> ppnum_t          <span class="enscript-function-name">pmap_find_phys</span>(pmap_t map, addr64_t va);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pmap_cpu_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pmap_disable_NX</span>(pmap_t pmap);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pt_fake_zone_init</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pt_fake_zone_info</span>(<span class="enscript-type">int</span> *, vm_size_t *, vm_size_t *, vm_size_t *, vm_size_t *, 
			      uint64_t *, <span class="enscript-type">int</span> *, <span class="enscript-type">int</span> *, <span class="enscript-type">int</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pmap_pagetable_corruption_msg_log</span>(<span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * fmt, ...)__printflike(1,2));

<span class="enscript-comment">/*
 *	Macros for speed.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>

				  
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_ACTIVATE_MAP</span>(map, thread, my_cpu)	{				\
	<span class="enscript-type">register</span> pmap_t		tpmap;					\
                                                                        \
        tpmap = vm_map_pmap(map);					\
        set_dirbase(tpmap, thread, my_cpu);					\
}

#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_DEACTIVATE_MAP</span>(map, thread, ccpu)				\
	pmap_assert(pmap_pcid_ncpus ? (pcid_for_pmap_cpu_tuple(map-&gt;pmap, ccpu) == (get_cr3_raw() &amp; 0xFFF)) : TRUE);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_DEACTIVATE_MAP</span>(map, thread)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PMAP_SWITCH_CONTEXT</span>(old_th, new_th, my_cpu) {			\
                                                                        \
	pmap_assert(ml_get_interrupts_enabled() == FALSE);		\
	<span class="enscript-keyword">if</span> (old_th-&gt;map != new_th-&gt;map) {				\
		PMAP_DEACTIVATE_MAP(old_th-&gt;map, old_th, my_cpu);		\
		PMAP_ACTIVATE_MAP(new_th-&gt;map, new_th, my_cpu);		\
	}								\
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PMAP_SWITCH_USER</span>(th, new_map, my_cpu) {				\
	spl_t		spl;						\
									\
	spl = splhigh();						\
	PMAP_DEACTIVATE_MAP(th-&gt;map, th);				\
	th-&gt;map = new_map;						\
	PMAP_ACTIVATE_MAP(th-&gt;map, th);					\
	splx(spl);							\
	inval_copy_windows(th);						\
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PMAP_SWITCH_USER</span>(th, new_map, my_cpu) {				\
	spl_t		spl;						\
									\
	spl = splhigh();						\
	PMAP_DEACTIVATE_MAP(th-&gt;map, th, my_cpu);				\
	th-&gt;map = new_map;						\
	PMAP_ACTIVATE_MAP(th-&gt;map, th, my_cpu);				\
	splx(spl);							\
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Marking the current cpu's cr3 inactive is achieved by setting its lsb.
 * Marking the current cpu's cr3 active once more involves clearng this bit.
 * Note that valid page tables are page-aligned and so the bottom 12 bits
 * are normally zero, modulo PCID.
 * We can only mark the current cpu active/inactive but we can test any cpu.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_CR3_MARK_INACTIVE</span>()						\
	current_cpu_datap()-&gt;cpu_active_cr3 |= 1

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_CR3_MARK_ACTIVE</span>()	 					\
	current_cpu_datap()-&gt;cpu_active_cr3 &amp;= ~1

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_CR3_IS_ACTIVE</span>(cpu)						\
	((cpu_datap(cpu)-&gt;cpu_active_cr3 &amp; 1) == 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_GET_ACTIVE_CR3</span>(cpu)						\
	(cpu_datap(cpu)-&gt;cpu_active_cr3 &amp; ~1)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CPU_GET_TASK_CR3</span>(cpu)						\
	(cpu_datap(cpu)-&gt;cpu_task_cr3)

<span class="enscript-comment">/*
 *	Mark this cpu idle, and remove it from the active set,
 *	since it is not actively using any pmap.  Signal_cpus
 *	will notice that it is idle, and avoid signaling it,
 *	but will queue the update request for when the cpu
 *	becomes active.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MARK_CPU_IDLE</span>(my_cpu)	{					\
	assert(ml_get_interrupts_enabled() == FALSE);			\
	CPU_CR3_MARK_INACTIVE();					\
	mfence();									\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MARK_CPU_ACTIVE</span>(my_cpu) {					\
	assert(ml_get_interrupts_enabled() == FALSE);			\
	<span class="enscript-comment">/*								\
	 *	If a kernel_pmap update was requested while this cpu	\
	 *	was idle, process it as if we got the interrupt.	\
	 *	Before doing so, remove this cpu from the idle set.	\
	 *	Since we do not grab any pmap locks while we flush	\
	 *	our TLB, another cpu may start an update operation	\
	 *	before we finish.  Removing this cpu from the idle	\
	 *	set assures that we will receive another update		\
	 *	interrupt if this happens.				\
	 */</span>								\
	CPU_CR3_MARK_ACTIVE();						\
	mfence();									\
									\
	<span class="enscript-keyword">if</span> (current_cpu_datap()-&gt;cpu_tlb_invalid)			\
	    process_pmap_updates();					\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMAP_CONTEXT</span>(pmap, thread)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_kernel_va</span>(VA)	\
	((((vm_offset_t) (VA)) &gt;= vm_min_kernel_address) &amp;&amp;	\
	 (((vm_offset_t) (VA)) &lt;= vm_max_kernel_address))


#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_compressed</span>(pmap)		((pmap)-&gt;stats.compressed)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_resident_count</span>(pmap)	((pmap)-&gt;stats.resident_count)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pmap_resident_max</span>(pmap)		((pmap)-&gt;stats.resident_max)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pmap_copy</span>(dst_pmap,src_pmap,dst_addr,len,src_addr)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pmap_attribute</span>(pmap,addr,size,attr,value) \
					(KERN_INVALID_ADDRESS)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">pmap_attribute_cache_sync</span>(addr,size,attr,value) \
					(KERN_INVALID_ADDRESS)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACHINE_PMAP_IS_EMPTY</span>	1
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">pmap_is_empty</span>(pmap_t		pmap,
			       vm_map_offset_t	start,
			       vm_map_offset_t	end);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACHINE_BOOTSTRAPPTD</span>	1	<span class="enscript-comment">/* Static bootstrap page-tables */</span>

kern_return_t
<span class="enscript-function-name">pmap_permissions_verify</span>(pmap_t, vm_map_t, vm_offset_t, vm_offset_t);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ASSEMBLER */</span>


#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _PMAP_MACHINE_ */</span>


#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* KERNEL_PRIVATE */</span>
</pre>
<hr />
</body></html>