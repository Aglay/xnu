<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>trap.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">trap.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
* @OSF_COPYRIGHT@
*/</span>
<span class="enscript-comment">/* 
* Mach Operating System
* Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
* All Rights Reserved.
* 
* Permission to use, copy, modify and distribute this software and its
* documentation is hereby granted, provided that both the copyright
* notice and this permission notice appear in all copies of the
* software, derivative works or modified versions, and any portions
* thereof, and that both notices appear in supporting documentation.
* 
* CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
* CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
* ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
* 
* Carnegie Mellon requests users of this software to return to
* 
*  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
*  School of Computer Science
*  Carnegie Mellon University
*  Pittsburgh PA 15213-3890
* 
* any improvements or extensions that they make and grant Carnegie Mellon
* the rights to redistribute these changes.
*/</span>
<span class="enscript-comment">/*
*/</span>

<span class="enscript-comment">/*
* Hardware trap/fault handler.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_kdp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/eflags.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/trap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span> <span class="enscript-comment">/* panic_io_port_read() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/lapic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/thread_status.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/exception.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/telemetry.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;prng/random.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/postcode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MCA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_check.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/syscall_sw.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_threads.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">throttle_lowpri_io</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kprint_state</span>(x86_saved_state64_t *saved_state);

<span class="enscript-comment">/*
 * Forward declarations
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">user_page_fault_continue</span>(kern_return_t kret);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">panic_trap</span>(x86_saved_state64_t *saved_state, uint32_t pl);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">set_recovery_ip</span>(x86_saved_state64_t *saved_state, vm_offset_t ip);

<span class="enscript-type">volatile</span> perfCallback perfTrapHook = NULL; <span class="enscript-comment">/* Pointer to CHUD trap hook routine */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-comment">/* See &lt;rdar://problem/4613924&gt; */</span>
perfCallback tempDTraceTrapHook = NULL; <span class="enscript-comment">/* Pointer to DTrace fbt trap hook routine */</span>

<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">dtrace_tally_fault</span>(user_addr_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> boolean_t pmap_smep_enabled;
<span class="enscript-type">extern</span> boolean_t pmap_smap_enabled;

<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_syscall_return</span>(
        kern_return_t ret)
{
        thread_t	thr_act = current_thread();
	boolean_t	is_mach;
	<span class="enscript-type">int</span>		code;

	pal_register_cache_state(thr_act, DIRTY);

        <span class="enscript-keyword">if</span> (thread_is_64bit(thr_act)) {
	        x86_saved_state64_t	*regs;
		
		regs = USER_REGS64(thr_act);

		code = (<span class="enscript-type">int</span>) (regs-&gt;rax &amp; SYSCALL_NUMBER_MASK);
		is_mach = (regs-&gt;rax &amp; SYSCALL_CLASS_MASK)
			    == (SYSCALL_CLASS_MACH &lt;&lt; SYSCALL_CLASS_SHIFT);
		<span class="enscript-keyword">if</span> (kdebug_enable &amp;&amp; is_mach) {
		        <span class="enscript-comment">/* Mach trap */</span>
		        KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
			      MACHDBG_CODE(DBG_MACH_EXCP_SC,code)|DBG_FUNC_END,
			      ret, 0, 0, 0, 0);
		}
		regs-&gt;rax = ret;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> (is_mach)
			DEBUG_KPRINT_SYSCALL_MACH(
				<span class="enscript-string">&quot;thread_syscall_return: 64-bit mach ret=%u\n&quot;</span>,
				ret);
		<span class="enscript-keyword">else</span>
			DEBUG_KPRINT_SYSCALL_UNIX(
				<span class="enscript-string">&quot;thread_syscall_return: 64-bit unix ret=%u\n&quot;</span>,
				ret);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
	        x86_saved_state32_t	*regs;
		
		regs = USER_REGS32(thr_act);

		code = ((<span class="enscript-type">int</span>) regs-&gt;eax);
		is_mach = (code &lt; 0);
		<span class="enscript-keyword">if</span> (kdebug_enable &amp;&amp; is_mach) {
		        <span class="enscript-comment">/* Mach trap */</span>
		        KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
			      MACHDBG_CODE(DBG_MACH_EXCP_SC,-code)|DBG_FUNC_END,
			      ret, 0, 0, 0, 0);
		}
		regs-&gt;eax = ret;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> (is_mach)
			DEBUG_KPRINT_SYSCALL_MACH(
				<span class="enscript-string">&quot;thread_syscall_return: 32-bit mach ret=%u\n&quot;</span>,
				ret);
		<span class="enscript-keyword">else</span>
			DEBUG_KPRINT_SYSCALL_UNIX(
				<span class="enscript-string">&quot;thread_syscall_return: 32-bit unix ret=%u\n&quot;</span>,
				ret);
#<span class="enscript-reference">endif</span>
	}
	throttle_lowpri_io(1);

	thread_exception_return();
        <span class="enscript-comment">/*NOTREACHED*/</span>
}


<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">user_page_fault_continue</span>(
			 kern_return_t	kr)
{
	thread_t	thread = current_thread();
	user_addr_t	vaddr;

	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		x86_saved_state64_t	*uregs;

		uregs = USER_REGS64(thread);

		vaddr = (user_addr_t)uregs-&gt;cr2;
	} <span class="enscript-keyword">else</span> {
	        x86_saved_state32_t	*uregs;

		uregs = USER_REGS32(thread);

		vaddr = uregs-&gt;cr2;
	}


	<span class="enscript-comment">/* PAL debug hook */</span>
	pal_dbg_page_fault( thread, vaddr, kr );

	i386_exception(EXC_BAD_ACCESS, kr, vaddr);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/*
 * Fault recovery in copyin/copyout routines.
 */</span>
<span class="enscript-type">struct</span> recovery {
	uintptr_t	fault_addr;
	uintptr_t	recover_addr;
};

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> recovery	recover_table[];
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> recovery	recover_table_end[];

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *	trap_type[] = {TRAP_NAMES};
<span class="enscript-type">unsigned</span> 	TRAP_TYPES = <span class="enscript-keyword">sizeof</span>(trap_type)/<span class="enscript-keyword">sizeof</span>(trap_type[0]);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	PE_incoming_interrupt(<span class="enscript-type">int</span> interrupt);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>) &amp;&amp; <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kprint_state</span>(x86_saved_state64_t	*saved_state)
{
	kprintf(<span class="enscript-string">&quot;current_cpu_datap() 0x%lx\n&quot;</span>, (uintptr_t)current_cpu_datap());
	kprintf(<span class="enscript-string">&quot;Current GS base MSR 0x%llx\n&quot;</span>, rdmsr64(MSR_IA32_GS_BASE));
	kprintf(<span class="enscript-string">&quot;Kernel  GS base MSR 0x%llx\n&quot;</span>, rdmsr64(MSR_IA32_KERNEL_GS_BASE));
	kprintf(<span class="enscript-string">&quot;state at 0x%lx:\n&quot;</span>, (uintptr_t) saved_state);

	kprintf(<span class="enscript-string">&quot;      rdi    0x%llx\n&quot;</span>, saved_state-&gt;rdi);        
	kprintf(<span class="enscript-string">&quot;      rsi    0x%llx\n&quot;</span>, saved_state-&gt;rsi);    
	kprintf(<span class="enscript-string">&quot;      rdx    0x%llx\n&quot;</span>, saved_state-&gt;rdx);
	kprintf(<span class="enscript-string">&quot;      r10    0x%llx\n&quot;</span>, saved_state-&gt;r10);
	kprintf(<span class="enscript-string">&quot;      r8     0x%llx\n&quot;</span>, saved_state-&gt;r8);
	kprintf(<span class="enscript-string">&quot;      r9     0x%llx\n&quot;</span>, saved_state-&gt;r9);     

	kprintf(<span class="enscript-string">&quot;      cr2    0x%llx\n&quot;</span>, saved_state-&gt;cr2);
	kprintf(<span class="enscript-string">&quot;real  cr2    0x%lx\n&quot;</span>, get_cr2());
	kprintf(<span class="enscript-string">&quot;      r15    0x%llx\n&quot;</span>, saved_state-&gt;r15);
	kprintf(<span class="enscript-string">&quot;      r14    0x%llx\n&quot;</span>, saved_state-&gt;r14);
	kprintf(<span class="enscript-string">&quot;      r13    0x%llx\n&quot;</span>, saved_state-&gt;r13);
	kprintf(<span class="enscript-string">&quot;      r12    0x%llx\n&quot;</span>, saved_state-&gt;r12);
	kprintf(<span class="enscript-string">&quot;      r11    0x%llx\n&quot;</span>, saved_state-&gt;r11);
	kprintf(<span class="enscript-string">&quot;      rbp    0x%llx\n&quot;</span>, saved_state-&gt;rbp);
	kprintf(<span class="enscript-string">&quot;      rbx    0x%llx\n&quot;</span>, saved_state-&gt;rbx);
	kprintf(<span class="enscript-string">&quot;      rcx    0x%llx\n&quot;</span>, saved_state-&gt;rcx);
	kprintf(<span class="enscript-string">&quot;      rax    0x%llx\n&quot;</span>, saved_state-&gt;rax);

	kprintf(<span class="enscript-string">&quot;      gs     0x%x\n&quot;</span>, saved_state-&gt;gs);
	kprintf(<span class="enscript-string">&quot;      fs     0x%x\n&quot;</span>, saved_state-&gt;fs);

	kprintf(<span class="enscript-string">&quot;  isf.trapno 0x%x\n&quot;</span>, saved_state-&gt;isf.trapno);
	kprintf(<span class="enscript-string">&quot;  isf._pad   0x%x\n&quot;</span>, saved_state-&gt;isf._pad);
	kprintf(<span class="enscript-string">&quot;  isf.trapfn 0x%llx\n&quot;</span>, saved_state-&gt;isf.trapfn);
	kprintf(<span class="enscript-string">&quot;  isf.err    0x%llx\n&quot;</span>, saved_state-&gt;isf.err);
	kprintf(<span class="enscript-string">&quot;  isf.rip    0x%llx\n&quot;</span>, saved_state-&gt;isf.rip);
	kprintf(<span class="enscript-string">&quot;  isf.cs     0x%llx\n&quot;</span>, saved_state-&gt;isf.cs);
	kprintf(<span class="enscript-string">&quot;  isf.rflags 0x%llx\n&quot;</span>, saved_state-&gt;isf.rflags);
	kprintf(<span class="enscript-string">&quot;  isf.rsp    0x%llx\n&quot;</span>, saved_state-&gt;isf.rsp);
	kprintf(<span class="enscript-string">&quot;  isf.ss     0x%llx\n&quot;</span>, saved_state-&gt;isf.ss);
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Non-zero indicates latency assert is enabled and capped at valued
 * absolute time units.
 */</span>
   
uint64_t interrupt_latency_cap = 0;
boolean_t ilat_assert = FALSE;

<span class="enscript-type">void</span>
<span class="enscript-function-name">interrupt_latency_tracker_setup</span>(<span class="enscript-type">void</span>) {
	uint32_t ilat_cap_us;
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;interrupt_latency_cap_us&quot;</span>, &amp;ilat_cap_us, <span class="enscript-keyword">sizeof</span>(ilat_cap_us))) {
		interrupt_latency_cap = ilat_cap_us * NSEC_PER_USEC;
		nanoseconds_to_absolutetime(interrupt_latency_cap, &amp;interrupt_latency_cap);
	} <span class="enscript-keyword">else</span> {
		interrupt_latency_cap = LockTimeOut;
	}
	PE_parse_boot_argn(<span class="enscript-string">&quot;-interrupt_latency_assert_enable&quot;</span>, &amp;ilat_assert, <span class="enscript-keyword">sizeof</span>(ilat_assert));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">interrupt_reset_latency_stats</span>(<span class="enscript-type">void</span>) {
	uint32_t i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; real_ncpus; i++) {
		cpu_data_ptr[i]-&gt;cpu_max_observed_int_latency =
		    cpu_data_ptr[i]-&gt;cpu_max_observed_int_latency_vector = 0;
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">interrupt_populate_latency_stats</span>(<span class="enscript-type">char</span> *buf, <span class="enscript-type">unsigned</span> bufsize) {
	uint32_t i, tcpu = ~0;
	uint64_t cur_max = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; real_ncpus; i++) {
		<span class="enscript-keyword">if</span> (cur_max &lt; cpu_data_ptr[i]-&gt;cpu_max_observed_int_latency) {
			cur_max = cpu_data_ptr[i]-&gt;cpu_max_observed_int_latency;
			tcpu = i;
		}
	}

	<span class="enscript-keyword">if</span> (tcpu &lt; real_ncpus)
		snprintf(buf, bufsize, <span class="enscript-string">&quot;0x%x 0x%x 0x%llx&quot;</span>, tcpu, cpu_data_ptr[tcpu]-&gt;cpu_max_observed_int_latency_vector, cpu_data_ptr[tcpu]-&gt;cpu_max_observed_int_latency);
}

uint32_t interrupt_timer_coalescing_enabled = 1;
uint64_t interrupt_coalesced_timers;

<span class="enscript-comment">/*
 * Handle interrupts:
 *  - local APIC interrupts (IPIs, timers, etc) are handled by the kernel,
 *  - device interrupts go to the platform expert.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">interrupt</span>(x86_saved_state_t *state)
{
	uint64_t	rip;
	uint64_t	rsp;
	<span class="enscript-type">int</span>		interrupt_num;
	boolean_t	user_mode = FALSE;
	<span class="enscript-type">int</span>		ipl;
	<span class="enscript-type">int</span>		cnum = cpu_number();
	cpu_data_t	*cdp = cpu_data_ptr[cnum];
	<span class="enscript-type">int</span>		itype = 0;

	<span class="enscript-keyword">if</span> (is_saved_state64(state) == TRUE) {
	        x86_saved_state64_t	*state64;

	        state64 = saved_state64(state);
		rip = state64-&gt;isf.rip;
		rsp = state64-&gt;isf.rsp;
		interrupt_num = state64-&gt;isf.trapno;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
		<span class="enscript-keyword">if</span>(state64-&gt;isf.cs &amp; 0x03)
#<span class="enscript-reference">endif</span>
			user_mode = TRUE;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*state32;

		state32 = saved_state32(state);
		<span class="enscript-keyword">if</span> (state32-&gt;cs &amp; 0x03)
			user_mode = TRUE;
		rip = state32-&gt;eip;
		rsp = state32-&gt;uesp;
		interrupt_num = state32-&gt;trapno;
	}

	<span class="enscript-keyword">if</span> (cpu_data_ptr[cnum]-&gt;lcpu.package-&gt;num_idle == topoParms.nLThreadsPerPackage)
		cpu_data_ptr[cnum]-&gt;cpu_hwIntpexits[interrupt_num]++;

	<span class="enscript-keyword">if</span> (interrupt_num == (LAPIC_DEFAULT_INTERRUPT_BASE + LAPIC_INTERPROCESSOR_INTERRUPT))
		itype = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (interrupt_num == (LAPIC_DEFAULT_INTERRUPT_BASE + LAPIC_TIMER_INTERRUPT))
		itype = 2;
	<span class="enscript-keyword">else</span>
		itype = 3;

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
		MACHDBG_CODE(DBG_MACH_EXCP_INTR, 0) | DBG_FUNC_START,
		interrupt_num,
		(user_mode ? rip : VM_KERNEL_UNSLIDE(rip)),
		user_mode, itype, 0);

	SCHED_STATS_INTERRUPT(current_processor());

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
	<span class="enscript-keyword">if</span> (telemetry_needs_record) {
		telemetry_mark_curthread(user_mode);
	}
#<span class="enscript-reference">endif</span>

	ipl = get_preemption_level();
	
	<span class="enscript-comment">/*
	 * Handle local APIC interrupts
	 * else call platform expert for devices.
	 */</span>
	<span class="enscript-keyword">if</span> (!lapic_interrupt(interrupt_num, state)) {
		PE_incoming_interrupt(interrupt_num);
	}

	<span class="enscript-keyword">if</span> (__improbable(get_preemption_level() != ipl)) {
		panic(<span class="enscript-string">&quot;Preemption level altered by interrupt vector 0x%x: initial 0x%x, final: 0x%x\n&quot;</span>, interrupt_num, ipl, get_preemption_level());
	}


 	<span class="enscript-keyword">if</span> (__improbable(cdp-&gt;cpu_nested_istack)) {
 		cdp-&gt;cpu_nested_istack_events++;
 	}
 	<span class="enscript-keyword">else</span>  {
		uint64_t ctime = mach_absolute_time();
		uint64_t int_latency = ctime - cdp-&gt;cpu_int_event_time;
		uint64_t esdeadline, ehdeadline;
		<span class="enscript-comment">/* Attempt to process deferred timers in the context of
		 * this interrupt, unless interrupt time has already exceeded
		 * TCOAL_ILAT_THRESHOLD.
		 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCOAL_ILAT_THRESHOLD</span> (30000ULL)

		<span class="enscript-keyword">if</span> ((int_latency &lt; TCOAL_ILAT_THRESHOLD) &amp;&amp;
		    interrupt_timer_coalescing_enabled) {
			esdeadline = cdp-&gt;rtclock_timer.queue.earliest_soft_deadline;
			ehdeadline = cdp-&gt;rtclock_timer.deadline;
			<span class="enscript-keyword">if</span> ((ctime &gt;= esdeadline) &amp;&amp; (ctime &lt; ehdeadline)) {
				interrupt_coalesced_timers++;
				TCOAL_DEBUG(0x88880000 | DBG_FUNC_START, ctime, esdeadline, ehdeadline, interrupt_coalesced_timers, 0);
				rtclock_intr(state);
				TCOAL_DEBUG(0x88880000 | DBG_FUNC_END, ctime, esdeadline, interrupt_coalesced_timers, 0, 0);
			} <span class="enscript-keyword">else</span> {
				TCOAL_DEBUG(0x77770000, ctime, cdp-&gt;rtclock_timer.queue.earliest_soft_deadline, cdp-&gt;rtclock_timer.deadline, interrupt_coalesced_timers, 0);
			}
		}

		<span class="enscript-keyword">if</span> (__improbable(ilat_assert &amp;&amp; (int_latency &gt; interrupt_latency_cap) &amp;&amp; !machine_timeout_suspended())) {
			panic(<span class="enscript-string">&quot;Interrupt vector 0x%x exceeded interrupt latency threshold, 0x%llx absolute time delta, prior signals: 0x%x, current signals: 0x%x&quot;</span>, interrupt_num, int_latency, cdp-&gt;cpu_prior_signals, cdp-&gt;cpu_signals);
		}

		<span class="enscript-keyword">if</span> (__improbable(int_latency &gt; cdp-&gt;cpu_max_observed_int_latency)) {
			cdp-&gt;cpu_max_observed_int_latency = int_latency;
			cdp-&gt;cpu_max_observed_int_latency_vector = interrupt_num;
		}
	}

	<span class="enscript-comment">/*
	 * Having serviced the interrupt first, look at the interrupted stack depth.
	 */</span>
	<span class="enscript-keyword">if</span> (!user_mode) {
		uint64_t depth = cdp-&gt;cpu_kernel_stack
				 + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_kernel_state)
				 + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> i386_exception_link *)
				 - rsp;
		<span class="enscript-keyword">if</span> (__improbable(depth &gt; kernel_stack_depth_max)) {
			kernel_stack_depth_max = (vm_offset_t)depth;
			KERNEL_DEBUG_CONSTANT(
				MACHDBG_CODE(DBG_MACH_SCHED, MACH_STACK_DEPTH),
				(<span class="enscript-type">long</span>) depth, (<span class="enscript-type">long</span>) VM_KERNEL_UNSLIDE(rip), 0, 0, 0);
		}
	}
	
	<span class="enscript-keyword">if</span> (cnum == master_cpu)
		ml_entropy_collect();

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
		MACHDBG_CODE(DBG_MACH_EXCP_INTR, 0) | DBG_FUNC_END,
		interrupt_num, 0, 0, 0, 0);

	assert(ml_get_interrupts_enabled() == FALSE);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">reset_dr7</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">long</span> dr7 = 0x400; <span class="enscript-comment">/* magic dr7 reset value; 32 bit on i386, 64 bit on x86_64 */</span>
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;mov %0,%%dr7&quot;</span> : : <span class="enscript-string">&quot;r&quot;</span> (dr7));
}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_KDP</span>
<span class="enscript-type">unsigned</span> kdp_has_active_watchpoints = 0;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_WATCHPOINTS</span> (!kdp_has_active_watchpoints)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_WATCHPOINTS</span> 1
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*
 * Trap from kernel mode.  Only page-fault errors are recoverable,
 * and then only in special circumstances.  All other errors are
 * fatal.  Return value indicates if trap was handled.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">kernel_trap</span>(
	x86_saved_state_t	*state,
	uintptr_t *lo_spp)
{
	x86_saved_state64_t	*saved_state;
	<span class="enscript-type">int</span>			code;
	user_addr_t		vaddr;
	<span class="enscript-type">int</span>			type;
	vm_map_t		map = 0;	<span class="enscript-comment">/* protected by T_PAGE_FAULT */</span>
	kern_return_t		result = KERN_FAILURE;
	thread_t		thread;
	ast_t			*myast;
	boolean_t               intr;
	vm_prot_t		prot;
        <span class="enscript-type">struct</span> recovery		*rp;
	vm_offset_t		kern_ip;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	<span class="enscript-type">int</span>			fault_in_copy_window = -1;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>			is_user = 0;
	<span class="enscript-type">int</span>			trap_pl = get_preemption_level();

	thread = current_thread();

	<span class="enscript-keyword">if</span> (__improbable(is_saved_state32(state)))
		panic(<span class="enscript-string">&quot;kernel_trap(%p) with 32-bit state&quot;</span>, state);
	saved_state = saved_state64(state);

	<span class="enscript-comment">/* Record cpu where state was captured */</span>
	saved_state-&gt;isf.cpu = cpu_number();

	vaddr = (user_addr_t)saved_state-&gt;cr2;
	type  = saved_state-&gt;isf.trapno;
	code  = (<span class="enscript-type">int</span>)(saved_state-&gt;isf.err &amp; 0xffff);
	intr  = (saved_state-&gt;isf.rflags &amp; EFL_IF) != 0;	<span class="enscript-comment">/* state of ints at trap */</span>
	kern_ip = (vm_offset_t)saved_state-&gt;isf.rip;

	myast = ast_pending();

	perfASTCallback astfn = perfASTHook;
	<span class="enscript-keyword">if</span> (__improbable(astfn != NULL)) {
		<span class="enscript-keyword">if</span> (*myast &amp; AST_CHUD_ALL)
			astfn(AST_CHUD_ALL, myast);
	} <span class="enscript-keyword">else</span>
		*myast &amp;= ~AST_CHUD_ALL;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * Is there a DTrace hook?
	 */</span>	
	<span class="enscript-keyword">if</span> (__improbable(tempDTraceTrapHook != NULL)) {
		<span class="enscript-keyword">if</span> (tempDTraceTrapHook(type, state, lo_spp, 0) == KERN_SUCCESS) {
			<span class="enscript-comment">/*
			 * If it succeeds, we are done...
			 */</span>
			<span class="enscript-keyword">return</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

	<span class="enscript-comment">/*
	 * we come here with interrupts off as we don't want to recurse
	 * on preemption below.  but we do want to re-enable interrupts
	 * as soon we possibly can to hold latency down
	 */</span>
	<span class="enscript-keyword">if</span> (__improbable(T_PREEMPT == type)) {
	        ast_taken(AST_PREEMPTION, FALSE);

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
			(MACHDBG_CODE(DBG_MACH_EXCP_KTRAP_x86, type)) | DBG_FUNC_NONE,
			0, 0, 0, VM_KERNEL_UNSLIDE(kern_ip), 0);
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (T_PAGE_FAULT == type) {
		<span class="enscript-comment">/*
		 * assume we're faulting in the kernel map
		 */</span>
		map = kernel_map;

		<span class="enscript-keyword">if</span> (__probable(thread != THREAD_NULL &amp;&amp; thread-&gt;map != kernel_map)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
			vm_offset_t	copy_window_base;
			vm_offset_t	kvaddr;
			<span class="enscript-type">int</span>		window_index;

			kvaddr = (vm_offset_t)vaddr;
			<span class="enscript-comment">/*
			 * must determine if fault occurred in
			 * the copy window while pre-emption is
			 * disabled for this processor so that
			 * we only need to look at the window
			 * associated with this processor
			 */</span>
			copy_window_base = current_cpu_datap()-&gt;cpu_copywindow_base;

			<span class="enscript-keyword">if</span> (kvaddr &gt;= copy_window_base &amp;&amp; kvaddr &lt; (copy_window_base + (NBPDE * NCOPY_WINDOWS)) ) {

				window_index = (<span class="enscript-type">int</span>)((kvaddr - copy_window_base) / NBPDE);

				<span class="enscript-keyword">if</span> (thread-&gt;machine.copy_window[window_index].user_base != (user_addr_t)-1) {

				        kvaddr -= (copy_window_base + (NBPDE * window_index));
				        vaddr = thread-&gt;machine.copy_window[window_index].user_base + kvaddr;

					map = thread-&gt;map;
					fault_in_copy_window = window_index;
				}
				is_user = -1;
			}
#<span class="enscript-reference">else</span>
			<span class="enscript-keyword">if</span> (__probable(vaddr &lt; VM_MAX_USER_PAGE_ADDRESS)) {
				<span class="enscript-comment">/* fault occurred in userspace */</span>
				map = thread-&gt;map;
				is_user = -1;

				<span class="enscript-comment">/* Intercept a potential Supervisor Mode Execute
				 * Protection fault. These criteria identify
				 * both NX faults and SMEP faults, but both
				 * are fatal. We avoid checking PTEs (racy).
				 * (The VM could just redrive a SMEP fault, hence
				 * the intercept).
				 */</span>
				<span class="enscript-keyword">if</span> (__improbable((code == (T_PF_PROT | T_PF_EXECUTE)) &amp;&amp; (pmap_smep_enabled) &amp;&amp; (saved_state-&gt;isf.rip == vaddr))) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">debugger_entry</span>;
				}

				<span class="enscript-comment">/*
				 * Additionally check for SMAP faults...
				 * which are characterized by page-present and
				 * the AC bit unset (i.e. not from copyin/out path).
				 */</span>
				<span class="enscript-keyword">if</span> (__improbable(code &amp; T_PF_PROT &amp;&amp;
						 pmap_smap_enabled &amp;&amp;
						 (saved_state-&gt;isf.rflags &amp; EFL_AC) == 0)) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">debugger_entry</span>;
				}

				<span class="enscript-comment">/*
				 * If we're not sharing cr3 with the user
				 * and we faulted in copyio,
				 * then switch cr3 here and dismiss the fault.
				 */</span>
				<span class="enscript-keyword">if</span> (no_shared_cr3 &amp;&amp;
				    (thread-&gt;machine.specFlags&amp;CopyIOActive) &amp;&amp;
				    map-&gt;pmap-&gt;pm_cr3 != get_cr3_base()) {
					pmap_assert(current_cpu_datap()-&gt;cpu_pmap_pcid_enabled == FALSE);
					set_cr3_raw(map-&gt;pmap-&gt;pm_cr3);
					<span class="enscript-keyword">return</span>;
				}

			}
#<span class="enscript-reference">endif</span>
		}
	}
	user_addr_t	kd_vaddr = is_user ? vaddr : VM_KERNEL_UNSLIDE(vaddr);	
	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
		(MACHDBG_CODE(DBG_MACH_EXCP_KTRAP_x86, type)) | DBG_FUNC_NONE,
		(<span class="enscript-type">unsigned</span>)(kd_vaddr &gt;&gt; 32), (<span class="enscript-type">unsigned</span>)kd_vaddr, is_user,
		VM_KERNEL_UNSLIDE(kern_ip), 0);


	(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(intr);

	<span class="enscript-keyword">switch</span> (type) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_NO_FPU</span>:
		fpnoextflt();
		<span class="enscript-keyword">return</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_FPU_FAULT</span>:
		fpextovrflt();
		<span class="enscript-keyword">return</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_FLOATING_POINT_ERROR</span>:
		fpexterrflt();
		<span class="enscript-keyword">return</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_SSE_FLOAT_ERROR</span>:
	        fpSSEexterrflt();
		<span class="enscript-keyword">return</span>;
 	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_DEBUG</span>:
		    <span class="enscript-keyword">if</span> ((saved_state-&gt;isf.rflags &amp; EFL_TF) == 0 &amp;&amp; NO_WATCHPOINTS)
		    {
			    <span class="enscript-comment">/* We've somehow encountered a debug
			     * register match that does not belong
			     * to the kernel debugger.
			     * This isn't supposed to happen.
			     */</span>
			    reset_dr7();
			    <span class="enscript-keyword">return</span>;
		    }
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">debugger_entry</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__x86_64__</span>
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_INT3</span>:
	      <span class="enscript-keyword">goto</span> <span class="enscript-reference">debugger_entry</span>;
#<span class="enscript-reference">endif</span>
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_PAGE_FAULT</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (thread != THREAD_NULL &amp;&amp; thread-&gt;options &amp; TH_OPT_DTRACE) {	<span class="enscript-comment">/* Executing under dtrace_probe? */</span>
			<span class="enscript-keyword">if</span> (dtrace_tally_fault(vaddr)) { <span class="enscript-comment">/* Should a fault under dtrace be ignored? */</span>
				<span class="enscript-comment">/*
				 * DTrace has &quot;anticipated&quot; the possibility of this fault, and has
				 * established the suitable recovery state. Drop down now into the
				 * recovery handling code in &quot;case T_GENERAL_PROTECTION:&quot;. 
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">FALL_THROUGH</span>;
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>
		
		prot = VM_PROT_READ;

		<span class="enscript-keyword">if</span> (code &amp; T_PF_WRITE)
		        prot |= VM_PROT_WRITE;
		<span class="enscript-keyword">if</span> (code &amp; T_PF_EXECUTE)
		        prot |= VM_PROT_EXECUTE;

		result = vm_fault(map,
				  vm_map_trunc_page(vaddr,
						    PAGE_MASK),
				  prot,
				  FALSE, 
				  THREAD_UNINT, NULL, 0);

		<span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
			<span class="enscript-keyword">if</span> (fault_in_copy_window != -1) {
				ml_set_interrupts_enabled(FALSE);
				copy_window_fault(thread, map,
						  fault_in_copy_window);
				(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(intr);
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NCOPY_WINDOWS &gt; 0 */</span>
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-comment">/*
		 * fall through
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-reference">FALL_THROUGH</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_GENERAL_PROTECTION</span>:
		<span class="enscript-comment">/*
		 * If there is a failure recovery address
		 * for this fault, go there.
		 */</span>
	        <span class="enscript-keyword">for</span> (rp = recover_table; rp &lt; recover_table_end; rp++) {
		        <span class="enscript-keyword">if</span> (kern_ip == rp-&gt;fault_addr) {
			        set_recovery_ip(saved_state, rp-&gt;recover_addr);
				<span class="enscript-keyword">return</span>;
			}
		}

		<span class="enscript-comment">/*
		 * Check thread recovery address also.
		 */</span>
		<span class="enscript-keyword">if</span> (thread != THREAD_NULL &amp;&amp; thread-&gt;recover) {
			set_recovery_ip(saved_state, thread-&gt;recover);
			thread-&gt;recover = 0;
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-comment">/*
		 * Unanticipated page-fault errors in kernel
		 * should not happen.
		 *
		 * fall through...
		 */</span>
	    <span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * Exception 15 is reserved but some chips may generate it
		 * spuriously. Seen at startup on AMD Athlon-64.
		 */</span>
	    	<span class="enscript-keyword">if</span> (type == 15) {
			kprintf(<span class="enscript-string">&quot;kernel_trap() ignoring spurious trap 15\n&quot;</span>); 
			<span class="enscript-keyword">return</span>;
		}
<span class="enscript-reference">debugger_entry</span>:
		<span class="enscript-comment">/* Ensure that the i386_kernel_state at the base of the
		 * current thread's stack (if any) is synchronized with the
		 * context at the moment of the trap, to facilitate
		 * access through the debugger.
		 */</span>
		sync_iss_to_iks(state);
#<span class="enscript-reference">if</span>  <span class="enscript-variable-name">MACH_KDP</span>
		<span class="enscript-keyword">if</span> (current_debugger != KDB_CUR_DB) {
			<span class="enscript-keyword">if</span> (kdp_i386_trap(type, saved_state, result, (vm_offset_t)vaddr))
				<span class="enscript-keyword">return</span>;
		}
#<span class="enscript-reference">endif</span>
	}
	pal_cli();
	panic_trap(saved_state, trap_pl);
	<span class="enscript-comment">/*
	 * NO RETURN
	 */</span>
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">set_recovery_ip</span>(x86_saved_state64_t  *saved_state, vm_offset_t ip)
{
        saved_state-&gt;isf.rip = ip;
}




<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">panic_trap</span>(x86_saved_state64_t *regs, uint32_t pl)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*trapname = <span class="enscript-string">&quot;Unknown&quot;</span>;
	pal_cr_t	cr0, cr2, cr3, cr4;
	boolean_t	potential_smep_fault = FALSE, potential_kernel_NX_fault = FALSE;
	boolean_t	potential_smap_fault = FALSE;

	pal_get_control_registers( &amp;cr0, &amp;cr2, &amp;cr3, &amp;cr4 );
	assert(ml_get_interrupts_enabled() == FALSE);
	current_cpu_datap()-&gt;cpu_fatal_trap_state = regs;
	<span class="enscript-comment">/*
	 * Issue an I/O port read if one has been requested - this is an
	 * event logic analyzers can use as a trigger point.
	 */</span>
	panic_io_port_read();

	kprintf(<span class="enscript-string">&quot;panic trap number 0x%x, rip 0x%016llx\n&quot;</span>,
		regs-&gt;isf.trapno, regs-&gt;isf.rip);
	kprintf(<span class="enscript-string">&quot;cr0 0x%016llx cr2 0x%016llx cr3 0x%016llx cr4 0x%016llx\n&quot;</span>,
		cr0, cr2, cr3, cr4);

	<span class="enscript-keyword">if</span> (regs-&gt;isf.trapno &lt; TRAP_TYPES)
	        trapname = trap_type[regs-&gt;isf.trapno];

	<span class="enscript-keyword">if</span> ((regs-&gt;isf.trapno == T_PAGE_FAULT) &amp;&amp; (regs-&gt;isf.err == (T_PF_PROT | T_PF_EXECUTE)) &amp;&amp; (regs-&gt;isf.rip == regs-&gt;cr2)) {
		<span class="enscript-keyword">if</span> (pmap_smep_enabled &amp;&amp; (regs-&gt;isf.rip &lt; VM_MAX_USER_PAGE_ADDRESS)) {
			potential_smep_fault = TRUE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (regs-&gt;isf.rip &gt;= VM_MIN_KERNEL_AND_KEXT_ADDRESS) {
			potential_kernel_NX_fault = TRUE;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pmap_smap_enabled &amp;&amp;
		   regs-&gt;isf.trapno == T_PAGE_FAULT &amp;&amp;
		   regs-&gt;isf.err &amp; T_PF_PROT &amp;&amp;
		   regs-&gt;cr2 &lt; VM_MAX_USER_PAGE_ADDRESS &amp;&amp;
		   regs-&gt;isf.rip &gt;= VM_MIN_KERNEL_AND_KEXT_ADDRESS) {
		potential_smap_fault = TRUE;
	}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">panic</span>
	panic(<span class="enscript-string">&quot;Kernel trap at 0x%016llx, type %d=%s, registers:\n&quot;</span>
	      <span class="enscript-string">&quot;CR0: 0x%016llx, CR2: 0x%016llx, CR3: 0x%016llx, CR4: 0x%016llx\n&quot;</span>
	      <span class="enscript-string">&quot;RAX: 0x%016llx, RBX: 0x%016llx, RCX: 0x%016llx, RDX: 0x%016llx\n&quot;</span>
	      <span class="enscript-string">&quot;RSP: 0x%016llx, RBP: 0x%016llx, RSI: 0x%016llx, RDI: 0x%016llx\n&quot;</span>
	      <span class="enscript-string">&quot;R8:  0x%016llx, R9:  0x%016llx, R10: 0x%016llx, R11: 0x%016llx\n&quot;</span>
	      <span class="enscript-string">&quot;R12: 0x%016llx, R13: 0x%016llx, R14: 0x%016llx, R15: 0x%016llx\n&quot;</span>
	      <span class="enscript-string">&quot;RFL: 0x%016llx, RIP: 0x%016llx, CS:  0x%016llx, SS:  0x%016llx\n&quot;</span>
	      <span class="enscript-string">&quot;Fault CR2: 0x%016llx, Error code: 0x%016llx, Fault CPU: 0x%x%s%s%s%s, PL: %d\n&quot;</span>,
	      regs-&gt;isf.rip, regs-&gt;isf.trapno, trapname,
	      cr0, cr2, cr3, cr4,
	      regs-&gt;rax, regs-&gt;rbx, regs-&gt;rcx, regs-&gt;rdx,
	      regs-&gt;isf.rsp, regs-&gt;rbp, regs-&gt;rsi, regs-&gt;rdi,
	      regs-&gt;r8,  regs-&gt;r9,  regs-&gt;r10, regs-&gt;r11,
	      regs-&gt;r12, regs-&gt;r13, regs-&gt;r14, regs-&gt;r15,
	      regs-&gt;isf.rflags, regs-&gt;isf.rip, regs-&gt;isf.cs &amp; 0xFFFF,
	      regs-&gt;isf.ss &amp; 0xFFFF,regs-&gt;cr2, regs-&gt;isf.err, regs-&gt;isf.cpu,
	      virtualized ? <span class="enscript-string">&quot; VMM&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	      potential_kernel_NX_fault ? <span class="enscript-string">&quot; Kernel NX fault&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	      potential_smep_fault ? <span class="enscript-string">&quot; SMEP/User NX fault&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	      potential_smap_fault ? <span class="enscript-string">&quot; SMAP fault&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, pl);
	<span class="enscript-comment">/*
	 * This next statement is not executed,
	 * but it's needed to stop the compiler using tail call optimization
	 * for the panic call - which confuses the subsequent backtrace.
	 */</span>
	cr0 = 0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">dtrace_user_probe</span>(x86_saved_state_t *);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Trap from user mode.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">user_trap</span>(
	x86_saved_state_t *saved_state)
{
	<span class="enscript-type">int</span>			exc;
	<span class="enscript-type">int</span>			err;
	mach_exception_code_t 	code;
	mach_exception_subcode_t subcode;
	<span class="enscript-type">int</span>			type;
	user_addr_t		vaddr;
	vm_prot_t		prot;
	thread_t		thread = current_thread();
	ast_t			*myast;
	kern_return_t		kret;
	user_addr_t		rip;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> 		dr6 = 0; <span class="enscript-comment">/* 32 bit for i386, 64 bit for x86_64 */</span>

	assert((is_saved_state32(saved_state) &amp;&amp; !thread_is_64bit(thread)) ||
	       (is_saved_state64(saved_state) &amp;&amp;  thread_is_64bit(thread)));

	<span class="enscript-keyword">if</span> (is_saved_state64(saved_state)) {
	        x86_saved_state64_t	*regs;

		regs = saved_state64(saved_state);

		<span class="enscript-comment">/* Record cpu where state was captured */</span>
		regs-&gt;isf.cpu = cpu_number();

		type = regs-&gt;isf.trapno;
		err  = (<span class="enscript-type">int</span>)regs-&gt;isf.err &amp; 0xffff;
		vaddr = (user_addr_t)regs-&gt;cr2;
		rip   = (user_addr_t)regs-&gt;isf.rip;
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t	*regs;

		regs = saved_state32(saved_state);

		<span class="enscript-comment">/* Record cpu where state was captured */</span>
		regs-&gt;cpu = cpu_number();

		type  = regs-&gt;trapno;
		err   = regs-&gt;err &amp; 0xffff;
		vaddr = (user_addr_t)regs-&gt;cr2;
		rip   = (user_addr_t)regs-&gt;eip;
	}

	<span class="enscript-keyword">if</span> ((type == T_DEBUG) &amp;&amp; thread-&gt;machine.ids) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> clear = 0;
		<span class="enscript-comment">/* Stash and clear this processor's DR6 value, in the event
		 * this was a debug register match
		 */</span>
		__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;mov %%db6, %0&quot;</span> : <span class="enscript-string">&quot;=r&quot;</span> (dr6)); 
		__asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;mov %0, %%db6&quot;</span> : : <span class="enscript-string">&quot;r&quot;</span> (clear));
	}

	pal_sti();

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
		(MACHDBG_CODE(DBG_MACH_EXCP_UTRAP_x86, type)) | DBG_FUNC_NONE,
		(<span class="enscript-type">unsigned</span>)(vaddr&gt;&gt;32), (<span class="enscript-type">unsigned</span>)vaddr,
		(<span class="enscript-type">unsigned</span>)(rip&gt;&gt;32), (<span class="enscript-type">unsigned</span>)rip, 0);

	code = 0;
	subcode = 0;
	exc = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_TRACE</span>
	kprintf(<span class="enscript-string">&quot;user_trap(0x%08x) type=%d vaddr=0x%016llx\n&quot;</span>,
		saved_state, type, vaddr);
#<span class="enscript-reference">endif</span>

	perfASTCallback astfn = perfASTHook;
	<span class="enscript-keyword">if</span> (__improbable(astfn != NULL)) {
		myast = ast_pending();
		<span class="enscript-keyword">if</span> (*myast &amp; AST_CHUD_ALL) {
			astfn(AST_CHUD_ALL, myast);
		}
	}

	<span class="enscript-comment">/* Is there a hook? */</span>
	perfCallback fn = perfTrapHook;
	<span class="enscript-keyword">if</span> (__improbable(fn != NULL)) {
		<span class="enscript-keyword">if</span> (fn(type, saved_state, 0, 0) == KERN_SUCCESS)
			<span class="enscript-keyword">return</span>;	<span class="enscript-comment">/* If it succeeds, we are done... */</span>
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * DTrace does not consume all user traps, only INT_3's for now.
	 * Avoid needlessly calling tempDTraceTrapHook here, and let the
	 * INT_3 case handle them.
	 */</span>
#<span class="enscript-reference">endif</span>
	
	DEBUG_KPRINT_SYSCALL_MASK(1,
		<span class="enscript-string">&quot;user_trap: type=0x%x(%s) err=0x%x cr2=%p rip=%p\n&quot;</span>,
		type, trap_type[type], err, (<span class="enscript-type">void</span> *)(<span class="enscript-type">long</span>) vaddr, (<span class="enscript-type">void</span> *)(<span class="enscript-type">long</span>) rip);
	
	<span class="enscript-keyword">switch</span> (type) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_DIVIDE_ERROR</span>:
		exc = EXC_ARITHMETIC;
		code = EXC_I386_DIV;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_DEBUG</span>:
		{
			pcb_t	pcb;
			<span class="enscript-comment">/*
			 * Update the PCB with this processor's DR6 value
			 * in the event this was a debug register match.
			 */</span>
			pcb = THREAD_TO_PCB(thread);
			<span class="enscript-keyword">if</span> (pcb-&gt;ids) {
				<span class="enscript-comment">/*
				 * We can get and set the status register
				 * in 32-bit mode even on a 64-bit thread
				 * because the high order bits are not
				 * used on x86_64
				 */</span>
				<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
					x86_debug_state64_t *ids = pcb-&gt;ids;
					ids-&gt;dr6 = dr6;
				} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* 32 bit thread */</span>
					x86_debug_state32_t *ids = pcb-&gt;ids;
					ids-&gt;dr6 = (uint32_t) dr6;
				}
			}
			exc = EXC_BREAKPOINT;
			code = EXC_I386_SGL;
			<span class="enscript-keyword">break</span>;
		}
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_INT3</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (dtrace_user_probe(saved_state) == KERN_SUCCESS)
			<span class="enscript-keyword">return</span>; <span class="enscript-comment">/* If it succeeds, we are done... */</span>
#<span class="enscript-reference">endif</span>
		exc = EXC_BREAKPOINT;
		code = EXC_I386_BPT;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_OVERFLOW</span>:
		exc = EXC_ARITHMETIC;
		code = EXC_I386_INTO;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_OUT_OF_BOUNDS</span>:
		exc = EXC_SOFTWARE;
		code = EXC_I386_BOUND;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_INVALID_OPCODE</span>:
		exc = EXC_BAD_INSTRUCTION;
		code = EXC_I386_INVOP;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_NO_FPU</span>:
		fpnoextflt();
		<span class="enscript-keyword">return</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_FPU_FAULT</span>:
		fpextovrflt(); <span class="enscript-comment">/* Propagates exception directly, doesn't return */</span>
		<span class="enscript-keyword">return</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_INVALID_TSS</span>:	<span class="enscript-comment">/* invalid TSS == iret with NT flag set */</span>
		exc = EXC_BAD_INSTRUCTION;
		code = EXC_I386_INVTSSFLT;
		subcode = err;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_SEGMENT_NOT_PRESENT</span>:
		exc = EXC_BAD_INSTRUCTION;
		code = EXC_I386_SEGNPFLT;
		subcode = err;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_STACK_FAULT</span>:
		exc = EXC_BAD_INSTRUCTION;
		code = EXC_I386_STKFLT;
		subcode = err;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_GENERAL_PROTECTION</span>:
		<span class="enscript-comment">/*
		 * There's a wide range of circumstances which generate this
		 * class of exception. From user-space, many involve bad
		 * addresses (such as a non-canonical 64-bit address).
		 * So we map this to EXC_BAD_ACCESS (and thereby SIGSEGV).
		 * The trouble is cr2 doesn't contain the faulting address;
		 * we'd need to decode the faulting instruction to really
		 * determine this. We'll leave that to debuggers.
		 * However, attempted execution of privileged instructions
		 * (e.g. cli) also generate GP faults and so we map these to
		 * to EXC_BAD_ACCESS (and thence SIGSEGV) also - rather than
		 * EXC_BAD_INSTRUCTION which is more accurate. We just can't
		 * win!
		 */</span> 
		exc = EXC_BAD_ACCESS;
		code = EXC_I386_GPFLT;
		subcode = err;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_PAGE_FAULT</span>:
	    {
		    prot = VM_PROT_READ;

		<span class="enscript-keyword">if</span> (err &amp; T_PF_WRITE)
		        prot |= VM_PROT_WRITE;
		<span class="enscript-keyword">if</span> (__improbable(err &amp; T_PF_EXECUTE))
		        prot |= VM_PROT_EXECUTE;
		kret = vm_fault(thread-&gt;map,
				vm_map_trunc_page(vaddr,
						  PAGE_MASK),
				prot, FALSE,
				THREAD_ABORTSAFE, NULL, 0);

		<span class="enscript-keyword">if</span> (__probable((kret == KERN_SUCCESS) || (kret == KERN_ABORTED))) {
			thread_exception_return();
			<span class="enscript-comment">/*NOTREACHED*/</span>
		}

	        user_page_fault_continue(kret);
	    }	<span class="enscript-comment">/* NOTREACHED */</span>
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_SSE_FLOAT_ERROR</span>:
		fpSSEexterrflt(); <span class="enscript-comment">/* Propagates exception directly, doesn't return */</span>
		<span class="enscript-keyword">return</span>;


	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_FLOATING_POINT_ERROR</span>:
		fpexterrflt(); <span class="enscript-comment">/* Propagates exception directly, doesn't return */</span>
		<span class="enscript-keyword">return</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">T_DTRACE_RET</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (dtrace_user_probe(saved_state) == KERN_SUCCESS)
			<span class="enscript-keyword">return</span>; <span class="enscript-comment">/* If it succeeds, we are done... */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * If we get an INT 0x7f when we do not expect to,
		 * treat it as an illegal instruction
		 */</span>
		exc = EXC_BAD_INSTRUCTION;
		code = EXC_I386_INVOP;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;Unexpected user trap, type %d&quot;</span>, type);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* Note: Codepaths that directly return from user_trap() have pending
	 * ASTs processed in locore
	 */</span>
	i386_exception(exc, code, subcode);
	<span class="enscript-comment">/* NOTREACHED */</span>
}


<span class="enscript-comment">/*
 * Handle AST traps for i386.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">log_thread_action</span> (thread_t, <span class="enscript-type">char</span> *);

<span class="enscript-type">void</span>
<span class="enscript-function-name">i386_astintr</span>(<span class="enscript-type">int</span> preemption)
{
	ast_t		mask = AST_ALL;
	spl_t		s;

	<span class="enscript-keyword">if</span> (preemption)
	        mask = AST_PREEMPTION;

	s = splsched();

	ast_taken(mask, s);

	splx(s);
}

<span class="enscript-comment">/*
 * Handle exceptions for i386.
 *
 * If we are an AT bus machine, we must turn off the AST for a
 * delayed floating-point exception.
 *
 * If we are providing floating-point emulation, we may have
 * to retrieve the real register values from the floating point
 * emulator.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">i386_exception</span>(
	<span class="enscript-type">int</span>	exc,
	mach_exception_code_t code,
	mach_exception_subcode_t subcode)
{
	mach_exception_data_type_t   codes[EXCEPTION_CODE_MAX];

	DEBUG_KPRINT_SYSCALL_MACH(<span class="enscript-string">&quot;i386_exception: exc=%d code=0x%llx subcode=0x%llx\n&quot;</span>,
							  exc, code, subcode);
	codes[0] = code;		<span class="enscript-comment">/* new exception interface */</span>
	codes[1] = subcode;
	exception_triage(exc, codes, 2);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}


<span class="enscript-comment">/* Synchronize a thread's x86_kernel_state (if any) with the given
 * x86_saved_state_t obtained from the trap/IPI handler; called in
 * kernel_trap() prior to entering the debugger, and when receiving
 * an &quot;MP_KDP&quot; IPI. Called with null saved_state if an incoming IPI
 * was detected from the kernel while spinning with interrupts masked.
 */</span>
  
<span class="enscript-type">void</span>
<span class="enscript-function-name">sync_iss_to_iks</span>(x86_saved_state_t *saved_state)
{
	<span class="enscript-type">struct</span> x86_kernel_state *iks;
	vm_offset_t kstack;
	boolean_t record_active_regs = FALSE;

	<span class="enscript-comment">/* The PAL may have a special way to sync registers */</span>
	<span class="enscript-keyword">if</span> (saved_state &amp;&amp; saved_state-&gt;flavor == THREAD_STATE_NONE)
		pal_get_kern_regs( saved_state );

	<span class="enscript-keyword">if</span> ((kstack = current_thread()-&gt;kernel_stack) != 0) {
		x86_saved_state64_t	*regs = saved_state64(saved_state);

		iks = STACK_IKS(kstack);

		<span class="enscript-comment">/* Did we take the trap/interrupt in kernel mode? */</span>
		<span class="enscript-keyword">if</span> (saved_state == NULL || <span class="enscript-comment">/* NULL =&gt; polling in kernel */</span>
		    regs == USER_REGS64(current_thread()))
		        record_active_regs = TRUE;
		<span class="enscript-keyword">else</span> {
			iks-&gt;k_rbx = regs-&gt;rbx;
			iks-&gt;k_rsp = regs-&gt;isf.rsp;
			iks-&gt;k_rbp = regs-&gt;rbp;
			iks-&gt;k_r12 = regs-&gt;r12;
			iks-&gt;k_r13 = regs-&gt;r13;
			iks-&gt;k_r14 = regs-&gt;r14;
			iks-&gt;k_r15 = regs-&gt;r15;
			iks-&gt;k_rip = regs-&gt;isf.rip;
		}
	}

	<span class="enscript-keyword">if</span> (record_active_regs == TRUE) {
		<span class="enscript-comment">/* Show the trap handler path */</span>
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rbx, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rbx));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rsp, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rsp));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rbp, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rbp));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r12, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r12));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r13, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r13));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r14, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r14));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r15, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r15));
		<span class="enscript-comment">/* &quot;Current&quot; instruction pointer */</span>
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;leaq 1f(%%rip), %%rax; mov %%rax, %0\n1:&quot;</span>
				 : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rip)
				 :
				 : <span class="enscript-string">&quot;rax&quot;</span>);
	}
}

<span class="enscript-comment">/*
 * This is used by the NMI interrupt handler (from mp.c) to
 * uncondtionally sync the trap handler context to the IKS
 * irrespective of whether the NMI was fielded in kernel
 * or user space.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sync_iss_to_iks_unconditionally</span>(__unused x86_saved_state_t *saved_state) {
	<span class="enscript-type">struct</span> x86_kernel_state *iks;
	vm_offset_t kstack;

	<span class="enscript-keyword">if</span> ((kstack = current_thread()-&gt;kernel_stack) != 0) {
		iks = STACK_IKS(kstack);
		<span class="enscript-comment">/* Display the trap handler path */</span>
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rbx, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rbx));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rsp, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rsp));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rbp, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rbp));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r12, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r12));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r13, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r13));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r14, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r14));
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%r15, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_r15));
		<span class="enscript-comment">/* &quot;Current&quot; instruction pointer */</span>
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;leaq 1f(%%rip), %%rax; mov %%rax, %0\n1:&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (iks-&gt;k_rip)::<span class="enscript-string">&quot;rax&quot;</span>);
	}
}
</pre>
<hr />
</body></html>