<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pcb_native.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pcb_native.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_rt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/counters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/commpage/commpage.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/eflags.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/user_ldt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/seg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/hv_support.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_IS_16BYTE_MULTIPLE_SIZEOF</span>(_type_)	\
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> assert_is_16byte_multiple_sizeof_ ## _type_	\
		[(<span class="enscript-keyword">sizeof</span>(_type_) % 16) == 0 ? 1 : -1]

<span class="enscript-comment">/* Compile-time checks for vital save area sizing: */</span>
<span class="enscript-function-name">ASSERT_IS_16BYTE_MULTIPLE_SIZEOF</span>(x86_64_intr_stack_frame_t);
<span class="enscript-function-name">ASSERT_IS_16BYTE_MULTIPLE_SIZEOF</span>(x86_saved_state_t);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIRECTION_FLAG_DEBUG</span> (DEBUG | DEVELOPMENT)

<span class="enscript-type">extern</span> zone_t		iss_zone;		<span class="enscript-comment">/* zone for saved_state area */</span>
<span class="enscript-type">extern</span> zone_t		ids_zone;		<span class="enscript-comment">/* zone for debug_state area */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">act_machine_switch_pcb</span>(__unused thread_t old, thread_t new)
{
        pcb_t			pcb = THREAD_TO_PCB(new);
	cpu_data_t      	*cdp = current_cpu_datap();
	<span class="enscript-type">struct</span> real_descriptor	*ldtp;
	mach_vm_offset_t	pcb_stack_top;

	assert(new-&gt;kernel_stack != 0);
	assert(ml_get_interrupts_enabled() == FALSE);
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">DIRECTION_FLAG_DEBUG</span>
	<span class="enscript-keyword">if</span> (x86_get_flags() &amp; EFL_DF) {
		panic(<span class="enscript-string">&quot;Direction flag detected: 0x%lx&quot;</span>, x86_get_flags());
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Clear segment state
	 * unconditionally for DS/ES/FS but more carefully for GS whose
	 * cached state we track.
	 */</span>
	set_ds(NULL_SEG);
	set_es(NULL_SEG);
	set_fs(NULL_SEG);
	<span class="enscript-keyword">if</span> (get_gs() != NULL_SEG) {
		swapgs();		<span class="enscript-comment">/* switch to user's GS context */</span>
		set_gs(NULL_SEG);
		swapgs();		<span class="enscript-comment">/* and back to kernel */</span>

		<span class="enscript-comment">/* record the active machine state lost */</span>
		cdp-&gt;cpu_uber.cu_user_gs_base = 0;
	} 

	vm_offset_t			isf;

	<span class="enscript-comment">/*
	 * Set pointer to PCB's interrupt stack frame in cpu data.
	 * Used by syscall and double-fault trap handlers.
	 */</span>
	isf = (vm_offset_t) &amp;pcb-&gt;iss-&gt;ss_64.isf;
	cdp-&gt;cpu_uber.cu_isf = isf;
	pcb_stack_top = (vm_offset_t) (pcb-&gt;iss + 1);
	<span class="enscript-comment">/* require 16-byte alignment */</span>
	assert((pcb_stack_top &amp; 0xF) == 0);

	<span class="enscript-comment">/* Interrupt stack is pcb */</span>
	current_ktss64()-&gt;rsp0 = pcb_stack_top;

	<span class="enscript-comment">/*
	 * Top of temporary sysenter stack points to pcb stack.
	 * Although this is not normally used by 64-bit users,
	 * it needs to be set in case a sysenter is attempted.
	 */</span>
	*current_sstk64() = pcb_stack_top;

	<span class="enscript-keyword">if</span> (is_saved_state64(pcb-&gt;iss)) {

		cdp-&gt;cpu_task_map = new-&gt;map-&gt;pmap-&gt;pm_task_map; 

		<span class="enscript-comment">/*
		 * Enable the 64-bit user code segment, USER64_CS.
		 * Disable the 32-bit user code segment, USER_CS.
		 */</span>
		ldt_desc_p(USER64_CS)-&gt;access |= ACC_PL_U;
		ldt_desc_p(USER_CS)-&gt;access &amp;= ~ACC_PL_U;

		<span class="enscript-comment">/*
		 * Switch user's GS base if necessary
		 * by setting the Kernel's GS base MSR
		 * - this will become the user's on the swapgs when
		 * returning to user-space.  Avoid this for
		 * kernel threads (no user TLS support required)
		 * and verify the memory shadow of the segment base
		 * in the event it was altered in user space.
		 */</span>
		<span class="enscript-keyword">if</span> ((pcb-&gt;cthread_self != 0) || (new-&gt;task != kernel_task)) {
			<span class="enscript-keyword">if</span> ((cdp-&gt;cpu_uber.cu_user_gs_base != pcb-&gt;cthread_self) || (pcb-&gt;cthread_self != rdmsr64(MSR_IA32_KERNEL_GS_BASE))) {
				cdp-&gt;cpu_uber.cu_user_gs_base = pcb-&gt;cthread_self;
				wrmsr64(MSR_IA32_KERNEL_GS_BASE, pcb-&gt;cthread_self);
			}
		}

	} <span class="enscript-keyword">else</span> {

		cdp-&gt;cpu_task_map = TASK_MAP_32BIT;

		<span class="enscript-comment">/*
		 * Disable USER64_CS
		 * Enable USER_CS
		 */</span>
		ldt_desc_p(USER64_CS)-&gt;access &amp;= ~ACC_PL_U;
		ldt_desc_p(USER_CS)-&gt;access |= ACC_PL_U;

		<span class="enscript-comment">/*
		 * Set the thread`s cthread (a.k.a pthread)
		 * For 32-bit user this involves setting the USER_CTHREAD
		 * descriptor in the LDT to point to the cthread data.
		 * The involves copying in the pre-initialized descriptor.
		 */</span> 
		ldtp = (<span class="enscript-type">struct</span> real_descriptor *)current_ldt();
		ldtp[sel_idx(USER_CTHREAD)] = pcb-&gt;cthread_desc;
		<span class="enscript-keyword">if</span> (pcb-&gt;uldt_selector != 0)
			ldtp[sel_idx(pcb-&gt;uldt_selector)] = pcb-&gt;uldt_desc;
		cdp-&gt;cpu_uber.cu_user_gs_base = pcb-&gt;cthread_self;

		<span class="enscript-comment">/*
		 * Set the thread`s LDT or LDT entry.
		 */</span>
		<span class="enscript-keyword">if</span> (new-&gt;task == TASK_NULL || new-&gt;task-&gt;i386_ldt == 0) {
			<span class="enscript-comment">/*
			 * Use system LDT.
			 */</span>
		       	ml_cpu_set_ldt(KERNEL_LDT);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Task has its own LDT.
			 */</span>
			user_ldt_set(new);
		}
	}

	<span class="enscript-comment">/*
	 * Bump the scheduler generation count in the commpage.
	 * This can be read by user code to detect its preemption.
	 */</span>
	commpage_sched_gen_inc();
}

kern_return_t
<span class="enscript-function-name">thread_set_wq_state32</span>(thread_t thread, thread_state_t tstate)
{
        x86_thread_state32_t	*state;
        x86_saved_state32_t	*saved_state;
	thread_t curth = current_thread();
	spl_t			s=0;

	pal_register_cache_state(thread, DIRTY);

	saved_state = USER_REGS32(thread);

	state = (x86_thread_state32_t *)tstate;
	
	<span class="enscript-keyword">if</span> (curth != thread) {
		s = splsched();
	        thread_lock(thread);
	}

	saved_state-&gt;ebp = 0;
	saved_state-&gt;eip = state-&gt;eip;
	saved_state-&gt;eax = state-&gt;eax;
	saved_state-&gt;ebx = state-&gt;ebx;
	saved_state-&gt;ecx = state-&gt;ecx;
	saved_state-&gt;edx = state-&gt;edx;
	saved_state-&gt;edi = state-&gt;edi;
	saved_state-&gt;esi = state-&gt;esi;
	saved_state-&gt;uesp = state-&gt;esp;
	saved_state-&gt;efl = EFL_USER_SET;

	saved_state-&gt;cs = USER_CS;
	saved_state-&gt;ss = USER_DS;
	saved_state-&gt;ds = USER_DS;
	saved_state-&gt;es = USER_DS;

	<span class="enscript-keyword">if</span> (curth != thread) {
	        thread_unlock(thread);
		splx(s);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


kern_return_t
<span class="enscript-function-name">thread_set_wq_state64</span>(thread_t thread, thread_state_t tstate)
{
        x86_thread_state64_t	*state;
        x86_saved_state64_t	*saved_state;
	thread_t curth = current_thread();
	spl_t			s=0;

	saved_state = USER_REGS64(thread);
	state = (x86_thread_state64_t *)tstate;
	
	<span class="enscript-comment">/* Disallow setting non-canonical PC or stack */</span>
	<span class="enscript-keyword">if</span> (!IS_USERADDR64_CANONICAL(state-&gt;rsp) ||
	    !IS_USERADDR64_CANONICAL(state-&gt;rip)) {
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	pal_register_cache_state(thread, DIRTY);

	<span class="enscript-keyword">if</span> (curth != thread) {
		s = splsched();
	        thread_lock(thread);
	}

	saved_state-&gt;rbp = 0;
	saved_state-&gt;rdi = state-&gt;rdi;
	saved_state-&gt;rsi = state-&gt;rsi;
	saved_state-&gt;rdx = state-&gt;rdx;
	saved_state-&gt;rcx = state-&gt;rcx;
	saved_state-&gt;r8  = state-&gt;r8;
	saved_state-&gt;r9  = state-&gt;r9;

	saved_state-&gt;isf.rip = state-&gt;rip;
	saved_state-&gt;isf.rsp = state-&gt;rsp;
	saved_state-&gt;isf.cs = USER64_CS;
	saved_state-&gt;isf.rflags = EFL_USER_SET;

	<span class="enscript-keyword">if</span> (curth != thread) {
	        thread_unlock(thread);
		splx(s);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Initialize the machine-dependent state for a new thread.
 */</span>
kern_return_t
<span class="enscript-function-name">machine_thread_create</span>(
	thread_t		thread,
	task_t			task)
{
        pcb_t			pcb = THREAD_TO_PCB(thread);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	inval_copy_windows(thread);

	thread-&gt;machine.physwindow_pte = 0;
	thread-&gt;machine.physwindow_busy = 0;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Allocate save frame only if required.
	 */</span>
	<span class="enscript-keyword">if</span> (pcb-&gt;iss == NULL) {
		assert((get_preemption_level() == 0));
		pcb-&gt;iss = (x86_saved_state_t *) zalloc(iss_zone);
		<span class="enscript-keyword">if</span> (pcb-&gt;iss == NULL)
			panic(<span class="enscript-string">&quot;iss_zone&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Assure that the synthesized 32-bit state including
	 * the 64-bit interrupt state can be acommodated in the 
	 * 64-bit state we allocate for both 32-bit and 64-bit threads.
	 */</span>
	assert(<span class="enscript-keyword">sizeof</span>(pcb-&gt;iss-&gt;ss_32) + <span class="enscript-keyword">sizeof</span>(pcb-&gt;iss-&gt;ss_64.isf) &lt;=
	       <span class="enscript-keyword">sizeof</span>(pcb-&gt;iss-&gt;ss_64));

	bzero((<span class="enscript-type">char</span> *)pcb-&gt;iss, <span class="enscript-keyword">sizeof</span>(x86_saved_state_t));

        <span class="enscript-keyword">if</span> (task_has_64BitAddr(task)) {
		pcb-&gt;iss-&gt;flavor = x86_SAVED_STATE64;

		pcb-&gt;iss-&gt;ss_64.isf.cs = USER64_CS;
		pcb-&gt;iss-&gt;ss_64.isf.ss = USER_DS;
		pcb-&gt;iss-&gt;ss_64.fs = USER_DS;
		pcb-&gt;iss-&gt;ss_64.gs = USER_DS;
		pcb-&gt;iss-&gt;ss_64.isf.rflags = EFL_USER_SET;
	} <span class="enscript-keyword">else</span> {
		pcb-&gt;iss-&gt;flavor = x86_SAVED_STATE32;

		pcb-&gt;iss-&gt;ss_32.cs = USER_CS;
		pcb-&gt;iss-&gt;ss_32.ss = USER_DS;
		pcb-&gt;iss-&gt;ss_32.ds = USER_DS;
		pcb-&gt;iss-&gt;ss_32.es = USER_DS;
		pcb-&gt;iss-&gt;ss_32.fs = USER_DS;
		pcb-&gt;iss-&gt;ss_32.gs = USER_DS;
		pcb-&gt;iss-&gt;ss_32.efl = EFL_USER_SET;
	}

	simple_lock_init(&amp;pcb-&gt;lock, 0);

	pcb-&gt;cthread_self = 0;
	pcb-&gt;uldt_selector = 0;
	pcb-&gt;thread_gpu_ns = 0;
	<span class="enscript-comment">/* Ensure that the &quot;cthread&quot; descriptor describes a valid
	 * segment.
	 */</span>
	<span class="enscript-keyword">if</span> ((pcb-&gt;cthread_desc.access &amp; ACC_P) == 0) {
		<span class="enscript-type">struct</span> real_descriptor  *ldtp;
		ldtp = (<span class="enscript-type">struct</span> real_descriptor *)current_ldt();
		pcb-&gt;cthread_desc = ldtp[sel_idx(USER_DS)];
	}

	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Machine-dependent cleanup prior to destroying a thread
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_thread_destroy</span>(
	thread_t		thread)
{
	<span class="enscript-type">register</span> pcb_t	pcb = THREAD_TO_PCB(thread);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
	<span class="enscript-keyword">if</span> (thread-&gt;hv_thread_target) {
		hv_callbacks.thread_destroy(thread-&gt;hv_thread_target);
		thread-&gt;hv_thread_target = NULL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (pcb-&gt;ifps != 0)
		fpu_free(pcb-&gt;ifps);
	<span class="enscript-keyword">if</span> (pcb-&gt;iss != 0) {
		zfree(iss_zone, pcb-&gt;iss);
		pcb-&gt;iss = 0;
	}
	<span class="enscript-keyword">if</span> (pcb-&gt;ids) {
		zfree(ids_zone, pcb-&gt;ids);
		pcb-&gt;ids = NULL;
	}
}

kern_return_t
<span class="enscript-function-name">machine_thread_set_tsd_base</span>(
	thread_t			thread,
	mach_vm_offset_t	tsd_base)
{

	<span class="enscript-keyword">if</span> (thread-&gt;task == kernel_task) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
		<span class="enscript-comment">/* check for canonical address, set 0 otherwise  */</span>
		<span class="enscript-keyword">if</span> (!IS_USERADDR64_CANONICAL(tsd_base))
			tsd_base = 0ULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (tsd_base &gt; UINT32_MAX)
			tsd_base = 0ULL;
	}

	pcb_t pcb = THREAD_TO_PCB(thread);
	pcb-&gt;cthread_self = tsd_base;

	<span class="enscript-keyword">if</span> (!thread_is_64bit(thread)) {
		<span class="enscript-comment">/* Set up descriptor for later use */</span>
		<span class="enscript-type">struct</span> real_descriptor desc = {
			.limit_low = 1,
			.limit_high = 0,
			.base_low = tsd_base &amp; 0xffff,
			.base_med = (tsd_base &gt;&gt; 16) &amp; 0xff,
			.base_high = (tsd_base &gt;&gt; 24) &amp; 0xff,
			.access = ACC_P|ACC_PL_U|ACC_DATA_W,
			.granularity = SZ_32|SZ_G,
		};

		pcb-&gt;cthread_desc = desc;
		saved_state32(pcb-&gt;iss)-&gt;gs = USER_CTHREAD;
	}

	<span class="enscript-comment">/* For current thread, make the TSD base active immediately */</span>
	<span class="enscript-keyword">if</span> (thread == current_thread()) {

		<span class="enscript-keyword">if</span> (thread_is_64bit(thread)) {
			cpu_data_t              *cdp;

			mp_disable_preemption();
			cdp = current_cpu_datap();
			<span class="enscript-keyword">if</span> ((cdp-&gt;cpu_uber.cu_user_gs_base != pcb-&gt;cthread_self) ||
				(pcb-&gt;cthread_self != rdmsr64(MSR_IA32_KERNEL_GS_BASE)))
				wrmsr64(MSR_IA32_KERNEL_GS_BASE, tsd_base);
			cdp-&gt;cpu_uber.cu_user_gs_base = tsd_base;
			mp_enable_preemption();
		} <span class="enscript-keyword">else</span> {

			<span class="enscript-comment">/* assign descriptor */</span>
			mp_disable_preemption();
			*ldt_desc_p(USER_CTHREAD) = pcb-&gt;cthread_desc;
			mp_enable_preemption();
		}
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}
</pre>
<hr />
</body></html>