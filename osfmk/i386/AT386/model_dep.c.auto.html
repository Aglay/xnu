<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>model_dep.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">model_dep.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989, 1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

<span class="enscript-comment">/*
 */</span>

<span class="enscript-comment">/*
 *	File:	model_dep.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Copyright (C) 1986, Avadis Tevanian, Jr., Michael Wayne Young
 *
 *	Basic initialization for I386 - ISA bus machines.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/time_value.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/startup.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/postcode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp_desc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/trap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>		<span class="enscript-comment">/* mp_rendezvous_break_lock */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MTRR</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mtrr.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/ucode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/panic_hooks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;architecture/i386/pio.h&gt;</span> <span class="enscript-comment">/* inb() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/i386/boot.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_dyld.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/i386/efi.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSKextLibPrivate.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/branch_predicates.h&gt;</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPRINTF</span>(x...)	kprintf(x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPRINTF</span>(x...)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">machine_conf</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">panic_print_symbol_name</span>(vm_address_t search);

<span class="enscript-type">extern</span> boolean_t init_task_died;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>	version[];
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> 	osversion[];
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		max_unsafe_quanta;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		max_poll_quanta;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	panic_is_inited;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	proc_pid(<span class="enscript-type">void</span> *p);

<span class="enscript-comment">/* Definitions for frame pointers */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FP_ALIGNMENT_MASK</span>      ((uint32_t)(0x3))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FP_LR_OFFSET</span>           ((uint32_t)4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FP_LR_OFFSET64</span>         ((uint32_t)8)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FP_MAX_NUM_TO_EVALUATE</span> (50)

<span class="enscript-type">int</span> db_run_mode;

<span class="enscript-type">volatile</span> <span class="enscript-type">int</span> pbtcpu = -1;
hw_lock_data_t pbtlock;		<span class="enscript-comment">/* backtrace print lock */</span>
uint32_t pbtcnt = 0;

<span class="enscript-type">volatile</span> <span class="enscript-type">int</span> panic_double_fault_cpu = -1;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PRINT_ARGS_FROM_STACK_FRAME</span>	0

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _cframe_t {
    <span class="enscript-type">struct</span> _cframe_t	*prev;
    uintptr_t		caller;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRINT_ARGS_FROM_STACK_FRAME</span>
    <span class="enscript-type">unsigned</span>		args[0];
#<span class="enscript-reference">endif</span>
} cframe_t;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> panic_io_port;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span>	commit_paniclog_to_nvram;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> debug_boot_arg;

<span class="enscript-comment">/*
 * Backtrace a single frame.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">print_one_backtrace</span>(pmap_t pmap, vm_offset_t topfp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cur_marker,
	boolean_t is_64_bit, boolean_t nvram_format) 
{
	<span class="enscript-type">int</span>		    i = 0;
	addr64_t	lr;
	addr64_t	fp;
	addr64_t	fp_for_ppn;
	ppnum_t		ppn;
	boolean_t	dump_kernel_stack;

	fp = topfp;
	fp_for_ppn = 0;
	ppn = (ppnum_t)NULL;

	<span class="enscript-keyword">if</span> (fp &gt;= VM_MIN_KERNEL_ADDRESS)
		dump_kernel_stack = TRUE;
	<span class="enscript-keyword">else</span>
		dump_kernel_stack = FALSE;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> ((fp == 0) || ((fp &amp; FP_ALIGNMENT_MASK) != 0))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (dump_kernel_stack &amp;&amp; ((fp &lt; VM_MIN_KERNEL_ADDRESS) || (fp &gt; VM_MAX_KERNEL_ADDRESS)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> ((!dump_kernel_stack) &amp;&amp; (fp &gt;=VM_MIN_KERNEL_ADDRESS))
			<span class="enscript-keyword">break</span>;
			
        <span class="enscript-comment">/* Check to see if current address will result in a different
           ppn than previously computed (to avoid recomputation) via
           (addr) ^ fp_for_ppn) &gt;&gt; PAGE_SHIFT) */</span>

		<span class="enscript-keyword">if</span> ((((fp + FP_LR_OFFSET) ^ fp_for_ppn) &gt;&gt; PAGE_SHIFT) != 0x0U) {
			ppn = pmap_find_phys(pmap, fp + FP_LR_OFFSET);
			fp_for_ppn = fp + (is_64_bit ? FP_LR_OFFSET64 : FP_LR_OFFSET);
		}
		<span class="enscript-keyword">if</span> (ppn != (ppnum_t)NULL) {
			<span class="enscript-keyword">if</span> (is_64_bit) {
				lr = ml_phys_read_double_64(((((vm_offset_t)ppn) &lt;&lt; PAGE_SHIFT)) | ((fp + FP_LR_OFFSET64) &amp; PAGE_MASK));
			} <span class="enscript-keyword">else</span> {
				lr = ml_phys_read_word(((((vm_offset_t)ppn) &lt;&lt; PAGE_SHIFT)) | ((fp + FP_LR_OFFSET) &amp; PAGE_MASK));
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (is_64_bit) {
				kdb_printf(<span class="enscript-string">&quot;%s\t  Could not read LR from frame at 0x%016llx\n&quot;</span>, cur_marker, fp + FP_LR_OFFSET64);
			} <span class="enscript-keyword">else</span> {
				kdb_printf(<span class="enscript-string">&quot;%s\t  Could not read LR from frame at 0x%08x\n&quot;</span>, cur_marker, (uint32_t)(fp + FP_LR_OFFSET));
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (((fp ^ fp_for_ppn) &gt;&gt; PAGE_SHIFT) != 0x0U) {
			ppn = pmap_find_phys(pmap, fp);
			fp_for_ppn = fp;
		}
		<span class="enscript-keyword">if</span> (ppn != (ppnum_t)NULL) {
			<span class="enscript-keyword">if</span> (is_64_bit) {
				fp = ml_phys_read_double_64(((((vm_offset_t)ppn) &lt;&lt; PAGE_SHIFT)) | (fp &amp; PAGE_MASK));
			} <span class="enscript-keyword">else</span> {
				fp = ml_phys_read_word(((((vm_offset_t)ppn) &lt;&lt; PAGE_SHIFT)) | (fp &amp; PAGE_MASK));
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (is_64_bit) {
				kdb_printf(<span class="enscript-string">&quot;%s\t  Could not read FP from frame at 0x%016llx\n&quot;</span>, cur_marker, fp);
			} <span class="enscript-keyword">else</span> {
				kdb_printf(<span class="enscript-string">&quot;%s\t  Could not read FP from frame at 0x%08x\n&quot;</span>, cur_marker, (uint32_t)fp);
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (nvram_format) {
			<span class="enscript-keyword">if</span> (is_64_bit) {
				kdb_printf(<span class="enscript-string">&quot;%s\t0x%016llx\n&quot;</span>, cur_marker, lr);
			} <span class="enscript-keyword">else</span> {
				kdb_printf(<span class="enscript-string">&quot;%s\t0x%08x\n&quot;</span>, cur_marker, (uint32_t)lr);
			}
		} <span class="enscript-keyword">else</span> {		
			<span class="enscript-keyword">if</span> (is_64_bit) {
				kdb_printf(<span class="enscript-string">&quot;%s\t  lr: 0x%016llx  fp: 0x%016llx\n&quot;</span>, cur_marker, lr, fp);
			} <span class="enscript-keyword">else</span> {
				kdb_printf(<span class="enscript-string">&quot;%s\t  lr: 0x%08x  fp: 0x%08x\n&quot;</span>, cur_marker, (uint32_t)lr, (uint32_t)fp);
			}
		}
	} <span class="enscript-keyword">while</span> ((++i &lt; FP_MAX_NUM_TO_EVALUATE) &amp;&amp; (fp != topfp));
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_startup</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>	boot_arg;

#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">if</span>( PE_get_hotkey( kPEControlKey ))
            halt_in_debugger = halt_in_debugger ? 0 : 1;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;debug&quot;</span>, &amp;debug_boot_arg, <span class="enscript-keyword">sizeof</span> (debug_boot_arg))) {
		panicDebugging = TRUE;
		<span class="enscript-keyword">if</span> (debug_boot_arg &amp; DB_HALT) halt_in_debugger=1;
		<span class="enscript-keyword">if</span> (debug_boot_arg &amp; DB_PRT) disable_debug_output=FALSE; 
		<span class="enscript-keyword">if</span> (debug_boot_arg &amp; DB_SLOG) systemLogDiags=TRUE; 
		<span class="enscript-keyword">if</span> (debug_boot_arg &amp; DB_LOG_PI_SCRN) logPanicDataToScreen=TRUE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KDEBUG_MOJO_TRACE</span>
		<span class="enscript-keyword">if</span> (debug_boot_arg &amp; DB_PRT_KDEBUG) {
			kdebug_serial = TRUE;
			disable_debug_output = FALSE;
		}
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
		debug_boot_arg = 0;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;nvram_paniclog&quot;</span>, &amp;commit_paniclog_to_nvram, <span class="enscript-keyword">sizeof</span> (commit_paniclog_to_nvram)))
		commit_paniclog_to_nvram = 1;

	<span class="enscript-comment">/*
	 * Entering the debugger will put the CPUs into a &quot;safe&quot;
	 * power mode.
	 */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;pmsafe_debug&quot;</span>, &amp;boot_arg, <span class="enscript-keyword">sizeof</span> (boot_arg)))
	    pmsafe_debug = boot_arg;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOTYET</span>
	hw_lock_init(&amp;debugger_lock);	<span class="enscript-comment">/* initialize debugger lock */</span>
#<span class="enscript-reference">endif</span>
	hw_lock_init(&amp;pbtlock);		<span class="enscript-comment">/* initialize print backtrace lock */</span>

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;preempt&quot;</span>, &amp;boot_arg, <span class="enscript-keyword">sizeof</span> (boot_arg))) {
		default_preemption_rate = boot_arg;
	}
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;unsafe&quot;</span>, &amp;boot_arg, <span class="enscript-keyword">sizeof</span> (boot_arg))) {
		max_unsafe_quanta = boot_arg;
	}
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;poll&quot;</span>, &amp;boot_arg, <span class="enscript-keyword">sizeof</span> (boot_arg))) {
		max_poll_quanta = boot_arg;
	}
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;yield&quot;</span>, &amp;boot_arg, <span class="enscript-keyword">sizeof</span> (boot_arg))) {
		sched_poll_yield_shift = boot_arg;
	}
<span class="enscript-comment">/* The I/O port to issue a read from, in the event of a panic. Useful for
 * triggering logic analyzers.
 */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;panic_io_port&quot;</span>, &amp;boot_arg, <span class="enscript-keyword">sizeof</span> (boot_arg))) {
		<span class="enscript-comment">/*I/O ports range from 0 through 0xFFFF */</span>
		panic_io_port = boot_arg &amp; 0xffff;
	}

	machine_conf();

	panic_hooks_init();

	<span class="enscript-comment">/*
	 * Start the system.
	 */</span>
	kernel_bootstrap();
	<span class="enscript-comment">/*NOTREACHED*/</span>
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">machine_conf</span>(<span class="enscript-type">void</span>)
{
	machine_info.memory_size = (typeof(machine_info.memory_size))mem_size;
}


<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *gPEEFIRuntimeServices;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *gPEEFISystemTable;

<span class="enscript-comment">/*-
 *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
 *  code or tables extracted from it, as desired without restriction.
 *
 *  First, the polynomial itself and its table of feedback terms.  The
 *  polynomial is
 *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
 *
 *  Note that we take it &quot;backwards&quot; and put the highest-order term in
 *  the lowest-order bit.  The X^32 term is &quot;implied&quot;; the LSB is the
 *  X^31 term, etc.  The X^0 term (usually shown as &quot;+1&quot;) results in
 *  the MSB being 1
 *
 *  Note that the usual hardware shift register implementation, which
 *  is what we're using (we're merely optimizing it by doing eight-bit
 *  chunks at a time) shifts bits into the lowest-order term.  In our
 *  implementation, that means shifting towards the right.  Why do we
 *  do it this way?  Because the calculated CRC must be transmitted in
 *  order from highest-order term to lowest-order term.  UARTs transmit
 *  characters in order from LSB to MSB.  By storing the CRC this way
 *  we hand it to the UART in the order low-byte to high-byte; the UART
 *  sends each low-bit to hight-bit; and the result is transmission bit
 *  by bit from highest- to lowest-order term without requiring any bit
 *  shuffling on our part.  Reception works similarly
 *
 *  The feedback terms table consists of 256, 32-bit entries.  Notes
 *
 *      The table can be generated at runtime if desired; code to do so
 *      is shown later.  It might not be obvious, but the feedback
 *      terms simply represent the results of eight shift/xor opera
 *      tions for all combinations of data and CRC register values
 *
 *      The values must be right-shifted by eight bits by the &quot;updcrc
 *      logic; the shift must be unsigned (bring in zeroes).  On some
 *      hardware you could probably optimize the shift in assembler by
 *      using byte-swap instructions
 *      polynomial $edb88320
 *
 *
 * CRC32 code derived from work by Gary S. Brown.
 */</span>

<span class="enscript-type">static</span> uint32_t crc32_tab[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3,	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de,	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,	0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5,	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,	0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940,	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,	0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">crc32</span>(uint32_t crc, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *buf, size_t size)
{
	<span class="enscript-type">const</span> uint8_t *p;

	p = buf;
	crc = crc ^ ~0U;

	<span class="enscript-keyword">while</span> (size--)
		crc = crc32_tab[(crc ^ *p++) &amp; 0xFF] ^ (crc &gt;&gt; 8);

	<span class="enscript-keyword">return</span> crc ^ ~0U;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">efi_set_tables_64</span>(EFI_SYSTEM_TABLE_64 * system_table)
{
    EFI_RUNTIME_SERVICES_64 *runtime;
    uint32_t hdr_cksum;
    uint32_t cksum;

    DPRINTF(<span class="enscript-string">&quot;Processing 64-bit EFI tables at %p\n&quot;</span>, system_table);
    <span class="enscript-keyword">do</span> {
	DPRINTF(<span class="enscript-string">&quot;Header:\n&quot;</span>);
	DPRINTF(<span class="enscript-string">&quot;  Signature:   0x%016llx\n&quot;</span>, system_table-&gt;Hdr.Signature);
	DPRINTF(<span class="enscript-string">&quot;  Revision:    0x%08x\n&quot;</span>, system_table-&gt;Hdr.Revision);
	DPRINTF(<span class="enscript-string">&quot;  HeaderSize:  0x%08x\n&quot;</span>, system_table-&gt;Hdr.HeaderSize);
	DPRINTF(<span class="enscript-string">&quot;  CRC32:       0x%08x\n&quot;</span>, system_table-&gt;Hdr.CRC32);
	DPRINTF(<span class="enscript-string">&quot;RuntimeServices: 0x%016llx\n&quot;</span>, system_table-&gt;RuntimeServices);
        <span class="enscript-keyword">if</span> (system_table-&gt;Hdr.Signature != EFI_SYSTEM_TABLE_SIGNATURE) {
	    kprintf(<span class="enscript-string">&quot;Bad EFI system table signature\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-comment">// Verify signature of the system table
</span>        hdr_cksum = system_table-&gt;Hdr.CRC32;
        system_table-&gt;Hdr.CRC32 = 0;
        cksum = crc32(0L, system_table, system_table-&gt;Hdr.HeaderSize);

        DPRINTF(<span class="enscript-string">&quot;System table calculated CRC32 = 0x%x, header = 0x%x\n&quot;</span>, cksum, hdr_cksum);
        system_table-&gt;Hdr.CRC32 = hdr_cksum;
        <span class="enscript-keyword">if</span> (cksum != hdr_cksum) {
            kprintf(<span class="enscript-string">&quot;Bad EFI system table checksum\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }

        gPEEFISystemTable     = system_table;

        <span class="enscript-keyword">if</span>(system_table-&gt;RuntimeServices == 0) {
            kprintf(<span class="enscript-string">&quot;No runtime table present\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }
        DPRINTF(<span class="enscript-string">&quot;RuntimeServices table at 0x%qx\n&quot;</span>, system_table-&gt;RuntimeServices);
        <span class="enscript-comment">// 64-bit virtual address is OK for 64-bit EFI and 64/32-bit kernel.
</span>        runtime = (EFI_RUNTIME_SERVICES_64 *) (uintptr_t)system_table-&gt;RuntimeServices;
        DPRINTF(<span class="enscript-string">&quot;Checking runtime services table %p\n&quot;</span>, runtime);
        <span class="enscript-keyword">if</span> (runtime-&gt;Hdr.Signature != EFI_RUNTIME_SERVICES_SIGNATURE) {
            kprintf(<span class="enscript-string">&quot;Bad EFI runtime table signature\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }

	<span class="enscript-comment">// Verify signature of runtime services table
</span>	hdr_cksum = runtime-&gt;Hdr.CRC32;
	runtime-&gt;Hdr.CRC32 = 0;
	cksum = crc32(0L, runtime, runtime-&gt;Hdr.HeaderSize);

	DPRINTF(<span class="enscript-string">&quot;Runtime table calculated CRC32 = 0x%x, header = 0x%x\n&quot;</span>, cksum, hdr_cksum);
	runtime-&gt;Hdr.CRC32 = hdr_cksum;
	<span class="enscript-keyword">if</span> (cksum != hdr_cksum) {
	    kprintf(<span class="enscript-string">&quot;Bad EFI runtime table checksum\n&quot;</span>);
	    <span class="enscript-keyword">break</span>;
	}

	gPEEFIRuntimeServices = runtime;
    }
    <span class="enscript-keyword">while</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">efi_set_tables_32</span>(EFI_SYSTEM_TABLE_32 * system_table)
{
    EFI_RUNTIME_SERVICES_32 *runtime;
    uint32_t hdr_cksum;
    uint32_t cksum;

    DPRINTF(<span class="enscript-string">&quot;Processing 32-bit EFI tables at %p\n&quot;</span>, system_table);
    <span class="enscript-keyword">do</span> {
	DPRINTF(<span class="enscript-string">&quot;Header:\n&quot;</span>);
	DPRINTF(<span class="enscript-string">&quot;  Signature:   0x%016llx\n&quot;</span>, system_table-&gt;Hdr.Signature);
	DPRINTF(<span class="enscript-string">&quot;  Revision:    0x%08x\n&quot;</span>, system_table-&gt;Hdr.Revision);
	DPRINTF(<span class="enscript-string">&quot;  HeaderSize:  0x%08x\n&quot;</span>, system_table-&gt;Hdr.HeaderSize);
	DPRINTF(<span class="enscript-string">&quot;  CRC32:       0x%08x\n&quot;</span>, system_table-&gt;Hdr.CRC32);
	DPRINTF(<span class="enscript-string">&quot;RuntimeServices: 0x%08x\n&quot;</span>, system_table-&gt;RuntimeServices);
        <span class="enscript-keyword">if</span> (system_table-&gt;Hdr.Signature != EFI_SYSTEM_TABLE_SIGNATURE) {
            kprintf(<span class="enscript-string">&quot;Bad EFI system table signature\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-comment">// Verify signature of the system table
</span>        hdr_cksum = system_table-&gt;Hdr.CRC32;
        system_table-&gt;Hdr.CRC32 = 0;
        DPRINTF(<span class="enscript-string">&quot;System table at %p HeaderSize 0x%x\n&quot;</span>, system_table, system_table-&gt;Hdr.HeaderSize);
        cksum = crc32(0L, system_table, system_table-&gt;Hdr.HeaderSize);

        DPRINTF(<span class="enscript-string">&quot;System table calculated CRC32 = 0x%x, header = 0x%x\n&quot;</span>, cksum, hdr_cksum);
        system_table-&gt;Hdr.CRC32 = hdr_cksum;
        <span class="enscript-keyword">if</span> (cksum != hdr_cksum) {
            kprintf(<span class="enscript-string">&quot;Bad EFI system table checksum\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }

        gPEEFISystemTable     = system_table;

        <span class="enscript-keyword">if</span>(system_table-&gt;RuntimeServices == 0) {
            kprintf(<span class="enscript-string">&quot;No runtime table present\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }
        DPRINTF(<span class="enscript-string">&quot;RuntimeServices table at 0x%x\n&quot;</span>, system_table-&gt;RuntimeServices);
        <span class="enscript-comment">// 32-bit virtual address is OK for 32-bit EFI and 32-bit kernel.
</span>        <span class="enscript-comment">// For a 64-bit kernel, booter provides a virtual address mod 4G
</span>        runtime = (EFI_RUNTIME_SERVICES_32 *)
			(system_table-&gt;RuntimeServices | VM_MIN_KERNEL_ADDRESS);
	DPRINTF(<span class="enscript-string">&quot;Runtime table addressed at %p\n&quot;</span>, runtime);
        <span class="enscript-keyword">if</span> (runtime-&gt;Hdr.Signature != EFI_RUNTIME_SERVICES_SIGNATURE) {
            kprintf(<span class="enscript-string">&quot;Bad EFI runtime table signature\n&quot;</span>);
            <span class="enscript-keyword">break</span>;
        }

	<span class="enscript-comment">// Verify signature of runtime services table
</span>	hdr_cksum = runtime-&gt;Hdr.CRC32;
	runtime-&gt;Hdr.CRC32 = 0;
	cksum = crc32(0L, runtime, runtime-&gt;Hdr.HeaderSize);

	DPRINTF(<span class="enscript-string">&quot;Runtime table calculated CRC32 = 0x%x, header = 0x%x\n&quot;</span>, cksum, hdr_cksum);
	runtime-&gt;Hdr.CRC32 = hdr_cksum;
	<span class="enscript-keyword">if</span> (cksum != hdr_cksum) {
	    kprintf(<span class="enscript-string">&quot;Bad EFI runtime table checksum\n&quot;</span>);
	    <span class="enscript-keyword">break</span>;
	}

	DPRINTF(<span class="enscript-string">&quot;Runtime functions\n&quot;</span>);
	DPRINTF(<span class="enscript-string">&quot;  GetTime                  : 0x%x\n&quot;</span>, runtime-&gt;GetTime);
	DPRINTF(<span class="enscript-string">&quot;  SetTime                  : 0x%x\n&quot;</span>, runtime-&gt;SetTime);
	DPRINTF(<span class="enscript-string">&quot;  GetWakeupTime            : 0x%x\n&quot;</span>, runtime-&gt;GetWakeupTime);
	DPRINTF(<span class="enscript-string">&quot;  SetWakeupTime            : 0x%x\n&quot;</span>, runtime-&gt;SetWakeupTime);
	DPRINTF(<span class="enscript-string">&quot;  SetVirtualAddressMap     : 0x%x\n&quot;</span>, runtime-&gt;SetVirtualAddressMap);
	DPRINTF(<span class="enscript-string">&quot;  ConvertPointer           : 0x%x\n&quot;</span>, runtime-&gt;ConvertPointer);
	DPRINTF(<span class="enscript-string">&quot;  GetVariable              : 0x%x\n&quot;</span>, runtime-&gt;GetVariable);
	DPRINTF(<span class="enscript-string">&quot;  GetNextVariableName      : 0x%x\n&quot;</span>, runtime-&gt;GetNextVariableName);
	DPRINTF(<span class="enscript-string">&quot;  SetVariable              : 0x%x\n&quot;</span>, runtime-&gt;SetVariable);
	DPRINTF(<span class="enscript-string">&quot;  GetNextHighMonotonicCount: 0x%x\n&quot;</span>, runtime-&gt;GetNextHighMonotonicCount);
	DPRINTF(<span class="enscript-string">&quot;  ResetSystem              : 0x%x\n&quot;</span>, runtime-&gt;ResetSystem);

	gPEEFIRuntimeServices = runtime;
    }
    <span class="enscript-keyword">while</span> (FALSE);
}


<span class="enscript-comment">/* Map in EFI runtime areas. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">efi_init</span>(<span class="enscript-type">void</span>)
{
    boot_args *args = (boot_args *)PE_state.bootArgs;

    kprintf(<span class="enscript-string">&quot;Initializing EFI runtime services\n&quot;</span>);

    <span class="enscript-keyword">do</span>
    {
	vm_offset_t vm_size, vm_addr;
	vm_map_offset_t phys_addr;
	EfiMemoryRange *mptr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> msize, mcount;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	msize = args-&gt;MemoryMapDescriptorSize;
	mcount = args-&gt;MemoryMapSize / msize;

	DPRINTF(<span class="enscript-string">&quot;efi_init() kernel base: 0x%x size: 0x%x\n&quot;</span>,
		args-&gt;kaddr, args-&gt;ksize);
	DPRINTF(<span class="enscript-string">&quot;           efiSystemTable physical: 0x%x virtual: %p\n&quot;</span>,
		args-&gt;efiSystemTable,
		(<span class="enscript-type">void</span> *) ml_static_ptovirt(args-&gt;efiSystemTable));
	DPRINTF(<span class="enscript-string">&quot;           efiRuntimeServicesPageStart: 0x%x\n&quot;</span>,
		args-&gt;efiRuntimeServicesPageStart);
	DPRINTF(<span class="enscript-string">&quot;           efiRuntimeServicesPageCount: 0x%x\n&quot;</span>,
		args-&gt;efiRuntimeServicesPageCount);
	DPRINTF(<span class="enscript-string">&quot;           efiRuntimeServicesVirtualPageStart: 0x%016llx\n&quot;</span>,
		args-&gt;efiRuntimeServicesVirtualPageStart);
	mptr = (EfiMemoryRange *)ml_static_ptovirt(args-&gt;MemoryMap);
	<span class="enscript-keyword">for</span> (i=0; i &lt; mcount; i++, mptr = (EfiMemoryRange *)(((vm_offset_t)mptr) + msize)) {
	    <span class="enscript-keyword">if</span> (((mptr-&gt;Attribute &amp; EFI_MEMORY_RUNTIME) == EFI_MEMORY_RUNTIME) ) {
		vm_size = (vm_offset_t)i386_ptob((uint32_t)mptr-&gt;NumberOfPages);
		vm_addr =   (vm_offset_t) mptr-&gt;VirtualStart;
		<span class="enscript-comment">/* For K64 on EFI32, shadow-map into high KVA */</span>
		<span class="enscript-keyword">if</span> (vm_addr &lt; VM_MIN_KERNEL_ADDRESS)
			vm_addr |= VM_MIN_KERNEL_ADDRESS;
		phys_addr = (vm_map_offset_t) mptr-&gt;PhysicalStart;
		DPRINTF(<span class="enscript-string">&quot; Type: %x phys: %p EFIv: %p kv: %p size: %p\n&quot;</span>,
			mptr-&gt;Type,
			(<span class="enscript-type">void</span> *) (uintptr_t) phys_addr,
			(<span class="enscript-type">void</span> *) (uintptr_t) mptr-&gt;VirtualStart,
			(<span class="enscript-type">void</span> *) vm_addr,
			(<span class="enscript-type">void</span> *) vm_size);
		pmap_map_bd(vm_addr, phys_addr, phys_addr + round_page(vm_size),
		     (mptr-&gt;Type == kEfiRuntimeServicesCode) ? VM_PROT_READ | VM_PROT_EXECUTE : VM_PROT_READ|VM_PROT_WRITE,
		     (mptr-&gt;Type == EfiMemoryMappedIO)       ? VM_WIMG_IO   : VM_WIMG_USE_DEFAULT);
	    }
	}

        <span class="enscript-keyword">if</span> (args-&gt;Version != kBootArgsVersion2)
            panic(<span class="enscript-string">&quot;Incompatible boot args version %d revision %d\n&quot;</span>, args-&gt;Version, args-&gt;Revision);

	DPRINTF(<span class="enscript-string">&quot;Boot args version %d revision %d mode %d\n&quot;</span>, args-&gt;Version, args-&gt;Revision, args-&gt;efiMode);
        <span class="enscript-keyword">if</span> (args-&gt;efiMode == kBootArgsEfiMode64) {
            efi_set_tables_64((EFI_SYSTEM_TABLE_64 *) ml_static_ptovirt(args-&gt;efiSystemTable));
        } <span class="enscript-keyword">else</span> {
            efi_set_tables_32((EFI_SYSTEM_TABLE_32 *) ml_static_ptovirt(args-&gt;efiSystemTable));
        }
    }
    <span class="enscript-keyword">while</span> (FALSE);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* Remap EFI runtime areas. */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hibernate_newruntime_map</span>(<span class="enscript-type">void</span> * map, vm_size_t map_size, uint32_t system_table_offset)
{
    boot_args *args = (boot_args *)PE_state.bootArgs;

    kprintf(<span class="enscript-string">&quot;Reinitializing EFI runtime services\n&quot;</span>);

    <span class="enscript-keyword">do</span>
    {
        vm_offset_t vm_size, vm_addr;
	vm_map_offset_t phys_addr;
	EfiMemoryRange *mptr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> msize, mcount;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	gPEEFISystemTable     = 0;
	gPEEFIRuntimeServices = 0;

	system_table_offset += ptoa_32(args-&gt;efiRuntimeServicesPageStart);

	kprintf(<span class="enscript-string">&quot;Old system table 0x%x, new 0x%x\n&quot;</span>,
	    (uint32_t)args-&gt;efiSystemTable,    system_table_offset);

	args-&gt;efiSystemTable    = system_table_offset;

	kprintf(<span class="enscript-string">&quot;Old map:\n&quot;</span>);
	msize = args-&gt;MemoryMapDescriptorSize;
	mcount = args-&gt;MemoryMapSize / msize;
	mptr = (EfiMemoryRange *)ml_static_ptovirt(args-&gt;MemoryMap);
	<span class="enscript-keyword">for</span> (i=0; i &lt; mcount; i++, mptr = (EfiMemoryRange *)(((vm_offset_t)mptr) + msize)) {
	    <span class="enscript-keyword">if</span> ((mptr-&gt;Attribute &amp; EFI_MEMORY_RUNTIME) == EFI_MEMORY_RUNTIME) {

		vm_size = (vm_offset_t)i386_ptob((uint32_t)mptr-&gt;NumberOfPages);
		vm_addr =   (vm_offset_t) mptr-&gt;VirtualStart;
		<span class="enscript-comment">/* K64 on EFI32 */</span>
		<span class="enscript-keyword">if</span> (vm_addr &lt; VM_MIN_KERNEL_ADDRESS)
			vm_addr |= VM_MIN_KERNEL_ADDRESS;
		phys_addr = (vm_map_offset_t) mptr-&gt;PhysicalStart;

		kprintf(<span class="enscript-string">&quot;mapping[%u] %qx @ %lx, %llu\n&quot;</span>, mptr-&gt;Type, phys_addr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)vm_addr, mptr-&gt;NumberOfPages);
	    }
	}

	pmap_remove(kernel_pmap, i386_ptob(args-&gt;efiRuntimeServicesPageStart), 
				 i386_ptob(args-&gt;efiRuntimeServicesPageStart + args-&gt;efiRuntimeServicesPageCount));

	kprintf(<span class="enscript-string">&quot;New map:\n&quot;</span>);
	msize = args-&gt;MemoryMapDescriptorSize;
	mcount = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> )(map_size / msize);
	mptr = map;
	<span class="enscript-keyword">for</span> (i=0; i &lt; mcount; i++, mptr = (EfiMemoryRange *)(((vm_offset_t)mptr) + msize)) {
	    <span class="enscript-keyword">if</span> ((mptr-&gt;Attribute &amp; EFI_MEMORY_RUNTIME) == EFI_MEMORY_RUNTIME) {

		vm_size = (vm_offset_t)i386_ptob((uint32_t)mptr-&gt;NumberOfPages);
		vm_addr =   (vm_offset_t) mptr-&gt;VirtualStart;
		<span class="enscript-keyword">if</span> (vm_addr &lt; VM_MIN_KERNEL_ADDRESS)
			vm_addr |= VM_MIN_KERNEL_ADDRESS;
		phys_addr = (vm_map_offset_t) mptr-&gt;PhysicalStart;

		kprintf(<span class="enscript-string">&quot;mapping[%u] %qx @ %lx, %llu\n&quot;</span>, mptr-&gt;Type, phys_addr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)vm_addr, mptr-&gt;NumberOfPages);

		pmap_map(vm_addr, phys_addr, phys_addr + round_page(vm_size),
			 (mptr-&gt;Type == kEfiRuntimeServicesCode) ? VM_PROT_READ | VM_PROT_EXECUTE : VM_PROT_READ|VM_PROT_WRITE,
			 (mptr-&gt;Type == EfiMemoryMappedIO)       ? VM_WIMG_IO   : VM_WIMG_USE_DEFAULT);
	    }
	}

        <span class="enscript-keyword">if</span> (args-&gt;Version != kBootArgsVersion2)
            panic(<span class="enscript-string">&quot;Incompatible boot args version %d revision %d\n&quot;</span>, args-&gt;Version, args-&gt;Revision);

        kprintf(<span class="enscript-string">&quot;Boot args version %d revision %d mode %d\n&quot;</span>, args-&gt;Version, args-&gt;Revision, args-&gt;efiMode);
        <span class="enscript-keyword">if</span> (args-&gt;efiMode == kBootArgsEfiMode64) {
	    efi_set_tables_64((EFI_SYSTEM_TABLE_64 *) ml_static_ptovirt(args-&gt;efiSystemTable));
        } <span class="enscript-keyword">else</span> {
	    efi_set_tables_32((EFI_SYSTEM_TABLE_32 *) ml_static_ptovirt(args-&gt;efiSystemTable));
        }
    }
    <span class="enscript-keyword">while</span> (FALSE);

    kprintf(<span class="enscript-string">&quot;Done reinitializing EFI runtime services\n&quot;</span>);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Find devices.  The system is alive.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* Now with VM up, switch to dynamically allocated cpu data */</span>
	cpu_data_realloc();

        <span class="enscript-comment">/* Ensure panic buffer is initialized. */</span>
        debug_log_init();

	<span class="enscript-comment">/*
	 * Display CPU identification
	 */</span>
	cpuid_cpu_display(<span class="enscript-string">&quot;CPU identification&quot;</span>);
	cpuid_feature_display(<span class="enscript-string">&quot;CPU features&quot;</span>);
	cpuid_extfeature_display(<span class="enscript-string">&quot;CPU extended features&quot;</span>);

        <span class="enscript-comment">/*
         * Initialize EFI runtime services.
         */</span>
        efi_init();

	smp_init();

	<span class="enscript-comment">/*
	 * Set up to use floating point.
	 */</span>
	init_fpu();

	<span class="enscript-comment">/*
	 * Configure clock devices.
	 */</span>
	clock_config();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MTRR</span>
	<span class="enscript-comment">/*
	 * Initialize MTRR from boot processor.
	 */</span>
	mtrr_init();

	<span class="enscript-comment">/*
	 * Set up PAT for boot processor.
	 */</span>
	pat_init();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Free lowmem pages and complete other setup
	 */</span>
	pmap_lowmem_finalize();
}

<span class="enscript-comment">/*
 * Halt a cpu.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">halt_cpu</span>(<span class="enscript-type">void</span>)
{
	halt_all_cpus(FALSE);
}

<span class="enscript-type">int</span> reset_mem_on_reboot = 1;

<span class="enscript-comment">/*
 * Halt the system or reboot.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">halt_all_cpus</span>(boolean_t reboot)
{
	<span class="enscript-keyword">if</span> (reboot) {
		printf(<span class="enscript-string">&quot;MACH Reboot\n&quot;</span>);
		PEHaltRestart( kPERestartCPU );
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;CPU halted\n&quot;</span>);
		PEHaltRestart( kPEHaltCPU );
	}
	<span class="enscript-keyword">while</span>(1);
}

 
<span class="enscript-comment">/* Issue an I/O port read if one has been requested - this is an event logic
 * analyzers can use as a trigger point.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">panic_io_port_read</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">if</span> (panic_io_port)
		(<span class="enscript-type">void</span>)inb(panic_io_port);
}

<span class="enscript-comment">/* For use with the MP rendezvous mechanism
 */</span>

uint64_t panic_restart_timeout = ~(0ULL);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PANIC_RESTART_TIMEOUT</span> (3ULL * NSEC_PER_SEC)

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">machine_halt_cpu</span>(<span class="enscript-type">void</span>) {
	uint64_t deadline;

	panic_io_port_read();

	<span class="enscript-comment">/* Halt here forever if we're not rebooting */</span>
	<span class="enscript-keyword">if</span> (!PE_reboot_on_panic() &amp;&amp; panic_restart_timeout == ~(0ULL)) {
		pmCPUHalt(PM_HALT_DEBUG);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (PE_reboot_on_panic())
		deadline = mach_absolute_time() + PANIC_RESTART_TIMEOUT;
	<span class="enscript-keyword">else</span>
		deadline = mach_absolute_time() + panic_restart_timeout;

	<span class="enscript-keyword">while</span> (mach_absolute_time() &lt; deadline)
		cpu_pause();

	kprintf(<span class="enscript-string">&quot;Invoking PE_halt_restart\n&quot;</span>);
	<span class="enscript-comment">/* Attempt restart via ACPI RESET_REG; at the time of this
	 * writing, this is routine is chained through AppleSMC-&gt;
	 * AppleACPIPlatform
	 */</span>
	<span class="enscript-keyword">if</span> (PE_halt_restart)
		(*PE_halt_restart)(kPERestartCPU);
	pmCPUHalt(PM_HALT_DEBUG);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pid_from_task</span>(task_t task)
{
        <span class="enscript-type">int</span> pid = -1;

        <span class="enscript-keyword">if</span> (task-&gt;bsd_info)
                pid = proc_pid(task-&gt;bsd_info);

        <span class="enscript-keyword">return</span> pid;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">DebuggerWithContext</span>(
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	reason,
	__unused <span class="enscript-type">void</span> 		*ctx,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*message)
{
	Debugger(message);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">Debugger</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*message)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> pi_size = 0;
	<span class="enscript-type">void</span> *stackptr;
	<span class="enscript-type">int</span> cn = cpu_number();
	task_t task = current_task();
	<span class="enscript-type">int</span>	task_pid = pid_from_task(task);
	boolean_t old_doprnt_hide_pointers = doprnt_hide_pointers;

	hw_atomic_add(&amp;debug_mode, 1);   
	<span class="enscript-keyword">if</span> (!panic_is_inited) {
		postcode(PANIC_HLT);
		asm(<span class="enscript-string">&quot;hlt&quot;</span>);
	}

	doprnt_hide_pointers = FALSE;

	printf(<span class="enscript-string">&quot;Debugger called: &lt;%s&gt;\n&quot;</span>, message);
	kprintf(<span class="enscript-string">&quot;Debugger called: &lt;%s&gt;\n&quot;</span>, message);

	<span class="enscript-comment">/*
	 * Skip the graphical panic box if no panic string.
	 * This is the case if we're being called from
	 *   host_reboot(,HOST_REBOOT_DEBUGGER)
	 * as a quiet way into the debugger.
	 */</span>

	<span class="enscript-keyword">if</span> (panicstr) {
		disable_preemption();

<span class="enscript-comment">/* Issue an I/O port read if one has been requested - this is an event logic
 * analyzers can use as a trigger point.
 */</span>
		panic_io_port_read();

		<span class="enscript-comment">/* Obtain current frame pointer */</span>
		__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;movq %%rbp, %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (stackptr));

		<span class="enscript-comment">/* Print backtrace - callee is internally synchronized */</span>
		<span class="enscript-keyword">if</span> (task_pid == 1 &amp;&amp; (init_task_died)) {
			<span class="enscript-comment">/* Special handling of launchd died panics */</span>
			print_launchd_info();
		} <span class="enscript-keyword">else</span> {
			panic_i386_backtrace(stackptr, ((panic_double_fault_cpu == cn) ? 80: 48), NULL, FALSE, NULL);
		}

		<span class="enscript-comment">/* everything should be printed now so copy to NVRAM
		 */</span>

		<span class="enscript-keyword">if</span>( debug_buf_size &gt; 0) {
		  <span class="enscript-comment">/* Optionally sync the panic log, if any, to NVRAM
		   * This is the default.
		   */</span>
		    <span class="enscript-keyword">if</span> (commit_paniclog_to_nvram) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bufpos;
			uintptr_t cr0;
			
			debug_putc(0);

			<span class="enscript-comment">/* Now call the compressor */</span>
			<span class="enscript-comment">/* XXX Consider using the WKdm compressor in the
			 * future, rather than just packing - would need to
			 * be co-ordinated with crashreporter, which decodes
			 * this post-restart. The compressor should be
			 * capable of in-place compression.
			 */</span>
			bufpos = packA(debug_buf,
			    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (debug_buf_ptr - debug_buf), debug_buf_size);
			<span class="enscript-comment">/* If compression was successful,
			 * use the compressed length
			 */</span>
			pi_size = bufpos ? bufpos : (<span class="enscript-type">unsigned</span>) (debug_buf_ptr - debug_buf);

			<span class="enscript-comment">/* Save panic log to non-volatile store
			 * Panic info handler must truncate data that is 
			 * too long for this platform.
			 * This call must save data synchronously,
			 * since we can subsequently halt the system.
			 */</span>


<span class="enscript-comment">/* The following sequence is a workaround for:
 * &lt;rdar://problem/5915669&gt; SnowLeopard10A67: AppleEFINVRAM should not invoke
 * any routines that use floating point (MMX in this case) when saving panic
 * logs to nvram/flash.
 */</span>
			cr0 = get_cr0();
			clear_ts();

			kprintf(<span class="enscript-string">&quot;Attempting to commit panic log to NVRAM\n&quot;</span>);
			pi_size = PESavePanicInfo((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)debug_buf,
					(uint32_t)pi_size );
			set_cr0(cr0);

			<span class="enscript-comment">/* Uncompress in-place, to permit examination of
			 * the panic log by debuggers.
			 */</span>

			<span class="enscript-keyword">if</span> (bufpos) {
			  unpackA(debug_buf, bufpos);
			}
                    }
                }

		<span class="enscript-keyword">if</span> (!panicDebugging) {
			<span class="enscript-type">unsigned</span> cnum;
			<span class="enscript-comment">/* Clear the MP rendezvous function lock, in the event
			 * that a panic occurred while in that codepath.
			 */</span>
			mp_rendezvous_break_lock();

			<span class="enscript-comment">/* Non-maskably interrupt all other processors
			 * If a restart timeout is specified, this processor
			 * will attempt a restart.
			 */</span>
			kprintf(<span class="enscript-string">&quot;Invoking machine_halt_cpu on CPU %d\n&quot;</span>, cn);
			<span class="enscript-keyword">for</span> (cnum = 0; cnum &lt; real_ncpus; cnum++) {
				<span class="enscript-keyword">if</span> (cnum != (<span class="enscript-type">unsigned</span>) cn) {
					cpu_NMI_interrupt(cnum);
				}
			}
			machine_halt_cpu();
			<span class="enscript-comment">/* NOT REACHED */</span>
		}
        }

	doprnt_hide_pointers = old_doprnt_hide_pointers;
	__asm__(<span class="enscript-string">&quot;int3&quot;</span>);
	hw_atomic_sub(&amp;debug_mode, 1);   
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">machine_boot_info</span>(<span class="enscript-type">char</span> *buf, __unused vm_size_t size)
{
	*buf =<span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">return</span> buf;
}

<span class="enscript-comment">/* Routines for address - symbol translation. Not called unless the &quot;keepsyms&quot;
 * boot-arg is supplied.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">panic_print_macho_symbol_name</span>(kernel_mach_header_t *mh, vm_address_t search, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *module_name)
{
    kernel_nlist_t	*sym = NULL;
    <span class="enscript-type">struct</span> load_command		*cmd;
    kernel_segment_command_t	*orig_ts = NULL, *orig_le = NULL;
    <span class="enscript-type">struct</span> symtab_command	*orig_st = NULL;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			i;
    <span class="enscript-type">char</span>					*strings, *bestsym = NULL;
    vm_address_t			bestaddr = 0, diff, curdiff;

    <span class="enscript-comment">/* Assume that if it's loaded and linked into the kernel, it's a valid Mach-O */</span>
    
    cmd = (<span class="enscript-type">struct</span> load_command *) &amp;mh[1];
    <span class="enscript-keyword">for</span> (i = 0; i &lt; mh-&gt;ncmds; i++) {
        <span class="enscript-keyword">if</span> (cmd-&gt;cmd == LC_SEGMENT_KERNEL) {
            kernel_segment_command_t *orig_sg = (kernel_segment_command_t *) cmd;
            
            <span class="enscript-keyword">if</span> (strncmp(SEG_TEXT, orig_sg-&gt;segname,
				    <span class="enscript-keyword">sizeof</span>(orig_sg-&gt;segname)) == 0)
                orig_ts = orig_sg;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strncmp(SEG_LINKEDIT, orig_sg-&gt;segname,
				    <span class="enscript-keyword">sizeof</span>(orig_sg-&gt;segname)) == 0)
                orig_le = orig_sg;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strncmp(<span class="enscript-string">&quot;&quot;</span>, orig_sg-&gt;segname,
				    <span class="enscript-keyword">sizeof</span>(orig_sg-&gt;segname)) == 0)
                orig_ts = orig_sg; <span class="enscript-comment">/* pre-Lion i386 kexts have a single unnamed segment */</span>
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;cmd == LC_SYMTAB)
            orig_st = (<span class="enscript-type">struct</span> symtab_command *) cmd;
        
        cmd = (<span class="enscript-type">struct</span> load_command *) ((uintptr_t) cmd + cmd-&gt;cmdsize);
    }
    
    <span class="enscript-keyword">if</span> ((orig_ts == NULL) || (orig_st == NULL) || (orig_le == NULL))
        <span class="enscript-keyword">return</span> 0;
    
    <span class="enscript-keyword">if</span> ((search &lt; orig_ts-&gt;vmaddr) ||
        (search &gt;= orig_ts-&gt;vmaddr + orig_ts-&gt;vmsize)) {
        <span class="enscript-comment">/* search out of range for this mach header */</span>
        <span class="enscript-keyword">return</span> 0;
    }
    
    sym = (kernel_nlist_t *)(uintptr_t)(orig_le-&gt;vmaddr + orig_st-&gt;symoff - orig_le-&gt;fileoff);
    strings = (<span class="enscript-type">char</span> *)(uintptr_t)(orig_le-&gt;vmaddr + orig_st-&gt;stroff - orig_le-&gt;fileoff);
    diff = search;
    
    <span class="enscript-keyword">for</span> (i = 0; i &lt; orig_st-&gt;nsyms; i++) {
        <span class="enscript-keyword">if</span> (sym[i].n_type &amp; N_STAB) <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> (sym[i].n_value &lt;= search) {
            curdiff = search - (vm_address_t)sym[i].n_value;
            <span class="enscript-keyword">if</span> (curdiff &lt; diff) {
                diff = curdiff;
                bestaddr = sym[i].n_value;
                bestsym = strings + sym[i].n_un.n_strx;
            }
        }
    }
    
    <span class="enscript-keyword">if</span> (bestsym != NULL) {
        <span class="enscript-keyword">if</span> (diff != 0) {
            kdb_printf(<span class="enscript-string">&quot;%s : %s + 0x%lx&quot;</span>, module_name, bestsym, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)diff);
        } <span class="enscript-keyword">else</span> {
            kdb_printf(<span class="enscript-string">&quot;%s : %s&quot;</span>, module_name, bestsym);
        }
        <span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">extern</span> kmod_info_t * kmod; <span class="enscript-comment">/* the list of modules */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">panic_print_kmod_symbol_name</span>(vm_address_t search)
{
    u_int i;

    <span class="enscript-keyword">if</span> (gLoadedKextSummaries == NULL)
	    <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; gLoadedKextSummaries-&gt;numSummaries; ++i) {
        OSKextLoadedKextSummary *summary = gLoadedKextSummaries-&gt;summaries + i;

        <span class="enscript-keyword">if</span> ((search &gt;= summary-&gt;address) &amp;&amp;
            (search &lt; (summary-&gt;address + summary-&gt;size)))
        {
            kernel_mach_header_t *header = (kernel_mach_header_t *)(uintptr_t) summary-&gt;address;
            <span class="enscript-keyword">if</span> (panic_print_macho_symbol_name(header, search, summary-&gt;name) == 0) {
                kdb_printf(<span class="enscript-string">&quot;%s + %llu&quot;</span>, summary-&gt;name, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)search - summary-&gt;address);
            }
            <span class="enscript-keyword">break</span>;
        }
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">panic_print_symbol_name</span>(vm_address_t search)
{
    <span class="enscript-comment">/* try searching in the kernel */</span>
    <span class="enscript-keyword">if</span> (panic_print_macho_symbol_name(&amp;_mh_execute_header, search, <span class="enscript-string">&quot;mach_kernel&quot;</span>) == 0) {
        <span class="enscript-comment">/* that failed, now try to search for the right kext */</span>
        panic_print_kmod_symbol_name(search);
    }
}

<span class="enscript-comment">/* Generate a backtrace, given a frame pointer - this routine
 * should walk the stack safely. The trace is appended to the panic log
 * and conditionally, to the console. If the trace contains kernel module
 * addresses, display the module name, load address and dependencies.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DUMPFRAMES</span> 32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PBT_TIMEOUT_CYCLES</span> (5 * 1000 * 1000 * 1000ULL)
<span class="enscript-type">void</span>
<span class="enscript-function-name">panic_i386_backtrace</span>(<span class="enscript-type">void</span> *_frame, <span class="enscript-type">int</span> nframes, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg, boolean_t regdump, x86_saved_state_t *regs)
{
	cframe_t	*frame = (cframe_t *)_frame;
	vm_offset_t raddrs[DUMPFRAMES];
	vm_offset_t PC = 0;
	<span class="enscript-type">int</span> frame_index;
	<span class="enscript-type">volatile</span> uint32_t *ppbtcnt = &amp;pbtcnt;
	uint64_t bt_tsc_timeout;
	boolean_t keepsyms = FALSE;
	<span class="enscript-type">int</span> cn = cpu_number();
	boolean_t old_doprnt_hide_pointers = doprnt_hide_pointers;

	<span class="enscript-keyword">if</span>(pbtcpu != cn) {
		hw_atomic_add(&amp;pbtcnt, 1);
		<span class="enscript-comment">/* Spin on print backtrace lock, which serializes output
		 * Continue anyway if a timeout occurs.
		 */</span>
		hw_lock_to(&amp;pbtlock, ~0U);
		pbtcpu = cn;
	}

	<span class="enscript-keyword">if</span> (__improbable(doprnt_hide_pointers == TRUE)) {
		<span class="enscript-comment">/* If we're called directly, the Debugger() function will not be called,
		 * so we need to reset the value in here. */</span>
		doprnt_hide_pointers = FALSE;
	}

	panic_check_hook();

	PE_parse_boot_argn(<span class="enscript-string">&quot;keepsyms&quot;</span>, &amp;keepsyms, <span class="enscript-keyword">sizeof</span> (keepsyms));

	<span class="enscript-keyword">if</span> (msg != NULL) {
		kdb_printf(<span class="enscript-string">&quot;%s&quot;</span>, msg);
	}

	<span class="enscript-keyword">if</span> ((regdump == TRUE) &amp;&amp; (regs != NULL)) {
		x86_saved_state64_t	*ss64p = saved_state64(regs);
		kdb_printf(
		    <span class="enscript-string">&quot;RAX: 0x%016llx, RBX: 0x%016llx, RCX: 0x%016llx, RDX: 0x%016llx\n&quot;</span>
		    <span class="enscript-string">&quot;RSP: 0x%016llx, RBP: 0x%016llx, RSI: 0x%016llx, RDI: 0x%016llx\n&quot;</span>
		    <span class="enscript-string">&quot;R8:  0x%016llx, R9:  0x%016llx, R10: 0x%016llx, R11: 0x%016llx\n&quot;</span>
		    <span class="enscript-string">&quot;R12: 0x%016llx, R13: 0x%016llx, R14: 0x%016llx, R15: 0x%016llx\n&quot;</span>
		    <span class="enscript-string">&quot;RFL: 0x%016llx, RIP: 0x%016llx, CS:  0x%016llx, SS:  0x%016llx\n&quot;</span>,
		    ss64p-&gt;rax, ss64p-&gt;rbx, ss64p-&gt;rcx, ss64p-&gt;rdx,
		    ss64p-&gt;isf.rsp, ss64p-&gt;rbp, ss64p-&gt;rsi, ss64p-&gt;rdi,
		    ss64p-&gt;r8,  ss64p-&gt;r9,  ss64p-&gt;r10, ss64p-&gt;r11,
		    ss64p-&gt;r12, ss64p-&gt;r13, ss64p-&gt;r14, ss64p-&gt;r15,
		    ss64p-&gt;isf.rflags, ss64p-&gt;isf.rip, ss64p-&gt;isf.cs,
		    ss64p-&gt;isf.ss);
		PC = ss64p-&gt;isf.rip;
	}

	kdb_printf(<span class="enscript-string">&quot;Backtrace (CPU %d), &quot;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRINT_ARGS_FROM_STACK_FRAME</span>
	<span class="enscript-string">&quot;Frame : Return Address (4 potential args on stack)\n&quot;</span>, cn);
#<span class="enscript-reference">else</span>
	<span class="enscript-string">&quot;Frame : Return Address\n&quot;</span>, cn);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">for</span> (frame_index = 0; frame_index &lt; nframes; frame_index++) {
		vm_offset_t curframep = (vm_offset_t) frame;

		<span class="enscript-keyword">if</span> (!curframep)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (curframep &amp; 0x3) {
			kdb_printf(<span class="enscript-string">&quot;Unaligned frame\n&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
		}

		<span class="enscript-keyword">if</span> (!kvtophys(curframep) ||
		    !kvtophys(curframep + <span class="enscript-keyword">sizeof</span>(cframe_t) - 1)) {
			kdb_printf(<span class="enscript-string">&quot;No mapping exists for frame pointer\n&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
		}

		kdb_printf(<span class="enscript-string">&quot;%p : 0x%lx &quot;</span>, frame, frame-&gt;caller);
		<span class="enscript-keyword">if</span> (frame_index &lt; DUMPFRAMES)
			raddrs[frame_index] = frame-&gt;caller;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRINT_ARGS_FROM_STACK_FRAME</span>
		<span class="enscript-keyword">if</span> (kvtophys((vm_offset_t)&amp;(frame-&gt;args[3])))
			kdb_printf(<span class="enscript-string">&quot;(0x%x 0x%x 0x%x 0x%x) &quot;</span>,
			    frame-&gt;args[0], frame-&gt;args[1],
			    frame-&gt;args[2], frame-&gt;args[3]);
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/* Display address-symbol translation only if the &quot;keepsyms&quot;
		 * boot-arg is suppplied, since we unload LINKEDIT otherwise.
		 * This routine is potentially unsafe; also, function
		 * boundary identification is unreliable after a strip -x.
		 */</span>
		<span class="enscript-keyword">if</span> (keepsyms)
			panic_print_symbol_name((vm_address_t)frame-&gt;caller);
		
		kdb_printf(<span class="enscript-string">&quot;\n&quot;</span>);

		frame = frame-&gt;prev;
	}

	<span class="enscript-keyword">if</span> (frame_index &gt;= nframes)
		kdb_printf(<span class="enscript-string">&quot;\tBacktrace continues...\n&quot;</span>);

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">invalid</span>:
	kdb_printf(<span class="enscript-string">&quot;Backtrace terminated-invalid frame pointer %p\n&quot;</span>,frame);
<span class="enscript-reference">out</span>:

	<span class="enscript-comment">/* Identify kernel modules in the backtrace and display their
	 * load addresses and dependencies. This routine should walk
	 * the kmod list safely.
	 */</span>
	<span class="enscript-keyword">if</span> (frame_index)
		kmod_panic_dump((vm_offset_t *)&amp;raddrs[0], frame_index);

	<span class="enscript-keyword">if</span> (PC != 0)
		kmod_panic_dump(&amp;PC, 1);

	panic_display_system_configuration();

	doprnt_hide_pointers = old_doprnt_hide_pointers;

	<span class="enscript-comment">/* Release print backtrace lock, to permit other callers in the
	 * event of panics on multiple processors.
	 */</span>
	hw_lock_unlock(&amp;pbtlock);
	hw_atomic_sub(&amp;pbtcnt, 1);
	<span class="enscript-comment">/* Wait for other processors to complete output
	 * Timeout and continue after PBT_TIMEOUT_CYCLES.
	 */</span>
	bt_tsc_timeout = rdtsc64() + PBT_TIMEOUT_CYCLES;
	<span class="enscript-keyword">while</span>(*ppbtcnt &amp;&amp; (rdtsc64() &lt; bt_tsc_timeout));
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">debug_copyin</span>(pmap_t p, uint64_t uaddr, <span class="enscript-type">void</span> *dest, size_t size)
{
        size_t rem = size;
        <span class="enscript-type">char</span> *kvaddr = dest;

        <span class="enscript-keyword">while</span> (rem) {
                ppnum_t upn = pmap_find_phys(p, uaddr);
                uint64_t phys_src = ptoa_64(upn) | (uaddr &amp; PAGE_MASK);
                uint64_t phys_dest = kvtophys((vm_offset_t)kvaddr);
                uint64_t src_rem = PAGE_SIZE - (phys_src &amp; PAGE_MASK);
                uint64_t dst_rem = PAGE_SIZE - (phys_dest &amp; PAGE_MASK);
                size_t cur_size = (uint32_t) MIN(src_rem, dst_rem);
                cur_size = MIN(cur_size, rem);

                <span class="enscript-keyword">if</span> (upn &amp;&amp; pmap_valid_page(upn) &amp;&amp; phys_dest) {
                        bcopy_phys(phys_src, phys_dest, cur_size);
                }
                <span class="enscript-keyword">else</span>
                        <span class="enscript-keyword">break</span>;
                uaddr += cur_size;
                kvaddr += cur_size;
                rem -= cur_size;
        }
        <span class="enscript-keyword">return</span> (rem == 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_threads_registers</span>(thread_t thread)
{
	x86_saved_state_t *savestate;
	
	savestate = get_user_regs(thread);
	kdb_printf(
		<span class="enscript-string">&quot;\nRAX: 0x%016llx, RBX: 0x%016llx, RCX: 0x%016llx, RDX: 0x%016llx\n&quot;</span>
	    <span class="enscript-string">&quot;RSP: 0x%016llx, RBP: 0x%016llx, RSI: 0x%016llx, RDI: 0x%016llx\n&quot;</span>
	    <span class="enscript-string">&quot;R8:  0x%016llx, R9:  0x%016llx, R10: 0x%016llx, R11: 0x%016llx\n&quot;</span>
		<span class="enscript-string">&quot;R12: 0x%016llx, R13: 0x%016llx, R14: 0x%016llx, R15: 0x%016llx\n&quot;</span>
		<span class="enscript-string">&quot;RFL: 0x%016llx, RIP: 0x%016llx, CS:  0x%016llx, SS:  0x%016llx\n\n&quot;</span>,
		savestate-&gt;ss_64.rax, savestate-&gt;ss_64.rbx, savestate-&gt;ss_64.rcx, savestate-&gt;ss_64.rdx,
		savestate-&gt;ss_64.isf.rsp, savestate-&gt;ss_64.rbp, savestate-&gt;ss_64.rsi, savestate-&gt;ss_64.rdi,
		savestate-&gt;ss_64.r8, savestate-&gt;ss_64.r9,  savestate-&gt;ss_64.r10, savestate-&gt;ss_64.r11,
		savestate-&gt;ss_64.r12, savestate-&gt;ss_64.r13, savestate-&gt;ss_64.r14, savestate-&gt;ss_64.r15,
		savestate-&gt;ss_64.isf.rflags, savestate-&gt;ss_64.isf.rip, savestate-&gt;ss_64.isf.cs,
		savestate-&gt;ss_64.isf.ss);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_tasks_user_threads</span>(task_t task)
{
	thread_t		thread = current_thread();
	x86_saved_state_t *savestate;
	pmap_t			pmap = 0;
	uint64_t		rbp;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*cur_marker = 0;
	<span class="enscript-type">int</span>             j;
	
	<span class="enscript-keyword">for</span> (j = 0, thread = (thread_t) queue_first(&amp;task-&gt;threads); j &lt; task-&gt;thread_count;
			++j, thread = (thread_t) queue_next(&amp;thread-&gt;task_threads)) {

		kdb_printf(<span class="enscript-string">&quot;Thread %d: %p\n&quot;</span>, j, thread);
		pmap = get_task_pmap(task);
		savestate = get_user_regs(thread);
		rbp = savestate-&gt;ss_64.rbp;
		print_one_backtrace(pmap, (vm_offset_t)rbp, cur_marker, TRUE, TRUE);
		kdb_printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_thread_num_that_crashed</span>(task_t task)
{
	thread_t		c_thread = current_thread();
	thread_t		thread;
	<span class="enscript-type">int</span>             j;
	
	<span class="enscript-keyword">for</span> (j = 0, thread = (thread_t) queue_first(&amp;task-&gt;threads); j &lt; task-&gt;thread_count;
			++j, thread = (thread_t) queue_next(&amp;thread-&gt;task_threads)) {

		<span class="enscript-keyword">if</span> (c_thread == thread) {
			kdb_printf(<span class="enscript-string">&quot;\nThread %d crashed\n&quot;</span>, j);
			<span class="enscript-keyword">break</span>;
		}
	}
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PANICLOG_UUID_BUF_SIZE</span> 256

<span class="enscript-type">void</span> <span class="enscript-function-name">print_uuid_info</span>(task_t task)
{
	uint32_t		uuid_info_count = 0;
	mach_vm_address_t	uuid_info_addr = 0;
	boolean_t		have_map = (task-&gt;map != NULL) &amp;&amp;	(ml_validate_nofault((vm_offset_t)(task-&gt;map), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> _vm_map)));
	boolean_t		have_pmap = have_map &amp;&amp; (task-&gt;map-&gt;pmap != NULL) &amp;&amp; (ml_validate_nofault((vm_offset_t)(task-&gt;map-&gt;pmap), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pmap)));
	<span class="enscript-type">int</span>				task_pid = pid_from_task(task);
	<span class="enscript-type">char</span>			uuidbuf[PANICLOG_UUID_BUF_SIZE] = {0};
	<span class="enscript-type">char</span>			*uuidbufptr = uuidbuf;
	uint32_t		k;

	<span class="enscript-keyword">if</span> (have_pmap &amp;&amp; task-&gt;active &amp;&amp; task_pid &gt; 0) {
		<span class="enscript-comment">/* Read dyld_all_image_infos struct from task memory to get UUID array count &amp; location */</span>
		<span class="enscript-type">struct</span> user64_dyld_all_image_infos task_image_infos;
		<span class="enscript-keyword">if</span> (debug_copyin(task-&gt;map-&gt;pmap, task-&gt;all_image_info_addr,
			&amp;task_image_infos, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_dyld_all_image_infos))) {
			uuid_info_count = (uint32_t)task_image_infos.uuidArrayCount;
			uuid_info_addr = task_image_infos.uuidArray;
		}

		<span class="enscript-comment">/* If we get a NULL uuid_info_addr (which can happen when we catch dyld
		 * in the middle of updating this data structure), we zero the
		 * uuid_info_count so that we won't even try to save load info for this task
		 */</span>
		<span class="enscript-keyword">if</span> (!uuid_info_addr) {
			uuid_info_count = 0;
		}
	}

	<span class="enscript-keyword">if</span> (task_pid &gt; 0 &amp;&amp; uuid_info_count &gt; 0) {
		uint32_t uuid_info_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_dyld_uuid_info);
		uint32_t uuid_array_size = uuid_info_count * uuid_info_size;
		uint32_t uuid_copy_size = 0;
		uint32_t uuid_image_count = 0;
		<span class="enscript-type">char</span> *current_uuid_buffer = NULL;
		<span class="enscript-comment">/* Copy in the UUID info array. It may be nonresident, in which case just fix up nloadinfos to 0 */</span>
		
		kdb_printf(<span class="enscript-string">&quot;\nuuid info:\n&quot;</span>);
		<span class="enscript-keyword">while</span> (uuid_array_size) {
			<span class="enscript-keyword">if</span> (uuid_array_size &lt;= PANICLOG_UUID_BUF_SIZE) {
				uuid_copy_size = uuid_array_size;
				uuid_image_count = uuid_array_size/uuid_info_size;
			} <span class="enscript-keyword">else</span> {
				uuid_image_count = PANICLOG_UUID_BUF_SIZE/uuid_info_size;
				uuid_copy_size = uuid_image_count * uuid_info_size;
			}
			<span class="enscript-keyword">if</span> (have_pmap &amp;&amp; !debug_copyin(task-&gt;map-&gt;pmap, uuid_info_addr, uuidbufptr,
				uuid_copy_size)) {
				kdb_printf(<span class="enscript-string">&quot;Error!! Failed to copy UUID info for task %p pid %d\n&quot;</span>, task, task_pid);
				uuid_image_count = 0;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (uuid_image_count &gt; 0) {
				current_uuid_buffer = uuidbufptr;
				<span class="enscript-keyword">for</span> (k = 0; k &lt; uuid_image_count; k++) {
					kdb_printf(<span class="enscript-string">&quot; %#llx&quot;</span>, *(uint64_t *)current_uuid_buffer);
					current_uuid_buffer += <span class="enscript-keyword">sizeof</span>(uint64_t);
					uint8_t *uuid = (uint8_t *)current_uuid_buffer;
					kdb_printf(<span class="enscript-string">&quot;\tuuid = &lt;%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x&gt;\n&quot;</span>,
					uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7], uuid[8],
					uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);
					current_uuid_buffer += 16;
				}
				bzero(&amp;uuidbuf, <span class="enscript-keyword">sizeof</span>(uuidbuf));
			}
			uuid_info_addr += uuid_copy_size;
			uuid_array_size -= uuid_copy_size;
		}
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">print_launchd_info</span>(<span class="enscript-type">void</span>)
{
	task_t		task = current_task();
	thread_t	thread = current_thread();
	<span class="enscript-type">volatile</span>	uint32_t *ppbtcnt = &amp;pbtcnt;
	uint64_t	bt_tsc_timeout;
	<span class="enscript-type">int</span>		cn = cpu_number();

	<span class="enscript-keyword">if</span>(pbtcpu != cn) {
		hw_atomic_add(&amp;pbtcnt, 1);
		<span class="enscript-comment">/* Spin on print backtrace lock, which serializes output
		 * Continue anyway if a timeout occurs.
		 */</span>
		hw_lock_to(&amp;pbtlock, ~0U);
		pbtcpu = cn;
	}
	
	print_uuid_info(task);
	print_thread_num_that_crashed(task);
	print_threads_registers(thread);
	print_tasks_user_threads(task);
	kdb_printf(<span class="enscript-string">&quot;Mac OS version: %s\n&quot;</span>, (osversion[0] != 0) ? osversion : <span class="enscript-string">&quot;Not yet set&quot;</span>);
	kdb_printf(<span class="enscript-string">&quot;Kernel version: %s\n&quot;</span>, version);
	panic_display_kernel_uuid();
	panic_display_model_name();
	
	<span class="enscript-comment">/* Release print backtrace lock, to permit other callers in the
	 * event of panics on multiple processors.
	 */</span>
	hw_lock_unlock(&amp;pbtlock);
	hw_atomic_sub(&amp;pbtcnt, 1);
	<span class="enscript-comment">/* Wait for other processors to complete output
	 * Timeout and continue after PBT_TIMEOUT_CYCLES.
	 */</span>
	bt_tsc_timeout = rdtsc64() + PBT_TIMEOUT_CYCLES;
	<span class="enscript-keyword">while</span>(*ppbtcnt &amp;&amp; (rdtsc64() &lt; bt_tsc_timeout));

}
</pre>
<hr />
</body></html>