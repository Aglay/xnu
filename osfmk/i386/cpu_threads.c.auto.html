<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>cpu_threads.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">cpu_threads.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_threads.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/bit_routines.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIVISOR_GUARD</span>(denom)				\
	<span class="enscript-keyword">if</span> ((denom) == 0) {				\
		kprintf(<span class="enscript-string">&quot;%s: %d Zero divisor: &quot;</span> #denom,	\
			__FILE__, __LINE__);		\
	}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">debug_topology_print</span>(<span class="enscript-type">void</span>);

boolean_t	topo_dbg = FALSE;

x86_pkg_t	*x86_pkgs		= NULL;
uint32_t	num_Lx_caches[MAX_CACHE_DEPTH]	= { 0 };

<span class="enscript-type">static</span> x86_pkg_t	*free_pkgs	= NULL;
<span class="enscript-type">static</span> x86_die_t	*free_dies	= NULL;
<span class="enscript-type">static</span> x86_core_t	*free_cores	= NULL;
<span class="enscript-type">static</span> uint32_t		num_dies	= 0;

<span class="enscript-type">static</span> x86_cpu_cache_t	*x86_caches	= NULL;
<span class="enscript-type">static</span> uint32_t		num_caches	= 0;

<span class="enscript-type">static</span> boolean_t	topoParmsInited	= FALSE;
x86_topology_parameters_t	topoParms;

<span class="enscript-function-name">decl_simple_lock_data</span>(, x86_topo_lock);
 
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cpu_cache {
	<span class="enscript-type">int</span>	level;	<span class="enscript-type">int</span>	type;
} cpu_caches [LCACHE_MAX] = {
	[L1D] = {	1,	CPU_CACHE_TYPE_DATA },
	[L1I] = {	1,	CPU_CACHE_TYPE_INST },
	[L2U] = { 2,	CPU_CACHE_TYPE_UNIF },
	[L3U] = { 3,	CPU_CACHE_TYPE_UNIF },
};

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">cpu_is_hyperthreaded</span>(<span class="enscript-type">void</span>)
{
    i386_cpu_info_t	*cpuinfo;

    cpuinfo = cpuid_info();
    <span class="enscript-keyword">return</span>(cpuinfo-&gt;thread_count &gt; cpuinfo-&gt;core_count);
}

<span class="enscript-type">static</span> x86_cpu_cache_t *
<span class="enscript-function-name">x86_cache_alloc</span>(<span class="enscript-type">void</span>)
{
    x86_cpu_cache_t	*cache;
    <span class="enscript-type">int</span>			i;

    <span class="enscript-keyword">if</span> (x86_caches == NULL) {
	cache = kalloc(<span class="enscript-keyword">sizeof</span>(x86_cpu_cache_t) + (MAX_CPUS * <span class="enscript-keyword">sizeof</span>(x86_lcpu_t *)));
	<span class="enscript-keyword">if</span> (cache == NULL)
	    <span class="enscript-keyword">return</span>(NULL);
    } <span class="enscript-keyword">else</span> {
	cache = x86_caches;
	x86_caches = cache-&gt;next;
	cache-&gt;next = NULL;
    }

    bzero(cache, <span class="enscript-keyword">sizeof</span>(x86_cpu_cache_t));
    cache-&gt;next = NULL;
    cache-&gt;maxcpus = MAX_CPUS;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; cache-&gt;maxcpus; i += 1) {
	cache-&gt;cpus[i] = NULL;
    }

    num_caches += 1;

    <span class="enscript-keyword">return</span>(cache);
}
 
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_LLC_info</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span>			cache_level	= 0;
    uint32_t		nCPUsSharing	= 1;
    i386_cpu_info_t	*cpuinfo;
    <span class="enscript-type">struct</span> cpu_cache	*cachep;
    <span class="enscript-type">int</span>			i;

    cpuinfo = cpuid_info();

    <span class="enscript-keyword">for</span> (i = 0, cachep = &amp;cpu_caches[0]; i &lt; LCACHE_MAX; i++, cachep++) {

	<span class="enscript-keyword">if</span> (cachep-&gt;type == 0 || cpuid_info()-&gt;cache_size[i] == 0)
	    <span class="enscript-keyword">continue</span>;

	<span class="enscript-comment">/*
	 * Only worry about it if it's a deeper level than
	 * what we've seen before.
	 */</span>
	<span class="enscript-keyword">if</span> (cachep-&gt;level &gt; cache_level) {
	    cache_level = cachep-&gt;level;

	    <span class="enscript-comment">/*
	     * Save the number of CPUs sharing this cache.
	     */</span>
	    nCPUsSharing = cpuinfo-&gt;cache_sharing[i];
	}
    }

    <span class="enscript-comment">/*
     * Make the level of the LLC be 0 based.
     */</span>
    topoParms.LLCDepth = cache_level - 1;

    <span class="enscript-comment">/*
     * nCPUsSharing represents the *maximum* number of cores or
     * logical CPUs sharing the cache.
     */</span>
    topoParms.maxSharingLLC = nCPUsSharing;

    topoParms.nCoresSharingLLC = nCPUsSharing / (cpuinfo-&gt;thread_count /
						 cpuinfo-&gt;core_count);
    topoParms.nLCPUsSharingLLC = nCPUsSharing;

    <span class="enscript-comment">/*
     * nCPUsSharing may not be the number of *active* cores or
     * threads that are sharing the cache.
     */</span>
    <span class="enscript-keyword">if</span> (nCPUsSharing &gt; cpuinfo-&gt;core_count)
	topoParms.nCoresSharingLLC = cpuinfo-&gt;core_count;
    <span class="enscript-keyword">if</span> (nCPUsSharing &gt; cpuinfo-&gt;thread_count)
	topoParms.nLCPUsSharingLLC = cpuinfo-&gt;thread_count;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">initTopoParms</span>(<span class="enscript-type">void</span>)
{
    i386_cpu_info_t	*cpuinfo;

    topoParms.stable = FALSE;

    cpuinfo = cpuid_info();

    PE_parse_boot_argn(<span class="enscript-string">&quot;-topo&quot;</span>, &amp;topo_dbg, <span class="enscript-keyword">sizeof</span>(topo_dbg));

    <span class="enscript-comment">/*
     * We need to start with getting the LLC information correct.
     */</span>
    x86_LLC_info();

    <span class="enscript-comment">/*
     * Compute the number of threads (logical CPUs) per core.
     */</span>
    DIVISOR_GUARD(cpuinfo-&gt;core_count);
    topoParms.nLThreadsPerCore = cpuinfo-&gt;thread_count / cpuinfo-&gt;core_count;
    DIVISOR_GUARD(cpuinfo-&gt;cpuid_cores_per_package);
    topoParms.nPThreadsPerCore = cpuinfo-&gt;cpuid_logical_per_package / cpuinfo-&gt;cpuid_cores_per_package;

    <span class="enscript-comment">/*
     * Compute the number of dies per package.
     */</span>
     DIVISOR_GUARD(topoParms.nCoresSharingLLC);
    topoParms.nLDiesPerPackage = cpuinfo-&gt;core_count / topoParms.nCoresSharingLLC;
    DIVISOR_GUARD(topoParms.nPThreadsPerCore);
    DIVISOR_GUARD(topoParms.maxSharingLLC / topoParms.nPThreadsPerCore);
    topoParms.nPDiesPerPackage = cpuinfo-&gt;cpuid_cores_per_package / (topoParms.maxSharingLLC / topoParms.nPThreadsPerCore);


    <span class="enscript-comment">/*
     * Compute the number of cores per die.
     */</span>
    topoParms.nLCoresPerDie = topoParms.nCoresSharingLLC;
    topoParms.nPCoresPerDie = (topoParms.maxSharingLLC / topoParms.nPThreadsPerCore);

    <span class="enscript-comment">/*
     * Compute the number of threads per die.
     */</span>
    topoParms.nLThreadsPerDie = topoParms.nLThreadsPerCore * topoParms.nLCoresPerDie;
    topoParms.nPThreadsPerDie = topoParms.nPThreadsPerCore * topoParms.nPCoresPerDie;

    <span class="enscript-comment">/*
     * Compute the number of cores per package.
     */</span>
    topoParms.nLCoresPerPackage = topoParms.nLCoresPerDie * topoParms.nLDiesPerPackage;
    topoParms.nPCoresPerPackage = topoParms.nPCoresPerDie * topoParms.nPDiesPerPackage;

    <span class="enscript-comment">/*
     * Compute the number of threads per package.
     */</span>
    topoParms.nLThreadsPerPackage = topoParms.nLThreadsPerCore * topoParms.nLCoresPerPackage;
    topoParms.nPThreadsPerPackage = topoParms.nPThreadsPerCore * topoParms.nPCoresPerPackage;

    TOPO_DBG(<span class="enscript-string">&quot;\nCache Topology Parameters:\n&quot;</span>);
    TOPO_DBG(<span class="enscript-string">&quot;\tLLC Depth:           %d\n&quot;</span>, topoParms.LLCDepth);
    TOPO_DBG(<span class="enscript-string">&quot;\tCores Sharing LLC:   %d\n&quot;</span>, topoParms.nCoresSharingLLC);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads Sharing LLC: %d\n&quot;</span>, topoParms.nLCPUsSharingLLC);
    TOPO_DBG(<span class="enscript-string">&quot;\tmax Sharing of LLC:  %d\n&quot;</span>, topoParms.maxSharingLLC);

    TOPO_DBG(<span class="enscript-string">&quot;\nLogical Topology Parameters:\n&quot;</span>);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads per Core:  %d\n&quot;</span>, topoParms.nLThreadsPerCore);
    TOPO_DBG(<span class="enscript-string">&quot;\tCores per Die:     %d\n&quot;</span>, topoParms.nLCoresPerDie);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads per Die:   %d\n&quot;</span>, topoParms.nLThreadsPerDie);
    TOPO_DBG(<span class="enscript-string">&quot;\tDies per Package:  %d\n&quot;</span>, topoParms.nLDiesPerPackage);
    TOPO_DBG(<span class="enscript-string">&quot;\tCores per Package: %d\n&quot;</span>, topoParms.nLCoresPerPackage);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads per Package: %d\n&quot;</span>, topoParms.nLThreadsPerPackage);

    TOPO_DBG(<span class="enscript-string">&quot;\nPhysical Topology Parameters:\n&quot;</span>);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads per Core: %d\n&quot;</span>, topoParms.nPThreadsPerCore);
    TOPO_DBG(<span class="enscript-string">&quot;\tCores per Die:     %d\n&quot;</span>, topoParms.nPCoresPerDie);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads per Die:   %d\n&quot;</span>, topoParms.nPThreadsPerDie);
    TOPO_DBG(<span class="enscript-string">&quot;\tDies per Package:  %d\n&quot;</span>, topoParms.nPDiesPerPackage);
    TOPO_DBG(<span class="enscript-string">&quot;\tCores per Package: %d\n&quot;</span>, topoParms.nPCoresPerPackage);
    TOPO_DBG(<span class="enscript-string">&quot;\tThreads per Package: %d\n&quot;</span>, topoParms.nPThreadsPerPackage);

    topoParmsInited = TRUE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_cache_free</span>(x86_cpu_cache_t *cache)
{
    num_caches -= 1;
    <span class="enscript-keyword">if</span> (cache-&gt;level &gt; 0 &amp;&amp; cache-&gt;level &lt;= MAX_CACHE_DEPTH)
	num_Lx_caches[cache-&gt;level - 1] -= 1;
    cache-&gt;next = x86_caches;
    x86_caches = cache;
}

<span class="enscript-comment">/*
 * This returns a list of cache structures that represent the
 * caches for a CPU.  Some of the structures may have to be
 * &quot;freed&quot; if they are actually shared between CPUs.
 */</span>
<span class="enscript-type">static</span> x86_cpu_cache_t *
<span class="enscript-function-name">x86_cache_list</span>(<span class="enscript-type">void</span>)
{
    x86_cpu_cache_t	*root	= NULL;
    x86_cpu_cache_t	*cur	= NULL;
    x86_cpu_cache_t	*last	= NULL;
    <span class="enscript-type">struct</span> cpu_cache	*cachep;
    <span class="enscript-type">int</span>			i;

    <span class="enscript-comment">/*
     * Cons up a list driven not by CPUID leaf 4 (deterministic cache params)
     * but by the table above plus parameters already cracked from cpuid...
     */</span>
    <span class="enscript-keyword">for</span> (i = 0, cachep = &amp;cpu_caches[0]; i &lt; LCACHE_MAX; i++, cachep++) {

	<span class="enscript-keyword">if</span> (cachep-&gt;type == 0 || cpuid_info()-&gt;cache_size[i] == 0)
	    <span class="enscript-keyword">continue</span>;
	
	cur = x86_cache_alloc();
	<span class="enscript-keyword">if</span> (cur == NULL)
	    <span class="enscript-keyword">break</span>;

	cur-&gt;type       = cachep-&gt;type;
	cur-&gt;level      = cachep-&gt;level;
	cur-&gt;nlcpus     = 0;
	cur-&gt;maxcpus    = cpuid_info()-&gt;cache_sharing[i];
	cur-&gt;partitions = cpuid_info()-&gt;cache_partitions[i];
	cur-&gt;cache_size = cpuid_info()-&gt;cache_size[i];
	cur-&gt;line_size  = cpuid_info()-&gt;cache_linesize;

	<span class="enscript-keyword">if</span> (last == NULL) {
	    root = cur;
	    last = cur;
	} <span class="enscript-keyword">else</span> {
	    last-&gt;next = cur;
	    last = cur;
	}
	num_Lx_caches[cur-&gt;level - 1] += 1;
    }
    <span class="enscript-keyword">return</span> root;
}


<span class="enscript-type">static</span> x86_cpu_cache_t *
<span class="enscript-function-name">x86_match_cache</span>(x86_cpu_cache_t *list, x86_cpu_cache_t *matcher)
{
    x86_cpu_cache_t	*cur_cache;
 
    cur_cache = list;
    <span class="enscript-keyword">while</span> (cur_cache != NULL) {
	<span class="enscript-keyword">if</span> (cur_cache-&gt;maxcpus  == matcher-&gt;maxcpus
	    &amp;&amp; cur_cache-&gt;type  == matcher-&gt;type
	    &amp;&amp; cur_cache-&gt;level == matcher-&gt;level
	    &amp;&amp; cur_cache-&gt;partitions == matcher-&gt;partitions
	    &amp;&amp; cur_cache-&gt;line_size  == matcher-&gt;line_size
	    &amp;&amp; cur_cache-&gt;cache_size == matcher-&gt;cache_size)
	    <span class="enscript-keyword">break</span>;

	cur_cache = cur_cache-&gt;next;
    }

    <span class="enscript-keyword">return</span>(cur_cache);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_lcpu_init</span>(<span class="enscript-type">int</span> cpu)
{
    cpu_data_t		*cpup;
    x86_lcpu_t		*lcpu;
    <span class="enscript-type">int</span>			i;

    cpup = cpu_datap(cpu);

    lcpu = &amp;cpup-&gt;lcpu;
    lcpu-&gt;lcpu = lcpu;
    lcpu-&gt;cpu  = cpup;
    lcpu-&gt;next_in_core = NULL;
    lcpu-&gt;next_in_die  = NULL;
    lcpu-&gt;next_in_pkg  = NULL;
    lcpu-&gt;core         = NULL;
    lcpu-&gt;die          = NULL;
    lcpu-&gt;package      = NULL;
    lcpu-&gt;cpu_num = cpu;
    lcpu-&gt;lnum = cpu;
    lcpu-&gt;pnum = cpup-&gt;cpu_phys_number;
    lcpu-&gt;state = LCPU_OFF;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_CACHE_DEPTH; i += 1)
	lcpu-&gt;caches[i] = NULL;
}

<span class="enscript-type">static</span> x86_core_t *
<span class="enscript-function-name">x86_core_alloc</span>(<span class="enscript-type">int</span> cpu)
{
    x86_core_t	*core;
    cpu_data_t	*cpup;

    cpup = cpu_datap(cpu);

    simple_lock(&amp;x86_topo_lock);
    <span class="enscript-keyword">if</span> (free_cores != NULL) {
	core = free_cores;
	free_cores = core-&gt;next_in_die;
	core-&gt;next_in_die = NULL;
	simple_unlock(&amp;x86_topo_lock);
    } <span class="enscript-keyword">else</span> {
	simple_unlock(&amp;x86_topo_lock);
	core = kalloc(<span class="enscript-keyword">sizeof</span>(x86_core_t));
	<span class="enscript-keyword">if</span> (core == NULL)
	    panic(<span class="enscript-string">&quot;x86_core_alloc() kalloc of x86_core_t failed!\n&quot;</span>);
    }

    bzero((<span class="enscript-type">void</span> *) core, <span class="enscript-keyword">sizeof</span>(x86_core_t));

    core-&gt;pcore_num = cpup-&gt;cpu_phys_number / topoParms.nPThreadsPerCore;
    core-&gt;lcore_num = core-&gt;pcore_num % topoParms.nPCoresPerPackage;

    core-&gt;flags = X86CORE_FL_PRESENT | X86CORE_FL_READY
	        | X86CORE_FL_HALTED | X86CORE_FL_IDLE;

    <span class="enscript-keyword">return</span>(core);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_core_free</span>(x86_core_t *core)
{
    simple_lock(&amp;x86_topo_lock);
    core-&gt;next_in_die = free_cores;
    free_cores = core;
    simple_unlock(&amp;x86_topo_lock);
}

<span class="enscript-type">static</span> x86_pkg_t *
<span class="enscript-function-name">x86_package_find</span>(<span class="enscript-type">int</span> cpu)
{
    x86_pkg_t	*pkg;
    cpu_data_t	*cpup;
    uint32_t	pkg_num;

    cpup = cpu_datap(cpu);

    pkg_num = cpup-&gt;cpu_phys_number / topoParms.nPThreadsPerPackage;

    pkg = x86_pkgs;
    <span class="enscript-keyword">while</span> (pkg != NULL) {
	<span class="enscript-keyword">if</span> (pkg-&gt;ppkg_num == pkg_num)
	    <span class="enscript-keyword">break</span>;
	pkg = pkg-&gt;next;
    }

    <span class="enscript-keyword">return</span>(pkg);
}
 
<span class="enscript-type">static</span> x86_die_t *
<span class="enscript-function-name">x86_die_find</span>(<span class="enscript-type">int</span> cpu)
{
    x86_die_t	*die;
    x86_pkg_t	*pkg;
    cpu_data_t	*cpup;
    uint32_t	die_num;

    cpup = cpu_datap(cpu);

    die_num = cpup-&gt;cpu_phys_number / topoParms.nPThreadsPerDie;

    pkg = x86_package_find(cpu);
    <span class="enscript-keyword">if</span> (pkg == NULL)
	<span class="enscript-keyword">return</span>(NULL);

    die = pkg-&gt;dies;
    <span class="enscript-keyword">while</span> (die != NULL) {
	<span class="enscript-keyword">if</span> (die-&gt;pdie_num == die_num)
	    <span class="enscript-keyword">break</span>;
	die = die-&gt;next_in_pkg;
    }

    <span class="enscript-keyword">return</span>(die);
}

<span class="enscript-type">static</span> x86_core_t *
<span class="enscript-function-name">x86_core_find</span>(<span class="enscript-type">int</span> cpu)
{
    x86_core_t	*core;
    x86_die_t	*die;
    cpu_data_t	*cpup;
    uint32_t	core_num;

    cpup = cpu_datap(cpu);

    core_num = cpup-&gt;cpu_phys_number / topoParms.nPThreadsPerCore;

    die = x86_die_find(cpu);
    <span class="enscript-keyword">if</span> (die == NULL)
	<span class="enscript-keyword">return</span>(NULL);

    core = die-&gt;cores;
    <span class="enscript-keyword">while</span> (core != NULL) {
	<span class="enscript-keyword">if</span> (core-&gt;pcore_num == core_num)
	    <span class="enscript-keyword">break</span>;
	core = core-&gt;next_in_die;
    }

    <span class="enscript-keyword">return</span>(core);
}
 
<span class="enscript-type">void</span>
<span class="enscript-function-name">x86_set_logical_topology</span>(x86_lcpu_t *lcpu, <span class="enscript-type">int</span> pnum, <span class="enscript-type">int</span> lnum)
{
    x86_core_t	*core = lcpu-&gt;core;
    x86_die_t	*die  = lcpu-&gt;die;
    x86_pkg_t	*pkg  = lcpu-&gt;package;
    
    assert(core != NULL);
    assert(die != NULL);
    assert(pkg != NULL);

    lcpu-&gt;cpu_num = lnum;
    lcpu-&gt;pnum = pnum;
    lcpu-&gt;master = (lnum == master_cpu);
    lcpu-&gt;primary = (lnum % topoParms.nLThreadsPerPackage) == 0;

    lcpu-&gt;lnum = lnum % topoParms.nLThreadsPerCore;

    core-&gt;pcore_num = lnum / topoParms.nLThreadsPerCore;
    core-&gt;lcore_num = core-&gt;pcore_num % topoParms.nLCoresPerDie;

    die-&gt;pdie_num = lnum / (topoParms.nLThreadsPerCore*topoParms.nLCoresPerDie);
    die-&gt;ldie_num = die-&gt;pdie_num % topoParms.nLDiesPerPackage;

    pkg-&gt;ppkg_num = lnum / topoParms.nLThreadsPerPackage;
    pkg-&gt;lpkg_num = pkg-&gt;ppkg_num;

}

<span class="enscript-type">static</span> x86_die_t *
<span class="enscript-function-name">x86_die_alloc</span>(<span class="enscript-type">int</span> cpu)
{
    x86_die_t	*die;
    cpu_data_t	*cpup;

    cpup = cpu_datap(cpu);

    simple_lock(&amp;x86_topo_lock);
    <span class="enscript-keyword">if</span> (free_dies != NULL) {
	die = free_dies;
	free_dies = die-&gt;next_in_pkg;
	die-&gt;next_in_pkg = NULL;
	simple_unlock(&amp;x86_topo_lock);
    } <span class="enscript-keyword">else</span> {
	simple_unlock(&amp;x86_topo_lock);
	die = kalloc(<span class="enscript-keyword">sizeof</span>(x86_die_t));
	<span class="enscript-keyword">if</span> (die == NULL)
	    panic(<span class="enscript-string">&quot;x86_die_alloc() kalloc of x86_die_t failed!\n&quot;</span>);
    }

    bzero((<span class="enscript-type">void</span> *) die, <span class="enscript-keyword">sizeof</span>(x86_die_t));

    die-&gt;pdie_num = cpup-&gt;cpu_phys_number / topoParms.nPThreadsPerDie;

    die-&gt;ldie_num = num_dies;
    atomic_incl((<span class="enscript-type">long</span> *) &amp;num_dies, 1);

    die-&gt;flags = X86DIE_FL_PRESENT;
    <span class="enscript-keyword">return</span>(die);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_die_free</span>(x86_die_t *die)
{
    simple_lock(&amp;x86_topo_lock);
    die-&gt;next_in_pkg = free_dies;
    free_dies = die;
    atomic_decl((<span class="enscript-type">long</span> *) &amp;num_dies, 1);
    simple_unlock(&amp;x86_topo_lock);
}

<span class="enscript-type">static</span> x86_pkg_t *
<span class="enscript-function-name">x86_package_alloc</span>(<span class="enscript-type">int</span> cpu)
{
    x86_pkg_t	*pkg;
    cpu_data_t	*cpup;

    cpup = cpu_datap(cpu);

    simple_lock(&amp;x86_topo_lock);
    <span class="enscript-keyword">if</span> (free_pkgs != NULL) {
	pkg = free_pkgs;
	free_pkgs = pkg-&gt;next;
	pkg-&gt;next = NULL;
	simple_unlock(&amp;x86_topo_lock);
    } <span class="enscript-keyword">else</span> {
	simple_unlock(&amp;x86_topo_lock);
	pkg = kalloc(<span class="enscript-keyword">sizeof</span>(x86_pkg_t));
	<span class="enscript-keyword">if</span> (pkg == NULL)
	    panic(<span class="enscript-string">&quot;x86_package_alloc() kalloc of x86_pkg_t failed!\n&quot;</span>);
    }

    bzero((<span class="enscript-type">void</span> *) pkg, <span class="enscript-keyword">sizeof</span>(x86_pkg_t));

    pkg-&gt;ppkg_num = cpup-&gt;cpu_phys_number / topoParms.nPThreadsPerPackage;

    pkg-&gt;lpkg_num = topoParms.nPackages;
    atomic_incl((<span class="enscript-type">long</span> *) &amp;topoParms.nPackages, 1);

    pkg-&gt;flags = X86PKG_FL_PRESENT | X86PKG_FL_READY;
    <span class="enscript-keyword">return</span>(pkg);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_package_free</span>(x86_pkg_t *pkg)
{
    simple_lock(&amp;x86_topo_lock);
    pkg-&gt;next = free_pkgs;
    free_pkgs = pkg;
    atomic_decl((<span class="enscript-type">long</span> *) &amp;topoParms.nPackages, 1);
    simple_unlock(&amp;x86_topo_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_cache_add_lcpu</span>(x86_cpu_cache_t *cache, x86_lcpu_t *lcpu)
{
    x86_cpu_cache_t	*cur_cache;
    <span class="enscript-type">int</span>			i;

    <span class="enscript-comment">/*
     * Put the new CPU into the list of the cache.
     */</span>
    cur_cache = lcpu-&gt;caches[cache-&gt;level - 1];
    lcpu-&gt;caches[cache-&gt;level - 1] = cache;
    cache-&gt;next = cur_cache;
    cache-&gt;nlcpus += 1;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; cache-&gt;nlcpus; i += 1) {
	<span class="enscript-keyword">if</span> (cache-&gt;cpus[i] == NULL) {
	    cache-&gt;cpus[i] = lcpu;
	    <span class="enscript-keyword">break</span>;
	}
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_lcpu_add_caches</span>(x86_lcpu_t *lcpu)
{
    x86_cpu_cache_t	*list;
    x86_cpu_cache_t	*cur;
    x86_cpu_cache_t	*match;
    x86_die_t		*die;
    x86_core_t		*core;
    x86_lcpu_t		*cur_lcpu;
    uint32_t		level;
    boolean_t		found		= FALSE;

    assert(lcpu != NULL);

    <span class="enscript-comment">/*
     * Add the cache data to the topology.
     */</span>
    list = x86_cache_list();

    simple_lock(&amp;x86_topo_lock);

    <span class="enscript-keyword">while</span> (list != NULL) {
	<span class="enscript-comment">/*
	 * Remove the cache from the front of the list.
	 */</span>
	cur = list;
	list = cur-&gt;next;
	cur-&gt;next = NULL;
	level = cur-&gt;level - 1;

	<span class="enscript-comment">/*
	 * If the cache isn't shared then just put it where it
	 * belongs.
	 */</span>
	<span class="enscript-keyword">if</span> (cur-&gt;maxcpus == 1) {
	    x86_cache_add_lcpu(cur, lcpu);
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">/*
	 * We'll assume that all of the caches at a particular level
	 * have the same sharing.  So if we have a cache already at
	 * this level, we'll just skip looking for the match.
	 */</span>
	<span class="enscript-keyword">if</span> (lcpu-&gt;caches[level] != NULL) {
	    x86_cache_free(cur);
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">/*
	 * This is a shared cache, so we have to figure out if
	 * this is the first time we've seen this cache.  We do
	 * this by searching through the topology and seeing if
	 * this cache is already described.
	 *
	 * Assume that L{LLC-1} are all at the core level and that
	 * LLC is shared at the die level.
	 */</span>
	<span class="enscript-keyword">if</span> (level &lt; topoParms.LLCDepth) {
	    <span class="enscript-comment">/*
	     * Shared at the core.
	     */</span>
	    core = lcpu-&gt;core;
	    cur_lcpu = core-&gt;lcpus;
	    <span class="enscript-keyword">while</span> (cur_lcpu != NULL) {
		<span class="enscript-comment">/*
		 * Skip ourselves.
		 */</span>
		<span class="enscript-keyword">if</span> (cur_lcpu == lcpu) {
		    cur_lcpu = cur_lcpu-&gt;next_in_core;
		    <span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If there's a cache on this logical CPU,
		 * then use that one.
		 */</span>
		match = x86_match_cache(cur_lcpu-&gt;caches[level], cur);
		<span class="enscript-keyword">if</span> (match != NULL) {
		    x86_cache_free(cur);
		    x86_cache_add_lcpu(match, lcpu);
		    found = TRUE;
		    <span class="enscript-keyword">break</span>;
		}

		cur_lcpu = cur_lcpu-&gt;next_in_core;
	    }
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">/*
	     * Shared at the die.
	     */</span>
	    die = lcpu-&gt;die;
	    cur_lcpu = die-&gt;lcpus;
	    <span class="enscript-keyword">while</span> (cur_lcpu != NULL) {
		<span class="enscript-comment">/*
		 * Skip ourselves.
		 */</span>
		<span class="enscript-keyword">if</span> (cur_lcpu == lcpu) {
		    cur_lcpu = cur_lcpu-&gt;next_in_die;
		    <span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If there's a cache on this logical CPU,
		 * then use that one.
		 */</span>
		match = x86_match_cache(cur_lcpu-&gt;caches[level], cur);
		<span class="enscript-keyword">if</span> (match != NULL) {
		    x86_cache_free(cur);
		    x86_cache_add_lcpu(match, lcpu);
		    found = TRUE;
		    <span class="enscript-keyword">break</span>;
		}

		cur_lcpu = cur_lcpu-&gt;next_in_die;
	    }
	}

	<span class="enscript-comment">/*
	 * If a shared cache wasn't found, then this logical CPU must
	 * be the first one encountered.
	 */</span>
	<span class="enscript-keyword">if</span> (!found) {
	    x86_cache_add_lcpu(cur, lcpu);
	}
    }

    simple_unlock(&amp;x86_topo_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_core_add_lcpu</span>(x86_core_t *core, x86_lcpu_t *lcpu)
{
    assert(core != NULL);
    assert(lcpu != NULL);

    simple_lock(&amp;x86_topo_lock);

    lcpu-&gt;next_in_core = core-&gt;lcpus;
    lcpu-&gt;core = core;
    core-&gt;lcpus = lcpu;
    core-&gt;num_lcpus += 1;
    simple_unlock(&amp;x86_topo_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_die_add_lcpu</span>(x86_die_t *die, x86_lcpu_t *lcpu)
{
    assert(die != NULL);
    assert(lcpu != NULL);
 
    lcpu-&gt;next_in_die = die-&gt;lcpus;
    lcpu-&gt;die = die;
    die-&gt;lcpus = lcpu;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_die_add_core</span>(x86_die_t *die, x86_core_t *core)
{
    assert(die != NULL);
    assert(core != NULL);

    core-&gt;next_in_die = die-&gt;cores;
    core-&gt;die = die;
    die-&gt;cores = core;
    die-&gt;num_cores += 1;
}

 <span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_package_add_lcpu</span>(x86_pkg_t *pkg, x86_lcpu_t *lcpu)
{
    assert(pkg != NULL);
    assert(lcpu != NULL);

    lcpu-&gt;next_in_pkg = pkg-&gt;lcpus;
    lcpu-&gt;package = pkg;
    pkg-&gt;lcpus = lcpu;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_package_add_core</span>(x86_pkg_t *pkg, x86_core_t *core)
{
    assert(pkg != NULL);
    assert(core != NULL);

    core-&gt;next_in_pkg = pkg-&gt;cores;
    core-&gt;package = pkg;
    pkg-&gt;cores = core;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">x86_package_add_die</span>(x86_pkg_t *pkg, x86_die_t *die)
{
    assert(pkg != NULL);
    assert(die != NULL);

    die-&gt;next_in_pkg = pkg-&gt;dies;
    die-&gt;package = pkg;
    pkg-&gt;dies = die;
    pkg-&gt;num_dies += 1;
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">cpu_thread_alloc</span>(<span class="enscript-type">int</span> cpu)
{
    x86_core_t	*core		= NULL;
    x86_die_t	*die		= NULL;
    x86_pkg_t	*pkg		= NULL;
    cpu_data_t	*cpup;
    uint32_t	phys_cpu;

    <span class="enscript-comment">/*
     * Only allow one to manipulate the topology at a time.
     */</span>
    simple_lock(&amp;x86_topo_lock);

    <span class="enscript-comment">/*
     * Make sure all of the topology parameters have been initialized.
     */</span>
    <span class="enscript-keyword">if</span> (!topoParmsInited)
	initTopoParms();

    cpup = cpu_datap(cpu);

    phys_cpu = cpup-&gt;cpu_phys_number;

    x86_lcpu_init(cpu);

    <span class="enscript-comment">/*
     * Assume that all cpus have the same features.
     */</span>
    <span class="enscript-keyword">if</span> (cpu_is_hyperthreaded()) {
	cpup-&gt;cpu_threadtype = CPU_THREADTYPE_INTEL_HTT;
    } <span class="enscript-keyword">else</span> {
	cpup-&gt;cpu_threadtype = CPU_THREADTYPE_NONE;
    }

    <span class="enscript-comment">/*
     * Get the package that the logical CPU is in.
     */</span>
    <span class="enscript-keyword">do</span> {
	pkg = x86_package_find(cpu);
	<span class="enscript-keyword">if</span> (pkg == NULL) {
	    <span class="enscript-comment">/*
	     * Package structure hasn't been created yet, do it now.
	     */</span>
	    simple_unlock(&amp;x86_topo_lock);
	    pkg = x86_package_alloc(cpu);
	    simple_lock(&amp;x86_topo_lock);
	    <span class="enscript-keyword">if</span> (x86_package_find(cpu) != NULL) {
		x86_package_free(pkg);
		<span class="enscript-keyword">continue</span>;
	    }
	    
	    <span class="enscript-comment">/*
	     * Add the new package to the global list of packages.
	     */</span>
	    pkg-&gt;next = x86_pkgs;
	    x86_pkgs = pkg;
	}
    } <span class="enscript-keyword">while</span> (pkg == NULL);

    <span class="enscript-comment">/*
     * Get the die that the logical CPU is in.
     */</span>
    <span class="enscript-keyword">do</span> {
	die = x86_die_find(cpu);
	<span class="enscript-keyword">if</span> (die == NULL) {
	    <span class="enscript-comment">/*
	     * Die structure hasn't been created yet, do it now.
	     */</span>
	    simple_unlock(&amp;x86_topo_lock);
	    die = x86_die_alloc(cpu);
	    simple_lock(&amp;x86_topo_lock);
	    <span class="enscript-keyword">if</span> (x86_die_find(cpu) != NULL) {
		x86_die_free(die);
		<span class="enscript-keyword">continue</span>;
	    }

	    <span class="enscript-comment">/*
	     * Add the die to the package.
	     */</span>
	    x86_package_add_die(pkg, die);
	}
    } <span class="enscript-keyword">while</span> (die == NULL);

    <span class="enscript-comment">/*
     * Get the core for this logical CPU.
     */</span>
    <span class="enscript-keyword">do</span> {
	core = x86_core_find(cpu);
	<span class="enscript-keyword">if</span> (core == NULL) {
	    <span class="enscript-comment">/*
	     * Allocate the core structure now.
	     */</span>
	    simple_unlock(&amp;x86_topo_lock);
	    core = x86_core_alloc(cpu);
	    simple_lock(&amp;x86_topo_lock);
	    <span class="enscript-keyword">if</span> (x86_core_find(cpu) != NULL) {
		x86_core_free(core);
		<span class="enscript-keyword">continue</span>;
	    }

	    <span class="enscript-comment">/*
	     * Add the core to the die &amp; package.
	     */</span>
	    x86_die_add_core(die, core);
	    x86_package_add_core(pkg, core);
	    machine_info.physical_cpu_max += 1;
	}
    } <span class="enscript-keyword">while</span> (core == NULL);

    
    <span class="enscript-comment">/*
     * Done manipulating the topology, so others can get in.
     */</span>
    machine_info.logical_cpu_max += 1;
    simple_unlock(&amp;x86_topo_lock);

    <span class="enscript-comment">/*
     * Add the logical CPU to the other topology structures.
     */</span>
    x86_core_add_lcpu(core, &amp;cpup-&gt;lcpu);
    x86_die_add_lcpu(core-&gt;die, &amp;cpup-&gt;lcpu);
    x86_package_add_lcpu(core-&gt;package, &amp;cpup-&gt;lcpu);
    x86_lcpu_add_caches(&amp;cpup-&gt;lcpu);

    <span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) core;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cpu_thread_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span>		my_cpu		= get_cpu_number();
    cpu_data_t	*cpup		= current_cpu_datap();
    x86_core_t	*core;
    <span class="enscript-type">static</span> <span class="enscript-type">int</span>	initialized	= 0;

    <span class="enscript-comment">/*
     * If we're the boot processor, we do all of the initialization of
     * the CPU topology infrastructure.
     */</span>
    <span class="enscript-keyword">if</span> (my_cpu == master_cpu &amp;&amp; !initialized) {
	simple_lock_init(&amp;x86_topo_lock, 0);

	<span class="enscript-comment">/*
	 * Put this logical CPU into the physical CPU topology.
	 */</span>
	cpup-&gt;lcpu.core = cpu_thread_alloc(my_cpu);

	initialized = 1;
    }

    <span class="enscript-comment">/*
     * Do the CPU accounting.
     */</span>
    core = cpup-&gt;lcpu.core;
    simple_lock(&amp;x86_topo_lock);
    machine_info.logical_cpu += 1;
    <span class="enscript-keyword">if</span> (core-&gt;active_lcpus == 0)
	machine_info.physical_cpu += 1;
    core-&gt;active_lcpus += 1;
    simple_unlock(&amp;x86_topo_lock);

    pmCPUMarkRunning(cpup);
    timer_resync_deadlines();
}

<span class="enscript-comment">/*
 * Called for a cpu to halt permanently
 * (as opposed to halting and expecting an interrupt to awaken it).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cpu_thread_halt</span>(<span class="enscript-type">void</span>)
{
    x86_core_t	*core;
    cpu_data_t	*cpup = current_cpu_datap();

    simple_lock(&amp;x86_topo_lock);
    machine_info.logical_cpu -= 1;
    core = cpup-&gt;lcpu.core;
    core-&gt;active_lcpus -= 1;
    <span class="enscript-keyword">if</span> (core-&gt;active_lcpus == 0)
	machine_info.physical_cpu -= 1;
    simple_unlock(&amp;x86_topo_lock);

    <span class="enscript-comment">/*
     * Let the power management code determine the best way to &quot;stop&quot;
     * the processor.
     */</span>
    ml_set_interrupts_enabled(FALSE);
    <span class="enscript-keyword">while</span> (1) {
	pmCPUHalt(PM_HALT_NORMAL);
    }
    <span class="enscript-comment">/* NOT REACHED */</span>
}

<span class="enscript-comment">/*
 * Validates that the topology was built correctly.  Must be called only
 * after the complete topology is built and no other changes are being made.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">x86_validate_topology</span>(<span class="enscript-type">void</span>)
{
    x86_pkg_t		*pkg;
    x86_die_t		*die;
    x86_core_t		*core;
    x86_lcpu_t		*lcpu;
    uint32_t		nDies;
    uint32_t		nCores;
    uint32_t		nCPUs;

    <span class="enscript-keyword">if</span> (topo_dbg)
	debug_topology_print();

    <span class="enscript-comment">/*
     * XXX
     *
     * Right now this only works if the number of CPUs started is the total
     * number of CPUs.  However, when specifying cpus=n the topology is only
     * partially constructed and the checks below will fail.
     *
     * We should *always* build the complete topology and only start the CPUs
     * indicated by cpus=n.  Until that happens, this code will not check the
     * topology if the number of cpus defined is &lt; that described the the
     * topology parameters.
     */</span>
    nCPUs = topoParms.nPackages * topoParms.nLThreadsPerPackage;
    <span class="enscript-keyword">if</span> (nCPUs &gt; real_ncpus)
	<span class="enscript-keyword">return</span>;

    pkg = x86_pkgs;
    <span class="enscript-keyword">while</span> (pkg != NULL) {
	<span class="enscript-comment">/*
	 * Make sure that the package has the correct number of dies.
	 */</span>
	nDies = 0;
	die = pkg-&gt;dies;
	<span class="enscript-keyword">while</span> (die != NULL) {
	    <span class="enscript-keyword">if</span> (die-&gt;package == NULL)
		panic(<span class="enscript-string">&quot;Die(%d)-&gt;package is NULL&quot;</span>,
		      die-&gt;pdie_num);
	    <span class="enscript-keyword">if</span> (die-&gt;package != pkg)
		panic(<span class="enscript-string">&quot;Die %d points to package %d, should be %d&quot;</span>,
		      die-&gt;pdie_num, die-&gt;package-&gt;lpkg_num, pkg-&gt;lpkg_num);

	    TOPO_DBG(<span class="enscript-string">&quot;Die(%d)-&gt;package %d\n&quot;</span>,
		die-&gt;pdie_num, pkg-&gt;lpkg_num);

	    <span class="enscript-comment">/*
	     * Make sure that the die has the correct number of cores.
	     */</span>
	    TOPO_DBG(<span class="enscript-string">&quot;Die(%d)-&gt;cores: &quot;</span>, die-&gt;pdie_num);
	    nCores = 0;
	    core = die-&gt;cores;
	    <span class="enscript-keyword">while</span> (core != NULL) {
		<span class="enscript-keyword">if</span> (core-&gt;die == NULL)
		    panic(<span class="enscript-string">&quot;Core(%d)-&gt;die is NULL&quot;</span>,
			  core-&gt;pcore_num);
		<span class="enscript-keyword">if</span> (core-&gt;die != die)
		    panic(<span class="enscript-string">&quot;Core %d points to die %d, should be %d&quot;</span>,
			  core-&gt;pcore_num, core-&gt;die-&gt;pdie_num, die-&gt;pdie_num);
		nCores += 1;
		TOPO_DBG(<span class="enscript-string">&quot;%d &quot;</span>, core-&gt;pcore_num);
		core = core-&gt;next_in_die;
	    }
	    TOPO_DBG(<span class="enscript-string">&quot;\n&quot;</span>);

	    <span class="enscript-keyword">if</span> (nCores != topoParms.nLCoresPerDie)
		panic(<span class="enscript-string">&quot;Should have %d Cores, but only found %d for Die %d&quot;</span>,
		      topoParms.nLCoresPerDie, nCores, die-&gt;pdie_num);

	    <span class="enscript-comment">/*
	     * Make sure that the die has the correct number of CPUs.
	     */</span>
	    TOPO_DBG(<span class="enscript-string">&quot;Die(%d)-&gt;lcpus: &quot;</span>, die-&gt;pdie_num);
	    nCPUs = 0;
	    lcpu = die-&gt;lcpus;
	    <span class="enscript-keyword">while</span> (lcpu != NULL) {
		<span class="enscript-keyword">if</span> (lcpu-&gt;die == NULL)
		    panic(<span class="enscript-string">&quot;CPU(%d)-&gt;die is NULL&quot;</span>,
			  lcpu-&gt;cpu_num);
		<span class="enscript-keyword">if</span> (lcpu-&gt;die != die)
		    panic(<span class="enscript-string">&quot;CPU %d points to die %d, should be %d&quot;</span>,
			  lcpu-&gt;cpu_num, lcpu-&gt;die-&gt;pdie_num, die-&gt;pdie_num);
		nCPUs += 1;
		TOPO_DBG(<span class="enscript-string">&quot;%d &quot;</span>, lcpu-&gt;cpu_num);
		lcpu = lcpu-&gt;next_in_die;
	    }
	    TOPO_DBG(<span class="enscript-string">&quot;\n&quot;</span>);

	    <span class="enscript-keyword">if</span> (nCPUs != topoParms.nLThreadsPerDie)
		panic(<span class="enscript-string">&quot;Should have %d Threads, but only found %d for Die %d&quot;</span>,
		      topoParms.nLThreadsPerDie, nCPUs, die-&gt;pdie_num);

	    nDies += 1;
	    die = die-&gt;next_in_pkg;
	}

	<span class="enscript-keyword">if</span> (nDies != topoParms.nLDiesPerPackage)
	    panic(<span class="enscript-string">&quot;Should have %d Dies, but only found %d for package %d&quot;</span>,
		  topoParms.nLDiesPerPackage, nDies, pkg-&gt;lpkg_num);

	<span class="enscript-comment">/*
	 * Make sure that the package has the correct number of cores.
	 */</span>
	nCores = 0;
	core = pkg-&gt;cores;
	<span class="enscript-keyword">while</span> (core != NULL) {
	    <span class="enscript-keyword">if</span> (core-&gt;package == NULL)
		panic(<span class="enscript-string">&quot;Core(%d)-&gt;package is NULL&quot;</span>,
		      core-&gt;pcore_num);
	    <span class="enscript-keyword">if</span> (core-&gt;package != pkg)
		panic(<span class="enscript-string">&quot;Core %d points to package %d, should be %d&quot;</span>,
		      core-&gt;pcore_num, core-&gt;package-&gt;lpkg_num, pkg-&gt;lpkg_num);
	    TOPO_DBG(<span class="enscript-string">&quot;Core(%d)-&gt;package %d\n&quot;</span>,
		core-&gt;pcore_num, pkg-&gt;lpkg_num);

	    <span class="enscript-comment">/*
	     * Make sure that the core has the correct number of CPUs.
	     */</span>
	    nCPUs = 0;
	    lcpu = core-&gt;lcpus;
	    TOPO_DBG(<span class="enscript-string">&quot;Core(%d)-&gt;lcpus: &quot;</span>, core-&gt;pcore_num);
	    <span class="enscript-keyword">while</span> (lcpu != NULL) {
		<span class="enscript-keyword">if</span> (lcpu-&gt;core == NULL)
		    panic(<span class="enscript-string">&quot;CPU(%d)-&gt;core is NULL&quot;</span>,
			  lcpu-&gt;cpu_num);
		<span class="enscript-keyword">if</span> (lcpu-&gt;core != core)
		    panic(<span class="enscript-string">&quot;CPU %d points to core %d, should be %d&quot;</span>,
			  lcpu-&gt;cpu_num, lcpu-&gt;core-&gt;pcore_num, core-&gt;pcore_num);
		TOPO_DBG(<span class="enscript-string">&quot;%d &quot;</span>, lcpu-&gt;cpu_num);
		nCPUs += 1;
		lcpu = lcpu-&gt;next_in_core;
	    }
	    TOPO_DBG(<span class="enscript-string">&quot;\n&quot;</span>);

	    <span class="enscript-keyword">if</span> (nCPUs != topoParms.nLThreadsPerCore)
		panic(<span class="enscript-string">&quot;Should have %d Threads, but only found %d for Core %d&quot;</span>,
		      topoParms.nLThreadsPerCore, nCPUs, core-&gt;pcore_num);
	    nCores += 1;
	    core = core-&gt;next_in_pkg;
	}

	<span class="enscript-keyword">if</span> (nCores != topoParms.nLCoresPerPackage)
	    panic(<span class="enscript-string">&quot;Should have %d Cores, but only found %d for package %d&quot;</span>,
		  topoParms.nLCoresPerPackage, nCores, pkg-&gt;lpkg_num);

	<span class="enscript-comment">/*
	 * Make sure that the package has the correct number of CPUs.
	 */</span>
	nCPUs = 0;
	lcpu = pkg-&gt;lcpus;
	<span class="enscript-keyword">while</span> (lcpu != NULL) {
	    <span class="enscript-keyword">if</span> (lcpu-&gt;package == NULL)
		panic(<span class="enscript-string">&quot;CPU(%d)-&gt;package is NULL&quot;</span>,
		      lcpu-&gt;cpu_num);
	    <span class="enscript-keyword">if</span> (lcpu-&gt;package != pkg)
		panic(<span class="enscript-string">&quot;CPU %d points to package %d, should be %d&quot;</span>,
		      lcpu-&gt;cpu_num, lcpu-&gt;package-&gt;lpkg_num, pkg-&gt;lpkg_num);
	    TOPO_DBG(<span class="enscript-string">&quot;CPU(%d)-&gt;package %d\n&quot;</span>,
		lcpu-&gt;cpu_num, pkg-&gt;lpkg_num);
	    nCPUs += 1;
	    lcpu = lcpu-&gt;next_in_pkg;
	}

	<span class="enscript-keyword">if</span> (nCPUs != topoParms.nLThreadsPerPackage)
	    panic(<span class="enscript-string">&quot;Should have %d Threads, but only found %d for package %d&quot;</span>,
		  topoParms.nLThreadsPerPackage, nCPUs, pkg-&gt;lpkg_num);

	pkg = pkg-&gt;next;
    }
}

<span class="enscript-comment">/*
 * Prints out the topology
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">debug_topology_print</span>(<span class="enscript-type">void</span>)
{
    x86_pkg_t		*pkg;
    x86_die_t		*die;
    x86_core_t		*core;
    x86_lcpu_t		*cpu;

    pkg = x86_pkgs;
    <span class="enscript-keyword">while</span> (pkg != NULL) {
	kprintf(<span class="enscript-string">&quot;Package:\n&quot;</span>);
	kprintf(<span class="enscript-string">&quot;    Physical: %d\n&quot;</span>, pkg-&gt;ppkg_num);
	kprintf(<span class="enscript-string">&quot;    Logical:  %d\n&quot;</span>, pkg-&gt;lpkg_num);

	die = pkg-&gt;dies;
	<span class="enscript-keyword">while</span> (die != NULL) {
	    kprintf(<span class="enscript-string">&quot;    Die:\n&quot;</span>);
	    kprintf(<span class="enscript-string">&quot;        Physical: %d\n&quot;</span>, die-&gt;pdie_num);
	    kprintf(<span class="enscript-string">&quot;        Logical:  %d\n&quot;</span>, die-&gt;ldie_num);

	    core = die-&gt;cores;
	    <span class="enscript-keyword">while</span> (core != NULL) {
		kprintf(<span class="enscript-string">&quot;        Core:\n&quot;</span>);
		kprintf(<span class="enscript-string">&quot;            Physical: %d\n&quot;</span>, core-&gt;pcore_num);
		kprintf(<span class="enscript-string">&quot;            Logical:  %d\n&quot;</span>, core-&gt;lcore_num);

		cpu = core-&gt;lcpus;
		<span class="enscript-keyword">while</span> (cpu != NULL) {
		    kprintf(<span class="enscript-string">&quot;            LCPU:\n&quot;</span>);
		    kprintf(<span class="enscript-string">&quot;                CPU #:    %d\n&quot;</span>, cpu-&gt;cpu_num);
		    kprintf(<span class="enscript-string">&quot;                Physical: %d\n&quot;</span>, cpu-&gt;pnum);
		    kprintf(<span class="enscript-string">&quot;                Logical:  %d\n&quot;</span>, cpu-&gt;lnum);
		    kprintf(<span class="enscript-string">&quot;                Flags:    &quot;</span>);
		    <span class="enscript-keyword">if</span> (cpu-&gt;master)
			kprintf(<span class="enscript-string">&quot;MASTER &quot;</span>);
		    <span class="enscript-keyword">if</span> (cpu-&gt;primary)
			kprintf(<span class="enscript-string">&quot;PRIMARY&quot;</span>);
		    <span class="enscript-keyword">if</span> (!cpu-&gt;master &amp;&amp; !cpu-&gt;primary)
			kprintf(<span class="enscript-string">&quot;(NONE)&quot;</span>);
		    kprintf(<span class="enscript-string">&quot;\n&quot;</span>);

		    cpu = cpu-&gt;next_in_core;
		}

		core = core-&gt;next_in_die;
	    }

	    die = die-&gt;next_in_pkg;
	}

	pkg = pkg-&gt;next;
    }
}
</pre>
<hr />
</body></html>