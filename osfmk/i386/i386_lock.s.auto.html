<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>i386_lock.s</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">i386_lock.s&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 <span class="enscript-keyword">*</span> Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> This file contains Original Code and/or Modifications of Original Code
 <span class="enscript-keyword">*</span> as defined in and that are subject to the Apple Public Source License
 <span class="enscript-keyword">*</span> Version 2.0 (the 'License'). You may not use this file except in
 <span class="enscript-keyword">*</span> compliance with the License. The rights granted to you under the License
 <span class="enscript-keyword">*</span> may not be used to create, or enable the creation or redistribution of,
 <span class="enscript-keyword">*</span> unlawful or unlicensed copies of an Apple operating system, or to
 <span class="enscript-keyword">*</span> circumvent, violate, or enable the circumvention or violation of, any
 <span class="enscript-keyword">*</span> terms of an Apple operating system software license agreement.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> Please obtain a copy of the License at
 <span class="enscript-keyword">*</span> <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> The Original Code and all software distributed under the License are
 <span class="enscript-keyword">*</span> distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 <span class="enscript-keyword">*</span> EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 <span class="enscript-keyword">*</span> INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 <span class="enscript-keyword">*</span> FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 <span class="enscript-keyword">*</span> Please see the License for the specific language governing rights and
 <span class="enscript-keyword">*</span> limitations under the License.
 <span class="enscript-keyword">*</span> 
 <span class="enscript-keyword">*</span> @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 <span class="enscript-keyword">*/
</span>/*
 <span class="enscript-keyword">*</span> @OSF_COPYRIGHT@
 <span class="enscript-keyword">*/
</span>/* 
 <span class="enscript-keyword">*</span> Mach Operating System
 <span class="enscript-keyword">*</span> Copyright (c) 1989 Carnegie-Mellon University
 <span class="enscript-keyword">*</span> All rights reserved.  The CMU software License Agreement specifies
 <span class="enscript-keyword">*</span> the terms and conditions for use and redistribution.
 <span class="enscript-keyword">*/
</span>
#include &lt;mach_rt.h&gt;
#include &lt;mach_ldebug.h&gt;
#include &lt;i386/asm.h&gt;
#include &lt;i386/eflags.h&gt;
#include &lt;i386/trap.h&gt;
#include &lt;config_dtrace.h&gt;
#include &lt;i386/mp.h&gt;
	<span class="enscript-keyword">
</span>#include <span class="enscript-string">&quot;assym.s&quot;</span>

#define	PAUSE		rep<span class="enscript-comment">; nop

</span>#include &lt;i386/pal_lock_asm.h&gt;

#define LEAF_ENTRY(name)	\
	<span class="enscript-keyword">Entry(name)
</span>
#define LEAF_ENTRY2(n1,n2)	\
	<span class="enscript-keyword">Entry(n1);</span>		\
	<span class="enscript-keyword">Entry(n2)
</span>
#define LEAF_RET		\
	<span class="enscript-keyword">ret
</span>
/* Non-leaf routines always have a stack frame: */

#define NONLEAF_ENTRY(name)	\
	<span class="enscript-keyword">Entry(name);</span>		\
	<span class="enscript-keyword">FRAME
</span>
#define NONLEAF_ENTRY2(n1,n2)	\
	<span class="enscript-keyword">Entry(n1);</span>		\
	<span class="enscript-keyword">Entry(n2);</span>		\
	<span class="enscript-keyword">FRAME
</span>
#define NONLEAF_RET		\
	<span class="enscript-keyword">EMARF;</span>			\
	<span class="enscript-keyword">ret
</span>

/* For x86_64, the varargs ABI requires that %al indicate
 <span class="enscript-keyword">*</span> how many SSE register contain arguments. In our case, 0 */
#define ALIGN_STACK() 		and  $0xFFFFFFFFFFFFFFF0, %rsp <span class="enscript-comment">;
#define LOAD_STRING_ARG0(label)	leaq label(%rip), %rdi ;
</span>#define LOAD_ARG1(x)		mov x, %esi <span class="enscript-comment">;
#define LOAD_PTR_ARG1(x)	mov x, %rsi ;
</span>#define CALL_PANIC()		xorb %al,%al <span class="enscript-comment">; call EXT(panic) ;

</span>#define	CHECK_UNLOCK(current, owner)				\
	<span class="enscript-keyword">cmp</span>	current, owner				<span class="enscript-comment">;	\
	je	1f					;	\
</span>	<span class="enscript-keyword">ALIGN_STACK()</span>					<span class="enscript-comment">;	\
	LOAD_STRING_ARG0(2f)				;	\
</span>	<span class="enscript-keyword">CALL_PANIC()</span>					<span class="enscript-comment">;	\
	hlt						;	\
</span>	<span class="enscript-keyword">.data</span>						<span class="enscript-comment">;	\
2:	String	&quot;Mutex unlock attempted from non-owner thread&quot;;	\
</span>	<span class="enscript-keyword">.text</span>						<span class="enscript-comment">;	\
1:
</span>
#if	MACH_LDEBUG
/*
 <span class="enscript-keyword">*</span>  Routines for general lock debugging.
 <span class="enscript-keyword">*/
</span>
/* 
 <span class="enscript-keyword">*</span> Checks for expected lock types and calls <span class="enscript-string">&quot;panic&quot;</span> on
 <span class="enscript-keyword">*</span> mismatch.  Detects calls to Mutex functions with
 <span class="enscript-keyword">*</span> type simplelock and vice versa.
 <span class="enscript-keyword">*/
</span>#define	CHECK_MUTEX_TYPE()					\
	<span class="enscript-keyword">cmpl</span>	$ MUTEX_TAG,M_TYPE			<span class="enscript-comment">;	\
	je	1f					;	\
</span>	<span class="enscript-keyword">ALIGN_STACK()</span>					<span class="enscript-comment">;	\
	LOAD_STRING_ARG0(2f)				;	\
</span>	<span class="enscript-keyword">CALL_PANIC()</span>					<span class="enscript-comment">;	\
	hlt						;	\
</span>	<span class="enscript-keyword">.data</span>						<span class="enscript-comment">;	\
2:	String	&quot;not a mutex!&quot;				;	\
</span>	<span class="enscript-keyword">.text</span>						<span class="enscript-comment">;	\
1:
</span>
/*
 <span class="enscript-keyword">*</span> If one or more simplelocks are currently held by a thread,
 <span class="enscript-keyword">*</span> an attempt to acquire a mutex will cause this check to fail
 <span class="enscript-keyword">*</span> (since a mutex lock may context switch, holding a simplelock
 <span class="enscript-keyword">*</span> is not a good thing).
 <span class="enscript-keyword">*/
</span>#if	MACH_RT
#define CHECK_PREEMPTION_LEVEL()				\
	<span class="enscript-keyword">cmpl</span>	$0,%gs:CPU_HIBERNATE			<span class="enscript-comment">;	\
	jne	1f					;	\
</span>	<span class="enscript-keyword">cmpl</span>	$0,%gs:CPU_PREEMPTION_LEVEL		<span class="enscript-comment">;	\
	je	1f					;	\
</span>	<span class="enscript-keyword">ALIGN_STACK()</span>					<span class="enscript-comment">;	\
	movl	%gs:CPU_PREEMPTION_LEVEL, %eax		;	\
</span>	<span class="enscript-keyword">LOAD_ARG1(%eax)</span>					<span class="enscript-comment">;	\
	LOAD_STRING_ARG0(2f)				;	\
</span>	<span class="enscript-keyword">CALL_PANIC()</span>					<span class="enscript-comment">;	\
	hlt						;	\
</span>	<span class="enscript-keyword">.data</span>						<span class="enscript-comment">;	\
2:	String	&quot;preemption_level(%d) != 0!&quot;		;	\
</span>	<span class="enscript-keyword">.text</span>						<span class="enscript-comment">;	\
1:
</span>#else	/* MACH_RT */
#define	CHECK_PREEMPTION_LEVEL()
#endif	/* MACH_RT */

#define	CHECK_MYLOCK(current, owner)				\
	<span class="enscript-keyword">cmp</span>	current, owner				<span class="enscript-comment">;	\
	jne	1f					;	\
</span>	<span class="enscript-keyword">ALIGN_STACK()</span>					<span class="enscript-comment">;	\
	LOAD_STRING_ARG0(2f)				;	\
</span>	<span class="enscript-keyword">CALL_PANIC()</span>					<span class="enscript-comment">;	\
	hlt						;	\
</span>	<span class="enscript-keyword">.data</span>						<span class="enscript-comment">;	\
2:	String	&quot;Attempt to recursively lock a non-recursive lock&quot;;	\
</span>	<span class="enscript-keyword">.text</span>						<span class="enscript-comment">;	\
1:
</span>
#else	/* MACH_LDEBUG */
#define	CHECK_MUTEX_TYPE()
#define CHECK_PREEMPTION_LEVEL()
#define	CHECK_MYLOCK(thd)
#endif	/* MACH_LDEBUG */

#define PREEMPTION_DISABLE				\
	<span class="enscript-keyword">incl</span>	%gs:CPU_PREEMPTION_LEVEL

#define	PREEMPTION_LEVEL_DEBUG 1	
#if	PREEMPTION_LEVEL_DEBUG
#define	PREEMPTION_ENABLE				\
	<span class="enscript-keyword">decl</span>	%gs:CPU_PREEMPTION_LEVEL	<span class="enscript-comment">;	\
	js	17f				;	\
</span>	<span class="enscript-keyword">jnz</span>	19f				<span class="enscript-comment">;	\
	testl	$AST_URGENT,%gs:CPU_PENDING_AST	;	\
</span>	<span class="enscript-keyword">jz</span>	19f				<span class="enscript-comment">;	\
	PUSHF					;	\
</span>	<span class="enscript-keyword">testl</span>	$EFL_IF, S_PC			<span class="enscript-comment">;	\
	jz	18f				;	\
</span>	<span class="enscript-keyword">POPF</span>					<span class="enscript-comment">;	\
	int	$(T_PREEMPT)			;	\
</span>	<span class="enscript-keyword">jmp</span>	19f				<span class="enscript-comment">;	\
17:							\
</span>	<span class="enscript-keyword">call</span>	_preemption_underflow_panic	<span class="enscript-comment">;	\
18:							\
</span>	<span class="enscript-keyword">POPF</span>					<span class="enscript-comment">;	\
19:
</span>#else
#define	PREEMPTION_ENABLE				\
	<span class="enscript-keyword">decl</span>	%gs:CPU_PREEMPTION_LEVEL	<span class="enscript-comment">;	\
	jnz	19f				;	\
</span>	<span class="enscript-keyword">testl</span>	$AST_URGENT,%gs:CPU_PENDING_AST	<span class="enscript-comment">;	\
	jz	19f				;	\
</span>	<span class="enscript-keyword">PUSHF</span>					<span class="enscript-comment">;	\
	testl	$EFL_IF, S_PC			;	\
</span>	<span class="enscript-keyword">jz</span>	18f				<span class="enscript-comment">;	\
	POPF					;	\
</span>	<span class="enscript-keyword">int</span>	$(T_PREEMPT)			<span class="enscript-comment">;	\
	jmp	19f				;	\
</span><span class="enscript-function-name">18:</span>							\
	<span class="enscript-keyword">POPF</span>					<span class="enscript-comment">;	\
19:
</span>#endif


#if	CONFIG_DTRACE

       <span class="enscript-keyword">.globl</span>  _lockstat_probe
       <span class="enscript-keyword">.globl</span>  _lockstat_probemap

/*
 <span class="enscript-keyword">*</span> LOCKSTAT_LABEL creates a dtrace symbol which contains
 <span class="enscript-keyword">*</span> a pointer into the lock code function body. At that
 <span class="enscript-keyword">*</span> point is a <span class="enscript-string">&quot;ret&quot;</span> instruction that can be patched into
 <span class="enscript-keyword">*</span> a <span class="enscript-string">&quot;nop&quot;</span>
 <span class="enscript-keyword">*/
</span>
#define        LOCKSTAT_LABEL(lab) \
       <span class="enscript-keyword">.data</span>                                       <span class="enscript-comment">;\
       .globl  lab                                 ;\
</span>       <span class="enscript-keyword">lab:</span>                                        <span class="enscript-comment">;\
       .quad 9f                                    ;\
</span>       <span class="enscript-keyword">.text</span>                                       <span class="enscript-comment">;\
       9:
</span>
#define LOCKSTAT_RECORD(id, lck) \
       <span class="enscript-keyword">push</span>    %rbp                                <span class="enscript-comment">;       \
       mov     %rsp,%rbp                           ;       \
</span>       <span class="enscript-keyword">movl</span>    _lockstat_probemap + (id * 4)(%rip),%eax <span class="enscript-comment">;  \
       test    %eax,%eax                           ;       \
</span>       <span class="enscript-keyword">je</span>              9f                          <span class="enscript-comment">;       \
       mov             lck, %rsi                   ;       \
</span>       <span class="enscript-keyword">mov</span>             %rax, %rdi                  <span class="enscript-comment">;       \
       mov             $0, %rdx                    ;       \
</span>       <span class="enscript-keyword">mov</span>             $0, %rcx                    <span class="enscript-comment">;       \
       mov             $0, %r8                     ;       \
</span>       <span class="enscript-keyword">mov</span>             $0, %r9                     <span class="enscript-comment">;       \
       call    *_lockstat_probe(%rip)              ;       \
</span><span class="enscript-function-name">9:</span>	leave
	<span class="enscript-keyword">/*</span> ret - left to subsequent code, e.g. return values */

#endif /* CONFIG_DTRACE */

/*
 <span class="enscript-keyword">*</span> For most routines, the hw_lock_t pointer is loaded into a
 <span class="enscript-keyword">*</span> register initially, and then either a byte or register-sized
 <span class="enscript-keyword">*</span> word is loaded/stored to the pointer
 <span class="enscript-keyword">*/
</span> <span class="enscript-keyword">
</span>/*
 <span class="enscript-keyword">*</span>	void hw_lock_init(hw_lock_t)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Initialize a hardware lock.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_init)
	<span class="enscript-keyword">movq</span>	$0, (%rdi)		/* clear the lock */
	<span class="enscript-keyword">LEAF_RET
</span>

/*
 <span class="enscript-keyword">*</span>	void hw_lock_byte_init(volatile uint8_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Initialize a hardware byte lock.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_byte_init)
	<span class="enscript-keyword">movb</span>	$0, (%rdi)		/* clear the lock */
	<span class="enscript-keyword">LEAF_RET
</span>
/*
 <span class="enscript-keyword">*</span>	void hw_lock_lock(hw_lock_t)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Acquire lock, spinning until it becomes available.
 <span class="enscript-keyword">*</span>	MACH_RT:  also return with preemption disabled.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_lock)
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx	/* get thread pointer */
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">PREEMPTION_DISABLE
</span><span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %rax
	<span class="enscript-keyword">test</span>	%rax,%rax		/* lock locked? */
	<span class="enscript-keyword">jne</span>	3f			/* branch if so */
	<span class="enscript-keyword">lock;</span> cmpxchg %rcx,(%rdi)	/* try to acquire the HW lock */
	<span class="enscript-keyword">jne</span>	3f
	<span class="enscript-keyword">movl</span>	$1,%eax			/* In case this was a timeout call */
	<span class="enscript-keyword">LEAF_RET</span>			/* if yes, then nothing left to do */
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">PAUSE</span>				/* pause for hyper-threading */
	<span class="enscript-keyword">jmp</span>	1b			/* try again */

/*
 <span class="enscript-keyword">*</span>	void	hw_lock_byte_lock(uint8_t *lock_byte)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Acquire byte sized lock operand, spinning until it becomes available.
 <span class="enscript-keyword">*</span>	MACH_RT:  also return with preemption disabled.
 <span class="enscript-keyword">*/
</span>
LEAF_ENTRY(hw_lock_byte_lock)
	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">movl</span>	$1, %ecx		/* Set lock value */
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">movb</span>	(%rdi), %al		/* Load byte at address */
	<span class="enscript-keyword">testb</span>	%al,%al			/* lock locked? */
	<span class="enscript-keyword">jne</span>	3f			/* branch if so */
	<span class="enscript-keyword">lock;</span> cmpxchg %cl,(%rdi)	/* attempt atomic compare exchange */
	<span class="enscript-keyword">jne</span>	3f
	<span class="enscript-keyword">LEAF_RET</span>			/* if yes, then nothing left to do */
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">PAUSE</span>				/* pause for hyper-threading */
	<span class="enscript-keyword">jmp</span>	1b			/* try again */

/*
 <span class="enscript-keyword">*</span>	unsigned int hw_lock_to(hw_lock_t, unsigned int)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Acquire lock, spinning until it becomes available or timeout.
 <span class="enscript-keyword">*</span>	MACH_RT:  also return with preemption disabled.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_to)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx

	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Attempt to grab the lock immediately
	 <span class="enscript-keyword">*</span> - fastpath without timeout nonsense.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %rax
	<span class="enscript-keyword">test</span>	%rax,%rax		/* lock locked? */
	<span class="enscript-keyword">jne</span>	2f			/* branch if so */
	<span class="enscript-keyword">lock;</span> cmpxchg %rcx,(%rdi)	/* try to acquire the HW lock */
	<span class="enscript-keyword">jne</span>	2f			/* branch on failure */
	<span class="enscript-keyword">movl</span>	$1,%eax
	<span class="enscript-keyword">LEAF_RET
</span>
<span class="enscript-function-name">2:</span>
#define	INNER_LOOP_COUNT	1000
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Failed to get the lock so set the timeout
	 <span class="enscript-keyword">*</span> and then spin re-checking the lock but pausing
	 <span class="enscript-keyword">*</span> every so many (INNER_LOOP_COUNT) spins to check for timeout.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">push</span>	%r9
	<span class="enscript-keyword">lfence
</span>	<span class="enscript-keyword">rdtsc</span>				/* read cyclecount into %edx:%eax */
	<span class="enscript-keyword">shlq</span>	$32, %rdx
	<span class="enscript-keyword">orq</span>	%rdx, %rax		/* load 64-bit quantity into %rax */
	<span class="enscript-keyword">addq</span>	%rax, %rsi		/* %rsi is the timeout expiry */
	<span class="enscript-keyword">
</span><span class="enscript-function-name">4:</span>
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> The inner-loop spin to look for the lock being freed.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">mov</span>	$(INNER_LOOP_COUNT),%r9
<span class="enscript-function-name">5:</span>
	<span class="enscript-keyword">PAUSE</span>				/* pause for hyper-threading */
	<span class="enscript-keyword">mov</span>	(%rdi),%rax		/* spin checking lock value in cache */
	<span class="enscript-keyword">test</span>	%rax,%rax
	<span class="enscript-keyword">je</span>	6f			/* zero =&gt; unlocked, try to grab it */
	<span class="enscript-keyword">decq</span>	%r9			/* decrement inner loop count */
	<span class="enscript-keyword">jnz</span>	5b			/* time to check for timeout? */
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Here after spinning INNER_LOOP_COUNT times, check for timeout
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">lfence
</span>	<span class="enscript-keyword">rdtsc</span>				/* cyclecount into %edx:%eax */
	<span class="enscript-keyword">shlq</span>	$32, %rdx
	<span class="enscript-keyword">orq</span>	%rdx, %rax		/* load 64-bit quantity into %rax */
	<span class="enscript-keyword">cmpq</span>	%rsi, %rax		/* compare to timeout */
	<span class="enscript-keyword">jb</span>	4b			/* continue spinning if less, or */
	<span class="enscript-keyword">xor</span>	%rax,%rax		/* with 0 return value */
	<span class="enscript-keyword">pop</span>	%r9
	<span class="enscript-keyword">LEAF_RET
</span>
<span class="enscript-function-name">6:</span>
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Here to try to grab the lock that now appears to be free
	 <span class="enscript-keyword">*</span> after contention.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx
	<span class="enscript-keyword">lock;</span> cmpxchg %rcx,(%rdi)	/* try to acquire the HW lock */
	<span class="enscript-keyword">jne</span>	4b			/* no - spin again */
	<span class="enscript-keyword">movl</span>	$1,%eax			/* yes */
	<span class="enscript-keyword">pop</span>	%r9
	<span class="enscript-keyword">LEAF_RET
</span>
/*
 <span class="enscript-keyword">*</span>	void hw_lock_unlock(hw_lock_t)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Unconditionally release lock.
 <span class="enscript-keyword">*</span>	MACH_RT:  release preemption level.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_unlock)
	<span class="enscript-keyword">movq</span> $0, (%rdi)		/* clear the lock */
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">LEAF_RET
</span>
/*
 <span class="enscript-keyword">*</span>	void hw_lock_byte_unlock(uint8_t *lock_byte)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	Unconditionally release byte sized lock operand.
 <span class="enscript-keyword">*</span>	MACH_RT:  release preemption level.
 <span class="enscript-keyword">*/
</span>
LEAF_ENTRY(hw_lock_byte_unlock)
	<span class="enscript-keyword">movb</span> $0, (%rdi)		/* Clear the lock byte */
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">LEAF_RET
</span>
/*
 <span class="enscript-keyword">*</span>	unsigned int hw_lock_try(hw_lock_t)
 <span class="enscript-keyword">*</span>	MACH_RT:  returns with preemption disabled on success.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_try)
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx
	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>
	<span class="enscript-keyword">mov</span>	(%rdi),%rax
	<span class="enscript-keyword">test</span>	%rax,%rax
	<span class="enscript-keyword">jne</span>	1f
	<span class="enscript-keyword">lock;</span> cmpxchg %rcx,(%rdi)	/* try to acquire the HW lock */
	<span class="enscript-keyword">jne</span>	1f
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">movl</span>	$1,%eax			/* success */
	<span class="enscript-keyword">LEAF_RET
</span>
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE</span>		/* failure:  release preemption... */
	<span class="enscript-keyword">xorl</span>	%eax,%eax		/* ...and return failure */
	<span class="enscript-keyword">LEAF_RET
</span>
/*
 <span class="enscript-keyword">*</span>	unsigned int hw_lock_held(hw_lock_t)
 <span class="enscript-keyword">*</span>	MACH_RT:  doesn't change preemption state.
 <span class="enscript-keyword">*</span>	N.B.  Racy, of course.
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_lock_held)
	<span class="enscript-keyword">mov</span>	(%rdi),%rax		/* check lock value */
	<span class="enscript-keyword">test</span>	%rax,%rax
	<span class="enscript-keyword">movl</span>	$1,%ecx
	<span class="enscript-keyword">cmovne</span>	%ecx,%eax		/* 0 =&gt; unlocked, 1 =&gt; locked */
	<span class="enscript-keyword">LEAF_RET
</span>

/*
 <span class="enscript-keyword">*</span> Reader-writer lock fastpaths. These currently exist for the
 <span class="enscript-keyword">*</span> shared lock acquire, the exclusive lock acquire, the shared to
 <span class="enscript-keyword">*</span> exclusive upgrade and the release paths (where they reduce overhead
 <span class="enscript-keyword">*</span> considerably) -- these are by far the most frequently used routines
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> The following should reflect the layout of the bitfield embedded within
 <span class="enscript-keyword">*</span> the lck_rw_t structure (see i386/locks.h).
 <span class="enscript-keyword">*/
</span>#define LCK_RW_INTERLOCK	(0x1 &lt;&lt; 16)

#define LCK_RW_PRIV_EXCL	(0x1 &lt;&lt; 24)
#define LCK_RW_WANT_UPGRADE	(0x2 &lt;&lt; 24)
#define LCK_RW_WANT_WRITE	(0x4 &lt;&lt; 24)
#define LCK_R_WAITING		(0x8 &lt;&lt; 24)
#define LCK_W_WAITING		(0x10 &lt;&lt; 24)

#define LCK_RW_SHARED_MASK	(0xffff)

/*
 <span class="enscript-keyword">*</span> For most routines, the lck_rw_t pointer is loaded into a
 <span class="enscript-keyword">*</span> register initially, and the flags bitfield loaded into another
 <span class="enscript-keyword">*</span> register and examined
 <span class="enscript-keyword">*/
</span> <span class="enscript-keyword">
</span>#define	RW_LOCK_SHARED_MASK (LCK_RW_INTERLOCK | LCK_RW_WANT_UPGRADE | LCK_RW_WANT_WRITE)
/*
 <span class="enscript-keyword">*</span>	void lck_rw_lock_shared(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_lock_shared)
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx	/* Load thread pointer */
	<span class="enscript-keyword">incl</span>	TH_RWLOCK_COUNT(%rcx)		/* Increment count before atomic CAS */
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield and interlock */
	<span class="enscript-keyword">testl</span>	$(RW_LOCK_SHARED_MASK), %eax	/* Eligible for fastpath? */
	<span class="enscript-keyword">jne</span>	3f

	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">incl</span>	%ecx				/* Increment reader refcount */
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	2f

#if	CONFIG_DTRACE
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Dtrace lockstat event: LS_LCK_RW_LOCK_SHARED_ACQUIRE
	 <span class="enscript-keyword">*</span> Implemented by swapping between return and no-op instructions.
	 <span class="enscript-keyword">*</span> See bsd/dev/dtrace/lockstat.c.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_rw_lock_shared_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*
</span>	<span class="enscript-keyword">Fall</span> thru when patched, counting on lock pointer in %rdi
	<span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_RW_LOCK_SHARED_ACQUIRE,</span> %rdi)
#endif
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">jmp</span>	EXT(lck_rw_lock_shared_gen)


	<span class="enscript-keyword">
</span>#define	RW_TRY_LOCK_SHARED_MASK (LCK_RW_WANT_UPGRADE | LCK_RW_WANT_WRITE)
/*
 <span class="enscript-keyword">*</span>	void lck_rw_try_lock_shared(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_try_lock_shared)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield and interlock */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>	2f
	<span class="enscript-keyword">testl</span>	$(RW_TRY_LOCK_SHARED_MASK), %eax
	<span class="enscript-keyword">jne</span>	3f			/* lock is busy */

	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">incl</span>	%ecx				/* Increment reader refcount */
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	2f

	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx	/* Load thread pointer */
	<span class="enscript-keyword">incl</span>	TH_RWLOCK_COUNT(%rcx)		/* Increment count on success. */
	<span class="enscript-keyword">/*</span> There is a 3 instr window where preemption may not notice rwlock_count after cmpxchg */

#if	CONFIG_DTRACE
	<span class="enscript-keyword">movl</span>	$1, %eax
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Dtrace lockstat event: LS_LCK_RW_TRY_LOCK_SHARED_ACQUIRE
	 <span class="enscript-keyword">*</span> Implemented by swapping between return and no-op instructions.
	 <span class="enscript-keyword">*</span> See bsd/dev/dtrace/lockstat.c.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_rw_try_lock_shared_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> Fall thru when patched, counting on lock pointer in %rdi  */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_RW_TRY_LOCK_SHARED_ACQUIRE,</span> %rdi)
#endif
	<span class="enscript-keyword">movl</span>	$1, %eax			/* return TRUE */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">xorl</span>	%eax, %eax
	<span class="enscript-keyword">ret
</span>
	<span class="enscript-keyword">
</span>#define	RW_LOCK_EXCLUSIVE_HELD	(LCK_RW_WANT_WRITE | LCK_RW_WANT_UPGRADE)
/*
 <span class="enscript-keyword">*</span>	int lck_rw_grab_shared(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_grab_shared)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield and interlock */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>	5f
	<span class="enscript-keyword">testl</span>	$(RW_LOCK_EXCLUSIVE_HELD), %eax	
	<span class="enscript-keyword">jne</span>	3f
<span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">movl</span>	%eax, %ecx		/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">incl</span>	%ecx			/* Increment reader refcount */
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)		/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	4f

	<span class="enscript-keyword">movl</span>	$1, %eax		/* return success */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">testl</span>	$(LCK_RW_SHARED_MASK), %eax
	<span class="enscript-keyword">je</span>	4f
	<span class="enscript-keyword">testl</span>	$(LCK_RW_PRIV_EXCL), %eax
	<span class="enscript-keyword">je</span>	2b
<span class="enscript-function-name">4:</span>
	<span class="enscript-keyword">xorl</span>	%eax, %eax		/* return failure */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">5:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b


	<span class="enscript-keyword">
</span>#define	RW_LOCK_EXCLUSIVE_MASK (LCK_RW_SHARED_MASK | LCK_RW_INTERLOCK | \
	                        <span class="enscript-keyword">LCK_RW_WANT_UPGRADE</span> | LCK_RW_WANT_WRITE)
/*
 <span class="enscript-keyword">*</span>	void lck_rw_lock_exclusive(lck_rw_t*)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_lock_exclusive)
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx	/* Load thread pointer */
	<span class="enscript-keyword">incl</span>	TH_RWLOCK_COUNT(%rcx)		/* Increment count before atomic CAS */
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield, interlock and shared count */
	<span class="enscript-keyword">testl</span>	$(RW_LOCK_EXCLUSIVE_MASK), %eax		/* Eligible for fastpath? */
	<span class="enscript-keyword">jne</span>	3f					/* no, go slow */

	<span class="enscript-keyword">movl</span>	%eax, %ecx				/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">orl</span>	$(LCK_RW_WANT_WRITE), %ecx
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	2f

#if	CONFIG_DTRACE
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Dtrace lockstat event: LS_LCK_RW_LOCK_EXCL_ACQUIRE
	 <span class="enscript-keyword">*</span> Implemented by swapping between return and no-op instructions.
	 <span class="enscript-keyword">*</span> See bsd/dev/dtrace/lockstat.c.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_rw_lock_exclusive_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> Fall thru when patched, counting on lock pointer in %rdi  */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_RW_LOCK_EXCL_ACQUIRE,</span> %rdi)
#endif
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">jmp</span>	EXT(lck_rw_lock_exclusive_gen)


	<span class="enscript-keyword">
</span>#define	RW_TRY_LOCK_EXCLUSIVE_MASK (LCK_RW_SHARED_MASK | LCK_RW_WANT_UPGRADE | LCK_RW_WANT_WRITE)
/*
 <span class="enscript-keyword">*</span>	void lck_rw_try_lock_exclusive(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>		Tries to get a write lock.
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>		Returns FALSE if the lock is not held on return.
 <span class="enscript-keyword">*/
</span>Entry(lck_rw_try_lock_exclusive)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield, interlock and shared count */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>	2f
	<span class="enscript-keyword">testl</span>	$(RW_TRY_LOCK_EXCLUSIVE_MASK), %eax
	<span class="enscript-keyword">jne</span>	3f				/* can't get it */

	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">orl</span>	$(LCK_RW_WANT_WRITE), %ecx
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	2f

	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx	/* Load thread pointer */
	<span class="enscript-keyword">incl</span>	TH_RWLOCK_COUNT(%rcx)		/* Increment count on success. */
	<span class="enscript-keyword">/*</span> There is a 3 instr window where preemption may not notice rwlock_count after cmpxchg */

#if	CONFIG_DTRACE
	<span class="enscript-keyword">movl</span>	$1, %eax
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Dtrace lockstat event: LS_LCK_RW_TRY_LOCK_EXCL_ACQUIRE
	 <span class="enscript-keyword">*</span> Implemented by swapping between return and no-op instructions.
	 <span class="enscript-keyword">*</span> See bsd/dev/dtrace/lockstat.c.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_rw_try_lock_exclusive_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> Fall thru when patched, counting on lock pointer in %rdi  */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_RW_TRY_LOCK_EXCL_ACQUIRE,</span> %rdi)
#endif
	<span class="enscript-keyword">movl</span>	$1, %eax			/* return TRUE */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">xorl</span>	%eax, %eax			/* return FALSE */
	<span class="enscript-keyword">ret</span>	



/*
 <span class="enscript-keyword">*</span>	void lck_rw_lock_shared_to_exclusive(lck_rw_t*)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	fastpath can be taken if
 <span class="enscript-keyword">*</span>	the current rw_shared_count == 1
 <span class="enscript-keyword">*</span>	AND the interlock is clear
 <span class="enscript-keyword">*</span>	AND RW_WANT_UPGRADE is not set
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span>	note that RW_WANT_WRITE could be set, but will not
 <span class="enscript-keyword">*</span>	be indicative of an exclusive hold since we have
 <span class="enscript-keyword">*</span> 	a read count on the lock that we have not yet released
 <span class="enscript-keyword">*</span>	we can blow by that state since the lck_rw_lock_exclusive
 <span class="enscript-keyword">*</span> 	function will block until rw_shared_count == 0 and 
 <span class="enscript-keyword">*</span> 	RW_WANT_UPGRADE is clear... it does this check behind
 <span class="enscript-keyword">*</span>	the interlock which we are also checking for
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> 	to make the transition we must be able to atomically
 <span class="enscript-keyword">*</span>	set RW_WANT_UPGRADE and get rid of the read count we hold
 <span class="enscript-keyword">*/
</span>Entry(lck_rw_lock_shared_to_exclusive)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield, interlock and shared count */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>	7f
	<span class="enscript-keyword">testl</span>	$(LCK_RW_WANT_UPGRADE), %eax
	<span class="enscript-keyword">jne</span>	2f

	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">orl</span>	$(LCK_RW_WANT_UPGRADE), %ecx	/* ask for WANT_UPGRADE */
	<span class="enscript-keyword">decl</span>	%ecx				/* and shed our read count */
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	7f
						<span class="enscript-keyword">/*</span> we now own the WANT_UPGRADE */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_SHARED_MASK), %ecx	/* check to see if all of the readers are drained */
	<span class="enscript-keyword">jne</span>	8f				/* if not, we need to go wait */

#if	CONFIG_DTRACE
	<span class="enscript-keyword">movl</span>	$1, %eax
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> Dtrace lockstat event: LS_LCK_RW_LOCK_SHARED_TO_EXCL_UPGRADE
	 <span class="enscript-keyword">*</span> Implemented by swapping between return and no-op instructions.
	 <span class="enscript-keyword">*</span> See bsd/dev/dtrace/lockstat.c.
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_rw_lock_shared_to_exclusive_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>    <span class="enscript-keyword">/*</span> Fall thru when patched, counting on lock pointer in %rdi  */
    <span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_RW_LOCK_SHARED_TO_EXCL_UPGRADE,</span> %rdi)
#endif
	<span class="enscript-keyword">movl</span>	$1, %eax			/* return success */
	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">
</span><span class="enscript-function-name">2:</span>						/* someone else already holds WANT_UPGRADE */
	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">decl</span>	%ecx				/* shed our read count */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_SHARED_MASK), %ecx
	<span class="enscript-keyword">jne</span>	3f				/* we were the last reader */
	<span class="enscript-keyword">andl</span>	$(~LCK_W_WAITING), %ecx		/* so clear the wait indicator */
<span class="enscript-function-name">3:</span>	
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	7f

	<span class="enscript-keyword">mov</span>	%eax, %esi			/* put old flags as second arg */
						<span class="enscript-keyword">/*</span> lock is alread in %rdi */
	<span class="enscript-keyword">call</span>	EXT(lck_rw_lock_shared_to_exclusive_failure)
	<span class="enscript-keyword">ret</span>					/* and pass the failure return along */	
<span class="enscript-function-name">7:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b
<span class="enscript-function-name">8:</span>
	<span class="enscript-keyword">jmp</span>	EXT(lck_rw_lock_shared_to_exclusive_success)


	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">.cstring
</span><span class="enscript-function-name">rwl_release_error_str:</span>
	<span class="enscript-keyword">.asciz</span>  <span class="enscript-string">&quot;Releasing non-exclusive RW lock without a reader refcount!&quot;</span>
	<span class="enscript-keyword">.text
</span>	<span class="enscript-keyword">
</span>/*
 <span class="enscript-keyword">*</span>	lck_rw_type_t lck_rw_done(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_done)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield, interlock and reader count */
	<span class="enscript-keyword">testl</span>   $(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>     7f				/* wait for interlock to clear */

	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* keep original value in %eax for cmpxchgl */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_SHARED_MASK), %ecx	/* if reader count == 0, must be exclusive lock */
	<span class="enscript-keyword">je</span>	2f
	<span class="enscript-keyword">decl</span>	%ecx				/* Decrement reader count */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_SHARED_MASK), %ecx	/* if reader count has now gone to 0, check for waiters */
	<span class="enscript-keyword">je</span>	4f
	<span class="enscript-keyword">jmp</span>	6f
<span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">testl</span>	$(LCK_RW_WANT_UPGRADE), %ecx
	<span class="enscript-keyword">je</span>	3f
	<span class="enscript-keyword">andl</span>	$(~LCK_RW_WANT_UPGRADE), %ecx
	<span class="enscript-keyword">jmp</span>	4f
<span class="enscript-function-name">3:</span>	
	<span class="enscript-keyword">testl</span>	$(LCK_RW_WANT_WRITE), %ecx
	<span class="enscript-keyword">je</span>	8f				/* lock is not 'owned', go panic */
	<span class="enscript-keyword">andl</span>	$(~LCK_RW_WANT_WRITE), %ecx
<span class="enscript-function-name">4:</span>	
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> test the original values to match what
	 <span class="enscript-keyword">*</span> lck_rw_done_gen is going to do to determine
	 <span class="enscript-keyword">*</span> which wakeups need to happen...
	 <span class="enscript-keyword">*
</span>	 <span class="enscript-keyword">*</span> if !(fake_lck-&gt;lck_rw_priv_excl &amp;&amp; fake_lck-&gt;lck_w_waiting)
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">testl</span>	$(LCK_W_WAITING), %eax
	<span class="enscript-keyword">je</span>	5f
	<span class="enscript-keyword">andl</span>	$(~LCK_W_WAITING), %ecx

	<span class="enscript-keyword">testl</span>	$(LCK_RW_PRIV_EXCL), %eax
	<span class="enscript-keyword">jne</span>	6f
<span class="enscript-function-name">5:</span>	
	<span class="enscript-keyword">andl</span>	$(~LCK_R_WAITING), %ecx
<span class="enscript-function-name">6:</span>	
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	7f

	<span class="enscript-keyword">mov</span>	%eax,%esi	/* old flags in %rsi */
				<span class="enscript-keyword">/*</span> lock is in %rdi already */
	<span class="enscript-keyword">call</span>	EXT(lck_rw_done_gen)	
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">7:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b
<span class="enscript-function-name">8:</span>
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(rwl_release_error_str)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">
</span>
	<span class="enscript-keyword">
</span>/*
 <span class="enscript-keyword">*</span>	lck_rw_type_t lck_rw_lock_exclusive_to_shared(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_lock_exclusive_to_shared)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield, interlock and reader count */
	<span class="enscript-keyword">testl</span>   $(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>     6f				/* wait for interlock to clear */

	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* keep original value in %eax for cmpxchgl */
	<span class="enscript-keyword">incl</span>	%ecx				/* Increment reader count */

	<span class="enscript-keyword">testl</span>	$(LCK_RW_WANT_UPGRADE), %ecx
	<span class="enscript-keyword">je</span>	2f
	<span class="enscript-keyword">andl</span>	$(~LCK_RW_WANT_UPGRADE), %ecx
	<span class="enscript-keyword">jmp</span>	3f
<span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">andl</span>	$(~LCK_RW_WANT_WRITE), %ecx
<span class="enscript-function-name">3:</span>	
	<span class="enscript-keyword">/*
</span>	 <span class="enscript-keyword">*</span> test the original values to match what
	 <span class="enscript-keyword">*</span> lck_rw_lock_exclusive_to_shared_gen is going to do to determine
	 <span class="enscript-keyword">*</span> which wakeups need to happen...
	 <span class="enscript-keyword">*
</span>	 <span class="enscript-keyword">*</span> if !(fake_lck-&gt;lck_rw_priv_excl &amp;&amp; fake_lck-&gt;lck_w_waiting)
	 <span class="enscript-keyword">*/
</span>	<span class="enscript-keyword">testl</span>	$(LCK_W_WAITING), %eax
	<span class="enscript-keyword">je</span>	4f
	<span class="enscript-keyword">testl</span>	$(LCK_RW_PRIV_EXCL), %eax
	<span class="enscript-keyword">jne</span>	5f
<span class="enscript-function-name">4:</span>	
	<span class="enscript-keyword">andl</span>	$(~LCK_R_WAITING), %ecx
<span class="enscript-function-name">5:</span>	
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	6f

	<span class="enscript-keyword">mov</span>	%eax,%esi
	<span class="enscript-keyword">call</span>	EXT(lck_rw_lock_exclusive_to_shared_gen)
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">6:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b



/*
 <span class="enscript-keyword">*</span>	int lck_rw_grab_want(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_grab_want)
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	(%rdi), %eax		/* Load state bitfield, interlock and reader count */
	<span class="enscript-keyword">testl</span>   $(LCK_RW_INTERLOCK), %eax
	<span class="enscript-keyword">jne</span>     3f				/* wait for interlock to clear */
	<span class="enscript-keyword">testl</span>	$(LCK_RW_WANT_WRITE), %eax	/* want_write has been grabbed by someone else */
	<span class="enscript-keyword">jne</span>	2f				/* go return failure */
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">movl</span>	%eax, %ecx			/* original value in %eax for cmpxchgl */
	<span class="enscript-keyword">orl</span>	$(LCK_RW_WANT_WRITE), %ecx
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchgl</span> %ecx, (%rdi)			/* Attempt atomic exchange */
	<span class="enscript-keyword">jne</span>	2f
						<span class="enscript-keyword">/*</span> we now own want_write */
	<span class="enscript-keyword">movl</span>	$1, %eax			/* return success */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">xorl</span>	%eax, %eax			/* return failure */
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b

	<span class="enscript-keyword">
</span>#define	RW_LOCK_SHARED_OR_UPGRADE_MASK (LCK_RW_SHARED_MASK | LCK_RW_INTERLOCK | LCK_RW_WANT_UPGRADE)
/*
 <span class="enscript-keyword">*</span>	int lck_rw_held_read_or_upgrade(lck_rw_t *)
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*/
</span>Entry(lck_rw_held_read_or_upgrade)
	<span class="enscript-keyword">mov</span>	(%rdi), %eax
	<span class="enscript-keyword">andl</span>	$(RW_LOCK_SHARED_OR_UPGRADE_MASK), %eax
	<span class="enscript-keyword">ret
</span>

	<span class="enscript-keyword">
</span>/*
 <span class="enscript-keyword">*</span> N.B.: On x86, statistics are currently recorded for all indirect mutexes.
 <span class="enscript-keyword">*</span> Also, only the acquire attempt count (GRP_MTX_STAT_UTIL) is maintained
 <span class="enscript-keyword">*</span> as a 64-bit quantity (this matches the existing PowerPC implementation,
 <span class="enscript-keyword">*</span> and the new x86 specific statistics are also maintained as 32-bit
 <span class="enscript-keyword">*</span> quantities).
 <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*
</span> <span class="enscript-keyword">*</span> Enable this preprocessor define to record the first miss alone
 <span class="enscript-keyword">*</span> By default, we count every miss, hence multiple misses may be
 <span class="enscript-keyword">*</span> recorded for a single lock acquire attempt via lck_mtx_lock
 <span class="enscript-keyword">*/
</span>#undef LOG_FIRST_MISS_ALONE	

/*
 <span class="enscript-keyword">*</span> This preprocessor define controls whether the R-M-W update of the
 <span class="enscript-keyword">*</span> per-group statistics elements are atomic (LOCK-prefixed)
 <span class="enscript-keyword">*</span> Enabled by default.
 <span class="enscript-keyword">*/
</span>#define ATOMIC_STAT_UPDATES 1

#if defined(ATOMIC_STAT_UPDATES)
#define LOCK_IF_ATOMIC_STAT_UPDATES lock
#else
#define LOCK_IF_ATOMIC_STAT_UPDATES
#endif /* ATOMIC_STAT_UPDATES */


/*
 <span class="enscript-keyword">*</span> For most routines, the lck_mtx_t pointer is loaded into a
 <span class="enscript-keyword">*</span> register initially, and the owner field checked for indirection.
 <span class="enscript-keyword">*</span> Eventually the lock owner is loaded into a register and examined.
 <span class="enscript-keyword">*/
</span>
#define M_OWNER		MUTEX_OWNER
#define M_PTR		MUTEX_PTR
#define M_STATE		MUTEX_STATE	
	<span class="enscript-keyword">
</span>
#define LMTX_ENTER_EXTENDED					\
	<span class="enscript-keyword">mov</span>	M_PTR(%rdx), %rdx 			<span class="enscript-comment">;	\
	xor	%r11, %r11				;	\
</span>	<span class="enscript-keyword">mov</span>	MUTEX_GRP(%rdx), %r10		 	<span class="enscript-comment">;	\
	LOCK_IF_ATOMIC_STAT_UPDATES 			;	\
</span>	<span class="enscript-keyword">incq</span>	GRP_MTX_STAT_UTIL(%r10)


#if	LOG_FIRST_MISS_ALONE
#define LMTX_UPDATE_MISS					\
	<span class="enscript-keyword">test</span>	$1, %r11 				<span class="enscript-comment">;	\
	jnz	11f					;	\
</span>	<span class="enscript-keyword">LOCK_IF_ATOMIC_STAT_UPDATES</span> 			<span class="enscript-comment">;	\
	incl	GRP_MTX_STAT_MISS(%r10)			;	\
</span>	<span class="enscript-keyword">or</span>	$1, %r11				<span class="enscript-comment">;	\
11:
</span>#else
#define LMTX_UPDATE_MISS					\
	<span class="enscript-keyword">LOCK_IF_ATOMIC_STAT_UPDATES</span> 			<span class="enscript-comment">;	\
	incl	GRP_MTX_STAT_MISS(%r10)
</span>#endif
	<span class="enscript-keyword">
</span>
#if	LOG_FIRST_MISS_ALONE
#define LMTX_UPDATE_WAIT					\
	<span class="enscript-keyword">test</span>	$2, %r11 				<span class="enscript-comment">;	\
	jnz	11f					;	\
</span>	<span class="enscript-keyword">LOCK_IF_ATOMIC_STAT_UPDATES</span> 			<span class="enscript-comment">;	\
	incl	GRP_MTX_STAT_WAIT(%r10)			;	\
</span>	<span class="enscript-keyword">or</span>	$2, %r11				<span class="enscript-comment">;	\
11:
</span>#else
#define LMTX_UPDATE_WAIT					\
	<span class="enscript-keyword">LOCK_IF_ATOMIC_STAT_UPDATES</span> 			<span class="enscript-comment">;	\
	incl	GRP_MTX_STAT_WAIT(%r10)
</span>#endif


/*
 <span class="enscript-keyword">*</span> Record the <span class="enscript-string">&quot;direct wait&quot;</span> statistic, which indicates if a
 <span class="enscript-keyword">*</span> miss proceeded to block directly without spinning--occurs
 <span class="enscript-keyword">*</span> if the owner of the mutex isn't running on another processor
 <span class="enscript-keyword">*</span> at the time of the check.
 <span class="enscript-keyword">*/
</span>#define LMTX_UPDATE_DIRECT_WAIT					\
	<span class="enscript-keyword">LOCK_IF_ATOMIC_STAT_UPDATES</span> 			<span class="enscript-comment">;	\
	incl	GRP_MTX_STAT_DIRECT_WAIT(%r10)
</span>
	<span class="enscript-keyword">
</span>#define LMTX_CALLEXT1(func_name)		\
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		<span class="enscript-comment">;	\
	je	12f			;	\
</span>	<span class="enscript-keyword">push</span>	%r10			<span class="enscript-comment">;	\
	push	%r11			;	\
</span><span class="enscript-function-name">12:</span>	push	%rdi			<span class="enscript-comment">;	\
	push	%rdx			;	\
</span>	<span class="enscript-keyword">mov</span>	%rdx, %rdi		<span class="enscript-comment">;	\
	call	EXT(func_name)		;	\
</span>	<span class="enscript-keyword">pop</span>	%rdx			<span class="enscript-comment">;	\
	pop	%rdi			;	\
</span>	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		<span class="enscript-comment">;	\
	je	12f			;	\
</span>	<span class="enscript-keyword">pop</span>	%r11			<span class="enscript-comment">;	\
	pop	%r10			;	\
</span><span class="enscript-function-name">12:</span>
	<span class="enscript-keyword">
</span>#define LMTX_CALLEXT2(func_name, reg)		\
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		<span class="enscript-comment">;	\
	je	12f			;	\
</span>	<span class="enscript-keyword">push</span>	%r10			<span class="enscript-comment">;	\
	push	%r11			;	\
</span><span class="enscript-function-name">12:</span>	push	%rdi			<span class="enscript-comment">;	\
	push	%rdx			;	\
</span>	<span class="enscript-keyword">mov</span>	reg, %rsi		<span class="enscript-comment">;	\
	mov	%rdx, %rdi		;	\
</span>	<span class="enscript-keyword">call</span>	EXT(func_name)		<span class="enscript-comment">;	\
	pop	%rdx			;	\
</span>	<span class="enscript-keyword">pop</span>	%rdi			<span class="enscript-comment">;	\
	cmp	%rdx, %rdi		;	\
</span>	<span class="enscript-keyword">je</span>	12f			<span class="enscript-comment">;	\
	pop	%r11			;	\
</span>	<span class="enscript-keyword">pop</span>	%r10			<span class="enscript-comment">;	\
12:
</span>

#define M_WAITERS_MSK		0x0000ffff
#define M_PRIORITY_MSK		0x00ff0000
#define M_ILOCKED_MSK		0x01000000
#define M_MLOCKED_MSK		0x02000000
#define M_PROMOTED_MSK		0x04000000
#define M_SPIN_MSK		0x08000000

/*
 <span class="enscript-keyword">*</span>	void lck_mtx_assert(lck_mtx_t* l, unsigned int)
 <span class="enscript-keyword">*</span>	Takes the address of a lock, and an assertion type as parameters.
 <span class="enscript-keyword">*</span>	The assertion can take one of two forms determine by the type
 <span class="enscript-keyword">*</span>	parameter: either the lock is held by the current thread, and the
 <span class="enscript-keyword">*</span>	type is	LCK_MTX_ASSERT_OWNED, or it isn't and the type is
 <span class="enscript-keyword">*</span>	LCK_MTX_ASSERT_NOTOWNED. Calls panic on assertion failure.
 <span class="enscript-keyword">*</span>	
 <span class="enscript-keyword">*/
</span>
NONLEAF_ENTRY(lck_mtx_assert)
        <span class="enscript-keyword">mov</span>	%rdi, %rdx                   	/* Load lock address */
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax	/* Load current thread */

	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx		/* Is this an indirect mutex? */
	<span class="enscript-keyword">jne</span>	0f
	<span class="enscript-keyword">mov</span>	M_PTR(%rdx), %rdx		/* If so, take indirection */
<span class="enscript-function-name">0:</span>	
	<span class="enscript-keyword">mov</span>	M_OWNER(%rdx), %rcx		/* Load owner */
	<span class="enscript-keyword">cmp</span>	$(MUTEX_ASSERT_OWNED), %rsi
	<span class="enscript-keyword">jne</span>	2f				/* Assert ownership? */
	<span class="enscript-keyword">cmp</span>	%rax, %rcx			/* Current thread match? */
	<span class="enscript-keyword">jne</span>	3f				/* no, go panic */
	<span class="enscript-keyword">testl</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), M_STATE(%rdx)
	<span class="enscript-keyword">je</span>	3f
<span class="enscript-function-name">1:</span>						/* yes, we own it */
	<span class="enscript-keyword">NONLEAF_RET
</span><span class="enscript-function-name">2:</span>
	<span class="enscript-keyword">cmp</span>	%rax, %rcx			/* Current thread match? */
	<span class="enscript-keyword">jne</span>	1b				/* No, return */
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_PTR_ARG1(%rdx)
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(mutex_assert_owned_str)
</span>	<span class="enscript-keyword">jmp</span>	4f
<span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_PTR_ARG1(%rdx)
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(mutex_assert_not_owned_str)
</span><span class="enscript-function-name">4:</span>
	<span class="enscript-keyword">CALL_PANIC()
</span>

<span class="enscript-function-name">lck_mtx_destroyed:</span>
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_PTR_ARG1(%rdx)
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(mutex_interlock_destroyed_str)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">
</span>
.data
<span class="enscript-function-name">mutex_assert_not_owned_str:</span>
	<span class="enscript-keyword">.asciz</span>	<span class="enscript-string">&quot;mutex (%p) not owned\n&quot;</span>
<span class="enscript-function-name">mutex_assert_owned_str:</span>
	<span class="enscript-keyword">.asciz</span>	<span class="enscript-string">&quot;mutex (%p) owned\n&quot;</span>
<span class="enscript-function-name">mutex_interlock_destroyed_str:</span>
	<span class="enscript-keyword">.asciz</span>	<span class="enscript-string">&quot;trying to interlock destroyed mutex (%p)&quot;</span>
.text



/*
 <span class="enscript-keyword">*</span> lck_mtx_lock()
 <span class="enscript-keyword">*</span> lck_mtx_try_lock()
 <span class="enscript-keyword">*</span> lck_mtx_unlock()
 <span class="enscript-keyword">*</span> lck_mtx_lock_spin()
 <span class="enscript-keyword">*</span> lck_mtx_lock_spin_always()
 <span class="enscript-keyword">*</span> lck_mtx_try_lock_spin()
 <span class="enscript-keyword">*</span> lck_mtx_try_lock_spin_always()
 <span class="enscript-keyword">*</span> lck_mtx_convert_spin()
 <span class="enscript-keyword">*/
</span>NONLEAF_ENTRY(lck_mtx_lock_spin_always)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */
	<span class="enscript-keyword">jmp</span>     Llmls_avoid_check
	<span class="enscript-keyword">
</span>NONLEAF_ENTRY(lck_mtx_lock_spin)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */

	<span class="enscript-keyword">CHECK_PREEMPTION_LEVEL()
</span><span class="enscript-function-name">Llmls_avoid_check:</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx	/* is the interlock or mutex held */
	<span class="enscript-keyword">jnz</span>	Llmls_slow
<span class="enscript-function-name">Llmls_try:</span>				/* no - can't be INDIRECT, DESTROYED or locked */
	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK | M_SPIN_MSK), %ecx

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	Llmls_busy_disabled

 	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)	/* record owner of interlock */
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">incl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>	
#endif	/* MACH_LDEBUG */

	<span class="enscript-keyword">/*</span> return with the interlock held and preemption disabled */
	<span class="enscript-keyword">leave
</span>#if	CONFIG_DTRACE
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_lock_spin_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_LOCK_SPIN_ACQUIRE,</span> %rdx)
#endif
	<span class="enscript-keyword">ret
</span>
<span class="enscript-function-name">Llmls_slow:</span>	
	<span class="enscript-keyword">test</span>	$M_ILOCKED_MSK, %ecx		/* is the interlock held */
	<span class="enscript-keyword">jz</span>	Llml_contended			/* no, must have been the mutex */

	<span class="enscript-keyword">cmp</span>	$(MUTEX_DESTROYED), %ecx	/* check to see if its marked destroyed */
	<span class="enscript-keyword">je</span>	lck_mtx_destroyed
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx		/* Is this an indirect mutex */
	<span class="enscript-keyword">jne</span>	Llmls_loop			/* no... must be interlocked */

	<span class="enscript-keyword">LMTX_ENTER_EXTENDED
</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_SPIN_MSK), %ecx
	<span class="enscript-keyword">jz</span>	Llmls_loop1

	<span class="enscript-keyword">LMTX_UPDATE_MISS</span>		/* M_SPIN_MSK was set, so M_ILOCKED_MSK must also be present */
<span class="enscript-function-name">Llmls_loop:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">Llmls_loop1:</span>
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx
	<span class="enscript-keyword">jz</span>	Llmls_try
	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK), %ecx
	<span class="enscript-keyword">jnz</span>	Llml_contended			/* mutex owned by someone else, go contend for it */
	<span class="enscript-keyword">jmp</span>	Llmls_loop

<span class="enscript-function-name">Llmls_busy_disabled:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">jmp</span>	Llmls_loop


	<span class="enscript-keyword">
</span>NONLEAF_ENTRY(lck_mtx_lock)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */

	<span class="enscript-keyword">CHECK_PREEMPTION_LEVEL()
</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx	/* is the interlock or mutex held */
	<span class="enscript-keyword">jnz</span>	Llml_slow
<span class="enscript-function-name">Llml_try:</span>				/* no - can't be INDIRECT, DESTROYED or locked */
	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	Llml_busy_disabled

 	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)	/* record owner of mutex */
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">incl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>
#endif	/* MACH_LDEBUG */

	<span class="enscript-keyword">testl</span>	$(M_WAITERS_MSK), M_STATE(%rdx)
	<span class="enscript-keyword">jz</span>	Llml_finish

	<span class="enscript-keyword">LMTX_CALLEXT1(lck_mtx_lock_acquire_x86)
</span>
<span class="enscript-function-name">Llml_finish:</span>
	<span class="enscript-keyword">andl</span>	$(~M_ILOCKED_MSK), M_STATE(%rdx)
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		/* is this an extended mutex */
	<span class="enscript-keyword">jne</span>	2f

	<span class="enscript-keyword">leave
</span>#if	CONFIG_DTRACE
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_lock_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_LOCK_ACQUIRE,</span> %rdx)
#endif
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">leave
</span>#if	CONFIG_DTRACE
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_lock_ext_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_EXT_LOCK_ACQUIRE,</span> %rdx)
#endif
	<span class="enscript-keyword">ret
</span>
	<span class="enscript-keyword">
</span><span class="enscript-function-name">Llml_slow:</span>
	<span class="enscript-keyword">test</span>	$M_ILOCKED_MSK, %ecx		/* is the interlock held */
	<span class="enscript-keyword">jz</span>	Llml_contended			/* no, must have been the mutex */
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">cmp</span>	$(MUTEX_DESTROYED), %ecx	/* check to see if its marked destroyed */
	<span class="enscript-keyword">je</span>	lck_mtx_destroyed
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx		/* Is this an indirect mutex? */
	<span class="enscript-keyword">jne</span>	Llml_loop			/* no... must be interlocked */

	<span class="enscript-keyword">LMTX_ENTER_EXTENDED
</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_SPIN_MSK), %ecx
	<span class="enscript-keyword">jz</span>	Llml_loop1

	<span class="enscript-keyword">LMTX_UPDATE_MISS</span>		/* M_SPIN_MSK was set, so M_ILOCKED_MSK must also be present */
<span class="enscript-function-name">Llml_loop:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">Llml_loop1:</span>
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx
	<span class="enscript-keyword">jz</span>	Llml_try
	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK), %ecx
	<span class="enscript-keyword">jnz</span>	Llml_contended			/* mutex owned by someone else, go contend for it */
	<span class="enscript-keyword">jmp</span>	Llml_loop

<span class="enscript-function-name">Llml_busy_disabled:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">jmp</span>	Llml_loop

	<span class="enscript-keyword">
</span><span class="enscript-function-name">Llml_contended:</span>
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		/* is this an extended mutex */
	<span class="enscript-keyword">je</span>	0f
	<span class="enscript-keyword">LMTX_UPDATE_MISS
</span><span class="enscript-function-name">0:</span>	
	<span class="enscript-keyword">LMTX_CALLEXT1(lck_mtx_lock_spinwait_x86)
</span>
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	Llml_acquired		/* acquired mutex, interlock held and preemption disabled */

	<span class="enscript-keyword">cmp</span>	$1, %rax		/* check for direct wait status */
	<span class="enscript-keyword">je</span>	2f
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		/* is this an extended mutex */
	<span class="enscript-keyword">je</span>	2f
	<span class="enscript-keyword">LMTX_UPDATE_DIRECT_WAIT
</span><span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %ecx
	<span class="enscript-keyword">jnz</span>	6f

	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK), %ecx	/* try to take the interlock */

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	5f

	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK), %ecx	/* we've got the interlock and */
	<span class="enscript-keyword">jnz</span>	3f
	<span class="enscript-keyword">or</span>	$(M_MLOCKED_MSK), %ecx	/* the mutex is free... grab it directly */
	<span class="enscript-keyword">mov</span>	%ecx, M_STATE(%rdx)
	<span class="enscript-keyword">
</span> 	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)	/* record owner of mutex */
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">incl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>
#endif	/* MACH_LDEBUG */

<span class="enscript-function-name">Llml_acquired:</span>
	<span class="enscript-keyword">testl</span>	$(M_WAITERS_MSK), M_STATE(%rdx)
	<span class="enscript-keyword">jnz</span>	1f
	<span class="enscript-keyword">mov</span>	M_OWNER(%rdx), %rax
	<span class="enscript-keyword">mov</span>	TH_WAS_PROMOTED_ON_WAKEUP(%rax), %eax
	<span class="enscript-keyword">test</span>	%eax, %eax
	<span class="enscript-keyword">jz</span>	Llml_finish
<span class="enscript-function-name">1:</span>	
	<span class="enscript-keyword">LMTX_CALLEXT1(lck_mtx_lock_acquire_x86)
</span>	<span class="enscript-keyword">jmp</span>	Llml_finish

<span class="enscript-function-name">3:</span>					/* interlock held, mutex busy */
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi		/* is this an extended mutex */
	<span class="enscript-keyword">je</span>	4f
	<span class="enscript-keyword">LMTX_UPDATE_WAIT
</span><span class="enscript-function-name">4:</span>	
	<span class="enscript-keyword">LMTX_CALLEXT1(lck_mtx_lock_wait_x86)
</span>	<span class="enscript-keyword">jmp</span>	Llml_contended
<span class="enscript-function-name">5:</span>	
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span><span class="enscript-function-name">6:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	2b
	<span class="enscript-keyword">
</span>
NONLEAF_ENTRY(lck_mtx_try_lock_spin_always)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */
	<span class="enscript-keyword">jmp</span>     Llmts_avoid_check

NONLEAF_ENTRY(lck_mtx_try_lock_spin)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */

<span class="enscript-function-name">Llmts_avoid_check:</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx	/* is the interlock or mutex held */
	<span class="enscript-keyword">jnz</span>	Llmts_slow
<span class="enscript-function-name">Llmts_try:</span>				/* no - can't be INDIRECT, DESTROYED or locked */
	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK | M_SPIN_MSK), %rcx

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	Llmts_busy_disabled

 	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)	/* record owner of mutex */
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">incl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>
#endif	/* MACH_LDEBUG */

	<span class="enscript-keyword">leave
</span>
#if	CONFIG_DTRACE
	<span class="enscript-keyword">mov</span>	$1, %rax			/* return success */
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_try_lock_spin_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_TRY_SPIN_LOCK_ACQUIRE,</span> %rdx)
#endif
	<span class="enscript-keyword">mov</span>	$1, %rax			/* return success */
	<span class="enscript-keyword">ret
</span>
<span class="enscript-function-name">Llmts_slow:</span>
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %ecx	/* is the interlock held */
	<span class="enscript-keyword">jz</span>	Llmts_fail			/* no, must be held as a mutex */

	<span class="enscript-keyword">cmp</span>	$(MUTEX_DESTROYED), %ecx	/* check to see if its marked destroyed */
	<span class="enscript-keyword">je</span>	lck_mtx_destroyed
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx		/* Is this an indirect mutex? */
	<span class="enscript-keyword">jne</span>	Llmts_loop1

	<span class="enscript-keyword">LMTX_ENTER_EXTENDED
</span><span class="enscript-function-name">Llmts_loop:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">Llmts_loop1:</span>
	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK | M_SPIN_MSK), %ecx
	<span class="enscript-keyword">jnz</span>	Llmts_fail
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %ecx
	<span class="enscript-keyword">jz</span>	Llmts_try
	<span class="enscript-keyword">jmp</span>	Llmts_loop
	<span class="enscript-keyword">
</span><span class="enscript-function-name">Llmts_busy_disabled:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">jmp</span>	Llmts_loop


	<span class="enscript-keyword">
</span>NONLEAF_ENTRY(lck_mtx_try_lock)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */

	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx	/* is the interlock or mutex held */
	<span class="enscript-keyword">jnz</span>	Llmt_slow	
<span class="enscript-function-name">Llmt_try:</span>				/* no - can't be INDIRECT, DESTROYED or locked */
	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx
	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	Llmt_busy_disabled

 	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)	/* record owner of mutex */
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">incl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>
#endif	/* MACH_LDEBUG */

	<span class="enscript-keyword">test</span>	$(M_WAITERS_MSK), %ecx
	<span class="enscript-keyword">jz</span>	0f

	<span class="enscript-keyword">LMTX_CALLEXT1(lck_mtx_lock_acquire_x86)
</span><span class="enscript-function-name">0:</span>
	<span class="enscript-keyword">andl</span>	$(~M_ILOCKED_MSK), M_STATE(%rdx)
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>
	<span class="enscript-keyword">leave
</span>#if	CONFIG_DTRACE
	<span class="enscript-keyword">mov</span>	$1, %rax			/* return success */
	<span class="enscript-keyword">/*</span> Dtrace probe: LS_LCK_MTX_TRY_LOCK_ACQUIRE */
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_try_lock_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx from above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_TRY_LOCK_ACQUIRE,</span> %rdx)
#endif	
	<span class="enscript-keyword">mov</span>	$1, %rax			/* return success */
	<span class="enscript-keyword">ret
</span>
<span class="enscript-function-name">Llmt_slow:</span>
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %ecx	/* is the interlock held */
	<span class="enscript-keyword">jz</span>	Llmt_fail			/* no, must be held as a mutex */

	<span class="enscript-keyword">cmp</span>	$(MUTEX_DESTROYED), %ecx	/* check to see if its marked destroyed */
	<span class="enscript-keyword">je</span>	lck_mtx_destroyed
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx		/* Is this an indirect mutex? */
	<span class="enscript-keyword">jne</span>	Llmt_loop

	<span class="enscript-keyword">LMTX_ENTER_EXTENDED
</span><span class="enscript-function-name">Llmt_loop:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">Llmt_loop1:</span>
	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK | M_SPIN_MSK), %ecx
	<span class="enscript-keyword">jnz</span>	Llmt_fail
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %ecx
	<span class="enscript-keyword">jz</span>	Llmt_try
	<span class="enscript-keyword">jmp</span>	Llmt_loop

<span class="enscript-function-name">Llmt_busy_disabled:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>	<span class="enscript-keyword">jmp</span>	Llmt_loop


<span class="enscript-function-name">Llmt_fail:</span>
<span class="enscript-function-name">Llmts_fail:</span>
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi			/* is this an extended mutex */
	<span class="enscript-keyword">je</span>	0f
	<span class="enscript-keyword">LMTX_UPDATE_MISS
</span><span class="enscript-function-name">0:</span>
	<span class="enscript-keyword">xor</span>	%rax, %rax
	<span class="enscript-keyword">NONLEAF_RET
</span>


NONLEAF_ENTRY(lck_mtx_convert_spin)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx			/* fetch lock pointer */

	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx		/* Is this an indirect mutex? */
	<span class="enscript-keyword">jne</span>	0f
	<span class="enscript-keyword">mov</span>	M_PTR(%rdx), %rdx		/* If so, take indirection */
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">0:</span>
	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK), %ecx		/* already owned as a mutex, just return */
	<span class="enscript-keyword">jnz</span>	2f
	<span class="enscript-keyword">test</span>	$(M_WAITERS_MSK), %ecx		/* are there any waiters? */
	<span class="enscript-keyword">jz</span>	1f

	<span class="enscript-keyword">LMTX_CALLEXT1(lck_mtx_lock_acquire_x86)
</span>	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">1:</span>	
	<span class="enscript-keyword">and</span>	$(~(M_ILOCKED_MSK | M_SPIN_MSK)), %ecx	/* convert from spin version to mutex */
	<span class="enscript-keyword">or</span>	$(M_MLOCKED_MSK), %ecx
	<span class="enscript-keyword">mov</span>	%ecx, M_STATE(%rdx)		/* since I own the interlock, I don't need an atomic update */

	<span class="enscript-keyword">PREEMPTION_ENABLE
</span><span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">NONLEAF_RET
</span>
	<span class="enscript-keyword">
</span>
NONLEAF_ENTRY(lck_mtx_unlock)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer */
<span class="enscript-function-name">Llmu_entry:</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
<span class="enscript-function-name">Llmu_prim:</span>
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx	/* Is this an indirect mutex? */
	<span class="enscript-keyword">je</span>	Llmu_ext

<span class="enscript-function-name">Llmu_chktype:</span>
	<span class="enscript-keyword">test</span>	$(M_MLOCKED_MSK), %ecx	/* check for full mutex */
	<span class="enscript-keyword">jz</span>	Llmu_unlock
<span class="enscript-function-name">Llmu_mutex:</span>
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %rcx	/* have to wait for interlock to clear */
	<span class="enscript-keyword">jnz</span>	Llmu_busy

	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">and</span>	$(~M_MLOCKED_MSK), %ecx	/* drop mutex */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK), %ecx	/* pick up interlock */

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	Llmu_busy_disabled	/* branch on failure to spin loop */

<span class="enscript-function-name">Llmu_unlock:</span>
	<span class="enscript-keyword">xor</span>	%rax, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)
	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* keep original state in %ecx for later evaluation */
	<span class="enscript-keyword">and</span>	$(~(M_ILOCKED_MSK | M_SPIN_MSK | M_PROMOTED_MSK)), %rax

	<span class="enscript-keyword">test</span>	$(M_WAITERS_MSK), %eax
	<span class="enscript-keyword">jz</span>	2f
	<span class="enscript-keyword">dec</span>	%eax			/* decrement waiter count */
<span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">mov</span>	%eax, M_STATE(%rdx)	/* since I own the interlock, I don't need an atomic update */

#if	MACH_LDEBUG
	<span class="enscript-keyword">/*</span> perform lock statistics after drop to prevent delay */
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">decl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>
#endif	/* MACH_LDEBUG */

	<span class="enscript-keyword">test</span>	$(M_PROMOTED_MSK | M_WAITERS_MSK), %ecx
	<span class="enscript-keyword">jz</span>	3f

	<span class="enscript-keyword">LMTX_CALLEXT2(lck_mtx_unlock_wakeup_x86,</span> %rcx)
<span class="enscript-function-name">3:</span>	
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>
	<span class="enscript-keyword">cmp</span>	%rdx, %rdi
	<span class="enscript-keyword">jne</span>	4f

	<span class="enscript-keyword">leave
</span>#if	CONFIG_DTRACE
	<span class="enscript-keyword">/*</span> Dtrace: LS_LCK_MTX_UNLOCK_RELEASE */
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_unlock_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx from above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_UNLOCK_RELEASE,</span> %rdx)
#endif
	<span class="enscript-keyword">ret
</span><span class="enscript-function-name">4:</span>	
	<span class="enscript-keyword">leave
</span>#if	CONFIG_DTRACE
	<span class="enscript-keyword">/*</span> Dtrace: LS_LCK_MTX_EXT_UNLOCK_RELEASE */
	<span class="enscript-keyword">LOCKSTAT_LABEL(_lck_mtx_ext_unlock_lockstat_patch_point)
</span>	<span class="enscript-keyword">ret
</span>	<span class="enscript-keyword">/*</span> inherit lock pointer in %rdx from above */
	<span class="enscript-keyword">LOCKSTAT_RECORD(LS_LCK_MTX_EXT_UNLOCK_RELEASE,</span> %rdx)
#endif
	<span class="enscript-keyword">ret
</span>

<span class="enscript-function-name">Llmu_busy_disabled:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span><span class="enscript-function-name">Llmu_busy:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">jmp</span>	Llmu_mutex

<span class="enscript-function-name">Llmu_ext:</span>
	<span class="enscript-keyword">mov</span>	M_PTR(%rdx), %rdx
	<span class="enscript-keyword">mov</span>	M_OWNER(%rdx), %rax
	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rcx
	<span class="enscript-keyword">CHECK_UNLOCK(%rcx,</span> %rax)
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">jmp</span> 	Llmu_chktype


	<span class="enscript-keyword">
</span>LEAF_ENTRY(lck_mtx_ilk_try_lock)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer - no indirection here */

	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx

	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %ecx	/* can't have the interlock yet */
	<span class="enscript-keyword">jnz</span>	3f

	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK), %ecx

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	2f			/* return failure after re-enabling preemption */

	<span class="enscript-keyword">mov</span>	$1, %rax		/* return success with preemption disabled */
	<span class="enscript-keyword">LEAF_RET
</span><span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">PREEMPTION_ENABLE</span>		/* need to re-enable preemption */
<span class="enscript-function-name">3:</span>	
	<span class="enscript-keyword">xor</span>	%rax, %rax		/* return failure */
	<span class="enscript-keyword">LEAF_RET
</span>	<span class="enscript-keyword">
</span>
LEAF_ENTRY(lck_mtx_ilk_unlock)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer - no indirection here */

	<span class="enscript-keyword">andl</span>	$(~M_ILOCKED_MSK), M_STATE(%rdx)

	<span class="enscript-keyword">PREEMPTION_ENABLE</span>		/* need to re-enable preemption */

	<span class="enscript-keyword">LEAF_RET
</span>
	<span class="enscript-keyword">
</span>LEAF_ENTRY(lck_mtx_lock_grab_mutex)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx		/* fetch lock pointer - no indirection here */

	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx

	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx	/* can't have the mutex yet */
	<span class="enscript-keyword">jnz</span>	3f

	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK | M_MLOCKED_MSK), %ecx

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	2f				/* branch on failure to spin loop */

 	<span class="enscript-keyword">mov</span>	%gs:CPU_ACTIVE_THREAD, %rax
	<span class="enscript-keyword">mov</span>	%rax, M_OWNER(%rdx)	/* record owner of mutex */
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	%rax, %rax
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">incl</span>	TH_MUTEX_COUNT(%rax)	/* lock statistic */
<span class="enscript-function-name">1:</span>
#endif	/* MACH_LDEBUG */

	<span class="enscript-keyword">mov</span>	$1, %rax		/* return success */
	<span class="enscript-keyword">LEAF_RET
</span><span class="enscript-function-name">2:</span>						
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span><span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">xor</span>	%rax, %rax	/* return failure */
	<span class="enscript-keyword">LEAF_RET
</span>	<span class="enscript-keyword">
</span>

LEAF_ENTRY(lck_mtx_lock_mark_destroyed)
	<span class="enscript-keyword">mov</span>	%rdi, %rdx
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">mov</span>	M_STATE(%rdx), %ecx
	<span class="enscript-keyword">cmp</span>	$(MUTEX_IND), %ecx	/* Is this an indirect mutex? */
	<span class="enscript-keyword">jne</span>	2f

	<span class="enscript-keyword">movl</span>	$(MUTEX_DESTROYED), M_STATE(%rdx)	/* convert to destroyed state */
	<span class="enscript-keyword">jmp</span>	3f
<span class="enscript-function-name">2:</span>	
	<span class="enscript-keyword">test</span>	$(M_ILOCKED_MSK), %rcx	/* have to wait for interlock to clear */
	<span class="enscript-keyword">jnz</span>	5f

	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>	<span class="enscript-keyword">mov</span>	%rcx, %rax		/* eax contains snapshot for cmpxchgl */
	<span class="enscript-keyword">or</span>	$(M_ILOCKED_MSK), %ecx
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">cmpxchg</span> %ecx, M_STATE(%rdx)	/* atomic compare and exchange */
	<span class="enscript-keyword">jne</span>	4f			/* branch on failure to spin loop */
	<span class="enscript-keyword">movl</span>	$(MUTEX_DESTROYED), M_STATE(%rdx)	/* convert to destroyed state */
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span><span class="enscript-function-name">3:</span>
	<span class="enscript-keyword">LEAF_RET</span>			/* return with M_ILOCKED set */
<span class="enscript-function-name">4:</span>
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span><span class="enscript-function-name">5:</span>
	<span class="enscript-keyword">PAUSE
</span>	<span class="enscript-keyword">jmp</span>	1b

LEAF_ENTRY(preemption_underflow_panic)
	<span class="enscript-keyword">FRAME
</span>	<span class="enscript-keyword">incl</span>	%gs:CPU_PREEMPTION_LEVEL
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(16f)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">hlt
</span>	<span class="enscript-keyword">.data
</span><span class="enscript-function-name">16:</span>	String	<span class="enscript-string">&quot;Preemption level underflow, possible cause unlocking an unlocked mutex or spinlock&quot;</span>
	<span class="enscript-keyword">.text
</span>

LEAF_ENTRY(_disable_preemption)
#if	MACH_RT
	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>#endif	/* MACH_RT */
	<span class="enscript-keyword">LEAF_RET
</span>
LEAF_ENTRY(_enable_preemption)
#if	MACH_RT
#if	MACH_ASSERT
	<span class="enscript-keyword">cmpl</span>	$0,%gs:CPU_PREEMPTION_LEVEL
	<span class="enscript-keyword">jg</span>	1f
	<span class="enscript-keyword">movl</span>	%gs:CPU_PREEMPTION_LEVEL,%esi
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(_enable_preemption_less_than_zero)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">hlt
</span>	<span class="enscript-keyword">.cstring
</span><span class="enscript-function-name">_enable_preemption_less_than_zero:</span>
	<span class="enscript-keyword">.asciz</span>	<span class="enscript-string">&quot;_enable_preemption: preemption_level(%d)  &lt; 0!&quot;</span>
	<span class="enscript-keyword">.text
</span><span class="enscript-function-name">1:</span>
#endif	/* MACH_ASSERT */
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>#endif	/* MACH_RT */
	<span class="enscript-keyword">LEAF_RET
</span>
LEAF_ENTRY(_enable_preemption_no_check)
#if	MACH_RT
#if	MACH_ASSERT
	<span class="enscript-keyword">cmpl</span>	$0,%gs:CPU_PREEMPTION_LEVEL
	<span class="enscript-keyword">jg</span>	1f
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(_enable_preemption_no_check_less_than_zero)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">hlt
</span>	<span class="enscript-keyword">.cstring
</span><span class="enscript-function-name">_enable_preemption_no_check_less_than_zero:</span>
	<span class="enscript-keyword">.asciz</span>	<span class="enscript-string">&quot;_enable_preemption_no_check: preemption_level &lt;= 0!&quot;</span>
	<span class="enscript-keyword">.text
</span><span class="enscript-function-name">1:</span>
#endif	/* MACH_ASSERT */
	<span class="enscript-keyword">_ENABLE_PREEMPTION_NO_CHECK
</span>#endif	/* MACH_RT */
	<span class="enscript-keyword">LEAF_RET
</span>	<span class="enscript-keyword">
</span>	<span class="enscript-keyword">
</span>LEAF_ENTRY(_mp_disable_preemption)
#if	MACH_RT
	<span class="enscript-keyword">PREEMPTION_DISABLE
</span>#endif	/* MACH_RT */
	<span class="enscript-keyword">LEAF_RET
</span>
LEAF_ENTRY(_mp_enable_preemption)
#if	MACH_RT
#if	MACH_ASSERT
	<span class="enscript-keyword">cmpl</span>	$0,%gs:CPU_PREEMPTION_LEVEL
	<span class="enscript-keyword">jg</span>	1f
	<span class="enscript-keyword">movl</span>	%gs:CPU_PREEMPTION_LEVEL,%esi
	<span class="enscript-keyword">ALIGN_PANIC()
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(_mp_enable_preemption_less_than_zero)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">hlt
</span>	<span class="enscript-keyword">.cstring
</span><span class="enscript-function-name">_mp_enable_preemption_less_than_zero:</span>
	<span class="enscript-keyword">.asciz</span> <span class="enscript-string">&quot;_mp_enable_preemption: preemption_level (%d) &lt;= 0!&quot;</span>
	<span class="enscript-keyword">.text
</span><span class="enscript-function-name">1:</span>
#endif	/* MACH_ASSERT */
	<span class="enscript-keyword">PREEMPTION_ENABLE
</span>#endif	/* MACH_RT */
	<span class="enscript-keyword">LEAF_RET
</span>
LEAF_ENTRY(_mp_enable_preemption_no_check)
#if	MACH_RT
#if	MACH_ASSERT
	<span class="enscript-keyword">cmpl</span>	$0,%gs:CPU_PREEMPTION_LEVEL
	<span class="enscript-keyword">jg</span>	1f
	<span class="enscript-keyword">ALIGN_STACK()
</span>	<span class="enscript-keyword">LOAD_STRING_ARG0(_mp_enable_preemption_no_check_less_than_zero)
</span>	<span class="enscript-keyword">CALL_PANIC()
</span>	<span class="enscript-keyword">hlt
</span>	<span class="enscript-keyword">.cstring
</span><span class="enscript-function-name">_mp_enable_preemption_no_check_less_than_zero:</span>
	<span class="enscript-keyword">.asciz</span> <span class="enscript-string">&quot;_mp_enable_preemption_no_check: preemption_level &lt;= 0!&quot;</span>
	<span class="enscript-keyword">.text
</span><span class="enscript-function-name">1:</span>
#endif	/* MACH_ASSERT */
	<span class="enscript-keyword">_ENABLE_PREEMPTION_NO_CHECK
</span>#endif	/* MACH_RT */
	<span class="enscript-keyword">LEAF_RET
</span>	<span class="enscript-keyword">
</span>/*
 <span class="enscript-keyword">*</span> Atomic primitives, prototyped in kern/simple_lock.h
 <span class="enscript-keyword">*/
</span>LEAF_ENTRY(hw_atomic_add)
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	$3, %rdi
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">ud2
</span><span class="enscript-function-name">1:</span>
#endif	
	<span class="enscript-keyword">movl</span>	%esi, %eax		/* Load addend */
	<span class="enscript-keyword">lock</span> 	xaddl %eax, (%rdi)	/* Atomic exchange and add */
	<span class="enscript-keyword">addl</span>	%esi, %eax		/* Calculate result */
	<span class="enscript-keyword">LEAF_RET
</span>
LEAF_ENTRY(hw_atomic_sub)
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	$3, %rdi
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">ud2
</span><span class="enscript-function-name">1:</span>
#endif	
	<span class="enscript-keyword">negl</span>	%esi
	<span class="enscript-keyword">movl</span>	%esi, %eax
	<span class="enscript-keyword">lock</span>	xaddl %eax, (%rdi)	/* Atomic exchange and add */
	<span class="enscript-keyword">addl</span>	%esi, %eax		/* Calculate result */
	<span class="enscript-keyword">LEAF_RET
</span>
LEAF_ENTRY(hw_atomic_or)
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	$3, %rdi
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">ud2
</span><span class="enscript-function-name">1:</span>
#endif	
	<span class="enscript-keyword">movl</span>	(%rdi), %eax
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">movl</span>	%esi, %edx		/* Load mask */
	<span class="enscript-keyword">orl</span>	%eax, %edx
	<span class="enscript-keyword">lock</span>	cmpxchgl %edx, (%rdi)	/* Atomic CAS */
	<span class="enscript-keyword">jne</span>	1b
	<span class="enscript-keyword">movl</span>	%edx, %eax		/* Result */
	<span class="enscript-keyword">LEAF_RET
</span>/*
 <span class="enscript-keyword">*</span> A variant of hw_atomic_or which doesn't return a value.
 <span class="enscript-keyword">*</span> The implementation is thus comparatively more efficient.
 <span class="enscript-keyword">*/
</span>
LEAF_ENTRY(hw_atomic_or_noret)
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	$3, %rdi
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">ud2
</span><span class="enscript-function-name">1:</span>
#endif	
	<span class="enscript-keyword">lock
</span>	<span class="enscript-keyword">orl</span>	%esi, (%rdi)		/* Atomic OR */
	<span class="enscript-keyword">LEAF_RET
</span>

LEAF_ENTRY(hw_atomic_and)
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	$3, %rdi
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">ud2
</span><span class="enscript-function-name">1:</span>
#endif	
	<span class="enscript-keyword">movl</span>	(%rdi), %eax
<span class="enscript-function-name">1:</span>
	<span class="enscript-keyword">movl</span>	%esi, %edx		/* Load mask */
	<span class="enscript-keyword">andl</span>	%eax, %edx
	<span class="enscript-keyword">lock</span>	cmpxchgl %edx, (%rdi)	/* Atomic CAS */
	<span class="enscript-keyword">jne</span>	1b
	<span class="enscript-keyword">movl</span>	%edx, %eax		/* Result */
	<span class="enscript-keyword">LEAF_RET
</span>/*
 <span class="enscript-keyword">*</span> A variant of hw_atomic_and which doesn't return a value.
 <span class="enscript-keyword">*</span> The implementation is thus comparatively more efficient.
 <span class="enscript-keyword">*/
</span>
LEAF_ENTRY(hw_atomic_and_noret)
#if	MACH_LDEBUG
	<span class="enscript-keyword">test</span>	$3, %rdi
	<span class="enscript-keyword">jz</span>	1f
	<span class="enscript-keyword">ud2
</span><span class="enscript-function-name">1:</span>
#endif	
	<span class="enscript-keyword">lock</span>	andl	%esi, (%rdi)	/* Atomic OR */
	<span class="enscript-keyword">LEAF_RET
</span>
</pre>
<hr />
</body></html>