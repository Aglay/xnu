<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>fpu.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">fpu.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1992-1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/i386/fp_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/branch_predicates.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;architecture/i386/pio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/fpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/trap.h&gt;</span>

<span class="enscript-type">int</span>		fp_kind = FP_NO;	<span class="enscript-comment">/* not inited */</span>
zone_t		ifps_zone;		<span class="enscript-comment">/* zone for FPU save area */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ALIGNED</span>(addr,size)	(((uintptr_t)(addr)&amp;((size)-1))==0)

<span class="enscript-comment">/* Forward */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		fpinit(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		fp_save(
				thread_t	thr_act);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		fp_load(
				thread_t	thr_act);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">configure_mxcsr_capability_mask</span>(<span class="enscript-type">struct</span> x86_avx_thread_state *fps);

<span class="enscript-type">struct</span> x86_avx_thread_state initial_fp_state <span class="enscript-function-name">__attribute</span>((aligned(64)));


<span class="enscript-comment">/* Global MXCSR capability bitmask */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mxcsr_capability_mask;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fninit</span>() \
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;fninit&quot;</span>)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fnstcw</span>(control) \
	__asm__(<span class="enscript-string">&quot;fnstcw %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (*(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)(control)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fldcw</span>(control) \
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;fldcw %0&quot;</span> : : <span class="enscript-string">&quot;m&quot;</span> (*(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *) &amp;(control)) )

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fnclex</span>() \
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;fnclex&quot;</span>)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fnsave</span>(state)  \
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;fnsave %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (*state))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">frstor</span>(state) \
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;frstor %0&quot;</span> : : <span class="enscript-string">&quot;m&quot;</span> (state))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">fwait</span>() \
    	__asm__(<span class="enscript-string">&quot;fwait&quot;</span>);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">fxrstor</span>(addr)           __asm__ __volatile__(<span class="enscript-string">&quot;fxrstor %0&quot;</span> : : <span class="enscript-string">&quot;m&quot;</span> (*(addr)))     
#<span class="enscript-reference">define</span> <span class="enscript-function-name">fxsave</span>(addr)            __asm__ __volatile__(<span class="enscript-string">&quot;fxsave %0&quot;</span> : <span class="enscript-string">&quot;=m&quot;</span> (*(addr)))

<span class="enscript-type">static</span> uint32_t	fp_register_state_size = 0;
<span class="enscript-type">static</span> uint32_t fpu_YMM_present	= FALSE;
<span class="enscript-type">static</span> uint32_t	cpuid_reevaluated = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fpu_store_registers</span>(<span class="enscript-type">void</span> *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fpu_load_registers</span>(<span class="enscript-type">void</span> *);

<span class="enscript-type">extern</span>	<span class="enscript-type">void</span> xsave64o(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span>	<span class="enscript-type">void</span> xrstor64o(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">XMASK</span> ((uint32_t) (XFEM_X87 | XFEM_SSE | XFEM_YMM))

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">xsetbv</span>(uint32_t mask_hi, uint32_t mask_lo) {
	__asm__ __volatile__(<span class="enscript-string">&quot;xsetbv&quot;</span> :: <span class="enscript-string">&quot;a&quot;</span>(mask_lo), <span class="enscript-string">&quot;d&quot;</span>(mask_hi), <span class="enscript-string">&quot;c&quot;</span> (XCR0));
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">xsave</span>(<span class="enscript-type">struct</span> x86_fx_thread_state *a) {
	__asm__ __volatile__(<span class="enscript-string">&quot;xsave %0&quot;</span> :<span class="enscript-string">&quot;=m&quot;</span> (*a) : <span class="enscript-string">&quot;a&quot;</span>(XMASK), <span class="enscript-string">&quot;d&quot;</span>(0));
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">xrstor</span>(<span class="enscript-type">struct</span> x86_fx_thread_state *a) {
	__asm__ __volatile__(<span class="enscript-string">&quot;xrstor %0&quot;</span> ::  <span class="enscript-string">&quot;m&quot;</span> (*a), <span class="enscript-string">&quot;a&quot;</span>(XMASK), <span class="enscript-string">&quot;d&quot;</span>(0));
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>
<span class="enscript-function-name">fnstsw</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> status;
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;fnstsw %0&quot;</span> : <span class="enscript-string">&quot;=ma&quot;</span> (status));
	<span class="enscript-keyword">return</span>(status);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Configure the initial FPU state presented to new threads.
 * Determine the MXCSR capability mask, which allows us to mask off any
 * potentially unsafe &quot;reserved&quot; bits before restoring the FPU context.
 * *Not* per-cpu, assumes symmetry.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">configure_mxcsr_capability_mask</span>(<span class="enscript-type">struct</span> x86_avx_thread_state *fps)
{
	<span class="enscript-comment">/* XSAVE requires a 64 byte aligned store */</span>
	assert(ALIGNED(fps, 64));
	<span class="enscript-comment">/* Clear, to prepare for the diagnostic FXSAVE */</span>
	bzero(fps, <span class="enscript-keyword">sizeof</span>(*fps));

	fpinit();
	fpu_store_registers(fps, FALSE);

	mxcsr_capability_mask = fps-&gt;fx_MXCSR_MASK;

	<span class="enscript-comment">/* Set default mask value if necessary */</span>
	<span class="enscript-keyword">if</span> (mxcsr_capability_mask == 0)
		mxcsr_capability_mask = 0xffbf;
	
	<span class="enscript-comment">/* Clear vector register store */</span>
	bzero(&amp;fps-&gt;fx_XMM_reg[0][0], <span class="enscript-keyword">sizeof</span>(fps-&gt;fx_XMM_reg));
	bzero(&amp;fps-&gt;x_YMMH_reg[0][0], <span class="enscript-keyword">sizeof</span>(fps-&gt;x_YMMH_reg));

	fps-&gt;fp_valid = TRUE;
	fps-&gt;fp_save_layout = fpu_YMM_present ? XSAVE32: FXSAVE32;
	fpu_load_registers(fps);

	<span class="enscript-comment">/* Poison values to trap unsafe usage */</span>
	fps-&gt;fp_valid = 0xFFFFFFFF;
	fps-&gt;fp_save_layout = FP_UNUSED;

	<span class="enscript-comment">/* Re-enable FPU/SSE DNA exceptions */</span>
	set_ts();
}


<span class="enscript-comment">/*
 * Look for FPU and initialize it.
 * Called on each CPU.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">init_fpu</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>	
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>	status;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> 	control;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Check for FPU by initializing it,
	 * then trying to read the correct bit patterns from
	 * the control and status registers.
	 */</span>
	set_cr0((get_cr0() &amp; ~(CR0_EM|CR0_TS)) | CR0_NE);	<span class="enscript-comment">/* allow use of FPU */</span>
	fninit();
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>	
	status = fnstsw();
	fnstcw(&amp;control);
	
	assert(((status &amp; 0xff) == 0) &amp;&amp; ((control &amp; 0x103f) == 0x3f));
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Advertise SSE support */</span>
	<span class="enscript-keyword">if</span> (cpuid_features() &amp; CPUID_FEATURE_FXSR) {
		fp_kind = FP_FXSR;
		set_cr4(get_cr4() | CR4_OSFXS);
		<span class="enscript-comment">/* And allow SIMD exceptions if present */</span>
		<span class="enscript-keyword">if</span> (cpuid_features() &amp; CPUID_FEATURE_SSE) {
			set_cr4(get_cr4() | CR4_OSXMM);
		}
		fp_register_state_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_fx_thread_state);

	} <span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;fpu is not FP_FXSR&quot;</span>);

	<span class="enscript-comment">/* Configure the XSAVE context mechanism if the processor supports
	 * AVX/YMM registers
	 */</span>
	<span class="enscript-keyword">if</span> (cpuid_features() &amp; CPUID_FEATURE_XSAVE) {
		cpuid_xsave_leaf_t *xsp = &amp;cpuid_info()-&gt;cpuid_xsave_leaf[0];
		<span class="enscript-keyword">if</span> (xsp-&gt;extended_state[0] &amp; (uint32_t)XFEM_YMM) {
			assert(xsp-&gt;extended_state[0] &amp; (uint32_t) XFEM_SSE);
			<span class="enscript-comment">/* XSAVE container size for all features */</span>
			fp_register_state_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_avx_thread_state);
			fpu_YMM_present = TRUE;
			set_cr4(get_cr4() | CR4_OSXSAVE);
			xsetbv(0, XMASK);
			<span class="enscript-comment">/* Re-evaluate CPUID, once, to reflect OSXSAVE */</span>
			<span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, &amp;cpuid_reevaluated))
				cpuid_set_info();
			<span class="enscript-comment">/* Verify that now selected state can be accommodated */</span>
			assert(xsp-&gt;extended_state[1] == fp_register_state_size);
		}
	}
	<span class="enscript-keyword">else</span>
		fpu_YMM_present = FALSE;

	fpinit();

	<span class="enscript-comment">/*
	 * Trap wait instructions.  Turn off FPU for now.
	 */</span>
	set_cr0(get_cr0() | CR0_TS | CR0_MP);
}

<span class="enscript-comment">/*
 * Allocate and initialize FP state for current thread.
 * Don't load state.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">fp_state_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = zalloc(ifps_zone);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>	
	<span class="enscript-keyword">if</span> (!(ALIGNED(ifps,64))) {
		panic(<span class="enscript-string">&quot;fp_state_alloc: %p, %u, %p, %u&quot;</span>, ifps, (<span class="enscript-type">unsigned</span>) ifps_zone-&gt;elem_size, (<span class="enscript-type">void</span> *) ifps_zone-&gt;free_elements, (<span class="enscript-type">unsigned</span>) ifps_zone-&gt;alloc_size);
	}
#<span class="enscript-reference">endif</span>
	bzero(ifps, <span class="enscript-keyword">sizeof</span>(*ifps));
	<span class="enscript-keyword">return</span> ifps;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">fp_state_free</span>(<span class="enscript-type">void</span> *ifps)
{
	zfree(ifps_zone, ifps);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">clear_fpu</span>(<span class="enscript-type">void</span>)
{
	set_ts();
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fpu_load_registers</span>(<span class="enscript-type">void</span> *fstate) {
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = fstate;
	fp_save_layout_t layout = ifps-&gt;fp_save_layout;

	assert(layout == FXSAVE32 || layout == FXSAVE64 || layout == XSAVE32 || layout == XSAVE64);
	assert(ALIGNED(ifps, 64));
	assert(ml_get_interrupts_enabled() == FALSE);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>	
	<span class="enscript-keyword">if</span> (layout == XSAVE32 || layout == XSAVE64) {
		<span class="enscript-type">struct</span> x86_avx_thread_state *iavx = fstate;
		<span class="enscript-type">unsigned</span> i;
		<span class="enscript-comment">/* Verify reserved bits in the XSAVE header*/</span>
		<span class="enscript-keyword">if</span> (iavx-&gt;_xh.xsbv &amp; ~7)
			panic(<span class="enscript-string">&quot;iavx-&gt;_xh.xsbv: 0x%llx&quot;</span>, iavx-&gt;_xh.xsbv);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(iavx-&gt;_xh.xhrsvd); i++)
			<span class="enscript-keyword">if</span> (iavx-&gt;_xh.xhrsvd[i])
				panic(<span class="enscript-string">&quot;Reserved bit set&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (fpu_YMM_present) {
		<span class="enscript-keyword">if</span> (layout != XSAVE32 &amp;&amp; layout != XSAVE64)
			panic(<span class="enscript-string">&quot;Inappropriate layout: %u\n&quot;</span>, layout);
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">if</span> ((layout == XSAVE64) || (layout == XSAVE32))
		xrstor(ifps);
	<span class="enscript-keyword">else</span>
		fxrstor(ifps);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fpu_store_registers</span>(<span class="enscript-type">void</span> *fstate, boolean_t is64) {
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = fstate;
	assert(ALIGNED(ifps, 64));
	<span class="enscript-keyword">if</span> (fpu_YMM_present) {
		xsave(ifps);
		ifps-&gt;fp_save_layout = is64 ? XSAVE64 : XSAVE32;
	}
	<span class="enscript-keyword">else</span> {
		fxsave(ifps);
		ifps-&gt;fp_save_layout = is64 ? FXSAVE64 : FXSAVE32;
	}
}

<span class="enscript-comment">/*
 * Initialize FP handling.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpu_module_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> ((fp_register_state_size != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_fx_thread_state)) &amp;&amp;
	    (fp_register_state_size != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_avx_thread_state)))
		panic(<span class="enscript-string">&quot;fpu_module_init: incorrect savearea size %u\n&quot;</span>, fp_register_state_size);

	assert(fpu_YMM_present != 0xFFFFFFFF);

	<span class="enscript-comment">/* We explicitly choose an allocation size of 64
	 * to eliminate waste for the 832 byte sized
	 * AVX XSAVE register save area.
	 */</span>
	ifps_zone = zinit(fp_register_state_size,
			  thread_max * fp_register_state_size,
			  64 * fp_register_state_size,
			  <span class="enscript-string">&quot;x86 fpsave state&quot;</span>);

	<span class="enscript-comment">/* To maintain the required alignment, disable
	 * zone debugging for this zone as that appends
	 * 16 bytes to each element.
	 */</span>
	zone_change(ifps_zone, Z_ALIGNMENT_REQUIRED, TRUE);
	<span class="enscript-comment">/* Determine MXCSR reserved bits and configure initial FPU state*/</span>
	configure_mxcsr_capability_mask(&amp;initial_fp_state);
}

<span class="enscript-comment">/*
 * Save thread`s FPU context.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fpu_save_context</span>(thread_t thread)
{
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps;

	assert(ml_get_interrupts_enabled() == FALSE);
	ifps = (thread)-&gt;machine.ifps;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (ifps &amp;&amp; ((ifps-&gt;fp_valid != FALSE) &amp;&amp; (ifps-&gt;fp_valid != TRUE))) {
		panic(<span class="enscript-string">&quot;ifps-&gt;fp_valid: %u\n&quot;</span>, ifps-&gt;fp_valid);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (ifps != 0 &amp;&amp; (ifps-&gt;fp_valid == FALSE)) {
		<span class="enscript-comment">/* Clear CR0.TS in preparation for the FP context save. In
		 * theory, this shouldn't be necessary since a live FPU should
		 * indicate that TS is clear. However, various routines
		 * (such as sendsig &amp; sigreturn) manipulate TS directly.
		 */</span>
		clear_ts();
		<span class="enscript-comment">/* registers are in FPU - save to memory */</span>
		fpu_store_registers(ifps, (thread_is_64bit(thread) &amp;&amp; is_saved_state64(thread-&gt;machine.iss)));
		ifps-&gt;fp_valid = TRUE;
	}
	set_ts();
}


<span class="enscript-comment">/*
 * Free a FPU save area.
 * Called only when thread terminating - no locking necessary.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fpu_free</span>(<span class="enscript-type">void</span> *fps)
{
	fp_state_free(fps);
}

<span class="enscript-comment">/*
 * Set the floating-point state for a thread based 
 * on the FXSave formatted data. This is basically  
 * the same as fpu_set_state except it uses the 
 * expanded data structure. 
 * If the thread is not the current thread, it is
 * not running (held).  Locking needed against
 * concurrent fpu_set_state or fpu_get_state.
 */</span>
kern_return_t
<span class="enscript-function-name">fpu_set_fxstate</span>(
	thread_t	thr_act,
	thread_state_t	tstate,
	thread_flavor_t f)
{
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps;
	<span class="enscript-type">struct</span> x86_fx_thread_state *new_ifps;
	x86_float_state64_t	*state;
	pcb_t	pcb;
	size_t	state_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_fx_thread_state);
	boolean_t	old_valid, fresh_state = FALSE;

	<span class="enscript-keyword">if</span> (fp_kind == FP_NO)
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	<span class="enscript-keyword">if</span> ((f == x86_AVX_STATE32 || f == x86_AVX_STATE64) &amp;&amp;
	    !ml_fpu_avx_enabled())
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	state = (x86_float_state64_t *)tstate;

	assert(thr_act != THREAD_NULL);
	pcb = THREAD_TO_PCB(thr_act);

	<span class="enscript-keyword">if</span> (state == NULL) {
		<span class="enscript-comment">/*
		 * new FPU state is 'invalid'.
		 * Deallocate the fp state if it exists.
		 */</span>
		simple_lock(&amp;pcb-&gt;lock);

		ifps = pcb-&gt;ifps;
		pcb-&gt;ifps = 0;

		simple_unlock(&amp;pcb-&gt;lock);

		<span class="enscript-keyword">if</span> (ifps != 0) {
			fp_state_free(ifps);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Valid incoming state. Allocate the fp state if there is none.
		 */</span>
		new_ifps = 0;
		<span class="enscript-reference">Retry</span>:
		simple_lock(&amp;pcb-&gt;lock);

		ifps = pcb-&gt;ifps;
		<span class="enscript-keyword">if</span> (ifps == 0) {
			<span class="enscript-keyword">if</span> (new_ifps == 0) {
				simple_unlock(&amp;pcb-&gt;lock);
				new_ifps = fp_state_alloc();
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Retry</span>;
			}
			ifps = new_ifps;
			new_ifps = 0;
			pcb-&gt;ifps = ifps;
			fresh_state = TRUE;
		}

		<span class="enscript-comment">/*
		 * now copy over the new data.
		 */</span>

		old_valid = ifps-&gt;fp_valid;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
		<span class="enscript-keyword">if</span> ((fresh_state == FALSE) &amp;&amp; (old_valid == FALSE) &amp;&amp; (thr_act != current_thread())) {
			panic(<span class="enscript-string">&quot;fpu_set_fxstate inconsistency, thread: %p not stopped&quot;</span>, thr_act);
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * Clear any reserved bits in the MXCSR to prevent a GPF
		 * when issuing an FXRSTOR.
		 */</span>

		state-&gt;fpu_mxcsr &amp;= mxcsr_capability_mask;

		bcopy((<span class="enscript-type">char</span> *)&amp;state-&gt;fpu_fcw, (<span class="enscript-type">char</span> *)ifps, state_size);

		<span class="enscript-keyword">if</span> (fpu_YMM_present) {
			<span class="enscript-type">struct</span> x86_avx_thread_state *iavx = (<span class="enscript-type">void</span> *) ifps;
			uint32_t fpu_nyreg = 0;

			<span class="enscript-keyword">if</span> (f == x86_AVX_STATE32)
				fpu_nyreg = 8;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (f == x86_AVX_STATE64)
				fpu_nyreg = 16;

			<span class="enscript-keyword">if</span> (fpu_nyreg) {
				x86_avx_state64_t *ystate = (x86_avx_state64_t *) state;
				bcopy(&amp;ystate-&gt;__fpu_ymmh0, &amp;iavx-&gt;x_YMMH_reg[0][0], fpu_nyreg * <span class="enscript-keyword">sizeof</span>(_STRUCT_XMM_REG));
			}

			iavx-&gt;fp_save_layout = thread_is_64bit(thr_act) ? XSAVE64 : XSAVE32;
			<span class="enscript-comment">/* Sanitize XSAVE header */</span>
			bzero(&amp;iavx-&gt;_xh.xhrsvd[0], <span class="enscript-keyword">sizeof</span>(iavx-&gt;_xh.xhrsvd));
			<span class="enscript-keyword">if</span> (fpu_nyreg)
				iavx-&gt;_xh.xsbv = (XFEM_YMM | XFEM_SSE | XFEM_X87);
			<span class="enscript-keyword">else</span>
				iavx-&gt;_xh.xsbv = (XFEM_SSE | XFEM_X87);
		} <span class="enscript-keyword">else</span> {
			ifps-&gt;fp_save_layout = thread_is_64bit(thr_act) ? FXSAVE64 : FXSAVE32;
		}
		ifps-&gt;fp_valid = old_valid;

		<span class="enscript-keyword">if</span> (old_valid == FALSE) {
			boolean_t istate = ml_set_interrupts_enabled(FALSE);
			ifps-&gt;fp_valid = TRUE;
			<span class="enscript-comment">/* If altering the current thread's state, disable FPU */</span>
			<span class="enscript-keyword">if</span> (thr_act == current_thread())
				set_ts();

			ml_set_interrupts_enabled(istate);
		}

		simple_unlock(&amp;pcb-&gt;lock);

		<span class="enscript-keyword">if</span> (new_ifps != 0)
			fp_state_free(new_ifps);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Get the floating-point state for a thread.
 * If the thread is not the current thread, it is
 * not running (held).  Locking needed against
 * concurrent fpu_set_state or fpu_get_state.
 */</span>
kern_return_t
<span class="enscript-function-name">fpu_get_fxstate</span>(
	thread_t	thr_act,
	thread_state_t	tstate,
	thread_flavor_t f)
{
	<span class="enscript-type">struct</span> x86_fx_thread_state	*ifps;
	x86_float_state64_t	*state;
	kern_return_t	ret = KERN_FAILURE;
	pcb_t	pcb;
	size_t	state_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_fx_thread_state);

	<span class="enscript-keyword">if</span> (fp_kind == FP_NO)
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	<span class="enscript-keyword">if</span> ((f == x86_AVX_STATE32 || f == x86_AVX_STATE64) &amp;&amp;
	    !ml_fpu_avx_enabled())
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	state = (x86_float_state64_t *)tstate;

	assert(thr_act != THREAD_NULL);
	pcb = THREAD_TO_PCB(thr_act);

	simple_lock(&amp;pcb-&gt;lock);

	ifps = pcb-&gt;ifps;
	<span class="enscript-keyword">if</span> (ifps == 0) {
		<span class="enscript-comment">/*
		 * No valid floating-point state.
		 */</span>

		bcopy((<span class="enscript-type">char</span> *)&amp;initial_fp_state, (<span class="enscript-type">char</span> *)&amp;state-&gt;fpu_fcw,
		    state_size);

		simple_unlock(&amp;pcb-&gt;lock);

		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	<span class="enscript-comment">/*
	 * Make sure we`ve got the latest fp state info
	 * If the live fpu state belongs to our target
	 */</span>
	<span class="enscript-keyword">if</span> (thr_act == current_thread()) {
		boolean_t	intr;

		intr = ml_set_interrupts_enabled(FALSE);

		clear_ts();
		fp_save(thr_act);
		clear_fpu();

		(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(intr);
	}
	<span class="enscript-keyword">if</span> (ifps-&gt;fp_valid) {
        	bcopy((<span class="enscript-type">char</span> *)ifps, (<span class="enscript-type">char</span> *)&amp;state-&gt;fpu_fcw, state_size);
		<span class="enscript-keyword">if</span> (fpu_YMM_present) {
			<span class="enscript-type">struct</span> x86_avx_thread_state *iavx = (<span class="enscript-type">void</span> *) ifps;
			uint32_t fpu_nyreg = 0;

			<span class="enscript-keyword">if</span> (f == x86_AVX_STATE32)
				fpu_nyreg = 8;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (f == x86_AVX_STATE64)
				fpu_nyreg = 16;

			<span class="enscript-keyword">if</span> (fpu_nyreg) {
				x86_avx_state64_t *ystate = (x86_avx_state64_t *) state;
				bcopy(&amp;iavx-&gt;x_YMMH_reg[0][0], &amp;ystate-&gt;__fpu_ymmh0, fpu_nyreg * <span class="enscript-keyword">sizeof</span>(_STRUCT_XMM_REG));
			}
		}

		ret = KERN_SUCCESS;
	}
	simple_unlock(&amp;pcb-&gt;lock);

	<span class="enscript-keyword">return</span> ret;
}



<span class="enscript-comment">/*
 * the child thread is 'stopped' with the thread
 * mutex held and is currently not known by anyone
 * so no way for fpu state to get manipulated by an
 * outside agency -&gt; no need for pcb lock
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpu_dup_fxstate</span>(
	thread_t	parent,
	thread_t	child)
{
	<span class="enscript-type">struct</span> x86_fx_thread_state *new_ifps = NULL;
	boolean_t	intr;
	pcb_t		ppcb;

	ppcb = THREAD_TO_PCB(parent);

	<span class="enscript-keyword">if</span> (ppcb-&gt;ifps == NULL)
	        <span class="enscript-keyword">return</span>;

        <span class="enscript-keyword">if</span> (child-&gt;machine.ifps)
	        panic(<span class="enscript-string">&quot;fpu_dup_fxstate: child's ifps non-null&quot;</span>);

	new_ifps = fp_state_alloc();

	simple_lock(&amp;ppcb-&gt;lock);

	<span class="enscript-keyword">if</span> (ppcb-&gt;ifps != NULL) {
		<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = ppcb-&gt;ifps;
	        <span class="enscript-comment">/*
		 * Make sure we`ve got the latest fp state info
		 */</span>
	        intr = ml_set_interrupts_enabled(FALSE);
		assert(current_thread() == parent);
		clear_ts();
		fp_save(parent);
		clear_fpu();

		(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(intr);

		<span class="enscript-keyword">if</span> (ifps-&gt;fp_valid) {
			child-&gt;machine.ifps = new_ifps;
			assert((fp_register_state_size == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_fx_thread_state)) ||
			    (fp_register_state_size == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> x86_avx_thread_state)));
			bcopy((<span class="enscript-type">char</span> *)(ppcb-&gt;ifps),
			    (<span class="enscript-type">char</span> *)(child-&gt;machine.ifps), fp_register_state_size);

			<span class="enscript-comment">/* Mark the new fp saved state as non-live. */</span>
			<span class="enscript-comment">/* Temporarily disabled: radar 4647827
			 * new_ifps-&gt;fp_valid = TRUE;
			 */</span>

			<span class="enscript-comment">/*
			 * Clear any reserved bits in the MXCSR to prevent a GPF
			 * when issuing an FXRSTOR.
			 */</span>
			new_ifps-&gt;fx_MXCSR &amp;= mxcsr_capability_mask;
			new_ifps = NULL;
		}
	}
	simple_unlock(&amp;ppcb-&gt;lock);

	<span class="enscript-keyword">if</span> (new_ifps != NULL)
	        fp_state_free(new_ifps);
}


<span class="enscript-comment">/*
 * Initialize FPU.
 *
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>	control;

	clear_ts();
	fninit();
	fnstcw(&amp;control);
	control &amp;= ~(FPC_PC|FPC_RC); <span class="enscript-comment">/* Clear precision &amp; rounding control */</span>
	control |= (FPC_PC_64 |		<span class="enscript-comment">/* Set precision */</span> 
			FPC_RC_RN | 	<span class="enscript-comment">/* round-to-nearest */</span>
			FPC_ZE |	<span class="enscript-comment">/* Suppress zero-divide */</span>
			FPC_OE |	<span class="enscript-comment">/*  and overflow */</span>
			FPC_UE |	<span class="enscript-comment">/*  underflow */</span>
			FPC_IE |	<span class="enscript-comment">/* Allow NaNQs and +-INF */</span>
			FPC_DE |	<span class="enscript-comment">/* Allow denorms as operands  */</span>
			FPC_PE);	<span class="enscript-comment">/* No trap for precision loss */</span>
	fldcw(control);

	<span class="enscript-comment">/* Initialize SSE/SSE2 */</span>
	__builtin_ia32_ldmxcsr(0x1f80);
}

<span class="enscript-comment">/*
 * Coprocessor not present.
 */</span>

uint64_t x86_isr_fp_simd_use;

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpnoextflt</span>(<span class="enscript-type">void</span>)
{
	boolean_t	intr;
	thread_t	thr_act;
	pcb_t		pcb;
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = 0;

	thr_act = current_thread();
	pcb = THREAD_TO_PCB(thr_act);

	assert(fp_register_state_size != 0);

	<span class="enscript-keyword">if</span> (pcb-&gt;ifps == 0 &amp;&amp; !get_interrupt_level()) {
	        ifps = fp_state_alloc();
		bcopy((<span class="enscript-type">char</span> *)&amp;initial_fp_state, (<span class="enscript-type">char</span> *)ifps,
		    fp_register_state_size);
		<span class="enscript-keyword">if</span> (!thread_is_64bit(thr_act)) {
			ifps-&gt;fp_save_layout = fpu_YMM_present ? XSAVE32 : FXSAVE32;
		}
		<span class="enscript-keyword">else</span>
			ifps-&gt;fp_save_layout = fpu_YMM_present ? XSAVE64 : FXSAVE64;
		ifps-&gt;fp_valid = TRUE;
	}
	intr = ml_set_interrupts_enabled(FALSE);

	clear_ts();			<span class="enscript-comment">/*  Enable FPU use */</span>

	<span class="enscript-keyword">if</span> (__improbable(get_interrupt_level())) {
		<span class="enscript-comment">/* Track number of #DNA traps at interrupt context,
		 * which is likely suboptimal. Racy, but good enough.
		 */</span>
		x86_isr_fp_simd_use++;
		<span class="enscript-comment">/*
		 * Save current FP/SIMD context if valid
		 * Initialize live FP/SIMD registers
		 */</span>
		<span class="enscript-keyword">if</span> (pcb-&gt;ifps) {
			fp_save(thr_act);
		}
		fpinit();
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (pcb-&gt;ifps == 0) {
		        pcb-&gt;ifps = ifps;
			ifps = 0;
		}
		<span class="enscript-comment">/*
		 * Load this thread`s state into coprocessor live context.
		 */</span>
		fp_load(thr_act);
	}
	(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(intr);

	<span class="enscript-keyword">if</span> (ifps)
	        fp_state_free(ifps);
}

<span class="enscript-comment">/*
 * FPU overran end of segment.
 * Re-initialize FPU.  Floating point state is not valid.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpextovrflt</span>(<span class="enscript-type">void</span>)
{
	thread_t	thr_act = current_thread();
	pcb_t		pcb;
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps;
	boolean_t	intr;

	intr = ml_set_interrupts_enabled(FALSE);

	<span class="enscript-keyword">if</span> (get_interrupt_level())
		panic(<span class="enscript-string">&quot;FPU segment overrun exception  at interrupt context\n&quot;</span>);
	<span class="enscript-keyword">if</span> (current_task() == kernel_task)
		panic(<span class="enscript-string">&quot;FPU segment overrun exception in kernel thread context\n&quot;</span>);

	<span class="enscript-comment">/*
	 * This is a non-recoverable error.
	 * Invalidate the thread`s FPU state.
	 */</span>
	pcb = THREAD_TO_PCB(thr_act);
	simple_lock(&amp;pcb-&gt;lock);
	ifps = pcb-&gt;ifps;
	pcb-&gt;ifps = 0;
	simple_unlock(&amp;pcb-&gt;lock);

	<span class="enscript-comment">/*
	 * Re-initialize the FPU.
	 */</span>
	clear_ts();
	fninit();

	<span class="enscript-comment">/*
	 * And disable access.
	 */</span>
	clear_fpu();

	(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(intr);

	<span class="enscript-keyword">if</span> (ifps)
	    zfree(ifps_zone, ifps);

	<span class="enscript-comment">/*
	 * Raise exception.
	 */</span>
	i386_exception(EXC_BAD_ACCESS, VM_PROT_READ|VM_PROT_EXECUTE, 0);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/*
 * FPU error. Called by AST.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpexterrflt</span>(<span class="enscript-type">void</span>)
{
	thread_t	thr_act = current_thread();
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = thr_act-&gt;machine.ifps;
	boolean_t	intr;

	intr = ml_set_interrupts_enabled(FALSE);

	<span class="enscript-keyword">if</span> (get_interrupt_level())
		panic(<span class="enscript-string">&quot;FPU error exception at interrupt context\n&quot;</span>);
	<span class="enscript-keyword">if</span> (current_task() == kernel_task)
		panic(<span class="enscript-string">&quot;FPU error exception in kernel thread context\n&quot;</span>);

	<span class="enscript-comment">/*
	 * Save the FPU state and turn off the FPU.
	 */</span>
	fp_save(thr_act);

	(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(intr);

	<span class="enscript-comment">/*
	 * Raise FPU exception.
	 * Locking not needed on pcb-&gt;ifps,
	 * since thread is running.
	 */</span>
	i386_exception(EXC_ARITHMETIC,
		       EXC_I386_EXTERR,
		       ifps-&gt;fx_status);

	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/*
 * Save FPU state.
 *
 * Locking not needed:
 * .	if called from fpu_get_state, pcb already locked.
 * .	if called from fpnoextflt or fp_intr, we are single-cpu
 * .	otherwise, thread is running.
 * N.B.: Must be called with interrupts disabled
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fp_save</span>(
	thread_t	thr_act)
{
	pcb_t pcb = THREAD_TO_PCB(thr_act);
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = pcb-&gt;ifps;

	assert(ifps != 0);
	<span class="enscript-keyword">if</span> (ifps != 0 &amp;&amp; !ifps-&gt;fp_valid) {
		assert((get_cr0() &amp; CR0_TS) == 0);
		<span class="enscript-comment">/* registers are in FPU */</span>
		ifps-&gt;fp_valid = TRUE;
		fpu_store_registers(ifps, thread_is_64bit(thr_act));
	}
}

<span class="enscript-comment">/*
 * Restore FPU state from PCB.
 *
 * Locking not needed; always called on the current thread.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fp_load</span>(
	thread_t	thr_act)
{
	pcb_t pcb = THREAD_TO_PCB(thr_act);
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = pcb-&gt;ifps;

	assert(ifps);
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (ifps-&gt;fp_valid != FALSE &amp;&amp; ifps-&gt;fp_valid != TRUE) {
		panic(<span class="enscript-string">&quot;fp_load() invalid fp_valid: %u, fp_save_layout: %u\n&quot;</span>,
		      ifps-&gt;fp_valid, ifps-&gt;fp_save_layout);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (ifps-&gt;fp_valid == FALSE) {
		fpinit();
	} <span class="enscript-keyword">else</span> {
		fpu_load_registers(ifps);
	}
	ifps-&gt;fp_valid = FALSE;		<span class="enscript-comment">/* in FPU */</span>
}

<span class="enscript-comment">/*
 * SSE arithmetic exception handling code.
 * Basically the same as the x87 exception handler with a different subtype
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fpSSEexterrflt</span>(<span class="enscript-type">void</span>)
{
	thread_t	thr_act = current_thread();
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = thr_act-&gt;machine.ifps;
	boolean_t	intr;

	intr = ml_set_interrupts_enabled(FALSE);

	<span class="enscript-keyword">if</span> (get_interrupt_level())
		panic(<span class="enscript-string">&quot;SSE exception at interrupt context\n&quot;</span>);
	<span class="enscript-keyword">if</span> (current_task() == kernel_task)
		panic(<span class="enscript-string">&quot;SSE exception in kernel thread context\n&quot;</span>);

	<span class="enscript-comment">/*
	 * Save the FPU state and turn off the FPU.
	 */</span>
	fp_save(thr_act);

	(<span class="enscript-type">void</span>)ml_set_interrupts_enabled(intr);
	<span class="enscript-comment">/*
	 * Raise FPU exception.
	 * Locking not needed on pcb-&gt;ifps,
	 * since thread is running.
	 */</span>

	i386_exception(EXC_ARITHMETIC,
		       EXC_I386_SSEEXTERR,
		       ifps-&gt;fx_MXCSR);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">fp_setvalid</span>(boolean_t value) {
        thread_t	thr_act = current_thread();
	<span class="enscript-type">struct</span> x86_fx_thread_state *ifps = thr_act-&gt;machine.ifps;

	<span class="enscript-keyword">if</span> (ifps) {
	        ifps-&gt;fp_valid = value;

		<span class="enscript-keyword">if</span> (value == TRUE) {
			boolean_t istate = ml_set_interrupts_enabled(FALSE);
		        clear_fpu();
			ml_set_interrupts_enabled(istate);
		}
	}
}

boolean_t
<span class="enscript-function-name">ml_fpu_avx_enabled</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> (fpu_YMM_present == TRUE);
}
</pre>
<hr />
</body></html>