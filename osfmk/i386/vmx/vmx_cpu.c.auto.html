<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vmx_cpu.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vmx_cpu.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx/vmx_asm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx/vmx_shims.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/vmx/vmx_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host.h&gt;</span>             <span class="enscript-comment">/* for host_info() */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VMX_KPRINTF</span>(x...) <span class="enscript-comment">/* kprintf(&quot;vmx: &quot; x) */</span>

<span class="enscript-type">int</span> vmx_use_count = 0;
boolean_t vmx_exclusive = FALSE;

lck_grp_t *vmx_lck_grp = NULL;
lck_mtx_t *vmx_lck_mtx = NULL;

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_is_available()
	Is the VMX facility available on this CPU?
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">vmx_is_available</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (0 != (cpuid_features() &amp; CPUID_FEATURE_VMX));
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmxon_is_enabled()
	Is the VMXON instruction enabled on this CPU?
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">vmxon_is_enabled</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (vmx_is_available() &amp;&amp;
		(rdmsr64(MSR_IA32_FEATURE_CONTROL) &amp; MSR_IA32_FEATCTL_VMXON));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_is_cr0_valid()
	Is CR0 valid for executing VMXON on this CPU?
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">vmx_is_cr0_valid</span>(vmx_specs_t *specs)
{
	uintptr_t cr0 = get_cr0();
	<span class="enscript-keyword">return</span> (0 == ((~cr0 &amp; specs-&gt;cr0_fixed_0)|(cr0 &amp; ~specs-&gt;cr0_fixed_1)));
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_is_cr4_valid()
	Is CR4 valid for executing VMXON on this CPU?
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">vmx_is_cr4_valid</span>(vmx_specs_t *specs)
{
	uintptr_t cr4 = get_cr4();
	<span class="enscript-keyword">return</span> (0 == ((~cr4 &amp; specs-&gt;cr4_fixed_0)|(cr4 &amp; ~specs-&gt;cr4_fixed_1)));
}

#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_enable</span>(<span class="enscript-type">void</span>)
{
	uint64_t msr_image;

	<span class="enscript-keyword">if</span> (!vmx_is_available())
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * We don't count on EFI initializing MSR_IA32_FEATURE_CONTROL
	 * and turning VMXON on and locking the bit, so we do that now.
	 */</span>
	msr_image = rdmsr64(MSR_IA32_FEATURE_CONTROL);
	<span class="enscript-keyword">if</span> (0 == ((msr_image &amp; MSR_IA32_FEATCTL_LOCK)))
		wrmsr64(MSR_IA32_FEATURE_CONTROL,
			(msr_image |
			 MSR_IA32_FEATCTL_VMXON |
			 MSR_IA32_FEATCTL_LOCK));

	set_cr4(get_cr4() | CR4_VMXE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_init</span>()
{
	vmx_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;vmx&quot;</span>, LCK_GRP_ATTR_NULL);
	assert(vmx_lck_grp);

	vmx_lck_mtx = lck_mtx_alloc_init(vmx_lck_grp, LCK_ATTR_NULL);
	assert(vmx_lck_mtx);
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_get_specs()
	Obtain VMX facility specifications for this CPU and
	enter them into the vmx_specs_t structure. If VMX is not available or
	disabled on this CPU, set vmx_present to false and return leaving
	the remainder of the vmx_specs_t uninitialized. 
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_cpu_init</span>()
{
	vmx_specs_t *specs = &amp;current_cpu_datap()-&gt;cpu_vmx.specs;

	vmx_enable();

	<span class="enscript-comment">/* if we have read the data on boot, we won't read it again on wakeup */</span>
	<span class="enscript-keyword">if</span> (specs-&gt;initialized)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">else</span>
		specs-&gt;initialized = TRUE;

	<span class="enscript-comment">/* See if VMX is present, return if it is not */</span>
	specs-&gt;vmx_present = vmx_is_available() &amp;&amp; vmxon_is_enabled();
	<span class="enscript-keyword">if</span> (!specs-&gt;vmx_present)
		<span class="enscript-keyword">return</span>;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">rdmsr_mask</span>(msr, mask) (uint32_t)(rdmsr64(msr) &amp; (mask))
	specs-&gt;vmcs_id = rdmsr_mask(MSR_IA32_VMX_BASIC, VMX_VCR_VMCS_REV_ID);

	<span class="enscript-comment">/* Obtain VMX-fixed bits in CR0 */</span>
	specs-&gt;cr0_fixed_0 = rdmsr_mask(MSR_IA32_VMX_CR0_FIXED0, 0xFFFFFFFF);
	specs-&gt;cr0_fixed_1 = rdmsr_mask(MSR_IA32_VMX_CR0_FIXED1, 0xFFFFFFFF);
	
	<span class="enscript-comment">/* Obtain VMX-fixed bits in CR4 */</span>
	specs-&gt;cr4_fixed_0 = rdmsr_mask(MSR_IA32_VMX_CR4_FIXED0, 0xFFFFFFFF);
	specs-&gt;cr4_fixed_1 = rdmsr_mask(MSR_IA32_VMX_CR4_FIXED1, 0xFFFFFFFF);
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_on()
	Enter VMX root operation on this CPU.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_on</span>(<span class="enscript-type">void</span> *arg __unused)
{
	vmx_cpu_t *cpu = &amp;current_cpu_datap()-&gt;cpu_vmx;
	addr64_t vmxon_region_paddr;
	<span class="enscript-type">int</span> result;

	assert(cpu-&gt;specs.vmx_present);

	<span class="enscript-keyword">if</span> (NULL == cpu-&gt;vmxon_region)
		panic(<span class="enscript-string">&quot;vmx_on: VMXON region not allocated&quot;</span>);
	vmxon_region_paddr = vmx_paddr(cpu-&gt;vmxon_region);

	<span class="enscript-comment">/*
	 * Enable VMX operation.
	 */</span>
	<span class="enscript-keyword">if</span> (FALSE == cpu-&gt;specs.vmx_on) {
		assert(vmx_is_cr0_valid(&amp;cpu-&gt;specs));
		assert(vmx_is_cr4_valid(&amp;cpu-&gt;specs));
	
		result = __vmxon(vmxon_region_paddr);

		<span class="enscript-keyword">if</span> (result != VMX_SUCCEED) {
			panic(<span class="enscript-string">&quot;vmx_on: unexpected return %d from __vmxon()&quot;</span>, result);
		}

		cpu-&gt;specs.vmx_on = TRUE;
	}
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_off()
	Leave VMX root operation on this CPU.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_off</span>(<span class="enscript-type">void</span> *arg __unused)
{
	vmx_cpu_t *cpu = &amp;current_cpu_datap()-&gt;cpu_vmx;
	<span class="enscript-type">int</span> result;
	
	<span class="enscript-keyword">if</span> (TRUE == cpu-&gt;specs.vmx_on) {
		<span class="enscript-comment">/* Tell the CPU to release the VMXON region */</span>
		result = __vmxoff();

		<span class="enscript-keyword">if</span> (result != VMX_SUCCEED) {
			panic(<span class="enscript-string">&quot;vmx_off: unexpected return %d from __vmxoff()&quot;</span>, result);
		}
	
		cpu-&gt;specs.vmx_on = FALSE;
	}
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_allocate_vmxon_regions()
	Allocate, clear and init VMXON regions for all CPUs.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_allocate_vmxon_regions</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">for</span> (i=0; i&lt;real_ncpus; i++) {
		vmx_cpu_t *cpu = &amp;cpu_datap(i)-&gt;cpu_vmx;

		<span class="enscript-comment">/* The size is defined to be always &lt;= 4K, so we just allocate a page */</span>
		cpu-&gt;vmxon_region = vmx_pcalloc();
		<span class="enscript-keyword">if</span> (NULL == cpu-&gt;vmxon_region)
			panic(<span class="enscript-string">&quot;vmx_allocate_vmxon_regions: unable to allocate VMXON region&quot;</span>);
		*(uint32_t*)(cpu-&gt;vmxon_region) = cpu-&gt;specs.vmcs_id;
	}
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_free_vmxon_regions()
	Free VMXON regions for all CPUs.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_free_vmxon_regions</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i=0; i&lt;real_ncpus; i++) {
		vmx_cpu_t *cpu = &amp;cpu_datap(i)-&gt;cpu_vmx;

		vmx_pfree(cpu-&gt;vmxon_region);
		cpu-&gt;vmxon_region = NULL;
	}
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_globally_available()
	Checks whether VT can be turned on for all CPUs.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">vmx_globally_available</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ncpus = ml_get_max_cpus();
	boolean_t available = TRUE;

	<span class="enscript-keyword">for</span> (i=0; i&lt;ncpus; i++) {
		vmx_cpu_t *cpu = &amp;cpu_datap(i)-&gt;cpu_vmx;

		<span class="enscript-keyword">if</span> (!cpu-&gt;specs.vmx_present)
			available = FALSE;
	}
	VMX_KPRINTF(<span class="enscript-string">&quot;VMX available: %d\n&quot;</span>, available);
	<span class="enscript-keyword">return</span> available;
}


<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_turn_on()
	Turn on VT operation on all CPUs.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">host_vmxon</span>(boolean_t exclusive)
{
	<span class="enscript-type">int</span> error;

	assert(0 == get_preemption_level());

	<span class="enscript-keyword">if</span> (!vmx_globally_available())
		<span class="enscript-keyword">return</span> VMX_UNSUPPORTED;

	lck_mtx_lock(vmx_lck_mtx);

	<span class="enscript-keyword">if</span> (vmx_exclusive || (exclusive &amp;&amp; vmx_use_count)) {
		error = VMX_INUSE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (0 == vmx_use_count) {
			vmx_allocate_vmxon_regions();
			vmx_exclusive = exclusive;
			vmx_use_count = 1;
			mp_cpus_call(CPUMASK_ALL, ASYNC, vmx_on, NULL);

		} <span class="enscript-keyword">else</span> {
			vmx_use_count++;
		}

		VMX_KPRINTF(<span class="enscript-string">&quot;VMX use count: %d\n&quot;</span>, vmx_use_count);
		error = VMX_OK;
	}

	lck_mtx_unlock(vmx_lck_mtx);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_turn_off()
	Turn off VT operation on all CPUs.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">host_vmxoff</span>()
{
	assert(0 == get_preemption_level());

	lck_mtx_lock(vmx_lck_mtx);

	<span class="enscript-keyword">if</span> (1 == vmx_use_count) {
		vmx_exclusive = FALSE;
		vmx_use_count = 0;
		mp_cpus_call(CPUMASK_ALL, ASYNC, vmx_off, NULL);
		vmx_free_vmxon_regions();
	} <span class="enscript-keyword">else</span> {
		vmx_use_count--;
	}

	lck_mtx_unlock(vmx_lck_mtx);

	VMX_KPRINTF(<span class="enscript-string">&quot;VMX use count: %d\n&quot;</span>, vmx_use_count);
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_suspend()
	Turn off VT operation on this CPU if it was on.
	Called when a CPU goes offline.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_suspend</span>()
{
	VMX_KPRINTF(<span class="enscript-string">&quot;vmx_suspend\n&quot;</span>);

	<span class="enscript-keyword">if</span> (vmx_use_count)
		vmx_off(NULL);
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_suspend()
	Restore the previous VT state. Called when CPU comes back online.
   -------------------------------------------------------------------------- */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vmx_resume</span>()
{
	VMX_KPRINTF(<span class="enscript-string">&quot;vmx_resume\n&quot;</span>);

	vmx_enable();

	<span class="enscript-keyword">if</span> (vmx_use_count)
		vmx_on(NULL);
}

<span class="enscript-comment">/* -----------------------------------------------------------------------------
   vmx_hv_support()
	Determine if the VMX feature set is sufficent for kernel HV support.
   -------------------------------------------------------------------------- */</span>
boolean_t
<span class="enscript-function-name">vmx_hv_support</span>()
{
	<span class="enscript-keyword">if</span> (!vmx_is_available())
		<span class="enscript-keyword">return</span> FALSE;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHK</span>(msr, shift, mask) if (!VMX_CAP(msr, shift, mask)) return FALSE;

	<span class="enscript-comment">/* 'EPT' and 'Unrestricted Mode' are part of the secondary processor-based
	 * VM-execution controls */</span>
	CHK(MSR_IA32_VMX_BASIC, 0, VMX_BASIC_TRUE_CTLS)
	CHK(MSR_IA32_VMX_TRUE_PROCBASED_CTLS, 32, VMX_TRUE_PROCBASED_SECONDARY_CTLS)

	<span class="enscript-comment">/* if we have these, check for 'EPT' and 'Unrestricted Mode' */</span>
	CHK(MSR_IA32_VMX_PROCBASED_CTLS2, 32, VMX_PROCBASED_CTLS2_EPT)
	CHK(MSR_IA32_VMX_PROCBASED_CTLS2, 32, VMX_PROCBASED_CTLS2_UNRESTRICTED)

	<span class="enscript-keyword">return</span> TRUE;
}
</pre>
<hr />
</body></html>