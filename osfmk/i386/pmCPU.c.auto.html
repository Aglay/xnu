<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pmCPU.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pmCPU.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * CPU-specific power management support.
 *
 * Implements the &quot;wrappers&quot; to the KEXT.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/asm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_cpu.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/proc_reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/pms.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_threads.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/rtclock_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/lapic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/tsc.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> disableConsoleOutput;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DELAY_UNSET</span>		0xFFFFFFFFFFFFFFFFULL

uint64_t cpu_itime_bins[CPU_ITIME_BINS] = {16* NSEC_PER_USEC, 32* NSEC_PER_USEC, 64* NSEC_PER_USEC, 128* NSEC_PER_USEC, 256* NSEC_PER_USEC, 512* NSEC_PER_USEC, 1024* NSEC_PER_USEC, 2048* NSEC_PER_USEC, 4096* NSEC_PER_USEC, 8192* NSEC_PER_USEC, 16384* NSEC_PER_USEC, 32768* NSEC_PER_USEC};
uint64_t *cpu_rtime_bins = &amp;cpu_itime_bins[0];

<span class="enscript-comment">/*
 * The following is set when the KEXT loads and initializes.
 */</span>
pmDispatch_t	*pmDispatch	= NULL;

uint32_t		pmInitDone		= 0;
<span class="enscript-type">static</span> boolean_t	earlyTopology		= FALSE;
<span class="enscript-type">static</span> uint64_t		earlyMaxBusDelay	= DELAY_UNSET;
<span class="enscript-type">static</span> uint64_t		earlyMaxIntDelay	= DELAY_UNSET;

<span class="enscript-comment">/*
 * Initialize the Cstate change code.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">power_management_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL &amp;&amp; pmDispatch-&gt;cstateInit != NULL)
	(*pmDispatch-&gt;cstateInit)();
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">machine_classify_interval</span>(uint64_t interval, uint64_t *bins, uint64_t *binvals, uint32_t nbins) {
	uint32_t i;
 	<span class="enscript-keyword">for</span> (i = 0; i &lt; nbins; i++) {
 		<span class="enscript-keyword">if</span> (interval &lt; binvals[i]) {
 			bins[i]++;
 			<span class="enscript-keyword">break</span>;
 		}
 	}
}

uint64_t	idle_pending_timers_processed;
uint32_t	idle_entry_timer_processing_hdeadline_threshold = 5000000;

<span class="enscript-comment">/*
 * Called when the CPU is idle.  It calls into the power management kext
 * to determine the best way to idle the CPU.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_idle</span>(<span class="enscript-type">void</span>)
{
	cpu_data_t		*my_cpu		= current_cpu_datap();
	__unused uint32_t	cnum = my_cpu-&gt;cpu_number;
	uint64_t		ctime, rtime, itime;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CST_DEMOTION_DEBUG</span>
	processor_t		cproc = my_cpu-&gt;cpu_processor;
	uint64_t		cwakeups = PROCESSOR_DATA(cproc, wakeups_issued_total);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CST_DEMOTION_DEBUG */</span>
	uint64_t esdeadline, ehdeadline;
	boolean_t do_process_pending_timers = FALSE;

	ctime = mach_absolute_time();
	esdeadline = my_cpu-&gt;rtclock_timer.queue.earliest_soft_deadline;
	ehdeadline = my_cpu-&gt;rtclock_timer.deadline;
<span class="enscript-comment">/* Determine if pending timers exist */</span>    
	<span class="enscript-keyword">if</span> ((ctime &gt;= esdeadline) &amp;&amp; (ctime &lt; ehdeadline) &amp;&amp;
	    ((ehdeadline - ctime) &lt; idle_entry_timer_processing_hdeadline_threshold)) {
		idle_pending_timers_processed++;
		do_process_pending_timers = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">machine_idle_exit</span>;
	} <span class="enscript-keyword">else</span> {
		TCOAL_DEBUG(0xCCCC0000, ctime, my_cpu-&gt;rtclock_timer.queue.earliest_soft_deadline, my_cpu-&gt;rtclock_timer.deadline, idle_pending_timers_processed, 0);
	}
    
	my_cpu-&gt;lcpu.state = LCPU_IDLE;
	DBGLOG(cpu_handle, cpu_number(), MP_IDLE);
	MARK_CPU_IDLE(cnum);

	rtime = ctime - my_cpu-&gt;cpu_ixtime;

	my_cpu-&gt;cpu_rtime_total += rtime;
	machine_classify_interval(rtime, &amp;my_cpu-&gt;cpu_rtimes[0], &amp;cpu_rtime_bins[0], CPU_RTIME_BINS);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CST_DEMOTION_DEBUG</span>
	uint32_t cl = 0, ch = 0;
	uint64_t c3res, c6res, c7res;
	rdmsr_carefully(MSR_IA32_CORE_C3_RESIDENCY, &amp;cl, &amp;ch);
	c3res = ((uint64_t)ch &lt;&lt; 32) | cl;
	rdmsr_carefully(MSR_IA32_CORE_C6_RESIDENCY, &amp;cl, &amp;ch);
	c6res = ((uint64_t)ch &lt;&lt; 32) | cl;
	rdmsr_carefully(MSR_IA32_CORE_C7_RESIDENCY, &amp;cl, &amp;ch);
	c7res = ((uint64_t)ch &lt;&lt; 32) | cl;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (pmInitDone) {
		<span class="enscript-comment">/*
		 * Handle case where ml_set_maxbusdelay() or ml_set_maxintdelay()
		 * were called prior to the CPU PM kext being registered.  We do
		 * this here since we know at this point the values will be first
		 * used since idle is where the decisions using these values is made.
		 */</span>
		<span class="enscript-keyword">if</span> (earlyMaxBusDelay != DELAY_UNSET)
			ml_set_maxbusdelay((uint32_t)(earlyMaxBusDelay &amp; 0xFFFFFFFF));
		<span class="enscript-keyword">if</span> (earlyMaxIntDelay != DELAY_UNSET)
			ml_set_maxintdelay(earlyMaxIntDelay);
	}

	<span class="enscript-keyword">if</span> (pmInitDone
	    &amp;&amp; pmDispatch != NULL
	    &amp;&amp; pmDispatch-&gt;MachineIdle != NULL)
		(*pmDispatch-&gt;MachineIdle)(0x7FFFFFFFFFFFFFFFULL);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If no power management, re-enable interrupts and halt.
		 * This will keep the CPU from spinning through the scheduler
		 * and will allow at least some minimal power savings (but it
		 * cause problems in some MP configurations w.r.t. the APIC
		 * stopping during a GV3 transition).
		 */</span>
		pal_hlt();
		<span class="enscript-comment">/* Once woken, re-disable interrupts. */</span>
		pal_cli();
	}

	<span class="enscript-comment">/*
	 * Mark the CPU as running again.
	 */</span>
	MARK_CPU_ACTIVE(cnum);
	DBGLOG(cpu_handle, cnum, MP_UNIDLE);
	my_cpu-&gt;lcpu.state = LCPU_RUN;
	uint64_t ixtime = my_cpu-&gt;cpu_ixtime = mach_absolute_time();
	itime = ixtime - ctime;
	my_cpu-&gt;cpu_idle_exits++;
        my_cpu-&gt;cpu_itime_total += itime;
    	machine_classify_interval(itime, &amp;my_cpu-&gt;cpu_itimes[0], &amp;cpu_itime_bins[0], CPU_ITIME_BINS);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CST_DEMOTION_DEBUG</span>
	cl = ch = 0;
	rdmsr_carefully(MSR_IA32_CORE_C3_RESIDENCY, &amp;cl, &amp;ch);
	c3res = (((uint64_t)ch &lt;&lt; 32) | cl) - c3res;
	rdmsr_carefully(MSR_IA32_CORE_C6_RESIDENCY, &amp;cl, &amp;ch);
	c6res = (((uint64_t)ch &lt;&lt; 32) | cl) - c6res;
	rdmsr_carefully(MSR_IA32_CORE_C7_RESIDENCY, &amp;cl, &amp;ch);
	c7res = (((uint64_t)ch &lt;&lt; 32) | cl) - c7res;

	uint64_t ndelta = itime - tmrCvt(c3res + c6res + c7res, tscFCvtt2n);
	KERNEL_DEBUG_CONSTANT(0xcead0000, ndelta, itime, c7res, c6res, c3res);
	<span class="enscript-keyword">if</span> ((itime &gt; 1000000) &amp;&amp; (ndelta &gt; 250000))
		KERNEL_DEBUG_CONSTANT(0xceae0000, ndelta, itime, c7res, c6res, c3res);
#<span class="enscript-reference">endif</span>

	<span class="enscript-reference">machine_idle_exit</span>:
	<span class="enscript-comment">/*
	 * Re-enable interrupts.
	 */</span>

	pal_sti();

	<span class="enscript-keyword">if</span> (do_process_pending_timers) {
		TCOAL_DEBUG(0xBBBB0000 | DBG_FUNC_START, ctime, esdeadline, ehdeadline, idle_pending_timers_processed, 0);

		<span class="enscript-comment">/* Adjust to reflect that this isn't truly a package idle exit */</span>
		__sync_fetch_and_sub(&amp;my_cpu-&gt;lcpu.package-&gt;num_idle, 1);
		lapic_timer_swi(); <span class="enscript-comment">/* Trigger software timer interrupt */</span>
		__sync_fetch_and_add(&amp;my_cpu-&gt;lcpu.package-&gt;num_idle, 1);

		TCOAL_DEBUG(0xBBBB0000 | DBG_FUNC_END, ctime, esdeadline, idle_pending_timers_processed, 0, 0);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CST_DEMOTION_DEBUG</span>
	uint64_t nwakeups = PROCESSOR_DATA(cproc, wakeups_issued_total);

	<span class="enscript-keyword">if</span> ((nwakeups == cwakeups) &amp;&amp; (topoParms.nLThreadsPerPackage == my_cpu-&gt;lcpu.package-&gt;num_idle)) {
		KERNEL_DEBUG_CONSTANT(0xceaa0000, cwakeups, 0, 0, 0, 0);
	}
#<span class="enscript-reference">endif</span>    
}

<span class="enscript-comment">/*
 * Called when the CPU is to be halted.  It will choose the best C-State
 * to be in.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmCPUHalt</span>(uint32_t reason)
{
    cpu_data_t	*cpup	= current_cpu_datap();

    <span class="enscript-keyword">switch</span> (reason) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PM_HALT_DEBUG</span>:
	cpup-&gt;lcpu.state = LCPU_PAUSE;
	pal_stop_cpu(FALSE);
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">PM_HALT_PANIC</span>:
	cpup-&gt;lcpu.state = LCPU_PAUSE;
	pal_stop_cpu(TRUE);
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">PM_HALT_NORMAL</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PM_HALT_SLEEP</span>:
    <span class="enscript-reference">default</span>:
        pal_cli();

	<span class="enscript-keyword">if</span> (pmInitDone
	    &amp;&amp; pmDispatch != NULL
	    &amp;&amp; pmDispatch-&gt;pmCPUHalt != NULL) {
	    <span class="enscript-comment">/*
	     * Halt the CPU (and put it in a low power state.
	     */</span>
	    (*pmDispatch-&gt;pmCPUHalt)();

	    <span class="enscript-comment">/*
	     * We've exited halt, so get the CPU schedulable again.
	     * - by calling the fast init routine for a slave, or
	     * - by returning if we're the master processor.
	     */</span>
	    <span class="enscript-keyword">if</span> (cpup-&gt;cpu_number != master_cpu) {
		i386_init_slave_fast();
		panic(<span class="enscript-string">&quot;init_slave_fast returned&quot;</span>);
	    }
	} <span class="enscript-keyword">else</span>
	{
	    <span class="enscript-comment">/*
	     * If no power managment and a processor is taken off-line,
	     * then invalidate the cache and halt it (it will not be able
	     * to be brought back on-line without resetting the CPU).
	     */</span>
	    __asm__ <span class="enscript-type">volatile</span> (<span class="enscript-string">&quot;wbinvd&quot;</span>);
	    cpup-&gt;lcpu.state = LCPU_HALT;
	    pal_stop_cpu(FALSE);

	    panic(<span class="enscript-string">&quot;back from Halt&quot;</span>);
	}

	<span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pmMarkAllCPUsOff</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;markAllCPUsOff != NULL)
	(*pmDispatch-&gt;markAllCPUsOff)();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pmInitComplete</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (earlyTopology
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmCPUStateInit != NULL) {
	(*pmDispatch-&gt;pmCPUStateInit)();
	earlyTopology = FALSE;
    }
    pmInitDone = 1;
}

x86_lcpu_t *
<span class="enscript-function-name">pmGetLogicalCPU</span>(<span class="enscript-type">int</span> cpu)
{
    <span class="enscript-keyword">return</span>(cpu_to_lcpu(cpu));
}

x86_lcpu_t *
<span class="enscript-function-name">pmGetMyLogicalCPU</span>(<span class="enscript-type">void</span>)
{
    cpu_data_t	*cpup	= current_cpu_datap();

    <span class="enscript-keyword">return</span>(&amp;cpup-&gt;lcpu);
}

<span class="enscript-type">static</span> x86_core_t *
<span class="enscript-function-name">pmGetCore</span>(<span class="enscript-type">int</span> cpu)
{
    <span class="enscript-keyword">return</span>(cpu_to_core(cpu));
}

<span class="enscript-type">static</span> x86_core_t *
<span class="enscript-function-name">pmGetMyCore</span>(<span class="enscript-type">void</span>)
{
    cpu_data_t	*cpup	= current_cpu_datap();

    <span class="enscript-keyword">return</span>(cpup-&gt;lcpu.core);
}

<span class="enscript-type">static</span> x86_die_t *
<span class="enscript-function-name">pmGetDie</span>(<span class="enscript-type">int</span> cpu)
{
    <span class="enscript-keyword">return</span>(cpu_to_die(cpu));
}

<span class="enscript-type">static</span> x86_die_t *
<span class="enscript-function-name">pmGetMyDie</span>(<span class="enscript-type">void</span>)
{
    cpu_data_t	*cpup	= current_cpu_datap();

    <span class="enscript-keyword">return</span>(cpup-&gt;lcpu.die);
}

<span class="enscript-type">static</span> x86_pkg_t *
<span class="enscript-function-name">pmGetPackage</span>(<span class="enscript-type">int</span> cpu)
{
    <span class="enscript-keyword">return</span>(cpu_to_package(cpu));
}

<span class="enscript-type">static</span> x86_pkg_t *
<span class="enscript-function-name">pmGetMyPackage</span>(<span class="enscript-type">void</span>)
{
    cpu_data_t	*cpup	= current_cpu_datap();

    <span class="enscript-keyword">return</span>(cpup-&gt;lcpu.package);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pmLockCPUTopology</span>(<span class="enscript-type">int</span> lock)
{
    <span class="enscript-keyword">if</span> (lock) {
	simple_lock(&amp;x86_topo_lock);
    } <span class="enscript-keyword">else</span> {
	simple_unlock(&amp;x86_topo_lock);
    }
}

<span class="enscript-comment">/*
 * Called to get the next deadline that has been set by the
 * power management code.
 * Note: a return of 0 from AICPM and this routine signifies
 * that no deadline is set.
 */</span>
uint64_t
<span class="enscript-function-name">pmCPUGetDeadline</span>(cpu_data_t *cpu)
{
    uint64_t	deadline	= 0;

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;GetDeadline != NULL)
	deadline = (*pmDispatch-&gt;GetDeadline)(&amp;cpu-&gt;lcpu);

    <span class="enscript-keyword">return</span>(deadline);
}

<span class="enscript-comment">/*
 * Called to determine if the supplied deadline or the power management
 * deadline is sooner.  Returns which ever one is first.
 */</span>

uint64_t
<span class="enscript-function-name">pmCPUSetDeadline</span>(cpu_data_t *cpu, uint64_t deadline)
{
   <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;SetDeadline != NULL)
	deadline = (*pmDispatch-&gt;SetDeadline)(&amp;cpu-&gt;lcpu, deadline);

    <span class="enscript-keyword">return</span>(deadline);
}

<span class="enscript-comment">/*
 * Called when a power management deadline expires.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmCPUDeadline</span>(cpu_data_t *cpu)
{
    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;Deadline != NULL)
	(*pmDispatch-&gt;Deadline)(&amp;cpu-&gt;lcpu);
}

<span class="enscript-comment">/*
 * Called to get a CPU out of idle.
 */</span>
boolean_t
<span class="enscript-function-name">pmCPUExitIdle</span>(cpu_data_t *cpu)
{
    boolean_t		do_ipi;

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;exitIdle != NULL)
	do_ipi = (*pmDispatch-&gt;exitIdle)(&amp;cpu-&gt;lcpu);
    <span class="enscript-keyword">else</span>
	do_ipi = TRUE;

    <span class="enscript-keyword">return</span>(do_ipi);
}

kern_return_t
<span class="enscript-function-name">pmCPUExitHalt</span>(<span class="enscript-type">int</span> cpu)
{
    kern_return_t	rc	= KERN_INVALID_ARGUMENT;

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;exitHalt != NULL)
	rc = pmDispatch-&gt;exitHalt(cpu_to_lcpu(cpu));

    <span class="enscript-keyword">return</span>(rc);
}

kern_return_t
<span class="enscript-function-name">pmCPUExitHaltToOff</span>(<span class="enscript-type">int</span> cpu)
{
    kern_return_t	rc	= KERN_SUCCESS;

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;exitHaltToOff != NULL)
	rc = pmDispatch-&gt;exitHaltToOff(cpu_to_lcpu(cpu));

    <span class="enscript-keyword">return</span>(rc);
}

<span class="enscript-comment">/*
 * Called to initialize the power management structures for the CPUs.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmCPUStateInit</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL &amp;&amp; pmDispatch-&gt;pmCPUStateInit != NULL)
	(*pmDispatch-&gt;pmCPUStateInit)();
    <span class="enscript-keyword">else</span>
	earlyTopology = TRUE;
}

<span class="enscript-comment">/*
 * Called when a CPU is being restarted after being powered off (as in S3).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmCPUMarkRunning</span>(cpu_data_t *cpu)
{
    cpu_data_t	*cpup	= current_cpu_datap();

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;markCPURunning != NULL)
	(*pmDispatch-&gt;markCPURunning)(&amp;cpu-&gt;lcpu);
    <span class="enscript-keyword">else</span>
	cpup-&gt;lcpu.state = LCPU_RUN;
}

<span class="enscript-comment">/*
 * Called to get/set CPU power management state.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pmCPUControl</span>(uint32_t cmd, <span class="enscript-type">void</span> *datap)
{
    <span class="enscript-type">int</span>		rc	= -1;

    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmCPUControl != NULL)
	rc = (*pmDispatch-&gt;pmCPUControl)(cmd, datap);

    <span class="enscript-keyword">return</span>(rc);
}

<span class="enscript-comment">/*
 * Called to save the timer state used by power management prior
 * to &quot;sleeping&quot;.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmTimerSave</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmTimerStateSave != NULL)
	(*pmDispatch-&gt;pmTimerStateSave)();
}

<span class="enscript-comment">/*
 * Called to restore the timer state used by power management after
 * waking from &quot;sleep&quot;.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmTimerRestore</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmTimerStateRestore != NULL)
	(*pmDispatch-&gt;pmTimerStateRestore)();
}

<span class="enscript-comment">/*
 * Set the worst-case time for the C4 to C2 transition.
 * No longer does anything.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ml_set_maxsnoop</span>(__unused uint32_t maxdelay)
{
}


<span class="enscript-comment">/*
 * Get the worst-case time for the C4 to C2 transition.  Returns nanoseconds.
 */</span>
<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">ml_get_maxsnoop</span>(<span class="enscript-type">void</span>)
{
    uint64_t	max_snoop	= 0;

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;getMaxSnoop != NULL)
	max_snoop = pmDispatch-&gt;getMaxSnoop();

    <span class="enscript-keyword">return</span>((<span class="enscript-type">unsigned</span>)(max_snoop &amp; 0xffffffff));
}


uint32_t
<span class="enscript-function-name">ml_get_maxbusdelay</span>(<span class="enscript-type">void</span>)
{
    uint64_t	max_delay	= 0;

    <span class="enscript-keyword">if</span> (pmInitDone
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;getMaxBusDelay != NULL)
	max_delay = pmDispatch-&gt;getMaxBusDelay();

    <span class="enscript-keyword">return</span>((uint32_t)(max_delay &amp; 0xffffffff));
}

<span class="enscript-comment">/*
 * Advertise a memory access latency tolerance of &quot;mdelay&quot; ns
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ml_set_maxbusdelay</span>(uint32_t mdelay)
{
    uint64_t	maxdelay	= mdelay;

    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;setMaxBusDelay != NULL) {
	earlyMaxBusDelay = DELAY_UNSET;
	pmDispatch-&gt;setMaxBusDelay(maxdelay);
    } <span class="enscript-keyword">else</span>
	earlyMaxBusDelay = maxdelay;
}

uint64_t
<span class="enscript-function-name">ml_get_maxintdelay</span>(<span class="enscript-type">void</span>)
{
    uint64_t	max_delay	= 0;

    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;getMaxIntDelay != NULL)
	max_delay = pmDispatch-&gt;getMaxIntDelay();

    <span class="enscript-keyword">return</span>(max_delay);
}

<span class="enscript-comment">/*
 * Set the maximum delay allowed for an interrupt.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ml_set_maxintdelay</span>(uint64_t mdelay)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;setMaxIntDelay != NULL) {
	earlyMaxIntDelay = DELAY_UNSET;
	pmDispatch-&gt;setMaxIntDelay(mdelay);
    } <span class="enscript-keyword">else</span>
	earlyMaxIntDelay = mdelay;
}

boolean_t
<span class="enscript-function-name">ml_get_interrupt_prewake_applicable</span>()
{
    boolean_t applicable = FALSE;

    <span class="enscript-keyword">if</span> (pmInitDone 
	&amp;&amp; pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmInterruptPrewakeApplicable != NULL)
	applicable = pmDispatch-&gt;pmInterruptPrewakeApplicable();

    <span class="enscript-keyword">return</span> applicable;
}

<span class="enscript-comment">/*
 * Put a CPU into &quot;safe&quot; mode with respect to power.
 *
 * Some systems cannot operate at a continuous &quot;normal&quot; speed without
 * exceeding the thermal design.  This is called per-CPU to place the
 * CPUs into a &quot;safe&quot; operating mode.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmSafeMode</span>(x86_lcpu_t *lcpu, uint32_t flags)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmCPUSafeMode != NULL)
	pmDispatch-&gt;pmCPUSafeMode(lcpu, flags);
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/*
	 * Do something reasonable if the KEXT isn't present.
	 *
	 * We only look at the PAUSE and RESUME flags.  The other flag(s)
	 * will not make any sense without the KEXT, so just ignore them.
	 *
	 * We set the CPU's state to indicate that it's halted.  If this
	 * is the CPU we're currently running on, then spin until the
	 * state becomes non-halted.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; PM_SAFE_FL_PAUSE) {
	    lcpu-&gt;state = LCPU_PAUSE;
	    <span class="enscript-keyword">if</span> (lcpu == x86_lcpu()) {
		<span class="enscript-keyword">while</span> (lcpu-&gt;state == LCPU_PAUSE)
		    cpu_pause();
	    }
	}
	
	<span class="enscript-comment">/*
	 * Clear the halted flag for the specified CPU, that will
	 * get it out of it's spin loop.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; PM_SAFE_FL_RESUME) {
	    lcpu-&gt;state = LCPU_RUN;
	}
    }
}

<span class="enscript-type">static</span> uint32_t		saved_run_count = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_run_count</span>(uint32_t count)
{
    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmSetRunCount != NULL)
	pmDispatch-&gt;pmSetRunCount(count);
    <span class="enscript-keyword">else</span>
	saved_run_count = count;
}

processor_t
<span class="enscript-function-name">machine_choose_processor</span>(processor_set_t pset,
			 processor_t preferred)
{
    <span class="enscript-type">int</span>		startCPU;
    <span class="enscript-type">int</span>		endCPU;
    <span class="enscript-type">int</span>		preferredCPU;
    <span class="enscript-type">int</span>		chosenCPU;

    <span class="enscript-keyword">if</span> (!pmInitDone)
	<span class="enscript-keyword">return</span>(preferred);

    <span class="enscript-keyword">if</span> (pset == NULL) {
	startCPU = -1;
	endCPU = -1;
    } <span class="enscript-keyword">else</span> {
	startCPU = pset-&gt;cpu_set_low;
	endCPU = pset-&gt;cpu_set_hi;
    }

    <span class="enscript-keyword">if</span> (preferred == NULL)
	preferredCPU = -1;
    <span class="enscript-keyword">else</span>
	preferredCPU = preferred-&gt;cpu_id;

    <span class="enscript-keyword">if</span> (pmDispatch != NULL
	&amp;&amp; pmDispatch-&gt;pmChooseCPU != NULL) {
	chosenCPU = pmDispatch-&gt;pmChooseCPU(startCPU, endCPU, preferredCPU);

	<span class="enscript-keyword">if</span> (chosenCPU == -1)
	    <span class="enscript-keyword">return</span>(NULL);
	<span class="enscript-keyword">return</span>(cpu_datap(chosenCPU)-&gt;cpu_processor);
    }

    <span class="enscript-keyword">return</span>(preferred);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pmThreadGetUrgency</span>(uint64_t *rt_period, uint64_t *rt_deadline)
{
	<span class="enscript-type">int</span>             urgency;
	uint64_t        arg1, arg2;

	urgency = thread_get_urgency(current_processor()-&gt;next_thread, &amp;arg1, &amp;arg2);

	<span class="enscript-keyword">if</span> (urgency == THREAD_URGENCY_REAL_TIME) {
		<span class="enscript-keyword">if</span> (rt_period != NULL)
			*rt_period = arg1;
		
		<span class="enscript-keyword">if</span> (rt_deadline != NULL)
			*rt_deadline = arg2;
	}

	<span class="enscript-keyword">return</span>(urgency);
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
uint32_t	urgency_stats[64][THREAD_URGENCY_MAX];
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>		<span class="enscript-variable-name">URGENCY_NOTIFICATION_ASSERT_NS</span> (5 * 1000 * 1000)
uint64_t	urgency_notification_assert_abstime_threshold, urgency_notification_max_recorded;

<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_tell_urgency</span>(<span class="enscript-type">int</span> urgency,
    uint64_t rt_period,
    uint64_t rt_deadline,
    uint64_t sched_latency,
    thread_t nthread)
{
	uint64_t	urgency_notification_time_start, delta;
	boolean_t	urgency_assert = (urgency_notification_assert_abstime_threshold != 0);
	assert(get_preemption_level() &gt; 0 || ml_get_interrupts_enabled() == FALSE);
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	urgency_stats[cpu_number() % 64][urgency]++;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (!pmInitDone
	    || pmDispatch == NULL
	    || pmDispatch-&gt;pmThreadTellUrgency == NULL)
		<span class="enscript-keyword">return</span>;

	SCHED_DEBUG_PLATFORM_KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED,MACH_URGENCY) | DBG_FUNC_START, urgency, rt_period, rt_deadline, sched_latency, 0);

	<span class="enscript-keyword">if</span> (__improbable((urgency_assert == TRUE)))
		urgency_notification_time_start = mach_absolute_time();

	current_cpu_datap()-&gt;cpu_nthread = nthread;
	pmDispatch-&gt;pmThreadTellUrgency(urgency, rt_period, rt_deadline);

	<span class="enscript-keyword">if</span> (__improbable((urgency_assert == TRUE))) {
		delta = mach_absolute_time() - urgency_notification_time_start;

		<span class="enscript-keyword">if</span> (__improbable(delta &gt; urgency_notification_max_recorded)) {
			<span class="enscript-comment">/* This is not synchronized, but it doesn't matter
			 * if we (rarely) miss an event, as it is statistically
			 * unlikely that it will never recur.
			 */</span>
			urgency_notification_max_recorded = delta;

			<span class="enscript-keyword">if</span> (__improbable((delta &gt; urgency_notification_assert_abstime_threshold) &amp;&amp; !machine_timeout_suspended()))
				panic(<span class="enscript-string">&quot;Urgency notification callout %p exceeded threshold, 0x%llx abstime units&quot;</span>, pmDispatch-&gt;pmThreadTellUrgency, delta);
		}
	}

	SCHED_DEBUG_PLATFORM_KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED,MACH_URGENCY) | DBG_FUNC_END, urgency, rt_period, rt_deadline, 0, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_thread_going_on_core</span>(__unused thread_t      new_thread,
							 __unused <span class="enscript-type">int</span>           urgency,
							 __unused uint64_t      sched_latency)
{
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_thread_going_off_core</span>(__unused thread_t old_thread, __unused boolean_t thread_terminating)
{
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_max_runnable_latency</span>(__unused uint64_t bg_max_latency,
							 __unused uint64_t default_max_latency,
							 __unused uint64_t realtime_max_latency)
{
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">machine_work_interval_notify</span>(__unused thread_t thread,
							 __unused uint64_t work_interval_id,
							 __unused uint64_t start_abstime,
							 __unused uint64_t finish_abstime,
							 __unused uint64_t deadline_abstime,
							 __unused uint64_t next_start_abstime,
							 __unused uint16_t urgency,
							 __unused uint32_t flags)
{
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">active_rt_threads</span>(boolean_t active)
{
    <span class="enscript-keyword">if</span> (!pmInitDone
	|| pmDispatch == NULL
	|| pmDispatch-&gt;pmActiveRTThreads == NULL)
	<span class="enscript-keyword">return</span>;

    pmDispatch-&gt;pmActiveRTThreads(active);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">pmGetSavedRunCount</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span>(saved_run_count);
}

<span class="enscript-comment">/*
 * Returns the root of the package tree.
 */</span>
x86_pkg_t *
<span class="enscript-function-name">pmGetPkgRoot</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span>(x86_pkgs);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">pmCPUGetHibernate</span>(<span class="enscript-type">int</span> cpu)
{
    <span class="enscript-keyword">return</span>(cpu_datap(cpu)-&gt;cpu_hibernate);
}

processor_t
<span class="enscript-function-name">pmLCPUtoProcessor</span>(<span class="enscript-type">int</span> lcpu)
{
    <span class="enscript-keyword">return</span>(cpu_datap(lcpu)-&gt;cpu_processor);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pmReSyncDeadlines</span>(<span class="enscript-type">int</span> cpu)
{
    <span class="enscript-type">static</span> boolean_t	registered	= FALSE;

    <span class="enscript-keyword">if</span> (!registered) {
	PM_interrupt_register(&amp;timer_resync_deadlines);
	registered = TRUE;
    }

    <span class="enscript-keyword">if</span> ((uint32_t)cpu == current_cpu_datap()-&gt;lcpu.cpu_num)
	timer_resync_deadlines();
    <span class="enscript-keyword">else</span>
	cpu_PM_interrupt(cpu);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pmSendIPI</span>(<span class="enscript-type">int</span> cpu)
{
    lapic_send_ipi(cpu, LAPIC_PM_INTERRUPT);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pmGetNanotimeInfo</span>(pm_rtc_nanotime_t *rtc_nanotime)
{
	<span class="enscript-comment">/*
	 * Make sure that nanotime didn't change while we were reading it.
	 */</span>
	<span class="enscript-keyword">do</span> {
		rtc_nanotime-&gt;generation = pal_rtc_nanotime_info.generation; <span class="enscript-comment">/* must be first */</span>
		rtc_nanotime-&gt;tsc_base = pal_rtc_nanotime_info.tsc_base;
		rtc_nanotime-&gt;ns_base = pal_rtc_nanotime_info.ns_base;
		rtc_nanotime-&gt;scale = pal_rtc_nanotime_info.scale;
		rtc_nanotime-&gt;shift = pal_rtc_nanotime_info.shift;
	} <span class="enscript-keyword">while</span>(pal_rtc_nanotime_info.generation != 0
		&amp;&amp; rtc_nanotime-&gt;generation != pal_rtc_nanotime_info.generation);
}

uint32_t
<span class="enscript-function-name">pmTimerQueueMigrate</span>(<span class="enscript-type">int</span> target_cpu)
{
    <span class="enscript-comment">/* Call the etimer code to do this. */</span>
    <span class="enscript-keyword">return</span> (target_cpu != cpu_number())
		? timer_queue_migrate_cpu(target_cpu)
		: 0;
}


<span class="enscript-comment">/*
 * Called by the power management kext to register itself and to get the
 * callbacks it might need into other kernel functions.  This interface
 * is versioned to allow for slight mis-matches between the kext and the
 * kernel.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmKextRegister</span>(uint32_t version, pmDispatch_t *cpuFuncs,
    pmCallBacks_t *callbacks)
{
	<span class="enscript-keyword">if</span> (callbacks != NULL &amp;&amp; version == PM_DISPATCH_VERSION) {
		callbacks-&gt;setRTCPop            = setPop;
		callbacks-&gt;resyncDeadlines      = pmReSyncDeadlines;
		callbacks-&gt;initComplete         = pmInitComplete;
		callbacks-&gt;GetLCPU              = pmGetLogicalCPU;
		callbacks-&gt;GetCore              = pmGetCore;
		callbacks-&gt;GetDie               = pmGetDie;
		callbacks-&gt;GetPackage           = pmGetPackage;
		callbacks-&gt;GetMyLCPU            = pmGetMyLogicalCPU;
		callbacks-&gt;GetMyCore            = pmGetMyCore;
		callbacks-&gt;GetMyDie             = pmGetMyDie;
		callbacks-&gt;GetMyPackage         = pmGetMyPackage;
		callbacks-&gt;GetPkgRoot           = pmGetPkgRoot;
		callbacks-&gt;LockCPUTopology      = pmLockCPUTopology;
		callbacks-&gt;GetHibernate         = pmCPUGetHibernate;
		callbacks-&gt;LCPUtoProcessor      = pmLCPUtoProcessor;
		callbacks-&gt;ThreadBind           = thread_bind;
		callbacks-&gt;GetSavedRunCount     = pmGetSavedRunCount;
		callbacks-&gt;GetNanotimeInfo	= pmGetNanotimeInfo;
		callbacks-&gt;ThreadGetUrgency	= pmThreadGetUrgency;
		callbacks-&gt;RTCClockAdjust	= rtc_clock_adjust;
		callbacks-&gt;timerQueueMigrate    = pmTimerQueueMigrate;
		callbacks-&gt;topoParms            = &amp;topoParms;
		callbacks-&gt;pmSendIPI		= pmSendIPI;
		callbacks-&gt;InterruptPending	= lapic_is_interrupt_pending;
		callbacks-&gt;IsInterrupting	= lapic_is_interrupting;
		callbacks-&gt;InterruptStats	= lapic_interrupt_counts;
		callbacks-&gt;DisableApicTimer	= lapic_disable_timer;
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Version mis-match between Kernel and CPU PM&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (cpuFuncs != NULL) {
		<span class="enscript-keyword">if</span> (pmDispatch) {
			panic(<span class="enscript-string">&quot;Attempt to re-register power management interface--AICPM present in xcpm mode? %p-&gt;%p&quot;</span>, pmDispatch, cpuFuncs);
		}

		pmDispatch = cpuFuncs;

		<span class="enscript-keyword">if</span> (earlyTopology
		    &amp;&amp; pmDispatch-&gt;pmCPUStateInit != NULL) {
			(*pmDispatch-&gt;pmCPUStateInit)();
			earlyTopology = FALSE;
		}

		<span class="enscript-keyword">if</span> (pmDispatch-&gt;pmIPIHandler != NULL) {
			lapic_set_pm_func((i386_intr_func_t)pmDispatch-&gt;pmIPIHandler);
		}
	}
}

<span class="enscript-comment">/*
 * Unregisters the power management functions from the kext.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pmUnRegister</span>(pmDispatch_t *cpuFuncs)
{
    <span class="enscript-keyword">if</span> (cpuFuncs != NULL &amp;&amp; pmDispatch == cpuFuncs) {
	pmDispatch = NULL;
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">machine_track_platform_idle</span>(boolean_t entry) {
	cpu_data_t		*my_cpu		= current_cpu_datap();

	<span class="enscript-keyword">if</span> (entry) {
		(<span class="enscript-type">void</span>)__sync_fetch_and_add(&amp;my_cpu-&gt;lcpu.package-&gt;num_idle, 1);
	}
 	<span class="enscript-keyword">else</span> {
 		uint32_t nidle = __sync_fetch_and_sub(&amp;my_cpu-&gt;lcpu.package-&gt;num_idle, 1);
 		<span class="enscript-keyword">if</span> (nidle == topoParms.nLThreadsPerPackage) {
 			my_cpu-&gt;lcpu.package-&gt;package_idle_exits++;
 		}
 	}
}
</pre>
<hr />
</body></html>