<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>subrs.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">subrs.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/*
 *(C)UNIX System Laboratories, Inc. all or some portions of this file are
 *derived from material licensed to the University of California by
 *American Telephone and Telegraph Co. or UNIX System Laboratories,
 *Inc. and are reproduced herein with the permission of UNIX System
 *Laboratories, Inc.
 */</span>

<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1993,1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1998 Todd C. Miller &lt;<a href="mailto:Todd.Miller@courtesan.com">Todd.Miller@courtesan.com</a>&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
<span class="enscript-comment">/*
 * Random device subroutines and stubs.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libsa/stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

<span class="enscript-comment">/* String routines, from CMU */</span>
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">strcpy</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">strcmp</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">strncmp</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">strcpy</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">strncpy</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">strlen</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Abstract:
 *      strcmp (s1, s2) compares the strings &quot;s1&quot; and &quot;s2&quot;.
 *      It returns 0 if the strings are identical. It returns
 *      &gt; 0 if the first character that differs in the two strings
 *      is larger in s1 than in s2 or if s1 is longer than s2 and
 *      the contents are identical up to the length of s2.
 *      It returns &lt; 0 if the first differing character is smaller
 *      in s1 than in s2 or if s1 is shorter than s2 and the
 *      contents are identical upto the length of s1.
 * Deprecation Warning:
 *	strcmp() is being deprecated. Please use strncmp() instead.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">strcmp</span>(
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1,
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2)
{
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> a, b;

        <span class="enscript-keyword">do</span> {
                a = *s1++;
                b = *s2++;
                <span class="enscript-keyword">if</span> (a != b)
                        <span class="enscript-keyword">return</span> a-b;     <span class="enscript-comment">/* includes case when
                                           'a' is zero and 'b' is not zero
                                           or vice versa */</span>
	} <span class="enscript-keyword">while</span> (a != <span class="enscript-string">'\0'</span>);

        <span class="enscript-keyword">return</span> 0;       <span class="enscript-comment">/* both are zero */</span>
}

<span class="enscript-comment">/*
 * Abstract:
 *      strncmp (s1, s2, n) compares the strings &quot;s1&quot; and &quot;s2&quot;
 *      in exactly the same way as strcmp does.  Except the
 *      comparison runs for at most &quot;n&quot; characters.
 */</span>

<span class="enscript-comment">// ARM implementation in ../arm/strncmp.s
</span><span class="enscript-comment">// ARM64 implementation in ../arm64/strncmp.s
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">strncmp</span>(
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1,
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2,
        size_t n)
{
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> a, b;

        <span class="enscript-keyword">while</span> (n != 0) {
                a = *s1++;
                b = *s2++;
                <span class="enscript-keyword">if</span> (a != b)
                        <span class="enscript-keyword">return</span> a-b;     <span class="enscript-comment">/* includes case when
                                           'a' is zero and 'b' is not zero
                                           or vice versa */</span>
                <span class="enscript-keyword">if</span> (a == <span class="enscript-string">'\0'</span>)
                        <span class="enscript-keyword">return</span> 0;       <span class="enscript-comment">/* both are zero */</span>
                n--;
	}

        <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// Lame implementation just for use by strcasecmp/strncasecmp
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tolower</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ch)
{
    <span class="enscript-keyword">if</span> (ch &gt;= <span class="enscript-string">'A'</span> &amp;&amp; ch &lt;= <span class="enscript-string">'Z'</span>)
	ch = <span class="enscript-string">'a'</span> + (ch - <span class="enscript-string">'A'</span>);

    <span class="enscript-keyword">return</span> ch;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">strcasecmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2)
{
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *us1 = (<span class="enscript-type">const</span> u_char *)s1,
                 *us2 = (<span class="enscript-type">const</span> u_char *)s2;

    <span class="enscript-keyword">while</span> (tolower(*us1) == tolower(*us2++))
	<span class="enscript-keyword">if</span> (*us1++ == <span class="enscript-string">'\0'</span>)
	    <span class="enscript-keyword">return</span> (0);
    <span class="enscript-keyword">return</span> (tolower(*us1) - tolower(*--us2));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">strncasecmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2, size_t n)
{
    <span class="enscript-keyword">if</span> (n != 0) {
	<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *us1 = (<span class="enscript-type">const</span> u_char *)s1,
                     *us2 = (<span class="enscript-type">const</span> u_char *)s2;

	<span class="enscript-keyword">do</span> {
	    <span class="enscript-keyword">if</span> (tolower(*us1) != tolower(*us2++))
		<span class="enscript-keyword">return</span> (tolower(*us1) - tolower(*--us2));
	    <span class="enscript-keyword">if</span> (*us1++ == <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">while</span> (--n != 0);
    }
    <span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Abstract:
 *      strcpy copies the contents of the string &quot;from&quot; including
 *      the null terminator to the string &quot;to&quot;. A pointer to &quot;to&quot;
 *      is returned.
 * Deprecation Warning: 
 *	strcpy() is being deprecated. Please use strlcpy() instead.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">strcpy</span>(
        <span class="enscript-type">char</span> *to,
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *from)
{
        <span class="enscript-type">char</span> *ret = to;

        <span class="enscript-keyword">while</span> ((*to++ = *from++) != <span class="enscript-string">'\0'</span>)
                <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Abstract:
 *      strncpy copies &quot;count&quot; characters from the &quot;from&quot; string to
 *      the &quot;to&quot; string. If &quot;from&quot; contains less than &quot;count&quot; characters
 *      &quot;to&quot; will be padded with null characters until exactly &quot;count&quot;
 *      characters have been written. The return value is a pointer
 *      to the &quot;to&quot; string.
 */</span>

<span class="enscript-comment">// ARM and ARM64 implementation in ../arm/strncpy.c
</span><span class="enscript-type">char</span> *
<span class="enscript-function-name">strncpy</span>(
	<span class="enscript-type">char</span> *s1, 
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2,
	size_t n)
{
        <span class="enscript-type">char</span> *os1 = s1;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i;

        <span class="enscript-keyword">for</span> (i = 0; i &lt; n;)
                <span class="enscript-keyword">if</span> ((*s1++ = *s2++) == <span class="enscript-string">'\0'</span>)
                        <span class="enscript-keyword">for</span> (i++; i &lt; n; i++)
                                *s1++ = <span class="enscript-string">'\0'</span>;
                <span class="enscript-keyword">else</span>
                        i++;
        <span class="enscript-keyword">return</span> (os1);
}

<span class="enscript-comment">/*
 * atoi:
 *
 *      This function converts an ascii string into an integer.
 *
 * input        : string
 * output       : a number
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">atoi</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp)
{
        <span class="enscript-type">int</span>     number;

        <span class="enscript-keyword">for</span> (number = 0; (<span class="enscript-string">'0'</span> &lt;= *cp) &amp;&amp; (*cp &lt;= <span class="enscript-string">'9'</span>); cp++)
                number = (number * 10) + (*cp - <span class="enscript-string">'0'</span>);

        <span class="enscript-keyword">return</span>( number );
}

<span class="enscript-comment">/*
 * convert an ASCII string (decimal radix) to an integer
 * inputs:
 *	p	string pointer.
 *	t	char **, return a pointer to the cahr which terminates the
 *		numeric string.
 * returns:
 *	integer value of the numeric string.
 * side effect:
 *	pointer to terminating char.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">atoi_term</span>(
	<span class="enscript-type">char</span>	*p,	<span class="enscript-comment">/* IN */</span>
	<span class="enscript-type">char</span>	**t)	<span class="enscript-comment">/* OUT */</span>
{
        <span class="enscript-type">int</span> n;
        <span class="enscript-type">int</span> f;

        n = 0;
        f = 0;
        <span class="enscript-keyword">for</span>(;;p++) {
                <span class="enscript-keyword">switch</span>(*p) {
                <span class="enscript-keyword">case</span> <span class="enscript-string">' '</span>:
                <span class="enscript-keyword">case</span> <span class="enscript-string">'\t'</span>:
                        <span class="enscript-keyword">continue</span>;
                <span class="enscript-keyword">case</span> <span class="enscript-string">'-'</span>:
                        f++;
                <span class="enscript-keyword">case</span> <span class="enscript-string">'+'</span>:
                        p++;
                }
                <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">while</span>(*p &gt;= <span class="enscript-string">'0'</span> &amp;&amp; *p &lt;= <span class="enscript-string">'9'</span>)
                n = n*10 + *p++ - <span class="enscript-string">'0'</span>;

        <span class="enscript-comment">/* return pointer to terminating character */</span>
        <span class="enscript-keyword">if</span> ( t )
                *t = p;

        <span class="enscript-keyword">return</span>(f? -n: n);
}

<span class="enscript-comment">/*
 * Does the same thing as strlen, except only looks up
 * to max chars inside the buffer. 
 * Taken from archive/kern-stuff/sbf_machine.c in 
 * seatbelt. 
 * inputs:
 * 	s	string whose length is to be measured
 *	max	maximum length of string to search for null
 * outputs:
 *	length of s or max; whichever is smaller
 */</span>

<span class="enscript-comment">// ARM implementation in ../arm/strnlen.s
</span><span class="enscript-comment">// ARM64 implementation in ../arm64/strnlen.s
</span>size_t
<span class="enscript-function-name">strnlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, size_t max) {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *es = s + max, *p = s;
	<span class="enscript-keyword">while</span>(*p &amp;&amp; p != es) 
		p++;

	<span class="enscript-keyword">return</span> p - s;
}

<span class="enscript-comment">/*
 * convert an integer to an ASCII string.
 * inputs:
 *	num	integer to be converted
 *	str	string pointer.
 *
 * outputs:
 *	pointer to string start.
 */</span>

<span class="enscript-type">char</span> *
<span class="enscript-function-name">itoa</span>(
	<span class="enscript-type">int</span>	num,
	<span class="enscript-type">char</span>	*str)
{
        <span class="enscript-type">char</span>    digits[11];
        <span class="enscript-type">char</span> *dp;
        <span class="enscript-type">char</span> *cp = str;

        <span class="enscript-keyword">if</span> (num == 0) {
            *cp++ = <span class="enscript-string">'0'</span>;
        }
        <span class="enscript-keyword">else</span> {
            dp = digits;
            <span class="enscript-keyword">while</span> (num) {
                *dp++ = <span class="enscript-string">'0'</span> + num % 10;
                num /= 10;
            }
            <span class="enscript-keyword">while</span> (dp != digits) {
                *cp++ = *--dp;
            }
        }
        *cp++ = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">return</span> str;
}

<span class="enscript-comment">/* 
 * Deprecation Warning:
 *	strcat() is being deprecated. Please use strlcat() instead.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">strcat</span>(
	<span class="enscript-type">char</span> *dest,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *src)
{
	<span class="enscript-type">char</span> *old = dest;

	<span class="enscript-keyword">while</span> (*dest)
		++dest;
	<span class="enscript-keyword">while</span> ((*dest++ = *src++))
		;
	<span class="enscript-keyword">return</span> (old);
}

<span class="enscript-comment">/*
 * Appends src to string dst of size siz (unlike strncat, siz is the
 * full size of dst, not space left).  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz &lt;= strlen(dst)).
 * Returns strlen(src) + MIN(siz, strlen(initial dst)).
 * If retval &gt;= siz, truncation occurred.
 */</span>
size_t
<span class="enscript-function-name">strlcat</span>(<span class="enscript-type">char</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *src, size_t siz)
{
	<span class="enscript-type">char</span> *d = dst;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s = src;
	size_t n = siz;
	size_t dlen;

	<span class="enscript-comment">/* Find the end of dst and adjust bytes left but don't go past end */</span>
	<span class="enscript-keyword">while</span> (n-- != 0 &amp;&amp; *d != <span class="enscript-string">'\0'</span>)
		d++;
	dlen = d - dst;
	n = siz - dlen;

	<span class="enscript-keyword">if</span> (n == 0)
		<span class="enscript-keyword">return</span>(dlen + strlen(s));
	<span class="enscript-keyword">while</span> (*s != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> (n != 1) {
			*d++ = *s;
			n--;
		}
		s++;
	}
	*d = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">return</span>(dlen + (s - src));       <span class="enscript-comment">/* count does not include NUL */</span>
}

<span class="enscript-comment">/*
 * Copy src to string dst of size siz.  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz == 0).
 * Returns strlen(src); if retval &gt;= siz, truncation occurred.
 */</span>

<span class="enscript-comment">// ARM and ARM64 implementation in ../arm/strlcpy.c
</span>size_t
<span class="enscript-function-name">strlcpy</span>(<span class="enscript-type">char</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *src, size_t siz)
{
	<span class="enscript-type">char</span> *d = dst;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s = src;
	size_t n = siz;

	<span class="enscript-comment">/* Copy as many bytes as will fit */</span>
	<span class="enscript-keyword">if</span> (n != 0 &amp;&amp; --n != 0) {
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> ((*d++ = *s++) == 0)
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">while</span> (--n != 0);
	}

	<span class="enscript-comment">/* Not enough room in dst, add NUL and traverse rest of src */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		<span class="enscript-keyword">if</span> (siz != 0)
			*d = <span class="enscript-string">'\0'</span>;		<span class="enscript-comment">/* NUL-terminate dst */</span>
		<span class="enscript-keyword">while</span> (*s++)
			;
	}

	<span class="enscript-keyword">return</span>(s - src - 1);	<span class="enscript-comment">/* count does not include NUL */</span>
}

<span class="enscript-comment">/*
 * STRDUP
 *
 * Description: The STRDUP function allocates sufficient memory for a copy
 *              of the string &quot;string&quot;, does the copy, and returns a pointer
 *              it. The pointer may subsequently be used as an argument to
 *              the macro FREE().
 *
 * Parameters:  string		String to be duplicated
 *              type		type of memory to be allocated (normally
 *              		M_TEMP)
 *
 * Returns:     char *          A pointer to the newly allocated string with
 *                              duplicated contents in it.
 *
 *              NULL		If MALLOC() fails.
 *
 * Note:        This function can *not* be called from interrupt context as
 *              it calls MALLOC with M_WAITOK.  In fact, you really
 *              shouldn't be doing string manipulation in interrupt context
 *              ever.
 *
 *              This function name violates the kernel style(9) guide
 *              by being all caps.  This was done on purpose to emphasize
 *              one should use FREE() with the allocated buffer.
 *
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">STRDUP</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *string, <span class="enscript-type">int</span> type)
{
	size_t len;
	<span class="enscript-type">char</span> *copy;   

	len = strlen(string) + 1;
	MALLOC(copy, <span class="enscript-type">char</span> *, len, type, M_WAITOK);
	<span class="enscript-keyword">if</span> (copy == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	bcopy(string, copy, len);
	<span class="enscript-keyword">return</span> (copy); 
}

<span class="enscript-comment">/*
 * Return TRUE(1) if string 2 is a prefix of string 1.
 */</span>     
<span class="enscript-type">int</span>       
<span class="enscript-function-name">strprefix</span>(<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1, <span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2)
{               
        <span class="enscript-type">register</span> <span class="enscript-type">int</span>    c;
                
        <span class="enscript-keyword">while</span> ((c = *s2++) != <span class="enscript-string">'\0'</span>) {
            <span class="enscript-keyword">if</span> (c != *s1++) 
                <span class="enscript-keyword">return</span> (0);
        }       
        <span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">strnstr</span>(<span class="enscript-type">char</span> *s, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *find, size_t slen)
{
  <span class="enscript-type">char</span> c, sc;
  size_t len;
  
  <span class="enscript-keyword">if</span> ((c = *find++) != <span class="enscript-string">'\0'</span>) {
    len = strlen(find);
    <span class="enscript-keyword">do</span> {
      <span class="enscript-keyword">do</span> {
        <span class="enscript-keyword">if</span> ((sc = *s++) == <span class="enscript-string">'\0'</span> || slen-- &lt; 1)
          <span class="enscript-keyword">return</span> (NULL);
      } <span class="enscript-keyword">while</span> (sc != c);
      <span class="enscript-keyword">if</span> (len &gt; slen)
        <span class="enscript-keyword">return</span> (NULL);
    } <span class="enscript-keyword">while</span> (strncmp(s, find, len) != 0);
    s--;
  }
  <span class="enscript-keyword">return</span> (s);
}

</pre>
<hr />
</body></html>