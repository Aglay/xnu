<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>loader.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">loader.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2010 Apple Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_MACHO_LOADER_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_MACHO_LOADER_H_</span>

<span class="enscript-comment">/*
 * This file describes the format of mach object files.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>

<span class="enscript-comment">/*
 * &lt;mach/machine.h&gt; is needed here for the cpu_type_t and cpu_subtype_t types
 * and contains the constants for the possible values of these types.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>

<span class="enscript-comment">/*
 * &lt;mach/vm_prot.h&gt; is needed here for the vm_prot_t type and contains the 
 * constants that are or'ed together for the possible values of this type.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>

<span class="enscript-comment">/*
 * &lt;machine/thread_status.h&gt; is expected to define the flavors of the thread
 * states and the structures of those flavors for each machine.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;architecture/byte_order.h&gt;</span>

<span class="enscript-comment">/*
 * The 32-bit mach header appears at the very beginning of the object file for
 * 32-bit architectures.
 */</span>
<span class="enscript-type">struct</span> mach_header {
	uint32_t	magic;		<span class="enscript-comment">/* mach magic number identifier */</span>
	cpu_type_t	cputype;	<span class="enscript-comment">/* cpu specifier */</span>
	cpu_subtype_t	cpusubtype;	<span class="enscript-comment">/* machine specifier */</span>
	uint32_t	filetype;	<span class="enscript-comment">/* type of file */</span>
	uint32_t	ncmds;		<span class="enscript-comment">/* number of load commands */</span>
	uint32_t	sizeofcmds;	<span class="enscript-comment">/* the size of all the load commands */</span>
	uint32_t	flags;		<span class="enscript-comment">/* flags */</span>
};

<span class="enscript-comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_MAGIC</span>	0xfeedface	<span class="enscript-comment">/* the mach magic number */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_CIGAM</span>	0xcefaedfe	<span class="enscript-comment">/* NXSwapInt(MH_MAGIC) */</span>

<span class="enscript-comment">/*
 * The 64-bit mach header appears at the very beginning of object files for
 * 64-bit architectures.
 */</span>
<span class="enscript-type">struct</span> mach_header_64 {
	uint32_t	magic;		<span class="enscript-comment">/* mach magic number identifier */</span>
	cpu_type_t	cputype;	<span class="enscript-comment">/* cpu specifier */</span>
	cpu_subtype_t	cpusubtype;	<span class="enscript-comment">/* machine specifier */</span>
	uint32_t	filetype;	<span class="enscript-comment">/* type of file */</span>
	uint32_t	ncmds;		<span class="enscript-comment">/* number of load commands */</span>
	uint32_t	sizeofcmds;	<span class="enscript-comment">/* the size of all the load commands */</span>
	uint32_t	flags;		<span class="enscript-comment">/* flags */</span>
	uint32_t	reserved;	<span class="enscript-comment">/* reserved */</span>
};

<span class="enscript-comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_MAGIC_64</span> 0xfeedfacf <span class="enscript-comment">/* the 64-bit mach magic number */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_CIGAM_64</span> 0xcffaedfe <span class="enscript-comment">/* NXSwapInt(MH_MAGIC_64) */</span>

<span class="enscript-comment">/*
 * The layout of the file depends on the filetype.  For all but the MH_OBJECT
 * file type the segments are padded out and aligned on a segment alignment
 * boundary for efficient demand pageing.  The MH_EXECUTE, MH_FVMLIB, MH_DYLIB,
 * MH_DYLINKER and MH_BUNDLE file types also have the headers included as part
 * of their first segment.
 * 
 * The file type MH_OBJECT is a compact format intended as output of the
 * assembler and input (and possibly output) of the link editor (the .o
 * format).  All sections are in one unnamed segment with no segment padding. 
 * This format is used as an executable format when the file is so small the
 * segment padding greatly increases its size.
 *
 * The file type MH_PRELOAD is an executable format intended for things that
 * are not executed under the kernel (proms, stand alones, kernels, etc).  The
 * format can be executed under the kernel but may demand paged it and not
 * preload it before execution.
 *
 * A core file is in MH_CORE format and can be any in an arbritray legal
 * Mach-O file.
 *
 * Constants for the filetype field of the mach_header
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_OBJECT</span>	0x1		<span class="enscript-comment">/* relocatable object file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_EXECUTE</span>	0x2		<span class="enscript-comment">/* demand paged executable file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_FVMLIB</span>	0x3		<span class="enscript-comment">/* fixed VM shared library file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_CORE</span>		0x4		<span class="enscript-comment">/* core file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_PRELOAD</span>	0x5		<span class="enscript-comment">/* preloaded executable file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_DYLIB</span>	0x6		<span class="enscript-comment">/* dynamically bound shared library */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_DYLINKER</span>	0x7		<span class="enscript-comment">/* dynamic link editor */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_BUNDLE</span>	0x8		<span class="enscript-comment">/* dynamically bound bundle file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_DYLIB_STUB</span>	0x9		<span class="enscript-comment">/* shared library stub for static */</span>
					<span class="enscript-comment">/*  linking only, no section contents */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_DSYM</span>		0xa		<span class="enscript-comment">/* companion file with only debug */</span>
					<span class="enscript-comment">/*  sections */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_KEXT_BUNDLE</span>	0xb		<span class="enscript-comment">/* x86_64 kexts */</span>

<span class="enscript-comment">/* Constants for the flags field of the mach_header */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_NOUNDEFS</span>	0x1		<span class="enscript-comment">/* the object file has no undefined
					   references */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_INCRLINK</span>	0x2		<span class="enscript-comment">/* the object file is the output of an
					   incremental link against a base file
					   and can't be link edited again */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_DYLDLINK</span>	0x4		<span class="enscript-comment">/* the object file is input for the
					   dynamic linker and can't be staticly
					   link edited again */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_BINDATLOAD</span>	0x8		<span class="enscript-comment">/* the object file's undefined
					   references are bound by the dynamic
					   linker when loaded. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_PREBOUND</span>	0x10		<span class="enscript-comment">/* the file has its dynamic undefined
					   references prebound. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_SPLIT_SEGS</span>	0x20		<span class="enscript-comment">/* the file has its read-only and
					   read-write segments split */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_LAZY_INIT</span>	0x40		<span class="enscript-comment">/* the shared library init routine is
					   to be run lazily via catching memory
					   faults to its writeable segments
					   (obsolete) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_TWOLEVEL</span>	0x80		<span class="enscript-comment">/* the image is using two-level name
					   space bindings */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_FORCE_FLAT</span>	0x100		<span class="enscript-comment">/* the executable is forcing all images
					   to use flat name space bindings */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_NOMULTIDEFS</span>	0x200		<span class="enscript-comment">/* this umbrella guarantees no multiple
					   defintions of symbols in its
					   sub-images so the two-level namespace
					   hints can always be used. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_NOFIXPREBINDING</span> 0x400	<span class="enscript-comment">/* do not have dyld notify the
					   prebinding agent about this
					   executable */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_PREBINDABLE</span>  0x800           <span class="enscript-comment">/* the binary is not prebound but can
					   have its prebinding redone. only used
                                           when MH_PREBOUND is not set. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_ALLMODSBOUND</span> 0x1000		<span class="enscript-comment">/* indicates that this binary binds to
                                           all two-level namespace modules of
					   its dependent libraries. only used
					   when MH_PREBINDABLE and MH_TWOLEVEL
					   are both set. */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_SUBSECTIONS_VIA_SYMBOLS</span> 0x2000<span class="enscript-comment">/* safe to divide up the sections into
					    sub-sections via symbols for dead
					    code stripping */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_CANONICAL</span>    0x4000		<span class="enscript-comment">/* the binary has been canonicalized
					   via the unprebind operation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_WEAK_DEFINES</span>	0x8000		<span class="enscript-comment">/* the final linked image contains
					   external weak symbols */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_BINDS_TO_WEAK</span> 0x10000	<span class="enscript-comment">/* the final linked image uses
					   weak symbols */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_ALLOW_STACK_EXECUTION</span> 0x20000<span class="enscript-comment">/* When this bit is set, all stacks 
					   in the task will be given stack
					   execution privilege.  Only used in
					   MH_EXECUTE filetypes. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_ROOT_SAFE</span> 0x40000           <span class="enscript-comment">/* When this bit is set, the binary 
					  declares it is safe for use in
					  processes with uid zero */</span>
                                         
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_SETUID_SAFE</span> 0x80000         <span class="enscript-comment">/* When this bit is set, the binary 
					  declares it is safe for use in
					  processes when issetugid() is true */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_NO_REEXPORTED_DYLIBS</span> 0x100000 <span class="enscript-comment">/* When this bit is set on a dylib, 
					  the static linker does not need to
					  examine dependent dylibs to see
					  if any are re-exported */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_PIE</span> 0x200000			<span class="enscript-comment">/* When this bit is set, the OS will
					   load the main executable at a
					   random address.  Only used in
					   MH_EXECUTE filetypes. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH_DEAD_STRIPPABLE_DYLIB</span> 0x400000 <span class="enscript-comment">/* Only for use on dylibs.  When
					     linking against a dylib that
					     has this bit set, the static linker
					     will automatically not create a
					     LC_LOAD_DYLIB load command to the
					     dylib if no symbols are being
					     referenced from the dylib. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_HAS_TLV_DESCRIPTORS</span> 0x800000 <span class="enscript-comment">/* Contains a section of type 
					    S_THREAD_LOCAL_VARIABLES */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_NO_HEAP_EXECUTION</span> 0x1000000	<span class="enscript-comment">/* When this bit is set, the OS will
					   run the main executable with
					   a non-executable heap even on
					   platforms (e.g. i386) that don't
					   require it. Only used in MH_EXECUTE
					   filetypes. */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MH_APP_EXTENSION_SAFE</span> 0x02000000 <span class="enscript-comment">/* The code was linked for use in an
					    application extension. */</span>

<span class="enscript-comment">/*
 * The load commands directly follow the mach_header.  The total size of all
 * of the commands is given by the sizeofcmds field in the mach_header.  All
 * load commands must have as their first two fields cmd and cmdsize.  The cmd
 * field is filled in with a constant for that command type.  Each command type
 * has a structure specifically for it.  The cmdsize field is the size in bytes
 * of the particular load command structure plus anything that follows it that
 * is a part of the load command (i.e. section structures, strings, etc.).  To
 * advance to the next load command the cmdsize can be added to the offset or
 * pointer of the current load command.  The cmdsize for 32-bit architectures
 * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple
 * of 8 bytes (these are forever the maximum alignment of any load commands).
 * The padded bytes must be zero.  All tables in the object file must also
 * follow these rules so the file can be memory mapped.  Otherwise the pointers
 * to these tables will not work well or at all on some machines.  With all
 * padding zeroed like objects will compare byte for byte.
 */</span>
<span class="enscript-type">struct</span> load_command {
	uint32_t cmd;		<span class="enscript-comment">/* type of load command */</span>
	uint32_t cmdsize;	<span class="enscript-comment">/* total size of command in bytes */</span>
};

<span class="enscript-comment">/*
 * After MacOS X 10.1 when a new load command is added that is required to be
 * understood by the dynamic linker for the image to execute properly the
 * LC_REQ_DYLD bit will be or'ed into the load command constant.  If the dynamic
 * linker sees such a load command it it does not understand will issue a
 * &quot;unknown load command required for execution&quot; error and refuse to use the
 * image.  Other load commands without this bit that are not understood will
 * simply be ignored.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_REQ_DYLD</span> 0x80000000

<span class="enscript-comment">/* Constants for the cmd field of all load commands, the type */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SEGMENT</span>	0x1	<span class="enscript-comment">/* segment of this file to be mapped */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SYMTAB</span>	0x2	<span class="enscript-comment">/* link-edit stab symbol table info */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SYMSEG</span>	0x3	<span class="enscript-comment">/* link-edit gdb symbol table info (obsolete) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_THREAD</span>	0x4	<span class="enscript-comment">/* thread */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_UNIXTHREAD</span>	0x5	<span class="enscript-comment">/* unix thread (includes a stack) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_LOADFVMLIB</span>	0x6	<span class="enscript-comment">/* load a specified fixed VM shared library */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_IDFVMLIB</span>	0x7	<span class="enscript-comment">/* fixed VM shared library identification */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_IDENT</span>	0x8	<span class="enscript-comment">/* object identification info (obsolete) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_FVMFILE</span>	0x9	<span class="enscript-comment">/* fixed VM file inclusion (internal use) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_PREPAGE</span>      0xa     <span class="enscript-comment">/* prepage command (internal use) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_DYSYMTAB</span>	0xb	<span class="enscript-comment">/* dynamic link-edit symbol table info */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_LOAD_DYLIB</span>	0xc	<span class="enscript-comment">/* load a dynamically linked shared library */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_ID_DYLIB</span>	0xd	<span class="enscript-comment">/* dynamically linked shared lib ident */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_LOAD_DYLINKER</span> 0xe	<span class="enscript-comment">/* load a dynamic linker */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_ID_DYLINKER</span>	0xf	<span class="enscript-comment">/* dynamic linker identification */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_PREBOUND_DYLIB</span> 0x10	<span class="enscript-comment">/* modules prebound for a dynamically */</span>
				<span class="enscript-comment">/*  linked shared library */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_ROUTINES</span>	0x11	<span class="enscript-comment">/* image routines */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SUB_FRAMEWORK</span> 0x12	<span class="enscript-comment">/* sub framework */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SUB_UMBRELLA</span> 0x13	<span class="enscript-comment">/* sub umbrella */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SUB_CLIENT</span>	0x14	<span class="enscript-comment">/* sub client */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SUB_LIBRARY</span>  0x15	<span class="enscript-comment">/* sub library */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_TWOLEVEL_HINTS</span> 0x16	<span class="enscript-comment">/* two-level namespace lookup hints */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_PREBIND_CKSUM</span>  0x17	<span class="enscript-comment">/* prebind checksum */</span>

<span class="enscript-comment">/*
 * load a dynamically linked shared library that is allowed to be missing
 * (all symbols are weak imported).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_LOAD_WEAK_DYLIB</span> (0x18 | LC_REQ_DYLD)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_SEGMENT_64</span>	0x19	<span class="enscript-comment">/* 64-bit segment of this file to be
				   mapped */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_ROUTINES_64</span>	0x1a	<span class="enscript-comment">/* 64-bit image routines */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_UUID</span>		0x1b	<span class="enscript-comment">/* the uuid */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_RPATH</span>       (0x1c | LC_REQ_DYLD)    <span class="enscript-comment">/* runpath additions */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_CODE_SIGNATURE</span> 0x1d	<span class="enscript-comment">/* local of code signature */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_SEGMENT_SPLIT_INFO</span> 0x1e <span class="enscript-comment">/* local of info to split segments */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_REEXPORT_DYLIB</span> (0x1f | LC_REQ_DYLD) <span class="enscript-comment">/* load and re-export dylib */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_LAZY_LOAD_DYLIB</span> 0x20	<span class="enscript-comment">/* delay load of dylib until first use */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_ENCRYPTION_INFO</span> 0x21	<span class="enscript-comment">/* encrypted segment information */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_DYLD_INFO</span> 	0x22	<span class="enscript-comment">/* compressed dyld information */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_DYLD_INFO_ONLY</span> (0x22|LC_REQ_DYLD)	<span class="enscript-comment">/* compressed dyld information only */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_LOAD_UPWARD_DYLIB</span> (0x23 | LC_REQ_DYLD) <span class="enscript-comment">/* load upward dylib */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_VERSION_MIN_MACOSX</span> 0x24   <span class="enscript-comment">/* build for MacOSX min OS version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_VERSION_MIN_IPHONEOS</span> 0x25 <span class="enscript-comment">/* build for iPhoneOS min OS version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_FUNCTION_STARTS</span> 0x26 <span class="enscript-comment">/* compressed table of function start addresses */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_DYLD_ENVIRONMENT</span> 0x27 <span class="enscript-comment">/* string for dyld to treat
				    like environment variable */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_MAIN</span> (0x28|LC_REQ_DYLD) <span class="enscript-comment">/* replacement for LC_UNIXTHREAD */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_DATA_IN_CODE</span> 0x29 <span class="enscript-comment">/* table of non-instructions in __text */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_SOURCE_VERSION</span> 0x2A <span class="enscript-comment">/* source version used to build binary */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_DYLIB_CODE_SIGN_DRS</span> 0x2B <span class="enscript-comment">/* Code signing DRs copied from linked dylibs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LC_ENCRYPTION_INFO_64</span> 0x2C <span class="enscript-comment">/* 64-bit encrypted segment information */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_LINKER_OPTION</span> 0x2D <span class="enscript-comment">/* linker options in MH_OBJECT files */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_LINKER_OPTIMIZATION_HINT</span> 0x2E <span class="enscript-comment">/* optimization hints in MH_OBJECT files */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LC_VERSION_MIN_WATCHOS</span> 0x30 <span class="enscript-comment">/* build for Watch min OS version */</span>

<span class="enscript-comment">/*
 * A variable length string in a load command is represented by an lc_str
 * union.  The strings are stored just after the load command structure and
 * the offset is from the start of the load command structure.  The size
 * of the string is reflected in the cmdsize field of the load command.
 * Once again any padded bytes to bring the cmdsize field to a multiple
 * of 4 bytes must be zero.
 */</span>
<span class="enscript-type">union</span> lc_str {
	uint32_t	offset;	<span class="enscript-comment">/* offset to the string */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-type">char</span>		*ptr;	<span class="enscript-comment">/* pointer to the string */</span>
#<span class="enscript-reference">endif</span> 
};

<span class="enscript-comment">/*
 * The segment load command indicates that a part of this file is to be
 * mapped into the task's address space.  The size of this segment in memory,
 * vmsize, maybe equal to or larger than the amount to map from this file,
 * filesize.  The file is mapped starting at fileoff to the beginning of
 * the segment in memory, vmaddr.  The rest of the memory of the segment,
 * if any, is allocated zero fill on demand.  The segment's maximum virtual
 * memory protection and initial virtual memory protection are specified
 * by the maxprot and initprot fields.  If the segment has sections then the
 * section structures directly follow the segment command and their size is
 * reflected in cmdsize.
 */</span>
<span class="enscript-type">struct</span> segment_command { <span class="enscript-comment">/* for 32-bit architectures */</span>
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SEGMENT */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes sizeof section structs */</span>
	<span class="enscript-type">char</span>		segname[16];	<span class="enscript-comment">/* segment name */</span>
	uint32_t	vmaddr;		<span class="enscript-comment">/* memory address of this segment */</span>
	uint32_t	vmsize;		<span class="enscript-comment">/* memory size of this segment */</span>
	uint32_t	fileoff;	<span class="enscript-comment">/* file offset of this segment */</span>
	uint32_t	filesize;	<span class="enscript-comment">/* amount to map from the file */</span>
	vm_prot_t	maxprot;	<span class="enscript-comment">/* maximum VM protection */</span>
	vm_prot_t	initprot;	<span class="enscript-comment">/* initial VM protection */</span>
	uint32_t	nsects;		<span class="enscript-comment">/* number of sections in segment */</span>
	uint32_t	flags;		<span class="enscript-comment">/* flags */</span>
};

<span class="enscript-comment">/*
 * The 64-bit segment load command indicates that a part of this file is to be
 * mapped into a 64-bit task's address space.  If the 64-bit segment has
 * sections then section_64 structures directly follow the 64-bit segment
 * command and their size is reflected in cmdsize.
 */</span>
<span class="enscript-type">struct</span> segment_command_64 { <span class="enscript-comment">/* for 64-bit architectures */</span>
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SEGMENT_64 */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes sizeof section_64 structs */</span>
	<span class="enscript-type">char</span>		segname[16];	<span class="enscript-comment">/* segment name */</span>
	uint64_t	vmaddr;		<span class="enscript-comment">/* memory address of this segment */</span>
	uint64_t	vmsize;		<span class="enscript-comment">/* memory size of this segment */</span>
	uint64_t	fileoff;	<span class="enscript-comment">/* file offset of this segment */</span>
	uint64_t	filesize;	<span class="enscript-comment">/* amount to map from the file */</span>
	vm_prot_t	maxprot;	<span class="enscript-comment">/* maximum VM protection */</span>
	vm_prot_t	initprot;	<span class="enscript-comment">/* initial VM protection */</span>
	uint32_t	nsects;		<span class="enscript-comment">/* number of sections in segment */</span>
	uint32_t	flags;		<span class="enscript-comment">/* flags */</span>
};

<span class="enscript-comment">/* Constants for the flags field of the segment_command */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SG_HIGHVM</span>	0x1	<span class="enscript-comment">/* the file contents for this segment is for
				   the high part of the VM space, the low part
				   is zero filled (for stacks in core files) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SG_FVMLIB</span>	0x2	<span class="enscript-comment">/* this segment is the VM that is allocated by
				   a fixed VM library, for overlap checking in
				   the link editor */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SG_NORELOC</span>	0x4	<span class="enscript-comment">/* this segment has nothing that was relocated
				   in it and nothing relocated to it, that is
				   it maybe safely replaced without relocation*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SG_PROTECTED_VERSION_1</span>	0x8 <span class="enscript-comment">/* This segment is protected.  If the
				       segment starts at file offset 0, the
				       first page of the segment is not
				       protected.  All other pages of the
				       segment are protected. */</span>

<span class="enscript-comment">/*
 * A segment is made up of zero or more sections.  Non-MH_OBJECT files have
 * all of their segments with the proper sections in each, and padded to the
 * specified segment alignment when produced by the link editor.  The first
 * segment of a MH_EXECUTE and MH_FVMLIB format file contains the mach_header
 * and load commands of the object file before its first section.  The zero
 * fill sections are always last in their segment (in all formats).  This
 * allows the zeroed segment padding to be mapped into memory where zero fill
 * sections might be. The gigabyte zero fill sections, those with the section
 * type S_GB_ZEROFILL, can only be in a segment with sections of this type.
 * These segments are then placed after all other segments.
 *
 * The MH_OBJECT format has all of its sections in one segment for
 * compactness.  There is no padding to a specified segment boundary and the
 * mach_header and load commands are not part of the segment.
 *
 * Sections with the same section name, sectname, going into the same segment,
 * segname, are combined by the link editor.  The resulting section is aligned
 * to the maximum alignment of the combined sections and is the new section's
 * alignment.  The combined sections are aligned to their original alignment in
 * the combined section.  Any padded bytes to get the specified alignment are
 * zeroed.
 *
 * The format of the relocation entries referenced by the reloff and nreloc
 * fields of the section structure for mach object files is described in the
 * header file &lt;reloc.h&gt;.
 */</span>
<span class="enscript-type">struct</span> section { <span class="enscript-comment">/* for 32-bit architectures */</span>
	<span class="enscript-type">char</span>		sectname[16];	<span class="enscript-comment">/* name of this section */</span>
	<span class="enscript-type">char</span>		segname[16];	<span class="enscript-comment">/* segment this section goes in */</span>
	uint32_t	addr;		<span class="enscript-comment">/* memory address of this section */</span>
	uint32_t	size;		<span class="enscript-comment">/* size in bytes of this section */</span>
	uint32_t	offset;		<span class="enscript-comment">/* file offset of this section */</span>
	uint32_t	align;		<span class="enscript-comment">/* section alignment (power of 2) */</span>
	uint32_t	reloff;		<span class="enscript-comment">/* file offset of relocation entries */</span>
	uint32_t	nreloc;		<span class="enscript-comment">/* number of relocation entries */</span>
	uint32_t	flags;		<span class="enscript-comment">/* flags (section type and attributes)*/</span>
	uint32_t	reserved1;	<span class="enscript-comment">/* reserved (for offset or index) */</span>
	uint32_t	reserved2;	<span class="enscript-comment">/* reserved (for count or sizeof) */</span>
};

<span class="enscript-type">struct</span> section_64 { <span class="enscript-comment">/* for 64-bit architectures */</span>
	<span class="enscript-type">char</span>		sectname[16];	<span class="enscript-comment">/* name of this section */</span>
	<span class="enscript-type">char</span>		segname[16];	<span class="enscript-comment">/* segment this section goes in */</span>
	uint64_t	addr;		<span class="enscript-comment">/* memory address of this section */</span>
	uint64_t	size;		<span class="enscript-comment">/* size in bytes of this section */</span>
	uint32_t	offset;		<span class="enscript-comment">/* file offset of this section */</span>
	uint32_t	align;		<span class="enscript-comment">/* section alignment (power of 2) */</span>
	uint32_t	reloff;		<span class="enscript-comment">/* file offset of relocation entries */</span>
	uint32_t	nreloc;		<span class="enscript-comment">/* number of relocation entries */</span>
	uint32_t	flags;		<span class="enscript-comment">/* flags (section type and attributes)*/</span>
	uint32_t	reserved1;	<span class="enscript-comment">/* reserved (for offset or index) */</span>
	uint32_t	reserved2;	<span class="enscript-comment">/* reserved (for count or sizeof) */</span>
	uint32_t	reserved3;	<span class="enscript-comment">/* reserved */</span>
};

<span class="enscript-comment">/*
 * The flags field of a section structure is separated into two parts a section
 * type and section attributes.  The section types are mutually exclusive (it
 * can only have one type) but the section attributes are not (it may have more
 * than one attribute).
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECTION_TYPE</span>		 0x000000ff	<span class="enscript-comment">/* 256 section types */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECTION_ATTRIBUTES</span>	 0xffffff00	<span class="enscript-comment">/*  24 section attributes */</span>

<span class="enscript-comment">/* Constants for the type of a section */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_REGULAR</span>		0x0	<span class="enscript-comment">/* regular section */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_ZEROFILL</span>		0x1	<span class="enscript-comment">/* zero fill on demand section */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_CSTRING_LITERALS</span>	0x2	<span class="enscript-comment">/* section with only literal C strings*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_4BYTE_LITERALS</span>	0x3	<span class="enscript-comment">/* section with only 4 byte literals */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_8BYTE_LITERALS</span>	0x4	<span class="enscript-comment">/* section with only 8 byte literals */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_LITERAL_POINTERS</span>	0x5	<span class="enscript-comment">/* section with only pointers to */</span>
					<span class="enscript-comment">/*  literals */</span>
<span class="enscript-comment">/*
 * For the two types of symbol pointers sections and the symbol stubs section
 * they have indirect symbol table entries.  For each of the entries in the
 * section the indirect symbol table entries, in corresponding order in the
 * indirect symbol table, start at the index stored in the reserved1 field
 * of the section structure.  Since the indirect symbol table entries
 * correspond to the entries in the section the number of indirect symbol table
 * entries is inferred from the size of the section divided by the size of the
 * entries in the section.  For symbol pointers sections the size of the entries
 * in the section is 4 bytes and for symbol stubs sections the byte size of the
 * stubs is stored in the reserved2 field of the section structure.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_NON_LAZY_SYMBOL_POINTERS</span>	0x6	<span class="enscript-comment">/* section with only non-lazy
						   symbol pointers */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_LAZY_SYMBOL_POINTERS</span>		0x7	<span class="enscript-comment">/* section with only lazy symbol
						   pointers */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_SYMBOL_STUBS</span>			0x8	<span class="enscript-comment">/* section with only symbol
						   stubs, byte size of stub in
						   the reserved2 field */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_MOD_INIT_FUNC_POINTERS</span>	0x9	<span class="enscript-comment">/* section with only function
						   pointers for initialization*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_MOD_TERM_FUNC_POINTERS</span>	0xa	<span class="enscript-comment">/* section with only function
						   pointers for termination */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_COALESCED</span>			0xb	<span class="enscript-comment">/* section contains symbols that
						   are to be coalesced */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_GB_ZEROFILL</span>			0xc	<span class="enscript-comment">/* zero fill on demand section
						   (that can be larger than 4
						   gigabytes) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_INTERPOSING</span>			0xd	<span class="enscript-comment">/* section with only pairs of
						   function pointers for
						   interposing */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_16BYTE_LITERALS</span>		0xe	<span class="enscript-comment">/* section with only 16 byte
						   literals */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_DTRACE_DOF</span>			0xf	<span class="enscript-comment">/* section contains 
						   DTrace Object Format */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_LAZY_DYLIB_SYMBOL_POINTERS</span>	0x10	<span class="enscript-comment">/* section with only lazy
						   symbol pointers to lazy
						   loaded dylibs */</span>
<span class="enscript-comment">/*
 * Section types to support thread local variables
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_THREAD_LOCAL_REGULAR</span>                   0x11  <span class="enscript-comment">/* template of initial 
							  values for TLVs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_THREAD_LOCAL_ZEROFILL</span>                  0x12  <span class="enscript-comment">/* template of initial 
							  values for TLVs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_THREAD_LOCAL_VARIABLES</span>                 0x13  <span class="enscript-comment">/* TLV descriptors */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_THREAD_LOCAL_VARIABLE_POINTERS</span>         0x14  <span class="enscript-comment">/* pointers to TLV 
                                                          descriptors */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_THREAD_LOCAL_INIT_FUNCTION_POINTERS</span>    0x15  <span class="enscript-comment">/* functions to call
							  to initialize TLV
							  values */</span>

<span class="enscript-comment">/*
 * Constants for the section attributes part of the flags field of a section
 * structure.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECTION_ATTRIBUTES_USR</span>	 0xff000000	<span class="enscript-comment">/* User setable attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_PURE_INSTRUCTIONS</span> 0x80000000	<span class="enscript-comment">/* section contains only true
						   machine instructions */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_NO_TOC</span> 		 0x40000000	<span class="enscript-comment">/* section contains coalesced
						   symbols that are not to be
						   in a ranlib table of
						   contents */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_STRIP_STATIC_SYMS</span> 0x20000000	<span class="enscript-comment">/* ok to strip static symbols
						   in this section in files
						   with the MH_DYLDLINK flag */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_NO_DEAD_STRIP</span>	 0x10000000	<span class="enscript-comment">/* no dead stripping */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_LIVE_SUPPORT</span>	 0x08000000	<span class="enscript-comment">/* blocks are live if they
						   reference live blocks */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_SELF_MODIFYING_CODE</span> 0x04000000	<span class="enscript-comment">/* Used with i386 code stubs
						   written on by dyld */</span>
<span class="enscript-comment">/*
 * If a segment contains any sections marked with S_ATTR_DEBUG then all
 * sections in that segment must have this attribute.  No section other than
 * a section marked with this attribute may reference the contents of this
 * section.  A section with this attribute may contain no symbols and must have
 * a section type S_REGULAR.  The static linker will not copy section contents
 * from sections with this attribute into its output file.  These sections
 * generally contain DWARF debugging info.
 */</span> 
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_ATTR_DEBUG</span>		 0x02000000	<span class="enscript-comment">/* a debug section */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECTION_ATTRIBUTES_SYS</span>	 0x00ffff00	<span class="enscript-comment">/* system setable attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_SOME_INSTRUCTIONS</span> 0x00000400	<span class="enscript-comment">/* section contains some
						   machine instructions */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_EXT_RELOC</span>	 0x00000200	<span class="enscript-comment">/* section has external
						   relocation entries */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_ATTR_LOC_RELOC</span>	 0x00000100	<span class="enscript-comment">/* section has local
						   relocation entries */</span>


<span class="enscript-comment">/*
 * The names of segments and sections in them are mostly meaningless to the
 * link-editor.  But there are few things to support traditional UNIX
 * executables that require the link-editor and assembler to use some names
 * agreed upon by convention.
 *
 * The initial protection of the &quot;__TEXT&quot; segment has write protection turned
 * off (not writeable).
 *
 * The link-editor will allocate common symbols at the end of the &quot;__common&quot;
 * section in the &quot;__DATA&quot; segment.  It will create the section and segment
 * if needed.
 */</span>

<span class="enscript-comment">/* The currently known segment names and the section names in those segments */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SEG_PAGEZERO</span>	<span class="enscript-string">&quot;__PAGEZERO&quot;</span>	<span class="enscript-comment">/* the pagezero segment which has no */</span>
					<span class="enscript-comment">/* protections and catches NULL */</span>
					<span class="enscript-comment">/* references for MH_EXECUTE files */</span>


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SEG_TEXT</span>	<span class="enscript-string">&quot;__TEXT&quot;</span>	<span class="enscript-comment">/* the tradition UNIX text segment */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SECT_TEXT</span>	<span class="enscript-string">&quot;__text&quot;</span>	<span class="enscript-comment">/* the real text part of the text */</span>
					<span class="enscript-comment">/* section no headers, and no padding */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_FVMLIB_INIT0</span> <span class="enscript-string">&quot;__fvmlib_init0&quot;</span>	<span class="enscript-comment">/* the fvmlib initialization */</span>
						<span class="enscript-comment">/*  section */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_FVMLIB_INIT1</span> <span class="enscript-string">&quot;__fvmlib_init1&quot;</span>	<span class="enscript-comment">/* the section following the */</span>
					        <span class="enscript-comment">/*  fvmlib initialization */</span>
						<span class="enscript-comment">/*  section */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SEG_DATA</span>	<span class="enscript-string">&quot;__DATA&quot;</span>	<span class="enscript-comment">/* the tradition UNIX data segment */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SECT_DATA</span>	<span class="enscript-string">&quot;__data&quot;</span>	<span class="enscript-comment">/* the real initialized data section */</span>
					<span class="enscript-comment">/* no padding, no bss overlap */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SECT_BSS</span>	<span class="enscript-string">&quot;__bss&quot;</span>		<span class="enscript-comment">/* the real uninitialized data section*/</span>
					<span class="enscript-comment">/* no padding */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_COMMON</span>	<span class="enscript-string">&quot;__common&quot;</span>	<span class="enscript-comment">/* the section common symbols are */</span>
					<span class="enscript-comment">/* allocated in by the link editor */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SEG_OBJC</span>	<span class="enscript-string">&quot;__OBJC&quot;</span>	<span class="enscript-comment">/* objective-C runtime segment */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_OBJC_SYMBOLS</span> <span class="enscript-string">&quot;__symbol_table&quot;</span>	<span class="enscript-comment">/* symbol table */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_OBJC_MODULES</span> <span class="enscript-string">&quot;__module_info&quot;</span>	<span class="enscript-comment">/* module information */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_OBJC_STRINGS</span> <span class="enscript-string">&quot;__selector_strs&quot;</span>	<span class="enscript-comment">/* string table */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_OBJC_REFS</span> <span class="enscript-string">&quot;__selector_refs&quot;</span>	<span class="enscript-comment">/* string table */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SEG_ICON</span>	 <span class="enscript-string">&quot;__ICON&quot;</span>	<span class="enscript-comment">/* the icon segment */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SECT_ICON_HEADER</span> <span class="enscript-string">&quot;__header&quot;</span>	<span class="enscript-comment">/* the icon headers */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SECT_ICON_TIFF</span>   <span class="enscript-string">&quot;__tiff&quot;</span>	<span class="enscript-comment">/* the icons in tiff format */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SEG_LINKEDIT</span>	<span class="enscript-string">&quot;__LINKEDIT&quot;</span>	<span class="enscript-comment">/* the segment containing all structs */</span>
					<span class="enscript-comment">/* created and maintained by the link */</span>
					<span class="enscript-comment">/* editor.  Created with -seglinkedit */</span>
					<span class="enscript-comment">/* option to ld(1) for MH_EXECUTE and */</span>
					<span class="enscript-comment">/* FVMLIB file types only */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SEG_UNIXSTACK</span>	<span class="enscript-string">&quot;__UNIXSTACK&quot;</span>	<span class="enscript-comment">/* the unix stack segment */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SEG_IMPORT</span>	<span class="enscript-string">&quot;__IMPORT&quot;</span>	<span class="enscript-comment">/* the segment for the self (dyld) */</span>
					<span class="enscript-comment">/* modifing code stubs that has read, */</span>
					<span class="enscript-comment">/* write and execute permissions */</span>

<span class="enscript-comment">/*
 * Fixed virtual memory shared libraries are identified by two things.  The
 * target pathname (the name of the library as found for execution), and the
 * minor version number.  The address of where the headers are loaded is in
 * header_addr. (THIS IS OBSOLETE and no longer supported).
 */</span>
<span class="enscript-type">struct</span> fvmlib {
	<span class="enscript-type">union</span> lc_str	name;		<span class="enscript-comment">/* library's target pathname */</span>
	uint32_t	minor_version;	<span class="enscript-comment">/* library's minor version number */</span>
	uint32_t	header_addr;	<span class="enscript-comment">/* library's header address */</span>
};

<span class="enscript-comment">/*
 * A fixed virtual shared library (filetype == MH_FVMLIB in the mach header)
 * contains a fvmlib_command (cmd == LC_IDFVMLIB) to identify the library.
 * An object that uses a fixed virtual shared library also contains a
 * fvmlib_command (cmd == LC_LOADFVMLIB) for each library it uses.
 * (THIS IS OBSOLETE and no longer supported).
 */</span>
<span class="enscript-type">struct</span> fvmlib_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_IDFVMLIB or LC_LOADFVMLIB */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes pathname string */</span>
	<span class="enscript-type">struct</span> fvmlib	fvmlib;		<span class="enscript-comment">/* the library identification */</span>
};

<span class="enscript-comment">/*
 * Dynamicly linked shared libraries are identified by two things.  The
 * pathname (the name of the library as found for execution), and the
 * compatibility version number.  The pathname must match and the compatibility
 * number in the user of the library must be greater than or equal to the
 * library being used.  The time stamp is used to record the time a library was
 * built and copied into user so it can be use to determined if the library used
 * at runtime is exactly the same as used to built the program.
 */</span>
<span class="enscript-type">struct</span> dylib {
    <span class="enscript-type">union</span> lc_str  name;			<span class="enscript-comment">/* library's path name */</span>
    uint32_t timestamp;			<span class="enscript-comment">/* library's build time stamp */</span>
    uint32_t current_version;		<span class="enscript-comment">/* library's current version number */</span>
    uint32_t compatibility_version;	<span class="enscript-comment">/* library's compatibility vers number*/</span>
};

<span class="enscript-comment">/*
 * A dynamically linked shared library (filetype == MH_DYLIB in the mach header)
 * contains a dylib_command (cmd == LC_ID_DYLIB) to identify the library.
 * An object that uses a dynamically linked shared library also contains a
 * dylib_command (cmd == LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, or
 * LC_REEXPORT_DYLIB) for each library it uses.
 */</span>
<span class="enscript-type">struct</span> dylib_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB,
					   LC_REEXPORT_DYLIB */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes pathname string */</span>
	<span class="enscript-type">struct</span> dylib	dylib;		<span class="enscript-comment">/* the library identification */</span>
};

<span class="enscript-comment">/*
 * A dynamically linked shared library may be a subframework of an umbrella
 * framework.  If so it will be linked with &quot;-umbrella umbrella_name&quot; where
 * Where &quot;umbrella_name&quot; is the name of the umbrella framework. A subframework
 * can only be linked against by its umbrella framework or other subframeworks
 * that are part of the same umbrella framework.  Otherwise the static link
 * editor produces an error and states to link against the umbrella framework.
 * The name of the umbrella framework for subframeworks is recorded in the
 * following structure.
 */</span>
<span class="enscript-type">struct</span> sub_framework_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SUB_FRAMEWORK */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes umbrella string */</span>
	<span class="enscript-type">union</span> lc_str 	umbrella;	<span class="enscript-comment">/* the umbrella framework name */</span>
};

<span class="enscript-comment">/*
 * For dynamically linked shared libraries that are subframework of an umbrella
 * framework they can allow clients other than the umbrella framework or other
 * subframeworks in the same umbrella framework.  To do this the subframework
 * is built with &quot;-allowable_client client_name&quot; and an LC_SUB_CLIENT load
 * command is created for each -allowable_client flag.  The client_name is
 * usually a framework name.  It can also be a name used for bundles clients
 * where the bundle is built with &quot;-client_name client_name&quot;.
 */</span>
<span class="enscript-type">struct</span> sub_client_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SUB_CLIENT */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes client string */</span>
	<span class="enscript-type">union</span> lc_str 	client;		<span class="enscript-comment">/* the client name */</span>
};

<span class="enscript-comment">/*
 * A dynamically linked shared library may be a sub_umbrella of an umbrella
 * framework.  If so it will be linked with &quot;-sub_umbrella umbrella_name&quot; where
 * Where &quot;umbrella_name&quot; is the name of the sub_umbrella framework.  When
 * staticly linking when -twolevel_namespace is in effect a twolevel namespace 
 * umbrella framework will only cause its subframeworks and those frameworks
 * listed as sub_umbrella frameworks to be implicited linked in.  Any other
 * dependent dynamic libraries will not be linked it when -twolevel_namespace
 * is in effect.  The primary library recorded by the static linker when
 * resolving a symbol in these libraries will be the umbrella framework.
 * Zero or more sub_umbrella frameworks may be use by an umbrella framework.
 * The name of a sub_umbrella framework is recorded in the following structure.
 */</span>
<span class="enscript-type">struct</span> sub_umbrella_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SUB_UMBRELLA */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes sub_umbrella string */</span>
	<span class="enscript-type">union</span> lc_str 	sub_umbrella;	<span class="enscript-comment">/* the sub_umbrella framework name */</span>
};

<span class="enscript-comment">/*
 * A dynamically linked shared library may be a sub_library of another shared
 * library.  If so it will be linked with &quot;-sub_library library_name&quot; where
 * Where &quot;library_name&quot; is the name of the sub_library shared library.  When
 * staticly linking when -twolevel_namespace is in effect a twolevel namespace 
 * shared library will only cause its subframeworks and those frameworks
 * listed as sub_umbrella frameworks and libraries listed as sub_libraries to
 * be implicited linked in.  Any other dependent dynamic libraries will not be
 * linked it when -twolevel_namespace is in effect.  The primary library
 * recorded by the static linker when resolving a symbol in these libraries
 * will be the umbrella framework (or dynamic library). Zero or more sub_library
 * shared libraries may be use by an umbrella framework or (or dynamic library).
 * The name of a sub_library framework is recorded in the following structure.
 * For example /usr/lib/libobjc_profile.A.dylib would be recorded as &quot;libobjc&quot;.
 */</span>
<span class="enscript-type">struct</span> sub_library_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SUB_LIBRARY */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes sub_library string */</span>
	<span class="enscript-type">union</span> lc_str 	sub_library;	<span class="enscript-comment">/* the sub_library name */</span>
};

<span class="enscript-comment">/*
 * A program (filetype == MH_EXECUTE) that is
 * prebound to its dynamic libraries has one of these for each library that
 * the static linker used in prebinding.  It contains a bit vector for the
 * modules in the library.  The bits indicate which modules are bound (1) and
 * which are not (0) from the library.  The bit for module 0 is the low bit
 * of the first byte.  So the bit for the Nth module is:
 * (linked_modules[N/8] &gt;&gt; N%8) &amp; 1
 */</span>
<span class="enscript-type">struct</span> prebound_dylib_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_PREBOUND_DYLIB */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes strings */</span>
	<span class="enscript-type">union</span> lc_str	name;		<span class="enscript-comment">/* library's path name */</span>
	uint32_t	nmodules;	<span class="enscript-comment">/* number of modules in library */</span>
	<span class="enscript-type">union</span> lc_str	linked_modules;	<span class="enscript-comment">/* bit vector of linked modules */</span>
};

<span class="enscript-comment">/*
 * A program that uses a dynamic linker contains a dylinker_command to identify
 * the name of the dynamic linker (LC_LOAD_DYLINKER).  And a dynamic linker
 * contains a dylinker_command to identify the dynamic linker (LC_ID_DYLINKER).
 * A file can have at most one of these.
 * This struct is also used for the LC_DYLD_ENVIRONMENT load command and
 * contains string for dyld to treat like environment variable.
 */</span>
<span class="enscript-type">struct</span> dylinker_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_ID_DYLINKER, LC_LOAD_DYLINKER or
					   LC_DYLD_ENVIRONMENT */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* includes pathname string */</span>
	<span class="enscript-type">union</span> lc_str    name;		<span class="enscript-comment">/* dynamic linker's path name */</span>
};

<span class="enscript-comment">/*
 * Thread commands contain machine-specific data structures suitable for
 * use in the thread state primitives.  The machine specific data structures
 * follow the struct thread_command as follows.
 * Each flavor of machine specific data structure is preceded by an unsigned
 * long constant for the flavor of that data structure, an uint32_t
 * that is the count of longs of the size of the state data structure and then
 * the state data structure follows.  This triple may be repeated for many
 * flavors.  The constants for the flavors, counts and state data structure
 * definitions are expected to be in the header file &lt;machine/thread_status.h&gt;.
 * These machine specific data structures sizes must be multiples of
 * 4 bytes  The cmdsize reflects the total size of the thread_command
 * and all of the sizes of the constants for the flavors, counts and state
 * data structures.
 *
 * For executable objects that are unix processes there will be one
 * thread_command (cmd == LC_UNIXTHREAD) created for it by the link-editor.
 * This is the same as a LC_THREAD, except that a stack is automatically
 * created (based on the shell's limit for the stack size).  Command arguments
 * and environment variables are copied onto that stack.
 */</span>
<span class="enscript-type">struct</span> thread_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_THREAD or  LC_UNIXTHREAD */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* total size of this command */</span>
	<span class="enscript-comment">/* uint32_t flavor		   flavor of thread state */</span>
	<span class="enscript-comment">/* uint32_t count		   count of longs in thread state */</span>
	<span class="enscript-comment">/* struct XXX_thread_state state   thread state for this flavor */</span>
	<span class="enscript-comment">/* ... */</span>
};

<span class="enscript-comment">/*
 * The routines command contains the address of the dynamic shared library 
 * initialization routine and an index into the module table for the module
 * that defines the routine.  Before any modules are used from the library the
 * dynamic linker fully binds the module that defines the initialization routine
 * and then calls it.  This gets called before any module initialization
 * routines (used for C++ static constructors) in the library.
 */</span>
<span class="enscript-type">struct</span> routines_command { <span class="enscript-comment">/* for 32-bit architectures */</span>
	uint32_t	cmd;		<span class="enscript-comment">/* LC_ROUTINES */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* total size of this command */</span>
	uint32_t	init_address;	<span class="enscript-comment">/* address of initialization routine */</span>
	uint32_t	init_module;	<span class="enscript-comment">/* index into the module table that */</span>
				        <span class="enscript-comment">/*  the init routine is defined in */</span>
	uint32_t	reserved1;
	uint32_t	reserved2;
	uint32_t	reserved3;
	uint32_t	reserved4;
	uint32_t	reserved5;
	uint32_t	reserved6;
};

<span class="enscript-comment">/*
 * The 64-bit routines command.  Same use as above.
 */</span>
<span class="enscript-type">struct</span> routines_command_64 { <span class="enscript-comment">/* for 64-bit architectures */</span>
	uint32_t	cmd;		<span class="enscript-comment">/* LC_ROUTINES_64 */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* total size of this command */</span>
	uint64_t	init_address;	<span class="enscript-comment">/* address of initialization routine */</span>
	uint64_t	init_module;	<span class="enscript-comment">/* index into the module table that */</span>
					<span class="enscript-comment">/*  the init routine is defined in */</span>
	uint64_t	reserved1;
	uint64_t	reserved2;
	uint64_t	reserved3;
	uint64_t	reserved4;
	uint64_t	reserved5;
	uint64_t	reserved6;
};

<span class="enscript-comment">/*
 * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD
 * &quot;stab&quot; style symbol table information as described in the header files
 * &lt;nlist.h&gt; and &lt;stab.h&gt;.
 */</span>
<span class="enscript-type">struct</span> symtab_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SYMTAB */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct symtab_command) */</span>
	uint32_t	symoff;		<span class="enscript-comment">/* symbol table offset */</span>
	uint32_t	nsyms;		<span class="enscript-comment">/* number of symbol table entries */</span>
	uint32_t	stroff;		<span class="enscript-comment">/* string table offset */</span>
	uint32_t	strsize;	<span class="enscript-comment">/* string table size in bytes */</span>
};

<span class="enscript-comment">/*
 * This is the second set of the symbolic information which is used to support
 * the data structures for the dynamically link editor.
 *
 * The original set of symbolic information in the symtab_command which contains
 * the symbol and string tables must also be present when this load command is
 * present.  When this load command is present the symbol table is organized
 * into three groups of symbols:
 *	local symbols (static and debugging symbols) - grouped by module
 *	defined external symbols - grouped by module (sorted by name if not lib)
 *	undefined external symbols (sorted by name if MH_BINDATLOAD is not set,
 *	     			    and in order the were seen by the static
 *				    linker if MH_BINDATLOAD is set)
 * In this load command there are offsets and counts to each of the three groups
 * of symbols.
 *
 * This load command contains a the offsets and sizes of the following new
 * symbolic information tables:
 *	table of contents
 *	module table
 *	reference symbol table
 *	indirect symbol table
 * The first three tables above (the table of contents, module table and
 * reference symbol table) are only present if the file is a dynamically linked
 * shared library.  For executable and object modules, which are files
 * containing only one module, the information that would be in these three
 * tables is determined as follows:
 * 	table of contents - the defined external symbols are sorted by name
 *	module table - the file contains only one module so everything in the
 *		       file is part of the module.
 *	reference symbol table - is the defined and undefined external symbols
 *
 * For dynamically linked shared library files this load command also contains
 * offsets and sizes to the pool of relocation entries for all sections
 * separated into two groups:
 *	external relocation entries
 *	local relocation entries
 * For executable and object modules the relocation entries continue to hang
 * off the section structures.
 */</span>
<span class="enscript-type">struct</span> dysymtab_command {
    uint32_t cmd;	<span class="enscript-comment">/* LC_DYSYMTAB */</span>
    uint32_t cmdsize;	<span class="enscript-comment">/* sizeof(struct dysymtab_command) */</span>

    <span class="enscript-comment">/*
     * The symbols indicated by symoff and nsyms of the LC_SYMTAB load command
     * are grouped into the following three groups:
     *    local symbols (further grouped by the module they are from)
     *    defined external symbols (further grouped by the module they are from)
     *    undefined symbols
     *
     * The local symbols are used only for debugging.  The dynamic binding
     * process may have to use them to indicate to the debugger the local
     * symbols for a module that is being bound.
     *
     * The last two groups are used by the dynamic binding process to do the
     * binding (indirectly through the module table and the reference symbol
     * table when this is a dynamically linked shared library file).
     */</span>
    uint32_t ilocalsym;	<span class="enscript-comment">/* index to local symbols */</span>
    uint32_t nlocalsym;	<span class="enscript-comment">/* number of local symbols */</span>

    uint32_t iextdefsym;<span class="enscript-comment">/* index to externally defined symbols */</span>
    uint32_t nextdefsym;<span class="enscript-comment">/* number of externally defined symbols */</span>

    uint32_t iundefsym;	<span class="enscript-comment">/* index to undefined symbols */</span>
    uint32_t nundefsym;	<span class="enscript-comment">/* number of undefined symbols */</span>

    <span class="enscript-comment">/*
     * For the for the dynamic binding process to find which module a symbol
     * is defined in the table of contents is used (analogous to the ranlib
     * structure in an archive) which maps defined external symbols to modules
     * they are defined in.  This exists only in a dynamically linked shared
     * library file.  For executable and object modules the defined external
     * symbols are sorted by name and is use as the table of contents.
     */</span>
    uint32_t tocoff;	<span class="enscript-comment">/* file offset to table of contents */</span>
    uint32_t ntoc;	<span class="enscript-comment">/* number of entries in table of contents */</span>

    <span class="enscript-comment">/*
     * To support dynamic binding of &quot;modules&quot; (whole object files) the symbol
     * table must reflect the modules that the file was created from.  This is
     * done by having a module table that has indexes and counts into the merged
     * tables for each module.  The module structure that these two entries
     * refer to is described below.  This exists only in a dynamically linked
     * shared library file.  For executable and object modules the file only
     * contains one module so everything in the file belongs to the module.
     */</span>
    uint32_t modtaboff;	<span class="enscript-comment">/* file offset to module table */</span>
    uint32_t nmodtab;	<span class="enscript-comment">/* number of module table entries */</span>

    <span class="enscript-comment">/*
     * To support dynamic module binding the module structure for each module
     * indicates the external references (defined and undefined) each module
     * makes.  For each module there is an offset and a count into the
     * reference symbol table for the symbols that the module references.
     * This exists only in a dynamically linked shared library file.  For
     * executable and object modules the defined external symbols and the
     * undefined external symbols indicates the external references.
     */</span>
    uint32_t extrefsymoff;	<span class="enscript-comment">/* offset to referenced symbol table */</span>
    uint32_t nextrefsyms;	<span class="enscript-comment">/* number of referenced symbol table entries */</span>

    <span class="enscript-comment">/*
     * The sections that contain &quot;symbol pointers&quot; and &quot;routine stubs&quot; have
     * indexes and (implied counts based on the size of the section and fixed
     * size of the entry) into the &quot;indirect symbol&quot; table for each pointer
     * and stub.  For every section of these two types the index into the
     * indirect symbol table is stored in the section header in the field
     * reserved1.  An indirect symbol table entry is simply a 32bit index into
     * the symbol table to the symbol that the pointer or stub is referring to.
     * The indirect symbol table is ordered to match the entries in the section.
     */</span>
    uint32_t indirectsymoff; <span class="enscript-comment">/* file offset to the indirect symbol table */</span>
    uint32_t nindirectsyms;  <span class="enscript-comment">/* number of indirect symbol table entries */</span>

    <span class="enscript-comment">/*
     * To support relocating an individual module in a library file quickly the
     * external relocation entries for each module in the library need to be
     * accessed efficiently.  Since the relocation entries can't be accessed
     * through the section headers for a library file they are separated into
     * groups of local and external entries further grouped by module.  In this
     * case the presents of this load command who's extreloff, nextrel,
     * locreloff and nlocrel fields are non-zero indicates that the relocation
     * entries of non-merged sections are not referenced through the section
     * structures (and the reloff and nreloc fields in the section headers are
     * set to zero).
     *
     * Since the relocation entries are not accessed through the section headers
     * this requires the r_address field to be something other than a section
     * offset to identify the item to be relocated.  In this case r_address is
     * set to the offset from the vmaddr of the first LC_SEGMENT command.
     * For MH_SPLIT_SEGS images r_address is set to the the offset from the
     * vmaddr of the first read-write LC_SEGMENT command.
     *
     * The relocation entries are grouped by module and the module table
     * entries have indexes and counts into them for the group of external
     * relocation entries for that the module.
     *
     * For sections that are merged across modules there must not be any
     * remaining external relocation entries for them (for merged sections
     * remaining relocation entries must be local).
     */</span>
    uint32_t extreloff;	<span class="enscript-comment">/* offset to external relocation entries */</span>
    uint32_t nextrel;	<span class="enscript-comment">/* number of external relocation entries */</span>

    <span class="enscript-comment">/*
     * All the local relocation entries are grouped together (they are not
     * grouped by their module since they are only used if the object is moved
     * from it staticly link edited address).
     */</span>
    uint32_t locreloff;	<span class="enscript-comment">/* offset to local relocation entries */</span>
    uint32_t nlocrel;	<span class="enscript-comment">/* number of local relocation entries */</span>

};	

<span class="enscript-comment">/*
 * An indirect symbol table entry is simply a 32bit index into the symbol table 
 * to the symbol that the pointer or stub is refering to.  Unless it is for a
 * non-lazy symbol pointer section for a defined symbol which strip(1) as 
 * removed.  In which case it has the value INDIRECT_SYMBOL_LOCAL.  If the
 * symbol was also absolute INDIRECT_SYMBOL_ABS is or'ed with that.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INDIRECT_SYMBOL_LOCAL</span>	0x80000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INDIRECT_SYMBOL_ABS</span>	0x40000000


<span class="enscript-comment">/* a table of contents entry */</span>
<span class="enscript-type">struct</span> dylib_table_of_contents {
    uint32_t symbol_index;	<span class="enscript-comment">/* the defined external symbol
				   (index into the symbol table) */</span>
    uint32_t module_index;	<span class="enscript-comment">/* index into the module table this symbol
				   is defined in */</span>
};	

<span class="enscript-comment">/* a module table entry */</span>
<span class="enscript-type">struct</span> dylib_module {
    uint32_t module_name;	<span class="enscript-comment">/* the module name (index into string table) */</span>

    uint32_t iextdefsym;	<span class="enscript-comment">/* index into externally defined symbols */</span>
    uint32_t nextdefsym;	<span class="enscript-comment">/* number of externally defined symbols */</span>
    uint32_t irefsym;		<span class="enscript-comment">/* index into reference symbol table */</span>
    uint32_t nrefsym;		<span class="enscript-comment">/* number of reference symbol table entries */</span>
    uint32_t ilocalsym;		<span class="enscript-comment">/* index into symbols for local symbols */</span>
    uint32_t nlocalsym;		<span class="enscript-comment">/* number of local symbols */</span>

    uint32_t iextrel;		<span class="enscript-comment">/* index into external relocation entries */</span>
    uint32_t nextrel;		<span class="enscript-comment">/* number of external relocation entries */</span>

    uint32_t iinit_iterm;	<span class="enscript-comment">/* low 16 bits are the index into the init
				   section, high 16 bits are the index into
			           the term section */</span>
    uint32_t ninit_nterm;	<span class="enscript-comment">/* low 16 bits are the number of init section
				   entries, high 16 bits are the number of
				   term section entries */</span>

    uint32_t			<span class="enscript-comment">/* for this module address of the start of */</span>
	objc_module_info_addr;  <span class="enscript-comment">/*  the (__OBJC,__module_info) section */</span>
    uint32_t			<span class="enscript-comment">/* for this module size of */</span>
	objc_module_info_size;	<span class="enscript-comment">/*  the (__OBJC,__module_info) section */</span>
};	

<span class="enscript-comment">/* a 64-bit module table entry */</span>
<span class="enscript-type">struct</span> dylib_module_64 {
    uint32_t module_name;	<span class="enscript-comment">/* the module name (index into string table) */</span>

    uint32_t iextdefsym;	<span class="enscript-comment">/* index into externally defined symbols */</span>
    uint32_t nextdefsym;	<span class="enscript-comment">/* number of externally defined symbols */</span>
    uint32_t irefsym;		<span class="enscript-comment">/* index into reference symbol table */</span>
    uint32_t nrefsym;		<span class="enscript-comment">/* number of reference symbol table entries */</span>
    uint32_t ilocalsym;		<span class="enscript-comment">/* index into symbols for local symbols */</span>
    uint32_t nlocalsym;		<span class="enscript-comment">/* number of local symbols */</span>

    uint32_t iextrel;		<span class="enscript-comment">/* index into external relocation entries */</span>
    uint32_t nextrel;		<span class="enscript-comment">/* number of external relocation entries */</span>

    uint32_t iinit_iterm;	<span class="enscript-comment">/* low 16 bits are the index into the init
				   section, high 16 bits are the index into
				   the term section */</span>
    uint32_t ninit_nterm;      <span class="enscript-comment">/* low 16 bits are the number of init section
				  entries, high 16 bits are the number of
				  term section entries */</span>

    uint32_t			<span class="enscript-comment">/* for this module size of */</span>
        objc_module_info_size;	<span class="enscript-comment">/*  the (__OBJC,__module_info) section */</span>
    uint64_t			<span class="enscript-comment">/* for this module address of the start of */</span>
        objc_module_info_addr;	<span class="enscript-comment">/*  the (__OBJC,__module_info) section */</span>
};

<span class="enscript-comment">/* 
 * The entries in the reference symbol table are used when loading the module
 * (both by the static and dynamic link editors) and if the module is unloaded
 * or replaced.  Therefore all external symbols (defined and undefined) are
 * listed in the module's reference table.  The flags describe the type of
 * reference that is being made.  The constants for the flags are defined in
 * &lt;mach-o/nlist.h&gt; as they are also used for symbol table entries.
 */</span>
<span class="enscript-type">struct</span> dylib_reference {
    uint32_t isym:24,		<span class="enscript-comment">/* index into the symbol table */</span>
    		  <span class="enscript-reference">flags</span>:8;	<span class="enscript-comment">/* flags to indicate the type of reference */</span>
};

<span class="enscript-comment">/*
 * The twolevel_hints_command contains the offset and number of hints in the
 * two-level namespace lookup hints table.
 */</span>
<span class="enscript-type">struct</span> twolevel_hints_command {
    uint32_t cmd;	<span class="enscript-comment">/* LC_TWOLEVEL_HINTS */</span>
    uint32_t cmdsize;	<span class="enscript-comment">/* sizeof(struct twolevel_hints_command) */</span>
    uint32_t offset;	<span class="enscript-comment">/* offset to the hint table */</span>
    uint32_t nhints;	<span class="enscript-comment">/* number of hints in the hint table */</span>
};

<span class="enscript-comment">/*
 * The entries in the two-level namespace lookup hints table are twolevel_hint
 * structs.  These provide hints to the dynamic link editor where to start
 * looking for an undefined symbol in a two-level namespace image.  The
 * isub_image field is an index into the sub-images (sub-frameworks and
 * sub-umbrellas list) that made up the two-level image that the undefined
 * symbol was found in when it was built by the static link editor.  If
 * isub-image is 0 the the symbol is expected to be defined in library and not
 * in the sub-images.  If isub-image is non-zero it is an index into the array
 * of sub-images for the umbrella with the first index in the sub-images being
 * 1. The array of sub-images is the ordered list of sub-images of the umbrella
 * that would be searched for a symbol that has the umbrella recorded as its
 * primary library.  The table of contents index is an index into the
 * library's table of contents.  This is used as the starting point of the
 * binary search or a directed linear search.
 */</span>
<span class="enscript-type">struct</span> twolevel_hint {
    uint32_t 
	<span class="enscript-reference">isub_image</span>:8,	<span class="enscript-comment">/* index into the sub images */</span>
	<span class="enscript-reference">itoc</span>:24;	<span class="enscript-comment">/* index into the table of contents */</span>
};

<span class="enscript-comment">/*
 * The prebind_cksum_command contains the value of the original check sum for
 * prebound files or zero.  When a prebound file is first created or modified
 * for other than updating its prebinding information the value of the check sum
 * is set to zero.  When the file has it prebinding re-done and if the value of
 * the check sum is zero the original check sum is calculated and stored in
 * cksum field of this load command in the output file.  If when the prebinding
 * is re-done and the cksum field is non-zero it is left unchanged from the
 * input file.
 */</span>
<span class="enscript-type">struct</span> prebind_cksum_command {
    uint32_t cmd;	<span class="enscript-comment">/* LC_PREBIND_CKSUM */</span>
    uint32_t cmdsize;	<span class="enscript-comment">/* sizeof(struct prebind_cksum_command) */</span>
    uint32_t cksum;	<span class="enscript-comment">/* the check sum or zero */</span>
};

<span class="enscript-comment">/*
 * The uuid load command contains a single 128-bit unique random number that
 * identifies an object produced by the static link editor.
 */</span>
<span class="enscript-type">struct</span> uuid_command {
    uint32_t	cmd;		<span class="enscript-comment">/* LC_UUID */</span>
    uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct uuid_command) */</span>
    uint8_t	uuid[16];	<span class="enscript-comment">/* the 128-bit uuid */</span>
};

<span class="enscript-comment">/*
 * The rpath_command contains a path which at runtime should be added to
 * the current run path used to find @rpath prefixed dylibs.
 */</span>
<span class="enscript-type">struct</span> rpath_command {
    uint32_t	 cmd;		<span class="enscript-comment">/* LC_RPATH */</span>
    uint32_t	 cmdsize;	<span class="enscript-comment">/* includes string */</span>
    <span class="enscript-type">union</span> lc_str path;		<span class="enscript-comment">/* path to add to run path */</span>
};

<span class="enscript-comment">/*
 * The linkedit_data_command contains the offsets and sizes of a blob
 * of data in the __LINKEDIT segment.  
 */</span>
<span class="enscript-type">struct</span> linkedit_data_command {
    uint32_t	cmd;		<span class="enscript-comment">/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,
                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,
				   LC_DYLIB_CODE_SIGN_DRS or
				   LC_LINKER_OPTIMIZATION_HINT. */</span>
    uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct linkedit_data_command) */</span>
    uint32_t	dataoff;	<span class="enscript-comment">/* file offset of data in __LINKEDIT segment */</span>
    uint32_t	datasize;	<span class="enscript-comment">/* file size of data in __LINKEDIT segment  */</span>
};

<span class="enscript-comment">/*
 * The encryption_info_command contains the file offset and size of an
 * of an encrypted segment.
 */</span>
<span class="enscript-type">struct</span> encryption_info_command {
   uint32_t	cmd;		<span class="enscript-comment">/* LC_ENCRYPTION_INFO */</span>
   uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct encryption_info_command) */</span>
   uint32_t	cryptoff;	<span class="enscript-comment">/* file offset of encrypted range */</span>
   uint32_t	cryptsize;	<span class="enscript-comment">/* file size of encrypted range */</span>
   uint32_t	cryptid;	<span class="enscript-comment">/* which enryption system,
				   0 means not-encrypted yet */</span>
};

<span class="enscript-comment">/*
 * The encryption_info_command_64 contains the file offset and size of an
 * of an encrypted segment (for use in x86_64 targets).
 */</span>
<span class="enscript-type">struct</span> encryption_info_command_64 {
   uint32_t	cmd;		<span class="enscript-comment">/* LC_ENCRYPTION_INFO_64 */</span>
   uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct encryption_info_command_64) */</span>
   uint32_t	cryptoff;	<span class="enscript-comment">/* file offset of encrypted range */</span>
   uint32_t	cryptsize;	<span class="enscript-comment">/* file size of encrypted range */</span>
   uint32_t	cryptid;	<span class="enscript-comment">/* which enryption system,
				   0 means not-encrypted yet */</span>
   uint32_t	pad;		<span class="enscript-comment">/* padding to make this struct's size a multiple
				   of 8 bytes */</span>
};

<span class="enscript-comment">/*
 * The version_min_command contains the min OS version on which this 
 * binary was built to run.
 */</span>
<span class="enscript-type">struct</span> version_min_command {
    uint32_t	cmd;		<span class="enscript-comment">/* LC_VERSION_MIN_MACOSX or
				   LC_VERSION_MIN_IPHONEOS
				   LC_VERSION_MIN_WATCHOS */</span>
    uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct min_version_command) */</span>
    uint32_t	version;	<span class="enscript-comment">/* X.Y.Z is encoded in nibbles xxxx.yy.zz */</span>
    uint32_t	sdk;		<span class="enscript-comment">/* X.Y.Z is encoded in nibbles xxxx.yy.zz */</span>
};

<span class="enscript-comment">/*
 * The dyld_info_command contains the file offsets and sizes of 
 * the new compressed form of the information dyld needs to 
 * load the image.  This information is used by dyld on Mac OS X
 * 10.6 and later.  All information pointed to by this command
 * is encoded using byte streams, so no endian swapping is needed
 * to interpret it. 
 */</span>
<span class="enscript-type">struct</span> dyld_info_command {
   uint32_t   cmd;		<span class="enscript-comment">/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</span>
   uint32_t   cmdsize;		<span class="enscript-comment">/* sizeof(struct dyld_info_command) */</span>

    <span class="enscript-comment">/*
     * Dyld rebases an image whenever dyld loads it at an address different
     * from its preferred address.  The rebase information is a stream
     * of byte sized opcodes whose symbolic names start with REBASE_OPCODE_.
     * Conceptually the rebase information is a table of tuples:
     *    &lt;seg-index, seg-offset, type&gt;
     * The opcodes are a compressed way to encode the table by only
     * encoding when a column changes.  In addition simple patterns
     * like &quot;every n'th offset for m times&quot; can be encoded in a few
     * bytes.
     */</span>
    uint32_t   rebase_off;	<span class="enscript-comment">/* file offset to rebase info  */</span>
    uint32_t   rebase_size;	<span class="enscript-comment">/* size of rebase info   */</span>
    
    <span class="enscript-comment">/*
     * Dyld binds an image during the loading process, if the image
     * requires any pointers to be initialized to symbols in other images.  
     * The bind information is a stream of byte sized 
     * opcodes whose symbolic names start with BIND_OPCODE_.
     * Conceptually the bind information is a table of tuples:
     *    &lt;seg-index, seg-offset, type, symbol-library-ordinal, symbol-name, addend&gt;
     * The opcodes are a compressed way to encode the table by only
     * encoding when a column changes.  In addition simple patterns
     * like for runs of pointers initialzed to the same value can be 
     * encoded in a few bytes.
     */</span>
    uint32_t   bind_off;	<span class="enscript-comment">/* file offset to binding info   */</span>
    uint32_t   bind_size;	<span class="enscript-comment">/* size of binding info  */</span>
        
    <span class="enscript-comment">/*
     * Some C++ programs require dyld to unique symbols so that all
     * images in the process use the same copy of some code/data.
     * This step is done after binding. The content of the weak_bind
     * info is an opcode stream like the bind_info.  But it is sorted
     * alphabetically by symbol name.  This enable dyld to walk 
     * all images with weak binding information in order and look
     * for collisions.  If there are no collisions, dyld does
     * no updating.  That means that some fixups are also encoded
     * in the bind_info.  For instance, all calls to &quot;operator new&quot;
     * are first bound to libstdc++.dylib using the information
     * in bind_info.  Then if some image overrides operator new
     * that is detected when the weak_bind information is processed
     * and the call to operator new is then rebound.
     */</span>
    uint32_t   weak_bind_off;	<span class="enscript-comment">/* file offset to weak binding info   */</span>
    uint32_t   weak_bind_size;  <span class="enscript-comment">/* size of weak binding info  */</span>
    
    <span class="enscript-comment">/*
     * Some uses of external symbols do not need to be bound immediately.
     * Instead they can be lazily bound on first use.  The lazy_bind
     * are contains a stream of BIND opcodes to bind all lazy symbols.
     * Normal use is that dyld ignores the lazy_bind section when
     * loading an image.  Instead the static linker arranged for the
     * lazy pointer to initially point to a helper function which 
     * pushes the offset into the lazy_bind area for the symbol
     * needing to be bound, then jumps to dyld which simply adds
     * the offset to lazy_bind_off to get the information on what 
     * to bind.  
     */</span>
    uint32_t   lazy_bind_off;	<span class="enscript-comment">/* file offset to lazy binding info */</span>
    uint32_t   lazy_bind_size;  <span class="enscript-comment">/* size of lazy binding infs */</span>
    
    <span class="enscript-comment">/*
     * The symbols exported by a dylib are encoded in a trie.  This
     * is a compact representation that factors out common prefixes.
     * It also reduces LINKEDIT pages in RAM because it encodes all  
     * information (name, address, flags) in one small, contiguous range.
     * The export area is a stream of nodes.  The first node sequentially
     * is the start node for the trie.  
     *
     * Nodes for a symbol start with a uleb128 that is the length of
     * the exported symbol information for the string so far.
     * If there is no exported symbol, the node starts with a zero byte. 
     * If there is exported info, it follows the length.  
	 *
	 * First is a uleb128 containing flags. Normally, it is followed by
     * a uleb128 encoded offset which is location of the content named
     * by the symbol from the mach_header for the image.  If the flags
     * is EXPORT_SYMBOL_FLAGS_REEXPORT, then following the flags is
     * a uleb128 encoded library ordinal, then a zero terminated
     * UTF8 string.  If the string is zero length, then the symbol
     * is re-export from the specified dylib with the same name.
	 * If the flags is EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER, then following
	 * the flags is two uleb128s: the stub offset and the resolver offset.
	 * The stub is used by non-lazy pointers.  The resolver is used
	 * by lazy pointers and must be called to get the actual address to use.
     *
     * After the optional exported symbol information is a byte of
     * how many edges (0-255) that this node has leaving it, 
     * followed by each edge.
     * Each edge is a zero terminated UTF8 of the addition chars
     * in the symbol, followed by a uleb128 offset for the node that
     * edge points to.
     *  
     */</span>
    uint32_t   export_off;	<span class="enscript-comment">/* file offset to lazy binding info */</span>
    uint32_t   export_size;	<span class="enscript-comment">/* size of lazy binding infs */</span>
};

<span class="enscript-comment">/*
 * The following are used to encode rebasing information
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_TYPE_POINTER</span>					1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_TYPE_TEXT_ABSOLUTE32</span>				2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_TYPE_TEXT_PCREL32</span>				3

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_MASK</span>					0xF0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_IMMEDIATE_MASK</span>					0x0F
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_DONE</span>					0x00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_SET_TYPE_IMM</span>				0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</span>		0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_ADD_ADDR_ULEB</span>				0x30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_ADD_ADDR_IMM_SCALED</span>			0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_DO_REBASE_IMM_TIMES</span>			0x50
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_DO_REBASE_ULEB_TIMES</span>			0x60
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB</span>			0x70
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB</span>	0x80


<span class="enscript-comment">/*
 * The following are used to encode binding information
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_TYPE_POINTER</span>					1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_TYPE_TEXT_ABSOLUTE32</span>				2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_TYPE_TEXT_PCREL32</span>					3

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_SPECIAL_DYLIB_SELF</span>					 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE</span>			-1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_SPECIAL_DYLIB_FLAT_LOOKUP</span>				-2

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_SYMBOL_FLAGS_WEAK_IMPORT</span>				0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION</span>			0x8

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_MASK</span>					0xF0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_IMMEDIATE_MASK</span>					0x0F
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_DONE</span>					0x00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_DYLIB_ORDINAL_IMM</span>			0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB</span>			0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_DYLIB_SPECIAL_IMM</span>			0x30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM</span>		0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_TYPE_IMM</span>				0x50
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_ADDEND_SLEB</span>				0x60
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</span>			0x70
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_ADD_ADDR_ULEB</span>				0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_DO_BIND</span>					0x90
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB</span>			0xA0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED</span>			0xB0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB</span>		0xC0


<span class="enscript-comment">/*
 * The following are used on the flags byte of a terminal node
 * in the export information.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPORT_SYMBOL_FLAGS_KIND_MASK</span>				0x03
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPORT_SYMBOL_FLAGS_KIND_REGULAR</span>			0x00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL</span>			0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION</span>			0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPORT_SYMBOL_FLAGS_REEXPORT</span>				0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER</span>			0x10

<span class="enscript-comment">/*
 * The linker_option_command contains linker options embedded in object files.
 */</span>
<span class="enscript-type">struct</span> linker_option_command {
    uint32_t  cmd;	<span class="enscript-comment">/* LC_LINKER_OPTION only used in MH_OBJECT filetypes */</span>
    uint32_t  cmdsize;
    uint32_t  count;	<span class="enscript-comment">/* number of strings */</span>
    <span class="enscript-comment">/* concatenation of zero terminated UTF8 strings.
       Zero filled at end to align */</span>
};

<span class="enscript-comment">/*
 * The symseg_command contains the offset and size of the GNU style
 * symbol table information as described in the header file &lt;symseg.h&gt;.
 * The symbol roots of the symbol segments must also be aligned properly
 * in the file.  So the requirement of keeping the offsets aligned to a
 * multiple of a 4 bytes translates to the length field of the symbol
 * roots also being a multiple of a long.  Also the padding must again be
 * zeroed. (THIS IS OBSOLETE and no longer supported).
 */</span>
<span class="enscript-type">struct</span> symseg_command {
	uint32_t	cmd;		<span class="enscript-comment">/* LC_SYMSEG */</span>
	uint32_t	cmdsize;	<span class="enscript-comment">/* sizeof(struct symseg_command) */</span>
	uint32_t	offset;		<span class="enscript-comment">/* symbol segment offset */</span>
	uint32_t	size;		<span class="enscript-comment">/* symbol segment size in bytes */</span>
};

<span class="enscript-comment">/*
 * The ident_command contains a free format string table following the
 * ident_command structure.  The strings are null terminated and the size of
 * the command is padded out with zero bytes to a multiple of 4 bytes/
 * (THIS IS OBSOLETE and no longer supported).
 */</span>
<span class="enscript-type">struct</span> ident_command {
	uint32_t cmd;		<span class="enscript-comment">/* LC_IDENT */</span>
	uint32_t cmdsize;	<span class="enscript-comment">/* strings that follow this command */</span>
};

<span class="enscript-comment">/*
 * The fvmfile_command contains a reference to a file to be loaded at the
 * specified virtual address.  (Presently, this command is reserved for
 * internal use.  The kernel ignores this command when loading a program into
 * memory).
 */</span>
<span class="enscript-type">struct</span> fvmfile_command {
	uint32_t cmd;			<span class="enscript-comment">/* LC_FVMFILE */</span>
	uint32_t cmdsize;		<span class="enscript-comment">/* includes pathname string */</span>
	<span class="enscript-type">union</span> lc_str	name;		<span class="enscript-comment">/* files pathname */</span>
	uint32_t	header_addr;	<span class="enscript-comment">/* files virtual address */</span>
};


<span class="enscript-comment">/*
 * The entry_point_command is a replacement for thread_command.
 * It is used for main executables to specify the location (file offset)
 * of main().  If -stack_size was used at link time, the stacksize
 * field will contain the stack size need for the main thread.
 */</span>
<span class="enscript-type">struct</span> entry_point_command {
    uint32_t  cmd;	<span class="enscript-comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span>
    uint32_t  cmdsize;	<span class="enscript-comment">/* 24 */</span>
    uint64_t  entryoff;	<span class="enscript-comment">/* file (__TEXT) offset of main() */</span>
    uint64_t  stacksize;<span class="enscript-comment">/* if not zero, initial stack size */</span>
};


<span class="enscript-comment">/*
 * The source_version_command is an optional load command containing
 * the version of the sources used to build the binary.
 */</span>
<span class="enscript-type">struct</span> source_version_command {
    uint32_t  cmd;	<span class="enscript-comment">/* LC_SOURCE_VERSION */</span>
    uint32_t  cmdsize;	<span class="enscript-comment">/* 16 */</span>
    uint64_t  version;	<span class="enscript-comment">/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */</span>
};


<span class="enscript-comment">/*
 * The LC_DATA_IN_CODE load commands uses a linkedit_data_command 
 * to point to an array of data_in_code_entry entries. Each entry
 * describes a range of data in a code section.
 */</span>
<span class="enscript-type">struct</span> data_in_code_entry {
    uint32_t	offset;  <span class="enscript-comment">/* from mach_header to start of data range*/</span>
    uint16_t	length;  <span class="enscript-comment">/* number of bytes in data range */</span>
    uint16_t	kind;    <span class="enscript-comment">/* a DICE_KIND_* value  */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DICE_KIND_DATA</span>              0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DICE_KIND_JUMP_TABLE8</span>       0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DICE_KIND_JUMP_TABLE16</span>      0x0003
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DICE_KIND_JUMP_TABLE32</span>      0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DICE_KIND_ABS_JUMP_TABLE32</span>  0x0005



<span class="enscript-comment">/*
 * Sections of type S_THREAD_LOCAL_VARIABLES contain an array 
 * of tlv_descriptor structures.
 */</span>
<span class="enscript-type">struct</span> tlv_descriptor
{
	<span class="enscript-type">void</span>*		(*thunk)(<span class="enscript-type">struct</span> tlv_descriptor*);
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>	key;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>	offset;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _MACHO_LOADER_H_ */</span>
</pre>
<hr />
</body></html>