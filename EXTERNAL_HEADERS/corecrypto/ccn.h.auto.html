<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ccn.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ccn.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 *  ccn.h
 *  corecrypto
 *
 *  Created on 11/16/2010
 *
 *  Copyright (c) 2010,2011,2012,2013,2014,2015 Apple Inc. All rights reserved.
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_CORECRYPTO_CCN_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_CORECRYPTO_CCN_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/cc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>

<span class="enscript-type">typedef</span> uint8_t cc_byte;
<span class="enscript-type">typedef</span> size_t cc_size;

#<span class="enscript-reference">if</span>  <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 8
<span class="enscript-type">typedef</span> uint64_t cc_unit;          <span class="enscript-comment">// 64 bit unit
</span><span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> cc_dunit <span class="enscript-function-name">__attribute__</span>((mode(TI)));         <span class="enscript-comment">// 128 bit double width unit
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN_LOG2_BITS_PER_UNIT</span>  6  // 2^6 = 64 bits
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_C</span>(x) UINT64_C(x)
#<span class="enscript-reference">elif</span>  <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 4
<span class="enscript-type">typedef</span> uint32_t cc_unit;          <span class="enscript-comment">// 32 bit unit
</span><span class="enscript-type">typedef</span> uint64_t cc_dunit;         <span class="enscript-comment">// 64 bit double width unit
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN_LOG2_BITS_PER_UNIT</span>  5  // 2^5 = 32 bits
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_C</span>(x) UINT32_C(x)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 2
<span class="enscript-type">typedef</span> uint16_t cc_unit;          <span class="enscript-comment">// 16 bit unit
</span><span class="enscript-type">typedef</span> uint32_t cc_dunit;         <span class="enscript-comment">// 32 bit double width unit
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN_LOG2_BITS_PER_UNIT</span>  4  // 2^4 = 16 bits
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_C</span>(x) UINT16_C(x)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 1
<span class="enscript-type">typedef</span> uint8_t cc_unit;           <span class="enscript-comment">// 8 bit unit
</span><span class="enscript-type">typedef</span> uint16_t cc_dunit;         <span class="enscript-comment">// 16 bit double width unit
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN_LOG2_BITS_PER_UNIT</span>  3  // 2^3 = 8 bits
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_C</span>(x) UINT8_C(x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">invalid</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// All mp types have units in little endian unit order.
</span><span class="enscript-type">typedef</span> cc_unit *ccn_t;                <span class="enscript-comment">// n unit long mp
</span><span class="enscript-type">typedef</span> cc_unit *ccnp1_t;              <span class="enscript-comment">// n + 1 unit long mp
</span><span class="enscript-type">typedef</span> cc_unit *cc2n_t;               <span class="enscript-comment">// 2 * n unit long mp
</span><span class="enscript-type">typedef</span> cc_unit *cc2np2_t;             <span class="enscript-comment">// 2 * n + 2 unit long mp
</span><span class="enscript-type">typedef</span> <span class="enscript-type">const</span> cc_unit *ccn_in_t;       <span class="enscript-comment">// n unit long mp
</span><span class="enscript-type">typedef</span> <span class="enscript-type">const</span> cc_unit *ccnp1_in_t;     <span class="enscript-comment">// n + 1 unit long mp
</span><span class="enscript-type">typedef</span> <span class="enscript-type">const</span> cc_unit *cc2n_in_t;      <span class="enscript-comment">// 2 * n unit long mp
</span><span class="enscript-type">typedef</span> <span class="enscript-type">const</span> cc_unit *cc2np2_in_t;    <span class="enscript-comment">// 2 * n + 2 unit long mp
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN_UNIT_BITS</span>  (sizeof(cc_unit) * 8)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN_UNIT_MASK</span>  ((cc_unit)~0)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    cc_unit *start;      <span class="enscript-comment">// First cc_unit of the workspace
</span>    cc_unit *end;        <span class="enscript-comment">// address and beyond NOT TO BE TOUCHED
</span>} cc_ws,*cc_ws_t;

<span class="enscript-comment">/* Conversions between n sizeof and bits */</span>

<span class="enscript-comment">/* Returns the sizeof a ccn vector of length _n_ units. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_sizeof_n</span>(_n_)  (sizeof(cc_unit) * (_n_))

<span class="enscript-comment">/* Returns the count (n) of a ccn vector that can represent _bits_. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_nof</span>(_bits_)  (((_bits_) + CCN_UNIT_BITS - 1) / CCN_UNIT_BITS)

<span class="enscript-comment">/* Returns the sizeof a ccn vector that can represent _bits_. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_sizeof</span>(_bits_)  (ccn_sizeof_n(ccn_nof(_bits_)))

<span class="enscript-comment">/* Returns the count (n) of a ccn vector that can represent _size_ bytes. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_nof_size</span>(_size_)  (((_size_) + CCN_UNIT_SIZE - 1) / CCN_UNIT_SIZE)

<span class="enscript-comment">/* Return the max number of bits a ccn vector of _n_ units can hold. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_bitsof_n</span>(_n_)  ((_n_) * CCN_UNIT_BITS)

<span class="enscript-comment">/* Return the max number of bits a ccn vector of _size_ bytes can hold. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_bitsof_size</span>(_size_)  ((_size_) * 8)

<span class="enscript-comment">/* Return the size of a ccn of size bytes in bytes. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_sizeof_size</span>(_size_)  ccn_sizeof_n(ccn_nof_size(_size_))

<span class="enscript-comment">/* Returns the value of bit _k_ of _ccn_, both are only evaluated once.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_bit</span>(_ccn_, _k_) ({__typeof__ (_k_) __k = (_k_); \
    1 &amp; ((_ccn_)[__k / CCN_UNIT_BITS] &gt;&gt; (__k &amp; (CCN_UNIT_BITS - 1)));})

<span class="enscript-comment">/* Set the value of bit _k_ of _ccn_ to the value _v_  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_set_bit</span>(_ccn_, _k_, _v_) ({__typeof__ (_k_) __k = (_k_);        \
    <span class="enscript-keyword">if</span> (_v_)                                                                \
        (_ccn_)[__k/CCN_UNIT_BITS] |= CC_UNIT_C(1) &lt;&lt; (__k &amp; (CCN_UNIT_BITS - 1));     \
    <span class="enscript-keyword">else</span>                                                                    \
        (_ccn_)[__k/CCN_UNIT_BITS] &amp;= ~(CC_UNIT_C(1) &lt;&lt; (__k &amp; (CCN_UNIT_BITS - 1)));  \
    })

<span class="enscript-comment">/* Macros for making ccn constants.  You must use list of CCN64_C() instances
 separated by commas, with an optional smaller sized CCN32_C, CCN16_C, or
 CCN8_C() instance at the end of the list, when making macros to declare
 larger sized constants. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN8_C</span>(a0) CC_UNIT_C(0x##a0)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> &gt;= 2
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN16_C</span>(a1,a0) CC_UNIT_C(0x##a1##a0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn16_v</span>(a0)  (a0)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN16_C</span>(a1,a0) CCN8_C(a0),CCN8_C(a1)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn16_v</span>(a0)  (a0 &amp; UINT8_C(0xff)),(a0 &gt;&gt; 8)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> &gt;= 4
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN32_C</span>(a3,a2,a1,a0) CC_UNIT_C(0x##a3##a2##a1##a0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_v</span>(a0)  (a0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN32_C</span>(a3,a2,a1,a0) CCN16_C(a1,a0),CCN16_C(a3,a2)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_v</span>(a0)  ccn16_v(a0 &amp; UINT16_C(0xffff)),ccn16_v(a0 &gt;&gt; 16)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 8
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN64_C</span>(a7,a6,a5,a4,a3,a2,a1,a0) CC_UNIT_C(0x##a7##a6##a5##a4##a3##a2##a1##a0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN40_C</span>(a4,a3,a2,a1,a0) CC_UNIT_C(0x##a4##a3##a2##a1##a0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_v</span>(a0)  (a0)
<span class="enscript-comment">//#define ccn64_32(a1,a0)  ((a1 &lt;&lt; 32) | a0)
</span><span class="enscript-comment">//#define ccn_uint64(a,i) (a[i])
</span>#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN64_C</span>(a7,a6,a5,a4,a3,a2,a1,a0) CCN32_C(a3,a2,a1,a0),CCN32_C(a7,a6,a5,a4)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN40_C</span>(a4,a3,a2,a1,a0) CCN32_C(a3,a2,a1,a0),CCN8_C(a4)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_v</span>(a0)  ccn32_v((uint64_t)a0 &amp; UINT32_C(0xffffffff)),ccn32_v((uint64_t)a0 &gt;&gt; 32)
<span class="enscript-comment">//#define ccn64_32(a1,a0)  ccn32_v(a0),ccn32_v(a1)
</span><span class="enscript-comment">//#define ccn_uint64(a,i) ((uint64_t)ccn_uint32(a, i &lt;&lt; 1 + 1) &lt;&lt; 32 | (uint64_t)ccn_uint32(a, i &lt;&lt; 1))
</span>#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Macro's for reading uint32_t and uint64_t from ccns, the index is in 32 or
   64 bit units respectively. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 8
<span class="enscript-comment">/* #define ccn_uint16(a,i) ((i &amp; 3) == 3 ? ((uint16_t)(a[i &gt;&gt; 2] &gt;&gt; 48)) : \
     (i &amp; 3) == 2 ? ((uint16_t)(a[i &gt;&gt; 2] &gt;&gt; 32) &amp; UINT16_C(0xffff)) : \
     (i &amp; 3) == 1 ? ((uint16_t)(a[i &gt;&gt; 2] &gt;&gt; 16) &amp; UINT16_C(0xffff)) : \
     ((uint16_t)(a[i &gt;&gt; 1] &amp; UINT16_C(0xffff))))
*/</span>
<span class="enscript-comment">//#define ccn_uint32(a,i) (i &amp; 1 ? ((uint32_t)(a[i &gt;&gt; 1] &gt;&gt; 32)) : ((uint32_t)(a[i &gt;&gt; 1] &amp; UINT32_C(0xffffffff))))
</span>#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 4
<span class="enscript-comment">//#define ccn16_v(a0)  (a0)
</span><span class="enscript-comment">//#define ccn32_v(a0)  (a0)
</span><span class="enscript-comment">//#define ccn_uint16(a,i) (i &amp; 1 ? ((uint16_t)(a[i &gt;&gt; 1] &gt;&gt; 16)) : ((uint16_t)(a[i &gt;&gt; 1] &amp; UINT16_C(0xffff))))
</span><span class="enscript-comment">//#define ccn_uint32(a,i) (a[i])
</span>#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 2
<span class="enscript-comment">//#define ccn16_v(a0)  (a0)
</span><span class="enscript-comment">//#define ccn32_v(a0,a1)  (a1,a0)
</span><span class="enscript-comment">//#define ccn_uint16(a,i) (a[i])
</span><span class="enscript-comment">//#define ccn_uint32(a,i) (((uint32_t)a[i &lt;&lt; 1 + 1]) &lt;&lt; 16 | (uint32_t)a[i &lt;&lt; 1]))
</span>#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 1
<span class="enscript-comment">//#define ccn16_v(a0)  (a0 &amp; UINT8_C(0xff)),(a0 &gt;&gt; 8)
</span><span class="enscript-comment">//#define ccn_uint16(a,i) ((uint16_t)((a[i &lt;&lt; 1 + 1] &lt;&lt; 8) | a[i &lt;&lt; 1]))
</span><span class="enscript-comment">//#define ccn_uint32(a,i) ((uint32_t)ccn_uint16(a, i &lt;&lt; 1 + 1) &lt;&lt; 16 | (uint32_t)ccn_uint16(a, i &lt;&lt; 1))
</span>#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Macro's for reading uint32_t and uint64_t from ccns, the index is in 32 or
 64 bit units respectively. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 8

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_32</span>(a1,a0) (((const cc_unit)a1) &lt;&lt; 32 | ((const cc_unit)a0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32</span>(a0) a0
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LITTLE_ENDIAN__</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32_parse</span>(p,i) (((const uint32_t *)p)[i])
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32_parse</span>(p,i) (((const uint32_t *)p)[i^1])
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn32_32_null</span> 0

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64</span>(a0) a0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64_parse</span>(p,i) p[i]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn64_64_null</span> 0

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 4

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32</span>(a0) a0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32_parse</span>(p,i) p[i]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn32_32_null</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_32</span>(a1,a0) ccn32_32(a0),ccn32_32(a1)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64</span>(a1,a0) a0,a1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64_parse</span>(p,i) p[1+(i&lt;&lt;1)],p[i&lt;&lt;1]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn64_64_null</span> 0,0

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 2

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32</span>(a1,a0) a0,a1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32_parse</span>(p,i) p[1+(i&lt;&lt;1)],p[i&lt;&lt;1]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn32_32_null</span> 0,0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_32</span>(a3,a2,a1,a0) ccn32_32(a1,a0),ccn32_32(a3,a2)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64</span>(a3,a2,a1,a0) a0,a1,a2,a3
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64_parse</span>(p,i) p[3+(i&lt;&lt;2)],p[2+(i&lt;&lt;2)],p[1+(i&lt;&lt;2)],p[i&lt;&lt;2]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn64_64_null</span> 0,0,0,0

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 1

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32</span>(a3,a2,a1,a0) a0,a1,a2,a3
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn32_32_parse</span>(p,i) p[3+(i&lt;&lt;2)],p[2+(i&lt;&lt;2)],p[1+(i&lt;&lt;2)],p[i&lt;&lt;2]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn32_32_null</span> 0,0,0,0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_32</span>(a7,a6,a5,a4,a3,a2,a1,a0) ccn32_32(a3,a2,a1,a0),ccn32_32(a7,a6,a5,a4)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64</span>(a7,a6,a5,a4,a3,a2,a1,a0) a0,a1,a2,a3,a4,a5,a6,a7
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn64_64_parse</span>(p,i)  p[7+(i&lt;&lt;3)],p[6+(i&lt;&lt;3)],p[5+(i&lt;&lt;3)],p[4+(i&lt;&lt;3)],p[3+(i&lt;&lt;3)],p[2+(i&lt;&lt;3)],p[1+(i&lt;&lt;3)],p[i&lt;&lt;3]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ccn64_64_null</span>  0,0,0,0,0,0,0,0

#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* Macros to construct fixed size ccn arrays from 64 or 32 bit quantities. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn192_64</span>(a2,a1,a0) ccn64_64(a0),ccn64_64(a1),ccn64_64(a2)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn224_32</span>(a6,a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4),ccn32_32(a6)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn256_32</span>(a7,a6,a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4),ccn64_32(a7,a6)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn384_32</span>(a11,a10,a9,a8,a7,a6,a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4),ccn64_32(a7,a6),ccn64_32(a9,a8),ccn64_32(a11,a10)


#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN192_C</span>(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN64_C(a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN64_C(b7,b6,b5,b4,b3,b2,b1,b0),\
    CCN64_C(c7,c6,c5,c4,c3,c2,c1,c0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN200_C</span>(d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN8_C(d0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN224_C</span>(d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN32_C(d3,d2,d1,d0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN232_C</span>(d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN40_C(d4,d3,d2,d1,d0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN256_C</span>(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN64_C(d7,d6,d5,d4,d3,d2,d1,d0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN264_C</span>(e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN8_C(e0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN384_C</span>(f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN64_C(e7,e6,e5,e4,e3,e2,e1,e0),\
    CCN64_C(f7,f6,f5,f4,f3,f2,f1,f0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN392_C</span>(g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN384_C(f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN8_C(g0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CCN528_C</span>(i1,i0,h7,h6,h5,h4,h3,h2,h1,h0,g7,g6,g5,g4,g3,g2,g1,g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) \
    CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),\
    CCN256_C(h7,h6,h5,h4,h3,h2,h1,h0,g7,g6,g5,g4,g3,g2,g1,g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0),\
    CCN16_C(i1,i0)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN192_N</span>  ccn_nof(192)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN224_N</span>  ccn_nof(224)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN256_N</span>  ccn_nof(256)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN384_N</span>  ccn_nof(384)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN512_N</span>  ccn_nof(512)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CCN521_N</span>  ccn_nof(521)

<span class="enscript-comment">/* Return the number of used units after stripping leading 0 units.  */</span>
CC_PURE CC_NONNULL2
cc_size <span class="enscript-function-name">ccn_n</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/* s &gt;&gt; k -&gt; r return bits shifted out of least significant word in bits [0, n&gt;
 { N bit, scalar -&gt; N bit } N = n * sizeof(cc_unit) * 8
 the _multi version doesn't return the shifted bits, but does support multiple
 word shifts.  */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
cc_unit <span class="enscript-function-name">ccn_shift_right</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, size_t k);
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_shift_right_multi</span>(cc_size n, cc_unit *r,<span class="enscript-type">const</span> cc_unit *s, size_t k);

<span class="enscript-comment">/* s &lt;&lt; k -&gt; r return bits shifted out of most significant word in bits [0, n&gt;
 { N bit, scalar -&gt; N bit } N = n * sizeof(cc_unit) * 8
 the _multi version doesn't return the shifted bits, but does support multiple
 word shifts */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
cc_unit <span class="enscript-function-name">ccn_shift_left</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, size_t k);
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_shift_left_multi</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, size_t k);

<span class="enscript-comment">/* s == 0 -&gt; return 0 | s &gt; 0 -&gt; return index (starting at 1) of most
 significant bit that is 1.
 { N bit } N = n * sizeof(cc_unit) * 8 */</span>
CC_NONNULL2
size_t <span class="enscript-function-name">ccn_bitlen</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/* Returns the number of bits which are zero before the first one bit
   counting from least to most significant bit. */</span>
CC_NONNULL2
size_t <span class="enscript-function-name">ccn_trailing_zeros</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/* s == 0 -&gt; return true | s != 0 -&gt; return false
 { N bit } N = n * sizeof(cc_unit) * 8 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_is_zero</span>(_n_, _s_) (!ccn_n(_n_, _s_))

<span class="enscript-comment">/* s == 1 -&gt; return true | s != 1 -&gt; return false
 { N bit } N = n * sizeof(cc_unit) * 8 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_is_one</span>(_n_, _s_) (ccn_n(_n_, _s_) == 1 &amp;&amp; _s_[0] == 1)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_is_zero_or_one</span>(_n_, _s_) (((_n_)==0) || ((ccn_n(_n_, _s_) &lt;= 1) &amp;&amp; (_s_[0] &lt;= 1)))

<span class="enscript-comment">/* s &lt; t -&gt; return - 1 | s == t -&gt; return 0 | s &gt; t -&gt; return 1
 { N bit, N bit -&gt; int } N = n * sizeof(cc_unit) * 8 */</span>
CC_PURE <span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">int</span> <span class="enscript-function-name">ccn_cmp</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);

<span class="enscript-comment">/* s &lt; t -&gt; return - 1 | s == t -&gt; return 0 | s &gt; t -&gt; return 1
 { N bit, M bit -&gt; int } N = ns * sizeof(cc_unit) * 8  M = nt * sizeof(cc_unit) * 8 */</span>
CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 4))
<span class="enscript-type">int</span> <span class="enscript-function-name">ccn_cmpn</span>(cc_size ns, <span class="enscript-type">const</span> cc_unit *s,
             cc_size nt, <span class="enscript-type">const</span> cc_unit *t) {
    <span class="enscript-keyword">if</span> (ns &gt; nt) {
        <span class="enscript-keyword">return</span> 1;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ns &lt; nt) {
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">return</span> ccn_cmp(ns, s, t);
}

<span class="enscript-comment">/* s - t -&gt; r return 1 iff t &gt; s
 { N bit, N bit -&gt; N bit } N = n * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
cc_unit <span class="enscript-function-name">ccn_sub</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);

<span class="enscript-comment">/* s - v -&gt; r return 1 iff v &gt; s return 0 otherwise.
 { N bit, sizeof(cc_unit) * 8 bit -&gt; N bit } N = n * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
cc_unit <span class="enscript-function-name">ccn_sub1</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, cc_unit v);

<span class="enscript-comment">/* s - t -&gt; r return 1 iff t &gt; s
 { N bit, NT bit -&gt; N bit  NT &lt;= N} N = n * sizeof(cc_unit) * 8 */</span>
CC_INLINE
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 5))
cc_unit <span class="enscript-function-name">ccn_subn</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s,
             cc_size nt, <span class="enscript-type">const</span> cc_unit *t) {
    assert(n &gt;= nt);
    <span class="enscript-keyword">return</span> ccn_sub1(n - nt, r + nt, s + nt, ccn_sub(nt, r, s, t));
}


<span class="enscript-comment">/* s + t -&gt; r return carry if result doesn't fit in n bits.
 { N bit, N bit -&gt; N bit } N = n * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
cc_unit <span class="enscript-function-name">ccn_add</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);

<span class="enscript-comment">/* s + v -&gt; r return carry if result doesn't fit in n bits.
 { N bit, sizeof(cc_unit) * 8 bit -&gt; N bit } N = n * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
cc_unit <span class="enscript-function-name">ccn_add1</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, cc_unit v);

<span class="enscript-comment">/* s + t -&gt; r return carry if result doesn't fit in n bits
 { N bit, NT bit -&gt; N bit  NT &lt;= N} N = n * sizeof(cc_unit) * 8 */</span>
CC_INLINE
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 5))
cc_unit <span class="enscript-function-name">ccn_addn</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s,
                 cc_size nt, <span class="enscript-type">const</span> cc_unit *t) {
    assert(n &gt;= nt);
    <span class="enscript-keyword">return</span> ccn_add1(n - nt, r + nt, s + nt, ccn_add(nt, r, s, t));
}

<span class="enscript-function-name">CC_NONNULL</span>((4, 5))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_divmod</span>(cc_size n, cc_unit *q, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);


<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_lcm</span>(cc_size n, cc_unit *r2n, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);


<span class="enscript-comment">/* s * t -&gt; r_2n                   r_2n must not overlap with s nor t
 { n bit, n bit -&gt; 2 * n bit } n = count * sizeof(cc_unit) * 8
 { N bit, N bit -&gt; 2N bit } N = ccn_bitsof(n) */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_mul</span>(cc_size n, cc_unit *r_2n, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);

<span class="enscript-comment">/* s * t -&gt; r_2n                   r_2n must not overlap with s nor t
 { n bit, n bit -&gt; 2 * n bit } n = count * sizeof(cc_unit) * 8
 { N bit, N bit -&gt; 2N bit } N = ccn_bitsof(n) 
 Provide a workspace for potential speedup */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4, 5))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_mul_ws</span>(cc_size count, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t, cc_ws_t ws);

<span class="enscript-comment">/* s[0..n) * v -&gt; r[0..n)+return value
 { N bit, sizeof(cc_unit) * 8 bit -&gt; N + sizeof(cc_unit) * 8 bit } N = n * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
cc_unit <span class="enscript-function-name">ccn_mul1</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit v);

<span class="enscript-comment">/* s[0..n) * v + r[0..n) -&gt; r[0..n)+return value
 { N bit, sizeof(cc_unit) * 8 bit -&gt; N + sizeof(cc_unit) * 8 bit } N = n * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
cc_unit <span class="enscript-function-name">ccn_addmul1</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit v);

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/* a % d -&gt; n
   {2 * n bit, n bit -&gt; n bit } n = count * sizeof(cc_unit) * 8 */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_mod</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *a_2n, <span class="enscript-type">const</span> cc_unit *d);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* r = gcd(s, t).
   N bit, N bit -&gt; N bit */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_gcd</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t);

<span class="enscript-comment">/* r = gcd(s, t).
 N bit, N bit -&gt; O bit */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 4, 6))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_gcdn</span>(cc_size rn, cc_unit *r, cc_size sn, <span class="enscript-type">const</span> cc_unit *s, cc_size tn, <span class="enscript-type">const</span> cc_unit *t);

<span class="enscript-comment">/* r = (data, len) treated as a big endian byte array, return -1 if data
 doesn't fit in r, return 0 otherwise. */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 4))
<span class="enscript-type">int</span> <span class="enscript-function-name">ccn_read_uint</span>(cc_size n, cc_unit *r, size_t data_size, <span class="enscript-type">const</span> uint8_t *data);

<span class="enscript-comment">/* r = (data, len) treated as a big endian byte array, return -1 if data
 doesn't fit in r, return 0 otherwise. 
 ccn_read_uint strips leading zeroes and doesn't care about sign. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_read_int</span>(n, r, data_size, data) ccn_read_uint(n, r, data_size, data)

<span class="enscript-comment">/* Return actual size in bytes needed to serialize s. */</span>
CC_PURE CC_NONNULL2
size_t <span class="enscript-function-name">ccn_write_uint_size</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/* Serialize s, to out.
   First byte of byte stream is the m.s. byte of s,
   regardless of the size of cc_unit.

   No assumption is made about the alignment of out.

   The out_size argument should be the value returned from ccn_write_uint_size,
   and is also the exact number of bytes this function will write to out.
   If out_size if less than the value returned by ccn_write_uint_size, only the
   first out_size non-zero most significant octets of s will be written. */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_write_uint</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s, size_t out_size, <span class="enscript-type">void</span> *out);


CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 4))
cc_size <span class="enscript-function-name">ccn_write_uint_padded</span>(cc_size n, <span class="enscript-type">const</span> cc_unit* s, size_t out_size, uint8_t* to)
{
    size_t bytesInKey = ccn_write_uint_size(n, s);
    cc_size offset = (out_size &gt; bytesInKey) ? out_size - bytesInKey : 0;

    cc_zero(offset, to);
    ccn_write_uint(n, s, out_size - offset, to + offset);

    <span class="enscript-keyword">return</span> offset;
}


<span class="enscript-comment">/*  Return actual size in bytes needed to serialize s as int 
    (adding leading zero if high bit is set). */</span>
CC_PURE CC_NONNULL2
size_t <span class="enscript-function-name">ccn_write_int_size</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/*  Serialize s, to out.
    First byte of byte stream is the m.s. byte of s,
    regardless of the size of cc_unit.

    No assumption is made about the alignment of out.

    The out_size argument should be the value returned from ccn_write_int_size,
    and is also the exact number of bytes this function will write to out.
    If out_size if less than the value returned by ccn_write_int_size, only the
    first out_size non-zero most significant octets of s will be written. */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_write_int</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s, size_t out_size, <span class="enscript-type">void</span> *out);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_DEDICATED_SQR</span>

<span class="enscript-comment">/* s^2 -&gt; r
 { n bit -&gt; 2 * n bit } */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_sqr</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/* s^2 -&gt; r
 { n bit -&gt; 2 * n bit } */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_sqr_ws</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, cc_ws_t ws);

#<span class="enscript-reference">else</span>

<span class="enscript-comment">/* s^2 -&gt; r
 { n bit -&gt; 2 * n bit } */</span>
CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_sqr</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s) {
    ccn_mul(n, r, s, s);
}

<span class="enscript-comment">/* s^2 -&gt; r
 { n bit -&gt; 2 * n bit } */</span>
CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_sqr_ws</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, cc_ws_t ws) {
    ccn_mul_ws(n, r, s, s, ws);
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* s -&gt; r
 { n bit -&gt; n bit } */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_set</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s);

CC_INLINE CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_zero</span>(cc_size n, cc_unit *r) {
    cc_zero(ccn_sizeof_n(n),r);
}

CC_INLINE CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_clear</span>(cc_size n, cc_unit *r) {
    cc_clear(ccn_sizeof_n(n),r);
}

CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_zero_multi</span>(cc_size n, cc_unit *r, ...);

CC_INLINE CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_seti</span>(cc_size n, cc_unit *r, cc_unit v) {
    <span class="enscript-comment">/* assert(n &gt; 0); */</span>
    r[0] = v;
    ccn_zero(n - 1, r + 1);
}

CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_setn</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_size s_size, <span class="enscript-type">const</span> cc_unit *s) {
    <span class="enscript-comment">/* FIXME: assert not available in kernel.
    assert(n &gt; 0);
    assert(s_size &gt; 0);
    assert(s_size &lt;= n);
    */</span>
    ccn_set(s_size, r, s);
    ccn_zero(n - s_size, r + s_size);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_SWAP_HOST_BIG_64</span>(x) \
    ((uint64_t)((((uint64_t)(x) &amp; 0xff00000000000000ULL) &gt;&gt; 56) | \
    (((uint64_t)(x) &amp; 0x00ff000000000000ULL) &gt;&gt; 40) | \
    (((uint64_t)(x) &amp; 0x0000ff0000000000ULL) &gt;&gt; 24) | \
    (((uint64_t)(x) &amp; 0x000000ff00000000ULL) &gt;&gt;  8) | \
    (((uint64_t)(x) &amp; 0x00000000ff000000ULL) &lt;&lt;  8) | \
    (((uint64_t)(x) &amp; 0x0000000000ff0000ULL) &lt;&lt; 24) | \
    (((uint64_t)(x) &amp; 0x000000000000ff00ULL) &lt;&lt; 40) | \
    (((uint64_t)(x) &amp; 0x00000000000000ffULL) &lt;&lt; 56)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_SWAP_HOST_BIG_32</span>(x) \
    ((((x) &amp; 0xff000000) &gt;&gt; 24) | \
    (((x) &amp; 0x00ff0000) &gt;&gt;  8) | \
    (((x) &amp; 0x0000ff00) &lt;&lt;  8) | \
    (((x) &amp; 0x000000ff) &lt;&lt;  24))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_SWAP_HOST_BIG_16</span>(x) \
    ((((x) &amp; 0xff00) &gt;&gt;  8) | \
    (((x) &amp; 0x00ff) &lt;&lt;  8))

<span class="enscript-comment">/* This should probably move if we move ccn_swap out of line. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 8
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_TO_BIG</span>(x) CC_SWAP_HOST_BIG_64(x)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 4
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_TO_BIG</span>(x) CC_SWAP_HOST_BIG_32(x)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 2
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_TO_BIG</span>(x) CC_SWAP_HOST_BIG_16(x)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span> == 1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_UNIT_TO_BIG</span>(x) (x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">unsupported</span> <span class="enscript-variable-name">CCN_UNIT_SIZE</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Swap units in r in place from cc_unit vector byte order to big endian byte order (or back). */</span>
CC_INLINE CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_swap</span>(cc_size n, cc_unit *r) {
    cc_unit *e;
    <span class="enscript-keyword">for</span> (e = r + n - 1; r &lt; e; ++r, --e) {
        cc_unit t = CC_UNIT_TO_BIG(*r);
        *r = CC_UNIT_TO_BIG(*e);
        *e = t;
    }
    <span class="enscript-keyword">if</span> (n &amp; 1)
        *r = CC_UNIT_TO_BIG(*r);
}

CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 3, 4))
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_xor</span>(cc_size n, cc_unit *r, <span class="enscript-type">const</span> cc_unit *s, <span class="enscript-type">const</span> cc_unit *t) {
    <span class="enscript-keyword">while</span> (n--) {
        r[n] = s[n] ^ t[n];
    }
}

<span class="enscript-comment">/* Debugging */</span>
CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_print</span>(cc_size n, <span class="enscript-type">const</span> cc_unit *s);
CC_NONNULL3
<span class="enscript-type">void</span> <span class="enscript-function-name">ccn_lprint</span>(cc_size n, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *label, <span class="enscript-type">const</span> cc_unit *s);

<span class="enscript-comment">/* Forward declaration so we don't depend on ccrng.h. */</span>
<span class="enscript-type">struct</span> ccrng_state;

#<span class="enscript-reference">if</span> 0
CC_INLINE <span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">int</span> <span class="enscript-function-name">ccn_random</span>(cc_size n, cc_unit *r, <span class="enscript-type">struct</span> ccrng_state *rng) {
    <span class="enscript-keyword">return</span> (RNG)-&gt;generate((RNG), ccn_sizeof_n(n), (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)r);
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ccn_random</span>(_n_,_r_,_ccrng_ctx_) \
    ccrng_generate(_ccrng_ctx_, ccn_sizeof_n(_n_), (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)_r_)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Make a ccn of size ccn_nof(nbits) units with up to nbits sized random value. */</span>
<span class="enscript-function-name">CC_NONNULL</span>((2, 3))
<span class="enscript-type">int</span> <span class="enscript-function-name">ccn_random_bits</span>(cc_size nbits, cc_unit *r, <span class="enscript-type">struct</span> ccrng_state *rng);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _CORECRYPTO_CCN_H_ */</span>
</pre>
<hr />
</body></html>