<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>cc.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">cc.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 *  cc.h
 *  corecrypto
 *
 *  Created on 12/16/2010
 *
 *  Copyright (c) 2010,2011,2012,2014,2015 Apple Inc. All rights reserved.
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_CORECRYPTO_CC_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_CORECRYPTO_CC_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/cc_config.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>

<span class="enscript-comment">/* Manage asserts here because a few functions in header public files do use asserts */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_assert</span>(x) assert(x)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CC_KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">CC_USE_S3</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">assert</span>(args)  // No assert in S3
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;assert.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Declare a struct element with a guarenteed alignment of _alignment_.
   The resulting struct can be used to create arrays that are aligned by
   a certain amount.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_aligned_struct</span>(_alignment_)  \
    <span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> { \
        uint8_t b[_alignment_]; \
    } __attribute__((aligned(_alignment_)))

<span class="enscript-comment">/* number of array elements used in a cc_ctx_decl */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_ctx_n</span>(_type_, _size_) ((_size_ + sizeof(_type_) - 1) / sizeof(_type_))

<span class="enscript-comment">/* sizeof of a context declared with cc_ctx_decl */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_ctx_sizeof</span>(_type_, _size_) sizeof(_type_[cc_ctx_n(_type_, _size_)])

#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_ctx_decl</span>(_type_, _size_, _name_)  \
    _type_ _name_[cc_ctx_n(_type_, _size_)]

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CC_HAS_BZERO</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_zero</span>(_size_,_data_) bzero((_data_), (_size_))
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* Alternate version if you don't have bzero. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_zero</span>(_size_,_data_) memset((_data_),0 ,(_size_))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* cc_clear:
 Set &quot;len&quot; bytes of memory to zero at address &quot;dst&quot;.
 cc_clear has been developed so that it won't be optimized out.
 To be used to clear key buffers or sensitive data.
*/</span>
CC_NONNULL2
<span class="enscript-type">void</span> <span class="enscript-function-name">cc_clear</span>(size_t len, <span class="enscript-type">void</span> *dst);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">cc_copy</span>(_size_, _dst_, _src_) memcpy(_dst_, _src_, _size_)

CC_INLINE CC_NONNULL2 CC_NONNULL3 CC_NONNULL4
<span class="enscript-type">void</span> <span class="enscript-function-name">cc_xor</span>(size_t size, <span class="enscript-type">void</span> *r, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *s, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *t) {
    uint8_t *_r=(uint8_t *)r;
    <span class="enscript-type">const</span> uint8_t *_s=(<span class="enscript-type">const</span> uint8_t *)s;
    <span class="enscript-type">const</span> uint8_t *_t=(<span class="enscript-type">const</span> uint8_t *)t;
    <span class="enscript-keyword">while</span> (size--) {
        _r[size] = _s[size] ^ _t[size];
    }
}

<span class="enscript-comment">/* cc_cmp_safe:
 Compare &quot;num&quot; pointed by ptr1 and ptr2, array of identical size.
 Functional behavior: Returns 0 if the &quot;num&quot; bytes starting at ptr1 are identical to the &quot;num&quot;
    bytes starting at ptr2.
    Return !=0 if they are different or if &quot;num&quot; is 0 (empty arrays)
 Security: The execution time/cycles is *independent* of the data and therefore guarantees
    no leak about the data.
    However, the execution time depends on &quot;num&quot;.
*/</span>
CC_NONNULL2 CC_NONNULL3
<span class="enscript-type">int</span> <span class="enscript-function-name">cc_cmp_safe</span> (size_t num, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * ptr1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * ptr2);


<span class="enscript-comment">/* Exchange S and T of any type.  NOTE: Both and S and T are evaluated
   mutliple times and MUST NOT be expressions. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_SWAP</span>(S,T)  do { \
    __typeof__(S) _cc_swap_tmp = S; S = T; T = _cc_swap_tmp; \
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/* Return the maximum value between S and T. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_MAX</span>(S, T) ({__typeof__(S) _cc_max_s = S; __typeof__(T) _cc_max_t = T; _cc_max_s &gt; _cc_max_t ? _cc_max_s : _cc_max_t;})

<span class="enscript-comment">/* Return the minimum value between S and T. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CC_MIN</span>(S, T) ({__typeof__(S) _cc_min_s = S; __typeof__(T) _cc_min_t = T; _cc_min_s &lt;= _cc_min_t ? _cc_min_s : _cc_min_t;})

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _CORECRYPTO_CC_H_ */</span>
</pre>
<hr />
</body></html>