<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>AssertMacros.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">AssertMacros.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2008 by Apple Inc.. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
	File:       AssertMacros.h
 
	Contains:   This file defines structured error handling and assertion macros for
				programming in C. Originally used in QuickDraw GX and later enhanced.
				These macros are used throughout Apple's software.
	
				New code may not want to begin adopting these macros and instead use
				existing language functionality.
	
				See &quot;Living In an Exceptional World&quot; by Sean Parent
				(develop, The Apple Technical Journal, Issue 11, August/September 1992)
				&lt;<a href="http://developer.apple.com/dev/techsupport/develop/issue11toc.shtml">http://developer.apple.com/dev/techsupport/develop/issue11toc.shtml</a>&gt; or
				&lt;<a href="http://www.mactech.com/articles/develop/issue_11/Parent_final.html">http://www.mactech.com/articles/develop/issue_11/Parent_final.html</a>&gt;
				for the methodology behind these error handling and assertion macros.
	
	Bugs?:      For bug reports, consult the following page on
				the World Wide Web:

	 <a href="http://developer.apple.com/bugreporter/">http://developer.apple.com/bugreporter/</a> 
*/</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__ASSERTMACROS__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__ASSERTMACROS__</span>

<span class="enscript-comment">/*
 *  Macro overview:
 *  
 *      check(assertion)
 *         In production builds, pre-processed away  
 *         In debug builds, if assertion evaluates to false, calls DEBUG_ASSERT_MESSAGE
 *  
 *      verify(assertion)
 *         In production builds, evaluates assertion and does nothing
 *         In debug builds, if assertion evaluates to false, calls DEBUG_ASSERT_MESSAGE
 *  
 *      require(assertion, exceptionLabel)
 *         In production builds, if the assertion expression evaluates to false, goto exceptionLabel
 *         In debug builds, if the assertion expression evaluates to false, calls DEBUG_ASSERT_MESSAGE
 *                          and jumps to exceptionLabel
 *  
 *      In addition the following suffixes are available:
 * 
 *         _noerr     Adds &quot;!= 0&quot; to assertion.  Useful for asserting and OSStatus or OSErr is noErr (zero)
 *         _action    Adds statement to be executued if assertion fails
 *         _quiet     Suppress call to DEBUG_ASSERT_MESSAGE
 *         _string    Allows you to add explanitory message to DEBUG_ASSERT_MESSAGE
 *  
 *        For instance, require_noerr_string(resultCode, label, msg) will do nothing if 
 *        resultCode is zero, otherwise it will call DEBUG_ASSERT_MESSAGE with msg
 *        and jump to label.
 *
 *  Configuration:
 *
 *      By default all macros generate &quot;production code&quot; (i.e non-debug).  If  
 *      DEBUG_ASSERT_PRODUCTION_CODE is defined to zero or DEBUG is defined to non-zero
 *      while this header is included, the macros will generated debug code.
 *
 *      If DEBUG_ASSERT_COMPONENT_NAME_STRING is defined, all debug messages will
 *      be prefixed with it.
 *
 *      By default, all messages write to stderr.  If you would like to write a custom
 *      error message formater, defined DEBUG_ASSERT_MESSAGE to your function name.
 *
 *      Each individual macro will only be defined if it is not already defined, so
 *      you can redefine their behavior singly by providing your own definition before
 *      this file is included.
 *
 *      If you define __ASSERTMACROS__ before this file is included, then nothing in
 *      this file will take effect.
 *
 *      Prior to Mac OS X 10.6 the macro names used in this file conflicted with some
 *      user code, including libraries in boost and the proposed C++ standards efforts,
 *      and there was no way for a client of this header to resolve this conflict. Because
 *      of this, most of the macros have been changed so that they are prefixed with 
 *      __ and contain at least one capital letter, which should alleviate the current
 *      and future conflicts.  However, to allow current sources to continue to compile,
 *      compatibility macros are defined at the end with the old names.  A tops script 
 *      at the end of this file will convert all of the old macro names used in a directory
 *      to the new names.  Clients are recommended to migrate over to these new macros as
 *      they update their sources because a future release of Mac OS X will remove the
 *      old macro definitions ( without the double-underscore prefix ).  Clients who
 *      want to compile without the old macro definitions can define the macro
 *      __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES to 0 before this file is
 *      included.
 */</span>


<span class="enscript-comment">/*
 *  Before including this file, #define DEBUG_ASSERT_COMPONENT_NAME_STRING to
 *  a C-string containing the name of your client. This string will be passed to
 *  the DEBUG_ASSERT_MESSAGE macro for inclusion in any assertion messages.
 *
 *  If you do not define DEBUG_ASSERT_COMPONENT_NAME_STRING, the default
 *  DEBUG_ASSERT_COMPONENT_NAME_STRING value, an empty string, will be used by
 *  the assertion macros.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DEBUG_ASSERT_COMPONENT_NAME_STRING</span>
    #define DEBUG_ASSERT_COMPONENT_NAME_STRING <span class="enscript-string">&quot;&quot;</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 *  To activate the additional assertion code and messages for non-production builds,
 *  #define DEBUG_ASSERT_PRODUCTION_CODE to zero before including this file.
 *
 *  If you do not define DEBUG_ASSERT_PRODUCTION_CODE, the default value 1 will be used
 *  (production code = no assertion code and no messages).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DEBUG_ASSERT_PRODUCTION_CODE</span>
   #define DEBUG_ASSERT_PRODUCTION_CODE !DEBUG
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 *  DEBUG_ASSERT_MESSAGE(component, assertion, label, error, file, line, errorCode)
 *
 *  Summary:
 *    All assertion messages are routed through this macro. If you wish to use your
 *    own routine to display assertion messages, you can override DEBUG_ASSERT_MESSAGE
 *    by #defining DEBUG_ASSERT_MESSAGE before including this file.
 *
 *  Parameters:
 *
 *    componentNameString:
 *      A pointer to a string constant containing the name of the
 *      component this code is part of. This must be a string constant
 *      (and not a string variable or NULL) because the preprocessor
 *      concatenates it with other string constants.
 *
 *    assertionString:
 *      A pointer to a string constant containing the assertion.
 *      This must be a string constant (and not a string variable or
 *      NULL) because the Preprocessor concatenates it with other
 *      string constants.
 *    
 *    exceptionLabelString:
 *      A pointer to a string containing the exceptionLabel, or NULL.
 *    
 *    errorString:
 *      A pointer to the error string, or NULL. DEBUG_ASSERT_MESSAGE macros
 *      must not attempt to concatenate this string with constant
 *      character strings.
 *    
 *    fileName:
 *      A pointer to the fileName or pathname (generated by the
 *      preprocessor __FILE__ identifier), or NULL.
 *    
 *    lineNumber:
 *      The line number in the file (generated by the preprocessor
 *      __LINE__ identifier), or 0 (zero).
 *    
 *    errorCode:
 *      A value associated with the assertion, or 0.
 *
 *  Here is an example of a DEBUG_ASSERT_MESSAGE macro and a routine which displays
 *  assertion messsages:
 *
 *      #define DEBUG_ASSERT_COMPONENT_NAME_STRING &quot;MyCoolProgram&quot;
 *
 *      #define DEBUG_ASSERT_MESSAGE(componentNameString, assertionString,                           \
 *                                   exceptionLabelString, errorString, fileName, lineNumber, errorCode) \
 *              MyProgramDebugAssert(componentNameString, assertionString,                           \
 *                                   exceptionLabelString, errorString, fileName, lineNumber, errorCode)
 *
 *      static void
 *      MyProgramDebugAssert(const char *componentNameString, const char *assertionString, 
 *                           const char *exceptionLabelString, const char *errorString, 
 *                           const char *fileName, long lineNumber, int errorCode)
 *      {
 *          if ( (assertionString != NULL) &amp;&amp; (*assertionString != '\0') )
 *              fprintf(stderr, &quot;Assertion failed: %s: %s\n&quot;, componentNameString, assertionString);
 *          else
 *              fprintf(stderr, &quot;Check failed: %s:\n&quot;, componentNameString);
 *          if ( exceptionLabelString != NULL )
 *              fprintf(stderr, &quot;    %s\n&quot;, exceptionLabelString);
 *          if ( errorString != NULL )
 *              fprintf(stderr, &quot;    %s\n&quot;, errorString);
 *          if ( fileName != NULL )
 *              fprintf(stderr, &quot;    file: %s\n&quot;, fileName);
 *          if ( lineNumber != 0 )
 *              fprintf(stderr, &quot;    line: %ld\n&quot;, lineNumber);
 *          if ( errorCode != 0 )
 *              fprintf(stderr, &quot;    error: %d\n&quot;, errorCode);
 *      }
 *
 *  If you do not define DEBUG_ASSERT_MESSAGE, a simple printf to stderr will be used.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DEBUG_ASSERT_MESSAGE</span>
   #ifdef KERNEL
      #include &lt;libkern/libkern.h&gt;
      #define DEBUG_ASSERT_MESSAGE(name, assertion, label, message, file, line, value) \
                                  printf( <span class="enscript-string">&quot;AssertMacros: %s, %s file: %s, line: %d\n&quot;</span>, assertion, (message!=0) ? message : <span class="enscript-string">&quot;&quot;</span>, file, line);
   #<span class="enscript-keyword">else</span>
      #include &lt;stdio.h&gt;
      #define DEBUG_ASSERT_MESSAGE(name, assertion, label, message, file, line, value) \
                                  fprintf(stderr, <span class="enscript-string">&quot;AssertMacros: %s, %s file: %s, line: %d\n&quot;</span>, assertion, (message!=0) ? message : <span class="enscript-string">&quot;&quot;</span>, file, line);
   #endif
#<span class="enscript-reference">endif</span>





<span class="enscript-comment">/*
 *  __Debug_String(message)
 *
 *  Summary:
 *    Production builds: does nothing and produces no code.
 *
 *    Non-production builds: call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    message:
 *      The C string to display.
 *
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Debug_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Debug_String(message)
	#<span class="enscript-keyword">else</span>
	   #define __Debug_String(message)                                             \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  DEBUG_ASSERT_MESSAGE(                                               \
				  DEBUG_ASSERT_COMPONENT_NAME_STRING,                             \
				  <span class="enscript-string">&quot;&quot;</span>,                                                             \
				  0,                                                              \
				  message,                                                        \
				  __FILE__,                                                       \
				  __LINE__,                                                       \
				  0);                                                             \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Check(assertion)
 *
 *  Summary:
 *    Production builds: does nothing and produces no code.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Check</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Check(assertion)
	#<span class="enscript-keyword">else</span>
	   #define __Check(assertion)                                                 \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, 0, 0, __FILE__, __LINE__, 0 );                  \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nCheck</span>
	#define __nCheck(assertion)  __Check(!(assertion))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Check_String(assertion, message)
 *
 *  Summary:
 *    Production builds: does nothing and produces no code.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Check_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Check_String(assertion, message)
	#<span class="enscript-keyword">else</span>
	   #define __Check_String(assertion, message)                                 \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, 0, message, __FILE__, __LINE__, 0 );            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nCheck_String</span>
	#define __nCheck_String(assertion, message)  __Check_String(!(assertion), message)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Check_noErr(errorCode)
 *
 *  Summary:
 *    Production builds: does nothing and produces no code.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The errorCode expression to compare with 0.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Check_noErr</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Check_noErr(errorCode)
	#<span class="enscript-keyword">else</span>
	   #define __Check_noErr(errorCode)                                           \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, 0, 0, __FILE__, __LINE__, evalOnceErrorCode ); \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Check_noErr_String(errorCode, message)
 *
 *  Summary:
 *    Production builds: check_noerr_string() does nothing and produces
 *    no code.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The errorCode expression to compare to 0.
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Check_noErr_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Check_noErr_String(errorCode, message)
	#<span class="enscript-keyword">else</span>
	   #define __Check_noErr_String(errorCode, message)                           \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, 0, message, __FILE__, __LINE__, evalOnceErrorCode ); \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Verify(assertion)
 *
 *  Summary:
 *    Production builds: evaluate the assertion expression, but ignore
 *    the result.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Verify</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Verify(assertion)                                                \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( !(assertion) )                                                 \
			  {                                                                   \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Verify(assertion)                                                \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, 0, 0, __FILE__, __LINE__, 0 );                  \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nVerify</span>
	#define __nVerify(assertion)	__Verify(!(assertion))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Verify_String(assertion, message)
 *
 *  Summary:
 *    Production builds: evaluate the assertion expression, but ignore
 *    the result.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Verify_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Verify_String(assertion, message)                                \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( !(assertion) )                                                 \
			  {                                                                   \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Verify_String(assertion, message)                                \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, 0, message, __FILE__, __LINE__, 0 );            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nVerify_String</span>
	#define __nVerify_String(assertion, message)  __Verify_String(!(assertion), message)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Verify_noErr(errorCode)
 *
 *  Summary:
 *    Production builds: evaluate the errorCode expression, but ignore
 *    the result.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Verify_noErr</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Verify_noErr(errorCode)                                          \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( 0 != (errorCode) )                                             \
			  {                                                                   \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Verify_noErr(errorCode)                                          \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, 0, 0, __FILE__, __LINE__, evalOnceErrorCode ); \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Verify_noErr_String(errorCode, message)
 *
 *  Summary:
 *    Production builds: evaluate the errorCode expression, but ignore
 *    the result.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Verify_noErr_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Verify_noErr_String(errorCode, message)                          \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( 0 != (errorCode) )                                             \
			  {                                                                   \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Verify_noErr_String(errorCode, message)                          \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, 0, message, __FILE__, __LINE__, evalOnceErrorCode ); \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Verify_noErr_Action(errorCode, action)
 *
 *  Summary:
 *    Production builds: if the errorCode expression does not equal 0 (noErr),
 *    execute the action statement or compound statement (block).
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE and then execute the action statement or compound
 *    statement (block).
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    action:
 *      The statement or compound statement (block).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Verify_noErr_Action</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Verify_noErr_Action(errorCode, action)                          \
		  <span class="enscript-keyword">if</span> ( 0 != (errorCode) ) {                                              \
			  action;                                                            \
		  }                                                                      \
		  <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {} <span class="enscript-keyword">while</span> (0)
	#<span class="enscript-keyword">else</span>
	   #define __Verify_noErr_Action(errorCode, action)                          \
               <span class="enscript-keyword">do</span> {                                                                   \
		  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                                  \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) ) {                   \
			  DEBUG_ASSERT_MESSAGE(                                              \
				  DEBUG_ASSERT_COMPONENT_NAME_STRING,                            \
				  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, 0, 0, __FILE__, __LINE__, evalOnceErrorCode );            \
			  action;                                                            \
		  }                                                                      \
	       } <span class="enscript-keyword">while</span> (0)
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Verify_Action(assertion, action)
 *
 *  Summary:
 *    Production builds: if the assertion expression evaluates to false,
 *    then execute the action statement or compound statement (block).
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE and then execute the action statement or compound
 *    statement (block).
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    action:
 *      The statement or compound statement (block).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Verify_Action</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Verify_Action(assertion, action)                                \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) ) {                             \
			action;                                                              \
		  }                                                                      \
		  <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {} <span class="enscript-keyword">while</span> (0)
	#<span class="enscript-keyword">else</span>
	   #define __Verify_Action(assertion, action)                                \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) ) {                             \
			  DEBUG_ASSERT_MESSAGE(                                              \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                        \
					  #assertion, 0, 0, __FILE__, __LINE__, 0 );                 \
			  action;                                                            \
		  }                                                                      \
		  <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {} <span class="enscript-keyword">while</span> (0)
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require(assertion, exceptionLabel)
 *
 *  Summary:
 *    Production builds: if the assertion expression evaluates to false,
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    exceptionLabel:
 *      The label.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require(assertion, exceptionLabel)                               \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require(assertion, exceptionLabel)                               \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) ) {                          \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, #exceptionLabel, 0, __FILE__, __LINE__,  0);    \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nRequire</span>
	#define __nRequire(assertion, exceptionLabel)  __Require(!(assertion), exceptionLabel)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_Action(assertion, exceptionLabel, action)
 *
 *  Summary:
 *    Production builds: if the assertion expression evaluates to false,
 *    execute the action statement or compound statement (block) and then
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE, execute the action statement or compound
 *    statement (block), and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    action:
 *      The statement or compound statement (block).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_Action</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_Action(assertion, exceptionLabel, action)                \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_Action(assertion, exceptionLabel, action)                \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, #exceptionLabel, 0,   __FILE__, __LINE__, 0);   \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nRequire_Action</span>
	#define __nRequire_Action(assertion, exceptionLabel, action)                  \
	__Require_Action(!(assertion), exceptionLabel, action)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_Quiet(assertion, exceptionLabel)
 *
 *  Summary:
 *    If the assertion expression evaluates to false, goto exceptionLabel.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    exceptionLabel:
 *      The label.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_Quiet</span>
	#define __Require_Quiet(assertion, exceptionLabel)                            \
	  <span class="enscript-keyword">do</span>                                                                          \
	  {                                                                           \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                                \
		  {                                                                       \
			  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                                \
		  }                                                                       \
	  } <span class="enscript-keyword">while</span> ( 0 )
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nRequire_Quiet</span>
	#define __nRequire_Quiet(assertion, exceptionLabel)  __Require_Quiet(!(assertion), exceptionLabel)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_Action_Quiet(assertion, exceptionLabel, action)
 *
 *  Summary:
 *    If the assertion expression evaluates to false, execute the action
 *    statement or compound statement (block), and goto exceptionLabel.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    action:
 *      The statement or compound statement (block).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_Action_Quiet</span>
	#define __Require_Action_Quiet(assertion, exceptionLabel, action)             \
	  <span class="enscript-keyword">do</span>                                                                          \
	  {                                                                           \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                                \
		  {                                                                       \
			  {                                                                   \
				  action;                                                         \
			  }                                                                   \
			  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                                \
		  }                                                                       \
	  } <span class="enscript-keyword">while</span> ( 0 )
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nRequire_Action_Quiet</span>
	#define __nRequire_Action_Quiet(assertion, exceptionLabel, action)              \
		__Require_Action_Quiet(!(assertion), exceptionLabel, action)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_String(assertion, exceptionLabel, message)
 *
 *  Summary:
 *    Production builds: if the assertion expression evaluates to false,
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE, and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_String(assertion, exceptionLabel, message)               \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_String(assertion, exceptionLabel, message)               \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, #exceptionLabel,  message,  __FILE__, __LINE__, 0); \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nRequire_String</span>
	#define __nRequire_String(assertion, exceptionLabel, string)                  \
		__Require_String(!(assertion), exceptionLabel, string)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_Action_String(assertion, exceptionLabel, action, message)
 *
 *  Summary:
 *    Production builds: if the assertion expression evaluates to false,
 *    execute the action statement or compound statement (block), and then
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the assertion expression evaluates to false,
 *    call DEBUG_ASSERT_MESSAGE, execute the action statement or compound
 *    statement (block), and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    assertion:
 *      The assertion expression.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    action:
 *      The statement or compound statement (block).
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_Action_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_Action_String(assertion, exceptionLabel, action, message)  \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_Action_String(assertion, exceptionLabel, action, message)  \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(!(assertion), 0) )                            \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #assertion, #exceptionLabel,  message,  __FILE__,  __LINE__, 0); \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__nRequire_Action_String</span>
	#define __nRequire_Action_String(assertion, exceptionLabel, action, message)    \
		__Require_Action_String(!(assertion), exceptionLabel, action, message)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_noErr(errorCode, exceptionLabel)
 *
 *  Summary:
 *    Production builds: if the errorCode expression does not equal 0 (noErr),
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    exceptionLabel:
 *      The label.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_noErr</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_noErr(errorCode, exceptionLabel)                         \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != (errorCode), 0) )                        \
			  {                                                                   \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_noErr(errorCode, exceptionLabel)                         \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>,  #exceptionLabel,  0,  __FILE__, __LINE__, evalOnceErrorCode); \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_noErr_Action(errorCode, exceptionLabel, action)
 *
 *  Summary:
 *    Production builds: if the errorCode expression does not equal 0 (noErr),
 *    execute the action statement or compound statement (block) and
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE, execute the action statement or
 *    compound statement (block), and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    action:
 *      The statement or compound statement (block).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_noErr_Action</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_noErr_Action(errorCode, exceptionLabel, action)          \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != (errorCode), 0) )                        \
			  {                                                                   \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_noErr_Action(errorCode, exceptionLabel, action)          \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, #exceptionLabel,  0,  __FILE__, __LINE__,  evalOnceErrorCode); \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_noErr_Quiet(errorCode, exceptionLabel)
 *
 *  Summary:
 *    If the errorCode expression does not equal 0 (noErr),
 *    goto exceptionLabel.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    exceptionLabel:
 *      The label.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_noErr_Quiet</span>
	#define __Require_noErr_Quiet(errorCode, exceptionLabel)                      \
	  <span class="enscript-keyword">do</span>                                                                          \
	  {                                                                           \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != (errorCode), 0) )                            \
		  {                                                                       \
			  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                                \
		  }                                                                       \
	  } <span class="enscript-keyword">while</span> ( 0 )
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)
 *
 *  Summary:
 *    If the errorCode expression does not equal 0 (noErr),
 *    execute the action statement or compound statement (block) and
 *    goto exceptionLabel.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    action:
 *      The statement or compound statement (block).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_noErr_Action_Quiet</span>
	#define __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)       \
	  <span class="enscript-keyword">do</span>                                                                          \
	  {                                                                           \
		  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != (errorCode), 0) )                            \
		  {                                                                       \
			  {                                                                   \
				  action;                                                         \
			  }                                                                   \
			  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                                \
		  }                                                                       \
	  } <span class="enscript-keyword">while</span> ( 0 )
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_noErr_String(errorCode, exceptionLabel, message)
 *
 *  Summary:
 *    Production builds: if the errorCode expression does not equal 0 (noErr),
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE, and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_noErr_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_noErr_String(errorCode, exceptionLabel, message)         \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != (errorCode), 0) )                        \
			  {                                                                   \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_noErr_String(errorCode, exceptionLabel, message)         \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>,  #exceptionLabel, message, __FILE__,  __LINE__,  evalOnceErrorCode); \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Require_noErr_Action_String(errorCode, exceptionLabel, action, message)
 *
 *  Summary:
 *    Production builds: if the errorCode expression does not equal 0 (noErr),
 *    execute the action statement or compound statement (block) and
 *    goto exceptionLabel.
 *
 *    Non-production builds: if the errorCode expression does not equal 0 (noErr),
 *    call DEBUG_ASSERT_MESSAGE, execute the action statement or compound
 *    statement (block), and then goto exceptionLabel.
 *
 *  Parameters:
 *
 *    errorCode:
 *      The expression to compare to 0.
 *
 *    exceptionLabel:
 *      The label.
 *
 *    action:
 *      The statement or compound statement (block).
 *
 *    message:
 *      The C string to display.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Require_noErr_Action_String</span>
	#<span class="enscript-keyword">if</span> DEBUG_ASSERT_PRODUCTION_CODE
	   #define __Require_noErr_Action_String(errorCode, exceptionLabel, action, message) \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != (errorCode), 0) )                        \
			  {                                                                   \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#<span class="enscript-keyword">else</span>
	   #define __Require_noErr_Action_String(errorCode, exceptionLabel, action, message) \
		  <span class="enscript-keyword">do</span>                                                                      \
		  {                                                                       \
			  <span class="enscript-type">long</span> evalOnceErrorCode = (errorCode);                               \
			  <span class="enscript-keyword">if</span> ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \
			  {                                                                   \
				  DEBUG_ASSERT_MESSAGE(                                           \
					  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \
					  #errorCode <span class="enscript-string">&quot; == 0 &quot;</span>, #exceptionLabel, message, __FILE__, __LINE__, evalOnceErrorCode); \
				  {                                                               \
					  action;                                                     \
				  }                                                               \
				  <span class="enscript-keyword">goto</span> <span class="enscript-reference">exceptionLabel</span>;                                            \
			  }                                                                   \
		  } <span class="enscript-keyword">while</span> ( 0 )
	#endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  __Check_Compile_Time(expr)
 *
 *  Summary:
 *    any build: if the expression is not true, generated a compile time error.
 *
 *  Parameters:
 *
 *    expr:
 *      The compile time expression that should evaluate to non-zero.
 *
 *  Discussion:
 *     This declares an array with a size that is determined by a compile-time expression.
 *     If false, it declares a negatively sized array, which generates a compile-time error.
 *
 * Examples:
 *     __Check_Compile_Time( sizeof( int ) == 4 );
 *     __Check_Compile_Time( offsetof( MyStruct, myField ) == 4 );
 *     __Check_Compile_Time( ( kMyBufferSize % 512 ) == 0 );
 *
 *  Note: This only works with compile-time expressions.
 *  Note: This only works in places where extern declarations are allowed (e.g. global scope).
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__Check_Compile_Time</span>
    #ifdef __GNUC__ 
        #define __Check_Compile_Time( expr )    \
            <span class="enscript-type">extern</span> <span class="enscript-type">int</span> compile_time_assert_failed[ ( expr ) ? 1 : -1 ] __attribute__( ( unused ) )
    #<span class="enscript-keyword">else</span>
        #define __Check_Compile_Time( expr )    \
            <span class="enscript-type">extern</span> <span class="enscript-type">int</span> compile_time_assert_failed[ ( expr ) ? 1 : -1 ]
    #endif
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	For time immemorial, Mac OS X has defined version of most of these macros without the __ prefix, which
 *	could collide with similarly named functions or macros in user code, including new functionality in
 *	Boost and the C++ standard library.
 *
 *	A future release of Mac OS X will no longer do this, and will require that clients move to the
 *  new macros as defined above.  However, in the interim both the new and old macros will work, unless
 *  clients define a macro __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES before this file is included
 *  in their compilations.  Clients who do not want the older macros defined can accomplish this by adding
 *    #define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
 *  at the top of their sources, or my adding -D__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES=0 to the
 *  gcc compilation options.
 *
 *  To aid users of these macros in converting their sources, the following tops script will convert usages
 *  of the old macros into the new equivalents.  To do so, in Terminal go into the directory containing the
 *  sources to be converted and run this command.
 *
    find . -name '*.[c|cc|cp|cpp|m|mm|h]' -print0 |  xargs -0 tops -verbose \
      replace &quot;check(&lt;b args&gt;)&quot; with &quot;__Check(&lt;args&gt;)&quot; \
      replace &quot;check_noerr(&lt;b args&gt;)&quot; with &quot;__Check_noErr(&lt;args&gt;)&quot; \
      replace &quot;check_noerr_string(&lt;b args&gt;)&quot; with &quot;__Check_noErr_String(&lt;args&gt;)&quot; \
      replace &quot;check_string(&lt;b args&gt;)&quot; with &quot;__Check_String(&lt;args&gt;)&quot; \
      replace &quot;require(&lt;b args&gt;)&quot; with &quot;__Require(&lt;args&gt;)&quot; \
      replace &quot;require_action(&lt;b args&gt;)&quot; with &quot;__Require_Action(&lt;args&gt;)&quot; \
      replace &quot;require_action_string(&lt;b args&gt;)&quot; with &quot;__Require_Action_String(&lt;args&gt;)&quot; \
      replace &quot;require_noerr(&lt;b args&gt;)&quot; with &quot;__Require_noErr(&lt;args&gt;)&quot; \
      replace &quot;require_noerr_action(&lt;b args&gt;)&quot; with &quot;__Require_noErr_Action(&lt;args&gt;)&quot; \
      replace &quot;require_noerr_action_string(&lt;b args&gt;)&quot; with &quot;__Require_noErr_Action_String(&lt;args&gt;)&quot; \
      replace &quot;require_noerr_string(&lt;b args&gt;)&quot; with &quot;__Require_noErr_String(&lt;args&gt;)&quot; \
      replace &quot;require_string(&lt;b args&gt;)&quot; with &quot;__Require_String(&lt;args&gt;)&quot; \
      replace &quot;verify(&lt;b args&gt;)&quot; with &quot;__Verify(&lt;args&gt;)&quot; \
      replace &quot;verify_action(&lt;b args&gt;)&quot; with &quot;__Verify_Action(&lt;args&gt;)&quot; \
      replace &quot;verify_noerr(&lt;b args&gt;)&quot; with &quot;__Verify_noErr(&lt;args&gt;)&quot; \
      replace &quot;verify_noerr_action(&lt;b args&gt;)&quot; with &quot;__Verify_noErr_Action(&lt;args&gt;)&quot; \
      replace &quot;verify_noerr_string(&lt;b args&gt;)&quot; with &quot;__Verify_noErr_String(&lt;args&gt;)&quot; \
      replace &quot;verify_string(&lt;b args&gt;)&quot; with &quot;__Verify_String(&lt;args&gt;)&quot; \
      replace &quot;ncheck(&lt;b args&gt;)&quot; with &quot;__nCheck(&lt;args&gt;)&quot; \
      replace &quot;ncheck_string(&lt;b args&gt;)&quot; with &quot;__nCheck_String(&lt;args&gt;)&quot; \
      replace &quot;nrequire(&lt;b args&gt;)&quot; with &quot;__nRequire(&lt;args&gt;)&quot; \
      replace &quot;nrequire_action(&lt;b args&gt;)&quot; with &quot;__nRequire_Action(&lt;args&gt;)&quot; \
      replace &quot;nrequire_action_quiet(&lt;b args&gt;)&quot; with &quot;__nRequire_Action_Quiet(&lt;args&gt;)&quot; \
      replace &quot;nrequire_action_string(&lt;b args&gt;)&quot; with &quot;__nRequire_Action_String(&lt;args&gt;)&quot; \
      replace &quot;nrequire_quiet(&lt;b args&gt;)&quot; with &quot;__nRequire_Quiet(&lt;args&gt;)&quot; \
      replace &quot;nrequire_string(&lt;b args&gt;)&quot; with &quot;__nRequire_String(&lt;args&gt;)&quot; \
      replace &quot;nverify(&lt;b args&gt;)&quot; with &quot;__nVerify(&lt;args&gt;)&quot; \
      replace &quot;nverify_string(&lt;b args&gt;)&quot; with &quot;__nVerify_String(&lt;args&gt;)&quot; \
      replace &quot;require_action_quiet(&lt;b args&gt;)&quot; with &quot;__Require_Action_Quiet(&lt;args&gt;)&quot; \
      replace &quot;require_noerr_action_quiet(&lt;b args&gt;)&quot; with &quot;__Require_noErr_Action_Quiet(&lt;args&gt;)&quot; \
      replace &quot;require_noerr_quiet(&lt;b args&gt;)&quot; with &quot;__Require_noErr_Quiet(&lt;args&gt;)&quot; \
      replace &quot;require_quiet(&lt;b args&gt;)&quot; with &quot;__Require_Quiet(&lt;args&gt;)&quot; \
      replace &quot;check_compile_time(&lt;b args&gt;)&quot; with &quot;__Check_Compile_Time(&lt;args&gt;)&quot; \
      replace &quot;debug_string(&lt;b args&gt;)&quot; with &quot;__Debug_String(&lt;args&gt;)&quot;
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES</span>
	<span class="enscript-comment">/* If we haven't set this yet, it defaults to on.  In the next release, this will default to off. */</span>
	#define	__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES	1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES</span>

	#ifndef check
	#define check(assertion)  __Check(assertion)
	#endif

	#ifndef check_noerr
	#define check_noerr(errorCode)  __Check_noErr(errorCode)
	#endif

	#ifndef check_noerr_string
		#define check_noerr_string(errorCode, message)  __Check_noErr_String(errorCode, message)
	#endif

	#ifndef check_string
		#define check_string(assertion, message)  __Check_String(assertion, message)
	#endif

	#ifndef require
		#define require(assertion, exceptionLabel)  __Require(assertion, exceptionLabel)
	#endif

	#ifndef require_action
		#define require_action(assertion, exceptionLabel, action)  __Require_Action(assertion, exceptionLabel, action)
	#endif

	#ifndef require_action_string
		#define require_action_string(assertion, exceptionLabel, action, message)  __Require_Action_String(assertion, exceptionLabel, action, message)
	#endif

	#ifndef require_noerr
		#define require_noerr(errorCode, exceptionLabel)  __Require_noErr(errorCode, exceptionLabel)
	#endif

	#ifndef require_noerr_action
		#define require_noerr_action(errorCode, exceptionLabel, action)  __Require_noErr_Action(errorCode, exceptionLabel, action)
	#endif

	#ifndef require_noerr_action_string
		#define require_noerr_action_string(errorCode, exceptionLabel, action, message)  __Require_noErr_Action_String(errorCode, exceptionLabel, action, message)
	#endif

	#ifndef require_noerr_string
		#define require_noerr_string(errorCode, exceptionLabel, message)  __Require_noErr_String(errorCode, exceptionLabel, message)
	#endif

	#ifndef require_string
		#define require_string(assertion, exceptionLabel, message)  __Require_String(assertion, exceptionLabel, message)
	#endif

	#ifndef verify
		#define verify(assertion) __Verify(assertion)
	#endif

	#ifndef verify_action
		#define verify_action(assertion, action)  __Verify_Action(assertion, action)
	#endif

	#ifndef verify_noerr
		#define verify_noerr(errorCode)  __Verify_noErr(errorCode)
	#endif

	#ifndef verify_noerr_action
		#define verify_noerr_action(errorCode, action)  __Verify_noErr_Action(errorCode, action)
	#endif

	#ifndef verify_noerr_string
		#define verify_noerr_string(errorCode, message)  __Verify_noErr_String(errorCode, message)
	#endif

	#ifndef verify_string
		#define verify_string(assertion, message)  __Verify_String(assertion, message)
	#endif

	#ifndef ncheck
		#define ncheck(assertion)  __nCheck(assertion)
	#endif

	#ifndef ncheck_string
		#define ncheck_string(assertion, message)  __nCheck_String(assertion, message)
	#endif

	#ifndef nrequire
		#define nrequire(assertion, exceptionLabel)  __nRequire(assertion, exceptionLabel)
	#endif

	#ifndef nrequire_action
		#define nrequire_action(assertion, exceptionLabel, action)  __nRequire_Action(assertion, exceptionLabel, action)
	#endif

	#ifndef nrequire_action_quiet
		#define nrequire_action_quiet(assertion, exceptionLabel, action)  __nRequire_Action_Quiet(assertion, exceptionLabel, action)
	#endif

	#ifndef nrequire_action_string
		#define nrequire_action_string(assertion, exceptionLabel, action, message)  __nRequire_Action_String(assertion, exceptionLabel, action, message)
	#endif

	#ifndef nrequire_quiet
		#define nrequire_quiet(assertion, exceptionLabel)  __nRequire_Quiet(assertion, exceptionLabel)
	#endif

	#ifndef nrequire_string
		#define nrequire_string(assertion, exceptionLabel, string)  __nRequire_String(assertion, exceptionLabel, string)
	#endif

	#ifndef nverify
		#define nverify(assertion)  __nVerify(assertion)
	#endif

	#ifndef nverify_string
		#define nverify_string(assertion, message)  __nVerify_String(assertion, message)
	#endif

	#ifndef require_action_quiet
		#define require_action_quiet(assertion, exceptionLabel, action)  __Require_Action_Quiet(assertion, exceptionLabel, action)
	#endif

	#ifndef require_noerr_action_quiet
		#define require_noerr_action_quiet(errorCode, exceptionLabel, action)  __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)
	#endif

	#ifndef require_noerr_quiet
		#define require_noerr_quiet(errorCode, exceptionLabel)  __Require_noErr_Quiet(errorCode, exceptionLabel)
	#endif

	#ifndef require_quiet
		#define require_quiet(assertion, exceptionLabel)  __Require_Quiet(assertion, exceptionLabel)
	#endif

	#ifndef check_compile_time
		#define check_compile_time( expr )  __Check_Compile_Time( expr )
	#endif

	#ifndef debug_string
		#define debug_string(message)  __Debug_String(message)
	#endif
	
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES */</span>


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __ASSERTMACROS__ */</span>
</pre>
<hr />
</body></html>