<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>bootstrap.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">bootstrap.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kmod.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/prelink.h&gt;</span>
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/version.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSKextLibPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceTreeSupport.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCatalogue.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span> 0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Bootstrap</span> <span class="enscript-variable-name">Declarations</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Bootstrap Declarations
*
* The ENTIRE point of the libsa/KLD segment is to isolate bootstrap
* code from other parts of the kernel, so function symbols are not
* exported; rather pointers to those functions are exported.
*
* xxx - need to think about locking for handling the 'weak' refs.
* xxx - do export a non-KLD function that says you've called a
* xxx - bootstrap function that has been removed.
*
* ALL call-ins to this segment of the kernel must be done through
* exported pointers. The symbols themselves are private and not to
* be linked against.
*********************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
    <span class="enscript-type">extern</span> <span class="enscript-type">void</span> (*record_startup_extensions_function)(<span class="enscript-type">void</span>);
    <span class="enscript-type">extern</span> <span class="enscript-type">void</span> (*load_security_extensions_function)(<span class="enscript-type">void</span>);
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bootstrapRecordStartupExtensions</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bootstrapLoadSecurityExtensions</span>(<span class="enscript-type">void</span>);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NO_KEXTD</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">bool</span> IORamDiskBSDRoot(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Macros</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Macros
*********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CONST_STRLEN</span>(str) (sizeof(str) - 1)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Kernel</span> <span class="enscript-variable-name">Component</span> <span class="enscript-variable-name">Kext</span> <span class="enscript-variable-name">Identifiers</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Kernel Component Kext Identifiers
*
* We could have each kernel resource kext automatically &quot;load&quot; as
* it's created, but it's nicer to have them listed in kextstat in
* the order of this list. We'll walk through this after setting up
* all the boot kexts and have them load up.
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * sKernelComponentNames[] = {
   <span class="enscript-comment">// The kexts for these IDs must have a version matching 'osrelease'.
</span>   <span class="enscript-string">&quot;com.apple.kernel&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.bsd&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.dsep&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.iokit&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.libkern&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.mach&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.private&quot;</span>,
   <span class="enscript-string">&quot;com.apple.kpi.unsupported&quot;</span>,
   <span class="enscript-string">&quot;com.apple.iokit.IONVRAMFamily&quot;</span>,
   <span class="enscript-string">&quot;com.apple.driver.AppleNMI&quot;</span>,
   <span class="enscript-string">&quot;com.apple.iokit.IOSystemManagementFamily&quot;</span>,
   <span class="enscript-string">&quot;com.apple.iokit.ApplePlatformFamily&quot;</span>,
   NULL
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">KLDBootstrap</span> <span class="enscript-variable-name">Class</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* KLDBootstrap Class
*
* We use a C++ class here so that it can be a friend of OSKext and
* get at private stuff. We can't hide the class itself, but we can
* hide the instance through which we invoke the functions.
*********************************************************************/</span>
<span class="enscript-type">class</span> KLDBootstrap {
    <span class="enscript-type">friend</span> <span class="enscript-type">void</span> bootstrapRecordStartupExtensions(<span class="enscript-type">void</span>);
    <span class="enscript-type">friend</span> <span class="enscript-type">void</span> bootstrapLoadSecurityExtensions(<span class="enscript-type">void</span>);

<span class="enscript-type">private</span>:
    <span class="enscript-type">void</span> readStartupExtensions(<span class="enscript-type">void</span>);

    <span class="enscript-type">void</span> readPrelinkedExtensions(
        kernel_section_t * prelinkInfoSect);
    <span class="enscript-type">void</span> readBooterExtensions(<span class="enscript-type">void</span>);
    
    OSReturn loadKernelComponentKexts(<span class="enscript-type">void</span>);
    <span class="enscript-type">void</span>     loadKernelExternalComponents(<span class="enscript-type">void</span>);
    <span class="enscript-type">void</span>     readBuiltinPersonalities(<span class="enscript-type">void</span>);

    <span class="enscript-type">void</span>     loadSecurityExtensions(<span class="enscript-type">void</span>);
    
<span class="enscript-type">public</span>:
    KLDBootstrap(<span class="enscript-type">void</span>);
    ~KLDBootstrap(<span class="enscript-type">void</span>);
};

<span class="enscript-type">static</span> KLDBootstrap sBootstrapObject;

<span class="enscript-comment">/*********************************************************************
* Set the function pointers for the entry points into the bootstrap
* segment upon C++ static constructor invocation.
*********************************************************************/</span>
<span class="enscript-function-name">KLDBootstrap::KLDBootstrap</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> != &amp;sBootstrapObject) {
        panic(<span class="enscript-string">&quot;Attempt to access bootstrap segment.&quot;</span>);
    }
    record_startup_extensions_function = &amp;bootstrapRecordStartupExtensions;
    load_security_extensions_function = &amp;bootstrapLoadSecurityExtensions;
}

<span class="enscript-comment">/*********************************************************************
* Clear the function pointers for the entry points into the bootstrap
* segment upon C++ static destructor invocation.
*********************************************************************/</span>
<span class="enscript-function-name">KLDBootstrap::~KLDBootstrap</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> != &amp;sBootstrapObject) {
        panic(<span class="enscript-string">&quot;Attempt to access bootstrap segment.&quot;</span>);
    }


    record_startup_extensions_function = 0;
    load_security_extensions_function = 0;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">KLDBootstrap::readStartupExtensions</span>(<span class="enscript-type">void</span>)
{
    kernel_section_t * prelinkInfoSect = NULL;  <span class="enscript-comment">// do not free
</span>
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogGeneralFlag | kOSKextLogDirectoryScanFlag |
        kOSKextLogKextBookkeepingFlag,
        <span class="enscript-string">&quot;Reading startup extensions.&quot;</span>);
    
   <span class="enscript-comment">/* If the prelink info segment has a nonzero size, we are prelinked
    * and won't have any individual kexts or mkexts to read.
    * Otherwise, we need to read kexts or the mkext from what the booter
    * has handed us.
    */</span>
    prelinkInfoSect = getsectbyname(kPrelinkInfoSegment, kPrelinkInfoSection);
    <span class="enscript-keyword">if</span> (prelinkInfoSect-&gt;size) {
        readPrelinkedExtensions(prelinkInfoSect);
    } <span class="enscript-keyword">else</span> {
        readBooterExtensions();
    }

    loadKernelComponentKexts();
    loadKernelExternalComponents();
    readBuiltinPersonalities();
    <span class="enscript-reference">OSKext</span>::sendAllKextPersonalitiesToCatalog();

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">KLDBootstrap::readPrelinkedExtensions</span>(
    kernel_section_t * prelinkInfoSect)
{
    OSArray                   * infoDictArray           = NULL;  <span class="enscript-comment">// do not release
</span>    OSObject                  * parsedXML       = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary              * prelinkInfoDict         = NULL;  <span class="enscript-comment">// do not release
</span>    OSString                  * errorString             = NULL;  <span class="enscript-comment">// must release
</span>    OSKext                    * theKernel               = NULL;  <span class="enscript-comment">// must release
</span>
    kernel_segment_command_t  * prelinkTextSegment      = NULL;  <span class="enscript-comment">// see code
</span>    kernel_segment_command_t  * prelinkInfoSegment      = NULL;  <span class="enscript-comment">// see code
</span>
   <span class="enscript-comment">/* We make some copies of data, but if anything fails we're basically
    * going to fail the boot, so these won't be cleaned up on error.
    */</span>
    <span class="enscript-type">void</span>                      * prelinkData             = NULL;  <span class="enscript-comment">// see code
</span>    vm_size_t                   prelinkLength           = 0;


    OSDictionary              * infoDict                = NULL;  <span class="enscript-comment">// do not release
</span>
    IORegistryEntry           * registryRoot            = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber                  * prelinkCountObj         = NULL;  <span class="enscript-comment">// must release
</span>
    u_int                       i = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NO_KEXTD</span>
    <span class="enscript-type">bool</span>                        ramDiskBoot;
    <span class="enscript-type">bool</span>                        developerDevice;
    <span class="enscript-type">bool</span>                        dontLoad;
#<span class="enscript-reference">endif</span>

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogDirectoryScanFlag | kOSKextLogArchiveFlag,
        <span class="enscript-string">&quot;Starting from prelinked kernel.&quot;</span>);

    prelinkTextSegment = getsegbyname(kPrelinkTextSegment);
    <span class="enscript-keyword">if</span> (!prelinkTextSegment) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogDirectoryScanFlag | kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Can't find prelinked kexts' text segment.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   scratchSize;
    vm_offset_t     scratchAddr;
    
    IOLog(<span class="enscript-string">&quot;kaslr: prelinked kernel address info: \n&quot;</span>);
    
    scratchAddr = (vm_offset_t) getsegdatafromheader(&amp;_mh_execute_header, <span class="enscript-string">&quot;__TEXT&quot;</span>, &amp;scratchSize);
    IOLog(<span class="enscript-string">&quot;kaslr: start 0x%lx end 0x%lx length %lu for __TEXT \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)scratchAddr, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(scratchAddr + scratchSize),
          scratchSize);
    
    scratchAddr = (vm_offset_t) getsegdatafromheader(&amp;_mh_execute_header, <span class="enscript-string">&quot;__DATA&quot;</span>, &amp;scratchSize);
    IOLog(<span class="enscript-string">&quot;kaslr: start 0x%lx end 0x%lx length %lu for __DATA \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)scratchAddr, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(scratchAddr + scratchSize),
          scratchSize);
    
    scratchAddr = (vm_offset_t) getsegdatafromheader(&amp;_mh_execute_header, <span class="enscript-string">&quot;__LINKEDIT&quot;</span>, &amp;scratchSize);
    IOLog(<span class="enscript-string">&quot;kaslr: start 0x%lx end 0x%lx length %lu for __LINKEDIT \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)scratchAddr, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(scratchAddr + scratchSize),
          scratchSize);
    
    scratchAddr = (vm_offset_t) getsegdatafromheader(&amp;_mh_execute_header, <span class="enscript-string">&quot;__KLD&quot;</span>, &amp;scratchSize);
    IOLog(<span class="enscript-string">&quot;kaslr: start 0x%lx end 0x%lx length %lu for __KLD \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)scratchAddr, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(scratchAddr + scratchSize),
          scratchSize);
    
    scratchAddr = (vm_offset_t) getsegdatafromheader(&amp;_mh_execute_header, <span class="enscript-string">&quot;__PRELINK_TEXT&quot;</span>, &amp;scratchSize);
    IOLog(<span class="enscript-string">&quot;kaslr: start 0x%lx end 0x%lx length %lu for __PRELINK_TEXT \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)scratchAddr, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(scratchAddr + scratchSize),
          scratchSize);
    
    scratchAddr = (vm_offset_t) getsegdatafromheader(&amp;_mh_execute_header, <span class="enscript-string">&quot;__PRELINK_INFO&quot;</span>, &amp;scratchSize);
    IOLog(<span class="enscript-string">&quot;kaslr: start 0x%lx end 0x%lx length %lu for __PRELINK_INFO \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)scratchAddr, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(scratchAddr + scratchSize),
          scratchSize);
#<span class="enscript-reference">endif</span>

    prelinkData = (<span class="enscript-type">void</span> *) prelinkTextSegment-&gt;vmaddr;
    prelinkLength = prelinkTextSegment-&gt;vmsize;


   <span class="enscript-comment">/* Unserialize the info dictionary from the prelink info section.
    */</span>
    parsedXML = OSUnserializeXML((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)prelinkInfoSect-&gt;addr,
        &amp;errorString);
    <span class="enscript-keyword">if</span> (parsedXML) {
        prelinkInfoDict = OSDynamicCast(OSDictionary, parsedXML);
    }
    <span class="enscript-keyword">if</span> (!prelinkInfoDict) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * errorCString = <span class="enscript-string">&quot;(unknown error)&quot;</span>;
        
        <span class="enscript-keyword">if</span> (errorString &amp;&amp; errorString-&gt;getCStringNoCopy()) {
            errorCString = errorString-&gt;getCStringNoCopy();
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parsedXML) {
            errorCString = <span class="enscript-string">&quot;not a dictionary&quot;</span>;
        }
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL, kOSKextLogErrorLevel | kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Error unserializing prelink plist: %s.&quot;</span>, errorCString);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NO_KEXTD</span>
    <span class="enscript-comment">/* Check if we should keep developer kexts around.
     * TODO: Check DeviceTree instead of a boot-arg &lt;rdar://problem/10604201&gt;
     */</span>
    developerDevice = true;
    PE_parse_boot_argn(<span class="enscript-string">&quot;developer&quot;</span>, &amp;developerDevice, <span class="enscript-keyword">sizeof</span>(developerDevice));

    ramDiskBoot = IORamDiskBSDRoot();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_KEXTD */</span>

    infoDictArray = OSDynamicCast(OSArray, 
        prelinkInfoDict-&gt;getObject(kPrelinkInfoDictionaryKey));
    <span class="enscript-keyword">if</span> (!infoDictArray) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL, kOSKextLogErrorLevel | kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;The prelinked kernel has no kext info dictionaries&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">/* Create dictionary of excluded kexts
     */</span>
    <span class="enscript-reference">OSKext</span>::createExcludeListFromPrelinkInfo(infoDictArray);

    <span class="enscript-comment">/* Create OSKext objects for each info dictionary. 
     */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; infoDictArray-&gt;getCount(); ++i) {
        infoDict = OSDynamicCast(OSDictionary, infoDictArray-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!infoDict) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogDirectoryScanFlag | kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Can't find info dictionary for prelinked kext #%d.&quot;</span>, i);
            <span class="enscript-keyword">continue</span>;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NO_KEXTD</span>
        dontLoad = false;

        <span class="enscript-comment">/* If we're not on a developer device, skip and free developer kexts.
         */</span>
        <span class="enscript-keyword">if</span> (developerDevice == false) {
            OSBoolean *devOnlyBool = OSDynamicCast(OSBoolean,
                infoDict-&gt;getObject(kOSBundleDeveloperOnlyKey));
            <span class="enscript-keyword">if</span> (devOnlyBool == kOSBooleanTrue) {
                dontLoad = true;
            }
        }

        <span class="enscript-comment">/* Skip and free kexts that are only needed when booted from a ram disk.
         */</span>
        <span class="enscript-keyword">if</span> (ramDiskBoot == false) {
            OSBoolean *ramDiskOnlyBool = OSDynamicCast(OSBoolean,
                infoDict-&gt;getObject(kOSBundleRamDiskOnlyKey));
            <span class="enscript-keyword">if</span> (ramDiskOnlyBool == kOSBooleanTrue) {
                dontLoad = true;
            }
	}

        <span class="enscript-keyword">if</span> (dontLoad == true) {
            OSString *bundleID = OSDynamicCast(OSString,
                infoDict-&gt;getObject(kCFBundleIdentifierKey));
            <span class="enscript-keyword">if</span> (bundleID) {
                OSKextLog(NULL, kOSKextLogWarningLevel | kOSKextLogGeneralFlag,
                    <span class="enscript-string">&quot;Kext %s not loading.&quot;</span>, bundleID-&gt;getCStringNoCopy());
            }
            
            OSNumber *addressNum = OSDynamicCast(OSNumber,
                infoDict-&gt;getObject(kPrelinkExecutableLoadKey));
            OSNumber *lengthNum = OSDynamicCast(OSNumber,
                infoDict-&gt;getObject(kPrelinkExecutableSizeKey));
            <span class="enscript-keyword">if</span> (addressNum &amp;&amp; lengthNum) {
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Pick</span> <span class="enscript-variable-name">the</span> <span class="enscript-variable-name">right</span> <span class="enscript-variable-name">way</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">free</span> <span class="enscript-variable-name">prelinked</span> <span class="enscript-variable-name">data</span> <span class="enscript-variable-name">on</span> <span class="enscript-variable-name">this</span> <span class="enscript-variable-name">arch</span>
            }

            infoDictArray-&gt;removeObject(i--);
            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_KEXTD */</span>

       <span class="enscript-comment">/* Create the kext for the entry, then release it, because the
        * kext system keeps them around until explicitly removed.
        * Any creation/registration failures are already logged for us.
        */</span>
        OSKext * newKext = OSKext::withPrelinkedInfoDict(infoDict);
        OSSafeReleaseNULL(newKext);
    }
    
   <span class="enscript-comment">/* Store the number of prelinked kexts in the registry so we can tell
    * when the system has been started from a prelinked kernel.
    */</span>
    registryRoot = IORegistryEntry::getRegistryRoot();
    assert(registryRoot);

    prelinkCountObj = OSNumber::withNumber(
        (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)infoDictArray-&gt;getCount(),
        8 * <span class="enscript-keyword">sizeof</span>(uint32_t));
    assert(prelinkCountObj);
    <span class="enscript-keyword">if</span> (prelinkCountObj) {
        registryRoot-&gt;setProperty(kOSPrelinkKextCountKey, prelinkCountObj);
    }

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogGeneralFlag | kOSKextLogKextBookkeepingFlag |
        kOSKextLogDirectoryScanFlag | kOSKextLogArchiveFlag,
        <span class="enscript-string">&quot;%u prelinked kexts&quot;</span>, 
        infoDictArray-&gt;getCount());

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEXT_BASEMENT</span>
        <span class="enscript-comment">/* On CONFIG_KEXT_BASEMENT systems, kexts are copied to their own 
         * special VM region during OSKext init time, so we can free the whole 
         * segment now.
         */</span>
        ml_static_mfree((vm_offset_t) prelinkData, prelinkLength);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __x86_64__ */</span>

   <span class="enscript-comment">/* Free the prelink info segment, we're done with it.
    */</span>
    prelinkInfoSegment = getsegbyname(kPrelinkInfoSegment);
    <span class="enscript-keyword">if</span> (prelinkInfoSegment) {
        ml_static_mfree((vm_offset_t)prelinkInfoSegment-&gt;vmaddr,
            (vm_size_t)prelinkInfoSegment-&gt;vmsize);
    }

<span class="enscript-reference">finish</span>:
    OSSafeRelease(errorString);
    OSSafeRelease(parsedXML);
    OSSafeRelease(theKernel);
    OSSafeRelease(prelinkCountObj);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOOTER_KEXT_PREFIX</span>   <span class="enscript-string">&quot;Driver-&quot;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _DeviceTreeBuffer {
    uint32_t paddr;
    uint32_t length;
} _DeviceTreeBuffer;

<span class="enscript-type">void</span>
<span class="enscript-function-name">KLDBootstrap::readBooterExtensions</span>(<span class="enscript-type">void</span>)
{
    IORegistryEntry           * booterMemoryMap         = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary              * propertyDict            = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator      * keyIterator             = NULL;  <span class="enscript-comment">// must release
</span>    OSString                  * deviceTreeName          = NULL;  <span class="enscript-comment">// do not release
</span>    
    <span class="enscript-type">const</span> _DeviceTreeBuffer   * deviceTreeBuffer        = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">char</span>                      * booterDataPtr           = NULL;  <span class="enscript-comment">// do not free
</span>    OSData                    * booterData              = NULL;  <span class="enscript-comment">// must release
</span>
    OSKext                    * aKext                   = NULL;  <span class="enscript-comment">// must release
</span>
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogDirectoryScanFlag | kOSKextLogKextBookkeepingFlag,
        <span class="enscript-string">&quot;Reading startup extensions from booter memory.&quot;</span>);
    
    booterMemoryMap = IORegistryEntry::fromPath( <span class="enscript-string">&quot;/chosen/memory-map&quot;</span>, gIODTPlane);

    <span class="enscript-keyword">if</span> (!booterMemoryMap) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag | kOSKextLogDirectoryScanFlag,
            <span class="enscript-string">&quot;Can't read booter memory map.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    propertyDict = booterMemoryMap-&gt;dictionaryWithProperties();
    <span class="enscript-keyword">if</span> (!propertyDict) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogDirectoryScanFlag,
            <span class="enscript-string">&quot;Can't get property dictionary from memory map.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    keyIterator = OSCollectionIterator::withCollection(propertyDict);
    <span class="enscript-keyword">if</span> (!keyIterator) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Can't allocate iterator for driver images.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Create dictionary of excluded kexts
     */</span>
    <span class="enscript-reference">OSKext</span>::createExcludeListFromBooterData(propertyDict, keyIterator);
    keyIterator-&gt;reset();

    <span class="enscript-keyword">while</span> ( ( deviceTreeName =
        OSDynamicCast(OSString, keyIterator-&gt;getNextObject() ))) {

        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * devTreeNameCString = deviceTreeName-&gt;getCStringNoCopy();
        OSData * deviceTreeEntry = OSDynamicCast(OSData,
            propertyDict-&gt;getObject(deviceTreeName));

       <span class="enscript-comment">/* Clear out the booterData from the prior iteration.
        */</span>
        OSSafeReleaseNULL(booterData);

        <span class="enscript-comment">/* If there is no entry for the name, we can't do much with it. */</span>
        <span class="enscript-keyword">if</span> (!deviceTreeEntry) {
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">/* Make sure it is a kext */</span>
        <span class="enscript-keyword">if</span> (strncmp(devTreeNameCString,
                    BOOTER_KEXT_PREFIX,
                    CONST_STRLEN(BOOTER_KEXT_PREFIX))) {
            <span class="enscript-keyword">continue</span>;
        }

        deviceTreeBuffer = (<span class="enscript-type">const</span> _DeviceTreeBuffer *)
            deviceTreeEntry-&gt;getBytesNoCopy(0, <span class="enscript-keyword">sizeof</span>(deviceTreeBuffer));
        <span class="enscript-keyword">if</span> (!deviceTreeBuffer) {
           <span class="enscript-comment">/* We can't get to the data, so we can't do anything,
            * not even free it from physical memory (if it's there).
            */</span>
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogDirectoryScanFlag,
                <span class="enscript-string">&quot;Device tree entry %s has NULL pointer.&quot;</span>,
                devTreeNameCString);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;  <span class="enscript-comment">// xxx - continue, panic?
</span>        }

        booterDataPtr = (<span class="enscript-type">char</span> *)ml_static_ptovirt(deviceTreeBuffer-&gt;paddr);
        <span class="enscript-keyword">if</span> (!booterDataPtr) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogDirectoryScanFlag,
                <span class="enscript-string">&quot;Can't get virtual address for device tree entry %s.&quot;</span>,
                devTreeNameCString);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* Wrap the booter data buffer in an OSData and set a dealloc function
        * so it will take care of the physical memory when freed. Kexts will
        * retain the booterData for as long as they need it. Remove the entry
        * from the booter memory map after this is done.
        */</span>
        booterData = OSData::withBytesNoCopy(booterDataPtr,
            deviceTreeBuffer-&gt;length);
        <span class="enscript-keyword">if</span> (!booterData) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag,
                <span class="enscript-string">&quot;Error - Can't allocate OSData wrapper for device tree entry %s.&quot;</span>,
                devTreeNameCString);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        booterData-&gt;setDeallocFunction(osdata_phys_free);

        <span class="enscript-comment">/* Create the kext for the entry, then release it, because the
         * kext system keeps them around until explicitly removed.
         * Any creation/registration failures are already logged for us.
         */</span>
        OSKext * newKext = OSKext::withBooterData(deviceTreeName, booterData);
        OSSafeRelease(newKext);

        booterMemoryMap-&gt;removeProperty(deviceTreeName);

    } <span class="enscript-comment">/* while ( (deviceTreeName = OSDynamicCast(OSString, ...) ) ) */</span>

<span class="enscript-reference">finish</span>:

    OSSafeRelease(booterMemoryMap);
    OSSafeRelease(propertyDict);
    OSSafeRelease(keyIterator);
    OSSafeRelease(booterData);
    OSSafeRelease(aKext);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COM_APPLE</span>  <span class="enscript-string">&quot;com.apple.&quot;</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">KLDBootstrap::loadSecurityExtensions</span>(<span class="enscript-type">void</span>)
{
    OSDictionary         * extensionsDict = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * keyIterator    = NULL;  <span class="enscript-comment">// must release
</span>    OSString             * bundleID       = NULL;  <span class="enscript-comment">// don't release
</span>    OSKext               * theKext        = NULL;  <span class="enscript-comment">// don't release
</span>    OSBoolean            * isSecurityKext = NULL;  <span class="enscript-comment">// don't release
</span>
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogStepLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Loading security extensions.&quot;</span>);

    extensionsDict = OSKext::copyKexts();
    <span class="enscript-keyword">if</span> (!extensionsDict) {
        <span class="enscript-keyword">return</span>;
    }

    keyIterator = OSCollectionIterator::withCollection(extensionsDict);
    <span class="enscript-keyword">if</span> (!keyIterator) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Failed to allocate iterator for security extensions.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">while</span> ((bundleID = OSDynamicCast(OSString, keyIterator-&gt;getNextObject()))) {

        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * bundle_id = bundleID-&gt;getCStringNoCopy();
        
       <span class="enscript-comment">/* Skip extensions whose bundle IDs don't start with &quot;com.apple.&quot;.
        */</span>
        <span class="enscript-keyword">if</span> (!bundle_id ||
            (strncmp(bundle_id, COM_APPLE, CONST_STRLEN(COM_APPLE)) != 0)) {

            <span class="enscript-keyword">continue</span>;
        }

        theKext = OSDynamicCast(OSKext, extensionsDict-&gt;getObject(bundleID));
        <span class="enscript-keyword">if</span> (!theKext) {
            <span class="enscript-keyword">continue</span>;
        }

        isSecurityKext = OSDynamicCast(OSBoolean,
            theKext-&gt;getPropertyForHostArch(kAppleSecurityExtensionKey));
        <span class="enscript-keyword">if</span> (isSecurityKext &amp;&amp; isSecurityKext-&gt;isTrue()) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogStepLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Loading security extension %s.&quot;</span>, bundleID-&gt;getCStringNoCopy());
            <span class="enscript-reference">OSKext</span>::loadKextWithIdentifier(bundleID-&gt;getCStringNoCopy(),
                <span class="enscript-comment">/* allowDefer */</span> false);
        }
    }

<span class="enscript-reference">finish</span>:
    OSSafeRelease(keyIterator);
    OSSafeRelease(extensionsDict);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* We used to require that all listed kernel components load, but
* nowadays we can get them from userland so we only try to load the
* ones we have. If an error occurs later, such is life.
*
* Note that we look the kexts up first, so we can avoid spurious
* (in this context, anyhow) log messages about kexts not being found.
*
* xxx - do we even need to do this any more? Check if the kernel
* xxx - compoonents just load in the regular paths
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">KLDBootstrap::loadKernelComponentKexts</span>(<span class="enscript-type">void</span>)
{
    OSReturn      result      = kOSReturnSuccess;  <span class="enscript-comment">// optimistic
</span>    OSKext      * theKext     = NULL;              <span class="enscript-comment">// must release
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span> ** kextIDPtr   = NULL;              <span class="enscript-comment">// do not release
</span>
    <span class="enscript-keyword">for</span> (kextIDPtr = &amp;sKernelComponentNames[0]; *kextIDPtr; kextIDPtr++) {
        
        OSSafeReleaseNULL(theKext);
        theKext = OSKext::lookupKextWithIdentifier(*kextIDPtr);

        <span class="enscript-keyword">if</span> (theKext) {
            <span class="enscript-keyword">if</span> (kOSReturnSuccess != OSKext::loadKextWithIdentifier(
                *kextIDPtr, <span class="enscript-comment">/* allowDefer */</span> false)) {

                <span class="enscript-comment">// xxx - check KextBookkeeping, might be redundant
</span>                OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                    kOSKextLogErrorLevel |
                    kOSKextLogDirectoryScanFlag | kOSKextLogKextBookkeepingFlag,
                    <span class="enscript-string">&quot;Failed to initialize kernel component %s.&quot;</span>, *kextIDPtr);
                result = kOSReturnError;
            }
        }
    }

    OSSafeRelease(theKext);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Ensure that Kernel External Components are loaded early in boot,
* before other kext personalities get sent to the IOCatalogue. These
* kexts are treated specially because they may provide the implementation
* for kernel-vended KPI, so they must register themselves before
* general purpose IOKit probing begins.
*********************************************************************/</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COM_APPLE_KEC</span>  <span class="enscript-string">&quot;com.apple.kec.&quot;</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">KLDBootstrap::loadKernelExternalComponents</span>(<span class="enscript-type">void</span>)
{
    OSDictionary         * extensionsDict = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * keyIterator    = NULL;  <span class="enscript-comment">// must release
</span>    OSString             * bundleID       = NULL;  <span class="enscript-comment">// don't release
</span>    OSKext               * theKext        = NULL;  <span class="enscript-comment">// don't release
</span>    OSBoolean            * isKernelExternalComponent = NULL;  <span class="enscript-comment">// don't release
</span>
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogStepLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Loading Kernel External Components.&quot;</span>);

    extensionsDict = OSKext::copyKexts();
    <span class="enscript-keyword">if</span> (!extensionsDict) {
        <span class="enscript-keyword">return</span>;
    }

    keyIterator = OSCollectionIterator::withCollection(extensionsDict);
    <span class="enscript-keyword">if</span> (!keyIterator) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Failed to allocate iterator for Kernel External Components.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">while</span> ((bundleID = OSDynamicCast(OSString, keyIterator-&gt;getNextObject()))) {

        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * bundle_id = bundleID-&gt;getCStringNoCopy();
        
       <span class="enscript-comment">/* Skip extensions whose bundle IDs don't start with &quot;com.apple.kec.&quot;.
        */</span>
        <span class="enscript-keyword">if</span> (!bundle_id ||
            (strncmp(bundle_id, COM_APPLE_KEC, CONST_STRLEN(COM_APPLE_KEC)) != 0)) {

            <span class="enscript-keyword">continue</span>;
        }

        theKext = OSDynamicCast(OSKext, extensionsDict-&gt;getObject(bundleID));
        <span class="enscript-keyword">if</span> (!theKext) {
            <span class="enscript-keyword">continue</span>;
        }

        isKernelExternalComponent = OSDynamicCast(OSBoolean,
            theKext-&gt;getPropertyForHostArch(kAppleKernelExternalComponentKey));
        <span class="enscript-keyword">if</span> (isKernelExternalComponent &amp;&amp; isKernelExternalComponent-&gt;isTrue()) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogStepLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Loading kernel external component %s.&quot;</span>, bundleID-&gt;getCStringNoCopy());
            <span class="enscript-reference">OSKext</span>::loadKextWithIdentifier(bundleID-&gt;getCStringNoCopy(),
                <span class="enscript-comment">/* allowDefer */</span> false);
        }
    }

<span class="enscript-reference">finish</span>:
    OSSafeRelease(keyIterator);
    OSSafeRelease(extensionsDict);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
 *********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">KLDBootstrap::readBuiltinPersonalities</span>(<span class="enscript-type">void</span>)
{
    OSObject              * parsedXML             = NULL;  <span class="enscript-comment">// must release
</span>    OSArray               * builtinExtensions     = NULL;  <span class="enscript-comment">// do not release
</span>    OSArray               * allPersonalities      = NULL;  <span class="enscript-comment">// must release
</span>    OSString              * errorString           = NULL;  <span class="enscript-comment">// must release
</span>    kernel_section_t      * infosect              = NULL;  <span class="enscript-comment">// do not free
</span>    OSCollectionIterator  * personalitiesIterator = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            count, i;
    
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogStepLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Reading built-in kernel personalities for I/O Kit drivers.&quot;</span>);

   <span class="enscript-comment">/* Look in the __BUILTIN __info segment for an array of Info.plist
    * entries. For each one, extract the personalities dictionary, add
    * it to our array, then push them all (without matching) to
    * the IOCatalogue. This can be used to augment the personalities
    * in gIOKernelConfigTables, especially when linking entire kexts into
    * the mach_kernel image.
    */</span>
    infosect   = getsectbyname(<span class="enscript-string">&quot;__BUILTIN&quot;</span>, <span class="enscript-string">&quot;__info&quot;</span>);
    <span class="enscript-keyword">if</span> (!infosect) {
        <span class="enscript-comment">// this isn't fatal
</span>        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
        
    parsedXML = OSUnserializeXML((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) (uintptr_t)infosect-&gt;addr,
        &amp;errorString);
    <span class="enscript-keyword">if</span> (parsedXML) {
        builtinExtensions = OSDynamicCast(OSArray, parsedXML);
    }
    <span class="enscript-keyword">if</span> (!builtinExtensions) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * errorCString = <span class="enscript-string">&quot;(unknown error)&quot;</span>;
        
        <span class="enscript-keyword">if</span> (errorString &amp;&amp; errorString-&gt;getCStringNoCopy()) {
            errorCString = errorString-&gt;getCStringNoCopy();
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parsedXML) {
            errorCString = <span class="enscript-string">&quot;not an array&quot;</span>;
        }
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Error unserializing built-in personalities: %s.&quot;</span>, errorCString);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
            
    <span class="enscript-comment">// estimate 3 personalities per Info.plist/kext
</span>    count = builtinExtensions-&gt;getCount();
    allPersonalities = OSArray::withCapacity(count * 3);
            
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSDictionary            * infoDict = NULL;      <span class="enscript-comment">// do not release
</span>        OSString                * moduleName = NULL;    <span class="enscript-comment">// do not release
</span>        OSDictionary            * personalities;        <span class="enscript-comment">// do not release
</span>        OSString                * personalityName;      <span class="enscript-comment">// do not release    
</span>        
        OSSafeReleaseNULL(personalitiesIterator);

        infoDict = OSDynamicCast(OSDictionary,
            builtinExtensions-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!infoDict) {
            <span class="enscript-keyword">continue</span>;
        }
        
        moduleName = OSDynamicCast(OSString,
            infoDict-&gt;getObject(kCFBundleIdentifierKey));
        <span class="enscript-keyword">if</span> (!moduleName) {
            <span class="enscript-keyword">continue</span>;
        }
        
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogStepLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Adding personalities for built-in driver %s:&quot;</span>,
            moduleName-&gt;getCStringNoCopy());
        
        personalities = OSDynamicCast(OSDictionary,
            infoDict-&gt;getObject(<span class="enscript-string">&quot;IOKitPersonalities&quot;</span>));
        <span class="enscript-keyword">if</span> (!personalities) {
            <span class="enscript-keyword">continue</span>;
        }
        
        personalitiesIterator = OSCollectionIterator::withCollection(personalities);
        <span class="enscript-keyword">if</span> (!personalitiesIterator) {
            <span class="enscript-keyword">continue</span>;  <span class="enscript-comment">// xxx - well really, what can we do? should we panic?
</span>        }
        
        <span class="enscript-keyword">while</span> ((personalityName = OSDynamicCast(OSString,
            personalitiesIterator-&gt;getNextObject()))) {
            
            OSDictionary * personality = OSDynamicCast(OSDictionary,
                personalities-&gt;getObject(personalityName));

            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogDetailLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Adding built-in driver personality %s.&quot;</span>,
                personalityName-&gt;getCStringNoCopy());
        
			<span class="enscript-keyword">if</span> (personality &amp;&amp; !personality-&gt;getObject(kCFBundleIdentifierKey)) {
				personality-&gt;setObject(kCFBundleIdentifierKey, moduleName);
			}
            allPersonalities-&gt;setObject(personality);
        }
    }
    
    gIOCatalogue-&gt;addDrivers(allPersonalities, false);

<span class="enscript-reference">finish</span>:
    OSSafeRelease(parsedXML);
    OSSafeRelease(allPersonalities);
    OSSafeRelease(errorString);
    OSSafeRelease(personalitiesIterator);
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Bootstrap</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Bootstrap Functions
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bootstrapRecordStartupExtensions</span>(<span class="enscript-type">void</span>)
{
    sBootstrapObject.readStartupExtensions();
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bootstrapLoadSecurityExtensions</span>(<span class="enscript-type">void</span>)
{
    sBootstrapObject.loadSecurityExtensions();
    <span class="enscript-keyword">return</span>;
}

</pre>
<hr />
</body></html>