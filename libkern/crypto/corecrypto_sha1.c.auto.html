<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>corecrypto_sha1.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">corecrypto_sha1.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/crypto_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/sha1.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/ccdigest.h&gt;</span>


<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">getCount</span>(SHA1_CTX *ctx)
{
	<span class="enscript-keyword">return</span> ctx-&gt;c.b64[0];
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">setCount</span>(SHA1_CTX *ctx, uint64_t count)
{
	ctx-&gt;c.b64[0]=count;
}

<span class="enscript-comment">/* Copy a ccdigest ctx into a legacy SHA1 context */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DiToSHA1</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ccdigest_info *di, <span class="enscript-type">struct</span> ccdigest_ctx *di_ctx, SHA1_CTX *sha1_ctx)
{
	setCount(sha1_ctx, ccdigest_nbits(di, di_ctx)/8+ccdigest_num(di, di_ctx));
	memcpy(sha1_ctx-&gt;m.b8, ccdigest_data(di, di_ctx), di-&gt;block_size);
	memcpy(sha1_ctx-&gt;h.b8, ccdigest_state_ccn(di, di_ctx), di-&gt;state_size);
}

<span class="enscript-comment">/* Copy a legacy SHA1 context into a ccdigest ctx  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">SHA1ToDi</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ccdigest_info *di, SHA1_CTX *sha1_ctx, <span class="enscript-type">struct</span> ccdigest_ctx *di_ctx)
{
	uint64_t count = getCount(sha1_ctx);
	
	ccdigest_num(di, di_ctx)=count%di-&gt;block_size;
	ccdigest_nbits(di, di_ctx)=(count-ccdigest_num(di, di_ctx))*8;
	memcpy(ccdigest_data(di, di_ctx), sha1_ctx-&gt;m.b8, di-&gt;block_size);
	memcpy(ccdigest_state_ccn(di, di_ctx), sha1_ctx-&gt;h.b8, di-&gt;state_size);	
}

<span class="enscript-type">void</span> <span class="enscript-function-name">SHA1Init</span>(SHA1_CTX *ctx)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ccdigest_info *di=g_crypto_funcs-&gt;ccsha1_di;
	ccdigest_di_decl(di, di_ctx);
	
	g_crypto_funcs-&gt;ccdigest_init_fn(di, di_ctx);
	
	DiToSHA1(di, di_ctx, ctx);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">SHA1Update</span>(SHA1_CTX *ctx, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ccdigest_info *di=g_crypto_funcs-&gt;ccsha1_di;
	ccdigest_di_decl(di, di_ctx);
	
	SHA1ToDi(di, ctx, di_ctx);
	g_crypto_funcs-&gt;ccdigest_update_fn(di, di_ctx, len, data);	
	DiToSHA1(di, di_ctx, ctx);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">SHA1Final</span>(<span class="enscript-type">void</span> *digest, SHA1_CTX *ctx)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ccdigest_info *di=g_crypto_funcs-&gt;ccsha1_di;
	ccdigest_di_decl(di, di_ctx);
	
	SHA1ToDi(di, ctx, di_ctx);
	ccdigest_final(di, di_ctx, digest);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">SHA1UpdateUsePhysicalAddress</span>(SHA1_CTX *ctx, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-comment">//TODO: What the hell ?
</span>	SHA1Update(ctx, data, len);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* This is not publicised in header, but exported in libkern.exports */</span> 
<span class="enscript-type">void</span> <span class="enscript-function-name">SHA1Final_r</span>(SHA1_CTX *context, <span class="enscript-type">void</span> *digest);
<span class="enscript-type">void</span> <span class="enscript-function-name">SHA1Final_r</span>(SHA1_CTX *context, <span class="enscript-type">void</span> *digest)
{
	SHA1Final(digest, context);
}


<span class="enscript-comment">/*
 * This function is called by the SHA1 hardware kext during its init.
 * This will register the function to call to perform SHA1 using hardware.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">kern_return_t</span> (*InKernelPerformSHA1Func)(<span class="enscript-type">void</span> *ref, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, size_t dataLen, u_int32_t *inHash, u_int32_t options, u_int32_t *outHash, Boolean usePhysicalAddress);
<span class="enscript-type">void</span> <span class="enscript-function-name">sha1_hardware_hook</span>(Boolean option, InKernelPerformSHA1Func func, <span class="enscript-type">void</span> *ref);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *SHA1Ref;
<span class="enscript-type">static</span> InKernelPerformSHA1Func performSHA1WithinKernelOnly;

<span class="enscript-type">void</span> <span class="enscript-function-name">sha1_hardware_hook</span>(Boolean option, InKernelPerformSHA1Func func, <span class="enscript-type">void</span> *ref)
{
	<span class="enscript-keyword">if</span>(option) {
		<span class="enscript-comment">// Establish the hook. The hardware is ready.
</span>		OSCompareAndSwapPtr((<span class="enscript-type">void</span>*)NULL, (<span class="enscript-type">void</span>*)ref, (<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span>*)&amp;SHA1Ref);

		<span class="enscript-keyword">if</span>(!OSCompareAndSwapPtr((<span class="enscript-type">void</span> *)NULL, (<span class="enscript-type">void</span> *)func, (<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;performSHA1WithinKernelOnly)) {
			panic(<span class="enscript-string">&quot;sha1_hardware_hook: Called twice.. Should never happen\n&quot;</span>);
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// The hardware is going away. Tear down the hook.
</span>		performSHA1WithinKernelOnly = NULL;
		SHA1Ref = NULL;
	}
}
</pre>
<hr />
</body></html>