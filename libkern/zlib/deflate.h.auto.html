<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>deflate.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">deflate.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* deflate.h -- internal compression state
 * Copyright (C) 1995-2004 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span>

<span class="enscript-comment">/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */</span>

<span class="enscript-comment">/* @(#) $Id$ */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DEFLATE_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFLATE_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;zutil.h&quot;</span>

<span class="enscript-comment">/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip encoding
   should be left enabled. */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_GZIP</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">GZIP</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* ===========================================================================
 * Internal compression state.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LENGTH_CODES</span> 29
<span class="enscript-comment">/* number of length codes, not counting the special END_BLOCK code */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LITERALS</span>  256
<span class="enscript-comment">/* number of literal bytes 0..255 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">L_CODES</span> (LITERALS+1+LENGTH_CODES)
<span class="enscript-comment">/* number of Literal or Length codes, including the END_BLOCK code */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">D_CODES</span>   30
<span class="enscript-comment">/* number of distance codes */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BL_CODES</span>  19
<span class="enscript-comment">/* number of codes used to transfer the bit lengths */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HEAP_SIZE</span> (2*L_CODES+1)
<span class="enscript-comment">/* maximum heap size */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_BITS</span> 15
<span class="enscript-comment">/* All codes must not exceed MAX_BITS bits */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INIT_STATE</span>    42
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXTRA_STATE</span>   69
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NAME_STATE</span>    73
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMMENT_STATE</span> 91
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HCRC_STATE</span>   103
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BUSY_STATE</span>   113
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FINISH_STATE</span> 666
<span class="enscript-comment">/* Stream status */</span>


<span class="enscript-comment">/* Data structure describing a single value and its code string. */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ct_data_s {
    <span class="enscript-type">union</span> {
        ush  freq;       <span class="enscript-comment">/* frequency count */</span>
        ush  code;       <span class="enscript-comment">/* bit string */</span>
    } fc;
    <span class="enscript-type">union</span> {
        ush  dad;        <span class="enscript-comment">/* father node in Huffman tree */</span>
        ush  len;        <span class="enscript-comment">/* length of bit string */</span>
    } dl;
} FAR ct_data;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">Freq</span> fc.freq
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">Code</span> fc.code
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">Dad</span>  dl.dad
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">Len</span>  dl.len

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> static_tree_desc_s  static_tree_desc;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> tree_desc_s {
    ct_data *dyn_tree;           <span class="enscript-comment">/* the dynamic tree */</span>
    <span class="enscript-type">int</span>     max_code;            <span class="enscript-comment">/* largest code with non zero frequency */</span>
    static_tree_desc *stat_desc; <span class="enscript-comment">/* the corresponding static tree */</span>
} FAR tree_desc;

<span class="enscript-type">typedef</span> ush Pos;
<span class="enscript-type">typedef</span> Pos FAR Posf;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> IPos;

<span class="enscript-comment">/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> internal_state {
    z_streamp strm;      <span class="enscript-comment">/* pointer back to this zlib stream */</span>
    z_input_func zinput;
    z_output_func zoutput;
    <span class="enscript-type">int</span>   status;        <span class="enscript-comment">/* as the name implies */</span>
    Bytef *pending_buf;  <span class="enscript-comment">/* output still pending */</span>
    ulg   pending_buf_size; <span class="enscript-comment">/* size of pending_buf */</span>
    Bytef *pending_out;  <span class="enscript-comment">/* next pending byte to output to the stream */</span>
    uInt   pending;      <span class="enscript-comment">/* nb of bytes in the pending buffer */</span>
    <span class="enscript-type">int</span>   wrap;          <span class="enscript-comment">/* bit 0 true for zlib, bit 1 true for gzip */</span>
    gz_headerp  gzhead;  <span class="enscript-comment">/* gzip header information to write */</span>
    uInt   gzindex;      <span class="enscript-comment">/* where in extra, name, or comment */</span>
    Byte  method;        <span class="enscript-comment">/* STORED (for zip only) or DEFLATED */</span>
    <span class="enscript-type">int</span>   last_flush;    <span class="enscript-comment">/* value of flush param for previous deflate call */</span>

                <span class="enscript-comment">/* used by deflate.c: */</span>

    uInt  w_size;        <span class="enscript-comment">/* LZ77 window size (32K by default) */</span>
    uInt  w_bits;        <span class="enscript-comment">/* log2(w_size)  (8..16) */</span>
    uInt  w_mask;        <span class="enscript-comment">/* w_size - 1 */</span>

    Bytef *window;
    <span class="enscript-comment">/* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */</span>

    ulg window_size;
    <span class="enscript-comment">/* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */</span>

    Posf *prev;
    <span class="enscript-comment">/* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */</span>

    Posf *head; <span class="enscript-comment">/* Heads of the hash chains or NIL. */</span>

    uInt  ins_h;          <span class="enscript-comment">/* hash index of string to be inserted */</span>
    uInt  hash_size;      <span class="enscript-comment">/* number of elements in hash table */</span>
    uInt  hash_bits;      <span class="enscript-comment">/* log2(hash_size) */</span>
    uInt  hash_mask;      <span class="enscript-comment">/* hash_size-1 */</span>

    uInt  hash_shift;
    <span class="enscript-comment">/* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH &gt;= hash_bits
     */</span>

    <span class="enscript-type">long</span> block_start;
    <span class="enscript-comment">/* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */</span>

    uInt match_length;           <span class="enscript-comment">/* length of best match */</span>
    IPos prev_match;             <span class="enscript-comment">/* previous match */</span>
    <span class="enscript-type">int</span> match_available;         <span class="enscript-comment">/* set if previous match exists */</span>
    uInt strstart;               <span class="enscript-comment">/* start of string to insert */</span>
    uInt match_start;            <span class="enscript-comment">/* start of matching string */</span>
    uInt lookahead;              <span class="enscript-comment">/* number of valid bytes ahead in window */</span>

    uInt prev_length;
    <span class="enscript-comment">/* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */</span>

    uInt max_chain_length;
    <span class="enscript-comment">/* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */</span>

    uInt max_lazy_match;
    <span class="enscript-comment">/* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels &gt;= 4.
     */</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">max_insert_length</span>  max_lazy_match
    <span class="enscript-comment">/* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels &lt;= 3.
     */</span>

    <span class="enscript-type">int</span> level;    <span class="enscript-comment">/* compression level (1..9) */</span>
    <span class="enscript-type">int</span> strategy; <span class="enscript-comment">/* favor or force Huffman coding*/</span>

    uInt good_match;
    <span class="enscript-comment">/* Use a faster search when the previous match is longer than this */</span>

    <span class="enscript-type">int</span> nice_match; <span class="enscript-comment">/* Stop searching when current match exceeds this */</span>

                <span class="enscript-comment">/* used by trees.c: */</span>
    <span class="enscript-comment">/* Didn't use ct_data typedef below to supress compiler warning */</span>
    <span class="enscript-type">struct</span> ct_data_s dyn_ltree[HEAP_SIZE];   <span class="enscript-comment">/* literal and length tree */</span>
    <span class="enscript-type">struct</span> ct_data_s dyn_dtree[2*D_CODES+1]; <span class="enscript-comment">/* distance tree */</span>
    <span class="enscript-type">struct</span> ct_data_s bl_tree[2*BL_CODES+1];  <span class="enscript-comment">/* Huffman tree for bit lengths */</span>

    <span class="enscript-type">struct</span> tree_desc_s l_desc;               <span class="enscript-comment">/* desc. for literal tree */</span>
    <span class="enscript-type">struct</span> tree_desc_s d_desc;               <span class="enscript-comment">/* desc. for distance tree */</span>
    <span class="enscript-type">struct</span> tree_desc_s bl_desc;              <span class="enscript-comment">/* desc. for bit length tree */</span>

    ush bl_count[MAX_BITS+1];
    <span class="enscript-comment">/* number of codes at each bit length for an optimal tree */</span>

    <span class="enscript-type">int</span> heap[2*L_CODES+1];      <span class="enscript-comment">/* heap used to build the Huffman trees */</span>
    <span class="enscript-type">int</span> heap_len;               <span class="enscript-comment">/* number of elements in the heap */</span>
    <span class="enscript-type">int</span> heap_max;               <span class="enscript-comment">/* element of largest frequency */</span>
    <span class="enscript-comment">/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */</span>

    uch depth[2*L_CODES+1];
    <span class="enscript-comment">/* Depth of each subtree used as tie breaker for trees of equal frequency
     */</span>

    uchf *l_buf;          <span class="enscript-comment">/* buffer for literals or lengths */</span>

    uInt  lit_bufsize;
    <span class="enscript-comment">/* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */</span>

    uInt last_lit;      <span class="enscript-comment">/* running index in l_buf */</span>

    ushf *d_buf;
    <span class="enscript-comment">/* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */</span>

    ulg opt_len;        <span class="enscript-comment">/* bit length of current block with optimal trees */</span>
    ulg static_len;     <span class="enscript-comment">/* bit length of current block with static trees */</span>
    uInt matches;       <span class="enscript-comment">/* number of string matches in current block */</span>
    <span class="enscript-type">int</span> last_eob_len;   <span class="enscript-comment">/* bit length of EOB code for last block */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEBUG</span>
    ulg compressed_len; <span class="enscript-comment">/* total bit length of compressed file mod 2^32 */</span>
    ulg bits_sent;      <span class="enscript-comment">/* bit length of compressed data sent mod 2^32 */</span>
#<span class="enscript-reference">endif</span>

    ush bi_buf;
    <span class="enscript-comment">/* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */</span>
    <span class="enscript-type">int</span> bi_valid;
    <span class="enscript-comment">/* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */</span>

} FAR deflate_state;

<span class="enscript-comment">/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">put_byte</span>(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (c);}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MIN_LOOKAHEAD</span> (MAX_MATCH+MIN_MATCH+1)
<span class="enscript-comment">/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAX_DIST</span>(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)
<span class="enscript-comment">/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */</span>

        <span class="enscript-comment">/* in trees.c */</span>
<span class="enscript-type">void</span> _tr_init         <span class="enscript-function-name">OF</span>((deflate_state *s));
<span class="enscript-type">int</span>  _tr_tally        <span class="enscript-function-name">OF</span>((deflate_state *s, <span class="enscript-type">unsigned</span> dist, <span class="enscript-type">unsigned</span> lc));
<span class="enscript-type">void</span> _tr_flush_block  <span class="enscript-function-name">OF</span>((deflate_state *s, charf *buf, ulg stored_len,
                          <span class="enscript-type">int</span> eof));
<span class="enscript-type">void</span> _tr_align        <span class="enscript-function-name">OF</span>((deflate_state *s));
<span class="enscript-type">void</span> _tr_stored_block <span class="enscript-function-name">OF</span>((deflate_state *s, charf *buf, ulg stored_len,
                          <span class="enscript-type">int</span> eof));

#<span class="enscript-reference">define</span> <span class="enscript-function-name">d_code</span>(dist) \
   ((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256+((dist)&gt;&gt;7)])
<span class="enscript-comment">/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-comment">/* Inline versions of _tr_tally for speed: */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">GEN_TREES_H</span>) || !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">STDC</span>)
  <span class="enscript-type">extern</span> uch _length_code[];
  <span class="enscript-type">extern</span> uch _dist_code[];
#<span class="enscript-reference">else</span>
  <span class="enscript-type">extern</span> <span class="enscript-type">const</span> uch _length_code[];
  <span class="enscript-type">extern</span> <span class="enscript-type">const</span> uch _dist_code[];
#<span class="enscript-reference">endif</span>

# <span class="enscript-reference">define</span> <span class="enscript-function-name">_tr_tally_lit</span>(s, c, flush) \
  { uch cc = (c); \
    s-&gt;d_buf[s-&gt;last_lit] = 0; \
    s-&gt;l_buf[s-&gt;last_lit++] = cc; \
    s-&gt;dyn_ltree[cc].Freq++; \
    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
   }
# <span class="enscript-reference">define</span> <span class="enscript-function-name">_tr_tally_dist</span>(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s-&gt;d_buf[s-&gt;last_lit] = dist; \
    s-&gt;l_buf[s-&gt;last_lit++] = len; \
    dist--; \
    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s-&gt;dyn_dtree[d_code(dist)].Freq++; \
    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
  }
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">_tr_tally_lit</span>(s, c, flush) flush = _tr_tally(s, 0, c)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">_tr_tally_dist</span>(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEFLATE_H */</span>
</pre>
<hr />
</body></html>