<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>zutil.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">zutil.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span>

<span class="enscript-comment">/* @(#) $Id$ */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;zutil.h&quot;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_DUMMY_DECL</span>
<span class="enscript-type">struct</span> internal_state      {<span class="enscript-type">int</span> dummy;}; <span class="enscript-comment">/* for buggy compilers */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> z_errmsg[10] = {
<span class="enscript-string">&quot;need dictionary&quot;</span>,     <span class="enscript-comment">/* Z_NEED_DICT       2  */</span>
<span class="enscript-string">&quot;stream end&quot;</span>,          <span class="enscript-comment">/* Z_STREAM_END      1  */</span>
<span class="enscript-string">&quot;&quot;</span>,                    <span class="enscript-comment">/* Z_OK              0  */</span>
<span class="enscript-string">&quot;file error&quot;</span>,          <span class="enscript-comment">/* Z_ERRNO         (-1) */</span>
<span class="enscript-string">&quot;stream error&quot;</span>,        <span class="enscript-comment">/* Z_STREAM_ERROR  (-2) */</span>
<span class="enscript-string">&quot;data error&quot;</span>,          <span class="enscript-comment">/* Z_DATA_ERROR    (-3) */</span>
<span class="enscript-string">&quot;insufficient memory&quot;</span>, <span class="enscript-comment">/* Z_MEM_ERROR     (-4) */</span>
<span class="enscript-string">&quot;buffer error&quot;</span>,        <span class="enscript-comment">/* Z_BUF_ERROR     (-5) */</span>
<span class="enscript-string">&quot;incompatible version&quot;</span>,<span class="enscript-comment">/* Z_VERSION_ERROR (-6) */</span>
<span class="enscript-string">&quot;&quot;</span>};


<span class="enscript-type">const</span> <span class="enscript-type">char</span> * ZEXPORT <span class="enscript-function-name">zlibVersion</span>()
{
    <span class="enscript-keyword">return</span> ZLIB_VERSION;
}

uLong ZEXPORT <span class="enscript-function-name">zlibCompileFlags</span>()
{
    uLong flags;

    flags = 0;
    <span class="enscript-keyword">switch</span> (<span class="enscript-keyword">sizeof</span>(uInt)) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:     <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:     flags += 1;     <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:     flags += 2;     <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:    flags += 3;
    }
    <span class="enscript-keyword">switch</span> (<span class="enscript-keyword">sizeof</span>(uLong)) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:     <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:     flags += 1 &lt;&lt; 2;        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:     flags += 2 &lt;&lt; 2;        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:    flags += 3 &lt;&lt; 2;
    }
    <span class="enscript-keyword">switch</span> (<span class="enscript-keyword">sizeof</span>(voidpf)) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:     <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:     flags += 1 &lt;&lt; 4;        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:     flags += 2 &lt;&lt; 4;        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:    flags += 3 &lt;&lt; 4;
    }
    <span class="enscript-keyword">switch</span> (<span class="enscript-keyword">sizeof</span>(z_off_t)) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:     <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:     flags += 1 &lt;&lt; 6;        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:     flags += 2 &lt;&lt; 6;        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:    flags += 3 &lt;&lt; 6;
    }
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEBUG</span>
    flags += 1 &lt;&lt; 8;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">ASMV</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">ASMINF</span>)
    flags += 1 &lt;&lt; 9;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ZLIB_WINAPI</span>
    flags += 1 &lt;&lt; 10;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUILDFIXED</span>
    flags += 1 &lt;&lt; 12;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DYNAMIC_CRC_TABLE</span>
    flags += 1 &lt;&lt; 13;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_GZCOMPRESS</span>
    flags += 1L &lt;&lt; 16;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_GZIP</span>
    flags += 1L &lt;&lt; 17;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PKZIP_BUG_WORKAROUND</span>
    flags += 1L &lt;&lt; 20;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">FASTEST</span>
    flags += 1L &lt;&lt; 21;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">STDC</span>
#  <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_vsnprintf</span>
        flags += 1L &lt;&lt; 25;
#    <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAS_vsprintf_void</span>
        flags += 1L &lt;&lt; 26;
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">else</span>
#    <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAS_vsnprintf_void</span>
        flags += 1L &lt;&lt; 26;
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
        flags += 1L &lt;&lt; 24;
#  <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_snprintf</span>
        flags += 1L &lt;&lt; 25;
#    <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAS_sprintf_void</span>
        flags += 1L &lt;&lt; 26;
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">else</span>
#    <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAS_snprintf_void</span>
        flags += 1L &lt;&lt; 26;
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> flags;
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEBUG</span>

#  <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">verbose</span>
#    <span class="enscript-reference">define</span> <span class="enscript-variable-name">verbose</span> 0
#  <span class="enscript-reference">endif</span>
<span class="enscript-type">int</span> z_verbose = verbose;

<span class="enscript-type">void</span> <span class="enscript-function-name">z_error</span> (m)
    <span class="enscript-type">char</span> *m;
{
    fprintf(stderr, <span class="enscript-string">&quot;%s\n&quot;</span>, m);
    exit(1);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * ZEXPORT <span class="enscript-function-name">zError</span>(err)
    <span class="enscript-type">int</span> err;
{
    <span class="enscript-keyword">return</span> ERR_MSG(err);
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32_WCE</span>)
    <span class="enscript-comment">/* The Microsoft C Run-Time Library for Windows CE doesn't have
     * errno.  We define it as a global variable to simplify porting.
     * Its value is always 0 and should not be used.
     */</span>
    <span class="enscript-type">int</span> errno = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HAVE_MEMCPY</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">zmemcpy</span>(dest, source, len)
    Bytef* dest;
    <span class="enscript-type">const</span> Bytef* source;
    uInt  len;
{
    <span class="enscript-keyword">if</span> (len == 0) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">do</span> {
        *dest++ = *source++; <span class="enscript-comment">/* ??? to be unrolled */</span>
    } <span class="enscript-keyword">while</span> (--len != 0);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">zmemcmp</span>(s1, s2, len)
    <span class="enscript-type">const</span> Bytef* s1;
    <span class="enscript-type">const</span> Bytef* s2;
    uInt  len;
{
    uInt j;

    <span class="enscript-keyword">for</span> (j = 0; j &lt; len; j++) {
        <span class="enscript-keyword">if</span> (s1[j] != s2[j]) <span class="enscript-keyword">return</span> 2*(s1[j] &gt; s2[j])-1;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">zmemzero</span>(dest, len)
    Bytef* dest;
    uInt  len;
{
    <span class="enscript-keyword">if</span> (len == 0) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">do</span> {
        *dest++ = 0;  <span class="enscript-comment">/* ??? to be unrolled */</span>
    } <span class="enscript-keyword">while</span> (--len != 0);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_ZCFUNCS</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SYS16BIT</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__TURBOC__</span>
<span class="enscript-comment">/* Turbo C in 16-bit mode */</span>

#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">MY_ZCALLOC</span>

<span class="enscript-comment">/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_PTR</span> 10
<span class="enscript-comment">/* 10*64K = 640K */</span>

local <span class="enscript-type">int</span> next_ptr = 0;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
<span class="enscript-comment">/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */</span>

voidpf <span class="enscript-function-name">zcalloc</span> (voidpf opaque, <span class="enscript-type">unsigned</span> items, <span class="enscript-type">unsigned</span> size)
{
    voidpf buf = opaque; <span class="enscript-comment">/* just to make some compilers happy */</span>
    ulg bsize = (ulg)items*size;

    <span class="enscript-comment">/* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */</span>
    <span class="enscript-keyword">if</span> (bsize &lt; 65520L) {
        buf = farmalloc(bsize);
        <span class="enscript-keyword">if</span> (*(ush*)&amp;buf != 0) <span class="enscript-keyword">return</span> buf;
    } <span class="enscript-keyword">else</span> {
        buf = farmalloc(bsize + 16L);
    }
    <span class="enscript-keyword">if</span> (buf == NULL || next_ptr &gt;= MAX_PTR) <span class="enscript-keyword">return</span> NULL;
    table[next_ptr].org_ptr = buf;

    <span class="enscript-comment">/* Normalize the pointer to seg:0 */</span>
    *((ush*)&amp;buf+1) += ((ush)((uch*)buf-0) + 15) &gt;&gt; 4;
    *(ush*)&amp;buf = 0;
    table[next_ptr++].new_ptr = buf;
    <span class="enscript-keyword">return</span> buf;
}

<span class="enscript-type">void</span>  <span class="enscript-function-name">zcfree</span> (voidpf opaque, voidpf ptr)
{
    <span class="enscript-type">int</span> n;
    <span class="enscript-keyword">if</span> (*(ush*)&amp;ptr != 0) { <span class="enscript-comment">/* object &lt; 64K */</span>
        farfree(ptr);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-comment">/* Find the original pointer */</span>
    <span class="enscript-keyword">for</span> (n = 0; n &lt; next_ptr; n++) {
        <span class="enscript-keyword">if</span> (ptr != table[n].new_ptr) <span class="enscript-keyword">continue</span>;

        farfree(table[n].org_ptr);
        <span class="enscript-keyword">while</span> (++n &lt; next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        <span class="enscript-keyword">return</span>;
    }
    ptr = opaque; <span class="enscript-comment">/* just to make some compilers happy */</span>
    Assert(0, <span class="enscript-string">&quot;zcfree: ptr not found&quot;</span>);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __TURBOC__ */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">M_I86</span>
<span class="enscript-comment">/* Microsoft C in 16-bit mode */</span>

#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">MY_ZCALLOC</span>

#<span class="enscript-reference">if</span> (!<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>) || (<span class="enscript-variable-name">_MSC_VER</span> &lt;= 600))
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">_halloc</span>  halloc
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">_hfree</span>   hfree
#<span class="enscript-reference">endif</span>

voidpf <span class="enscript-function-name">zcalloc</span> (voidpf opaque, <span class="enscript-type">unsigned</span> items, <span class="enscript-type">unsigned</span> size)
{
    <span class="enscript-keyword">if</span> (opaque) opaque = 0; <span class="enscript-comment">/* to make compiler happy */</span>
    <span class="enscript-keyword">return</span> _halloc((<span class="enscript-type">long</span>)items, size);
}

<span class="enscript-type">void</span>  <span class="enscript-function-name">zcfree</span> (voidpf opaque, voidpf ptr)
{
    <span class="enscript-keyword">if</span> (opaque) opaque = 0; <span class="enscript-comment">/* to make compiler happy */</span>
    _hfree(ptr);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* M_I86 */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SYS16BIT */</span>


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MY_ZCALLOC</span> <span class="enscript-comment">/* Any system without a special alloc function */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">STDC</span>
<span class="enscript-type">extern</span> voidp  malloc <span class="enscript-function-name">OF</span>((uInt size));
<span class="enscript-type">extern</span> voidp  calloc <span class="enscript-function-name">OF</span>((uInt items, uInt size));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>   free   <span class="enscript-function-name">OF</span>((voidpf ptr));
#<span class="enscript-reference">endif</span>

voidpf <span class="enscript-function-name">zcalloc</span> (opaque, items, size)
    voidpf opaque;
    <span class="enscript-type">unsigned</span> items;
    <span class="enscript-type">unsigned</span> size;
{
    <span class="enscript-keyword">if</span> (opaque) items += size - size; <span class="enscript-comment">/* make compiler happy */</span>
    <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(uInt) &gt; 2 ? (voidpf)malloc(items * size) :
                              (voidpf)calloc(items, size);
}

<span class="enscript-type">void</span>  <span class="enscript-function-name">zcfree</span> (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    <span class="enscript-keyword">if</span> (opaque) <span class="enscript-keyword">return</span>; <span class="enscript-comment">/* make compiler happy */</span>
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MY_ZCALLOC */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_CZFUNCS */</span>
</pre>
<hr />
</body></html>