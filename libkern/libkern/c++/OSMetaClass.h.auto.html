<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSMetaClass.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSMetaClass.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_LIBKERN_OSMETACLASS_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_LIBKERN_OSMETACLASS_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSReturn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

class OSMetaClass;
class OSObject;
class OSString;
class OSSymbol;
class OSDictionary;
class OSSerialize;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
class OSOrderedSet;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*!
 * @header
 *
 * @abstract
 * This header declares the OSMetaClassBase and OSMetaClass classes,
 * which together form the basis of the Libkern and I/O Kit C++ class hierarchy
 * and run-time type information facility.
 */</span>
 
 
<span class="enscript-comment">/*! @parseOnly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_COMPATIBILITY</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>

<span class="enscript-comment">/*! @parseOnly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_VTABLE_PADDING</span>   1

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;TargetConditionals.h&gt;</span>

<span class="enscript-comment">/*! @parseOnly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_VTABLE_PADDING</span>   1

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-comment">/*! @parseOnly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_LEGACY_ABI</span>  0
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_LEGACY_ABI</span>  1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-comment">/*! @parseOnly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_COMPATIBILITY_VIRTUAL</span>
#<span class="enscript-reference">else</span>
<span class="enscript-comment">// private method made virtual only for binary compatibility
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_COMPATIBILITY_VIRTUAL</span>  virtual
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*! @parseOnly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_DEPRECATED</span>  __attribute__((deprecated))


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__cplusplus</span> &gt;= 201103L
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_OVERRIDE</span>  				override
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_COMPATIBILITY_OVERRIDE</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_COMPATIBILITY_OVERRIDE</span>	APPLE_KEXT_OVERRIDE
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_OVERRIDE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_COMPATIBILITY_OVERRIDE</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*!
 * @class OSMetaClassBase
 *
 * @abstract
 * OSMetaClassBase is the abstract bootstrap class
 * for the Libkern and I/O Kit run-time type information system.
 *
 * @discussion
 * OSMetaClassBase is the abstract C++ root class
 * underlying the entire Libkern and I/O Kit class hierarchy.
 * It defines the run-time type information system,
 * including dynamic class allocation and safe type-casting,
 * as well as the abstract interface for reference counting
 * and a few other utility functions.
 * OSMetaClassBase is the immediate superclass of
 * @link //apple_ref/doc/class/OSObject OSObject@/link and
 * @link //apple_ref/doc/class/OSMetaClass OSMetaClass@/link;
 * no other class should derive from OSMetaClassBase.
 *
 * For more information, see
 * &lt;i&gt;@link //apple_ref/doc/uid/TP40002799
 * I/O Kit Device Driver Design Guidelines@/link&lt;/i&gt;.
 *
 * &lt;b&gt;Use by Kernel Extensions&lt;/b&gt;
 *
 * Kernel Extensions should never interact directly with OSMetaClassBase,
 * but they will find useful several macros that tie in
 * to the run-time type information system, specifically:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;@link OSTypeAlloc OSTypeAlloc@/link&lt;/code&gt; - allocation of new instances&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt; - safe type casting&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt; -
 *     checking for inheritance/derivation&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSMemberFunctionCast OSMemberFunctionCast@/link&lt;/code&gt; -
 *     casting C++ member functions to C function pointers
 *     for registration as callbacks&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * See @link //apple_ref/doc/class/OSMetaClass OSMetaClass@/link
 * for more run-time type information interfaces.
 *
 * &lt;b&gt;Use Restrictions&lt;/b&gt;
 *
 * OSMetaClassBase should not be subclassed by kernel extensions,
 * nor should kernel extensions call its run-time type functions directly.
 *
 * The run-time type functions and macros are &lt;b&gt;not safe&lt;/b&gt;
 *  to call in a primary interrupt context.
 *
 * &lt;b&gt;Concurrency Protection&lt;/b&gt;
 *
 * The run-time type macros and functions of OSMetaClassBase are thread-safe.
 */</span>
class OSMetaClassBase
{
<span class="enscript-reference">public</span>:


   <span class="enscript-comment">/*!
    * @define OSTypeAlloc
    * @hidecontents
    *
    * @abstract
    * Allocates an instance of the named object class.
    *
    * @param type    The name of the desired class to be created,
    *                as a raw token, &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @result
    * A pointer to the new, uninitialized object on success;
    * &lt;code&gt;NULL&lt;/code&gt; on failure.
    *
    * @discussion
    * See also
    * &lt;code&gt;@link
    * //apple_ref/cpp/clm/OSMetaClass/allocClassWithName/staticOSObject*\/(constchar*)
    * OSMetaClass::allocClassWithName(const char *)@/link&lt;/code&gt;
    * and
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSMetaClass/alloc/virtualOSObject*\/()
    * OSMetaClass::alloc@/link&lt;/code&gt;.
    *
    * The OSTypeAlloc macro is used to avoid binary compatibility difficulties
    * presented by the C++ &lt;code&gt;new&lt;/code&gt; operator.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSTypeAlloc</span>(type)   ((type *) ((type::metaClass)-&gt;alloc()))


   <span class="enscript-comment">/*!
    * @define OSTypeID
    * @hidecontents
    *
    * @abstract
    * Returns the type ID (metaclass) of a class based on its name.
    *
    * @param type    The name of the desired class, as a raw token,
    *                &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @result
    * The unique type ID (metaclass) for the class.
    *
    * @discussion
    * It is typically more useful to determine whether a class is derived
    * from another; see
    * &lt;code&gt;@link //apple_ref/cpp/macro/OSDynamicCast OSDynamicCast@/link&lt;/code&gt;
    * and
    * &lt;code&gt;@link //apple_ref/cpp/macro/OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSTypeID</span>(type)   (type::metaClass)


   <span class="enscript-comment">/*!
    * @define OSTypeIDInst
    * @hidecontents
    *
    * @abstract
    * Returns the type ID (metaclass) for the class of an object instance.
    *
    * @param typeinst An instance of an OSObject subclass.
    *
    * @result
    * The type ID of that object's class; that is, its metaclass.
    *
    * @discussion
    * It is typically more useful to determine whether an object is derived
    * from a particular class; see
    * &lt;code&gt;@link //apple_ref/cpp/macro/OSDynamicCast OSDynamicCast@/link&lt;/code&gt;
    * and
    * &lt;code&gt;@link //apple_ref/cpp/macro/OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSTypeIDInst</span>(typeinst)   ((typeinst)-&gt;getMetaClass())


   <span class="enscript-comment">/*!
    * @define OSDynamicCast
    * @hidecontents
    *
    * @abstract
    * Safe type-casting for Libkern C++ objects.
    *
    * @param type    The name of the desired class type, as a raw token,
    *                &lt;i&gt;not&lt;/i&gt; a string or macro.
    *                It is assumed you intend to cast to a pointer
    *                to an object of this type.
    *                Type qualifiers, such as &lt;code&gt;const&lt;/code&gt;,
    *                are not recognized and will cause
    *                a (usually obscure) compile error.
    * @param inst    A pointer to the object instance to be cast.
    *                May be &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @result
    * &lt;code&gt;inst&lt;/code&gt; if it is non-&lt;code&gt;NULL&lt;/code&gt;
    * and derived from &lt;code&gt;type&lt;/code&gt;;
    * otherwise &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @discussion
    * &lt;code&gt;OSDynamicCast&lt;/code&gt; is a rough equivalent
    * to the standard C++ RTTI &lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;&lt;/code&gt; operator.
    * Your code should use this instead of raw C type-casting,
    * and check the resulting value.
    * If the result is non-&lt;code&gt;NULL&lt;/code&gt;,
    * the object is safe to use as the type-cast class;
    * if the result is &lt;code&gt;NULL&lt;/code&gt;,
    * the object does not derive from the type-cast class
    * and your code should take appropriate steps to handle the error.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDynamicCast</span>(type, inst)   \
    ((type *) OSMetaClassBase::safeMetaCast((inst), OSTypeID(type)))


   <span class="enscript-comment">/*!
    * @define OSCheckTypeInst
    * @hidecontents
    *
    * @abstract
    * Checks whether two objects are type-compatible.
    *
    * @param typeinst The reference object.
    * @param inst     The object to check for type compatibility.
    *
    * @result
    * &lt;code&gt;true&lt;/code&gt; if both &lt;code&gt;inst&lt;/code&gt; and
    * &lt;code&gt;typeinst&lt;/code&gt; are non-&lt;code&gt;NULL&lt;/code&gt;
    * and &lt;code&gt;inst&lt;/code&gt; is derived from the class of &lt;code&gt;typeinst&lt;/code&gt;;
    * otherwise &lt;code&gt;false&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSCheckTypeInst</span>(typeinst, inst) \
    <span class="enscript-reference">OSMetaClassBase</span>::checkTypeInst(inst, typeinst)

<span class="enscript-comment">/*! @function OSSafeRelease
 *  @abstract Release an object if not &lt;code&gt;NULL&lt;/code&gt;.
 *  @param    inst  Instance of an OSObject, may be &lt;code&gt;NULL&lt;/code&gt;.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSSafeRelease</span>(inst)       do { if (inst) (inst)-&gt;release(); } while (0)

<span class="enscript-comment">/*! @function OSSafeReleaseNULL
 *  @abstract Release an object if not &lt;code&gt;NULL&lt;/code&gt;, then set it to &lt;code&gt;NULL&lt;/code&gt;.
 *  @param    inst  Instance of an OSObject, may be &lt;code&gt;NULL&lt;/code&gt;.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSSafeReleaseNULL</span>(inst)   do { if (inst) (inst)-&gt;release(); (inst) = NULL; } while (0)

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*_ptf_t)(<span class="enscript-type">void</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_KEXT_LEGACY_ABI</span>

<span class="enscript-comment">// Arcane evil code interprets a C++ pointer to function as specified in the
</span><span class="enscript-comment">// -fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
</span><span class="enscript-comment">// the conversion of functions that are from MULTIPLY inherited classes.
</span>
<span class="enscript-type">static</span> inline _ptf_t
<span class="enscript-function-name">_ptmf2ptf</span>(<span class="enscript-type">const</span> OSMetaClassBase *self, <span class="enscript-type">void</span> (OSMetaClassBase::*func)(<span class="enscript-type">void</span>))
{
    <span class="enscript-type">union</span> {
        <span class="enscript-type">void</span> (OSMetaClassBase::*fIn)(<span class="enscript-type">void</span>);
        <span class="enscript-type">struct</span> {     <span class="enscript-comment">// Pointer to member function 2.95
</span>            <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> fToff;
            <span class="enscript-type">short</span>  fVInd;
            <span class="enscript-type">union</span> {
                _ptf_t fPFN;
                <span class="enscript-type">short</span>  fVOff;
            } u;
        } fptmf2;
    } map;

    map.fIn = func;
    <span class="enscript-keyword">if</span> (map.fptmf2.fToff) {
        panic(<span class="enscript-string">&quot;Multiple inheritance is not supported&quot;</span>);
        <span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (map.fptmf2.fVInd &lt; 0) {
        <span class="enscript-comment">// Not virtual, i.e. plain member func
</span>        <span class="enscript-keyword">return</span> map.fptmf2.u.fPFN;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-type">union</span> {
            <span class="enscript-type">const</span> OSMetaClassBase *fObj;
            _ptf_t **vtablep;
        } u;
        u.fObj = self;

        <span class="enscript-comment">// Virtual member function so dereference vtable
</span>        <span class="enscript-keyword">return</span> (*u.vtablep)[map.fptmf2.fVInd - 1];
    }
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !APPLE_KEXT_LEGACY_ABI */</span>
#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

<span class="enscript-comment">// Slightly less arcane and slightly less evil code to do
</span><span class="enscript-comment">// the same for kexts compiled with the standard Itanium C++
</span><span class="enscript-comment">// ABI
</span>
<span class="enscript-type">static</span> inline _ptf_t
<span class="enscript-function-name">_ptmf2ptf</span>(<span class="enscript-type">const</span> OSMetaClassBase *self, <span class="enscript-type">void</span> (OSMetaClassBase::*func)(<span class="enscript-type">void</span>))
{
    <span class="enscript-type">union</span> {
        <span class="enscript-type">void</span> (OSMetaClassBase::*fIn)(<span class="enscript-type">void</span>);
        uintptr_t fVTOffset;
        _ptf_t fPFN;
    } map;

    map.fIn = func;

    <span class="enscript-keyword">if</span> (map.fVTOffset &amp; 1) {
        <span class="enscript-comment">// virtual
</span>        <span class="enscript-type">union</span> {
            <span class="enscript-type">const</span> OSMetaClassBase *fObj;
            _ptf_t **vtablep;
        } u;
        u.fObj = self;

        <span class="enscript-comment">// Virtual member function so dereference vtable
</span>        <span class="enscript-keyword">return</span> *(_ptf_t *)(((uintptr_t)*u.vtablep) + map.fVTOffset - 1);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">// Not virtual, i.e. plain member func
</span>        <span class="enscript-keyword">return</span> map.fPFN;
    }
}

#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>.
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __arm__ */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !APPLE_KEXT_LEGACY_ABI */</span>

   <span class="enscript-comment">/*!
    * @define OSMemberFunctionCast
    * @hidecontents
    *
    * @abstract
    * Converts a C++ member function pointer, relative to an instance,
    * to a C-style pointer to function.
    *
    * @param cptrtype The function type declaration to cast to
    *                 (typically provided as a &lt;code&gt;typedef&lt;/code&gt; by  I/O KitKit classes).
    * @param self     The &lt;code&gt;this&lt;/code&gt; pointer of the object whose function
    *                 you wish to cache.
    * @param func     The pointer to the member function itself,
    *                 something like &lt;code&gt;&amp;Class::function&lt;/code&gt;.
    *
    * @result
    * A pointer to a function of the given type referencing &lt;code&gt;self&lt;/code&gt;.  
    *
    * @discussion
    * This function is used to generate pointers to C++ functions for instances,
    * such that they can be registered as callbacks with I/O Kit objects.
    *
    * No warnings are generated.
    *
    * This function will panic if an attempt is made to call it
    * with a multiply-inheriting class.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMemberFunctionCast</span>(cptrtype, self, func)         \
    (cptrtype) OSMetaClassBase::                           \
        _ptmf2ptf(self, (<span class="enscript-type">void</span> (OSMetaClassBase::*)(<span class="enscript-type">void</span>)) func)

<span class="enscript-reference">protected</span>:
    OSMetaClassBase();
    virtual ~OSMetaClassBase();

<span class="enscript-reference">private</span>:
    <span class="enscript-comment">// Disable copy constructors of OSMetaClassBase based objects
</span>   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @function operator =
    *
    * @abstract
    * Disable implicit copy constructor by making private
    *
    * @param src Reference to source object that isn't allowed to be copied.
    */</span>
    <span class="enscript-type">void</span> operator =(OSMetaClassBase &amp;src);

   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @function OSMetaClassBase
    *
    * @abstract
    * Disable implicit copy constructor by making private
    *
    * @param src Reference to source object that isn't allowed to be copied.
    */</span>
    OSMetaClassBase(OSMetaClassBase &amp;src);

<span class="enscript-reference">public</span>:

<span class="enscript-comment">// xx-review: the original comment for this makes it sound to me like we don't
</span><span class="enscript-comment">// xx-review: catch over-releasing an object...?
</span>
   <span class="enscript-comment">/*!
    * @function release
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/release/virtualvoid/(int)
    * release(int freeWhen)@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/release/virtualvoid/(int)
    * release(int freeWhen)@/link&lt;/code&gt;.
    */</span>
    virtual <span class="enscript-type">void</span> release(<span class="enscript-type">int</span> freeWhen) <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function getRetainCount
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/getRetainCount/virtualint/()
    * getRetainCount()@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/getRetainCount/virtualint/()
    * OSObject::getRetainCount()@/link&lt;/code&gt;.
    */</span>
    virtual <span class="enscript-type">int</span> getRetainCount() <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function retain
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/retain/virtualvoid/()
    * retain()@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/retain/virtualvoid/()
    * OSObject::retain()@/link&lt;/code&gt;.
    */</span>
    virtual <span class="enscript-type">void</span> retain() <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function release
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/release/virtualvoid/()
    * release@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/release/virtualvoid/()
    * OSObject::release@/link&lt;/code&gt;.
    */</span>
    virtual <span class="enscript-type">void</span> release() <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function serialize
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/serialize/virtualbool/(OSSerialize*)
    * serialize@/link&lt;/code&gt;.
    *
    * @discussion
    * See 
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/serialize/virtualbool/(OSSerialize*)
    * OSObject::serialize@/link&lt;/code&gt;.
    */</span>
    virtual bool serialize(OSSerialize * serializer) <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function getMetaClass
    *
    * @abstract
    * Returns the OSMetaClass representing
    * an OSMetaClassBase subclass.
    *
    * @discussion
    * OSObject overrides this abstract member function
    * to return the OSMetaClass object that represents
    * each class for run-time typing.
    */</span>
    virtual <span class="enscript-type">const</span> OSMetaClass * getMetaClass() <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function isEqualTo
    *
    * @abstract
    * Checks whether another object is equal to the receiver.
    *
    * @param anObject The object to copmare to the receiver.
    *
    * @result
    * &lt;code&gt;true&lt;/code&gt; if the objects are equal, &lt;code&gt;false&lt;/code&gt; otherwise.
    *
    * @discussion
    * OSMetaClassBase implements this as a direct pointer comparison,
    * since it has no other information to judge equality by.
    * Subclasses generally override this function
    * to do a more meaningful comparison.
    * For example, OSString implements it to return
    * &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;anObject&lt;/code&gt;
    * is derived from OSString and represents the same C string.
    */</span>
    virtual bool isEqualTo(<span class="enscript-type">const</span> OSMetaClassBase * anObject) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function metaCast
    *
    * @abstract
    * Casts this object is to the class managed by the given OSMetaClass.
    *
    * @param toMeta A pointer to a constant OSMetaClass
    *               for the desired target type.
    *
    * @result
    * &lt;code&gt;this&lt;/code&gt; if the object is derived
    * from the class managed by &lt;code&gt;toMeta&lt;/code&gt;,
    * otherwise &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @discussion
    * It is far more convenient to use
    * &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt;.
    */</span>
    OSMetaClassBase * metaCast(<span class="enscript-type">const</span> OSMetaClass * toMeta) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function metaCast
    *
    * @abstract
    * Casts this object is to the class managed by the named OSMetaClass.
    *
    * @param toMeta An OSSymbol naming the desired target type.
    *
    * @result
    * &lt;code&gt;this&lt;/code&gt; if the object is derived
    * from the class named by &lt;code&gt;toMeta&lt;/code&gt;,
    * otherwise &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @discussion
    * It is far more convenient to use
    * &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt;.
    */</span>
    OSMetaClassBase * metaCast(<span class="enscript-type">const</span> OSSymbol * toMeta) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function metaCast
    *
    * @abstract
    * Casts this object is to the class managed by the named OSMetaClass.
    *
    * @param toMeta An OSString naming the desired target type.
    * @result
    * &lt;code&gt;this&lt;/code&gt; if the object is derived
    * from the class named by &lt;code&gt;toMeta&lt;/code&gt;,
    * otherwise &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @discussion
    * It is far more convenient to use
    * &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt;.
    */</span>
    OSMetaClassBase * metaCast(<span class="enscript-type">const</span> OSString * toMeta) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function metaCast
    *
    * @abstract
    * Casts this object is to the class managed by the named OSMetaClass.
    *
    * @param toMeta A C string naming the desired target type.
    * @result
    * &lt;code&gt;this&lt;/code&gt; if the object is derived
    * from the class named by &lt;code&gt;toMeta&lt;/code&gt;,
    * otherwise &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @discussion
    * It is far more convenient to use
    * &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt;.
    */</span>
    OSMetaClassBase * metaCast(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * toMeta) <span class="enscript-type">const</span>;

    <span class="enscript-comment">// Helper inlines for run-time type preprocessor macros
</span>   <span class="enscript-comment">/*!
    * @function safeMetaCast
    *
    * @abstract
    * Casts an object is to the class managed by the given OSMetaClass.
    *
    * @param anObject A pointer to the object to be cast.
    * @param toMeta   A pointer to a constant OSMetaClass
    *                 for the desired target type.
    *
    * @result
    * &lt;code&gt;anObject&lt;/code&gt; if the object is derived
    * from the class managed by &lt;code&gt;toMeta&lt;/code&gt;,
    * otherwise &lt;code&gt;NULL&lt;/code&gt;.
    *
    * @discussion
    * It is far more convenient to use
    * &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> OSMetaClassBase * safeMetaCast(
        <span class="enscript-type">const</span> OSMetaClassBase * anObject,
        <span class="enscript-type">const</span> OSMetaClass     * toMeta);

   <span class="enscript-comment">/*!
    * @function checkTypeInst
    *
    * @abstract
    * Checks whether an object instance is of the same class
    * as another object instance (or a subclass of that class).
    *
    * @param inst       A pointer to the object to check.
    * @param typeinst   A pointer to an object of the class being checked.
    *
    * @result
    * &lt;code&gt;true&lt;/code&gt; if the object is derived
    * from the class of &lt;code&gt;typeinst&lt;/code&gt;
    * or a subclass of that class,
    * otherwise &lt;code&gt;false&lt;/code&gt;.
    *
    * @discussion
    * It is far more convenient to use
    * &lt;code&gt;@link OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> bool checkTypeInst(
        <span class="enscript-type">const</span> OSMetaClassBase * inst,
        <span class="enscript-type">const</span> OSMetaClassBase * typeinst);

    <span class="enscript-type">static</span> <span class="enscript-type">void</span> initialize(<span class="enscript-type">void</span>);

<span class="enscript-reference">public</span>:

   <span class="enscript-comment">/*!
    * @function taggedRetain
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/taggedRetain/virtualvoid/(constvoid*)
    * taggedRetain(const void *)@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/taggedRetain/virtualvoid/(constvoid*)
    * OSObject::taggedRetain(const void *)@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-comment">// WAS: virtual void _RESERVEDOSMetaClassBase0();
</span>    virtual <span class="enscript-type">void</span> taggedRetain(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * tag = 0) <span class="enscript-type">const</span> = 0;


   <span class="enscript-comment">/*!
    * @function taggedRelease
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/taggedRelease/virtualvoid/(constvoid*)
    * taggedRelease(const void *)@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/taggedRelease/virtualvoid/(constvoid*)
    * OSObject::taggedRelease(const void *)@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-comment">// WAS:  virtual void _RESERVEDOSMetaClassBase1();
</span>    virtual <span class="enscript-type">void</span> taggedRelease(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * tag = 0) <span class="enscript-type">const</span> = 0;

<span class="enscript-reference">protected</span>:
   <span class="enscript-comment">/*!
    * @function taggedRelease
    *
    * @abstract
    * Abstract declaration of
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/taggedRelease/virtualvoid/(constvoid*,constint)
    * taggedRelease(const void *, const int freeWhen)@/link&lt;/code&gt;.
    *
    * @discussion
    * See
    * &lt;code&gt;@link
    * //apple_ref/cpp/instm/OSObject/taggedRelease/virtualvoid/(constvoid*,constint)
    * OSObject::taggedRelease(const void *, const int freeWhen)@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-comment">// WAS:  virtual void _RESERVEDOSMetaClassBase2();
</span>    virtual <span class="enscript-type">void</span> taggedRelease(
        <span class="enscript-type">const</span> <span class="enscript-type">void</span> * tag,
        <span class="enscript-type">const</span> <span class="enscript-type">int</span>    freeWhen) <span class="enscript-type">const</span> = 0;

<span class="enscript-reference">private</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_KEXT_VTABLE_PADDING</span>
    <span class="enscript-comment">// Virtual Padding
</span>    virtual <span class="enscript-type">void</span> _RESERVEDOSMetaClassBase3();
    virtual <span class="enscript-type">void</span> _RESERVEDOSMetaClassBase4();
    virtual <span class="enscript-type">void</span> _RESERVEDOSMetaClassBase5();
    virtual <span class="enscript-type">void</span> _RESERVEDOSMetaClassBase6();
    virtual <span class="enscript-type">void</span> _RESERVEDOSMetaClassBase7();
#<span class="enscript-reference">endif</span>
} APPLE_KEXT_COMPATIBILITY;


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">bool</span> (*OSMetaClassInstanceApplierFunction)(<span class="enscript-type">const</span> OSObject * instance,
						   <span class="enscript-type">void</span> * context);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*!
 * @class OSMetaClass
 *
 * @abstract
 * OSMetaClass manages run-time type information
 * for Libkern and I/O Kit C++ classes.
 *
 * @discussion
 *
 * OSMetaClass manages run-time type information
 * for Libkern and I/O Kit C++ classes.
 * An instance of OSMetaClass exists for (nearly) every such C++ class,
 * keeping track of inheritance relationships, class lookup by name,
 * instance counts, and more.
 * OSMetaClass operates almost entirely behind the scenes,
 * and kernel extensions should rarely, if ever,
 * have to interact directly with OSMetaClass.
 *
 * &lt;b&gt;Use by Kernel Extensions&lt;/b&gt;
 *
 * While kernel extensions rarey interact directly with OSMetaClass at run time,
 * they must register their classes with the metaclass system
 * using the macros declared here.
 * The class declaration should use one of these two macros
 * before its first member function declaration:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDeclareDefaultStructors OSDeclareDefaultStructors@/link&lt;/code&gt; -
 *     for classes with no abstract member function declarations&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDeclareAbstractStructors OSDeclareAbstractStructors@/link&lt;/code&gt; -
 *     for classes with at least one abstract member function declaration&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDeclareFinalStructors OSDeclareFinalStructors@/link&lt;/code&gt; -
 *     for classes that should not be subclassable by another kext&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * The class implementation should then use one of these macros:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDefineMetaClassAndStructors
 *           OSDefineMetaClassAndStructors@/link&lt;/code&gt; -
 *     for classes with no abstract member function declarations&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDefineMetaClassAndAbstractStructors
 *           OSDefineMetaClassAndAbstractStructors@/link&lt;/code&gt; -
 *     for classes with at least one abstract member function declaration&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSDefineMetaClassAndFinalStructors
 *           OSDefineMetaClassAndFinalStructors@/link&lt;/code&gt; -
 *     for classes that should not be subclassable by another kext&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Classes in kernel extensions that are intended for use as libraries
 * may need to reserve vtable slots to preserve binary compatibility
 * as new functions are added. They may do so with these macros:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;@link OSMetaClassDeclareReservedUnused
 *           OSMetaClassDeclareReservedUnused@/link&lt;/code&gt; -
 *     reserves a vtable slot&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSMetaClassDefineReservedUnused
 *           OSMetaClassDefineReservedUnused@/link&lt;/code&gt; -
 *     defines the reserved vtable slot as an unimplemented function&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSMetaClassDeclareReservedUsed
 *           OSMetaClassDeclareReservedUsed@/link&lt;/code&gt; -
 *     documents that a formerly reserved slot is now used&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;@link OSMetaClassDefineReservedUsed
 *           OSMetaClassDefineReservedUsed@/link&lt;/code&gt; -
 *    documents that a formerly reserved slot is now used&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;b&gt;Use Restrictions&lt;/b&gt;
 *
 * OSMetaClass should not be explicitly subclassed by kernel extensions
 * (the declare/define macros do that),
 * nor should kernel extensions call its run-time type functions directly.
 *
 * OSMetaClass functions should be considered
 * &lt;b&gt;unsafe&lt;/b&gt; to call in a primary interrupt context.
 *
 * &lt;b&gt;Concurrency Protection&lt;/b&gt;
 *
 * Kernel extensions should in general not interact
 * with OSMetaClass objects directly,
 * instead using the run-time type macros.
 * Much of OSMetaClass's interface is intended for use
 * by the run-time type information system,
 * which handles concurrency and locking internally.
 */</span>
class OSMetaClass : private OSMetaClassBase
{
    friend class OSKext;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOKITSTATS</span>
	friend class IOStatistics;
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">private</span>:
    <span class="enscript-comment">// Can never be allocated must be created at compile time
</span>    <span class="enscript-type">static</span> <span class="enscript-type">void</span> * operator new(size_t size);

   <span class="enscript-comment">/* Reserved for future use.  (Internal use only) */</span>
    <span class="enscript-type">struct</span> ExpansionData *reserved;

   <span class="enscript-comment">/* superClass Handle to the superclass's meta class. */</span>
    <span class="enscript-type">const</span> OSMetaClass *superClassLink;

   <span class="enscript-comment">/* className OSSymbol of the class' name. */</span>
    <span class="enscript-type">const</span> OSSymbol *className;

   <span class="enscript-comment">/* classSize How big is a single instance of this class. */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> classSize;

   <span class="enscript-comment">/* instanceCount Roughly number of instances of the object,
    * +1 for each direct subclass with a nonzero refcount.
    * Used primarily as a code-in-use flag.
    */</span>
    mutable <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> instanceCount;

   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @function OSMetaClass
    *
    * @abstract
    * The default private constructor.
    */</span>
    OSMetaClass();

    <span class="enscript-comment">// Called by postModLoad
</span>   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @function logError
    *
    * @abstract
    * Logs an error string for an &lt;code&gt;OSReturn&lt;/code&gt; value
    * using &lt;code&gt;printf&lt;/code&gt;.
    *
    * @param result  The &lt;code&gt;OSReturn&lt;/code&gt; value for which to log a message.
    *
    * @discussion
    * This function is used to log errors loading kernel extensions.
    * Kernel extensions themselves should not call it.
    */</span>
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> logError(OSReturn result);

<span class="enscript-reference">public</span>:

   <span class="enscript-comment">/*!
    * @function getMetaClassWithName
    *
    * @abstract
    * Look up a metaclass in the run-time type information system.
    *
    * @param name The name of the desired class's metaclass. 
    *
    * @result
    * A pointer to the metaclass object if found, &lt;code&gt;NULL&lt;/code&gt; otherwise.
    */</span>
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> OSMetaClass * getMetaClassWithName(<span class="enscript-type">const</span> OSSymbol * name);

<span class="enscript-reference">protected</span>:
   <span class="enscript-comment">/*!
    * @function retain
    *
    * @abstract
    * Implements the abstract &lt;code&gt;retain&lt;/code&gt; function to do nothing.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">void</span> retain() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function release
    *
    * @abstract
    * Implements the abstract &lt;code&gt;release&lt;/code&gt; function to do nothing.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">void</span> release() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function release
    *
    * @abstract
    * Implements the abstract &lt;code&gt;release(int freeWhen)&lt;/code&gt;
    * function to do nothing.
    *
    * @param freeWhen  Unused.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">void</span> release(<span class="enscript-type">int</span> freeWhen) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function taggedRetain
    *
    * @abstract
    * Implements the abstract &lt;code&gt;taggedRetain(const void *)&lt;/code&gt;
    * function to do nothing.
    *
    * @param tag  Unused.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">void</span> taggedRetain(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * tag = 0) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function taggedRelease
    *
    * @abstract
    * Implements the abstract &lt;code&gt;taggedRelease(const void *)&lt;/code&gt;
    * function to do nothing.
    *
    * @param tag  Unused.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">void</span> taggedRelease(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * tag = 0) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function taggedRelease
    *
    * @abstract
    * Implements the abstract &lt;code&gt;taggedRelease(const void *, cont int)&lt;/code&gt;
    * function to do nothing.
    *
    * @param tag       Unused.
    * @param freeWhen  Unused.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">void</span> taggedRelease(
        <span class="enscript-type">const</span> <span class="enscript-type">void</span> * tag,
        <span class="enscript-type">const</span> <span class="enscript-type">int</span>    freeWhen) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function getRetainCount
    *
    * @abstract
    * Implements the abstract &lt;code&gt;getRetainCount&lt;/code&gt;
    * function to return 0.
    *
    * @result
    * Always returns 0.
    *
    * @discussion
    * Since an OSMetaClass instance must remain in existence
    * for as long as its kernel extension is loaded,
    * OSMetaClass does not use reference-counting.
    */</span>
    virtual <span class="enscript-type">int</span> getRetainCount() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @function getMetaClass
    *
    * @abstract
    * Returns the meta-metaclass.
    *
    * @result
    * The metaclass of the OSMetaClass object.
    */</span>
    virtual <span class="enscript-type">const</span> OSMetaClass * getMetaClass() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function OSMetaClass
    *
    * @abstract
    * Constructor for OSMetaClass objects.
    *
    * @param className  A C string naming the C++ class
    *                   that this OSMetaClass represents.
    * @param superclass The OSMetaClass object representing the superclass
    *                   of this metaclass's class.
    * @param classSize  The allocation size of the represented C++ class.
    *
    * @discussion
    * This constructor is protected and cannot be used
    * to instantiate OSMetaClass directly, as OSMetaClass is an abstract class.
    * This function is called during kext loading
    * to queue C++ classes for registration.
    * See &lt;code&gt;@link preModLoad preModLoad@/link&lt;/code&gt; and
    * &lt;code&gt;@link postModLoad postModLoad@/link&lt;/code&gt;.
    */</span>
    OSMetaClass(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * className,
        <span class="enscript-type">const</span> OSMetaClass  * superclass,
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>         classSize);


   <span class="enscript-comment">/*!
    * @function ~OSMetaClass
    *
    * @abstract
    * Destructor for OSMetaClass objects.
    *
    * @discussion
    * This function is called when the kernel extension that implements
    * the metaclass's class is unloaded.
    * The destructor removes all references to the class
    * from the run-time type information system.
    */</span>
    virtual ~OSMetaClass();

    <span class="enscript-comment">// Needs to be overriden as NULL as all OSMetaClass objects are allocated
</span>    <span class="enscript-comment">// statically at compile time, don't accidently try to free them.
</span>    <span class="enscript-type">void</span> operator delete(<span class="enscript-type">void</span> *, size_t) { };

<span class="enscript-reference">public</span>:
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> metaClass;

   <span class="enscript-comment">/*!
    * @function preModLoad
    *
    * @abstract
    * Prepares the run-time type system
    * for the creation of new metaclasses
    * during loading of a kernel extension (module).
    *
    * @param kextID  The bundle ID of the kext being loaded.
    *
    * @result
    * An opaque handle to the load context
    * for the kernel extension on success;
    * &lt;code&gt;NULL&lt;/code&gt; on failure.
    *
    * @discussion
    * &lt;i&gt;Not for use by kernel extensions.&lt;/i&gt;
    *
    * Prepares the run-time type information system to record and register
    * metaclasses created by static constructors until a subsequent call to
    * &lt;code&gt;@link postModLoad postModLoad@/link&lt;/code&gt;.
    * &lt;code&gt;preModLoad&lt;/code&gt; takes a lock to ensure processing of a single
    * load operation at a time; the lock is released by
    * &lt;code&gt;@link postModLoad postModLoad@/link&lt;/code&gt;.
    * Any OSMetaClass constructed between these two function calls
    * will be associated with &lt;code&gt;kextID&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> * preModLoad(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kextID);


   <span class="enscript-comment">/*!
    * @function checkModLoad
    *
    * @abstract
    * Checks whether the current kext load operation can proceed.
    *
    * @param loadHandle The opaque handle returned
    *                   by &lt;code&gt;@link preModLoad preModLoad@/link&lt;/code&gt;.
    * @result
    * &lt;code&gt;true&lt;/code&gt; if no errors are outstanding
    * and the system is ready to process more metaclasses.
    *
    * @discussion
    * &lt;i&gt;Not for use by kernel extensions.&lt;/i&gt;
    */</span>
    <span class="enscript-type">static</span> bool checkModLoad(<span class="enscript-type">void</span> * loadHandle);


   <span class="enscript-comment">/*!
    * @function postModLoad
    *
    * @abstract
    * Registers the metaclasses created during loading of a kernel extension.
    *
    * @param loadHandle The opaque handle returned
    *                   by &lt;code&gt;@link preModLoad preModLoad@/link&lt;/code&gt;.
    * @result
    * The error code of the first error encountered,
    * or
    * &lt;code&gt;@link
    * //apple_ref/cpp/macro/kOSReturnSuccess
    * kOSReturnSuccess@/link&lt;/code&gt;
    * if no error occurred.
    *
    * @discussion
    * &lt;i&gt;Not for use by kernel extensions.&lt;/i&gt;
    *
    * Called after all static constructors in a kernel extension
    * have created metaclasses,
    * this function checks for duplicate class names,
    * then registers the new metaclasses under the kext ID
    * that @link preModLoad preModLoad@/link was called with,
    * so that they can be dynamically allocated
    * and have their instance counts tracked.
    * &lt;code&gt;postModLoad&lt;/code&gt; releases the lock taken by
    * &lt;code&gt;@link preModLoad preModLoad@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> OSReturn postModLoad(<span class="enscript-type">void</span> * loadHandle);

   <span class="enscript-comment">/*!
    * @function modHasInstance
    *
    * @abstract
    * Returns whether any classes defined by the named
    * kernel extension (or their subclasses) have existing instances.
    *
    * @param kextID   The bundle ID of the kernel extension to check.
    *
    * @result
    * &lt;code&gt;true&lt;/code&gt; if the kext is found and
    * if any class defined by that kext
    * has a nonzero instance count,
    * &lt;code&gt;false&lt;/code&gt; otherwise.
    *
    * @discussion
    * This function is called before a kernel extension's static destructors
    * are invoked, prior to unloading the extension.
    * If any classes stil have instances or subclasses with instances,
    * those classes are logged
    * (using &lt;code&gt;@link reportModInstances reportModInstances@/link&lt;/code&gt;) and
    * the kernel extension is not be unloaded.
    */</span>
    <span class="enscript-type">static</span> bool modHasInstance(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kextID);


   <span class="enscript-comment">/*!
    * @function reportModInstances
    *
    * @abstract
    * Logs the instance counts for classes
    * defined by a kernel extension.
    *
    * @param kextID   The bundle ID of the kernel extension to report on.
    *
    * @discussion
    * This function prints the names and instance counts
    * of any class defined by &lt;code&gt;kextID&lt;/code&gt;
    * that has a nonzero instance count.
    * It's called by &lt;code&gt;@link modHasInstance modHasInstance@/link&lt;/code&gt;
    * to help diagnose problems unloading kernel extensions.
    */</span>
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> reportModInstances(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kextID);


   <span class="enscript-comment">/*!
    * @function considerUnloads
    *
    * @abstract
    * Schedule automatic unloading of unused kernel extensions.
    *
    * @discussion
    * This function schedules a check for kernel extensions
    * that can be automatically unloaded,
    * canceling any currently scheduled check.
    * At that time, any such kexts with no Libkern C++ instances
    * and no external references are unloaded.
    *
    * The I/O Kit calls this function when matching goes idle.
    *
    * Kernel extensions that define subclasses of
    * @link //apple_ref/doc/class/IOService IOService@/link
    * are eligible for automatic unloading.
    *
    * (On releases of Mac OS X prior to Snow Leopard (10.6),
    * any kernel extension defining any Libkern C++ class
    * was eligible for automatic unloading,
    * but that unload did not call the module stop routine.
    * Non-I/O Kit kernel extensions that define Libkern C++ subclasses
    * should be sure to have OSBundleLibraries declarations that ensure
    * they will not load on releases prior to Snow Leopard.)
    */</span>
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> considerUnloads();


   <span class="enscript-comment">/*!
    * @function allocClassWithName
    *
    * @abstract
    * Allocates an instance of a named OSObject-derived class.
    *
    * @param name The name of the desired class. 
    *
    * @result
    * A pointer to the newly-allocated, uninitialized object on success;
    * &lt;code&gt;NULL&lt;/code&gt; on failure.
    *
    * @discussion
    * Kernel extensions should not need to use this function
    * directly, instead using static instance-creation functions
    * defined by classes.
    *
    * This function consults the run-time type information system
    * to find the metaclass for the named class.
    * If it exists, it calls the metaclass's &lt;code&gt;@link alloc alloc@/link&lt;/code&gt;
    * function and returns the result.
    */</span>
    <span class="enscript-type">static</span> OSObject * allocClassWithName(<span class="enscript-type">const</span> OSSymbol * name);


   <span class="enscript-comment">/*!
    * function allocClassWithName
    *
    * @abstract
    * Allocates an instance of a named OSObject-derived class.
    *
    * @param name The name of the desired class. 
    *
    * @result
    * A pointer to the newly-allocated, uninitialized object on success;
    * &lt;code&gt;NULL&lt;/code&gt; on failure.
    *
    * @discussion
    * Kernel extensions should not need to use this function
    * directly, instead using static instance-creation functions
    * defined by classes.
    *
    * This function consults the run-time type information system
    * to find the metaclass for the named class.
    * If it exists, it calls the metaclass's &lt;code&gt;@link alloc alloc@/link&lt;/code&gt;
    * function and returns the result.
    */</span>
    <span class="enscript-type">static</span> OSObject * allocClassWithName(<span class="enscript-type">const</span> OSString * name);


   <span class="enscript-comment">/*!
    * function allocClassWithName
    *
    * @abstract
    * Allocates an instance of a named OSObject-derived class.
    *
    * @param name The name of the desired class. 
    *
    * @result
    * A pointer to the newly-allocated, uninitialized object on success;
    * &lt;code&gt;NULL&lt;/code&gt; on failure.
    *
    * @discussion
    * Kernel extensions should not need to use this function
    * directly, instead using static instance-creation functions
    * defined by classes.
    *
    * This function consults the run-time type information system
    * to find the metaclass for the named class.
    * If it exists, it calls the metaclass's &lt;code&gt;@link alloc alloc@/link&lt;/code&gt;
    * function and returns the result.
    */</span>
    <span class="enscript-type">static</span> OSObject * allocClassWithName(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name);


   <span class="enscript-comment">/*!
    * @function checkMetaCastWithName
    *
    * @abstract
    * Search the metaclass inheritance hierarchy by name for an object instance.
    *
    * @param className The name of the desired class or superclass. 
    * @param object    The object whose metaclass begins the search.
    *
    * @result
    * &lt;code&gt;object&lt;/code&gt; if it's derived from &lt;code&gt;className&lt;/code&gt;;
    * &lt;code&gt;NULL&lt;/code&gt; otherwise.
    *   
    * @discussion
    * This function is the basis of the Libkern run-time type-checking system.
    * Kernel extensions should not use it directly,
    * instead using &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt; or
    * &lt;code&gt;@link OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> OSMetaClassBase * checkMetaCastWithName(
        <span class="enscript-type">const</span> OSSymbol        * className,
        <span class="enscript-type">const</span> OSMetaClassBase * object);

   <span class="enscript-comment">/*!
    * @function checkMetaCastWithName
    *
    * @abstract
    * Search the metaclass inheritance hierarchy by name for an object instance.
    *
    * @param className The name of the desired class or superclass. 
    * @param object    The object whose metaclass begins the search.
    *
    * @result
    * &lt;code&gt;object&lt;/code&gt; if it's derived from &lt;code&gt;className&lt;/code&gt;;
    * &lt;code&gt;NULL&lt;/code&gt; otherwise.
    *   
    * @discussion
    * Kernel extensions should not use this function directly,
    * instead using &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt; or
    * &lt;code&gt;@link OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> OSMetaClassBase * checkMetaCastWithName(
        <span class="enscript-type">const</span> OSString        * className,
        <span class="enscript-type">const</span> OSMetaClassBase * object);

   <span class="enscript-comment">/*!
    * @function checkMetaCastWithName
    *
    * @abstract
    * Search the metaclass inheritance hierarchy by name for an object instance.
    *
    * @param className The name of the desired class or superclass. 
    * @param object    The object whose metaclass begins the search.
    *
    * @result
    * &lt;code&gt;object&lt;/code&gt; if it's derived from &lt;code&gt;className&lt;/code&gt;;
    * &lt;code&gt;NULL&lt;/code&gt; otherwise.
    *   
    * @discussion
    * Kernel extensions should not use this function directly,
    * instead using &lt;code&gt;@link OSDynamicCast OSDynamicCast@/link&lt;/code&gt; or
    * &lt;code&gt;@link OSCheckTypeInst OSCheckTypeInst@/link&lt;/code&gt;.
    */</span>
    <span class="enscript-type">static</span> OSMetaClassBase * checkMetaCastWithName(
        <span class="enscript-type">const</span> <span class="enscript-type">char</span>            * className,
        <span class="enscript-type">const</span> OSMetaClassBase * object);


   <span class="enscript-comment">/*!
    * @function instanceConstructed
    *
    * @abstract
    * Counts the instances of the class managed by this metaclass.
    *
    * @discussion
    * &lt;i&gt;Not for use by kernel extensions.&lt;/i&gt;
    *
    * Every non-abstract class that inherits from OSObject
    * has a default constructor that calls it's own metaclass's
    * &lt;code&gt;instanceConstructed&lt;/code&gt; function.
    * This constructor is defined by the
    * &lt;code&gt;@link
    * OSDefineMetaClassAndStructors
    * OSDefineMetaClassAndStructors@/link&lt;/code&gt;
    * macro that all OSObject subclasses must use.
    *
    * If a class's instance count goes from 0 to 1--that is,
    * upon the creation of the first instance of that class--the
    * superclass's instance count is also incremented.
    * This propagates reference counts up the inheritance chain so that
    * superclasses are counted as &quot;in use&quot; when subclasses have instances.
    */</span>
    <span class="enscript-type">void</span> instanceConstructed() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function instanceDestructed
    *
    * @abstract
    * Counts the instances of the class managed by this metaclass.
    *
    * @discussion
    * Every non-abstract class that inherits from OSObject
    * has a default destructor that calls it's own metaclass's
    * &lt;code&gt;instanceDestructed&lt;/code&gt; function.
    * This constructor is defined by the
    * @link OSDefineMetaClassAndStructors OSDefineMetaClassAndStructors@/link
    * macro that all OSObject subclasses must use.
    *
    * If a class's instance count goes from 1 to 0--that is,
    * upon the destruction of the last instance of that class--the
    * superclass's instance count is also decremented.
    * This reduces &quot;in use&quot; counts from superclasses when their subclasses
    * no longer have instances.
    */</span>
    <span class="enscript-type">void</span> instanceDestructed() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function checkMetaCast
    *
    * @abstract
    * Check whether a given object is an instance of the receiving
    * metaclass's class or one derived from it.
    *
    * @param object The object to check for inheritance.
    *
    * @result
    * &lt;code&gt;object&lt;/code&gt; if it is derived from the receiver's class,
    * &lt;code&gt;NULL&lt;/code&gt; if not.
    */</span>
    OSMetaClassBase * checkMetaCast(<span class="enscript-type">const</span> OSMetaClassBase * object) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function getInstanceCount
    *
    * @abstract
    * Returns the number of existing instances of the metaclass's class.
    *
    * @result
    * The number of existing instances of the metaclass's class,
    * plus 1 for each subclass with any instance.
    */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> getInstanceCount() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function getSuperClass
    *
    * @abstract
    * Returns the super-metaclass of the receiver.
    *
    * @result
    * Returns a pointer to the super-metaclass of the receiving
    * OSMetaClass, or &lt;code&gt;NULL&lt;/code&gt; for OSObject's metaclass.
    */</span>
    <span class="enscript-type">const</span> OSMetaClass * getSuperClass() <span class="enscript-type">const</span>;

   <span class="enscript-comment">/*!
    * @function getKmodName
    *
    * @abstract
    * Returns the bundle identifier of the kernel extension
    * that defines this metaclass.
    *
    * @result
    * The bundle identifier of the kernel extension that defines this metaclass.
    *
    * @discussion
    * &quot;Kmod&quot; is an older term for kernel extension.
    */</span>
    <span class="enscript-type">const</span> OSSymbol * getKmodName() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function getClassName
    *
    * @abstract
    * Returns the name of the C++ class managed by this metaclass.
    *
    * @result
    * Returns the name of the C++ class managed by this metaclass.
    */</span>
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * getClassName() <span class="enscript-type">const</span>;
    <span class="enscript-type">const</span> OSSymbol * getClassNameSymbol() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function getClassSize
    *
    * @abstract
    * Returns the allocation size of the C++ class managed by this metaclass.
    *
    * @result
    * The allocation size of the C++ class managed by this metaclass.
    */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> getClassSize() <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @function alloc
    *
    * @abstract
    * Allocates an instance of the C++ class managed by this metaclass.
    *
    * @result
    * A pointer to the newly allocated, uninitialized instance,
    * with a retain count of 1; &lt;code&gt;NULL&lt;/code&gt; on allocation failure.
    *
    * @discussion
    * This function is automatically created by the metaclass-registration macros
    * to enable dynamic instance allocation.
    */</span>
    virtual OSObject * alloc() <span class="enscript-type">const</span> = 0;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    <span class="enscript-type">void</span> addInstance(<span class="enscript-type">const</span> OSObject * instance, bool super = false) <span class="enscript-type">const</span>;	
    <span class="enscript-type">void</span> removeInstance(<span class="enscript-type">const</span> OSObject * instance, bool super = false) <span class="enscript-type">const</span>;
    <span class="enscript-type">void</span> applyToInstances(OSMetaClassInstanceApplierFunction applier, 
                          <span class="enscript-type">void</span> * context) <span class="enscript-type">const</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> applyToInstancesOfClassName(
    				<span class="enscript-type">const</span> OSSymbol * name,
    				OSMetaClassInstanceApplierFunction  applier,
                                <span class="enscript-type">void</span> * context);
<span class="enscript-reference">private</span>:
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> applyToInstances(OSOrderedSet * set,
			         OSMetaClassInstanceApplierFunction  applier,
                                 <span class="enscript-type">void</span> * context);
<span class="enscript-reference">public</span>:
#<span class="enscript-reference">endif</span>

   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDeclareCommonStructors
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className The name of the C++ class, as a raw token,
    *                  &lt;i&gt;not&lt;/i&gt; a string or macro.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDeclareCommonStructors</span>(className)                     \
    <span class="enscript-reference">private</span>:                                                    \
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> superClass;                \
    <span class="enscript-reference">public</span>:                                                     \
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> metaClass;                 \
        <span class="enscript-type">static</span> class MetaClass : public OSMetaClass {           \
        <span class="enscript-reference">public</span>:                                                 \
            MetaClass();                                        \
            virtual OSObject *alloc() <span class="enscript-type">const</span>;                    \
        } gMetaClass;                                           \
        friend class className ::MetaClass;                     \
        virtual <span class="enscript-type">const</span> OSMetaClass * getMetaClass() <span class="enscript-type">const</span> APPLE_KEXT_OVERRIDE; \
    <span class="enscript-reference">protected</span>:                                                  \
    className (<span class="enscript-type">const</span> OSMetaClass *);                            \
    virtual ~ className ()


   <span class="enscript-comment">/*!
    * @define OSDeclareDefaultStructors
    * @hidecontents
    *
    * @abstract
    * Declares run-time type information and functions
    * for a concrete Libkern C++ class.
    *
    * @param className The name of the C++ class, as a raw token,
    *                  &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @discussion
    * Concrete Libkern C++ classes should &quot;call&quot; this macro
    * immediately after the opening brace in a class declaration.
    * It leaves the current privacy state as &lt;code&gt;protected:&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDeclareDefaultStructors</span>(className)    \
    OSDeclareCommonStructors(className);        \
    <span class="enscript-reference">public</span>:                                     \
    className ();                               \
    <span class="enscript-reference">protected</span>:


   <span class="enscript-comment">/*!
    * @define OSDeclareAbstractStructors
    * @hidecontents
    *
    * @abstract
    * Declares run-time type information and functions
    * for an abstract Libkern C++ class.
    *
    * @param className The name of the C++ class, as a raw token,
    *                  &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @discussion
    * Abstract Libkern C++ classes--those with at least one
    * pure virtual method--should &quot;call&quot; this macro
    * immediately after the opening brace in a class declaration.
    * It leaves the current privacy state as &lt;code&gt;protected:&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDeclareAbstractStructors</span>(className)                          \
    OSDeclareCommonStructors(className);                               \
    <span class="enscript-reference">private</span>:                                                           \
    className (); <span class="enscript-comment">/* Make primary constructor private in abstract */</span>   \
    <span class="enscript-reference">protected</span>:

   <span class="enscript-comment">/*!
    * @define OSDeclareFinalStructors
    * @hidecontents
    *
    * @abstract
    * Declares run-time type information and functions
    * for a final (non-subclassable) Libkern C++ class.
    *
    * @param className The name of the C++ class, as a raw token,
    *                  &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @discussion
    * Final Libkern C++ classes--those that do not allow subclassing--should
    * &quot;call&quot; this macro immediately after the opening brace in a class declaration.
    * (Final classes in the kernel may actually have subclasses in the kernel,
    * but kexts cannot define any subclasses of a final class.)
    * It leaves the current privacy state as &lt;code&gt;protected:&lt;/code&gt;.
    *
    * &lt;b&gt;Note:&lt;/b&gt; If the class is exported by a pseudokext (symbol set),
    * the final symbol generated by this macro must be exported
    * for the final-class attribute to be enforced.
    *
    * &lt;b&gt;Warning:&lt;/b&gt; Changing a class from &quot;Default&quot; to &quot;Final&quot; will break
    * binary compatibility.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDeclareFinalStructors</span>(className)                              \
        OSDeclareDefaultStructors(className)                            \
    <span class="enscript-reference">private</span>:                                                            \
        <span class="enscript-type">void</span> __OSFinalClass(<span class="enscript-type">void</span>);                                      \
    <span class="enscript-reference">protected</span>:


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineMetaClassWithInit
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param init           A function to call in the constructor
    *                       of the class's OSMetaClass.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassWithInit</span>(className, superclassName, init)            \
    <span class="enscript-comment">/* Class global data */</span>                                                   \
    className ::MetaClass className ::gMetaClass;                             \
    <span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> className ::metaClass =                         \
        &amp; className ::gMetaClass;                                             \
    <span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> className ::superClass =                        \
        &amp; superclassName ::gMetaClass;                                        \
    <span class="enscript-comment">/* Class member functions */</span>                                              \
    className :: className(<span class="enscript-type">const</span> OSMetaClass *meta)                           \
        : superclassName (meta) { }                                           \
    className ::~ className() { }                                             \
    <span class="enscript-type">const</span> OSMetaClass * className ::getMetaClass() <span class="enscript-type">const</span>                      \
        { <span class="enscript-keyword">return</span> &amp;gMetaClass; }                                               \
    <span class="enscript-comment">/* The ::MetaClass constructor */</span>                                         \
    className ::MetaClass::MetaClass()                                        \
        : OSMetaClass(#className, className::superClass, <span class="enscript-keyword">sizeof</span>(className))   \
        { init; }


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineAbstractStructors
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineAbstractStructors</span>(className, superclassName)        \
    OSObject * className ::MetaClass::alloc() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> 0; }


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineDefaultStructors
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineDefaultStructors</span>(className, superclassName)     \
    OSObject * className ::MetaClass::alloc() <span class="enscript-type">const</span>             \
    { <span class="enscript-keyword">return</span> new className; }                                   \
    className :: className () : superclassName (&amp;gMetaClass)    \
    { gMetaClass.instanceConstructed(); }

   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineDefaultStructors
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineFinalStructors</span>(className, superclassName)               \
    OSDefineDefaultStructors(className, superclassName)                 \
    <span class="enscript-type">void</span> className ::__OSFinalClass(<span class="enscript-type">void</span>) { }


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineMetaClassAndStructorsWithInit
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param init           A function to call in the constructor
    *                       of the class's OSMetaClass.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassAndStructorsWithInit</span>(className, superclassName, init) \
    OSDefineMetaClassWithInit(className, superclassName, init)        \
    OSDefineDefaultStructors(className, superclassName)


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineMetaClassAndAbstractStructorsWithInit
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param init           A function to call in the constructor
    *                       of the class's OSMetaClass.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassAndAbstractStructorsWithInit</span>(className, superclassName, init) \
    OSDefineMetaClassWithInit(className, superclassName, init)        \
    OSDefineAbstractStructors(className, superclassName)


   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineMetaClassAndFinalStructorsWithInit
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param init           A function to call in the constructor
    *                       of the class's OSMetaClass.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassAndFinalStructorsWithInit</span>(className, superclassName, init) \
    OSDefineMetaClassWithInit(className, superclassName, init)                      \
    OSDefineFinalStructors(className, superclassName)


   <span class="enscript-comment">/* Helpers */</span>

   <span class="enscript-comment">/* Not to be included in headerdoc.
    *
    * @define OSDefineMetaClass
    * @hidecontents
    *
    * @abstract
    * Helper macro for for the standard metaclass-registration macros.
    * DO NOT USE.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param init           A function to call in the constructor
    *                       of the class's OSMetaClass.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClass</span>(className, superclassName)            \
    OSDefineMetaClassWithInit(className, superclassName, )


   <span class="enscript-comment">/*!
    * @define OSDefineMetaClassAndStructors
    * @hidecontents
    *
    * @abstract
    * Defines an OSMetaClass and associated routines
    * for a concrete Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @discussion
    * Concrete Libkern C++ classes should &quot;call&quot; this macro
    * at the beginning of their implementation files,
    * before any function implementations for the class.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(className, superclassName)    \
    OSDefineMetaClassAndStructorsWithInit(className, superclassName, )


   <span class="enscript-comment">/*!
    * @define OSDefineMetaClassAndAbstractStructors
    * @hidecontents
    *
    * @abstract
    * Defines an OSMetaClass and associated routines
    * for an abstract Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @discussion
    * Abstract Libkern C++ classes--those with at least one
    * pure virtual method--should &quot;call&quot; this macro
    * at the beginning of their implementation files,
    * before any function implementations for the class.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassAndAbstractStructors</span>(className, superclassName) \
    OSDefineMetaClassAndAbstractStructorsWithInit (className, superclassName, )


   <span class="enscript-comment">/*!
    * @define OSDefineMetaClassAndFinalStructors
    * @hidecontents
    *
    * @abstract
    * Defines an OSMetaClass and associated routines
    * for a final (non-subclassable) Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param superclassName The name of the superclass of the C++ class,
    *                       as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    *
    * @discussion
    * Final Libkern C++ classes--those that do not allow
    * subclassing--should &quot;call&quot; this macro at the beginning
    * of their implementation files,
    * before any function implementations for the class.
    * (Final classes in the kernel may actually have subclasses in the kernel,
    * but kexts cannot define any subclasses of a final class.)
    *
    * &lt;b&gt;Note:&lt;/b&gt; If the class is exported by a pseudokext (symbol set),
    * the final symbol generated by this macro must be exported
    * for the final-class attribute to be enforced.
    *
    * &lt;b&gt;Warning:&lt;/b&gt; Changing a class from &quot;Default&quot; to &quot;Final&quot; will break
    * binary compatibility.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDefineMetaClassAndFinalStructors</span>(className, superclassName)   \
    OSDefineMetaClassAndFinalStructorsWithInit(className, superclassName, )


    <span class="enscript-comment">// Dynamic vtable patchup support routines and types
</span>    <span class="enscript-type">void</span> reservedCalled(<span class="enscript-type">int</span> ind) <span class="enscript-type">const</span>;


   <span class="enscript-comment">/*!
    * @define OSMetaClassDeclareReservedUnused
    * @hidecontents
    *
    * @abstract
    * Reserves vtable space for new virtual functions
    * in a Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param index          The numeric index of the vtable slot,
    *                       as a raw constant, beginning from 0.
    *
    * @discussion
    * Libkern C++ classes in kernel extensions that can be used as libraries
    * can provide for backward compatibility by declaring a number
    * of reserved vtable slots
    * that can be replaced with new functions as they are added.
    * Each reserved declaration must be accompanied in the implementation
    * by a corresponding reference to
    * &lt;code&gt;@link OSMetaClassDefineReservedUnused
    *       OSMetaClassDefineReservedUnused@/link&lt;/code&gt;.
    *
    * When replacing a reserved slot, change the macro from &quot;Unused&quot;
    * to &quot;Used&quot; to document the fact that the slot used to be reserved,
    * and declare the new function immediately after the &quot;Used&quot; macro
    * to preserve vtable ordering.
    * See
    * &lt;code&gt;@link OSMetaClassDeclareReservedUsed
    *       OSMetaClassDeclareReservedUsed@/link&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_KEXT_VTABLE_PADDING</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMetaClassDeclareReservedUnused</span>(className, index)        \
    <span class="enscript-reference">private</span>:                                                      \
    virtual <span class="enscript-type">void</span> _RESERVED ## className ## index ()
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMetaClassDeclareReservedUnused</span>(className, index)
#<span class="enscript-reference">endif</span>


   <span class="enscript-comment">/*!
    * @define OSMetaClassDeclareReservedUsed
    * @hidecontents
    *
    * @abstract
    * Documents use of reserved vtable space for new virtual functions
    * in a Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param index          The numeric index of the vtable slot,
    *                       as a raw constant, beginning from 0.
    *
    * @discussion
    * This macro evaluates to nothing, and is used to document reserved
    * vtable slots as they are filled.
    * See
    * &lt;code&gt;@link OSMetaClassDeclareReservedUnused
    *       OSMetaClassDeclareReservedUnused@/link&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMetaClassDeclareReservedUsed</span>(className, index)


   <span class="enscript-comment">/*!
    * @define OSMetaClassDefineReservedUnused
    * @hidecontents
    *
    * @abstract
    * Defines a reserved vtable slot for a Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param index          The numeric index of the vtable slot,
    *                       as a raw constant, beginning from 0.
    *
    * @discussion
    * Libkern C++ classes in kernel extensions that can be used as libraries
    * can provide for backward compatibility by declaring a number
    * of reserved vtable slots
    * that can be replaced with new functions as they are added.
    * Each reserved defintion accompanies
    * a corresponding declaration created with
    * &lt;code&gt;@link OSMetaClassDeclareReservedUnused
    *       OSMetaClassDeclareReservedUnused@/link&lt;/code&gt;.
    *
    * This macro is used in the implementation file
    * to provide a placeholder definition for the reserved vtable slot,
    * as a function that calls &lt;code&gt;panic&lt;/code&gt; with an error message.
    *
    * When replacing a reserved slot, change the macro from &quot;Unused&quot;
    * to &quot;Used&quot; to document the fact that the slot used to be reserved,
    * and declare the new function immediately after the &quot;Used&quot; macro
    * to preserve vtable ordering.
    * See
    * &lt;code&gt;@link OSMetaClassDefineReservedUsed
    *       OSMetaClassDefineReservedUsed@/link&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_KEXT_VTABLE_PADDING</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(className, index)       \
<span class="enscript-type">void</span> className ::_RESERVED ## className ## index ()             \
	{ gMetaClass.reservedCalled(index); }
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(className, index)
#<span class="enscript-reference">endif</span>


   <span class="enscript-comment">/*!
    * @define OSMetaClassDefineReservedUsed
    * @hidecontents
    *
    * @abstract
    * Reserves vtable space for new virtual functions in a Libkern C++ class.
    *
    * @param className      The name of the C++ class, as a raw token,
    *                       &lt;i&gt;not&lt;/i&gt; a string or macro.
    * @param index          The numeric index of the vtable slot,
    *                       as a raw constant, beginning from 0.
    *
    * @discussion
    * This macro evaluates to nothing, and is used to document reserved
    * vtable slots as they are filled.
    * See
    * &lt;code&gt;@link OSMetaClassDefineReservedUnused
    *       OSMetaClassDefineReservedUnused@/link&lt;/code&gt;.
    */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(className, index)

    <span class="enscript-comment">// I/O Kit debug internal routines.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">void</span> printInstanceCounts();
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> serializeClassDictionary(OSDictionary * dict);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
<span class="enscript-reference">public</span>:
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> * trackedNew(size_t size);
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> trackedDelete(<span class="enscript-type">void</span> * mem, size_t size);
    <span class="enscript-type">void</span> trackedInstance(OSObject * instance) <span class="enscript-type">const</span>;
    <span class="enscript-type">void</span> trackedFree(OSObject * instance) <span class="enscript-type">const</span>;
    <span class="enscript-type">void</span> trackedAccumSize(OSObject * instance, size_t size) <span class="enscript-type">const</span>;
    <span class="enscript-type">struct</span> IOTrackingQueue * getTracking() <span class="enscript-type">const</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">private</span>:
    <span class="enscript-comment">// Obsolete APIs
</span>    <span class="enscript-type">static</span> OSDictionary * getClassDictionary();
    virtual bool serialize(OSSerialize * serializer) <span class="enscript-type">const</span>;

    <span class="enscript-comment">// Virtual Padding functions for MetaClass's
</span>    OSMetaClassDeclareReservedUnused(OSMetaClass, 0);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 1);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 2);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 3);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 4);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 5);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 6);
    OSMetaClassDeclareReservedUnused(OSMetaClass, 7);
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_LIBKERN_OSMETACLASS_H */</span>
</pre>
<hr />
</body></html>