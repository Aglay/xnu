<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSAtomic.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSAtomic.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2012 Apple Inc. All rights reserved.
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_OS_OSATOMIC_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_OS_OSATOMIC_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSBase.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__cplusplus</span>)
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * The macro SAFE_CAST_PTR() casts one type of pointer to another type, making sure
 * the data the pointer is referencing is the same size. If it is not, it will cause
 * a division by zero compiler warning. This is to work around &quot;SInt32&quot; being defined
 * as &quot;long&quot; on ILP32 and as &quot;int&quot; on LP64, which would require an explicit cast to
 * &quot;SInt32*&quot; when for instance passing an &quot;int*&quot; to OSAddAtomic() - which masks size
 * mismatches.
 * -- var is used, but sizeof does not evaluate the
 *    argument, i.e. we're safe against &quot;++&quot; etc. in var --
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__SAFE_CAST_PTR</span>(type, var) (((type)(var))+(0/(sizeof(*var) == sizeof(*(type)0) ? 1 : 0)))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__SAFE_CAST_PTR</span>(type, var) ((type)(var))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*!
 * @header
 *
 * @abstract
 * This header declares the OSAtomic group of functions for atomic
 * reading and updating of values.
 */</span>
 
<span class="enscript-comment">/*!
 * @function OSCompareAndSwap64
 *
 * @abstract
 * 64-bit compare and swap operation.
 *
 * @discussion
 * See OSCompareAndSwap.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSCompareAndSwap64</span>(
    UInt64            oldValue,
    UInt64            newValue,
    <span class="enscript-type">volatile</span> UInt64 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSCompareAndSwap64</span>(a, b, c) \
	(OSCompareAndSwap64(a, b, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt64*,c)))

<span class="enscript-comment">/*!
 * @function OSAddAtomic64
 *
 * @abstract
 * 64-bit atomic add operation.
 *
 * @discussion
 * See OSAddAtomic.
 */</span>
<span class="enscript-type">extern</span> SInt64 <span class="enscript-function-name">OSAddAtomic64</span>(
    SInt64            theAmount,
    <span class="enscript-type">volatile</span> SInt64 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSAddAtomic64</span>(a, b) \
	(OSAddAtomic64(a, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> SInt64*,b)))

<span class="enscript-comment">/*!
 * @function OSIncrementAtomic64
 *
 * @abstract
 * 64-bit increment.
 *
 * @discussion
 * See OSIncrementAtomic.
*/</span>
inline <span class="enscript-type">static</span> SInt64 <span class="enscript-function-name">OSIncrementAtomic64</span>(<span class="enscript-type">volatile</span> SInt64 * address)
{
    <span class="enscript-keyword">return</span> OSAddAtomic64(1LL, address);
}

<span class="enscript-comment">/*!
 * @function OSDecrementAtomic64
 *
 * @abstract
 * 64-bit decrement.
 *
 * @discussion
 * See OSDecrementAtomic.
*/</span>
inline <span class="enscript-type">static</span> SInt64 <span class="enscript-function-name">OSDecrementAtomic64</span>(<span class="enscript-type">volatile</span> SInt64 * address)
{
    <span class="enscript-keyword">return</span> OSAddAtomic64(-1LL, address);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-comment">/* Not to be included in headerdoc.
 *
 * @function OSAddAtomicLong
 *
 * @abstract
 * 32/64-bit atomic add operation, depending on sizeof(long).
 *
 * @discussion
 * See OSAddAtomic.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">long</span> <span class="enscript-function-name">OSAddAtomicLong</span>(
    <span class="enscript-type">long</span>            theAmount,
    <span class="enscript-type">volatile</span> <span class="enscript-type">long</span> * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSAddAtomicLong</span>(a, b) \
	(OSAddAtomicLong(a, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> <span class="enscript-type">long</span>*,b)))

<span class="enscript-comment">/* Not to be included in headerdoc.
 *
 * @function OSIncrementAtomicLong
 *
 * @abstract
 * 32/64-bit increment, depending on sizeof(long)
 *
 * @discussion
 * See OSIncrementAtomic.
*/</span>
inline <span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-function-name">OSIncrementAtomicLong</span>(<span class="enscript-type">volatile</span> <span class="enscript-type">long</span> * address)
{
    <span class="enscript-keyword">return</span> OSAddAtomicLong(1L, address);
}

<span class="enscript-comment">/* Not to be included in headerdoc.
 *
 * @function OSDecrementAtomicLong
 *
 * @abstract
 * 32/64-bit decrement, depending on sizeof(long)
 *@discussion See OSDecrementAtomic.
 */</span>
inline <span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-function-name">OSDecrementAtomicLong</span>(<span class="enscript-type">volatile</span> <span class="enscript-type">long</span> * address)
{
    <span class="enscript-keyword">return</span> OSAddAtomicLong(-1L, address);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-comment">/*!
 * @function OSCompareAndSwap8
 *
 * @abstract
 * Compare and swap operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSCompareAndSwap8 function compares the value at the specified address with oldVal. The value of newValue is written to the address only if oldValue and the value at the address are equal. OSCompareAndSwap returns true if newValue is written to the address; otherwise, it returns false.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @param oldValue The value to compare at address.
 * @param newValue The value to write to address if oldValue compares true.
 * @param address The byte aligned address of the data to update atomically.
 * @result true if newValue was written to the address.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSCompareAndSwap8</span>(
    UInt8            oldValue,
    UInt8            newValue,
    <span class="enscript-type">volatile</span> UInt8 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSCompareAndSwap8</span>(a, b, c) \
	(OSCompareAndSwap8(a, b, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt8*,c)))

<span class="enscript-comment">/*!
 * @function OSCompareAndSwap16
 *
 * @abstract
 * Compare and swap operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSCompareAndSwap16 function compares the value at the specified address with oldVal. The value of newValue is written to the address only if oldValue and the value at the address are equal. OSCompareAndSwap returns true if newValue is written to the address; otherwise, it returns false.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @param oldValue The value to compare at address.
 * @param newValue The value to write to address if oldValue compares true.
 * @param address The 2-byte aligned address of the data to update atomically.
 * @result true if newValue was written to the address.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSCompareAndSwap16</span>(
    UInt16            oldValue,
    UInt16            newValue,
    <span class="enscript-type">volatile</span> UInt16 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSCompareAndSwap16</span>(a, b, c) \
	(OSCompareAndSwap16(a, b, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt16*,c)))

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*!
 * @function OSCompareAndSwap
 *
 * @abstract
 * Compare and swap operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSCompareAndSwap function compares the value at the specified address with oldVal. The value of newValue is written to the address only if oldValue and the value at the address are equal. OSCompareAndSwap returns true if newValue is written to the address; otherwise, it returns false.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @param oldValue The value to compare at address.
 * @param newValue The value to write to address if oldValue compares true.
 * @param address The 4-byte aligned address of the data to update atomically.
 * @result true if newValue was written to the address.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSCompareAndSwap</span>(
    UInt32            oldValue,
    UInt32            newValue,
    <span class="enscript-type">volatile</span> UInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSCompareAndSwap</span>(a, b, c) \
	(OSCompareAndSwap(a, b, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt32*,c)))

<span class="enscript-comment">/*!
 * @function OSCompareAndSwapPtr
 *
 * @abstract
 * Compare and swap operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSCompareAndSwapPtr function compares the pointer-sized value at the specified address with oldVal. The value of newValue is written to the address only if oldValue and the value at the address are equal. OSCompareAndSwapPtr returns true if newValue is written to the address; otherwise, it returns false.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param oldValue The pointer value to compare at address.
 * @param newValue The pointer value to write to address if oldValue compares true.
 * @param address The pointer-size aligned address of the data to update atomically.
 * @result true if newValue was written to the address.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSCompareAndSwapPtr</span>(
    <span class="enscript-type">void</span>            * oldValue,
    <span class="enscript-type">void</span>            * newValue,
    <span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSCompareAndSwapPtr</span>(a, b, c) \
	(OSCompareAndSwapPtr(a, b, __SAFE_CAST_PTR(<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *,c)))

<span class="enscript-comment">/*!
 * @function OSAddAtomic
 *
 * @abstract
 * 32-bit add operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSAddAtomic function adds the specified amount to the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param amount The amount to add.
 * @param address The 4-byte aligned address of the value to update atomically.
 * @result The value before the addition
 */</span>
<span class="enscript-type">extern</span> SInt32 <span class="enscript-function-name">OSAddAtomic</span>(
    SInt32            amount,
    <span class="enscript-type">volatile</span> SInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSAddAtomic</span>(a, b) \
	(OSAddAtomic(a, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> SInt32*,b)))

<span class="enscript-comment">/*!
 * @function OSAddAtomic16
 *
 * @abstract
 * 16-bit add operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSAddAtomic16 function adds the specified amount to the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param address The 2-byte aligned address of the value to update atomically.
 * @result The value before the addition
 */</span>
<span class="enscript-type">extern</span> SInt16 <span class="enscript-function-name">OSAddAtomic16</span>(
    SInt32            amount,
    <span class="enscript-type">volatile</span> SInt16 * address);

<span class="enscript-comment">/*!
 * @function OSAddAtomic8
 *
 * @abstract
 * 8-bit add operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSAddAtomic8 function adds the specified amount to the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param amount The amount to add.
 * @param address The address of the value to update atomically.
 * @result The value before the addition.
 */</span>
<span class="enscript-type">extern</span> SInt8 <span class="enscript-function-name">OSAddAtomic8</span>(
    SInt32           amount,
    <span class="enscript-type">volatile</span> SInt8 * address);

<span class="enscript-comment">/*!
 * @function OSIncrementAtomic
 *
 * @abstract
 * 32-bit increment operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSIncrementAtomic function increments the value at the specified address by one and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device.
 * @param address The 4-byte aligned address of the value to update atomically.
 * @result The value before the increment.
 */</span>
<span class="enscript-type">extern</span> SInt32 <span class="enscript-function-name">OSIncrementAtomic</span>(<span class="enscript-type">volatile</span> SInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSIncrementAtomic</span>(a) \
	(OSIncrementAtomic(__SAFE_CAST_PTR(<span class="enscript-type">volatile</span> SInt32*,a)))

<span class="enscript-comment">/*!
 * @function OSIncrementAtomic16
 *
 * @abstract
 * 16-bit increment operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSIncrementAtomic16 function increments the value at the specified address by one and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param address The 2-byte aligned address of the value to update atomically.
 * @result The value before the increment.
 */</span>
<span class="enscript-type">extern</span> SInt16 <span class="enscript-function-name">OSIncrementAtomic16</span>(<span class="enscript-type">volatile</span> SInt16 * address);

<span class="enscript-comment">/*!
 * @function OSIncrementAtomic8
 *
 * @abstract
 * 8-bit increment operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSIncrementAtomic8 function increments the value at the specified address by one and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param address The address of the value to update atomically.
 * @result The value before the increment.
 */</span>
<span class="enscript-type">extern</span> SInt8 <span class="enscript-function-name">OSIncrementAtomic8</span>(<span class="enscript-type">volatile</span> SInt8 * address);

<span class="enscript-comment">/*!
 * @function OSDecrementAtomic
 *
 * @abstract
 * 32-bit decrement operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSDecrementAtomic function decrements the value at the specified address by one and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param address The 4-byte aligned address of the value to update atomically.
 * @result The value before the decrement.
 */</span>
<span class="enscript-type">extern</span> SInt32 <span class="enscript-function-name">OSDecrementAtomic</span>(<span class="enscript-type">volatile</span> SInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSDecrementAtomic</span>(a) \
	(OSDecrementAtomic(__SAFE_CAST_PTR(<span class="enscript-type">volatile</span> SInt32*,a)))

<span class="enscript-comment">/*!
 * @function OSDecrementAtomic16
 *
 * @abstract
 * 16-bit decrement operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSDecrementAtomic16 function decrements the value at the specified address by one and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param address The 2-byte aligned address of the value to update atomically.
 * @result The value before the decrement.
 */</span>
<span class="enscript-type">extern</span> SInt16 <span class="enscript-function-name">OSDecrementAtomic16</span>(<span class="enscript-type">volatile</span> SInt16 * address);

<span class="enscript-comment">/*!
 * @function OSDecrementAtomic8
 *
 * @abstract
 * 8-bit decrement operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSDecrementAtomic8 function decrements the value at the specified address by one and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers.
 * @param address The address of the value to update atomically.
 * @result The value before the decrement.
 */</span>
<span class="enscript-type">extern</span> SInt8 <span class="enscript-function-name">OSDecrementAtomic8</span>(<span class="enscript-type">volatile</span> SInt8 * address);

<span class="enscript-comment">/*!
 * @function OSBitAndAtomic
 *
 * @abstract
 * 32-bit logical and operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSBitAndAtomic function logically ands the bits of the specified mask into the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Previous incarnations of this function incorporated a memory barrier on systems with weakly-ordered memory architectures, but current versions contain no barriers..
 * @param mask The mask to logically and with the value.
 * @param address The 4-byte aligned address of the value to update atomically.
 * @result The value before the bitwise operation
 */</span>
<span class="enscript-type">extern</span> UInt32 <span class="enscript-function-name">OSBitAndAtomic</span>(
    UInt32            mask,
    <span class="enscript-type">volatile</span> UInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSBitAndAtomic</span>(a, b) \
	(OSBitAndAtomic(a, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt32*,b)))

<span class="enscript-comment">/*!
 * @function OSBitAndAtomic16
 *
 * @abstract
 * 16-bit logical and operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSBitAndAtomic16 function logically ands the bits of the specified mask into the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param mask The mask to logically and with the value.
 * @param address The 2-byte aligned address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt16 <span class="enscript-function-name">OSBitAndAtomic16</span>(
    UInt32            mask,
    <span class="enscript-type">volatile</span> UInt16 * address);

<span class="enscript-comment">/*!
 * @function OSBitAndAtomic8
 *
 * @abstract
 * 8-bit logical and operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSBitAndAtomic8 function logically ands the bits of the specified mask into the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param mask The mask to logically and with the value.
 * @param address The address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt8 <span class="enscript-function-name">OSBitAndAtomic8</span>(
    UInt32           mask,
    <span class="enscript-type">volatile</span> UInt8 * address);

<span class="enscript-comment">/*!
 * @function OSBitOrAtomic
 *
 * @abstract
 * 32-bit logical or operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSBitOrAtomic function logically ors the bits of the specified mask into the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param mask The mask to logically or with the value.
 * @param address The 4-byte aligned address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt32 <span class="enscript-function-name">OSBitOrAtomic</span>(
    UInt32            mask,
    <span class="enscript-type">volatile</span> UInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSBitOrAtomic</span>(a, b) \
	(OSBitOrAtomic(a, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt32*,b)))

<span class="enscript-comment">/*!
 * @function OSBitOrAtomic16
 *
 * @abstract
 * 16-bit logical or operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSBitOrAtomic16 function logically ors the bits of the specified mask into the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param mask The mask to logically or with the value.
 * @param address The 2-byte aligned address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt16 <span class="enscript-function-name">OSBitOrAtomic16</span>(
    UInt32            mask,
    <span class="enscript-type">volatile</span> UInt16 * address);

<span class="enscript-comment">/*!
 * @function OSBitOrAtomic8
 *
 * @abstract
 * 8-bit logical or operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @discussion
 * The OSBitOrAtomic8 function logically ors the bits of the specified mask into the value at the specified address and returns the original value.
 * @param mask The mask to logically or with the value.
 * @param address The address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt8 <span class="enscript-function-name">OSBitOrAtomic8</span>(
    UInt32           mask,
    <span class="enscript-type">volatile</span> UInt8 * address);

<span class="enscript-comment">/*!
 * @function OSBitXorAtomic
 *
 * @abstract
 * 32-bit logical xor operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @discussion
 * The OSBitXorAtomic function logically xors the bits of the specified mask into the value at the specified address and returns the original value.
 * @param mask The mask to logically or with the value.
 * @param address The 4-byte aligned address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt32 <span class="enscript-function-name">OSBitXorAtomic</span>(
    UInt32            mask,
    <span class="enscript-type">volatile</span> UInt32 * address);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSBitXorAtomic</span>(a, b) \
	(OSBitXorAtomic(a, __SAFE_CAST_PTR(<span class="enscript-type">volatile</span> UInt32*,b)))

<span class="enscript-comment">/*!
 * @function OSBitXorAtomic16
 *
 * @abstract
 * 16-bit logical xor operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSBitXorAtomic16 function logically xors the bits of the specified mask into the value at the specified address and returns the original value.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param mask The mask to logically or with the value.
 * @param address The 2-byte aligned address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt16 <span class="enscript-function-name">OSBitXorAtomic16</span>(
    UInt32            mask,
    <span class="enscript-type">volatile</span> UInt16 * address);

<span class="enscript-comment">/*!
 * @function OSBitXorAtomic8
 *
 * @abstract
 * 8-bit logical xor operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @discussion
 * The OSBitXorAtomic8 function logically xors the bits of the specified mask into the value at the specified address and returns the original value.
 * @param mask The mask to logically or with the value.
 * @param address The address of the value to update atomically.
 * @result The value before the bitwise operation.
 */</span>
<span class="enscript-type">extern</span> UInt8 <span class="enscript-function-name">OSBitXorAtomic8</span>(
    UInt32           mask,
    <span class="enscript-type">volatile</span> UInt8 * address);

<span class="enscript-comment">/*!
 * @function OSTestAndSet
 *
 * @abstract
 * Bit test and set operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 *
 * @discussion
 * The OSTestAndSet function sets a single bit in a byte at a specified address. It returns true if the bit was already set, false otherwise.
 * @param bit The bit number in the range 0 through 7. Bit 0 is the most significant.
 * @param startAddress The address of the byte to update atomically.
 * @result true if the bit was already set, false otherwise.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSTestAndSet</span>(
    UInt32           bit,
    <span class="enscript-type">volatile</span> UInt8 * startAddress);

<span class="enscript-comment">/*!
 * @function OSTestAndClear
 *
 * @abstract
 * Bit test and clear operation, performed atomically with respect to all devices that participate in the coherency architecture of the platform.
 *
 * @discussion
 * The OSTestAndClear function clears a single bit in a byte at a specified address. It returns true if the bit was already clear, false otherwise.
 *
 * This function guarantees atomicity only with main system memory. It is specifically unsuitable for use on noncacheable memory such as that in devices; this function cannot guarantee atomicity, for example, on memory mapped from a PCI device. Additionally, this function incorporates a memory barrier on systems with weakly-ordered memory architectures.
 * @param bit The bit number in the range 0 through 7. Bit 0 is the most significant.
 * @param startAddress The address of the byte to update atomically.
 * @result true if the bit was already clear, false otherwise.
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSTestAndClear</span>(
    UInt32           bit,
    <span class="enscript-type">volatile</span> UInt8 * startAddress);

<span class="enscript-comment">/*!
 * @defined OS_SPINLOCK_INIT
 *
 * @abstract
 * The default value for an OSSpinLock.
 *
 * @discussion
 * The convention is that unlocked is zero, locked is nonzero.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">OS_SPINLOCK_INIT</span> 0

<span class="enscript-comment">/*! 
 * @typedef OSSpinLock
 *
 * @abstract
 * Data type for a spinlock.
 *
 * @discussion
 * You should always initialize a spinlock to OS_SPINLOCK_INIT before using it.
 */</span>
<span class="enscript-type">typedef</span> SInt32 OSSpinLock;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
<span class="enscript-comment">/*!
 * @function OSSpinLockTry
 *
 * @abstract
 * Locks a spinlock if it would not block.
 *
 * @discussion
 * Multiprocessor locks used within the shared memory area between the kernel and event system.  These must work in both user and kernel mode.
 *
 * @result
 * Returns false if the lock was already held by another thread, true if it took the lock successfully. 
 */</span>
<span class="enscript-type">extern</span> Boolean <span class="enscript-function-name">OSSpinLockTry</span>(<span class="enscript-type">volatile</span> OSSpinLock * lock);

<span class="enscript-comment">/*!
 * @function OSSpinLockUnlock
 *
 * @abstract
 * Unlocks a spinlock.
 *
 * @discussion
 * Unlocks a spinlock.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">OSSpinLockUnlock</span>(<span class="enscript-type">volatile</span> OSSpinLock * lock);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>

<span class="enscript-comment">/*!
 * @function OSSynchronizeIO
 *
 * @abstract
 * The OSSynchronizeIO routine ensures orderly load and store operations to noncached memory mapped I/O devices.
 *
 * @discussion
 * The OSSynchronizeIO routine ensures orderly load and store operations to noncached memory mapped I/O devices. It executes the eieio instruction on PowerPC processors.
 */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">OSSynchronizeIO</span>(<span class="enscript-type">void</span>)
{
}

#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL_PRIVATE</span>)

#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>)
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">OSMemoryBarrier</span>(<span class="enscript-type">void</span>) {
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;mfence&quot;</span> ::: <span class="enscript-string">&quot;memory&quot;</span>);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__cplusplus</span>)
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! _OS_OSATOMIC_H */</span>
</pre>
<hr />
</body></html>