<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>WKdmCompress.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">WKdmCompress.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;WKdm.h&quot;</span>

<span class="enscript-comment">/***********************************************************************
 *                   THE PACKING ROUTINES
 */</span>

<span class="enscript-comment">/* WK_pack_2bits()
 * Pack some multiple of four words holding two-bit tags (in the low
 * two bits of each byte) into an integral number of words, i.e.,
 * one fourth as many.  
 * NOTE: Pad the input out with zeroes to a multiple of four words!
 */</span>
<span class="enscript-type">static</span> WK_word*
<span class="enscript-function-name">WK_pack_2bits</span>(WK_word* source_buf,
              WK_word* source_end,
	      WK_word* dest_buf) {

   <span class="enscript-type">register</span> WK_word* src_next = source_buf;
   WK_word* dest_next = dest_buf;
  
   <span class="enscript-keyword">while</span> (src_next &lt; source_end) {
      <span class="enscript-type">register</span> WK_word temp = src_next[0];
      temp |= (src_next[1] &lt;&lt; 2);
      temp |= (src_next[2] &lt;&lt; 4);
      temp |= (src_next[3] &lt;&lt; 6);
    
      dest_next[0] = temp;
      dest_next++;     
      src_next += 4;
   }
  
   <span class="enscript-keyword">return</span> dest_next;

}

<span class="enscript-comment">/* WK_pack_4bits()
 * Pack an even number of words holding 4-bit patterns in the low bits
 * of each byte into half as many words.
 * note: pad out the input with zeroes to an even number of words!
 */</span>

<span class="enscript-type">static</span> WK_word*
<span class="enscript-function-name">WK_pack_4bits</span>(WK_word* source_buf,
	      WK_word* source_end,
	      WK_word* dest_buf) {
   <span class="enscript-type">register</span> WK_word* src_next = source_buf;
   WK_word* dest_next = dest_buf;
  
   <span class="enscript-comment">/* this loop should probably be unrolled */</span>
   <span class="enscript-keyword">while</span> (src_next &lt; source_end) {
     <span class="enscript-type">register</span> WK_word temp = src_next[0];
     temp |= (src_next[1] &lt;&lt; 4);
    
     dest_next[0] = temp;
     dest_next++;     
     src_next += 2;
   }

   <span class="enscript-keyword">return</span> dest_next;

}

<span class="enscript-comment">/* pack_3_tenbits()
 * Pack a sequence of three ten bit items into one word.
 * note: pad out the input with zeroes to an even number of words!
 */</span>
<span class="enscript-type">static</span> WK_word*
<span class="enscript-function-name">WK_pack_3_tenbits</span>(WK_word* source_buf,
		  WK_word* source_end,
		  WK_word* dest_buf) {

   <span class="enscript-type">register</span> WK_word* src_next = source_buf;
   WK_word* dest_next = dest_buf;
  
   <span class="enscript-comment">/* this loop should probably be unrolled */</span>
   <span class="enscript-keyword">while</span> (src_next &lt; source_end) {
      <span class="enscript-type">register</span> WK_word temp = src_next[0];
      temp |= (src_next[1] &lt;&lt; 10);
      temp |= (src_next[2] &lt;&lt; 20);
    
      dest_next[0] = temp;
      dest_next++;     
      src_next += 3;
   }

   <span class="enscript-keyword">return</span> dest_next;

}

<span class="enscript-comment">/***************************************************************************
 *  WKdm_compress()---THE COMPRESSOR
 */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">WKdm_compress</span> (WK_word* src_buf,
               WK_word* dest_buf,
	       <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_input_words)
{
  DictionaryElement dictionary[DICTIONARY_SIZE];

  <span class="enscript-comment">/* arrays that hold output data in intermediate form during modeling */</span>
  <span class="enscript-comment">/* and whose contents are packed into the actual output after modeling */</span>

  <span class="enscript-comment">/* sizes of these arrays should be increased if you want to compress
   * pages larger than 4KB
   */</span>
  WK_word tempTagsArray[300];         <span class="enscript-comment">/* tags for everything          */</span>
  WK_word tempQPosArray[300];         <span class="enscript-comment">/* queue positions for matches  */</span>
  WK_word tempLowBitsArray[1200];     <span class="enscript-comment">/* low bits for partial matches */</span>

  <span class="enscript-comment">/* boundary_tmp will be used for keeping track of what's where in
   * the compressed page during packing
   */</span>
  WK_word* boundary_tmp;

  <span class="enscript-comment">/* Fill pointers for filling intermediate arrays (of queue positions
   * and low bits) during encoding.
   * Full words go straight to the destination buffer area reserved
   * for them.  (Right after where the tags go.)
   */</span>
  WK_word* next_full_patt;
  <span class="enscript-type">char</span>* next_tag = (<span class="enscript-type">char</span> *) tempTagsArray;
  <span class="enscript-type">char</span>* next_qp = (<span class="enscript-type">char</span> *) tempQPosArray;
  WK_word* next_low_bits = tempLowBitsArray;

  WK_word* next_input_word = src_buf;
  WK_word* end_of_input = src_buf + num_input_words;

  PRELOAD_DICTIONARY;

  next_full_patt = dest_buf + TAGS_AREA_OFFSET + (num_input_words / 16);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  printf(<span class="enscript-string">&quot;\nIn WKdm_compress\n&quot;</span>);
  printf(<span class="enscript-string">&quot;About to actually compress, src_buf is %u\n&quot;</span>, src_buf);
  printf(<span class="enscript-string">&quot;dictionary is at %u\n&quot;</span>, dictionary);
  printf(<span class="enscript-string">&quot;dest_buf is %u next_full_patt is %u\n&quot;</span>, dest_buf, next_full_patt);
  fflush(stdout);
#<span class="enscript-reference">endif</span>

  <span class="enscript-keyword">while</span> (next_input_word &lt; end_of_input)
  {
     WK_word *dict_location;
     WK_word dict_word;
     WK_word input_word = *next_input_word;

     <span class="enscript-comment">/* compute hash value, which is a byte offset into the dictionary,
      * and add it to the base address of the dictionary. Cast back and
      * forth to/from char * so no shifts are needed
      */</span>
     dict_location =
       (WK_word *)
       ((<span class="enscript-type">void</span>*) (((<span class="enscript-type">char</span>*) dictionary) + HASH_TO_DICT_BYTE_OFFSET(input_word)));

     dict_word = *dict_location;

     <span class="enscript-keyword">if</span> (input_word == dict_word)
     {
        RECORD_EXACT(dict_location - dictionary); 
     }
     <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (input_word == 0) {
        RECORD_ZERO;
     }
     <span class="enscript-keyword">else</span>
     {
        WK_word input_high_bits = HIGH_BITS(input_word);
        <span class="enscript-keyword">if</span> (input_high_bits == HIGH_BITS(dict_word)) {
	  RECORD_PARTIAL(dict_location - dictionary, LOW_BITS(input_word));
          *dict_location = input_word;
        }
        <span class="enscript-keyword">else</span> {
	  RECORD_MISS(input_word);
            *dict_location = input_word;
        }
     }
     next_input_word++;
  }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  printf(<span class="enscript-string">&quot;AFTER MODELING in WKdm_compress()\n&quot;</span>);  fflush(stdout);
  printf(<span class="enscript-string">&quot;tempTagsArray holds %u bytes\n&quot;</span>,
         next_tag - (<span class="enscript-type">char</span> *) tempTagsArray);
  printf(<span class="enscript-string">&quot;tempQPosArray holds %u bytes\n&quot;</span>,
         next_qp - (<span class="enscript-type">char</span> *) tempQPosArray);
  printf(<span class="enscript-string">&quot;tempLowBitsArray holds %u bytes\n&quot;</span>,
         (<span class="enscript-type">char</span> *) next_low_bits - (<span class="enscript-type">char</span> *) tempLowBitsArray);

  printf(<span class="enscript-string">&quot;next_full_patt is %p\n&quot;</span>,
          next_full_patt);

  printf(<span class="enscript-string">&quot; i.e., there are %u full patterns\n&quot;</span>,
     next_full_patt - (dest_buf + TAGS_AREA_OFFSET + (num_input_words / 16)));
  fflush(stdout);

  { <span class="enscript-type">int</span> i;
    WK_word *arr =(dest_buf + TAGS_AREA_OFFSET + (num_input_words / 16));

    printf(<span class="enscript-string">&quot;  first 20 full patterns are: \n&quot;</span>);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 20; i++) {
      printf(<span class="enscript-string">&quot; %d&quot;</span>, arr[i]);
    }
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
  }
#<span class="enscript-reference">endif</span>

  <span class="enscript-comment">/* Record (into the header) where we stopped writing full words,
   * which is where we will pack the queue positions.  (Recall
   * that we wrote the full words directly into the dest buffer
   * during modeling.
   */</span>

  SET_QPOS_AREA_START(dest_buf,next_full_patt);

  <span class="enscript-comment">/* Pack the tags into the tags area, between the page header
   * and the full words area.  We don't pad for the packer
   * because we assume that the page size is a multiple of 16.
   */</span>     

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  printf(<span class="enscript-string">&quot;about to pack %u bytes holding tags\n&quot;</span>, 
         next_tag - (<span class="enscript-type">char</span> *) tempTagsArray);

  { <span class="enscript-type">int</span> i;
    <span class="enscript-type">char</span>* arr = (<span class="enscript-type">char</span> *) tempTagsArray;

    printf(<span class="enscript-string">&quot;  first 200 tags are: \n&quot;</span>);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 200; i++) {
      printf(<span class="enscript-string">&quot; %d&quot;</span>, arr[i]);
    }
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
  }
#<span class="enscript-reference">endif</span>

  boundary_tmp = WK_pack_2bits(tempTagsArray,
		               (WK_word *) ((<span class="enscript-type">void</span> *) next_tag),
			       dest_buf + HEADER_SIZE_IN_WORDS);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>  
    printf(<span class="enscript-string">&quot;packing tags stopped at %u\n&quot;</span>, boundary_tmp);
#<span class="enscript-reference">endif</span>
  
  <span class="enscript-comment">/* Pack the queue positions into the area just after
   * the full words.  We have to round up the source
   * region to a multiple of two words.
   */</span>

  {
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_bytes_to_pack = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(next_qp - (<span class="enscript-type">char</span> *) tempQPosArray);
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_packed_words = (num_bytes_to_pack + 7) &gt;&gt; 3; <span class="enscript-comment">// ceil((double) num_bytes_to_pack / 8);
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_source_words = num_packed_words * 2;
    WK_word* endQPosArray = tempQPosArray + num_source_words;

    <span class="enscript-comment">/* Pad out the array with zeros to avoid corrupting real packed
       values. */</span>
    <span class="enscript-keyword">for</span> (; <span class="enscript-comment">/* next_qp is already set as desired */</span>
	 next_qp &lt; (<span class="enscript-type">char</span>*)endQPosArray;
	 next_qp++) {
      *next_qp = 0;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>    
    printf(<span class="enscript-string">&quot;about to pack %u (bytes holding) queue posns.\n&quot;</span>,
           num_bytes_to_pack);
    printf(<span class="enscript-string">&quot;packing them from %u words into %u words\n&quot;</span>,
           num_source_words, num_packed_words);
    printf(<span class="enscript-string">&quot;dest is range %u to %u\n&quot;</span>,
           next_full_patt, next_full_patt + num_packed_words);
    { <span class="enscript-type">int</span> i;
      <span class="enscript-type">char</span> *arr = (<span class="enscript-type">char</span> *) tempQPosArray;
      printf(<span class="enscript-string">&quot;  first 200 queue positions are: \n&quot;</span>);
      <span class="enscript-keyword">for</span> (i = 0; i &lt; 200; i++) {
        printf(<span class="enscript-string">&quot; %d&quot;</span>, arr[i]);
      }
      printf(<span class="enscript-string">&quot;\n&quot;</span>);
    }
#<span class="enscript-reference">endif</span>
    
    boundary_tmp = WK_pack_4bits(tempQPosArray,
			         endQPosArray,
				 next_full_patt);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
     printf(<span class="enscript-string">&quot;Packing of queue positions stopped at %u\n&quot;</span>, boundary_tmp);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">WK_DEBUG</span>

    <span class="enscript-comment">/* Record (into the header) where we stopped packing queue positions,
     * which is where we will start packing low bits.
     */</span>
    SET_LOW_BITS_AREA_START(dest_buf,boundary_tmp);

  }

  <span class="enscript-comment">/* Pack the low bit patterns into the area just after
   * the queue positions.  We have to round up the source
   * region to a multiple of three words.
   */</span>

  {
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_tenbits_to_pack =
      (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(next_low_bits - tempLowBitsArray);
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_packed_words = (num_tenbits_to_pack + 2) / 3; <span class="enscript-comment">//ceil((double) num_tenbits_to_pack / 3);
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_source_words = num_packed_words * 3;
    WK_word* endLowBitsArray = tempLowBitsArray + num_source_words;

    <span class="enscript-comment">/* Pad out the array with zeros to avoid corrupting real packed
       values. */</span>

    <span class="enscript-keyword">for</span> (; <span class="enscript-comment">/* next_low_bits is already set as desired */</span>
	 next_low_bits &lt; endLowBitsArray;
	 next_low_bits++) {
      *next_low_bits = 0;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
	  printf(<span class="enscript-string">&quot;about to pack low bits\n&quot;</span>);
          printf(<span class="enscript-string">&quot;num_tenbits_to_pack is %u\n&quot;</span>, num_tenbits_to_pack);
          printf(<span class="enscript-string">&quot;endLowBitsArray is %u\n&quot;</span>, endLowBitsArray);
#<span class="enscript-reference">endif</span>
    
    boundary_tmp = WK_pack_3_tenbits (tempLowBitsArray,
		                      endLowBitsArray,
				      boundary_tmp);

    SET_LOW_BITS_AREA_END(dest_buf,boundary_tmp);

  }

  <span class="enscript-keyword">return</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)((<span class="enscript-type">char</span> *) boundary_tmp - (<span class="enscript-type">char</span> *) dest_buf);
} 
</pre>
<hr />
</body></html>