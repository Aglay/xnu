<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kxld_seg.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kxld_seg.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    #include &lt;mach/vm_param.h&gt;
#<span class="enscript-reference">else</span>
    #include &lt;mach/mach_init.h&gt;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_ASSERT_COMPONENT_NAME_STRING</span> <span class="enscript-string">&quot;kxld&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;AssertMacros.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_reloc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_sect.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_seg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_symtab.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_util.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SEGS</span> 20

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEXT_SEG_PROT</span> (VM_PROT_READ | VM_PROT_EXECUTE)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DATA_SEG_PROT</span> (VM_PROT_READ | VM_PROT_WRITE)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">reorder_sections</span>(KXLDSeg *seg, KXLDArray *section_order);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">reorder_section</span>(KXLDArray *sects, u_int *sect_reorder_index, 
    KXLDSect **reorder_buffer, u_int reorder_buffer_index);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> KXLDSeg * <span class="enscript-function-name">get_segment_by_name</span>(KXLDArray *segarray, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">seg_export_macho_header_32</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_char *buf,
    u_long *header_offset, u_long header_size, u_long data_offset);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">seg_export_macho_header_64</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_char *buf,
    u_long *header_offset, u_long header_size, u_long data_offset);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> KXLDSect * <span class="enscript-function-name">get_sect_by_index</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_int idx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_init_from_macho_32</span>(KXLDSeg *seg, <span class="enscript-type">struct</span> segment_command *src)
{
    kern_return_t rval = KERN_FAILURE;
    check(seg);
    check(src);

    strlcpy(seg-&gt;segname, src-&gt;segname, <span class="enscript-keyword">sizeof</span>(seg-&gt;segname));
    seg-&gt;base_addr = src-&gt;vmaddr;
    seg-&gt;link_addr = src-&gt;vmaddr;
    seg-&gt;vmsize = src-&gt;vmsize;
    seg-&gt;fileoff = src-&gt;fileoff;
    seg-&gt;maxprot = src-&gt;maxprot;
    seg-&gt;initprot = src-&gt;initprot;
    seg-&gt;flags = src-&gt;flags;

    rval = kxld_array_init(&amp;seg-&gt;sects, <span class="enscript-keyword">sizeof</span>(KXLDSect *), src-&gt;nsects);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_init_from_macho_64</span>(KXLDSeg *seg, <span class="enscript-type">struct</span> segment_command_64 *src)
{
    kern_return_t rval = KERN_FAILURE;
    check(seg);
    check(src);

    strlcpy(seg-&gt;segname, src-&gt;segname, <span class="enscript-keyword">sizeof</span>(seg-&gt;segname));
    seg-&gt;base_addr = src-&gt;vmaddr;
    seg-&gt;link_addr = src-&gt;vmaddr;
    seg-&gt;vmsize = src-&gt;vmsize;
    seg-&gt;fileoff = src-&gt;fileoff;
    seg-&gt;maxprot = src-&gt;maxprot;
    seg-&gt;initprot = src-&gt;initprot;
    seg-&gt;flags = src-&gt;flags;

    rval = kxld_array_init(&amp;seg-&gt;sects, <span class="enscript-keyword">sizeof</span>(KXLDSect *), src-&gt;nsects);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_create_seg_from_sections</span>(KXLDArray *segarray, KXLDArray *sectarray)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSeg *seg = NULL;
    KXLDSect *sect = NULL;
    KXLDSect **sectp = NULL;
    u_int i = 0;

    <span class="enscript-comment">/* Initialize the segment array to one segment */</span>

    rval = kxld_array_init(segarray, <span class="enscript-keyword">sizeof</span>(KXLDSeg), 1);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Initialize the segment */</span>

    seg = kxld_array_get_item(segarray, 0);
    seg-&gt;initprot = VM_PROT_ALL;
    seg-&gt;maxprot = VM_PROT_ALL;
    seg-&gt;link_addr = 0;

    <span class="enscript-comment">/* Add the sections to the segment */</span>

    rval = kxld_array_init(&amp;seg-&gt;sects, <span class="enscript-keyword">sizeof</span>(KXLDSect *), sectarray-&gt;nitems);
    require_noerr(rval, finish);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; sectarray-&gt;nitems; ++i) {
        sect = kxld_array_get_item(sectarray, i);
        sectp = kxld_array_get_item(&amp;seg-&gt;sects, i);

        *sectp = sect;
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_finalize_object_segment</span>(KXLDArray *segarray, KXLDArray *section_order,
    u_long hdrsize)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSeg *seg = NULL;
    KXLDSect *sect = NULL;
    u_long sect_offset = 0;
    u_int i = 0;

    check(segarray);
    check(section_order);
    require_action(segarray-&gt;nitems == 1, finish, rval=KERN_FAILURE);

    seg = kxld_array_get_item(segarray, 0);
    
    <span class="enscript-comment">/* Reorder the sections */</span>
    
    rval = reorder_sections(seg, section_order);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Set the initial link address at the end of the header pages */</span>

    seg-&gt;link_addr = kxld_round_page_cross_safe(hdrsize);

    <span class="enscript-comment">/* Fix up all of the section addresses */</span>

    sect_offset = (u_long) seg-&gt;link_addr;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
        sect = *(KXLDSect **)kxld_array_get_item(&amp;seg-&gt;sects, i);

        sect-&gt;link_addr = kxld_sect_align_address(sect, sect_offset);
        sect_offset = (u_long) (sect-&gt;link_addr + sect-&gt;size);
    }

    <span class="enscript-comment">/* Finish initializing the segment */</span>

    seg-&gt;vmsize = kxld_round_page_cross_safe(sect_offset) - seg-&gt;link_addr;

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
* The legacy section ordering used by kld was based of the order of sections
* in the kernel file.  To achieve the same layout, we save the kernel's
* section ordering as an array of section names when the kernel file itself
* is linked.  Then, when kexts are linked with the KXLD_LEGACY_LAYOUT flag,
* we refer to the kernel's section layout to order the kext's sections.
*
* The algorithm below is as follows.  We iterate through all of the kernel's
* sections grouped by segment name, so that we are processing all of the __TEXT
* sections, then all of the __DATA sections, etc.  We then iterate through the
* kext's sections with a similar grouping, looking for sections that match
* the current kernel's section.  In this way, we order all of the matching
* kext sections in the order in which they appear in the kernel, and then place
* all remaining kext sections at the end of the current segment grouping in
* the order in which they originally appeared.  Sections that only appear in
* the kernel are not created.  segments that only appear in the kext are
* left in their original ordering.
*
* An example:
*
* Kernel sections:
* __TEXT,__text
* __TEXT,__const
* __DATA,__data
*
* Kext sections:
* __TEXT,__const
* __TEXT,__literal4
* __TEXT,__text
* __DATA,__const
* __DATA,__data
*
* Reordered kext sections:
* __TEXT,__text
* __TEXT,__const
* __TEXT,__literal4
* __DATA,__data
* __DATA,__const
*
* In the implementation below, we use a reorder buffer to hold pointers to the
* sections of the current working segment.  We scan this buffer looking for
* matching sections, placing them in the segment's section index as we find them.
* If this function must exit early, the segment's section index is left in an
* unusable state.
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">reorder_sections</span>(KXLDSeg *seg, KXLDArray *section_order)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    KXLDSect **reorder_buffer = NULL;
    KXLDSectionName *section_name = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname = NULL;
    u_int sect_index = 0, legacy_index = 0, sect_reorder_index = 0;
    u_int i = 0, j = 0;
    u_int sect_start = 0, sect_end = 0, legacy_start = 0, legacy_end = 0;
    u_int nsects = 0;

    check(seg);
    check(section_order);

    <span class="enscript-comment">/* Allocate the reorder buffer with enough space to hold all of the 
     * sections.
     */</span>

    reorder_buffer = kxld_alloc(
        seg-&gt;sects.nitems * <span class="enscript-keyword">sizeof</span>(*reorder_buffer));
    require_action(reorder_buffer, finish, rval=KERN_RESOURCE_SHORTAGE);

    <span class="enscript-keyword">while</span> (legacy_index &lt; section_order-&gt;nitems) {

        <span class="enscript-comment">/* Find the next group of sections with a common segment in the
         * section_order array.
         */</span>

        legacy_start = legacy_index++;
        legacy_end = legacy_index;

        section_name = kxld_array_get_item(section_order, legacy_start);
        segname = section_name-&gt;segname;
        <span class="enscript-keyword">while</span> (legacy_index &lt; section_order-&gt;nitems) {
            section_name = kxld_array_get_item(section_order, legacy_index);
            <span class="enscript-keyword">if</span> (!streq_safe(segname, section_name-&gt;segname, 
                    <span class="enscript-keyword">sizeof</span>(section_name-&gt;segname))) 
            {
                <span class="enscript-keyword">break</span>;
            }

            ++legacy_index;
            ++legacy_end;
        }

        <span class="enscript-comment">/* Find a group of sections in the kext that match the current
         * section_order segment.
         */</span>

        sect_start = sect_index;
        sect_end = sect_index;

        <span class="enscript-keyword">while</span> (sect_index &lt; seg-&gt;sects.nitems) {
            sect = *(KXLDSect **) kxld_array_get_item(&amp;seg-&gt;sects, sect_index);
            <span class="enscript-keyword">if</span> (!streq_safe(segname, sect-&gt;segname, <span class="enscript-keyword">sizeof</span>(sect-&gt;segname))) {
                <span class="enscript-keyword">break</span>;
            }

            ++sect_index;
            ++sect_end;
        }
        nsects = sect_end - sect_start;
        
        <span class="enscript-keyword">if</span> (!nsects) <span class="enscript-keyword">continue</span>;

        <span class="enscript-comment">/* Populate the reorder buffer with the current group of kext sections */</span>

        <span class="enscript-keyword">for</span> (i = sect_start; i &lt; sect_end; ++i) {
            reorder_buffer[i - sect_start] = 
                *(KXLDSect **) kxld_array_get_item(&amp;seg-&gt;sects, i);
        }

        <span class="enscript-comment">/* For each section_order section, scan the reorder buffer for a matching
         * kext section.  If one is found, copy it into the next slot in the
         * segment's section index.
         */</span>

        sect_reorder_index = sect_start;
        <span class="enscript-keyword">for</span> (i = legacy_start; i &lt; legacy_end; ++i) {
            section_name = kxld_array_get_item(section_order, i);
            sect = NULL;

            <span class="enscript-keyword">for</span> (j = 0; j &lt; nsects; ++j) {
                sect = reorder_buffer[j];
                <span class="enscript-keyword">if</span> (!sect) <span class="enscript-keyword">continue</span>;

                <span class="enscript-keyword">if</span> (streq_safe(section_name-&gt;sectname, sect-&gt;sectname, 
                        <span class="enscript-keyword">sizeof</span>(section_name-&gt;sectname))) 
                {
                    <span class="enscript-keyword">break</span>;
                }

                sect = NULL;
            }

            <span class="enscript-keyword">if</span> (sect) { 
                (<span class="enscript-type">void</span>) reorder_section(&amp;seg-&gt;sects, &amp;sect_reorder_index, 
                    reorder_buffer, j);
            }
        }

        <span class="enscript-comment">/* If any sections remain in the reorder buffer, they are not specified
         * in the section_order array, so append them to the section index in
         * in the order they are found.
         */</span>

        <span class="enscript-keyword">for</span> (i = 0; i &lt; nsects; ++i) {
            <span class="enscript-keyword">if</span> (!reorder_buffer[i]) <span class="enscript-keyword">continue</span>;
            reorder_section(&amp;seg-&gt;sects, &amp;sect_reorder_index, reorder_buffer, i);
        }
    }

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:

    <span class="enscript-keyword">if</span> (reorder_buffer) {
        kxld_free(reorder_buffer, seg-&gt;sects.nitems * <span class="enscript-keyword">sizeof</span>(*reorder_buffer));
        reorder_buffer = NULL;
    }

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">reorder_section</span>(KXLDArray *sects, u_int *sect_reorder_index, 
    KXLDSect **reorder_buffer, u_int reorder_buffer_index)
{
    KXLDSect **tmp = NULL;

    tmp = kxld_array_get_item(sects, *sect_reorder_index);

    *tmp = reorder_buffer[reorder_buffer_index];
    reorder_buffer[reorder_buffer_index]-&gt;sectnum = *sect_reorder_index;
    reorder_buffer[reorder_buffer_index] = NULL;

    ++(*sect_reorder_index);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_init_linkedit</span>(KXLDArray *segs)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSeg *seg = NULL;
    KXLDSeg *le = NULL;
    
    rval = kxld_array_resize(segs, 2);
    require_noerr(rval, finish);

    seg = kxld_array_get_item(segs, 0);
    le = kxld_array_get_item(segs, 1);

    strlcpy(le-&gt;segname, SEG_LINKEDIT, <span class="enscript-keyword">sizeof</span>(le-&gt;segname));
    le-&gt;link_addr = kxld_round_page_cross_safe(seg-&gt;link_addr + seg-&gt;vmsize);
    le-&gt;maxprot = VM_PROT_ALL;
    le-&gt;initprot = VM_PROT_DEFAULT;

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_seg_clear</span>(KXLDSeg *seg)
{
    check(seg);

    bzero(seg-&gt;segname, <span class="enscript-keyword">sizeof</span>(seg-&gt;segname));
    seg-&gt;base_addr = 0;
    seg-&gt;link_addr = 0;
    seg-&gt;vmsize = 0;
    seg-&gt;flags = 0;
    seg-&gt;maxprot = 0;
    seg-&gt;initprot = 0;

    <span class="enscript-comment">/* Don't clear the individual sections here because kxld_kext.c will take
     * care of that.
     */</span>
    kxld_array_clear(&amp;seg-&gt;sects);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_seg_deinit</span>(KXLDSeg *seg)
{
    check(seg);

    kxld_array_deinit(&amp;seg-&gt;sects);
    bzero(seg, <span class="enscript-keyword">sizeof</span>(*seg));
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kxld_size_t 
<span class="enscript-function-name">kxld_seg_get_vmsize</span>(<span class="enscript-type">const</span> KXLDSeg *seg)
{
    check(seg);

    <span class="enscript-keyword">return</span> seg-&gt;vmsize;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
u_long
<span class="enscript-function-name">kxld_seg_get_macho_header_size</span>(<span class="enscript-type">const</span> KXLDSeg *seg, boolean_t is_32_bit)
{
    u_long size = 0;
    
    check(seg);

    <span class="enscript-keyword">if</span> (is_32_bit) {
        size += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> segment_command);
    } <span class="enscript-keyword">else</span> {
        size += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> segment_command_64);
    }
    size += seg-&gt;sects.nitems * kxld_sect_get_macho_header_size(is_32_bit);

    <span class="enscript-keyword">return</span> size;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-comment">/* This is no longer used, but may be useful some day... */</span>
#<span class="enscript-reference">if</span> 0
u_long
<span class="enscript-function-name">kxld_seg_get_macho_data_size</span>(<span class="enscript-type">const</span> KXLDSeg *seg)
{
    u_long size = 0;
    u_int i = 0;
    KXLDSect *sect = NULL;

    check(seg);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
        sect = get_sect_by_index(seg, i);
        size = (u_long) kxld_sect_align_address(sect, size);
        size += kxld_sect_get_macho_data_size(sect);
    }

    <span class="enscript-keyword">return</span> kxld_round_page_cross_safe(size);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> KXLDSect * 
<span class="enscript-function-name">get_sect_by_index</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_int idx)
{
    check(seg);

    <span class="enscript-keyword">return</span> *(KXLDSect **) kxld_array_get_item(&amp;seg-&gt;sects, idx);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_export_macho_to_file_buffer</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_char *buf,
    u_long *header_offset, u_long header_size, 
    u_long *data_offset, u_long data_size,
    boolean_t is_32_bit)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    u_long base_data_offset = *data_offset;
    u_int i = 0;
    <span class="enscript-type">struct</span> segment_command *hdr32 = 
        (<span class="enscript-type">struct</span> segment_command *) ((<span class="enscript-type">void</span> *) (buf + *header_offset));
    <span class="enscript-type">struct</span> segment_command_64 *hdr64 = 
        (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) (buf + *header_offset));

    check(seg);
    check(buf);
    check(header_offset);
    check(data_offset);

    <span class="enscript-comment">/* Write out the header */</span>

    KXLD_3264_FUNC(is_32_bit, rval,
        seg_export_macho_header_32, seg_export_macho_header_64,
        seg, buf, header_offset, header_size, *data_offset);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Write out each section */</span>

    <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
        sect = get_sect_by_index(seg, i);

        rval = kxld_sect_export_macho_to_file_buffer(sect, buf, header_offset, 
            header_size, data_offset, data_size, is_32_bit);
        require_noerr(rval, finish);
    }

    <span class="enscript-comment">/* Update the filesize */</span>

    <span class="enscript-keyword">if</span> (is_32_bit) {
        hdr32-&gt;filesize = (uint32_t) (*data_offset - base_data_offset);
    } <span class="enscript-keyword">else</span> {
        hdr64-&gt;filesize = (uint64_t) (*data_offset - base_data_offset);
    }

    *data_offset = (u_long)kxld_round_page_cross_safe(*data_offset);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;

}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_export_macho_to_vm</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_char *buf,
    u_long *header_offset, u_long header_size, 
    u_long data_size, kxld_addr_t file_link_addr, 
    boolean_t is_32_bit)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    u_long data_offset = (u_long) (seg-&gt;link_addr - file_link_addr);
    u_int i = 0;

    check(seg);
    check(buf);
    check(header_offset);

    <span class="enscript-comment">/* Write out the header */</span>

    KXLD_3264_FUNC(is_32_bit, rval,
        seg_export_macho_header_32, seg_export_macho_header_64,
        seg, buf, header_offset, header_size, data_offset);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Write out each section */</span>

    <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
        sect = get_sect_by_index(seg, i);

        rval = kxld_sect_export_macho_to_vm(sect, buf, header_offset, 
            header_size, file_link_addr, data_size, is_32_bit);
        require_noerr(rval, finish);
    }

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">seg_export_macho_header_32</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_char *buf,
    u_long *header_offset, u_long header_size, u_long data_offset)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> segment_command *seghdr = NULL;

    check(seg);
    check(buf);
    check(header_offset);

    require_action(<span class="enscript-keyword">sizeof</span>(*seghdr) &lt;= header_size - *header_offset, finish,
        rval=KERN_FAILURE);
    seghdr = (<span class="enscript-type">struct</span> segment_command *) ((<span class="enscript-type">void</span> *) (buf + *header_offset));
    *header_offset += <span class="enscript-keyword">sizeof</span>(*seghdr);

    seghdr-&gt;cmd = LC_SEGMENT;
    seghdr-&gt;cmdsize = (uint32_t) <span class="enscript-keyword">sizeof</span>(*seghdr);
    seghdr-&gt;cmdsize += 
        (uint32_t) (seg-&gt;sects.nitems * kxld_sect_get_macho_header_size(TRUE));
    strlcpy(seghdr-&gt;segname, seg-&gt;segname, <span class="enscript-keyword">sizeof</span>(seghdr-&gt;segname));
    seghdr-&gt;vmaddr = (uint32_t) seg-&gt;link_addr;
    seghdr-&gt;vmsize = (uint32_t) seg-&gt;vmsize;
    seghdr-&gt;fileoff = (uint32_t) data_offset;
    seghdr-&gt;filesize = (uint32_t) seg-&gt;vmsize;
    seghdr-&gt;maxprot = seg-&gt;maxprot;
    seghdr-&gt;initprot = seg-&gt;initprot;
    seghdr-&gt;nsects = seg-&gt;sects.nitems;
    seghdr-&gt;flags = 0;

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span> 
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">seg_export_macho_header_64</span>(<span class="enscript-type">const</span> KXLDSeg *seg, u_char *buf,
    u_long *header_offset, u_long header_size, u_long data_offset)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> segment_command_64 *seghdr = NULL;

    check(seg);
    check(buf);
    check(header_offset);

    require_action(<span class="enscript-keyword">sizeof</span>(*seghdr) &lt;= header_size - *header_offset, finish,
        rval=KERN_FAILURE);
    seghdr = (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) (buf + *header_offset));
    *header_offset += <span class="enscript-keyword">sizeof</span>(*seghdr);

    seghdr-&gt;cmd = LC_SEGMENT_64;
    seghdr-&gt;cmdsize = (uint32_t) <span class="enscript-keyword">sizeof</span>(*seghdr);
    seghdr-&gt;cmdsize += 
        (uint32_t) (seg-&gt;sects.nitems * kxld_sect_get_macho_header_size(FALSE));
    strlcpy(seghdr-&gt;segname, seg-&gt;segname, <span class="enscript-keyword">sizeof</span>(seghdr-&gt;segname));
    seghdr-&gt;vmaddr = (uint64_t) seg-&gt;link_addr;
    seghdr-&gt;vmsize = (uint64_t) seg-&gt;vmsize;
    seghdr-&gt;fileoff = (uint64_t) data_offset;
    seghdr-&gt;filesize = (uint64_t) seg-&gt;vmsize;
    seghdr-&gt;maxprot = seg-&gt;maxprot;
    seghdr-&gt;initprot = seg-&gt;initprot;
    seghdr-&gt;nsects = seg-&gt;sects.nitems;
    seghdr-&gt;flags = 0;

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_add_section</span>(KXLDSeg *seg, KXLDSect *sect)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect **sectp = NULL;
    u_int i;

    check(seg);
    check(sect);
    require_action(streq_safe(seg-&gt;segname, sect-&gt;segname, <span class="enscript-keyword">sizeof</span>(seg-&gt;segname)),
        finish, rval=KERN_FAILURE);
    
    <span class="enscript-comment">/* Add the section into the section index */</span>

    <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
        sectp = kxld_array_get_item(&amp;seg-&gt;sects, i);
        <span class="enscript-keyword">if</span> (NULL == *sectp) {
            *sectp = sect;
            <span class="enscript-keyword">break</span>;
        }
    }
    require_action(i &lt; seg-&gt;sects.nitems, finish, rval=KERN_FAILURE);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_seg_finish_init</span>(KXLDSeg *seg)
{
    kern_return_t rval = KERN_FAILURE;
    u_int i = 0;
    KXLDSect *sect = NULL;
    kxld_addr_t maxaddr = 0;
    kxld_size_t maxsize = 0;

    <span class="enscript-comment">/* If we already have a size for this segment (e.g. from the mach-o load
     * command) then don't recalculate the segment size. This is safer since 
     * when we recalculate we are making assumptions about page alignment and 
     * padding that the kext mach-o file was built with. Better to trust the 
     * macho-o info, if we have it. If we don't (i.e. vmsize == 0) then add up 
     * the section sizes and take a best guess at page padding.
     */</span>
    <span class="enscript-keyword">if</span> ((seg-&gt;vmsize == 0) &amp;&amp; (seg-&gt;sects.nitems)) {
        <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
            sect = get_sect_by_index(seg, i);
            require_action(sect, finish, rval=KERN_FAILURE);
            <span class="enscript-keyword">if</span> (sect-&gt;base_addr &gt; maxaddr) {
                maxaddr = sect-&gt;base_addr;
                maxsize = sect-&gt;size;
            }
        }

        seg-&gt;vmsize = kxld_round_page_cross_safe(maxaddr + 
                                                 maxsize - seg-&gt;base_addr);
    }

    rval = KERN_SUCCESS;
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_seg_set_vm_protections</span>(KXLDSeg *seg, boolean_t strict_protections)
{
    <span class="enscript-keyword">if</span> (strict_protections) {
        <span class="enscript-keyword">if</span> (!strncmp(seg-&gt;segname, SEG_TEXT, const_strlen(SEG_TEXT))) {
            seg-&gt;initprot = TEXT_SEG_PROT;
            seg-&gt;maxprot = TEXT_SEG_PROT;
        } <span class="enscript-keyword">else</span> {
            seg-&gt;initprot = DATA_SEG_PROT;
            seg-&gt;maxprot = DATA_SEG_PROT;
        }
    } <span class="enscript-keyword">else</span> {
        seg-&gt;initprot = VM_PROT_ALL;
        seg-&gt;maxprot = VM_PROT_ALL;
    }
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_seg_relocate</span>(KXLDSeg *seg, kxld_addr_t link_addr)
{
    KXLDSect *sect = NULL;
    u_int i = 0;

    seg-&gt;link_addr += link_addr;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; seg-&gt;sects.nitems; ++i) {
        sect = get_sect_by_index(seg, i);
        kxld_sect_relocate(sect, link_addr);
    }
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_seg_populate_linkedit</span>(KXLDSeg *seg, <span class="enscript-type">const</span> KXLDSymtab *symtab, boolean_t is_32_bit 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    , <span class="enscript-type">const</span> KXLDArray *locrelocs
    , <span class="enscript-type">const</span> KXLDArray *extrelocs
    , boolean_t target_supports_slideable_kexts
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>
    )
{
    u_long size = 0;

    size += kxld_symtab_get_macho_data_size(symtab, is_32_bit);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    <span class="enscript-keyword">if</span> (target_supports_slideable_kexts) {
        size += kxld_reloc_get_macho_data_size(locrelocs, extrelocs);
    }
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>

    seg-&gt;vmsize = kxld_round_page_cross_safe(size);
}

</pre>
<hr />
</body></html>