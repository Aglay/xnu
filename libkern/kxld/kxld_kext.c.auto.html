<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kxld_kext.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kxld_kext.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008, 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kmod.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/reloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    #include &lt;libkern/kernel_mach_header.h&gt;
    #include &lt;libkern/OSKextLib.h&gt;
    #include &lt;libkern/OSKextLibPrivate.h&gt;
    #include &lt;mach/vm_param.h&gt;
    #include &lt;mach-o/fat.h&gt;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !KERNEL */</span>
    #include &lt;architecture/byte_order.h&gt;
    #include &lt;mach/mach_init.h&gt;
    #include &lt;mach-o/arch.h&gt;
    #include &lt;mach-o/swap.h&gt;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_ASSERT_COMPONENT_NAME_STRING</span> <span class="enscript-string">&quot;kxld&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;AssertMacros.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_demangle.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_dict.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_kext.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_object.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_reloc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_sect.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_seg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_symtab.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_util.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_vtable.h&quot;</span>

<span class="enscript-type">struct</span> symtab_command;

<span class="enscript-type">struct</span> kxld_kext {
    KXLDObject *kext;
    KXLDObject *interface;
    KXLDArray vtables;
    KXLDDict vtable_index;
    boolean_t vtables_created;
    boolean_t vtable_index_created;
};

<span class="enscript-comment">/*******************************************************************************
* Prototypes
*******************************************************************************/</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">export_symbols_through_interface</span>(
    <span class="enscript-type">const</span> KXLDObject *kext, <span class="enscript-type">const</span> KXLDObject *interface, 
    KXLDDict *defined_symbols_by_name, 
    KXLDDict *defined_cxx_symbol_by_value,
    KXLDDict *obsolete_symbols_by_name);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">export_symbols</span>(<span class="enscript-type">const</span> KXLDObject *kext,
    KXLDDict *defined_symbols_by_name, 
    KXLDDict *defined_cxx_symbols_by_value);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">create_vtables</span>(KXLDKext *kext,
    <span class="enscript-type">const</span> KXLDDict *defined_symbols, <span class="enscript-type">const</span> KXLDDict *defined_cxx_symbols);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">get_vtable_syms_from_smcp</span>(KXLDKext *kext, 
    <span class="enscript-type">const</span> KXLDDict *defined_symbols, KXLDSym *super_metaclass_ptr_sym, 
    KXLDSym **vtable_sym_out, KXLDSym **meta_vtable_sym_out);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">resolve_symbols</span>(KXLDKext *kext, 
    <span class="enscript-type">const</span> KXLDDict *defined_symbols, <span class="enscript-type">const</span> KXLDDict *obsolete_symbols);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">patch_vtables</span>(KXLDKext *kext, KXLDDict *patched_vtables,
    <span class="enscript-type">const</span> KXLDDict *defined_symbols);
<span class="enscript-type">static</span> <span class="enscript-type">const</span> KXLDSym *<span class="enscript-function-name">get_metaclass_symbol_from_super_meta_class_pointer_symbol</span>(
    KXLDKext *kext, KXLDSym *super_metaclass_pointer_sym);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">create_vtable_index</span>(KXLDKext *kext);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">validate_symbols</span>(KXLDKext *kext);

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
size_t
<span class="enscript-function-name">kxld_kext_sizeof</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(KXLDKext);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_kext_init</span>(KXLDKext *kext, KXLDObject *kext_object, 
    KXLDObject *interface_object)
{
    kern_return_t rval = KERN_FAILURE;

    check(kext);
    check(kext_object);

    kext-&gt;kext = kext_object;

    <span class="enscript-keyword">if</span> (interface_object) {
        kext-&gt;interface = interface_object;

        rval = kxld_object_index_symbols_by_name(kext-&gt;kext);
        require_noerr(rval, finish);
    }
    
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_kext_clear</span>(KXLDKext *kext)
{
    KXLDVTable *vtable = NULL;
    u_int i;

    check(kext);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; kext-&gt;vtables.nitems; ++i) {
        vtable = kxld_array_get_item(&amp;kext-&gt;vtables, i);
        kxld_vtable_clear(vtable);
    }
    kxld_array_reset(&amp;kext-&gt;vtables);
    kxld_dict_clear(&amp;kext-&gt;vtable_index);

    kext-&gt;kext = NULL;
    kext-&gt;interface = NULL;
    kext-&gt;vtables_created = FALSE;
    kext-&gt;vtable_index_created = FALSE;
}


<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_kext_deinit</span>(KXLDKext *kext)
{
    KXLDVTable *vtable = NULL;
    u_int i;

    check(kext);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; kext-&gt;vtables.maxitems; ++i) {
        vtable = kxld_array_get_slot(&amp;kext-&gt;vtables, i);
        kxld_vtable_deinit(vtable);
    }
    kxld_array_deinit(&amp;kext-&gt;vtables);
    kxld_dict_deinit(&amp;kext-&gt;vtable_index);

    bzero(kext, <span class="enscript-keyword">sizeof</span>(*kext));
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_kext_export_symbols</span>(<span class="enscript-type">const</span> KXLDKext *kext, 
    KXLDDict *defined_symbols_by_name,
    KXLDDict *obsolete_symbols_by_name,
    KXLDDict *defined_cxx_symbols_by_value)
{
    kern_return_t rval = KERN_FAILURE;

    check(kext);

    <span class="enscript-keyword">if</span> (kext-&gt;interface) {
        rval = export_symbols_through_interface(kext-&gt;kext, kext-&gt;interface, 
            defined_symbols_by_name, obsolete_symbols_by_name,
            defined_cxx_symbols_by_value);
        require_noerr(rval, finish);
    } <span class="enscript-keyword">else</span> {
        rval = export_symbols(kext-&gt;kext, defined_symbols_by_name,
            defined_cxx_symbols_by_value);
        require_noerr(rval, finish);
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">export_symbols_through_interface</span>(<span class="enscript-type">const</span> KXLDObject *kext,
    <span class="enscript-type">const</span> KXLDObject *interface, KXLDDict *defined_symbols_by_name,
    KXLDDict *obsolete_symbols_by_name, KXLDDict *defined_cxx_symbols_by_value)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSymtabIterator iter;
    <span class="enscript-type">const</span> KXLDSymtab *kext_symtab = NULL;
    <span class="enscript-type">const</span> KXLDSymtab *interface_symtab = NULL;
    KXLDSym *kext_sym = NULL;
    <span class="enscript-type">const</span> KXLDSym *interface_sym = NULL;

    check(kext);
    check(interface);

    kext_symtab = kxld_object_get_symtab(kext);
    interface_symtab = kxld_object_get_symtab(interface);

    <span class="enscript-keyword">if</span> (defined_symbols_by_name) {
        <span class="enscript-comment">/* Add exported symbols */</span>
        (<span class="enscript-type">void</span>) kxld_symtab_iterator_init(&amp;iter, interface_symtab, 
            kxld_sym_is_undefined, FALSE);
        <span class="enscript-keyword">while</span> ((interface_sym = kxld_symtab_iterator_get_next(&amp;iter))) {
            kext_sym = kxld_symtab_get_locally_defined_symbol_by_name(kext_symtab, 
                interface_sym-&gt;name);
            <span class="enscript-keyword">if</span> (!kext_sym) {
                kxld_log(kKxldLogLinking, kKxldLogWarn,
                    <span class="enscript-string">&quot;In interface %s of %s, couldn't find symbol %s\n&quot;</span>, 
                    kxld_object_get_name(interface), kxld_object_get_name(kext),
                    interface_sym-&gt;name);
                <span class="enscript-keyword">continue</span>;
            }

            rval = kxld_dict_insert(defined_symbols_by_name, 
                kext_sym-&gt;name, kext_sym);
            require_noerr(rval, finish);
        }

        <span class="enscript-comment">/* Add indirect symbols */</span>
        (<span class="enscript-type">void</span>) kxld_symtab_iterator_init(&amp;iter, interface_symtab, 
            kxld_sym_is_indirect, FALSE);
        <span class="enscript-keyword">while</span> ((interface_sym = kxld_symtab_iterator_get_next(&amp;iter))) {
            kext_sym = kxld_symtab_get_locally_defined_symbol_by_name(kext_symtab, 
                interface_sym-&gt;alias);
            <span class="enscript-keyword">if</span> (!kext_sym) {
                kxld_log(kKxldLogLinking, kKxldLogWarn,
                    <span class="enscript-string">&quot;In interface %s of %s, couldn't find indirect symbol %s (%s)\n&quot;</span>, 
                    kxld_object_get_name(interface), kxld_object_get_name(kext),
                    interface_sym-&gt;alias, interface_sym-&gt;name);
                <span class="enscript-keyword">continue</span>;
            }

            rval = kxld_dict_insert(defined_symbols_by_name, 
                interface_sym-&gt;name, kext_sym);
            require_noerr(rval, finish);
        }
    }

    <span class="enscript-comment">/* Add obsolete symbols */</span>
    <span class="enscript-keyword">if</span> (obsolete_symbols_by_name) {
        (<span class="enscript-type">void</span>) kxld_symtab_iterator_init(&amp;iter, interface_symtab, 
            kxld_sym_is_obsolete, FALSE);
        <span class="enscript-keyword">while</span> ((kext_sym = kxld_symtab_iterator_get_next(&amp;iter))) {
            rval = kxld_dict_insert(obsolete_symbols_by_name, 
                kext_sym-&gt;name, kext_sym);
            require_noerr(rval, finish);
        }
    }

    <span class="enscript-comment">/* Add C++ symbols */</span>
    <span class="enscript-keyword">if</span> (defined_cxx_symbols_by_value) {
        (<span class="enscript-type">void</span>) kxld_symtab_iterator_init(&amp;iter, kext_symtab,
            kxld_sym_is_cxx, FALSE);
        <span class="enscript-keyword">while</span> ((kext_sym = kxld_symtab_iterator_get_next(&amp;iter))) {
            rval = kxld_dict_insert(defined_cxx_symbols_by_value,
                &amp;kext_sym-&gt;link_addr, kext_sym);
            require_noerr(rval, finish);
        }
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">export_symbols</span>(<span class="enscript-type">const</span> KXLDObject *kext, KXLDDict *defined_symbols_by_name,
    KXLDDict *defined_cxx_symbols_by_value)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSymtabIterator iter;
    KXLDSym *sym = NULL;

    (<span class="enscript-type">void</span>) kxld_symtab_iterator_init(&amp;iter, kxld_object_get_symtab(kext), 
        kxld_sym_is_exported, FALSE);
    <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {
        <span class="enscript-keyword">if</span> (defined_symbols_by_name) {
            rval = kxld_dict_insert(defined_symbols_by_name, sym-&gt;name, sym);
            require_noerr(rval, finish);
        }

        <span class="enscript-keyword">if</span> (kxld_sym_is_cxx(sym) &amp;&amp; defined_cxx_symbols_by_value) {
            rval = kxld_dict_insert(defined_cxx_symbols_by_value,
                &amp;sym-&gt;link_addr, sym);
            require_noerr(rval, finish);
        }
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_kext_export_vtables</span>(KXLDKext *kext, <span class="enscript-type">const</span> KXLDDict *defined_cxx_symbols,
    <span class="enscript-type">const</span> KXLDDict *defined_symbols, KXLDDict *vtables)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDVTable *vtable = NULL;
    u_int i = 0;

    check(kext);
    check(defined_symbols);
    check(defined_cxx_symbols);
    check(vtables);

    rval = create_vtables(kext, defined_cxx_symbols, defined_symbols);
    require_noerr(rval, finish);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; kext-&gt;vtables.nitems; ++i) {
        vtable = kxld_array_get_item(&amp;kext-&gt;vtables, i);

        rval = kxld_dict_insert(vtables, vtable-&gt;name, vtable);
        require_noerr(rval, finish);
    }
    
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_kext_get_vmsize</span>(<span class="enscript-type">const</span> KXLDKext *kext, 
    u_long *header_size, u_long *vmsize)
{
    (<span class="enscript-type">void</span>) kxld_object_get_vmsize(kext-&gt;kext, header_size, vmsize);
}

<span class="enscript-comment">/*******************************************************************************
 *******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_kext_set_linked_object_size</span>(KXLDKext *kext, u_long vmsize)
{
    (<span class="enscript-type">void</span>) kxld_object_set_linked_object_size(kext-&gt;kext, vmsize);
}


<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_kext_export_linked_object</span>(<span class="enscript-type">const</span> KXLDKext *kext, 
    u_char *linked_object, kxld_addr_t *kmod_info)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">const</span> KXLDSym *kmodsym = NULL;

    kmodsym = kxld_symtab_get_locally_defined_symbol_by_name(
        kxld_object_get_symtab(kext-&gt;kext), KXLD_KMOD_INFO_SYMBOL);
    require_action(kmodsym, finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogNoKmodInfo));
 
    *kmod_info = kmodsym-&gt;link_addr;

    rval = kxld_object_export_linked_object(kext-&gt;kext, linked_object);
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_kext_relocate</span>(KXLDKext *kext, kxld_addr_t link_address,
    KXLDDict *patched_vtables, <span class="enscript-type">const</span> KXLDDict *defined_symbols, 
    <span class="enscript-type">const</span> KXLDDict *obsolete_symbols, <span class="enscript-type">const</span> KXLDDict *defined_cxx_symbols)
{
    kern_return_t rval = KERN_FAILURE;

    check(kext);
    check(patched_vtables);
    check(defined_symbols);
    check(obsolete_symbols);

    <span class="enscript-comment">/* Kexts that are being relocated need symbols indexed by value for vtable
     * creation and patching. Note that we don't need to index by value for
     * dependencies that have already been linked because their symbols are
     * already in the global cxx value table. It's important to index the
     * symbols by value before we relocate the symbols because the vtable
     * entries will still have unrelocated values.
     */</span>
    rval = kxld_object_index_cxx_symbols_by_value(kext-&gt;kext);
    require_noerr(rval, finish);

    rval = kxld_object_index_symbols_by_name(kext-&gt;kext);
    require_noerr(rval, finish);

    rval = kxld_object_relocate(kext-&gt;kext, link_address);
    require_noerr(rval, finish);

    rval = resolve_symbols(kext, defined_symbols, obsolete_symbols);
    require_noerr(rval, finish);

    rval = create_vtables(kext, defined_cxx_symbols, <span class="enscript-comment">/* defined_symbols */</span> NULL);
    require_noerr(rval, finish);

    rval = patch_vtables(kext, patched_vtables, defined_symbols);
    require_noerr(rval, finish);
    
    rval = validate_symbols(kext);
    require_noerr(rval, finish);

    rval = kxld_object_process_relocations(kext-&gt;kext, patched_vtables);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
* The defined symbols argument is optional.  When supplied, create_vtables()
* will look for vtable symbols in the defined_symbols dictionary.  Otherwise,
* it will look in the kext's symbol table for vtable symbols.
*
* We do this because there are two types of KXLDKext objects that call
* create_vtables(), those that have been linked, and those that haven't.  The
* linked kexts export their symbols into the global symbol table that is used
* for symbol resolution, so we can look there for vtable symbols without
* having to index their local symbol table separately.
* 
* Unlinked kexts haven't yet had their symbols exported into the global table,
* so we have to index their local symbol table separately.
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t 
<span class="enscript-function-name">create_vtables</span>(KXLDKext *kext, <span class="enscript-type">const</span> KXLDDict *defined_cxx_symbols,
    <span class="enscript-type">const</span> KXLDDict *defined_symbols)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">const</span> KXLDSymtab *symtab = NULL;
    KXLDSymtabIterator iter;
    KXLDSym *sym = NULL;
    KXLDSym *vtable_sym = NULL;
    KXLDSym *meta_vtable_sym = NULL;
    KXLDVTable *vtable = NULL;
    KXLDVTable *meta_vtable = NULL;
    u_int i = 0;
    u_int nvtables = 0;

    <span class="enscript-keyword">if</span> (kext-&gt;vtables_created) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    symtab = kxld_object_get_symtab(kext-&gt;kext);

    <span class="enscript-keyword">if</span> (kxld_object_is_linked(kext-&gt;kext)) {
        <span class="enscript-comment">/* Create a vtable object for every vtable symbol */</span>
        kxld_symtab_iterator_init(&amp;iter, symtab, kxld_sym_is_vtable, FALSE);
        nvtables = kxld_symtab_iterator_get_num_remaining(&amp;iter);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/* We walk over the super metaclass pointer symbols because classes
         * with them are the only ones that need patching.  Then we double the
         * number of vtables we're expecting, because every pointer will have a
         * class vtable and a MetaClass vtable.
         */</span>
        kxld_symtab_iterator_init(&amp;iter, symtab, 
            kxld_sym_is_super_metaclass_pointer, FALSE);
        nvtables = kxld_symtab_iterator_get_num_remaining(&amp;iter) * 2;
    }

    rval = kxld_array_init(&amp;kext-&gt;vtables, <span class="enscript-keyword">sizeof</span>(KXLDVTable), nvtables);
    require_noerr(rval, finish);

    <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {
        <span class="enscript-keyword">if</span> (kxld_object_is_linked(kext-&gt;kext)) {
            vtable_sym = sym;
            meta_vtable_sym = NULL;
            meta_vtable = NULL;
        } <span class="enscript-keyword">else</span> {
            rval = get_vtable_syms_from_smcp(kext, defined_symbols, sym,
                &amp;vtable_sym, &amp;meta_vtable_sym);
            require_noerr(rval, finish);
        }

        vtable = kxld_array_get_item(&amp;kext-&gt;vtables, i++);
        rval = kxld_vtable_init(vtable, vtable_sym, kext-&gt;kext, 
            defined_cxx_symbols);
        require_noerr(rval, finish);

        <span class="enscript-comment">/* meta_vtable_sym will be null when we don't support strict
         * patching and can't find the metaclass vtable. If that's the
         * case, we just reduce the expect number of vtables by 1.
         */</span>
        <span class="enscript-keyword">if</span> (!kxld_object_is_linked(kext-&gt;kext)) {
            <span class="enscript-keyword">if</span> (meta_vtable_sym) {
                meta_vtable = kxld_array_get_item(&amp;kext-&gt;vtables, i++);
                rval = kxld_vtable_init(meta_vtable, meta_vtable_sym, 
                    kext-&gt;kext, defined_cxx_symbols);
                require_noerr(rval, finish);
            } <span class="enscript-keyword">else</span> {
                kxld_array_resize(&amp;kext-&gt;vtables, --nvtables);
                meta_vtable = NULL;
            }
        }
    }
    require_action(i == kext-&gt;vtables.nitems, finish, 
        rval=KERN_FAILURE);

    kext-&gt;vtables_created = TRUE;
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">get_vtable_syms_from_smcp</span>(KXLDKext *kext, <span class="enscript-type">const</span> KXLDDict *defined_symbols,
    KXLDSym *super_metaclass_ptr_sym, KXLDSym **vtable_sym_out, 
    KXLDSym **meta_vtable_sym_out)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">const</span> KXLDSymtab *symtab = NULL;
    KXLDSym *vtable_sym = NULL;
    KXLDSym *meta_vtable_sym = NULL;
    <span class="enscript-type">char</span> class_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> vtable_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> meta_vtable_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> *demangled_name1 = NULL;
    <span class="enscript-type">char</span> *demangled_name2 = NULL;
    size_t demangled_length1 = 0;
    size_t demangled_length2 = 0;

    check(kext);
    check(vtable_sym_out);
    check(meta_vtable_sym_out);

    require(!kxld_object_is_kernel(kext-&gt;kext), finish);

    symtab = kxld_object_get_symtab(kext-&gt;kext);

    <span class="enscript-comment">/* Get the class name from the smc pointer */</span>
    rval = kxld_sym_get_class_name_from_super_metaclass_pointer(
        super_metaclass_ptr_sym, class_name, <span class="enscript-keyword">sizeof</span>(class_name));
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Get the vtable name from the class name */</span>
    rval = kxld_sym_get_vtable_name_from_class_name(class_name,
        vtable_name, <span class="enscript-keyword">sizeof</span>(vtable_name));
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Get the vtable symbol */</span>
    <span class="enscript-keyword">if</span> (defined_symbols) {
        vtable_sym = kxld_dict_find(defined_symbols, vtable_name);
    } <span class="enscript-keyword">else</span> {
        vtable_sym = kxld_symtab_get_locally_defined_symbol_by_name(symtab, 
            vtable_name);
    }
    require_action(vtable_sym, finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogPatching, kKxldLogErr, kKxldLogMissingVtable,
        vtable_name, class_name));

    <span class="enscript-comment">/* Get the meta vtable name from the class name */</span>
    rval = kxld_sym_get_meta_vtable_name_from_class_name(class_name,
        meta_vtable_name, <span class="enscript-keyword">sizeof</span>(meta_vtable_name));
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Get the meta vtable symbol */</span>
    <span class="enscript-keyword">if</span> (defined_symbols) {
        meta_vtable_sym = kxld_dict_find(defined_symbols, meta_vtable_name);
    } <span class="enscript-keyword">else</span> {
        meta_vtable_sym = kxld_symtab_get_locally_defined_symbol_by_name(symtab,
            meta_vtable_name);
    }
    <span class="enscript-keyword">if</span> (!meta_vtable_sym) {
        <span class="enscript-keyword">if</span> (kxld_object_target_supports_strict_patching(kext-&gt;kext)) {
            kxld_log(kKxldLogPatching, kKxldLogErr, 
                kKxldLogMissingVtable, 
                meta_vtable_name, class_name);
            rval = KERN_FAILURE;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        } <span class="enscript-keyword">else</span> {
            kxld_log(kKxldLogPatching, kKxldLogErr, 
                <span class="enscript-string">&quot;Warning: &quot;</span> kKxldLogMissingVtable, 
                kxld_demangle(meta_vtable_name, &amp;demangled_name1, 
                    &amp;demangled_length1), 
                kxld_demangle(class_name, &amp;demangled_name2, 
                    &amp;demangled_length2));
        }
    }
    
    *vtable_sym_out = vtable_sym;
    *meta_vtable_sym_out = meta_vtable_sym;
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (demangled_name1) kxld_free(demangled_name1, demangled_length1);
    <span class="enscript-keyword">if</span> (demangled_name2) kxld_free(demangled_name2, demangled_length2);

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">resolve_symbols</span>(KXLDKext *kext, <span class="enscript-type">const</span> KXLDDict *defined_symbols, 
    <span class="enscript-type">const</span> KXLDDict *obsolete_symbols)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">const</span> KXLDSymtab *symtab = NULL;
    KXLDSymtabIterator iter;
    KXLDSym *sym = NULL;
    KXLDSym *defined_sym = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = NULL;
    boolean_t tests_for_weak = FALSE;
    boolean_t error = FALSE;
    <span class="enscript-type">char</span> *demangled_name = NULL;
    size_t demangled_length = 0;

    check(kext-&gt;kext);
    check(defined_symbols);
    check(obsolete_symbols);

    symtab = kxld_object_get_symtab(kext-&gt;kext);

    <span class="enscript-comment">/* Check if the kext tests for weak symbols */</span>
    sym = kxld_symtab_get_symbol_by_name(symtab, KXLD_WEAK_TEST_SYMBOL);
    tests_for_weak = (sym != NULL);

    <span class="enscript-comment">/* Check for duplicate symbols */</span>
    kxld_symtab_iterator_init(&amp;iter, symtab, kxld_sym_is_exported, FALSE);
    <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {
        defined_sym = kxld_dict_find(defined_symbols, sym-&gt;name);
        <span class="enscript-keyword">if</span> (defined_sym) { 
            <span class="enscript-comment">/* Not a problem if the symbols have the same address */</span>
            <span class="enscript-keyword">if</span> (defined_sym-&gt;link_addr == sym-&gt;link_addr) {
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-keyword">if</span> (!error) {
                error = TRUE;
                kxld_log(kKxldLogLinking, kKxldLogErr,
                    <span class="enscript-string">&quot;The following symbols were defined more than once:&quot;</span>);
            }

            kxld_log(kKxldLogLinking, kKxldLogErr, <span class="enscript-string">&quot;\t%s: %p - %p&quot;</span>, 
                kxld_demangle(sym-&gt;name, &amp;demangled_name, &amp;demangled_length),
                (<span class="enscript-type">void</span> *) (uintptr_t) sym-&gt;link_addr, 
                (<span class="enscript-type">void</span> *) (uintptr_t) defined_sym-&gt;link_addr);
        }
    }
    require_noerr_action(error, finish, rval=KERN_FAILURE);

    <span class="enscript-comment">/* Resolve undefined and indirect symbols */</span>

    <span class="enscript-comment">/* Iterate over all unresolved symbols */</span>
    kxld_symtab_iterator_init(&amp;iter, symtab, 
        kxld_sym_is_unresolved, FALSE);
    <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {

        <span class="enscript-comment">/* Common symbols are not supported */</span>
        <span class="enscript-keyword">if</span> (kxld_sym_is_common(sym)) {

            <span class="enscript-keyword">if</span> (!error) {
                error = TRUE;
                <span class="enscript-keyword">if</span> (kxld_object_target_supports_common_symbols(kext-&gt;kext)) {
                    kxld_log(kKxldLogLinking, kKxldLogErr, 
                        <span class="enscript-string">&quot;The following common symbols were not resolved:&quot;</span>);
                } <span class="enscript-keyword">else</span> {
                    kxld_log(kKxldLogLinking, kKxldLogErr, 
                        <span class="enscript-string">&quot;Common symbols are not supported in kernel extensions. &quot;</span> 
                         <span class="enscript-string">&quot;Use -fno-common to build your kext. &quot;</span>
                         <span class="enscript-string">&quot;The following are common symbols:&quot;</span>);
                }
            }
            kxld_log(kKxldLogLinking, kKxldLogErr, <span class="enscript-string">&quot;\t%s&quot;</span>, 
                kxld_demangle(sym-&gt;name, &amp;demangled_name, &amp;demangled_length));

        } <span class="enscript-keyword">else</span> {

            <span class="enscript-comment">/* Find the address of the defined symbol */</span>
            <span class="enscript-keyword">if</span> (kxld_sym_is_undefined(sym)) {
                name = sym-&gt;name;
            } <span class="enscript-keyword">else</span> {
                name = sym-&gt;alias;
            }
            defined_sym = kxld_dict_find(defined_symbols, name);
            
            <span class="enscript-comment">/* Resolve the symbol.  If a definition cannot be found, then:
             * 1) Psuedokexts log a warning and proceed
             * 2) Actual kexts delay the error until validation in case vtable
             *    patching replaces the undefined symbol.
             */</span>

            <span class="enscript-keyword">if</span> (defined_sym) {

                rval = kxld_sym_resolve(sym, defined_sym-&gt;link_addr);
                require_noerr(rval, finish);

                <span class="enscript-keyword">if</span> (obsolete_symbols &amp;&amp; kxld_dict_find(obsolete_symbols, name)) {
                    kxld_log(kKxldLogLinking, kKxldLogWarn, 
                        <span class="enscript-string">&quot;This kext uses obsolete symbol %s.&quot;</span>, 
                        kxld_demangle(name, &amp;demangled_name, &amp;demangled_length));
                }

            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kxld_sym_is_weak(sym)) {
                kxld_addr_t addr = 0;

                <span class="enscript-comment">/* Make sure that the kext has referenced gOSKextUnresolved.
                 */</span>
                require_action(tests_for_weak, finish, 
                   rval=KERN_FAILURE;
                   kxld_log(kKxldLogLinking, kKxldLogErr, 
                      <span class="enscript-string">&quot;This kext has weak references but does not test for &quot;</span>
                      <span class="enscript-string">&quot;them. Test for weak references with &quot;</span>
                      <span class="enscript-string">&quot;OSKextSymbolIsResolved(). (found in &lt;libkern/OSKextLib.h&gt;)&quot;</span>));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
                <span class="enscript-comment">/* Get the address of the default weak address.
                 */</span>
                addr = (kxld_addr_t) &amp;kext_weak_symbol_referenced;
#<span class="enscript-reference">else</span>  
                <span class="enscript-comment">/* This is run during symbol generation only, so we only 
                 * need a filler value here.
                 */</span>
                addr = 0xF00DD00D;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

                rval = kxld_sym_resolve(sym, addr);
                require_noerr(rval, finish);
            }
        }
    }
    require_noerr_action(error, finish, rval=KERN_FAILURE);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (demangled_name) kxld_free(demangled_name, demangled_length);

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
* We must patch vtables to ensure binary compatibility, and to perform that
* patching, we have to determine the vtables' inheritance relationships.  The
* MetaClass system gives us a way to do that:
*   1) Iterate over all of the super MetaClass pointer symbols.  Every class
*      that inherits from OSObject will have a pointer in its MetaClass that
*      points to the MetaClass's super MetaClass.
*   2) Derive the name of the class from the super MetaClass pointer.
*   3) Derive the name of the class's vtable from the name of the class
*   4) Follow the super MetaClass pointer to get the address of the super
*      MetaClass's symbol
*   5) Look up the super MetaClass symbol by address
*   6) Derive the super class's name from the super MetaClass name
*   7) Derive the super class's vtable from the super class's name
* This procedure will allow us to find all of the OSObject-derived classes and
* their super classes, and thus patch all of the vtables.
*
* We also have to take care to patch up the MetaClass's vtables.  The
* MetaClasses follow a parallel hierarchy to the classes, so once we have the
* class name and super class name, we can also derive the MetaClass name and
* the super MetaClass name, and thus find and patch their vtables as well.
*******************************************************************************/</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kOSMetaClassVTableName</span> <span class="enscript-string">&quot;__ZTV11OSMetaClass&quot;</span>

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">patch_vtables</span>(KXLDKext *kext, KXLDDict *patched_vtables, 
    <span class="enscript-type">const</span> KXLDDict *defined_symbols)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSymtabIterator iter;
    <span class="enscript-type">const</span> KXLDSymtab *symtab = NULL;
    <span class="enscript-type">const</span> KXLDSym *metaclass = NULL;
    KXLDSym *super_metaclass_pointer = NULL;
    KXLDSym *final_sym = NULL;
    KXLDVTable *vtable = NULL;
    KXLDVTable *super_vtable = NULL;
    <span class="enscript-type">char</span> class_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> super_class_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> vtable_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> super_vtable_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> final_sym_name[KXLD_MAX_NAME_LEN];
    <span class="enscript-type">char</span> *demangled_name1 = NULL;
    <span class="enscript-type">char</span> *demangled_name2 = NULL;
    size_t demangled_length1 = 0;;
    size_t demangled_length2 = 0;
    size_t len = 0;
    u_int nvtables = 0;
    u_int npatched = 0;
    u_int nprogress = 0;
    boolean_t failure = FALSE;

    check(kext);
    check(patched_vtables);

    symtab = kxld_object_get_symtab(kext-&gt;kext);

    rval = create_vtable_index(kext);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Find each super meta class pointer symbol */</span>

    kxld_symtab_iterator_init(&amp;iter, symtab, 
        kxld_sym_is_super_metaclass_pointer, FALSE);
    nvtables = kxld_symtab_iterator_get_num_remaining(&amp;iter);

    <span class="enscript-keyword">while</span> (npatched &lt; nvtables) {
        npatched = 0;
        nprogress = 0;
        kxld_symtab_iterator_reset(&amp;iter);
        <span class="enscript-keyword">while</span>((super_metaclass_pointer = kxld_symtab_iterator_get_next(&amp;iter))) 
        {
            <span class="enscript-comment">/* Get the class name from the smc pointer */</span>
            rval = kxld_sym_get_class_name_from_super_metaclass_pointer(
                super_metaclass_pointer, class_name, <span class="enscript-keyword">sizeof</span>(class_name));
            require_noerr(rval, finish);

            <span class="enscript-comment">/* Get the vtable name from the class name */</span>
            rval = kxld_sym_get_vtable_name_from_class_name(class_name,
                vtable_name, <span class="enscript-keyword">sizeof</span>(vtable_name));
            require_noerr(rval, finish);

            <span class="enscript-comment">/* Get the vtable and make sure it hasn't been patched */</span>
            vtable = kxld_dict_find(&amp;kext-&gt;vtable_index, vtable_name);
            require_action(vtable, finish, rval=KERN_FAILURE;
                kxld_log(kKxldLogPatching, kKxldLogErr, kKxldLogMissingVtable,
                    vtable_name, class_name));

            <span class="enscript-keyword">if</span> (!vtable-&gt;is_patched) {

                <span class="enscript-comment">/* Find the SMCP's meta class symbol */</span>
                metaclass = get_metaclass_symbol_from_super_meta_class_pointer_symbol(
                    kext, super_metaclass_pointer);
                require_action(metaclass, finish, rval=KERN_FAILURE);

                <span class="enscript-comment">/* Get the super class name from the super metaclass */</span>
                rval = kxld_sym_get_class_name_from_metaclass(metaclass,
                    super_class_name, <span class="enscript-keyword">sizeof</span>(super_class_name));
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Get the super vtable name from the class name */</span>
                rval = kxld_sym_get_vtable_name_from_class_name(super_class_name,
                    super_vtable_name, <span class="enscript-keyword">sizeof</span>(super_vtable_name));
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Get the super vtable if it's been patched */</span>
                super_vtable = kxld_dict_find(patched_vtables, super_vtable_name);

                <span class="enscript-keyword">if</span> (failure) {
                    <span class="enscript-type">const</span> KXLDVTable *unpatched_super_vtable;
                    unpatched_super_vtable = kxld_dict_find(&amp;kext-&gt;vtable_index,
                        super_vtable_name);

                    <span class="enscript-comment">/* If the parent's vtable hasn't been patched, warn that
                     * this vtable is unpatchable because of the parent.
                     */</span>
                    <span class="enscript-keyword">if</span> (!super_vtable) {
                        kxld_log(kKxldLogPatching, kKxldLogErr, 
                            <span class="enscript-string">&quot;The %s was not patched because its parent, &quot;</span>
                            <span class="enscript-string">&quot;the %s, was not %s.&quot;</span>,
                            kxld_demangle(vtable_name, &amp;demangled_name1, 
                                &amp;demangled_length1), 
                            kxld_demangle(super_vtable_name, &amp;demangled_name2, 
                                &amp;demangled_length2),
                            (unpatched_super_vtable) ? <span class="enscript-string">&quot;patchable&quot;</span> : <span class="enscript-string">&quot;found&quot;</span>);
                    }
                    <span class="enscript-keyword">continue</span>;
                }

                <span class="enscript-keyword">if</span> (!super_vtable) <span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">/* Get the final symbol's name from the super vtable */</span>
                rval = kxld_sym_get_final_sym_name_from_class_name(super_class_name, 
                    final_sym_name, <span class="enscript-keyword">sizeof</span>(final_sym_name));
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Verify that the final symbol does not exist.  First check
                 * all the externally defined symbols, then check locally.
                 */</span>
                final_sym = kxld_dict_find(defined_symbols, final_sym_name);
                <span class="enscript-keyword">if</span> (!final_sym) {
                    final_sym = kxld_symtab_get_locally_defined_symbol_by_name(
                        symtab, final_sym_name);
                }
                <span class="enscript-keyword">if</span> (final_sym) {
                    kxld_log(kKxldLogPatching, kKxldLogErr, 
                        <span class="enscript-string">&quot;Class '%s' is a subclass of final class '%s'.&quot;</span>,
                        kxld_demangle(class_name, &amp;demangled_name1, 
                            &amp;demangled_length1), 
                        kxld_demangle(super_class_name, &amp;demangled_name2, 
                            &amp;demangled_length2));
                    <span class="enscript-keyword">continue</span>;
                }

                <span class="enscript-comment">/* Patch the class's vtable */</span>
                rval = kxld_vtable_patch(vtable, super_vtable, kext-&gt;kext);
                <span class="enscript-keyword">if</span> (rval) <span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">/* Add the class's vtable to the set of patched vtables */</span>
                rval = kxld_dict_insert(patched_vtables, vtable-&gt;name, vtable);
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Get the meta vtable name from the class name */</span>
                rval = kxld_sym_get_meta_vtable_name_from_class_name(class_name,
                    vtable_name, <span class="enscript-keyword">sizeof</span>(vtable_name));
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Get the meta vtable.  Whether or not it should exist has already
                 * been tested in create_vtables(), so if it doesn't exist and we're
                 * still running, we can safely skip it.
                 */</span>
                vtable = kxld_dict_find(&amp;kext-&gt;vtable_index, vtable_name);
                <span class="enscript-keyword">if</span> (!vtable) {
                    ++nprogress;
                    ++npatched;
                    <span class="enscript-keyword">continue</span>;
                }
                require_action(!vtable-&gt;is_patched, finish, rval=KERN_FAILURE);

                <span class="enscript-comment">/* There is no way to look up a metaclass vtable at runtime, but
                 * we know that every class's metaclass inherits directly from 
                 * OSMetaClass, so we just hardcode that vtable name here.
                 */</span>
                len = strlcpy(super_vtable_name, kOSMetaClassVTableName,
                    <span class="enscript-keyword">sizeof</span>(super_vtable_name));
                require_action(len == const_strlen(kOSMetaClassVTableName),
                    finish, rval=KERN_FAILURE);
                       
                <span class="enscript-comment">/* Get the super meta vtable */</span>
                super_vtable = kxld_dict_find(patched_vtables, super_vtable_name);
                require_action(super_vtable &amp;&amp; super_vtable-&gt;is_patched, 
                    finish, rval=KERN_FAILURE);

                <span class="enscript-comment">/* Patch the meta class's vtable */</span>
                rval = kxld_vtable_patch(vtable, super_vtable, kext-&gt;kext);
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Add the MetaClass's vtable to the set of patched vtables */</span>
                rval = kxld_dict_insert(patched_vtables, vtable-&gt;name, vtable);
                require_noerr(rval, finish);
                
                ++nprogress;
            }

            ++npatched;
        }

        require_action(!failure, finish, rval=KERN_FAILURE);
        failure = (nprogress == 0);
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (demangled_name1) kxld_free(demangled_name1, demangled_length1);
    <span class="enscript-keyword">if</span> (demangled_name2) kxld_free(demangled_name2, demangled_length2);

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">create_vtable_index</span>(KXLDKext *kext)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDVTable *vtable = NULL;
    u_int i = 0;

    <span class="enscript-keyword">if</span> (kext-&gt;vtable_index_created) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Map vtable names to the vtable structures */</span>
    rval = kxld_dict_init(&amp;kext-&gt;vtable_index, kxld_dict_string_hash, 
        kxld_dict_string_cmp, kext-&gt;vtables.nitems);
    require_noerr(rval, finish);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; kext-&gt;vtables.nitems; ++i) {
        vtable = kxld_array_get_item(&amp;kext-&gt;vtables, i);
        rval = kxld_dict_insert(&amp;kext-&gt;vtable_index, vtable-&gt;name, vtable);
        require_noerr(rval, finish);
    }

    kext-&gt;vtable_index_created = TRUE;
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> KXLDSym *
<span class="enscript-function-name">get_metaclass_symbol_from_super_meta_class_pointer_symbol</span>(KXLDKext *kext,
    KXLDSym *super_metaclass_pointer_sym)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">const</span> KXLDReloc *reloc = NULL;
    <span class="enscript-type">const</span> KXLDSect *sect = NULL;
    <span class="enscript-type">const</span> KXLDSym *metaclass = NULL;
    
    check(kext);
    check(super_metaclass_pointer_sym);

    <span class="enscript-comment">/* Get the relocation entry that fills in the super metaclass pointer. */</span>
    reloc = kxld_object_get_reloc_at_symbol(kext-&gt;kext,
        super_metaclass_pointer_sym);
    require_action(reloc, finish, rval=KERN_FAILURE);

    <span class="enscript-comment">/* Get the section of the super metaclass pointer. */</span>
    sect = kxld_object_get_section_by_index(kext-&gt;kext,
        super_metaclass_pointer_sym-&gt;sectnum);
    require_action(sect, finish, rval=KERN_FAILURE);

    <span class="enscript-comment">/* Get the symbol that will be filled into the super metaclass pointer. */</span>
    metaclass = kxld_object_get_symbol_of_reloc(kext-&gt;kext, reloc, sect);
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> metaclass;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">validate_symbols</span>(KXLDKext *kext)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSymtabIterator iter;
    KXLDSym *sym = NULL;
    u_int error = FALSE;
    <span class="enscript-type">char</span> *demangled_name = NULL;
    size_t demangled_length = 0;
    
    <span class="enscript-comment">/* Check for any unresolved symbols */</span>
    kxld_symtab_iterator_init(&amp;iter, kxld_object_get_symtab(kext-&gt;kext), 
        kxld_sym_is_unresolved, FALSE);
    <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {
        <span class="enscript-keyword">if</span> (!error) {
            error = TRUE;
            kxld_log(kKxldLogLinking, kKxldLogErr, 
                <span class="enscript-string">&quot;The following symbols are unresolved for this kext:&quot;</span>);
        }
        kxld_log(kKxldLogLinking, kKxldLogErr, <span class="enscript-string">&quot;\t%s&quot;</span>, 
            kxld_demangle(sym-&gt;name, &amp;demangled_name, &amp;demangled_length));
    }
    require_noerr_action(error, finish, rval=KERN_FAILURE);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (demangled_name) kxld_free(demangled_name, demangled_length);
    <span class="enscript-keyword">return</span> rval;
}

</pre>
<hr />
</body></html>