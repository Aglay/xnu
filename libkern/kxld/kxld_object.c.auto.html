<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kxld_object.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kxld_object.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    #include &lt;libkern/kernel_mach_header.h&gt;
    #include &lt;mach/machine.h&gt;
    #include &lt;mach/vm_param.h&gt;
    #include &lt;mach-o/fat.h&gt;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !KERNEL */</span>
    <span class="enscript-comment">/* Get machine.h from the kernel source so we can support all platforms
     * that the kernel supports. Otherwise we're at the mercy of the host.
     */</span>
    #include <span class="enscript-string">&quot;../../osfmk/mach/machine.h&quot;</span>

    #include &lt;architecture/byte_order.h&gt;
    #include &lt;mach/mach_init.h&gt;
    #include &lt;mach-o/arch.h&gt;
    #include &lt;mach-o/swap.h&gt;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/reloc.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_ASSERT_COMPONENT_NAME_STRING</span> <span class="enscript-string">&quot;kxld&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;AssertMacros.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_demangle.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_dict.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_reloc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_sect.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_seg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_srcversion.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_symtab.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_util.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_uuid.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_versionmin.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_vtable.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_object.h&quot;</span>

<span class="enscript-comment">/*******************************************************************************
* Data structures
*******************************************************************************/</span>

<span class="enscript-type">struct</span> kxld_object {
    u_char *file;
    u_long size;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;
    uint32_t filetype;
    cpu_type_t cputype;
    cpu_subtype_t cpusubtype;
    KXLDArray segs;
    KXLDArray sects;
    KXLDArray extrelocs;
    KXLDArray locrelocs;
    KXLDRelocator relocator;
    KXLDuuid uuid;
    KXLDversionmin versionmin;
    KXLDsrcversion srcversion;
    KXLDSymtab *symtab;
    <span class="enscript-type">struct</span> dysymtab_command *dysymtab_hdr;
    kxld_addr_t link_addr;
    u_long    output_buffer_size;
    boolean_t is_kernel;
    boolean_t is_final_image;
    boolean_t is_linked;
    boolean_t got_is_created;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
    KXLDArray *section_order;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    boolean_t include_kaslr_relocs;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-type">enum</span> NXByteOrder host_order;
    <span class="enscript-type">enum</span> NXByteOrder target_order;
#<span class="enscript-reference">endif</span>
};

<span class="enscript-comment">/*******************************************************************************
* Prototypes
*******************************************************************************/</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">get_target_machine_info</span>(KXLDObject *object, 
    cpu_type_t cputype, cpu_subtype_t cpusubtype);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">get_macho_slice_for_arch</span>(KXLDObject *object, 
    u_char *file, u_long size);

<span class="enscript-type">static</span> u_long <span class="enscript-function-name">get_macho_header_size</span>(<span class="enscript-type">const</span> KXLDObject *object);
<span class="enscript-type">static</span> u_long <span class="enscript-function-name">get_macho_data_size</span>(<span class="enscript-type">const</span> KXLDObject *object) __unused;

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">init_from_execute</span>(KXLDObject *object);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">init_from_final_linked_image</span>(KXLDObject *object, 
    u_int *filetype_out, <span class="enscript-type">struct</span> symtab_command **symtab_hdr_out);

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">target_supports_protected_segments</span>(<span class="enscript-type">const</span> KXLDObject *object)
    __attribute__((pure));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">set_is_object_linked</span>(KXLDObject *object);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_BUNDLE</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">target_supports_bundle</span>(<span class="enscript-type">const</span> KXLDObject *object) 
    __attribute((pure));
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">init_from_bundle</span>(KXLDObject *object);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">process_relocs_from_tables</span>(KXLDObject *object);
<span class="enscript-type">static</span> KXLDSeg *<span class="enscript-function-name">get_seg_by_base_addr</span>(KXLDObject *object,
    kxld_addr_t base_addr);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">process_symbol_pointers</span>(KXLDObject *object);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">add_to_ptr</span>(u_char *symptr, kxld_addr_t val, boolean_t is_32_bit);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_BUNDLE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">target_supports_object</span>(<span class="enscript-type">const</span> KXLDObject *object) 
    __attribute((pure));
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">init_from_object</span>(KXLDObject *object);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">process_relocs_from_sections</span>(KXLDObject *object);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">target_supports_slideable_kexts</span>(<span class="enscript-type">const</span> KXLDObject *object);
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>


<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">export_macho_header</span>(<span class="enscript-type">const</span> KXLDObject *object, u_char *buf, 
    u_int ncmds, u_long *header_offset, u_long header_size);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
<span class="enscript-type">static</span> u_long <span class="enscript-function-name">get_macho_cmd_data_32</span>(u_char *file, u_long offset, 
    u_int *filetype, u_int *ncmds);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">export_macho_header_32</span>(<span class="enscript-type">const</span> KXLDObject *object, 
    u_char *buf, u_int ncmds, u_long *header_offset, u_long header_size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
<span class="enscript-type">static</span> u_long <span class="enscript-function-name">get_macho_cmd_data_64</span>(u_char *file, u_long offset,
    u_int *filetype, u_int *ncmds);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">export_macho_header_64</span>(<span class="enscript-type">const</span> KXLDObject *object, 
    u_char *buf, u_int ncmds, u_long *header_offset, u_long header_size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_GOT</span> || <span class="enscript-variable-name">KXLD_USER_OR_COMMON</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">add_section</span>(KXLDObject *object, KXLDSect **sect);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_GOT || KXLD_USER_OR_COMMON */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_COMMON</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">resolve_common_symbols</span>(KXLDObject *object);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_COMMON */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_GOT</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">target_has_got</span>(<span class="enscript-type">const</span> KXLDObject *object) __attribute__((pure));
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">create_got</span>(KXLDObject *object);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">populate_got</span>(KXLDObject *object);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_GOT */</span>

<span class="enscript-type">static</span> KXLDSym *<span class="enscript-function-name">get_mutable_sym</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> KXLDSym *sym);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">populate_kmod_info</span>(KXLDObject *object);

<span class="enscript-comment">/*******************************************************************************
* Prototypes that may need to be exported
*******************************************************************************/</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">kxld_object_target_needs_swap</span>(<span class="enscript-type">const</span> KXLDObject *object __unused);
<span class="enscript-type">static</span> KXLDSeg * <span class="enscript-function-name">kxld_object_get_seg_by_name</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname);
<span class="enscript-type">static</span> KXLDSect * <span class="enscript-function-name">kxld_object_get_sect_by_name</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname, 
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sectname);

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
size_t 
<span class="enscript-function-name">kxld_object_sizeof</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(KXLDObject);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_init_from_macho</span>(KXLDObject *object, u_char *file, u_long size,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, KXLDArray *section_order __unused, 
    cpu_type_t cputype, cpu_subtype_t cpusubtype, KXLDFlags flags __unused)
{
    kern_return_t       rval    = KERN_FAILURE;
    KXLDSeg           * seg     = NULL;
    u_int               i       = 0;

    check(object);
    check(file);
    check(name);

    object-&gt;name = name;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
    object-&gt;section_order = section_order;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    object-&gt;include_kaslr_relocs = ((flags &amp; kKXLDFlagIncludeRelocs) == kKXLDFlagIncludeRelocs);
#<span class="enscript-reference">endif</span>
    
    <span class="enscript-comment">/* Find the local architecture */</span>

    rval = get_target_machine_info(object, cputype, cpusubtype);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Find the Mach-O slice for the target architecture */</span>

    rval = get_macho_slice_for_arch(object, file, size);
    require_noerr(rval, finish);

    <span class="enscript-comment">/* Allocate the symbol table */</span>

    <span class="enscript-keyword">if</span> (!object-&gt;symtab) {
        object-&gt;symtab = kxld_alloc(kxld_symtab_sizeof());
        require_action(object-&gt;symtab, finish, rval=KERN_RESOURCE_SHORTAGE);
        bzero(object-&gt;symtab, kxld_symtab_sizeof());
    }

    <span class="enscript-comment">/* Build the relocator */</span>

    rval = kxld_relocator_init(&amp;object-&gt;relocator, object-&gt;file,
        object-&gt;symtab, &amp;object-&gt;sects, object-&gt;cputype, 
        object-&gt;cpusubtype, kxld_object_target_needs_swap(object));
    require_noerr(rval, finish);

    <span class="enscript-comment">/* There are four types of Mach-O files that we can support:
     *   1) 32-bit MH_OBJECT      - Snow Leopard and earlier
     *   2) 32-bit MH_KEXT_BUNDLE - Lion and Later
     *   3) 64-bit MH_OBJECT      - Unsupported
     *   4) 64-bit MH_KEXT_BUNDLE - Snow Leopard and Later
     */</span>

    <span class="enscript-keyword">if</span> (kxld_object_is_32_bit(object)) {
        <span class="enscript-type">struct</span> mach_header *mach_hdr = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) object-&gt;file);
        object-&gt;filetype = mach_hdr-&gt;filetype;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-type">struct</span> mach_header_64 *mach_hdr = (<span class="enscript-type">struct</span> mach_header_64 *) ((<span class="enscript-type">void</span> *) object-&gt;file);
        object-&gt;filetype = mach_hdr-&gt;filetype;
    }

    <span class="enscript-keyword">switch</span> (object-&gt;filetype) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_BUNDLE</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_KEXT_BUNDLE</span>:
        rval = init_from_bundle(object);
        require_noerr(rval, finish);
        <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_BUNDLE */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_OBJECT</span>:
        rval = init_from_object(object);
        require_noerr(rval, finish);
        <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_EXECUTE</span>:
        object-&gt;is_kernel = TRUE;
        rval = init_from_execute(object);
        require_noerr(rval, finish);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        rval = KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr,
            kKxldLogFiletypeNotSupported, object-&gt;filetype);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!kxld_object_is_kernel(object)) {
        <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
            seg = kxld_array_get_item(&amp;object-&gt;segs, i);
            kxld_seg_set_vm_protections(seg, 
                target_supports_protected_segments(object));
        }

        seg = kxld_object_get_seg_by_name(object, SEG_LINKEDIT);
        <span class="enscript-keyword">if</span> (seg) {
            (<span class="enscript-type">void</span>) kxld_seg_populate_linkedit(seg, object-&gt;symtab,
                kxld_object_is_32_bit(object)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
                , &amp;object-&gt;locrelocs, &amp;object-&gt;extrelocs,
                target_supports_slideable_kexts(object)
#<span class="enscript-reference">endif</span>
                );
        }
    }

    (<span class="enscript-type">void</span>) set_is_object_linked(object);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">get_target_machine_info</span>(KXLDObject *object, cpu_type_t cputype __unused, 
    cpu_subtype_t cpusubtype __unused)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>

    <span class="enscript-comment">/* Because the kernel can only link for its own architecture, we know what
     * the host and target architectures are at compile time, so we can use
     * a vastly simplified version of this function.
     */</span> 

    check(object);

#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    object-&gt;cputype = CPU_TYPE_X86_64;
<span class="enscript-comment">/* FIXME: we need clang to provide a __x86_64h__ macro for the sub-type. Using
 * __AVX2__ is a temporary solution until this is available. */</span>
#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__AVX2__</span>)
    object-&gt;cpusubtype = CPU_SUBTYPE_X86_64_H;
#<span class="enscript-reference">else</span>
    object-&gt;cpusubtype = CPU_SUBTYPE_X86_64_ALL;
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
#<span class="enscript-reference">else</span> 
    kxld_log(kKxldLogLinking, kKxldLogErr, 
        kKxldLogArchNotSupported, _mh_execute_header-&gt;cputype);
    <span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* Supported architecture defines */</span>


#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !KERNEL */</span>

    <span class="enscript-comment">/* User-space must look up the architecture it's running on and the target
     * architecture at run-time.
     */</span>

    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">const</span> NXArchInfo *host_arch = NULL;

    check(object);

    host_arch = NXGetLocalArchInfo();
    require_action(host_arch, finish, rval=KERN_FAILURE);

    object-&gt;host_order = host_arch-&gt;byteorder;

    <span class="enscript-comment">/* If the user did not specify a cputype, use the local architecture.
     */</span>

    <span class="enscript-keyword">if</span> (cputype) {
        object-&gt;cputype = cputype;
        object-&gt;cpusubtype = cpusubtype;
    } <span class="enscript-keyword">else</span> {
        object-&gt;cputype = host_arch-&gt;cputype;
        object-&gt;target_order = object-&gt;host_order;

        <span class="enscript-keyword">switch</span> (object-&gt;cputype) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_I386</span>:
            object-&gt;cpusubtype = CPU_SUBTYPE_I386_ALL;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_X86_64</span>:
            object-&gt;cpusubtype = CPU_SUBTYPE_X86_64_ALL;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_ARM</span>:
            object-&gt;cpusubtype = CPU_SUBTYPE_ARM_ALL;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_ARM64</span>:
            object-&gt;cpusubtype = CPU_SUBTYPE_ARM64_ALL;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            object-&gt;cpusubtype = 0;
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-comment">/* Validate that we support the target architecture and record its 
     * endianness.
     */</span>

    <span class="enscript-keyword">switch</span>(object-&gt;cputype) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_ARM</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_ARM64</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_I386</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_TYPE_X86_64</span>:
        object-&gt;target_order = NX_LittleEndian;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        rval = KERN_NOT_SUPPORTED;
        kxld_log(kKxldLogLinking, kKxldLogErr, 
            kKxldLogArchNotSupported, object-&gt;cputype);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">get_macho_slice_for_arch</span>(KXLDObject *object, u_char *file, u_long size)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> mach_header *mach_hdr = NULL;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-type">struct</span> fat_header *fat = (<span class="enscript-type">struct</span> fat_header *) ((<span class="enscript-type">void</span> *) file);
    <span class="enscript-type">struct</span> fat_arch *archs = (<span class="enscript-type">struct</span> fat_arch *) &amp;fat[1];
    boolean_t swap = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    check(object);
    check(file);
    check(size);

    object-&gt;file = file;
    object-&gt;size = size;

    <span class="enscript-comment">/* We are assuming that we will never receive a fat file in the kernel */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    require_action(size &gt;= <span class="enscript-keyword">sizeof</span>(*fat), finish, 
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

    <span class="enscript-comment">/* The fat header is always big endian, so swap if necessary */</span>
    <span class="enscript-keyword">if</span> (fat-&gt;magic == FAT_CIGAM) {
        (<span class="enscript-type">void</span>) swap_fat_header(fat, object-&gt;host_order);
        swap = TRUE;
    }

    <span class="enscript-keyword">if</span> (fat-&gt;magic == FAT_MAGIC) {
        <span class="enscript-type">struct</span> fat_arch *arch = NULL;

        require_action(size &gt;= (<span class="enscript-keyword">sizeof</span>(*fat) + (fat-&gt;nfat_arch * <span class="enscript-keyword">sizeof</span>(*archs))),
            finish, 
            rval=KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

        <span class="enscript-comment">/* Swap the fat_arch structures if necessary */</span>
        <span class="enscript-keyword">if</span> (swap) {
            (<span class="enscript-type">void</span>) swap_fat_arch(archs, fat-&gt;nfat_arch, object-&gt;host_order);
        }

        <span class="enscript-comment">/* Locate the Mach-O for the requested architecture */</span>

        arch = NXFindBestFatArch(object-&gt;cputype, object-&gt;cpusubtype, archs, fat-&gt;nfat_arch);
        require_action(arch, finish, rval=KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogArchNotFound));
        require_action(size &gt;= arch-&gt;offset + arch-&gt;size, finish, 
            rval=KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

        object-&gt;file = file + arch-&gt;offset;
        object-&gt;size = arch-&gt;size;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    <span class="enscript-comment">/* Swap the Mach-O's headers to this architecture if necessary */</span>
    <span class="enscript-keyword">if</span> (kxld_object_is_32_bit(object)) {
        rval = validate_and_swap_macho_32(object-&gt;file, object-&gt;size
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            , object-&gt;host_order
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
            );
    } <span class="enscript-keyword">else</span> {
        rval = validate_and_swap_macho_64(object-&gt;file, object-&gt;size
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            , object-&gt;host_order
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
            );
    }
    require_noerr(rval, finish);

    mach_hdr = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) object-&gt;file);
    require_action(object-&gt;cputype == mach_hdr-&gt;cputype, finish,
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));
    object-&gt;cpusubtype = mach_hdr-&gt;cpusubtype;  <span class="enscript-comment">/* &lt;rdar://problem/16008438&gt; */</span>

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">init_from_final_linked_image</span>(KXLDObject *object, u_int *filetype_out,
    <span class="enscript-type">struct</span> symtab_command **symtab_hdr_out)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSeg *seg = NULL;
    KXLDSect *sect = NULL;
    <span class="enscript-type">struct</span> load_command *cmd_hdr = NULL;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    <span class="enscript-type">struct</span> uuid_command *uuid_hdr = NULL;
    <span class="enscript-type">struct</span> version_min_command *versionmin_hdr = NULL;
    <span class="enscript-type">struct</span> source_version_command *source_version_hdr = NULL;
    u_long base_offset = 0;
    u_long offset = 0;
    u_long sect_offset = 0;
    u_int filetype = 0;
    u_int i = 0;
    u_int j = 0;
    u_int segi = 0;
    u_int secti = 0;
    u_int nsegs = 0;
    u_int nsects = 0;
    u_int ncmds = 0;

    KXLD_3264_FUNC(kxld_object_is_32_bit(object), base_offset,
        get_macho_cmd_data_32, get_macho_cmd_data_64,
        object-&gt;file, offset, &amp;filetype, &amp;ncmds);

    <span class="enscript-comment">/* First pass to count segments and sections */</span>

    offset = base_offset;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ncmds; ++i, offset += cmd_hdr-&gt;cmdsize) {
        cmd_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (object-&gt;file + offset));

        <span class="enscript-keyword">switch</span>(cmd_hdr-&gt;cmd) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT</span>:
            {
                <span class="enscript-type">struct</span> segment_command *seg_hdr = 
                    (<span class="enscript-type">struct</span> segment_command *) cmd_hdr;

                <span class="enscript-comment">/* Ignore segments with no vm size */</span>
                <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

                ++nsegs;
                nsects += seg_hdr-&gt;nsects;
            }
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT_64</span>:
            {
                <span class="enscript-type">struct</span> segment_command_64 *seg_hdr = 
                    (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) cmd_hdr);

                <span class="enscript-comment">/* Ignore segments with no vm size */</span>
                <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

                ++nsegs;
                nsects += seg_hdr-&gt;nsects;
            }
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">continue</span>;
        }
    }

    <span class="enscript-comment">/* Allocate the segments and sections */</span>

    <span class="enscript-keyword">if</span> (nsegs) {
        rval = kxld_array_init(&amp;object-&gt;segs, <span class="enscript-keyword">sizeof</span>(KXLDSeg), nsegs);
        require_noerr(rval, finish);

        rval = kxld_array_init(&amp;object-&gt;sects, <span class="enscript-keyword">sizeof</span>(KXLDSect), nsects);
        require_noerr(rval, finish);
    }

    <span class="enscript-comment">/* Initialize the segments and sections */</span>

    offset = base_offset;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ncmds; ++i, offset += cmd_hdr-&gt;cmdsize) {
        cmd_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (object-&gt;file + offset)); 
        seg = NULL;

        <span class="enscript-keyword">switch</span>(cmd_hdr-&gt;cmd) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT</span>:
            {
                <span class="enscript-type">struct</span> segment_command *seg_hdr =
                    (<span class="enscript-type">struct</span> segment_command *) cmd_hdr;

                <span class="enscript-comment">/* Ignore segments with no vm size */</span>
                <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

                seg = kxld_array_get_item(&amp;object-&gt;segs, segi++);

                rval = kxld_seg_init_from_macho_32(seg, seg_hdr);
                require_noerr(rval, finish);

                sect_offset = offset + <span class="enscript-keyword">sizeof</span>(*seg_hdr);
            }
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT_64</span>:
            {
                <span class="enscript-type">struct</span> segment_command_64 *seg_hdr = 
                    (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) cmd_hdr);

                <span class="enscript-comment">/* Ignore segments with no vm size */</span>
                <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

                seg = kxld_array_get_item(&amp;object-&gt;segs, segi++);

                rval = kxld_seg_init_from_macho_64(seg, seg_hdr);
                require_noerr(rval, finish);

                sect_offset = offset + <span class="enscript-keyword">sizeof</span>(*seg_hdr);
            }
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SYMTAB</span>:
            symtab_hdr = (<span class="enscript-type">struct</span> symtab_command *) cmd_hdr;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_UUID</span>:
            uuid_hdr = (<span class="enscript-type">struct</span> uuid_command *) cmd_hdr;
            kxld_uuid_init_from_macho(&amp;object-&gt;uuid, uuid_hdr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_VERSION_MIN_MACOSX</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_VERSION_MIN_IPHONEOS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_VERSION_MIN_WATCHOS</span>:
            versionmin_hdr = (<span class="enscript-type">struct</span> version_min_command *) cmd_hdr;
            kxld_versionmin_init_from_macho(&amp;object-&gt;versionmin, versionmin_hdr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SOURCE_VERSION</span>:
            source_version_hdr = (<span class="enscript-type">struct</span> source_version_command *) (<span class="enscript-type">void</span> *) cmd_hdr;
            kxld_srcversion_init_from_macho(&amp;object-&gt;srcversion, source_version_hdr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYSYMTAB</span>:
            object-&gt;dysymtab_hdr = (<span class="enscript-type">struct</span> dysymtab_command *) cmd_hdr;            

            rval = kxld_reloc_create_macho(&amp;object-&gt;extrelocs, &amp;object-&gt;relocator,
                (<span class="enscript-type">struct</span> relocation_info *) ((<span class="enscript-type">void</span> *) (object-&gt;file + object-&gt;dysymtab_hdr-&gt;extreloff)), 
                object-&gt;dysymtab_hdr-&gt;nextrel);
            require_noerr(rval, finish);

            rval = kxld_reloc_create_macho(&amp;object-&gt;locrelocs, &amp;object-&gt;relocator,
                (<span class="enscript-type">struct</span> relocation_info *) ((<span class="enscript-type">void</span> *) (object-&gt;file + object-&gt;dysymtab_hdr-&gt;locreloff)), 
                object-&gt;dysymtab_hdr-&gt;nlocrel);
            require_noerr(rval, finish);

            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_UNIXTHREAD</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_MAIN</span>:
            <span class="enscript-comment">/* Don't need to do anything with UNIXTHREAD or MAIN for the kernel */</span>
            require_action(kxld_object_is_kernel(object), 
                finish, rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                    <span class="enscript-string">&quot;LC_UNIXTHREAD/LC_MAIN segment is not valid in a kext.&quot;</span>));
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT_SPLIT_INFO</span>:
            <span class="enscript-comment">/* To be implemented later; treat as uninteresting for now */</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_CODE_SIGNATURE</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYLD_INFO</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYLD_INFO_ONLY</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_FUNCTION_STARTS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DATA_IN_CODE</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYLIB_CODE_SIGN_DRS</span>:
            <span class="enscript-comment">/* Various metadata that might be stored in the linkedit segment */</span>
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            rval=KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                <span class="enscript-string">&quot;Invalid load command type in MH_KEXT_BUNDLE kext: %u.&quot;</span>, cmd_hdr-&gt;cmd);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">if</span> (seg) {

            <span class="enscript-comment">/* Initialize the sections */</span>
            <span class="enscript-keyword">for</span> (j = 0; j &lt; seg-&gt;sects.nitems; ++j, ++secti) {
                sect = kxld_array_get_item(&amp;object-&gt;sects, secti);
                KXLD_3264_FUNC(kxld_object_is_32_bit(object), rval,
                    kxld_sect_init_from_macho_32, kxld_sect_init_from_macho_64,
                    sect, object-&gt;file, &amp;sect_offset, secti, &amp;object-&gt;relocator);
                require_noerr(rval, finish);

                <span class="enscript-comment">/* Add the section to the segment.  This will also make sure
                 * that the sections and segments have the same segname.
                 */</span>
                rval = kxld_seg_add_section(seg, sect);
                require_noerr(rval, finish);
            }
            rval = kxld_seg_finish_init(seg);
            require_noerr(rval, finish);
        }
    }

    <span class="enscript-keyword">if</span> (filetype_out) *filetype_out = filetype;
    <span class="enscript-keyword">if</span> (symtab_hdr_out) *symtab_hdr_out = symtab_hdr;
    object-&gt;is_final_image = TRUE;
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">init_from_execute</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    u_int filetype = 0;
    KXLDSeg * kernel_linkedit_seg = NULL;  <span class="enscript-comment">// used if running kernel
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
    KXLDSeg *seg = NULL;
    KXLDSect *sect = NULL;
    KXLDSectionName *sname = NULL;
    u_int i = 0, j = 0, k = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

    check(object);

    require_action(kxld_object_is_kernel(object), finish, rval=KERN_FAILURE);

    rval = init_from_final_linked_image(object, &amp;filetype, &amp;symtab_hdr);
    require_noerr(rval, finish);

    require_action(filetype == MH_EXECUTE, finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO 
            <span class="enscript-string">&quot;The kernel file is not of type MH_EXECUTE.&quot;</span>));

   <span class="enscript-comment">/* Initialize the symbol table. If this is the running kernel
    * we  will work from the in-memory linkedit segment;
    * otherwise we work from the whole mach-o image.
    */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    kernel_linkedit_seg = kxld_object_get_seg_by_name(object, SEG_LINKEDIT);
    require_action(kernel_linkedit_seg, finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO));
#<span class="enscript-reference">endif</span>

    KXLD_3264_FUNC(kxld_object_is_32_bit(object), rval,
        kxld_symtab_init_from_macho_32, kxld_symtab_init_from_macho_64,
        object-&gt;symtab, symtab_hdr, object-&gt;file, kernel_linkedit_seg);
    require_noerr(rval, finish);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
    <span class="enscript-comment">/* Save off the order of section names so that we can lay out kext 
     * sections for MH_OBJECT-based systems.
     */</span>
    <span class="enscript-keyword">if</span> (target_supports_object(object)) {

        rval = kxld_array_init(object-&gt;section_order, <span class="enscript-keyword">sizeof</span>(KXLDSectionName), 
            object-&gt;sects.nitems);
        require_noerr(rval, finish);

        <span class="enscript-comment">/* Copy the section names into the section_order array for future kext
         * section ordering.
         */</span>
        <span class="enscript-keyword">for</span> (i = 0, k = 0; i &lt; object-&gt;segs.nitems; ++i) {
            seg = kxld_array_get_item(&amp;object-&gt;segs, i);

            <span class="enscript-keyword">for</span> (j = 0; j &lt; seg-&gt;sects.nitems; ++j, ++k) {
                sect = *(KXLDSect **) kxld_array_get_item(&amp;seg-&gt;sects, j);
                sname = kxld_array_get_item(object-&gt;section_order, k);

                strlcpy(sname-&gt;segname, sect-&gt;segname, <span class="enscript-keyword">sizeof</span>(sname-&gt;segname));
                strlcpy(sname-&gt;sectname, sect-&gt;sectname, <span class="enscript-keyword">sizeof</span>(sname-&gt;sectname));
            }
        }
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_BUNDLE</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">target_supports_bundle</span>(<span class="enscript-type">const</span> KXLDObject *object __unused)
{
    <span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t 
<span class="enscript-function-name">init_from_bundle</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    u_int filetype = 0;

    check(object);

    require_action(target_supports_bundle(object), finish,
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr,
            kKxldLogFiletypeNotSupported, MH_KEXT_BUNDLE));

    rval = init_from_final_linked_image(object, &amp;filetype, &amp;symtab_hdr);
    require_noerr(rval, finish);

    require_action(filetype == MH_KEXT_BUNDLE, finish, 
        rval=KERN_FAILURE);

    KXLD_3264_FUNC(kxld_object_is_32_bit(object), rval,
        kxld_symtab_init_from_macho_32, kxld_symtab_init_from_macho_64,
        object-&gt;symtab, symtab_hdr, object-&gt;file,
        <span class="enscript-comment">/* kernel_linkedit_seg */</span> NULL);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_BUNDLE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">target_supports_object</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    <span class="enscript-keyword">return</span> (object-&gt;cputype == CPU_TYPE_I386);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t 
<span class="enscript-function-name">init_from_object</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> load_command *cmd_hdr = NULL;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    <span class="enscript-type">struct</span> uuid_command *uuid_hdr = NULL;
    KXLDSect *sect = NULL;
    u_long offset = 0;
    u_long sect_offset = 0;
    u_int filetype = 0;
    u_int ncmds = 0;
    u_int nsects = 0;
    u_int i = 0;
    boolean_t has_segment = FALSE;

    check(object);

    require_action(target_supports_object(object),
        finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr,
            kKxldLogFiletypeNotSupported, MH_OBJECT));

    KXLD_3264_FUNC(kxld_object_is_32_bit(object), offset,
        get_macho_cmd_data_32, get_macho_cmd_data_64,
        object-&gt;file, offset, &amp;filetype, &amp;ncmds);

    require_action(filetype == MH_OBJECT, finish, rval=KERN_FAILURE);

    <span class="enscript-comment">/* MH_OBJECTs use one unnamed segment to contain all of the sections.  We
     * loop over all of the load commands to initialize the structures we
     * expect.  Then, we'll use the unnamed segment to get to all of the
     * sections, and then use those sections to create the actual segments.
     */</span>

    <span class="enscript-keyword">for</span> (; i &lt; ncmds; ++i, offset += cmd_hdr-&gt;cmdsize) {
        cmd_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (object-&gt;file + offset));

        <span class="enscript-keyword">switch</span>(cmd_hdr-&gt;cmd) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT</span>:
            {
                <span class="enscript-type">struct</span> segment_command *seg_hdr = 
                    (<span class="enscript-type">struct</span> segment_command *) cmd_hdr;

                <span class="enscript-comment">/* Ignore segments with no vm size */</span>
                <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">/* Ignore LINKEDIT segments */</span>
                <span class="enscript-keyword">if</span> (streq_safe(seg_hdr-&gt;segname, SEG_LINKEDIT, 
                        const_strlen(SEG_LINKEDIT))) 
                {
                    <span class="enscript-keyword">continue</span>;
                }

                require_action(kxld_object_is_32_bit(object), finish, rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                        <span class="enscript-string">&quot;LC_SEGMENT in 64-bit kext.&quot;</span>));
                require_action(!has_segment, finish, rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                        <span class="enscript-string">&quot;Multiple segments in an MH_OBJECT kext.&quot;</span>));

                nsects = seg_hdr-&gt;nsects;
                sect_offset = offset + <span class="enscript-keyword">sizeof</span>(*seg_hdr);
                has_segment = TRUE;
            }
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT_64</span>:
            {
                <span class="enscript-type">struct</span> segment_command_64 *seg_hdr =
                    (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) cmd_hdr);

                <span class="enscript-comment">/* Ignore segments with no vm size */</span>
                <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">/* Ignore LINKEDIT segments */</span>
                <span class="enscript-keyword">if</span> (streq_safe(seg_hdr-&gt;segname, SEG_LINKEDIT, 
                        const_strlen(SEG_LINKEDIT))) 
                {
                    <span class="enscript-keyword">continue</span>;
                }

                require_action(!kxld_object_is_32_bit(object), finish, rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                        <span class="enscript-string">&quot;LC_SEGMENT_64 in a 32-bit kext.&quot;</span>));
                require_action(!has_segment, finish, rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                        <span class="enscript-string">&quot;Multiple segments in an MH_OBJECT kext.&quot;</span>));

                nsects = seg_hdr-&gt;nsects;
                sect_offset = offset + <span class="enscript-keyword">sizeof</span>(*seg_hdr);
                has_segment = TRUE;
            }
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SYMTAB</span>:
            symtab_hdr = (<span class="enscript-type">struct</span> symtab_command *) cmd_hdr;

            KXLD_3264_FUNC(kxld_object_is_32_bit(object), rval,
                kxld_symtab_init_from_macho_32, kxld_symtab_init_from_macho_64,
                object-&gt;symtab, symtab_hdr, object-&gt;file,
                <span class="enscript-comment">/* kernel_linkedit_seg */</span> NULL);
            require_noerr(rval, finish);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_UUID</span>:
            uuid_hdr = (<span class="enscript-type">struct</span> uuid_command *) cmd_hdr;
            kxld_uuid_init_from_macho(&amp;object-&gt;uuid, uuid_hdr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_UNIXTHREAD</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_MAIN</span>:
            <span class="enscript-comment">/* Don't need to do anything with UNIXTHREAD or MAIN */</span>
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_CODE_SIGNATURE</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYLD_INFO</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYLD_INFO_ONLY</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_FUNCTION_STARTS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DATA_IN_CODE</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_DYLIB_CODE_SIGN_DRS</span>:
            <span class="enscript-comment">/* Various metadata that might be stored in the linkedit segment */</span>
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_VERSION_MIN_MACOSX</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_VERSION_MIN_IPHONEOS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_VERSION_MIN_WATCHOS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SOURCE_VERSION</span>:
            <span class="enscript-comment">/* Not supported for object files, fall through */</span>
        <span class="enscript-reference">default</span>:
            rval = KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
                <span class="enscript-string">&quot;Invalid load command type in MH_OBJECT kext: %u.&quot;</span>, cmd_hdr-&gt;cmd);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    <span class="enscript-keyword">if</span> (has_segment) {

        <span class="enscript-comment">/* Get the number of sections from the segment and build the section index */</span>

        rval = kxld_array_init(&amp;object-&gt;sects, <span class="enscript-keyword">sizeof</span>(KXLDSect), nsects);
        require_noerr(rval, finish);

        <span class="enscript-comment">/* Loop over all of the sections to initialize the section index */</span>

        <span class="enscript-keyword">for</span> (i = 0; i &lt; nsects; ++i) {
            sect = kxld_array_get_item(&amp;object-&gt;sects, i);
            KXLD_3264_FUNC(kxld_object_is_32_bit(object), rval,
                kxld_sect_init_from_macho_32, kxld_sect_init_from_macho_64,
                sect, object-&gt;file, &amp;sect_offset, i, &amp;object-&gt;relocator); 
            require_noerr(rval, finish);
        }

        <span class="enscript-comment">/* Create special sections */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_GOT</span>
        rval = create_got(object);
        require_noerr(rval, finish);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_GOT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_COMMON</span>
        rval = resolve_common_symbols(object);
        require_noerr(rval, finish);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_COMMON */</span>

        <span class="enscript-comment">/* Create the segments from the section index */</span>

        rval = kxld_seg_create_seg_from_sections(&amp;object-&gt;segs, &amp;object-&gt;sects);
        require_noerr(rval, finish);

        rval = kxld_seg_finalize_object_segment(&amp;object-&gt;segs, 
            object-&gt;section_order, get_macho_header_size(object));
        require_noerr(rval, finish);

        rval = kxld_seg_init_linkedit(&amp;object-&gt;segs);
        require_noerr(rval, finish);
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> u_long
<span class="enscript-function-name">get_macho_cmd_data_32</span>(u_char *file, u_long offset, u_int *filetype, u_int *ncmds)
{
    <span class="enscript-type">struct</span> mach_header *mach_hdr = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) (file + offset));

    <span class="enscript-keyword">if</span> (filetype) *filetype = mach_hdr-&gt;filetype;
    <span class="enscript-keyword">if</span> (ncmds) *ncmds = mach_hdr-&gt;ncmds;

    <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(*mach_hdr);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> u_long
<span class="enscript-function-name">get_macho_cmd_data_64</span>(u_char *file, u_long offset, u_int *filetype,  u_int *ncmds)
{
    <span class="enscript-type">struct</span> mach_header_64 *mach_hdr = (<span class="enscript-type">struct</span> mach_header_64 *) ((<span class="enscript-type">void</span> *) (file + offset));

    <span class="enscript-keyword">if</span> (filetype) *filetype = mach_hdr-&gt;filetype;
    <span class="enscript-keyword">if</span> (ncmds) *ncmds = mach_hdr-&gt;ncmds;

    <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(*mach_hdr);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> u_long
<span class="enscript-function-name">get_macho_header_size</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    KXLDSeg *seg = NULL;
    u_long header_size = 0;
    u_int i = 0;
    boolean_t   object_is_32_bit = kxld_object_is_32_bit(object);

    check(object);

    <span class="enscript-comment">/* Mach, segment, symtab, and UUID headers */</span>

    header_size += object_is_32_bit ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mach_header) : <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mach_header_64);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);
        header_size += kxld_seg_get_macho_header_size(seg, object_is_32_bit);
    }

    header_size += kxld_symtab_get_macho_header_size();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    <span class="enscript-keyword">if</span> (target_supports_slideable_kexts(object)) {
        header_size += kxld_reloc_get_macho_header_size();
    }
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>

    <span class="enscript-keyword">if</span> (object-&gt;uuid.has_uuid) {
        header_size += kxld_uuid_get_macho_header_size();
    }

    <span class="enscript-keyword">if</span> (object-&gt;versionmin.has_versionmin) {
        header_size += kxld_versionmin_get_macho_header_size();
    }

    <span class="enscript-keyword">if</span> (object-&gt;srcversion.has_srcversion) {
        header_size += kxld_srcversion_get_macho_header_size();
    }
    
    <span class="enscript-keyword">return</span> header_size;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> u_long
<span class="enscript-function-name">get_macho_data_size</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    KXLDSeg *seg = NULL;
    u_long data_size = 0;
    u_int i = 0;

    check(object);

    <span class="enscript-comment">/* total all segment vmsize values */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);
        data_size += (u_long) kxld_seg_get_vmsize(seg);
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    {
        <span class="enscript-comment">/* ensure that when we eventually emit the final linked object, 
         * appending the __DYSYMTAB data after the __LINKEDIT data will
         * not overflow the space allocated for the __LINKEDIT segment
         */</span>
        
        u_long  seg_vmsize = 0;
        u_long  symtab_size = 0;
        u_long  reloc_size = 0;
        
        <span class="enscript-comment">/* get current __LINKEDIT sizes */</span>
        seg = kxld_object_get_seg_by_name(object, SEG_LINKEDIT);
        seg_vmsize = (u_long) kxld_seg_get_vmsize(seg);
        
        <span class="enscript-comment">/* get size of symbol table data that will eventually be dumped
         * into the __LINKEDIT segment
         */</span>
        symtab_size = kxld_symtab_get_macho_data_size(object-&gt;symtab, kxld_object_is_32_bit(object));
        
        <span class="enscript-keyword">if</span> (target_supports_slideable_kexts(object)) {
            <span class="enscript-comment">/* get size of __DYSYMTAB relocation entries */</span>
            reloc_size = kxld_reloc_get_macho_data_size(&amp;object-&gt;locrelocs, &amp;object-&gt;extrelocs);
        }
        
        <span class="enscript-comment">/* combine, and ensure they'll both fit within the page(s)
         * allocated for the __LINKEDIT segment. If they'd overflow,
         * increase the vmsize appropriately so no overflow will occur
         */</span>
        <span class="enscript-keyword">if</span> ((symtab_size + reloc_size) &gt; seg_vmsize) {
            u_long  overflow = (symtab_size + reloc_size) - seg_vmsize;
            data_size += kxld_round_page_cross_safe(overflow);
        }
    }
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>

    <span class="enscript-keyword">return</span> data_size;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t 
<span class="enscript-function-name">kxld_object_target_needs_swap</span>(<span class="enscript-type">const</span> KXLDObject *object __unused)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">return</span> FALSE;
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> (object-&gt;target_order != object-&gt;host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
KXLDSeg *
<span class="enscript-function-name">kxld_object_get_seg_by_name</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname)
{
    KXLDSeg *seg = NULL;
    u_int i = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);

        <span class="enscript-keyword">if</span> (streq_safe(segname, seg-&gt;segname, <span class="enscript-keyword">sizeof</span>(seg-&gt;segname))) <span class="enscript-keyword">break</span>;

        seg = NULL;
    }

    <span class="enscript-keyword">return</span> seg;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> KXLDRelocator * 
<span class="enscript-function-name">kxld_object_get_relocator</span>(<span class="enscript-type">const</span> KXLDObject * object)
{
    check(object);

    <span class="enscript-keyword">return</span> &amp;object-&gt;relocator;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
KXLDSect *
<span class="enscript-function-name">kxld_object_get_sect_by_name</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname, 
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sectname)
{
    KXLDSect *sect = NULL;
    u_int i = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.nitems; ++i) {
        sect = kxld_array_get_item(&amp;object-&gt;sects, i);

        <span class="enscript-keyword">if</span> (streq_safe(segname, sect-&gt;segname, <span class="enscript-keyword">sizeof</span>(sect-&gt;segname)) &amp;&amp; 
            streq_safe(sectname, sect-&gt;sectname, <span class="enscript-keyword">sizeof</span>(sect-&gt;sectname))) 
        {
            <span class="enscript-keyword">break</span>;
        }

        sect = NULL;
    }

    <span class="enscript-keyword">return</span> sect;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> KXLDReloc * 
<span class="enscript-function-name">kxld_object_get_reloc_at_symbol</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> KXLDSym *sym)
{
    <span class="enscript-type">const</span> KXLDReloc *reloc = NULL;
    <span class="enscript-type">const</span> KXLDSect *sect = NULL;
    uint32_t offset = 0;

    check(object);
    check(sym);

    sect = kxld_object_get_section_by_index(object, sym-&gt;sectnum);
    require(sect, finish);

    <span class="enscript-keyword">if</span> (kxld_object_is_final_image(object)) {
        reloc = kxld_reloc_get_reloc_by_offset(&amp;object-&gt;extrelocs, 
            sym-&gt;base_addr);
        <span class="enscript-keyword">if</span> (!reloc) {
            reloc = kxld_reloc_get_reloc_by_offset(&amp;object-&gt;locrelocs, 
                sym-&gt;base_addr);
        }
    } <span class="enscript-keyword">else</span> {
        offset = kxld_sym_get_section_offset(sym, sect);
        reloc = kxld_reloc_get_reloc_by_offset(&amp;sect-&gt;relocs, offset);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> reloc;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> KXLDSym * 
<span class="enscript-function-name">kxld_object_get_symbol_of_reloc</span>(<span class="enscript-type">const</span> KXLDObject *object, 
    <span class="enscript-type">const</span> KXLDReloc *reloc, <span class="enscript-type">const</span> KXLDSect *sect)
{
    <span class="enscript-type">const</span> KXLDSym *sym = NULL;

    <span class="enscript-keyword">if</span> (kxld_object_is_final_image(object)) {
        sym = kxld_reloc_get_symbol(&amp;object-&gt;relocator, reloc, object-&gt;file);
    } <span class="enscript-keyword">else</span> {
        sym = kxld_reloc_get_symbol(&amp;object-&gt;relocator, reloc, sect-&gt;data);
    }

    <span class="enscript-keyword">return</span> sym;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> KXLDSect * 
<span class="enscript-function-name">kxld_object_get_section_by_index</span>(<span class="enscript-type">const</span> KXLDObject *object, u_int sectnum)
{
    KXLDSect *sect = NULL;
    
    check(object);

    <span class="enscript-keyword">if</span> (sectnum &lt; object-&gt;sects.nitems) {
        sect = kxld_array_get_item(&amp;object-&gt;sects, sectnum);
    }

    <span class="enscript-keyword">return</span> sect;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> KXLDArray  * 
<span class="enscript-function-name">kxld_object_get_extrelocs</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    <span class="enscript-type">const</span> KXLDArray *rval = NULL;
    
    check(object);

    <span class="enscript-keyword">if</span> (kxld_object_is_final_image(object)) {
        rval = &amp;object-&gt;extrelocs;
    }

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> KXLDSymtab *
<span class="enscript-function-name">kxld_object_get_symtab</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> object-&gt;symtab;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_GOT</span> || <span class="enscript-variable-name">KXLD_USER_OR_COMMON</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">add_section</span>(KXLDObject *object, KXLDSect **sect)
{
    kern_return_t rval = KERN_FAILURE;
    u_int nsects = object-&gt;sects.nitems;

    rval = kxld_array_resize(&amp;object-&gt;sects, nsects + 1);
    require_noerr(rval, finish);

    *sect = kxld_array_get_item(&amp;object-&gt;sects, nsects);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_GOT || KXLD_USER_OR_COMMON */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_COMMON</span>
<span class="enscript-comment">/*******************************************************************************
* If there are common symbols, calculate how much space they'll need
* and create/grow the __DATA __common section to accommodate them.
* Then, resolve them against that section.
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">resolve_common_symbols</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSymtabIterator iter;
    KXLDSym *sym = NULL;
    KXLDSect *sect = NULL;
    kxld_addr_t base_addr = 0;
    kxld_size_t size = 0;
    kxld_size_t total_size = 0;
    u_int align = 0;
    u_int max_align = 0;
    u_int sectnum = 0;

    <span class="enscript-keyword">if</span> (!kxld_object_target_supports_common_symbols(object)) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Iterate over the common symbols to calculate their total aligned size */</span>
    kxld_symtab_iterator_init(&amp;iter, object-&gt;symtab, kxld_sym_is_common, FALSE);
    <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {
        align = kxld_sym_get_common_align(sym);
        size = kxld_sym_get_common_size(sym);

        <span class="enscript-keyword">if</span> (align &gt; max_align) max_align = align;

        total_size = kxld_align_address(total_size, align) + size;
    }

    <span class="enscript-comment">/* If there are common symbols, grow or create the __DATA __common section
     * to hold them.
     */</span>
    <span class="enscript-keyword">if</span> (total_size) {
        sect = kxld_object_get_sect_by_name(object, SEG_DATA, SECT_COMMON);
        <span class="enscript-keyword">if</span> (sect) {
            base_addr = sect-&gt;base_addr + sect-&gt;size;

            kxld_sect_grow(sect, total_size, max_align);
        } <span class="enscript-keyword">else</span> {
            base_addr = 0;

            rval = add_section(object, &amp;sect);
            require_noerr(rval, finish);

            kxld_sect_init_zerofill(sect, SEG_DATA, SECT_COMMON, 
                total_size, max_align);
        }

        <span class="enscript-comment">/* Resolve the common symbols against the new section */</span>
        rval = kxld_array_get_index(&amp;object-&gt;sects, sect, &amp;sectnum);
        require_noerr(rval, finish);

        kxld_symtab_iterator_reset(&amp;iter);
        <span class="enscript-keyword">while</span> ((sym = kxld_symtab_iterator_get_next(&amp;iter))) {
            align = kxld_sym_get_common_align(sym);
            size = kxld_sym_get_common_size(sym);

            base_addr = kxld_align_address(base_addr, align);
            kxld_sym_resolve_common(sym, sectnum, base_addr);

            base_addr += size;
        }
    }

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_COMMON */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_GOT</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">target_has_got</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    <span class="enscript-keyword">return</span> FALSE:
}

<span class="enscript-comment">/*******************************************************************************
* Create and initialize the Global Offset Table
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">create_got</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    u_int ngots = 0;
    u_int i = 0;

    <span class="enscript-keyword">if</span> (!target_has_got(object)) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.nitems; ++i) {
        sect = kxld_array_get_item(&amp;object-&gt;sects, i);
        ngots += kxld_sect_get_ngots(sect, &amp;object-&gt;relocator, 
            object-&gt;symtab);
    }

    rval = add_section(object, &amp;sect);
    require_noerr(rval, finish);

    rval = kxld_sect_init_got(sect, ngots);
    require_noerr(rval, finish);

    object-&gt;got_is_created = TRUE;
    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">populate_got</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    u_int i = 0;

    <span class="enscript-keyword">if</span> (!target_has_got(object) || !object-&gt;got_is_created) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.nitems; ++i) {
        sect = kxld_array_get_item(&amp;object-&gt;sects, i);
        <span class="enscript-keyword">if</span> (streq_safe(sect-&gt;segname, KXLD_SEG_GOT, <span class="enscript-keyword">sizeof</span>(KXLD_SEG_GOT)) &amp;&amp;
            streq_safe(sect-&gt;sectname, KXLD_SECT_GOT, <span class="enscript-keyword">sizeof</span>(KXLD_SECT_GOT)))
        {
            kxld_sect_populate_got(sect, object-&gt;symtab,
                kxld_object_target_needs_swap(object));
            <span class="enscript-keyword">break</span>;
        }
    }

    require_action(i &lt; object-&gt;sects.nitems, finish, rval=KXLD_MISSING_GOT);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_GOT */</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">target_supports_protected_segments</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    <span class="enscript-keyword">return</span> (object-&gt;is_final_image &amp;&amp; 
            (object-&gt;cputype == CPU_TYPE_X86_64 ||
             object-&gt;cputype == CPU_TYPE_ARM ||
             object-&gt;cputype == CPU_TYPE_ARM64));
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">set_is_object_linked</span>(KXLDObject *object)
{
    u_int i = 0;

    <span class="enscript-keyword">if</span> (kxld_object_is_kernel(object)) {
        object-&gt;is_linked = TRUE;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (object-&gt;is_final_image) {
        object-&gt;is_linked = !object-&gt;extrelocs.nitems;
        <span class="enscript-keyword">return</span>;
    }

    object-&gt;is_linked = TRUE;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.nitems; ++i) {
        KXLDSect *sect = kxld_array_get_item(&amp;object-&gt;sects, i);
        <span class="enscript-keyword">if</span> (sect-&gt;relocs.nitems) {
            object-&gt;is_linked = FALSE;
            <span class="enscript-keyword">break</span>;
        }
    }
}


<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">kxld_object_clear</span>(KXLDObject *object __unused)
{
    KXLDSeg *seg = NULL;
    KXLDSect *sect = NULL;
    u_int i;

    check(object);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (kxld_object_is_kernel(object)) {
        unswap_macho(object-&gt;file, object-&gt;host_order, object-&gt;target_order);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);
        kxld_seg_clear(seg);
    }
    kxld_array_reset(&amp;object-&gt;segs);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.nitems; ++i) {
        sect = kxld_array_get_item(&amp;object-&gt;sects, i);
        kxld_sect_clear(sect);
    }
    kxld_array_reset(&amp;object-&gt;sects);

    kxld_array_reset(&amp;object-&gt;extrelocs);
    kxld_array_reset(&amp;object-&gt;locrelocs);
    kxld_relocator_clear(&amp;object-&gt;relocator);
    kxld_uuid_clear(&amp;object-&gt;uuid);
    kxld_versionmin_clear(&amp;object-&gt;versionmin);
    kxld_srcversion_clear(&amp;object-&gt;srcversion);

    <span class="enscript-keyword">if</span> (object-&gt;symtab) kxld_symtab_clear(object-&gt;symtab);

    object-&gt;file = NULL;
    object-&gt;size = 0;
    object-&gt;filetype = 0;
    object-&gt;cputype = 0;
    object-&gt;cpusubtype = 0;
    object-&gt;is_kernel = FALSE;
    object-&gt;is_final_image = FALSE;
    object-&gt;is_linked = FALSE;
    object-&gt;got_is_created = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
    object-&gt;section_order = NULL;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    object-&gt;host_order = 0;
    object-&gt;target_order = 0;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">kxld_object_deinit</span>(KXLDObject *object __unused)
{
    KXLDSeg *seg = NULL;
    KXLDSect *sect = NULL;
    u_int i;

    check(object);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (object-&gt;file &amp;&amp; kxld_object_is_kernel(object)) {
        unswap_macho(object-&gt;file, object-&gt;host_order, object-&gt;target_order);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.maxitems; ++i) {
        seg = kxld_array_get_slot(&amp;object-&gt;segs, i);
        kxld_seg_deinit(seg);
    }
    kxld_array_deinit(&amp;object-&gt;segs);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.maxitems; ++i) {
        sect = kxld_array_get_slot(&amp;object-&gt;sects, i);
        kxld_sect_deinit(sect);
    }
    kxld_array_deinit(&amp;object-&gt;sects);

    kxld_array_deinit(&amp;object-&gt;extrelocs);
    kxld_array_deinit(&amp;object-&gt;locrelocs);

    <span class="enscript-keyword">if</span> (object-&gt;symtab) {
        kxld_symtab_deinit(object-&gt;symtab);
        kxld_free(object-&gt;symtab, kxld_symtab_sizeof());
    }

    bzero(object, <span class="enscript-keyword">sizeof</span>(*object));
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> u_char *
<span class="enscript-function-name">kxld_object_get_file</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> object-&gt;file;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">kxld_object_get_name</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> object-&gt;name;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t 
<span class="enscript-function-name">kxld_object_is_32_bit</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> kxld_is_32_bit(object-&gt;cputype);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t 
<span class="enscript-function-name">kxld_object_is_final_image</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> object-&gt;is_final_image;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t 
<span class="enscript-function-name">kxld_object_is_kernel</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> object-&gt;is_kernel;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t 
<span class="enscript-function-name">kxld_object_is_linked</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> object-&gt;is_linked;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t
<span class="enscript-function-name">kxld_object_target_supports_strict_patching</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> (object-&gt;cputype != CPU_TYPE_I386);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t
<span class="enscript-function-name">kxld_object_target_supports_common_symbols</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> (object-&gt;cputype == CPU_TYPE_I386);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_object_get_vmsize</span>(<span class="enscript-type">const</span> KXLDObject *object, u_long *header_size, 
    u_long *vmsize)
{
    check(object);
    check(header_size);
    check(vmsize);
    *header_size = 0;
    *vmsize = 0;

    <span class="enscript-comment">/* vmsize is the padded header page(s) + segment vmsizes */</span>

    *header_size = (object-&gt;is_final_image) ?
        0 : (u_long)kxld_round_page_cross_safe(get_macho_header_size(object));
    *vmsize = *header_size + get_macho_data_size(object);

}

<span class="enscript-comment">/*******************************************************************************
 *******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_object_set_linked_object_size</span>(KXLDObject *object, u_long vmsize)
{
    object-&gt;output_buffer_size = vmsize;	<span class="enscript-comment">/* cache this for use later */</span>
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_export_linked_object</span>(<span class="enscript-type">const</span> KXLDObject *object, 
    u_char *linked_object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSeg *seg = NULL;
    u_long size = 0;
    u_long header_size = 0;
    u_long header_offset = 0;
    u_long data_offset = 0;
    u_int ncmds = 0;
    u_int i = 0;
    boolean_t   is_32bit_object = kxld_object_is_32_bit(object);

    check(object);
    check(linked_object);

    <span class="enscript-comment">/* Calculate the size of the headers and data */</span>

    header_size = get_macho_header_size(object);
    size = object-&gt;output_buffer_size;

    <span class="enscript-comment">/* Copy data to the file */</span>

    ncmds = object-&gt;segs.nitems + 1 <span class="enscript-comment">/* LC_SYMTAB */</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    <span class="enscript-comment">/* don't write out a DYSYMTAB segment for targets that can't digest it
     */</span>
    <span class="enscript-keyword">if</span> (target_supports_slideable_kexts(object)) {
        ncmds++; <span class="enscript-comment">/* dysymtab */</span>
    }
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>

    <span class="enscript-keyword">if</span> (object-&gt;uuid.has_uuid == TRUE) {
        ncmds++;
    }

    <span class="enscript-keyword">if</span> (object-&gt;versionmin.has_versionmin == TRUE) {
        ncmds++;
    }

    <span class="enscript-keyword">if</span> (object-&gt;srcversion.has_srcversion == TRUE) {
        ncmds++;
    }
    
    rval = export_macho_header(object, linked_object, ncmds, &amp;header_offset, header_size);
    require_noerr(rval, finish);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);

        rval = kxld_seg_export_macho_to_vm(seg, linked_object, &amp;header_offset,
            header_size, size, object-&gt;link_addr, is_32bit_object);
        require_noerr(rval, finish);
    }

    seg = kxld_object_get_seg_by_name(object, SEG_LINKEDIT);
    data_offset = (u_long) (seg-&gt;link_addr - object-&gt;link_addr);
    
    rval = kxld_symtab_export_macho(object-&gt;symtab, linked_object, &amp;header_offset,
        header_size, &amp;data_offset, size, is_32bit_object);
    require_noerr(rval, finish);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
    <span class="enscript-keyword">if</span> (target_supports_slideable_kexts(object)) {
        rval = kxld_reloc_export_macho(&amp;object-&gt;relocator, &amp;object-&gt;locrelocs,
            &amp;object-&gt;extrelocs, linked_object, &amp;header_offset, header_size,
            &amp;data_offset, size);
        require_noerr(rval, finish);
    }
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>

    <span class="enscript-keyword">if</span> (object-&gt;uuid.has_uuid) {
        rval = kxld_uuid_export_macho(&amp;object-&gt;uuid, linked_object, &amp;header_offset, header_size);
        require_noerr(rval, finish);
    }

    <span class="enscript-keyword">if</span> (object-&gt;versionmin.has_versionmin) {
        rval = kxld_versionmin_export_macho(&amp;object-&gt;versionmin, linked_object, &amp;header_offset, header_size);
        require_noerr(rval, finish);
    }

    <span class="enscript-keyword">if</span> (object-&gt;srcversion.has_srcversion) {
        rval = kxld_srcversion_export_macho(&amp;object-&gt;srcversion, linked_object, &amp;header_offset, header_size);
        require_noerr(rval, finish);
    }
    
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    unswap_macho(linked_object, object-&gt;host_order, object-&gt;target_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">export_macho_header</span>(<span class="enscript-type">const</span> KXLDObject *object, u_char *buf, u_int ncmds,
    u_long *header_offset, u_long header_size)
{
    kern_return_t rval = KERN_FAILURE;

    check(object);
    check(buf);
    check(header_offset);

    KXLD_3264_FUNC(kxld_object_is_32_bit(object), rval, 
        export_macho_header_32, export_macho_header_64, 
        object, buf, ncmds, header_offset, header_size);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_ILP32</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">export_macho_header_32</span>(<span class="enscript-type">const</span> KXLDObject *object, u_char *buf, u_int ncmds,
    u_long *header_offset, u_long header_size)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> mach_header *mach = NULL;

    check(object);
    check(buf);
    check(header_offset);

    require_action(<span class="enscript-keyword">sizeof</span>(*mach) &lt;= header_size - *header_offset, finish,
        rval=KERN_FAILURE);
    mach = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) (buf + *header_offset));

    mach-&gt;magic = MH_MAGIC;
    mach-&gt;cputype = object-&gt;cputype;
    mach-&gt;cpusubtype = object-&gt;cpusubtype;
    mach-&gt;filetype = object-&gt;filetype;
    mach-&gt;ncmds = ncmds;
    mach-&gt;sizeofcmds = (uint32_t) (header_size - <span class="enscript-keyword">sizeof</span>(*mach));
    mach-&gt;flags = MH_NOUNDEFS;

    *header_offset += <span class="enscript-keyword">sizeof</span>(*mach);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_ILP32 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_LP64</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">export_macho_header_64</span>(<span class="enscript-type">const</span> KXLDObject *object, u_char *buf, u_int ncmds,
    u_long *header_offset, u_long header_size)
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> mach_header_64 *mach = NULL;

    check(object);
    check(buf);
    check(header_offset);
    
    require_action(<span class="enscript-keyword">sizeof</span>(*mach) &lt;= header_size - *header_offset, finish,
        rval=KERN_FAILURE);
    mach = (<span class="enscript-type">struct</span> mach_header_64 *) ((<span class="enscript-type">void</span> *) (buf + *header_offset));
    
    mach-&gt;magic = MH_MAGIC_64;
    mach-&gt;cputype = object-&gt;cputype;
    mach-&gt;cpusubtype = object-&gt;cpusubtype;
    mach-&gt;filetype = object-&gt;filetype;
    mach-&gt;ncmds = ncmds;
    mach-&gt;sizeofcmds = (uint32_t) (header_size - <span class="enscript-keyword">sizeof</span>(*mach));
    mach-&gt;flags = MH_NOUNDEFS;

    *header_offset += <span class="enscript-keyword">sizeof</span>(*mach);

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_LP64 */</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_index_symbols_by_name</span>(KXLDObject *object)
{
    <span class="enscript-keyword">return</span> kxld_symtab_index_symbols_by_name(object-&gt;symtab);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_index_cxx_symbols_by_value</span>(KXLDObject *object)
{
    <span class="enscript-keyword">return</span> kxld_symtab_index_cxx_symbols_by_value(object-&gt;symtab);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_relocate</span>(KXLDObject *object, kxld_addr_t link_address)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSeg *seg = NULL;
    u_int i = 0;

    check(object);

    object-&gt;link_addr = link_address;

    <span class="enscript-comment">/* Relocate segments (which relocates the sections) */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);
        kxld_seg_relocate(seg, link_address);
    }

    <span class="enscript-comment">/* Relocate symbols */</span>
    rval = kxld_symtab_relocate(object-&gt;symtab, &amp;object-&gt;sects);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> KXLDSym *
<span class="enscript-function-name">get_mutable_sym</span>(<span class="enscript-type">const</span> KXLDObject *object, <span class="enscript-type">const</span> KXLDSym *sym)
{
    KXLDSym *rval = NULL;
    kern_return_t result = KERN_FAILURE;
    u_int i = 0;

    result = kxld_symtab_get_sym_index(object-&gt;symtab, sym, &amp;i);
    require_noerr(result, finish);

    rval = kxld_symtab_get_symbol_by_index(object-&gt;symtab, i);
    require_action(rval == sym, finish, rval=NULL);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_resolve_symbol</span>(KXLDObject *object, 
    <span class="enscript-type">const</span> KXLDSym *sym, kxld_addr_t addr)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSym *resolved_sym = NULL;

    resolved_sym = get_mutable_sym(object, sym);
    require_action(resolved_sym, finish, rval=KERN_FAILURE);

    rval = kxld_sym_resolve(resolved_sym, addr);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_patch_symbol</span>(KXLDObject *object, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kxld_sym *sym)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSym *patched_sym = NULL;

    patched_sym = get_mutable_sym(object, sym);
    require_action(patched_sym, finish, rval=KERN_FAILURE);

    (<span class="enscript-type">void</span>) kxld_sym_patch(patched_sym);
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_add_symbol</span>(KXLDObject *object, <span class="enscript-type">char</span> *name, kxld_addr_t link_addr, 
    <span class="enscript-type">const</span> KXLDSym **sym_out)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSym *sym = NULL;

    rval = kxld_symtab_add_symbol(object-&gt;symtab, name, link_addr, &amp;sym);
    require_noerr(rval, finish);

    *sym_out = sym;
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t 
<span class="enscript-function-name">kxld_object_process_relocations</span>(KXLDObject *object, 
    <span class="enscript-type">const</span> KXLDDict *patched_vtables)
{
    kern_return_t rval = KERN_FAILURE;

    (<span class="enscript-type">void</span>) kxld_relocator_set_vtables(&amp;object-&gt;relocator, patched_vtables);

    <span class="enscript-comment">/* Process relocation entries and populate the global offset table.
     *
     * For final linked images: the relocation entries are contained in a couple
     * of tables hanging off the end of the symbol table.  The GOT has its own
     * section created by the linker; we simply need to fill it.
     *
     * For object files: the relocation entries are bound to each section.
     * The GOT, if it exists for the target architecture, is created by kxld,
     * and we must populate it according to our internal structures.
     */</span>
    <span class="enscript-keyword">if</span> (object-&gt;is_final_image) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_BUNDLE</span>
        rval = process_symbol_pointers(object);
        require_noerr(rval, finish);

        rval = process_relocs_from_tables(object);
        require_noerr(rval, finish);
#<span class="enscript-reference">else</span>
        require_action(FALSE, finish, rval=KERN_FAILURE);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_BUNDLE */</span>
    } <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_GOT</span>
        <span class="enscript-comment">/* Populate GOT */</span>
        rval = populate_got(object);
        require_noerr(rval, finish);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_GOT */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
        rval = process_relocs_from_sections(object);
        require_noerr(rval, finish);
#<span class="enscript-reference">else</span>
        require_action(FALSE, finish, rval=KERN_FAILURE);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>
    }

    <span class="enscript-comment">/* Populate kmod info structure */</span>
    rval = populate_kmod_info(object);
    require_noerr(rval, finish);
 
    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_BUNDLE</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SECT_SYM_PTRS</span> <span class="enscript-string">&quot;__nl_symbol_ptr&quot;</span>

<span class="enscript-comment">/*******************************************************************************
* Final linked images create an __nl_symbol_ptr section for the global offset
* table and for symbol pointer lookups in general.  Rather than use relocation
* entries, the linker creates an &quot;indirect symbol table&quot; which stores indexes
* into the symbol table corresponding to the entries of this section.  This
* function populates the section with the relocated addresses of those symbols.
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">process_symbol_pointers</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    KXLDSym *sym = NULL;
    int32_t *symidx = NULL;
    u_char *symptr = NULL;
    u_long symptrsize = 0;
    u_int nsyms = 0;
    u_int firstsym = 0;
    u_int i = 0;

    check(object);

    require_action(object-&gt;is_final_image &amp;&amp; object-&gt;dysymtab_hdr, 
        finish, rval=KERN_FAILURE);

    <span class="enscript-comment">/* Get the __DATA,__nl_symbol_ptr section.  If it doesn't exist, we have
     * nothing to do.
     */</span>

    sect = kxld_object_get_sect_by_name(object, SEG_DATA, SECT_SYM_PTRS);
    <span class="enscript-keyword">if</span> (!sect || !(sect-&gt;flags &amp; S_NON_LAZY_SYMBOL_POINTERS)) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Calculate the table offset and number of entries in the section */</span>

    <span class="enscript-keyword">if</span> (kxld_object_is_32_bit(object)) {
        symptrsize = <span class="enscript-keyword">sizeof</span>(uint32_t);
    } <span class="enscript-keyword">else</span> {
        symptrsize = <span class="enscript-keyword">sizeof</span>(uint64_t);
    }

    nsyms = (u_int) (sect-&gt;size / symptrsize);
    firstsym = sect-&gt;reserved1;

    require_action(firstsym + nsyms &lt;= object-&gt;dysymtab_hdr-&gt;nindirectsyms,
        finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
            <span class="enscript-string">&quot;firstsym + nsyms &gt; object-&gt;dysymtab_hdr-&gt;nindirectsyms&quot;</span>));

    <span class="enscript-comment">/* Iterate through the indirect symbol table and fill in the section of
     * symbol pointers.  There are three cases:
     *   1) A normal symbol - put its value directly in the table
     *   2) An INDIRECT_SYMBOL_LOCAL - symbols that are local and already have
     *      their offset from the start of the file in the section.  Simply
     *      add the file's link address to fill this entry.
     *   3) An INDIRECT_SYMBOL_ABS - prepopulated absolute symbols.  No
     *      action is required.
     */</span>

    symidx = (int32_t *) ((<span class="enscript-type">void</span> *) (object-&gt;file + object-&gt;dysymtab_hdr-&gt;indirectsymoff));
    symidx += firstsym;
    symptr = sect-&gt;data;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; nsyms; ++i, ++symidx, symptr+=symptrsize) {
        <span class="enscript-keyword">if</span> (*symidx &amp; INDIRECT_SYMBOL_LOCAL) {
            <span class="enscript-keyword">if</span> (*symidx &amp; INDIRECT_SYMBOL_ABS) <span class="enscript-keyword">continue</span>;

            add_to_ptr(symptr, object-&gt;link_addr, kxld_object_is_32_bit(object));
        } <span class="enscript-keyword">else</span> {
            sym = kxld_symtab_get_symbol_by_index(object-&gt;symtab, *symidx);
            require_action(sym, finish, rval=KERN_FAILURE);

            add_to_ptr(symptr, sym-&gt;link_addr, kxld_object_is_32_bit(object));
        }
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> KXLDSeg *
<span class="enscript-function-name">get_seg_by_base_addr</span>(KXLDObject *object, kxld_addr_t base_addr)
{
    KXLDSeg *seg = NULL;
    kxld_addr_t start = 0;
    kxld_addr_t end = 0;
    u_int i = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;segs.nitems; ++i) {
        seg = kxld_array_get_item(&amp;object-&gt;segs, i);
        start = seg-&gt;base_addr;
        end = seg-&gt;base_addr + seg-&gt;vmsize;

        <span class="enscript-keyword">if</span> (start &lt;= base_addr &amp;&amp; base_addr &lt; end) <span class="enscript-keyword">return</span> seg;
    }

    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">process_relocs_from_tables</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDReloc *reloc = NULL;
    KXLDSeg *seg = NULL;
    u_int i = 0;

    <span class="enscript-comment">/* Process external relocations */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;extrelocs.nitems; ++i) {
        reloc = kxld_array_get_item(&amp;object-&gt;extrelocs, i);

        seg = get_seg_by_base_addr(object, reloc-&gt;address);
        require_action(seg, finish, rval=KERN_FAILURE);

        rval = kxld_relocator_process_table_reloc(&amp;object-&gt;relocator, reloc,
            seg, object-&gt;link_addr);
        require_noerr(rval, finish);
    }

    <span class="enscript-comment">/* Process local relocations */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;locrelocs.nitems; ++i) {
        reloc = kxld_array_get_item(&amp;object-&gt;locrelocs, i);

        seg = get_seg_by_base_addr(object, reloc-&gt;address);
        require_action(seg, finish, rval=KERN_FAILURE);

        rval = kxld_relocator_process_table_reloc(&amp;object-&gt;relocator, reloc,
            seg, object-&gt;link_addr);
        require_noerr(rval, finish);
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">add_to_ptr</span>(u_char *symptr, kxld_addr_t val, boolean_t is_32_bit)
{
    <span class="enscript-keyword">if</span> (is_32_bit) {
        uint32_t *ptr = (uint32_t *) ((<span class="enscript-type">void</span> *) symptr);
        *ptr += (uint32_t) val;
    } <span class="enscript-keyword">else</span> {
        uint64_t *ptr = (uint64_t *) ((<span class="enscript-type">void</span> *) symptr);
        *ptr += (uint64_t) val;
    }
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_BUNDLE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">process_relocs_from_sections</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *sect = NULL;
    u_int i = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; object-&gt;sects.nitems; ++i) {
        sect = kxld_array_get_item(&amp;object-&gt;sects, i);
        rval = kxld_sect_process_relocs(sect, &amp;object-&gt;relocator);
        require_noerr(rval, finish);
    }

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">populate_kmod_info</span>(KXLDObject *object)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDSect *kmodsect = NULL;
    KXLDSym *kmodsym = NULL;
    kmod_info_t *kmod_info = NULL;
    u_long kmod_offset = 0;
    u_long header_size;
    u_long size;

    <span class="enscript-keyword">if</span> (kxld_object_is_kernel(object)) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    kxld_object_get_vmsize(object, &amp;header_size, &amp;size);

    kmodsym = kxld_symtab_get_locally_defined_symbol_by_name(object-&gt;symtab, 
        KXLD_KMOD_INFO_SYMBOL);
    require_action(kmodsym, finish, rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogNoKmodInfo));
 
    kmodsect = kxld_array_get_item(&amp;object-&gt;sects, kmodsym-&gt;sectnum);
    kmod_offset = (u_long) (kmodsym-&gt;base_addr -  kmodsect-&gt;base_addr);
    kmod_info = (kmod_info_t *) ((<span class="enscript-type">void</span> *) (kmodsect-&gt;data + kmod_offset));

    <span class="enscript-keyword">if</span> (kxld_object_is_32_bit(object)) {
        kmod_info_32_v1_t *kmod = (kmod_info_32_v1_t *) (kmod_info);
        kmod-&gt;address = (uint32_t) object-&gt;link_addr;
        kmod-&gt;size = (uint32_t) size;
        kmod-&gt;hdr_size = (uint32_t) header_size;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
        <span class="enscript-keyword">if</span> (kxld_object_target_needs_swap(object)) {
            kmod-&gt;address = OSSwapInt32(kmod-&gt;address);
            kmod-&gt;size = OSSwapInt32(kmod-&gt;size);
            kmod-&gt;hdr_size = OSSwapInt32(kmod-&gt;hdr_size);
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
    } <span class="enscript-keyword">else</span> {
        kmod_info_64_v1_t *kmod = (kmod_info_64_v1_t *) (kmod_info);
        kmod-&gt;address = object-&gt;link_addr;
        kmod-&gt;size = size;
        kmod-&gt;hdr_size = header_size;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
        <span class="enscript-keyword">if</span> (kxld_object_target_needs_swap(object)) {
            kmod-&gt;address = OSSwapInt64(kmod-&gt;address);
            kmod-&gt;size = OSSwapInt64(kmod-&gt;size);
            kmod-&gt;hdr_size = OSSwapInt64(kmod-&gt;hdr_size);
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
    }


    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_PIC_KEXTS</span>
<span class="enscript-comment">/*******************************************************************************
 *******************************************************************************/</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">target_supports_slideable_kexts</span>(<span class="enscript-type">const</span> KXLDObject *object)
{
    check(object);

    <span class="enscript-keyword">return</span> (object-&gt;cputype != CPU_TYPE_I386 &amp;&amp; object-&gt;include_kaslr_relocs);
}
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* KXLD_PIC_KEXTS */</span>
</pre>
<hr />
</body></html>