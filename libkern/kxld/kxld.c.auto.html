<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kxld.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kxld.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2008, 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>  <span class="enscript-comment">/* For PAGE_SIZE */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_ASSERT_COMPONENT_NAME_STRING</span> <span class="enscript-string">&quot;kxld&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;AssertMacros.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__KXLD_KERNEL_UNUSED</span> __unused
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__KXLD_KERNEL_UNUSED</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    #include <span class="enscript-string">&quot;kxld.h&quot;</span>
    #include <span class="enscript-string">&quot;kxld_types.h&quot;</span>
#<span class="enscript-reference">else</span> 
    #include &lt;libkern/kxld.h&gt;
    #include &lt;libkern/kxld_types.h&gt;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_array.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_dict.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_kext.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_object.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_sym.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_symtab.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_util.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_vtable.h&quot;</span>

<span class="enscript-type">struct</span> kxld_vtable;

<span class="enscript-type">struct</span> kxld_context {
    KXLDKext *kext;
    KXLDArray *section_order;
    KXLDArray objects;
    KXLDArray dependencies;
    KXLDDict defined_symbols_by_name;
    KXLDDict defined_cxx_symbols_by_value;
    KXLDDict obsolete_symbols_by_name;
    KXLDDict vtables_by_name;
    KXLDFlags flags;
    KXLDAllocateCallback allocate_callback;
    cpu_type_t cputype;
    cpu_subtype_t cpusubtype;
};

<span class="enscript-comment">/*******************************************************************************
* Globals
*******************************************************************************/</span>

<span class="enscript-comment">/* Certain architectures alter the order of a kext's sections from its input
 * binary, so we track that order in a dictionary of arrays, with one array for
 * each architecture.  Since the kernel only has one architecture, we can
 * eliminate the dictionary and use a simple array.  
 * XXX: If we ever use the linker in a multithreaded environment, we will need 
 * locks around these global structures.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-type">static</span> KXLDArray *s_section_order;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> KXLDDict *s_order_dict;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*******************************************************************************
* Prototypes
*******************************************************************************/</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">init_context</span>(KXLDContext *context, u_int ndependencies);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">init_kext_objects</span>(KXLDContext *context, u_char *file, 
    u_long size, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, KXLDDependency *dependencies, 
    u_int ndependencies);
<span class="enscript-type">static</span> KXLDObject * <span class="enscript-function-name">get_object_for_file</span>(KXLDContext *context, 
    u_char *file, u_long size, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name);
<span class="enscript-type">static</span> u_char * <span class="enscript-function-name">allocate_kext</span>(KXLDContext *context, <span class="enscript-type">void</span> *callback_data,
    kxld_addr_t *vmaddr, u_long *vmsize, u_char **linked_object_alloc_out);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">clear_context</span>(KXLDContext *context);

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_create_context</span>(KXLDContext **_context, 
    KXLDAllocateCallback allocate_callback, KXLDLoggingCallback logging_callback,
    KXLDFlags flags, cpu_type_t cputype, cpu_subtype_t cpusubtype,
    vm_size_t pagesize __KXLD_KERNEL_UNUSED)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDContext       * context         = NULL;
    KXLDArray         * section_order   = NULL;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    cpu_type_t        * cputype_p       = NULL;
#<span class="enscript-reference">endif</span>

    check(_context);
    check(allocate_callback);
    check(logging_callback);
    *_context = NULL;

    context = kxld_alloc(<span class="enscript-keyword">sizeof</span>(*context));
    require_action(context, finish, rval=KERN_RESOURCE_SHORTAGE);
    bzero(context, <span class="enscript-keyword">sizeof</span>(*context));

    context-&gt;flags = flags;
    context-&gt;allocate_callback = allocate_callback;
    context-&gt;cputype = cputype;
    context-&gt;cpusubtype = cpusubtype;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (pagesize) {
        kxld_set_cross_link_page_size(pagesize);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    kxld_set_logging_callback(logging_callback);

    context-&gt;kext = kxld_alloc(kxld_kext_sizeof());
    require_action(context-&gt;kext, finish, rval=KERN_RESOURCE_SHORTAGE);
    bzero(context-&gt;kext, kxld_kext_sizeof());

    <span class="enscript-comment">/* Check if we already have an order array for this arch */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KXLD_USER_OR_OBJECT</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>   
    context-&gt;section_order = s_section_order;
#<span class="enscript-reference">else</span>
    <span class="enscript-comment">/* In userspace, create the dictionary if it doesn't already exist */</span>
    <span class="enscript-keyword">if</span> (!s_order_dict) {
        s_order_dict = kxld_alloc(<span class="enscript-keyword">sizeof</span>(*s_order_dict));
        require_action(s_order_dict, finish, rval=KERN_RESOURCE_SHORTAGE);
        bzero(s_order_dict, <span class="enscript-keyword">sizeof</span>(*s_order_dict));

        rval = kxld_dict_init(s_order_dict, kxld_dict_uint32_hash,
            kxld_dict_uint32_cmp, 0);
        require_noerr(rval, finish);
    }

    context-&gt;section_order = kxld_dict_find(s_order_dict, &amp;cputype);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    <span class="enscript-comment">/* Create an order array for this arch if needed */</span>
    
    <span class="enscript-keyword">if</span> (!context-&gt;section_order) {

        section_order = kxld_alloc(<span class="enscript-keyword">sizeof</span>(*section_order));
        require_action(section_order, finish, rval=KERN_RESOURCE_SHORTAGE);
        bzero(section_order, <span class="enscript-keyword">sizeof</span>(*section_order));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
        s_section_order = section_order;
#<span class="enscript-reference">else</span>
        <span class="enscript-comment">/* In userspace, add the new array to the order dictionary */</span>
        cputype_p = kxld_alloc(<span class="enscript-keyword">sizeof</span>(*cputype_p));
        require_action(cputype_p, finish, rval=KERN_RESOURCE_SHORTAGE);
        *cputype_p = cputype;

        rval = kxld_dict_insert(s_order_dict, cputype_p, section_order);
        require_noerr(rval, finish);

        cputype_p = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

        context-&gt;section_order = section_order;

        section_order = NULL;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KXLD_USER_OR_OBJECT */</span>

    rval = KERN_SUCCESS;
    *_context = context;
    context = NULL;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (context) kxld_destroy_context(context);
    <span class="enscript-keyword">if</span> (section_order) kxld_free(section_order, <span class="enscript-keyword">sizeof</span>(*section_order));
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (cputype_p) kxld_free(cputype_p, <span class="enscript-keyword">sizeof</span>(*cputype_p));
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_destroy_context</span>(KXLDContext *context)
{
    KXLDObject *object = NULL;
    KXLDKext *dep = NULL;
    u_int i = 0;

    check(context);

    kxld_kext_deinit(context-&gt;kext);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; context-&gt;objects.maxitems; ++i) {
        object = kxld_array_get_slot(&amp;context-&gt;objects, i);
        kxld_object_deinit(object);
    }
    kxld_array_deinit(&amp;context-&gt;objects);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; context-&gt;dependencies.maxitems; ++i) {
        dep = kxld_array_get_slot(&amp;context-&gt;dependencies, i);
        kxld_kext_deinit(dep);
    }
    kxld_array_deinit(&amp;context-&gt;dependencies);

    kxld_dict_deinit(&amp;context-&gt;defined_symbols_by_name);
    kxld_dict_deinit(&amp;context-&gt;defined_cxx_symbols_by_value);
    kxld_dict_deinit(&amp;context-&gt;obsolete_symbols_by_name);
    kxld_dict_deinit(&amp;context-&gt;vtables_by_name);

    kxld_free(context-&gt;kext, kxld_kext_sizeof());
    kxld_free(context, <span class="enscript-keyword">sizeof</span>(*context));

    kxld_print_memory_report();
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">kxld_link_file</span>(
    KXLDContext       * context,
    u_char            * file,
    u_long              size,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>        * name,
    <span class="enscript-type">void</span>              * callback_data,
    KXLDDependency    * dependencies,
    u_int               ndependencies,
    u_char           ** linked_object_out,
    kxld_addr_t       * kmod_info_kern)
{
    kern_return_t       rval                    = KERN_FAILURE;
    kxld_addr_t         vmaddr                  = 0;
    u_long              vmsize                  = 0;
    u_char            * linked_object           = NULL;
    u_char            * linked_object_alloc     = NULL;

    kxld_set_logging_callback_data(name, callback_data);

    kxld_log(kKxldLogLinking, kKxldLogBasic, <span class="enscript-string">&quot;Linking kext %s&quot;</span>, name);

    require_action(context, finish, rval=KERN_INVALID_ARGUMENT);
    require_action(file, finish, rval=KERN_INVALID_ARGUMENT);
    require_action(size, finish, rval=KERN_INVALID_ARGUMENT);
    require_action(dependencies, finish, rval=KERN_INVALID_ARGUMENT);
    require_action(ndependencies, finish, rval=KERN_INVALID_ARGUMENT);
    require_action(linked_object_out, finish, rval=KERN_INVALID_ARGUMENT);
    require_action(kmod_info_kern, finish, rval=KERN_INVALID_ARGUMENT);

    rval = init_context(context, ndependencies);
    require_noerr(rval, finish);

    rval = init_kext_objects(context, file, size, name, 
        dependencies, ndependencies);
    require_noerr(rval, finish);

    linked_object = allocate_kext(context, callback_data, 
        &amp;vmaddr, &amp;vmsize, &amp;linked_object_alloc);
    require_action(linked_object, finish, rval=KERN_RESOURCE_SHORTAGE);

    rval = kxld_kext_relocate(context-&gt;kext, vmaddr, 
        &amp;context-&gt;vtables_by_name, 
        &amp;context-&gt;defined_symbols_by_name, 
        &amp;context-&gt;obsolete_symbols_by_name,
        &amp;context-&gt;defined_cxx_symbols_by_value);
    require_noerr(rval, finish);

    rval = kxld_kext_export_linked_object(context-&gt;kext, 
        linked_object, kmod_info_kern);
    require_noerr(rval, finish);

    *linked_object_out = linked_object;
    linked_object_alloc = NULL;

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (linked_object_alloc) {
        kxld_page_free_untracked(linked_object_alloc, vmsize);
    }

    clear_context(context);
    kxld_set_logging_callback_data(NULL, NULL);

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">init_context</span>(KXLDContext *context, u_int ndependencies)
{
    kern_return_t rval = KERN_FAILURE;

    <span class="enscript-comment">/* Create an array of objects large enough to hold an object
     * for every dependency, an interface for each dependency, and a kext. */</span>
    rval = kxld_array_init(&amp;context-&gt;objects,
        kxld_object_sizeof(), 2 * ndependencies + 1);
    require_noerr(rval, finish);

    rval = kxld_array_init(&amp;context-&gt;dependencies, 
        kxld_kext_sizeof(), ndependencies);
    require_noerr(rval, finish);

    rval = kxld_dict_init(&amp;context-&gt;defined_symbols_by_name, 
        kxld_dict_string_hash, kxld_dict_string_cmp, 0);
    require_noerr(rval, finish);

    rval = kxld_dict_init(&amp;context-&gt;defined_cxx_symbols_by_value, 
        kxld_dict_kxldaddr_hash, kxld_dict_kxldaddr_cmp, 0);
    require_noerr(rval, finish);

    rval = kxld_dict_init(&amp;context-&gt;obsolete_symbols_by_name, 
        kxld_dict_string_hash, kxld_dict_string_cmp, 0);
    require_noerr(rval, finish);

    rval = kxld_dict_init(&amp;context-&gt;vtables_by_name, kxld_dict_string_hash,
        kxld_dict_string_cmp, 0);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> kern_return_t 
<span class="enscript-function-name">init_kext_objects</span>(KXLDContext *context, u_char *file, u_long size, 
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, KXLDDependency *dependencies, u_int ndependencies)
{
    kern_return_t rval = KERN_FAILURE;
    KXLDKext *kext = NULL;
    KXLDObject *kext_object = NULL;
    KXLDObject *interface_object = NULL;
    u_int i = 0;

    <span class="enscript-comment">/* Create a kext object for each dependency.  If it's a direct dependency,
     * export its symbols by name by value.  If it's indirect, just export the
     * C++ symbols by value.
     */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ndependencies; ++i) {
        kext = kxld_array_get_item(&amp;context-&gt;dependencies, i);
        kext_object = NULL;
        interface_object = NULL;

        kext_object = get_object_for_file(context, dependencies[i].kext,
            dependencies[i].kext_size, dependencies[i].kext_name);
        require_action(kext_object, finish, rval=KERN_FAILURE);

        <span class="enscript-keyword">if</span> (dependencies[i].interface) {
            interface_object = get_object_for_file(context, 
                dependencies[i].interface, dependencies[i].interface_size,
                dependencies[i].interface_name);
            require_action(interface_object, finish, rval=KERN_FAILURE);
        }

        rval = kxld_kext_init(kext, kext_object, interface_object);
        require_noerr(rval, finish);

        <span class="enscript-keyword">if</span> (dependencies[i].is_direct_dependency) {
            rval = kxld_kext_export_symbols(kext,
                &amp;context-&gt;defined_symbols_by_name, 
                &amp;context-&gt;obsolete_symbols_by_name,
                &amp;context-&gt;defined_cxx_symbols_by_value);
            require_noerr(rval, finish);
        } <span class="enscript-keyword">else</span> {
            rval = kxld_kext_export_symbols(kext, 
                <span class="enscript-comment">/* defined_symbols */</span> NULL, <span class="enscript-comment">/* obsolete_symbols */</span> NULL, 
                &amp;context-&gt;defined_cxx_symbols_by_value);
            require_noerr(rval, finish);
        }
    }

    <span class="enscript-comment">/* Export the vtables for all of the dependencies. */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; context-&gt;dependencies.nitems; ++i) {
        kext = kxld_array_get_item(&amp;context-&gt;dependencies, i);

        rval = kxld_kext_export_vtables(kext,
            &amp;context-&gt;defined_cxx_symbols_by_value,
            &amp;context-&gt;defined_symbols_by_name,
            &amp;context-&gt;vtables_by_name);
        require_noerr(rval, finish);
    }

    <span class="enscript-comment">/* Create a kext object for the kext we're linking and export its locally
     * defined C++ symbols. 
     */</span>
    kext_object = get_object_for_file(context, file, size, name);
    require_action(kext_object, finish, rval=KERN_FAILURE);

    rval = kxld_kext_init(context-&gt;kext, kext_object, <span class="enscript-comment">/* interface */</span> NULL);
    require_noerr(rval, finish);

    rval = kxld_kext_export_symbols(context-&gt;kext,
        <span class="enscript-comment">/* defined_symbols */</span> NULL, <span class="enscript-comment">/* obsolete_symbols */</span> NULL, 
        &amp;context-&gt;defined_cxx_symbols_by_value);
    require_noerr(rval, finish);

    rval = KERN_SUCCESS;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> KXLDObject *
<span class="enscript-function-name">get_object_for_file</span>(KXLDContext *context, u_char *file, u_long size,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
    KXLDObject *rval = NULL;
    KXLDObject *object = NULL;
    kern_return_t result = 0;
    u_int i = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; context-&gt;objects.nitems; ++i) {
        object = kxld_array_get_item(&amp;context-&gt;objects, i);

        <span class="enscript-keyword">if</span> (!kxld_object_get_file(object)) {
            result = kxld_object_init_from_macho(object, file, size, name,
                context-&gt;section_order, context-&gt;cputype, context-&gt;cpusubtype, context-&gt;flags);
            require_noerr(result, finish);

            rval = object;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (kxld_object_get_file(object) == file) {
            rval = object;
            <span class="enscript-keyword">break</span>;
        }
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}
 
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> u_char *
<span class="enscript-function-name">allocate_kext</span>(KXLDContext *context, <span class="enscript-type">void</span> *callback_data,
    kxld_addr_t *vmaddr_out, u_long *vmsize_out, 
    u_char **linked_object_alloc_out)
{
    KXLDAllocateFlags   flags                   = 0;
    kxld_addr_t         vmaddr                  = 0;
    u_long              vmsize                  = 0;
    u_long              header_size             = 0;
    u_char            * linked_object           = NULL;

    *linked_object_alloc_out = NULL;

    kxld_kext_get_vmsize(context-&gt;kext, &amp;header_size, &amp;vmsize);
    vmaddr = context-&gt;allocate_callback(vmsize, &amp;flags, callback_data);
    require_action(!(vmaddr &amp; (kxld_get_effective_page_size()-1)), finish,
        kxld_log(kKxldLogLinking, kKxldLogErr,
            <span class="enscript-string">&quot;Load address %p is not page-aligned.&quot;</span>,
            (<span class="enscript-type">void</span> *) (uintptr_t) vmaddr));

    <span class="enscript-keyword">if</span> (flags &amp; kKxldAllocateWritable) {
        linked_object = (u_char *) (u_long) vmaddr;
    } <span class="enscript-keyword">else</span> {
        linked_object = kxld_page_alloc_untracked(vmsize);
        require(linked_object, finish);

        *linked_object_alloc_out = linked_object;
    }

    kxld_kext_set_linked_object_size(context-&gt;kext, vmsize);
    
    <span class="enscript-comment">/* Zero out the memory before we fill it.  We fill this buffer in a
     * sparse fashion, and it's simpler to clear it now rather than
     * track and zero any pieces we didn't touch after we've written
     * all of the sections to memory.
     */</span>
    bzero(linked_object, vmsize);
    *vmaddr_out = vmaddr;
    *vmsize_out = vmsize;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> linked_object;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">clear_context</span>(KXLDContext *context)
{
    KXLDObject * object = NULL;
    KXLDKext   * dep     = NULL;
    u_int i = 0;

    check(context);

    kxld_kext_clear(context-&gt;kext);
    
    <span class="enscript-keyword">for</span> (i = 0; i &lt; context-&gt;objects.nitems; ++i) {
        object = kxld_array_get_item(&amp;context-&gt;objects, i);
        kxld_object_clear(object);
    }
    kxld_array_reset(&amp;context-&gt;objects);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; context-&gt;dependencies.nitems; ++i) {
        dep = kxld_array_get_item(&amp;context-&gt;dependencies, i);
        kxld_kext_clear(dep);
    }
    kxld_array_reset(&amp;context-&gt;dependencies);

    kxld_dict_clear(&amp;context-&gt;defined_symbols_by_name);
    kxld_dict_clear(&amp;context-&gt;defined_cxx_symbols_by_value);
    kxld_dict_clear(&amp;context-&gt;obsolete_symbols_by_name);
    kxld_dict_clear(&amp;context-&gt;vtables_by_name);
}

</pre>
<hr />
</body></html>