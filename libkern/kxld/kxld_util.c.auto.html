<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kxld_util.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kxld_util.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/reloc.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    #include &lt;kern/kalloc.h&gt;
    #include &lt;libkern/libkern.h&gt;
    #include &lt;mach/vm_param.h&gt;
    #include &lt;vm/vm_kern.h&gt;
#<span class="enscript-reference">else</span>
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;mach/mach_init.h&gt;
    #include &lt;mach-o/swap.h&gt;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_ASSERT_COMPONENT_NAME_STRING</span> <span class="enscript-string">&quot;kxld&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;AssertMacros.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kxld_util.h&quot;</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">unswap_macho_32</span>(u_char *file, <span class="enscript-type">enum</span> NXByteOrder host_order, 
    <span class="enscript-type">enum</span> NXByteOrder target_order);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">unswap_macho_64</span>(u_char *file, <span class="enscript-type">enum</span> NXByteOrder host_order, 
    <span class="enscript-type">enum</span> NXByteOrder target_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> num_allocations = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> num_frees = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> bytes_allocated = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> bytes_freed = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> KXLDLoggingCallback s_logging_callback = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s_callback_name = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *s_callback_data = NULL;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
<span class="enscript-type">static</span> boolean_t s_cross_link_enabled  = FALSE;
<span class="enscript-type">static</span> kxld_size_t s_cross_link_page_size = PAGE_SIZE;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_set_logging_callback</span>(KXLDLoggingCallback logging_callback)
{
    s_logging_callback = logging_callback;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_set_logging_callback_data</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">void</span> *user_data)
{
    s_callback_name = name;
    s_callback_data = user_data;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kxld_log</span>(KXLDLogSubsystem subsystem, KXLDLogLevel level, 
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *in_format, ...)
{
    <span class="enscript-type">char</span> stack_buffer[256];
    <span class="enscript-type">char</span> *alloc_buffer = NULL;
    <span class="enscript-type">char</span> *format = stack_buffer;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = (s_callback_name) ? s_callback_name : <span class="enscript-string">&quot;internal&quot;</span>;
    u_int length = 0;
    va_list ap;

    <span class="enscript-keyword">if</span> (s_logging_callback) {

        length = snprintf(stack_buffer, <span class="enscript-keyword">sizeof</span>(stack_buffer), <span class="enscript-string">&quot;kxld[%s]: %s&quot;</span>,
            name, in_format);

        <span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(stack_buffer)) {
            length += 1;
            alloc_buffer = kxld_alloc(length);
            <span class="enscript-keyword">if</span> (!alloc_buffer) <span class="enscript-keyword">return</span>;

            snprintf(alloc_buffer, length, <span class="enscript-string">&quot;kxld[%s]: %s&quot;</span>,
                name, in_format);
            format = alloc_buffer;
        }

        va_start(ap, in_format);
        s_logging_callback(subsystem, level, format, ap, s_callback_data);
        va_end(ap);

        <span class="enscript-keyword">if</span> (alloc_buffer) {
            kxld_free(alloc_buffer, length);
        }
    }
}

<span class="enscript-comment">/* We'll use kalloc for any page-based allocations under this threshold, and
 * kmem_alloc otherwise.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KALLOC_MAX</span> 16 * 1024

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> * 
<span class="enscript-function-name">kxld_alloc</span>(size_t size)
{
    <span class="enscript-type">void</span> * ptr = NULL;
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    ptr = kalloc(size);
#<span class="enscript-reference">else</span>
    ptr = malloc(size);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-keyword">if</span> (ptr) {
        ++num_allocations;
        bytes_allocated += size;
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">kxld_page_alloc_untracked</span>(size_t size)
{
    <span class="enscript-type">void</span> * ptr = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    kern_return_t rval = 0;
    vm_offset_t addr = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    size = round_page(size);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (size &lt; KALLOC_MAX) {
        ptr = kalloc(size);
    } <span class="enscript-keyword">else</span> {
        rval = kmem_alloc(kernel_map, &amp;addr, size, VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (!rval) ptr = (<span class="enscript-type">void</span> *) addr;
    }
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !KERNEL */</span>
    ptr = malloc(size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">kxld_page_alloc</span>(size_t size)
{
    <span class="enscript-type">void</span> * ptr = NULL;

    ptr = kxld_page_alloc_untracked(size);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-keyword">if</span> (ptr) {
        ++num_allocations;
        bytes_allocated += round_page(size);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">kxld_alloc_pageable</span>(size_t size)
{
    size = round_page(size);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    kern_return_t rval = 0;
    vm_offset_t ptr = 0;

    rval = kmem_alloc_pageable(kernel_map, &amp;ptr, size, VM_KERN_MEMORY_OSKEXT);
    <span class="enscript-keyword">if</span> (rval) ptr = 0;

    <span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) ptr;
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> kxld_page_alloc_untracked(size);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_free</span>(<span class="enscript-type">void</span> *ptr, size_t size __unused)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    ++num_frees;
    bytes_freed += size;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    kfree(ptr, size);
#<span class="enscript-reference">else</span>
    free(ptr);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_page_free_untracked</span>(<span class="enscript-type">void</span> *ptr, size_t size __unused)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    size = round_page(size);

    <span class="enscript-keyword">if</span> (size &lt; KALLOC_MAX) {
        kfree(ptr, size);
    } <span class="enscript-keyword">else</span> {
        kmem_free(kernel_map, (vm_offset_t) ptr, size);
    }
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !KERNEL */</span>
    free(ptr);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
}
    

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_page_free</span>(<span class="enscript-type">void</span> *ptr, size_t size)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    ++num_frees;
    bytes_freed += round_page(size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
    kxld_page_free_untracked(ptr, size);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">validate_and_swap_macho_32</span>(u_char *file, u_long size
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    , <span class="enscript-type">enum</span> NXByteOrder host_order
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
    )
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> mach_header *mach_hdr = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) file);
    <span class="enscript-type">struct</span> load_command *load_hdr = NULL;
    <span class="enscript-type">struct</span> segment_command *seg_hdr = NULL;
    <span class="enscript-type">struct</span> section *sects = NULL;
    <span class="enscript-type">struct</span> relocation_info *relocs = NULL;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    <span class="enscript-type">struct</span> nlist *symtab = NULL;
    u_long offset = 0;
    u_int cmd = 0;
    u_int cmdsize = 0;
    u_int i = 0; 
    u_int j = 0; 
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    boolean_t swap = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    check(file);
    check(size);

    <span class="enscript-comment">/* Verify that the file is big enough for the mach header */</span>
    require_action(size &gt;= <span class="enscript-keyword">sizeof</span>(*mach_hdr), finish, 
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));
    offset = <span class="enscript-keyword">sizeof</span>(*mach_hdr);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-comment">/* Swap the mach header if necessary */</span>
    <span class="enscript-keyword">if</span> (mach_hdr-&gt;magic == MH_CIGAM) {
        swap = TRUE;
        (<span class="enscript-type">void</span>) swap_mach_header(mach_hdr, host_order);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    <span class="enscript-comment">/* Validate the mach_header's magic number */</span>
    require_action(mach_hdr-&gt;magic == MH_MAGIC, finish,
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
            <span class="enscript-string">&quot;Invalid magic number: 0x%x.&quot;</span>, mach_hdr-&gt;magic));

   <span class="enscript-comment">/* If in the running kernel, and asked to validate the kernel
    * (which is the only file of type MH_EXECUTE we should ever see),
    * then just assume it's ok or we wouldn't be running to begin with.
    */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (mach_hdr-&gt;filetype == MH_EXECUTE) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    <span class="enscript-comment">/* Validate and potentially swap the load commands */</span>
    <span class="enscript-keyword">for</span>(i = 0; i &lt; mach_hdr-&gt;ncmds; ++i, offset += cmdsize) {

        <span class="enscript-comment">/* Get the load command and size */</span>
        load_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (file + offset));
        cmd = load_hdr-&gt;cmd;
        cmdsize = load_hdr-&gt;cmdsize;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
        <span class="enscript-keyword">if</span> (swap) {
            cmd = OSSwapInt32(load_hdr-&gt;cmd);
            cmdsize = OSSwapInt32(load_hdr-&gt;cmdsize);
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

        <span class="enscript-comment">/* Verify that the file is big enough to contain the load command */</span>        
        require_action(size &gt;= offset + cmdsize, finish,
            rval=KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

        <span class="enscript-keyword">switch</span>(cmd) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT</span>:
            <span class="enscript-comment">/* Get and swap the segment header */</span>
            seg_hdr = (<span class="enscript-type">struct</span> segment_command *) load_hdr;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-keyword">if</span> (swap) swap_segment_command(seg_hdr, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-comment">/* Get and swap the section headers */</span>
            sects = (<span class="enscript-type">struct</span> section *) &amp;seg_hdr[1];
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-keyword">if</span> (swap) swap_section(sects, seg_hdr-&gt;nsects, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-comment">/* Ignore segments with no vm size */</span>
            <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">/* Verify that the file is big enough for the segment data. */</span>
            require_action(size &gt;= seg_hdr-&gt;fileoff + seg_hdr-&gt;filesize, finish,
                rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

            <span class="enscript-keyword">for</span> (j = 0; j &lt; seg_hdr-&gt;nsects; ++j) {

                <span class="enscript-comment">/* Verify that, if the section is not to be zero filled on
                 * demand, that file is big enough for the section's data.
                 */</span>
                require_action((sects[j].flags &amp; S_ZEROFILL) ||
                    (size &gt;= sects[j].offset + sects[j].size), finish,
                    rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

                <span class="enscript-comment">/* Verify that the file is big enough for the section's
                 * relocation entries.
                 */</span>
                require_action(size &gt;= 
                    sects[j].reloff + sects[j].nreloc * <span class="enscript-keyword">sizeof</span>(*relocs), finish,
                    rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

                <span class="enscript-comment">/* Swap the relocation entries */</span>
                relocs = (<span class="enscript-type">struct</span> relocation_info *) ((<span class="enscript-type">void</span> *) (file + sects[j].reloff));
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
                <span class="enscript-keyword">if</span> (swap) {
                    swap_relocation_info(relocs, sects[j].nreloc, 
                        host_order);
                }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
            }

            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SYMTAB</span>:
            <span class="enscript-comment">/* Get and swap the symtab header */</span>
            symtab_hdr = (<span class="enscript-type">struct</span> symtab_command *) load_hdr;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-keyword">if</span> (swap) swap_symtab_command(symtab_hdr, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-comment">/* Verify that the file is big enough for the symbol table */</span>
            require_action(size &gt;= 
                symtab_hdr-&gt;symoff + symtab_hdr-&gt;nsyms * <span class="enscript-keyword">sizeof</span>(*symtab), finish,
                rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

            <span class="enscript-comment">/* Verify that the file is big enough for the string table */</span>
            require_action(size &gt;= symtab_hdr-&gt;stroff + symtab_hdr-&gt;strsize, finish,
                rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-comment">/* Swap the symbol table entries */</span>
            symtab = (<span class="enscript-type">struct</span> nlist *) ((<span class="enscript-type">void</span> *) (file + symtab_hdr-&gt;symoff));
            <span class="enscript-keyword">if</span> (swap) swap_nlist(symtab, symtab_hdr-&gt;nsyms, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-comment">/* Swap the load command */</span>
            <span class="enscript-keyword">if</span> (swap) swap_load_command(load_hdr, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
            <span class="enscript-keyword">break</span>;
        }
    }

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kern_return_t
<span class="enscript-function-name">validate_and_swap_macho_64</span>(u_char *file, u_long size
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    , <span class="enscript-type">enum</span> NXByteOrder host_order
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
    )
{
    kern_return_t rval = KERN_FAILURE;
    <span class="enscript-type">struct</span> mach_header_64 *mach_hdr = (<span class="enscript-type">struct</span> mach_header_64 *) ((<span class="enscript-type">void</span> *) file);
    <span class="enscript-type">struct</span> load_command *load_hdr = NULL;
    <span class="enscript-type">struct</span> segment_command_64 *seg_hdr = NULL;
    <span class="enscript-type">struct</span> section_64 *sects = NULL;
    <span class="enscript-type">struct</span> relocation_info *relocs = NULL;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    <span class="enscript-type">struct</span> nlist_64 *symtab = NULL;
    u_long offset = 0;
    u_int cmd = 0;
    u_int cmdsize = 0;
    u_int i = 0; 
    u_int j = 0; 
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    boolean_t swap = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    check(file);
    check(size);

    <span class="enscript-comment">/* Verify that the file is big enough for the mach header */</span>
    require_action(size &gt;= <span class="enscript-keyword">sizeof</span>(*mach_hdr), finish, 
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));
    offset = <span class="enscript-keyword">sizeof</span>(*mach_hdr);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-comment">/* Swap the mach header if necessary */</span>
    <span class="enscript-keyword">if</span> (mach_hdr-&gt;magic == MH_CIGAM_64) {
        swap = TRUE;
        (<span class="enscript-type">void</span>) swap_mach_header_64(mach_hdr, host_order);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

    <span class="enscript-comment">/* Validate the mach_header's magic number */</span>
    require_action(mach_hdr-&gt;magic == MH_MAGIC_64, finish,
        rval=KERN_FAILURE;
        kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogMalformedMachO
            <span class="enscript-string">&quot;Invalid magic number: 0x%x.&quot;</span>, mach_hdr-&gt;magic));

   <span class="enscript-comment">/* If in the running kernel, and asked to validate the kernel
    * (which is the only file of type MH_EXECUTE we should ever see),
    * then just assume it's ok or we wouldn't be running to begin with.
    */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">if</span> (mach_hdr-&gt;filetype == MH_EXECUTE) {
        rval = KERN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

    <span class="enscript-comment">/* Validate and potentially swap the load commands */</span>
    <span class="enscript-keyword">for</span>(i = 0; i &lt; mach_hdr-&gt;ncmds; ++i, offset += cmdsize) {
        <span class="enscript-comment">/* Get the load command and size */</span>
        load_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (file + offset));
        cmd = load_hdr-&gt;cmd;
        cmdsize = load_hdr-&gt;cmdsize;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
        <span class="enscript-keyword">if</span> (swap) {
            cmd = OSSwapInt32(load_hdr-&gt;cmd);
            cmdsize = OSSwapInt32(load_hdr-&gt;cmdsize);
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

        <span class="enscript-comment">/* Verify that the file is big enough to contain the load command */</span>        
        require_action(size &gt;= offset + cmdsize, finish,
            rval=KERN_FAILURE;
            kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));
        <span class="enscript-keyword">switch</span>(cmd) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT_64</span>:
            <span class="enscript-comment">/* Get and swap the segment header */</span>
            seg_hdr = (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) load_hdr);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-keyword">if</span> (swap) swap_segment_command_64(seg_hdr, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-comment">/* Get and swap the section headers */</span>
            sects = (<span class="enscript-type">struct</span> section_64 *) &amp;seg_hdr[1];
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-keyword">if</span> (swap) swap_section_64(sects, seg_hdr-&gt;nsects, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-comment">/* If the segment has no vm footprint, skip it */</span>
            <span class="enscript-keyword">if</span> (!seg_hdr-&gt;vmsize) <span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">/* Verify that the file is big enough for the segment data. */</span>
            require_action(size &gt;= seg_hdr-&gt;fileoff + seg_hdr-&gt;filesize, finish, 
                rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

            <span class="enscript-keyword">for</span> (j = 0; j &lt; seg_hdr-&gt;nsects; ++j) {

                <span class="enscript-comment">/* Verify that, if the section is not to be zero filled on
                 * demand, that file is big enough for the section's data.
                 */</span>
                require_action((sects[j].flags &amp; S_ZEROFILL) ||
                    (size &gt;= sects[j].offset + sects[j].size), finish,
                    rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

                <span class="enscript-comment">/* Verify that the file is big enough for the section's
                 * relocation entries.
                 */</span>
                require_action(size &gt;= 
                    sects[j].reloff + sects[j].nreloc * <span class="enscript-keyword">sizeof</span>(*relocs), finish,
                    rval=KERN_FAILURE;
                    kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

                <span class="enscript-comment">/* Swap the relocation entries */</span>
                relocs = (<span class="enscript-type">struct</span> relocation_info *) ((<span class="enscript-type">void</span> *) (file + sects[j].reloff));
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
                <span class="enscript-keyword">if</span> (swap) {
                    swap_relocation_info(relocs, sects[j].nreloc, 
                        host_order);
                }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
            }

            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SYMTAB</span>:
            <span class="enscript-comment">/* Get and swap the symtab header */</span>
            symtab_hdr = (<span class="enscript-type">struct</span> symtab_command *) load_hdr;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-keyword">if</span> (swap) swap_symtab_command(symtab_hdr, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-comment">/* Verify that the file is big enough for the symbol table */</span>
            require_action(size &gt;= 
                symtab_hdr-&gt;symoff + symtab_hdr-&gt;nsyms * <span class="enscript-keyword">sizeof</span>(*symtab), finish, 
                rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

            <span class="enscript-comment">/* Verify that the file is big enough for the string table */</span>
            require_action(size &gt;= symtab_hdr-&gt;stroff + symtab_hdr-&gt;strsize, finish,
                rval=KERN_FAILURE;
                kxld_log(kKxldLogLinking, kKxldLogErr, kKxldLogTruncatedMachO));

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-comment">/* Swap the symbol table entries */</span>
            symtab = (<span class="enscript-type">struct</span> nlist_64 *) ((<span class="enscript-type">void</span> *) (file + symtab_hdr-&gt;symoff));
            <span class="enscript-keyword">if</span> (swap) swap_nlist_64(symtab, symtab_hdr-&gt;nsyms, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
            <span class="enscript-comment">/* Swap the load command */</span>
            <span class="enscript-keyword">if</span> (swap) swap_load_command(load_hdr, host_order);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
            <span class="enscript-keyword">break</span>;
        }
    }

    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">unswap_macho</span>(u_char *file, <span class="enscript-type">enum</span> NXByteOrder host_order, 
    <span class="enscript-type">enum</span> NXByteOrder target_order)
{
    <span class="enscript-type">struct</span> mach_header *hdr = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) file);

    <span class="enscript-keyword">if</span> (!hdr) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (hdr-&gt;magic == MH_MAGIC) {
        unswap_macho_32(file, host_order, target_order);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hdr-&gt;magic == MH_MAGIC_64) {
        unswap_macho_64(file, host_order, target_order);
    }
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">unswap_macho_32</span>(u_char *file, <span class="enscript-type">enum</span> NXByteOrder host_order, 
    <span class="enscript-type">enum</span> NXByteOrder target_order)
{
    <span class="enscript-type">struct</span> mach_header *mach_hdr = (<span class="enscript-type">struct</span> mach_header *) ((<span class="enscript-type">void</span> *) file);
    <span class="enscript-type">struct</span> load_command *load_hdr = NULL;
    <span class="enscript-type">struct</span> segment_command *seg_hdr = NULL;
    <span class="enscript-type">struct</span> section *sects = NULL;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    <span class="enscript-type">struct</span> nlist *symtab = NULL;
    u_long offset = 0;
    u_int cmd = 0;
    u_int size = 0;
    u_int i = 0; 

    check(file);

    <span class="enscript-keyword">if</span> (target_order == host_order) <span class="enscript-keyword">return</span>;

    offset = <span class="enscript-keyword">sizeof</span>(*mach_hdr);
    <span class="enscript-keyword">for</span>(i = 0; i &lt; mach_hdr-&gt;ncmds; ++i, offset += size) {
        load_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (file + offset));
        cmd = load_hdr-&gt;cmd;
        size = load_hdr-&gt;cmdsize;

        <span class="enscript-keyword">switch</span>(cmd) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT</span>:
            seg_hdr = (<span class="enscript-type">struct</span> segment_command *) load_hdr;
            sects = (<span class="enscript-type">struct</span> section *) &amp;seg_hdr[1];

            <span class="enscript-comment">/* We don't need to unswap relocations because this function is
             * called when linking is completed (so there are no relocations).
             */</span>

            swap_section(sects, seg_hdr-&gt;nsects, target_order);
            swap_segment_command(seg_hdr, target_order);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SYMTAB</span>:
            symtab_hdr = (<span class="enscript-type">struct</span> symtab_command *) load_hdr;
            symtab = (<span class="enscript-type">struct</span> nlist*) ((<span class="enscript-type">void</span> *) (file + symtab_hdr-&gt;symoff));

            swap_nlist(symtab, symtab_hdr-&gt;nsyms, target_order);
            swap_symtab_command(symtab_hdr, target_order);
            
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            swap_load_command(load_hdr, target_order);
            <span class="enscript-keyword">break</span>;
        }
    }

    (<span class="enscript-type">void</span>) swap_mach_header(mach_hdr, target_order);
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">unswap_macho_64</span>(u_char *file, <span class="enscript-type">enum</span> NXByteOrder host_order, 
    <span class="enscript-type">enum</span> NXByteOrder target_order)
{
    <span class="enscript-type">struct</span> mach_header_64 *mach_hdr = (<span class="enscript-type">struct</span> mach_header_64 *) ((<span class="enscript-type">void</span> *) file);
    <span class="enscript-type">struct</span> load_command *load_hdr = NULL;
    <span class="enscript-type">struct</span> segment_command_64 *seg_hdr = NULL;
    <span class="enscript-type">struct</span> section_64 *sects = NULL;
    <span class="enscript-type">struct</span> symtab_command *symtab_hdr = NULL;
    <span class="enscript-type">struct</span> nlist_64 *symtab = NULL;
    u_long offset = 0;
    u_int cmd = 0;
    u_int size = 0;
    u_int i = 0; 

    check(file);

    <span class="enscript-keyword">if</span> (target_order == host_order) <span class="enscript-keyword">return</span>;

    offset = <span class="enscript-keyword">sizeof</span>(*mach_hdr);
    <span class="enscript-keyword">for</span>(i = 0; i &lt; mach_hdr-&gt;ncmds; ++i, offset += size) {
        load_hdr = (<span class="enscript-type">struct</span> load_command *) ((<span class="enscript-type">void</span> *) (file + offset));
        cmd = load_hdr-&gt;cmd;
        size = load_hdr-&gt;cmdsize;

        <span class="enscript-keyword">switch</span>(cmd) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SEGMENT_64</span>:
            seg_hdr = (<span class="enscript-type">struct</span> segment_command_64 *) ((<span class="enscript-type">void</span> *) load_hdr);
            sects = (<span class="enscript-type">struct</span> section_64 *) &amp;seg_hdr[1];

            <span class="enscript-comment">/* We don't need to unswap relocations because this function is
             * called when linking is completed (so there are no relocations).
             */</span>

            swap_section_64(sects, seg_hdr-&gt;nsects, target_order);
            swap_segment_command_64(seg_hdr, target_order);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LC_SYMTAB</span>:
            symtab_hdr = (<span class="enscript-type">struct</span> symtab_command *) load_hdr;
            symtab = (<span class="enscript-type">struct</span> nlist_64 *) ((<span class="enscript-type">void</span> *) (file + symtab_hdr-&gt;symoff));

            swap_nlist_64(symtab, symtab_hdr-&gt;nsyms, target_order);
            swap_symtab_command(symtab_hdr, target_order);

            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            swap_load_command(load_hdr, target_order);
            <span class="enscript-keyword">break</span>;
        }
    }

    (<span class="enscript-type">void</span>) swap_mach_header_64(mach_hdr, target_order);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>
    
<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
kxld_addr_t
<span class="enscript-function-name">kxld_align_address</span>(kxld_addr_t address, u_int align)
{
    kxld_addr_t alignment = (1 &lt;&lt; align);
    kxld_addr_t low_bits = 0;

    <span class="enscript-keyword">if</span> (!align) <span class="enscript-keyword">return</span> address;

    low_bits = (address) &amp; (alignment - 1);
    <span class="enscript-keyword">if</span> (low_bits) {
        address += (alignment - low_bits);
    }

    <span class="enscript-keyword">return</span> address;
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
boolean_t
<span class="enscript-function-name">kxld_is_32_bit</span>(cpu_type_t cputype)
{
    <span class="enscript-keyword">return</span> !(cputype &amp; CPU_ARCH_ABI64);
}

<span class="enscript-comment">/*******************************************************************************
* Borrowed (and slightly modified) the libc implementation for the kernel 
* until the kernel has a supported strstr().
* Find the first occurrence of find in s.
*******************************************************************************/</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">kxld_strstr</span>(s, find)
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, *find;
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-type">char</span> c, sc;
    size_t len;

    <span class="enscript-keyword">if</span> ((c = *find++) != 0) {
        len = strlen(find);
        <span class="enscript-keyword">do</span> {
            <span class="enscript-keyword">do</span> {
                <span class="enscript-keyword">if</span> ((sc = *s++) == 0)
                    <span class="enscript-keyword">return</span> (NULL);
            } <span class="enscript-keyword">while</span> (sc != c);
        } <span class="enscript-keyword">while</span> (strncmp(s, find, len) != 0);
        s--;
    }
    <span class="enscript-keyword">return</span> s;
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> strstr(s, find);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
}

<span class="enscript-comment">/*******************************************************************************
*******************************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_print_memory_report</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    kxld_log(kKxldLogLinking, kKxldLogExplicit, <span class="enscript-string">&quot;kxld memory usage report:\n&quot;</span>
        <span class="enscript-string">&quot;\tNumber of allocations:   %8lu\n&quot;</span>
        <span class="enscript-string">&quot;\tNumber of frees:         %8lu\n&quot;</span>
        <span class="enscript-string">&quot;\tAverage allocation size: %8lu\n&quot;</span>
        <span class="enscript-string">&quot;\tTotal bytes allocated:   %8lu\n&quot;</span>
        <span class="enscript-string">&quot;\tTotal bytes freed:       %8lu\n&quot;</span>
        <span class="enscript-string">&quot;\tTotal bytes leaked:      %8lu&quot;</span>,
        num_allocations, num_frees, bytes_allocated / num_allocations,
        bytes_allocated, bytes_freed, bytes_allocated - bytes_freed);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">KERNEL</span>
boolean_t <span class="enscript-function-name">kxld_set_cross_link_page_size</span>(kxld_size_t target_page_size)
{
    <span class="enscript-comment">// verify radix 2
</span>    <span class="enscript-keyword">if</span> ((target_page_size != 0) &amp;&amp; 
        ((target_page_size &amp; (target_page_size - 1)) == 0)) {

        s_cross_link_enabled = TRUE;
        s_cross_link_page_size = target_page_size;

        <span class="enscript-keyword">return</span> TRUE;   
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> FALSE;
    }
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !KERNEL */</span>

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
kxld_size_t <span class="enscript-function-name">kxld_get_effective_page_size</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">return</span> PAGE_SIZE;
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">if</span> (s_cross_link_enabled) {
        <span class="enscript-keyword">return</span> s_cross_link_page_size;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> PAGE_SIZE;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
kxld_addr_t <span class="enscript-function-name">kxld_round_page_cross_safe</span>(kxld_addr_t offset)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL</span>
    <span class="enscript-keyword">return</span> round_page(offset);
#<span class="enscript-reference">else</span>
    <span class="enscript-comment">// assume s_cross_link_page_size is power of 2
</span>    <span class="enscript-keyword">if</span> (s_cross_link_enabled) {
        <span class="enscript-keyword">return</span> (offset + (s_cross_link_page_size - 1)) &amp; 
               (~(s_cross_link_page_size - 1));
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> round_page(offset);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
}
</pre>
<hr />
</body></html>