<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>WKdmDecompress.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">WKdmDecompress.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;WKdm.h&quot;</span>

<span class="enscript-comment">/***************************************************************************
 *          THE UNPACKING ROUTINES should GO HERE
 */</span>

<span class="enscript-type">const</span> <span class="enscript-type">char</span> hashLookupTable [] = HASH_LOOKUP_TABLE_CONTENTS;

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GET_NEXT_TAG</span> tags[tagsIndex++]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GET_NEXT_FULL_PATTERN</span> fullPatterns[fullPatternsIndex++]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GET_NEXT_LOW_BITS</span> lowBits[lowBitsIndex++]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GET_NEXT_DICTIONARY_INDEX</span> dictionaryIndices[dictionaryIndicesIndex++]
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*  WK_unpack_2bits takes any number of words containing 16 two-bit values
 *  and unpacks them into four times as many words containg those
 *  two bit values as bytes (with the low two bits of each byte holding
 *  the actual value.
 */</span>
<span class="enscript-type">static</span> WK_word*
<span class="enscript-function-name">WK_unpack_2bits</span>(WK_word *input_buf,
                WK_word *input_end,
                WK_word *output_buf) {

  <span class="enscript-type">register</span> WK_word *input_next = input_buf;
  <span class="enscript-type">register</span> WK_word *output_next = output_buf;
  <span class="enscript-type">register</span> WK_word packing_mask = TWO_BITS_PACKING_MASK;

  <span class="enscript-comment">/* loop to repeatedly grab one input word and unpack it into
   * 4 output words.  This loop could be unrolled a little---it's
   * designed to be easy to do that.
   */</span>   
  <span class="enscript-keyword">while</span> (input_next &lt; input_end) {
    <span class="enscript-type">register</span> WK_word temp = input_next[0];
    DEBUG_PRINT_2(<span class="enscript-string">&quot;Unpacked tags word: %.8x\n&quot;</span>, temp);
    output_next[0] = temp &amp; packing_mask;
    output_next[1] = (temp &gt;&gt; 2) &amp; packing_mask;
    output_next[2] = (temp &gt;&gt; 4) &amp; packing_mask;
    output_next[3] = (temp &gt;&gt; 6) &amp; packing_mask;
    
    output_next += 4;
    input_next++;
  }

  <span class="enscript-keyword">return</span> output_next;

}

<span class="enscript-comment">/* unpack four bits consumes any number of words (between input_buf
 * and input_end) holding 8 4-bit values per word, and unpacks them
 * into twice as many words, with each value in a separate byte.
 * (The four-bit values occupy the low halves of the bytes in the
 * result).
 */</span>
<span class="enscript-type">static</span> WK_word*
<span class="enscript-function-name">WK_unpack_4bits</span>(WK_word *input_buf,
                WK_word *input_end,
                WK_word *output_buf) {

  <span class="enscript-type">register</span> WK_word *input_next = input_buf;
  <span class="enscript-type">register</span> WK_word *output_next = output_buf;
  <span class="enscript-type">register</span> WK_word packing_mask = FOUR_BITS_PACKING_MASK;
  
  
  <span class="enscript-comment">/* loop to repeatedly grab one input word and unpack it into
   * 4 output words.  This loop should probably be unrolled
   * a little---it's designed to be easy to do that.
   */</span>   
  <span class="enscript-keyword">while</span> (input_next &lt; input_end) {
    <span class="enscript-type">register</span> WK_word temp = input_next[0];
    DEBUG_PRINT_2(<span class="enscript-string">&quot;Unpacked dictionary indices word: %.8x\n&quot;</span>, temp);
    output_next[0] = temp &amp; packing_mask;
    output_next[1] = (temp &gt;&gt; 4) &amp; packing_mask;
    
    output_next += 2;
    input_next++;
  }
  
  <span class="enscript-keyword">return</span> output_next;

}

<span class="enscript-comment">/* unpack_3_tenbits unpacks three 10-bit items from (the low 30 bits of)
 * a 32-bit word
 */</span>
<span class="enscript-type">static</span> WK_word*
<span class="enscript-function-name">WK_unpack_3_tenbits</span>(WK_word *input_buf,
                    WK_word *input_end,
                    WK_word *output_buf) {

  <span class="enscript-type">register</span> WK_word *input_next = input_buf;
  <span class="enscript-type">register</span> WK_word *output_next = output_buf;
  <span class="enscript-type">register</span> WK_word packing_mask = LOW_BITS_MASK;
  
  <span class="enscript-comment">/* loop to fetch words of input, splitting each into three
   * words of output with 10 meaningful low bits.  This loop
   * probably ought to be unrolled and maybe coiled
   */</span>
  <span class="enscript-keyword">while</span> (input_next &lt; input_end) {
    <span class="enscript-type">register</span> WK_word temp = input_next[0];
    
    output_next[0] = temp &amp; packing_mask;
    output_next[1] = (temp &gt;&gt; 10) &amp; packing_mask;
    output_next[2] = temp &gt;&gt; 20;
    
    input_next++;
    output_next += 3;
  }
  
  <span class="enscript-keyword">return</span> output_next;

}

<span class="enscript-comment">/*********************************************************************
 * WKdm_decompress --- THE DECOMPRESSOR                                 
 * Expects WORD pointers to the source and destination buffers
 * and a page size in words.  The page size had better be 1024 unless     
 * somebody finds the places that are dependent on the page size and 
 * fixes them
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">WKdm_decompress</span> (WK_word* src_buf,
		 WK_word* dest_buf,
		 __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> words)
{

  DictionaryElement dictionary[DICTIONARY_SIZE];

  <span class="enscript-comment">/* arrays that hold output data in intermediate form during modeling */</span>
  <span class="enscript-comment">/* and whose contents are packed into the actual output after modeling */</span>

  <span class="enscript-comment">/* sizes of these arrays should be increased if you want to compress
   * pages larger than 4KB
   */</span>
  WK_word tempTagsArray[300];        <span class="enscript-comment">/* tags for everything          */</span>
  WK_word tempQPosArray[300];        <span class="enscript-comment">/* queue positions for matches  */</span>
  WK_word tempLowBitsArray[1200];    <span class="enscript-comment">/* low bits for partial matches */</span>

  PRELOAD_DICTIONARY;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  printf(<span class="enscript-string">&quot;\nIn DECOMPRESSOR\n&quot;</span>);
  printf(<span class="enscript-string">&quot;tempTagsArray is at %p\n&quot;</span>, tempTagsArray);
  printf(<span class="enscript-string">&quot;tempQPosArray is at %p\n&quot;</span>, tempQPosArray);
  printf(<span class="enscript-string">&quot;tempLowBitsArray is at %p\n&quot;</span>, tempLowBitsArray);

  printf(<span class="enscript-string">&quot; first four words of source buffer are:\n&quot;</span>);
  printf(<span class="enscript-string">&quot;   %u\n   %u\n   %u\n   %u\n&quot;</span>,
         src_buf[0], src_buf[1], src_buf[2], src_buf[3]);
  
  { <span class="enscript-type">int</span> i;
    WK_word *arr =(src_buf + TAGS_AREA_OFFSET + (PAGE_SIZE_IN_WORDS / 16));

    printf(<span class="enscript-string">&quot;  first 20 full patterns are: \n&quot;</span>);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 20; i++) {
      printf(<span class="enscript-string">&quot; %d&quot;</span>, arr[i]);
    }
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
  }
#<span class="enscript-reference">endif</span>

  WK_unpack_2bits(TAGS_AREA_START(src_buf),
                  TAGS_AREA_END(src_buf),
                  tempTagsArray);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  { <span class="enscript-type">int</span> i;
    <span class="enscript-type">char</span>* arr = (<span class="enscript-type">char</span> *) tempTagsArray;

    printf(<span class="enscript-string">&quot;  first 200 tags are: \n&quot;</span>);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 200; i++) {
      printf(<span class="enscript-string">&quot; %d&quot;</span>, arr[i]);
    }
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
  }
#<span class="enscript-reference">endif</span>

  WK_unpack_4bits(QPOS_AREA_START(src_buf),
                  QPOS_AREA_END(src_buf),
                  tempQPosArray);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  { <span class="enscript-type">int</span> i;
    <span class="enscript-type">char</span>* arr = (<span class="enscript-type">char</span> *) tempQPosArray;

    printf(<span class="enscript-string">&quot;  first 200 queue positions are: \n&quot;</span>);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 200; i++) {
      printf(<span class="enscript-string">&quot; %d&quot;</span>, arr[i]);
    }
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
  }
#<span class="enscript-reference">endif</span>

  WK_unpack_3_tenbits(LOW_BITS_AREA_START(src_buf),
                      LOW_BITS_AREA_END(src_buf),
                      tempLowBitsArray);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
  printf(<span class="enscript-string">&quot;AFTER UNPACKING, about to enter main block \n&quot;</span>);
#<span class="enscript-reference">endif</span>

  {
    <span class="enscript-type">register</span> <span class="enscript-type">char</span> *next_tag = (<span class="enscript-type">char</span> *) tempTagsArray;
    <span class="enscript-type">char</span> *tags_area_end =
       ((<span class="enscript-type">char</span> *) tempTagsArray) + PAGE_SIZE_IN_WORDS;
    <span class="enscript-type">char</span> *next_q_pos = (<span class="enscript-type">char</span> *) tempQPosArray;
    WK_word *next_low_bits = tempLowBitsArray;
    WK_word *next_full_word = FULL_WORD_AREA_START(src_buf);

    WK_word *next_output = dest_buf;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>
    printf(<span class="enscript-string">&quot;next_output is %u\n&quot;</span>, next_output);

    printf(<span class="enscript-string">&quot;next_tag is %u \n&quot;</span>, next_tag);
    printf(<span class="enscript-string">&quot;tags_area_end is %u\n&quot;</span>, tags_area_end);
    printf(<span class="enscript-string">&quot;next_q_pos is %u\n&quot;</span>, next_q_pos);
    printf(<span class="enscript-string">&quot;next_low_bits is %u\n&quot;</span>, next_low_bits);
    printf(<span class="enscript-string">&quot;next_full_word is %u\n&quot;</span>, next_full_word);
#<span class="enscript-reference">endif</span> 

    <span class="enscript-comment">/* this loop should probably be unrolled. Maybe we should unpack
     * as 4 bit values, giving two consecutive tags, and switch on
     * that 16 ways to decompress 2 words at a whack
     */</span>
    <span class="enscript-keyword">while</span> (next_tag &lt; tags_area_end) {

       <span class="enscript-type">char</span> tag = next_tag[0];

       <span class="enscript-keyword">switch</span>(tag) {

         <span class="enscript-keyword">case</span> <span class="enscript-reference">ZERO_TAG</span>: {
            *next_output = 0;
            <span class="enscript-keyword">break</span>;
         }
         <span class="enscript-keyword">case</span> <span class="enscript-reference">EXACT_TAG</span>: {
            WK_word *dict_location = dictionary + *(next_q_pos++);
            <span class="enscript-comment">/* no need to replace dict. entry if matched exactly */</span>
            *next_output = *dict_location;
            <span class="enscript-keyword">break</span>;
         }
         <span class="enscript-keyword">case</span> <span class="enscript-reference">PARTIAL_TAG</span>: {
            WK_word *dict_location = dictionary + *(next_q_pos++);
            {
               WK_word temp = *dict_location;

               <span class="enscript-comment">/* strip out low bits */</span>
               temp = ((temp &gt;&gt; NUM_LOW_BITS) &lt;&lt; NUM_LOW_BITS);

               <span class="enscript-comment">/* add in stored low bits from temp array */</span>
               temp = temp | *(next_low_bits++);

               *dict_location = temp;      <span class="enscript-comment">/* replace old value in dict. */</span>
               *next_output = temp;    <span class="enscript-comment">/* and echo it to output */</span>
            }
            <span class="enscript-keyword">break</span>;
         }
         <span class="enscript-keyword">case</span> <span class="enscript-reference">MISS_TAG</span>: {
            WK_word missed_word = *(next_full_word++);
            WK_word *dict_location = 
              (WK_word *)
              ((<span class="enscript-type">void</span> *) (((<span class="enscript-type">char</span> *) dictionary) + HASH_TO_DICT_BYTE_OFFSET(missed_word)));
            *dict_location = missed_word;
            *next_output = missed_word;
            <span class="enscript-keyword">break</span>;
         }
       }
       next_tag++;
       next_output++;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WK_DEBUG</span>        
    printf(<span class="enscript-string">&quot;AFTER DECOMPRESSING\n&quot;</span>);
    printf(<span class="enscript-string">&quot;next_output is %p\n&quot;</span>, next_output);
    printf(<span class="enscript-string">&quot;next_tag is %p\n&quot;</span>, next_tag);
    printf(<span class="enscript-string">&quot;next_full_word is %p\n&quot;</span>, next_full_word);
    printf(<span class="enscript-string">&quot;next_q_pos is %p\n&quot;</span>, next_q_pos);
#<span class="enscript-reference">endif</span>
  }
}
</pre>
<hr />
</body></html>