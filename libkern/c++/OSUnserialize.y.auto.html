<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSUnserialize.y</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSUnserialize.y&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*  OSUnserialize.y created by rsulack on Nov 21 1998 */

// 		&quot;classic&quot; parser for unserializing OSContainer objects
//
//  XXX - this code should really be removed!
//	- the XML format is now prefered
//	- this code leaks on syntax errors, the XML doesn't
//	- &quot;classic&quot; looks, reads, ... much better than XML :-(
//	- well except the XML is more efficent on OSData
//
//
// to build :
//	bison -p OSUnserialize OSUnserialize.y
//	head -50 OSUnserialize.y &gt; OSUnserialize.cpp
//	sed -e &quot;s/stdio.h/stddef.h/&quot; &lt; OSUnserialize.tab.c &gt;&gt; OSUnserialize.cpp
//
//	when changing code check in both OSUnserialize.y and OSUnserialize.cpp
//
//
//
//
//		 DO NOT EDIT OSUnserialize.tab.cpp!
//
//			this means you!
//
//
//
//
//

     
%{
#include &lt;libkern/c++/OSMetaClass.h&gt;
#include &lt;libkern/c++/OSContainers.h&gt;
#include &lt;libkern/c++/OSLib.h&gt;

typedef	struct object {
	struct object	*next;
	struct object	*prev;
	void		*object;
	int		size;		// for data
	union {
		void	*key;		// for dictionary
		long long offset;	// for offset
	} u;

} object_t;

static int yyerror(const char *s);
static int yylex();

static object_t * newObject();
static void freeObject(object_t *o);

static OSObject *buildOSDictionary(object_t *);
static OSObject *buildOSArray(object_t *);
static OSObject *buildOSSet(object_t *);
static OSObject *buildOSString(object_t *);
static OSObject *buildOSData(object_t *);
static OSObject *buildOSOffset(object_t *);
static OSObject *buildOSBoolean(object_t *o);

static void rememberObject(int, object_t *);
static OSObject *retrieveObject(int);

// temp variable to use during parsing
static object_t *oo;

// resultant object of parsed text
static OSObject	*parsedObject;

#define YYSTYPE object_t *

extern &quot;C&quot; {
extern void *kern_os_malloc(size_t size);
extern void *kern_os_realloc(void * addr, size_t size);
extern void kern_os_free(void * addr);
} /* extern &quot;C&quot; */

#define malloc(s) kern_os_malloc(s)
#define realloc(a, s) kern_os_realloc(a, s)
#define free(a) kern_os_free(a)

%}
%token NUMBER
%token STRING
%token DATA
%token BOOLEAN
%token SYNTAX_ERROR
     
%% /* Grammar rules and actions follow */

input:	  /* empty */		{ parsedObject = (OSObject *)NULL; YYACCEPT; }
	| object		{ parsedObject = (OSObject *)$1;   YYACCEPT; }
	| SYNTAX_ERROR		{ yyerror(&quot;syntax error&quot;);	   YYERROR; }
	;

object:	  dict			{ $$ = (object_t *)buildOSDictionary($1); }
	| array			{ $$ = (object_t *)buildOSArray($1); }
	| set			{ $$ = (object_t *)buildOSSet($1); }
	| string		{ $$ = (object_t *)buildOSString($1); }
	| data			{ $$ = (object_t *)buildOSData($1); }
	| offset		{ $$ = (object_t *)buildOSOffset($1); }
	| boolean		{ $$ = (object_t *)buildOSBoolean($1); }
	| '@' NUMBER		{ $$ = (object_t *)retrieveObject($2-&gt;u.offset);
				  if ($$) {
				    ((OSObject *)$$)-&gt;retain();
				  } else { 
				    yyerror(&quot;forward reference detected&quot;);
				    YYERROR;
				  }
				  freeObject($2); 
				}
	| object '@' NUMBER	{ $$ = $1; 
				  rememberObject($3-&gt;u.offset, $1);
				  freeObject($3); 
				}
	;

//------------------------------------------------------------------------------

dict:	  '{' '}'		{ $$ = NULL; }
	| '{' pairs '}'		{ $$ = $2; }
	;

pairs:	  pair
	| pairs pair		{ $2-&gt;next = $1; $1-&gt;prev = $2; $$ = $2; }
	;

pair:	  object '=' object ';'	{ $$ = newObject();
				  $$-&gt;next = NULL; 
				  $$-&gt;prev = NULL;
				  $$-&gt;u.key = $1;
				  $$-&gt;object = $3; 
				}
	;

//------------------------------------------------------------------------------

array:	  '(' ')'		{ $$ = NULL; }
	| '(' elements ')'	{ $$ = $2; }
	;

set:	  '[' ']'		{ $$ = NULL; }
	| '[' elements ']'	{ $$ = $2; }
	;

elements: object		{ $$ = newObject(); 
				  $$-&gt;object = $1; 
				  $$-&gt;next = NULL; 
				  $$-&gt;prev = NULL; 
				}
	| elements ',' object	{ oo = newObject();
				  oo-&gt;object = $3;
				  oo-&gt;next = $1;
				  oo-&gt;prev = NULL; 
				  $1-&gt;prev = oo;
				  $$ = oo; 
				}
	;

//------------------------------------------------------------------------------

offset:	  NUMBER ':' NUMBER	{ $$ = $1;
				  $$-&gt;size = $3-&gt;u.offset;
				  freeObject($3); 
				}
	;

//------------------------------------------------------------------------------

data:	  DATA
	;

//------------------------------------------------------------------------------

string:	  STRING
	;

//------------------------------------------------------------------------------

boolean:  BOOLEAN
	;

%%
     
static int		lineNumber = 0;
static const char	*parseBuffer;
static int		parseBufferIndex;

#define currentChar()	(parseBuffer[parseBufferIndex])
#define nextChar()	(parseBuffer[++parseBufferIndex])
#define prevChar()	(parseBuffer[parseBufferIndex - 1])

#define isSpace(c)	((c) == ' ' || (c) == '\t')
#define isAlpha(c)	(((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z') || ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z'))
#define isDigit(c)	((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
#define isAlphaDigit(c)	((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f')
#define isHexDigit(c)	(isDigit(c) || isAlphaDigit(c))
#define isAlphaNumeric(c) (isAlpha(c) || isDigit(c) || ((c) == '-')) 

static char yyerror_message[128];

int
yyerror(const char *s)  /* Called by yyparse on error */
{
	snprintf(yyerror_message, sizeof(yyerror_message), &quot;OSUnserialize: %s near line %d\n&quot;, s, lineNumber);
	return 0;
}

int
yylex()
{
	int c;

	if (parseBufferIndex == 0) lineNumber = 1;

 top:
	c = currentChar();

	/* skip white space  */
	if (isSpace(c)) while ((c = nextChar()) != 0 &amp;&amp; isSpace(c)) {};

	/* skip over comments */
	if (c == '#') while ((c = nextChar()) != 0 &amp;&amp; c != '\n') {};

	/* keep track of line number, don't return \n's */
	if (c == '\n') {
		lineNumber++;
		(void)nextChar();
		goto top;
	}

	/* parse boolean */
	if (c == '.') {
		bool boolean = false;
		if (nextChar() == 't') {
			if (nextChar() != 'r') return SYNTAX_ERROR;
			if (nextChar() != 'u') return SYNTAX_ERROR;
			if (nextChar() != 'e') return SYNTAX_ERROR;
			boolean = true;
		} else {
			if (currentChar() != 'f') return SYNTAX_ERROR;
			if (nextChar() != 'a') return SYNTAX_ERROR;
			if (nextChar() != 'l') return SYNTAX_ERROR;
			if (nextChar() != 's') return SYNTAX_ERROR;
			if (nextChar() != 'e') return SYNTAX_ERROR;
		}
		if (nextChar() != '.') return SYNTAX_ERROR;
		/* skip over dot */
		(void)nextChar();

		yylval = (object_t *)boolean;
		return BOOLEAN;
	}

	/* parse unquoted string */
	if (isAlpha(c)) {
		int start, length;
		char * tempString;

		start = parseBufferIndex;
		/* find end of string */
		while (isAlphaNumeric(c)) { 
			c = nextChar();
		}
		length = parseBufferIndex - start;

		/* copy to null terminated buffer */
		tempString = (char *)malloc(length + 1);
		if (tempString == 0) {
			printf(&quot;OSUnserialize: can't alloc temp memory\n&quot;);
			return 0;
		}
		bcopy(&amp;parseBuffer[start], tempString, length);
		tempString[length] = 0;
		yylval = (object_t *)tempString;
		return STRING;
	}

	/* parse quoted string */
	if (c == '&quot;' || c == '\'') {
		int start, length;
		char * tempString;
		char quoteChar = c;

		start = parseBufferIndex + 1;		// skip quote
		/* find end of string, line, buffer */
		while ((c = nextChar()) != quoteChar) {
			if (c == '\\') c = nextChar();
			if (c == '\n') lineNumber++;
			if (c == 0) return SYNTAX_ERROR;
		}
		length = parseBufferIndex - start;
		/* skip over trailing quote */
		(void)nextChar();
		/* copy to null terminated buffer */
		tempString = (char *)malloc(length + 1);
		if (tempString == 0) {
			printf(&quot;OSUnserialize: can't alloc temp memory\n&quot;);
			return 0;
		}

		int to = 0;
		for (int from=start; from &lt; parseBufferIndex; from++) {
			// hack - skip over backslashes
			if (parseBuffer[from] == '\\') {
				length--;
				continue;
			}
			tempString[to] = parseBuffer[from]; 
			to++;
		}
		tempString[length] = 0;
		yylval = (object_t *)tempString;
		return STRING;
	}

	/* process numbers */
	if (isDigit (c))
	{
		unsigned long long n = 0;
		int base = 10;

		if (c == '0') {
			c = nextChar();
			if (c == 'x') {
				base = 16;
				c = nextChar();
			}
		}
		if (base == 10) {
			while(isDigit(c)) {
				n = (n * base + c - '0');
				c = nextChar();
			}
		} else {
			while(isHexDigit(c)) {
				if (isDigit(c)) {
					n = (n * base + c - '0');
				} else {
					n = (n * base + 0xa + c - 'a');
				}
				c = nextChar();
			}
		}

		yylval = newObject();
		yylval-&gt;u.offset = n;
			
		return NUMBER;
	}

#define OSDATA_ALLOC_SIZE 4096
	
	/* process data */
	if (c == '&lt;') {
		unsigned char *d, *start, *lastStart;

		start = lastStart = d = (unsigned char *)malloc(OSDATA_ALLOC_SIZE);
		c = nextChar();	// skip over '&lt;'
		while (c != 0 &amp;&amp; c != '&gt;') {

			if (isSpace(c)) while ((c = nextChar()) != 0 &amp;&amp; isSpace(c)) {};
			if (c == '#') while ((c = nextChar()) != 0 &amp;&amp; c != '\n') {};
			if (c == '\n') {
				lineNumber++;
				c = nextChar();
				continue;
			}

			// get high nibble
			if (!isHexDigit(c)) break;
			if (isDigit(c)) {
				*d = (c - '0') &lt;&lt; 4;
			} else {
				*d =  (0xa + (c - 'a')) &lt;&lt; 4;
			}

			// get low nibble
			c = nextChar();
			if (!isHexDigit(c)) break;
			if (isDigit(c)) {
				*d |= c - '0';
			} else {
				*d |= 0xa + (c - 'a');
			}
	
			d++;
			if ((d - lastStart) &gt;= OSDATA_ALLOC_SIZE) {
				int oldsize = d - start;
				start = (unsigned char *)realloc(start, oldsize + OSDATA_ALLOC_SIZE);
				d = lastStart = start + oldsize;
			}
			c = nextChar();
		}
		if (c != '&gt;' ) {
			free(start);
			return SYNTAX_ERROR;
		}

		// got it!
		yylval = newObject();
		yylval-&gt;object = start;
		yylval-&gt;size = d - start;

		(void)nextChar();	// skip over '&gt;'
		return DATA;
	}


	/* return single chars, move pointer to next char */
	(void)nextChar();
	return c;
}

// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#

#if DEBUG
int debugUnserializeAllocCount = 0;
#endif

object_t *
newObject()
{
#if DEBUG
	debugUnserializeAllocCount++;
#endif
	return (object_t *)malloc(sizeof(object_t));
}

void
freeObject(object_t *o)
{
#if DEBUG
	debugUnserializeAllocCount--;
#endif
	free(o);
}

static OSDictionary *tags;

static void 
rememberObject(int tag, object_t *o)
{
	char key[16];
	snprintf(key, sizeof(key), &quot;%u&quot;, tag);

	tags-&gt;setObject(key, (OSObject *)o);
}

static OSObject *
retrieveObject(int tag)
{
	char key[16];
	snprintf(key, sizeof(key), &quot;%u&quot;, tag);

	return tags-&gt;getObject(key);
}

OSObject *
buildOSDictionary(object_t *o)
{
	object_t *temp, *last = o;
	int count = 0;

	// get count and last object
	while (o) {
		count++;
		last = o;
		o = o-&gt;next;
	}
	o = last;

	OSDictionary *d = OSDictionary::withCapacity(count);

	while (o) {
#ifdef metaclass_stuff_worksXXX
		if (((OSObject *)o-&gt;u.key)-&gt;metaCast(&quot;OSSymbol&quot;)) {
			// XXX the evil frontdoor
			d-&gt;setObject((OSSymbol *)o-&gt;u.key, (OSObject *)o-&gt;object);
		} else {
                        // If it isn't a symbol, I hope it's a string!
			d-&gt;setObject((OSString *)o-&gt;u.key, (OSObject *)o-&gt;object);
		}
#else
		d-&gt;setObject((OSString *)o-&gt;u.key, (OSObject *)o-&gt;object);
#endif
		((OSObject *)o-&gt;object)-&gt;release();
		((OSObject *)o-&gt;u.key)-&gt;release();
		temp = o;
		o = o-&gt;prev;
		freeObject(temp);
	}
	return d;
};

OSObject *
buildOSArray(object_t *o)
{
	object_t *temp, *last = o;
	int count = 0;

	// get count and last object
	while (o) {
		count++;
		last = o;
		o = o-&gt;next;
	}
	o = last;

	OSArray *a = OSArray::withCapacity(count);

	while (o) {
		a-&gt;setObject((OSObject *)o-&gt;object);
		((OSObject *)o-&gt;object)-&gt;release();
		temp = o;
		o = o-&gt;prev;
		freeObject(temp);
	}
	return a;
};

OSObject *
buildOSSet(object_t *o)
{
	OSArray *a = (OSArray *)buildOSArray(o);
	OSSet *s = OSSet::withArray(a, a-&gt;getCapacity());

	a-&gt;release();
	return s;
};

OSObject *
buildOSString(object_t *o)
{
	OSString *s = OSString::withCString((char *)o);

	free(o);

	return s;
};

OSObject *
buildOSData(object_t *o)
{
	OSData *d;

	if (o-&gt;size) {
		d = OSData::withBytes(o-&gt;object, o-&gt;size);
	} else {
		d = OSData::withCapacity(0);
	}
	free(o-&gt;object);
	freeObject(o);
	return d;
};

OSObject *
buildOSOffset(object_t *o)
{
	OSNumber *off = OSNumber::withNumber(o-&gt;u.offset, o-&gt;size);
	freeObject(o);
	return off;
};

OSObject *
buildOSBoolean(object_t *o)
{
	OSBoolean *b = OSBoolean::withBoolean((bool)o);
	return b;
};

__BEGIN_DECLS
#include &lt;kern/locks.h&gt;
__END_DECLS

static lck_mtx_t *lock = 0;
extern lck_grp_t *IOLockGroup;

OSObject*
OSUnserialize(const char *buffer, OSString **errorString)
{
	OSObject *object;

	if (!lock) {
		lock = lck_mtx_alloc_init(IOLockGroup, LCK_ATTR_NULL);
		lck_mtx_lock(lock);
	} else {
		lck_mtx_lock(lock);

	}

#if DEBUG
	debugUnserializeAllocCount = 0;
#endif
	yyerror_message[0] = 0;	//just in case
	parseBuffer = buffer;
	parseBufferIndex = 0;
	tags = OSDictionary::withCapacity(128);
	if (yyparse() == 0) {
		object = parsedObject;
		if (errorString) *errorString = 0;
	} else {
		object = 0;
		if (errorString)
			*errorString = OSString::withCString(yyerror_message);
	}

	tags-&gt;release();
#if DEBUG
	if (debugUnserializeAllocCount) {
		printf(&quot;OSUnserialize: allocation check failed, count = %d.\n&quot;, 
		       debugUnserializeAllocCount);
	}
#endif
	lck_mtx_unlock(lock);

	return object;
}


//
//
//
//
//
//		 DO NOT EDIT OSUnserialize.cpp!
//
//			this means you!
//
//
//
//
//
</pre>
<hr />
</body></html>