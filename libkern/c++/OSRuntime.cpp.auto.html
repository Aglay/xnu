<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSRuntime.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSRuntime.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000,2008-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1997 Apple Inc.
 *
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSMetaClass.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSSymbol.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

__BEGIN_DECLS

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Constants</span> &amp;<span class="enscript-variable-name">c</span>.
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRAGMA_MARK */</span>
OSKextLogSpec kOSRuntimeLogSpec =
    kOSKextLogErrorLevel |
    kOSKextLogLoadFlag |
    kOSKextLogKextBookkeepingFlag;
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Logging</span> <span class="enscript-variable-name">Bootstrap</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRAGMA_MARK */</span>
<span class="enscript-comment">/*********************************************************************
* kern_os Logging Bootstrap
*
* We can't call in to OSKext until the kernel's C++ environment is up
* and running, so let's mask those references with a check variable.
* We print unconditionally if C++ isn't up, but if that's the case
* we've generally hit a serious error in kernel init!
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> gKernelCPPInitialized = false;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSRuntimeLog</span>(kext, flags, format, args...)            \
    <span class="enscript-keyword">do</span> {                                                      \
        <span class="enscript-keyword">if</span> (gKernelCPPInitialized) {                          \
            OSKextLog((kext), (flags), (format), ## args);  \
        } <span class="enscript-keyword">else</span> {                                              \
            printf((format), ## args);                        \
        }                                                     \
    } <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">kern_os</span> <span class="enscript-variable-name">Allocator</span> <span class="enscript-variable-name">Package</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRAGMA_MARK */</span>
<span class="enscript-comment">/*********************************************************************
* kern_os Allocator Package
*********************************************************************/</span>

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">OSALLOCDEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> debug_iomalloc_size;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> _mhead {
    size_t  mlen;
    <span class="enscript-type">char</span>    dat[0];
};

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">kern_os_malloc</span>(size_t size)
{
    <span class="enscript-type">struct</span> _mhead * mem;
    size_t          memsize = <span class="enscript-keyword">sizeof</span> (*mem) + size ;

    <span class="enscript-keyword">if</span> (size == 0) {
        <span class="enscript-keyword">return</span> (0);
    }

    mem = (<span class="enscript-type">struct</span> _mhead *)kalloc_tag_bt(memsize, VM_KERN_MEMORY_LIBKERN);
    <span class="enscript-keyword">if</span> (!mem) {
        <span class="enscript-keyword">return</span> (0);
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">OSALLOCDEBUG</span>
    debug_iomalloc_size += memsize;
#<span class="enscript-reference">endif</span>

    mem-&gt;mlen = memsize;
    bzero(mem-&gt;dat, size);

    <span class="enscript-keyword">return</span> mem-&gt;dat;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kern_os_free</span>(<span class="enscript-type">void</span> * addr)
{
    <span class="enscript-type">struct</span> _mhead * hdr;

    <span class="enscript-keyword">if</span> (!addr) {
        <span class="enscript-keyword">return</span>;
    }

    hdr = (<span class="enscript-type">struct</span> _mhead *)addr; 
    hdr--;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">OSALLOCDEBUG</span>
    debug_iomalloc_size -= hdr-&gt;mlen;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
    memset((vm_offset_t)hdr, 0xbb, hdr-&gt;mlen);
#<span class="enscript-reference">else</span>
    kfree(hdr, hdr-&gt;mlen);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">kern_os_realloc</span>(
    <span class="enscript-type">void</span>   * addr,
    size_t   nsize)
{
    <span class="enscript-type">struct</span> _mhead * ohdr;
    <span class="enscript-type">struct</span> _mhead * nmem;
    size_t          nmemsize, osize;

    <span class="enscript-keyword">if</span> (!addr) {
        <span class="enscript-keyword">return</span> (kern_os_malloc(nsize));
    }

    ohdr = (<span class="enscript-type">struct</span> _mhead *)addr;
    ohdr--;
    osize = ohdr-&gt;mlen - <span class="enscript-keyword">sizeof</span>(*ohdr);
    <span class="enscript-keyword">if</span> (nsize == osize) {
        <span class="enscript-keyword">return</span> (addr);
    }

    <span class="enscript-keyword">if</span> (nsize == 0) {
        kern_os_free(addr);
        <span class="enscript-keyword">return</span> (0);
    }

    nmemsize = <span class="enscript-keyword">sizeof</span> (*nmem) + nsize ;
    nmem = (<span class="enscript-type">struct</span> _mhead *) kalloc_tag_bt(nmemsize, VM_KERN_MEMORY_LIBKERN);
    <span class="enscript-keyword">if</span> (!nmem){
        kern_os_free(addr);
        <span class="enscript-keyword">return</span> (0);
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">OSALLOCDEBUG</span>
    debug_iomalloc_size += (nmemsize - ohdr-&gt;mlen);
#<span class="enscript-reference">endif</span>

    nmem-&gt;mlen = nmemsize;
    <span class="enscript-keyword">if</span> (nsize &gt; osize) {
        (<span class="enscript-type">void</span>) memset(&amp;nmem-&gt;dat[osize], 0, nsize - osize);
    }
    (<span class="enscript-type">void</span>)memcpy(nmem-&gt;dat, ohdr-&gt;dat, (nsize &gt; osize) ? osize : nsize);
    kfree(ohdr, ohdr-&gt;mlen);

    <span class="enscript-keyword">return</span> (nmem-&gt;dat);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
size_t
<span class="enscript-function-name">kern_os_malloc_size</span>(<span class="enscript-type">void</span> * addr)
{
    <span class="enscript-type">struct</span> _mhead * hdr;

    <span class="enscript-keyword">if</span> (!addr) {
        <span class="enscript-keyword">return</span>(0);
    }

    hdr = (<span class="enscript-type">struct</span> _mhead *) addr; hdr--;
    <span class="enscript-keyword">return</span> hdr-&gt;mlen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> _mhead);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">C</span>++ <span class="enscript-variable-name">Runtime</span> <span class="enscript-variable-name">Load</span>/<span class="enscript-variable-name">Unload</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRAGMA_MARK */</span>
<span class="enscript-comment">/*********************************************************************
* kern_os C++ Runtime Load/Unload
*********************************************************************/</span>

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__GNUC__</span> &gt;= 3
<span class="enscript-type">void</span> <span class="enscript-function-name">__cxa_pure_virtual</span>( <span class="enscript-type">void</span> )    { panic(<span class="enscript-string">&quot;%s&quot;</span>, __FUNCTION__); }
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">__pure_virtual</span>( <span class="enscript-type">void</span> )        { panic(<span class="enscript-string">&quot;%s&quot;</span>, __FUNCTION__); }
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*structor_t)(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sectionIsDestructor</span>(kernel_section_t * section)
{
    boolean_t result;

    result = !strncmp(section-&gt;sectname, SECT_MODTERMFUNC,
        <span class="enscript-keyword">sizeof</span>(SECT_MODTERMFUNC) - 1);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__LP64__</span>
    result = result || !strncmp(section-&gt;sectname, SECT_DESTRUCTOR, 
        <span class="enscript-keyword">sizeof</span>(SECT_DESTRUCTOR) - 1);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sectionIsConstructor</span>(kernel_section_t * section)
{
    boolean_t result;

    result = !strncmp(section-&gt;sectname, SECT_MODINITFUNC,
        <span class="enscript-keyword">sizeof</span>(SECT_MODINITFUNC) - 1);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__LP64__</span>
    result = result || !strncmp(section-&gt;sectname, SECT_CONSTRUCTOR, 
        <span class="enscript-keyword">sizeof</span>(SECT_CONSTRUCTOR) - 1);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">/*********************************************************************
* OSRuntimeUnloadCPPForSegment()
*
* Given a pointer to a mach object segment, iterate the segment to
* obtain a destructor section for C++ objects, and call each of the
* destructors there.
*********************************************************************/</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSRuntimeUnloadCPPForSegmentInKmod</span>(
    kernel_segment_command_t * segment,
    kmod_info_t              * kmodInfo)
{

    kernel_section_t * section = NULL;  <span class="enscript-comment">// do not free
</span>    OSKext           * theKext = NULL;  <span class="enscript-comment">// must release
</span>
    <span class="enscript-keyword">if</span> (gKernelCPPInitialized &amp;&amp; kmodInfo) {
        theKext = OSKext::lookupKextWithIdentifier(kmodInfo-&gt;name);
    }

    <span class="enscript-keyword">for</span> (section = firstsect(segment);
         section != 0;
         section = nextsect(segment, section)) {

        <span class="enscript-keyword">if</span> (sectionIsDestructor(section)) {
            structor_t * destructors = (structor_t *)section-&gt;addr;

            <span class="enscript-keyword">if</span> (destructors) {
                <span class="enscript-type">int</span> num_destructors = section-&gt;size / <span class="enscript-keyword">sizeof</span>(structor_t);
                <span class="enscript-type">int</span> hit_null_destructor = 0;

                <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; num_destructors; i++) {
                    <span class="enscript-keyword">if</span> (destructors[i]) {
                        (*destructors[i])();
                    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!hit_null_destructor) {
                        hit_null_destructor = 1;
                        OSRuntimeLog(theKext, kOSRuntimeLogSpec,
                            <span class="enscript-string">&quot;Null destructor in kext %s segment %s!&quot;</span>,
                            kmodInfo ? kmodInfo-&gt;name : <span class="enscript-string">&quot;(unknown)&quot;</span>,
                            section-&gt;segname);
                    }
                }
            } <span class="enscript-comment">/* if (destructors) */</span>
        } <span class="enscript-comment">/* if (strncmp...) */</span>
    } <span class="enscript-comment">/* for (section...) */</span>

    OSSafeRelease(theKext);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSRuntimeUnloadCPPForSegment</span>(kernel_segment_command_t * segment) {
    OSRuntimeUnloadCPPForSegmentInKmod(segment, NULL);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSRuntimeUnloadCPP</span>(
    kmod_info_t * kmodInfo,
    <span class="enscript-type">void</span>        * data __unused)
{
    <span class="enscript-keyword">if</span> (kmodInfo &amp;&amp; kmodInfo-&gt;address) {

        kernel_segment_command_t * segment;
        kernel_mach_header_t * header;

        <span class="enscript-reference">OSSymbol</span>::checkForPageUnload((<span class="enscript-type">void</span> *)kmodInfo-&gt;address,
            (<span class="enscript-type">void</span> *)(kmodInfo-&gt;address + kmodInfo-&gt;size));

        header = (kernel_mach_header_t *)kmodInfo-&gt;address;
        segment = firstsegfromheader(header);

        <span class="enscript-keyword">for</span> (segment = firstsegfromheader(header);
             segment != 0;
             segment = nextsegfromheader(header, segment)) {

            OSRuntimeUnloadCPPForSegmentInKmod(segment, kmodInfo);
        }
    }

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
kern_return_t
<span class="enscript-function-name">OSRuntimeFinalizeCPP</span>(
    kmod_info_t * kmodInfo,
    <span class="enscript-type">void</span>        * data __unused)
{
    kern_return_t   result = KMOD_RETURN_FAILURE;
    <span class="enscript-type">void</span>          * metaHandle = NULL;  <span class="enscript-comment">// do not free
</span>    OSKext        * theKext    = NULL;  <span class="enscript-comment">// must release
</span>
    <span class="enscript-keyword">if</span> (gKernelCPPInitialized) {
        theKext = OSKext::lookupKextWithIdentifier(kmodInfo-&gt;name);
    }

    <span class="enscript-keyword">if</span> (theKext &amp;&amp; !theKext-&gt;isCPPInitialized()) {
        result = KMOD_RETURN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* OSKext checks for this condition now, but somebody might call
    * this function directly (the symbol is exported....).
    */</span>
    <span class="enscript-keyword">if</span> (OSMetaClass::modHasInstance(kmodInfo-&gt;name)) {
        <span class="enscript-comment">// xxx - Don't log under errors? this is more of an info thing
</span>        OSRuntimeLog(theKext, kOSRuntimeLogSpec,
            <span class="enscript-string">&quot;Can't tear down kext %s C++; classes have instances:&quot;</span>,
            kmodInfo-&gt;name);
        <span class="enscript-reference">OSKext</span>::reportOSMetaClassInstances(kmodInfo-&gt;name, kOSRuntimeLogSpec);
        result = kOSMetaClassHasInstances;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Tell the meta class system that we are starting to unload.
    * metaHandle isn't actually needed on the finalize path,
    * so we don't check it here, even though OSMetaClass::postModLoad() will
    * return a failure (it only does actual work on the init path anyhow).
    */</span>
    metaHandle = OSMetaClass::preModLoad(kmodInfo-&gt;name);
    OSRuntimeUnloadCPP(kmodInfo, 0);
    (<span class="enscript-type">void</span>)OSMetaClass::postModLoad(metaHandle);

    <span class="enscript-keyword">if</span> (theKext) {
        theKext-&gt;setCPPInitialized(false);
    }
    result = KMOD_RETURN_SUCCESS;
<span class="enscript-reference">finish</span>:
    OSSafeRelease(theKext);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">// Functions used by the extenTools/kmod library project
</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
kern_return_t
<span class="enscript-function-name">OSRuntimeInitializeCPP</span>(
    kmod_info_t * kmodInfo,
    <span class="enscript-type">void</span> *        data __unused)
{
    kern_return_t              result          = KMOD_RETURN_FAILURE;
    OSKext                   * theKext         = NULL;  <span class="enscript-comment">// must release
</span>    kernel_mach_header_t     * header          = NULL;
    <span class="enscript-type">void</span>                     * metaHandle      = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">bool</span>                       load_success    = true;
    kernel_segment_command_t * segment         = NULL;  <span class="enscript-comment">// do not free
</span>    kernel_segment_command_t * failure_segment = NULL;  <span class="enscript-comment">// do not free
</span>
    <span class="enscript-keyword">if</span> (!kmodInfo || !kmodInfo-&gt;address) {
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (gKernelCPPInitialized) {
        theKext = OSKext::lookupKextWithIdentifier(kmodInfo-&gt;name);
    }

    <span class="enscript-keyword">if</span> (theKext &amp;&amp; theKext-&gt;isCPPInitialized()) {
        result = KMOD_RETURN_SUCCESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    header = (kernel_mach_header_t *)kmodInfo-&gt;address;

   <span class="enscript-comment">/* Tell the meta class system that we are starting the load
    */</span>
    metaHandle = OSMetaClass::preModLoad(kmodInfo-&gt;name);
    assert(metaHandle);
    <span class="enscript-keyword">if</span> (!metaHandle) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* NO GOTO PAST HERE. */</span>

   <span class="enscript-comment">/* Scan the header for all constructor sections, in any
    * segment, and invoke the constructors within those sections.
    */</span>
    <span class="enscript-keyword">for</span> (segment = firstsegfromheader(header);
         segment != NULL &amp;&amp; load_success;
         segment = nextsegfromheader(header, segment)) {

        kernel_section_t * section;

       <span class="enscript-comment">/* Record the current segment in the event of a failure.
        */</span>
        failure_segment = segment;

        <span class="enscript-keyword">for</span> (section = firstsect(segment);
             section != NULL;
             section = nextsect(segment, section)) {

            <span class="enscript-keyword">if</span> (sectionIsConstructor(section)) {
                structor_t * constructors = (structor_t *)section-&gt;addr;

                <span class="enscript-keyword">if</span> (constructors) {
                    <span class="enscript-type">int</span> num_constructors = section-&gt;size / <span class="enscript-keyword">sizeof</span>(structor_t);
                    <span class="enscript-type">int</span> hit_null_constructor = 0;

                    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0;
                         i &lt; num_constructors &amp;&amp;
                         <span class="enscript-reference">OSMetaClass</span>::checkModLoad(metaHandle);
                         i++) {

                        <span class="enscript-keyword">if</span> (constructors[i]) {
                            (*constructors[i])();
                        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!hit_null_constructor) {
                            hit_null_constructor = 1;
                            OSRuntimeLog(theKext, kOSRuntimeLogSpec,
                                <span class="enscript-string">&quot;Null constructor in kext %s segment %s!&quot;</span>,
                                kmodInfo-&gt;name, section-&gt;segname);
                        }
                    }
                    load_success = OSMetaClass::checkModLoad(metaHandle);

                    <span class="enscript-keyword">break</span>;
                } <span class="enscript-comment">/* if (constructors) */</span>
            } <span class="enscript-comment">/* if (strncmp...) */</span>
        } <span class="enscript-comment">/* for (section...) */</span>
    } <span class="enscript-comment">/* for (segment...) */</span>

   <span class="enscript-comment">/* We failed so call all of the destructors. We must do this before
    * calling OSMetaClass::postModLoad() as the OSMetaClass destructors
    * will alter state (in the metaHandle) used by that function.
    */</span>
    <span class="enscript-keyword">if</span> (!load_success) {

       <span class="enscript-comment">/* Scan the header for all destructor sections, in any
        * segment, and invoke the constructors within those sections.
        */</span>
        <span class="enscript-keyword">for</span> (segment = firstsegfromheader(header);
             segment != failure_segment &amp;&amp; segment != 0;
             segment = nextsegfromheader(header, segment)) {

            OSRuntimeUnloadCPPForSegment(segment);

        } <span class="enscript-comment">/* for (segment...) */</span>
    }

   <span class="enscript-comment">/* Now, regardless of success so far, do the post-init registration
    * and cleanup. If we had to call the unloadCPP function, static
    * destructors have removed classes from the stalled list so no
    * metaclasses will actually be registered.
    */</span>
    result = OSMetaClass::postModLoad(metaHandle);

   <span class="enscript-comment">/* If we've otherwise been fine up to now, but OSMetaClass::postModLoad()
    * fails (typically due to a duplicate class), tear down all the C++
    * stuff from the kext. This isn't necessary for libkern/OSMetaClass stuff,
    * but may be necessary for other C++ code. We ignore the return value
    * because it's only a fail when there are existing instances of libkern
    * classes, and there had better not be any created on the C++ init path.
    */</span>
    <span class="enscript-keyword">if</span> (load_success &amp;&amp; result != KMOD_RETURN_SUCCESS) {
        (<span class="enscript-type">void</span>)OSRuntimeFinalizeCPP(kmodInfo, NULL);
    }

    <span class="enscript-keyword">if</span> (theKext &amp;&amp; load_success &amp;&amp; result == KMOD_RETURN_SUCCESS) {
        theKext-&gt;setCPPInitialized(true);
    }
<span class="enscript-reference">finish</span>:
    OSSafeRelease(theKext);
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Libkern</span> <span class="enscript-variable-name">Init</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRAGMA_MARK */</span>
<span class="enscript-comment">/*********************************************************************
* Libkern Init
*********************************************************************/</span>

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">extern</span> lck_grp_t * IOLockGroup;
<span class="enscript-type">extern</span> kmod_info_t g_kernel_kmod_info;

<span class="enscript-type">void</span> <span class="enscript-function-name">OSlibkernInit</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-comment">// This must be called before calling OSRuntimeInitializeCPP.
</span>    <span class="enscript-reference">OSMetaClassBase</span>::initialize();
    
    g_kernel_kmod_info.address = (vm_address_t) &amp;_mh_execute_header;
    <span class="enscript-keyword">if</span> (kOSReturnSuccess != OSRuntimeInitializeCPP(&amp;g_kernel_kmod_info, 0)) {
        panic(<span class="enscript-string">&quot;OSRuntime: C++ runtime failed to initialize.&quot;</span>);
    }
    
    gKernelCPPInitialized = true;

    <span class="enscript-keyword">return</span>;
}

__END_DECLS

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">C</span>++ <span class="enscript-variable-name">Allocators</span> &amp; <span class="enscript-variable-name">Deallocators</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRAGMA_MARK */</span>
<span class="enscript-comment">/*********************************************************************
* C++ Allocators &amp; Deallocators
*********************************************************************/</span>
<span class="enscript-type">void</span> *
operator <span class="enscript-function-name">new</span>(size_t size)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__cplusplus</span> &gt;= 201103L
								noexcept
#<span class="enscript-reference">endif</span>
{
    <span class="enscript-type">void</span> * result;

    result = (<span class="enscript-type">void</span> *) kern_os_malloc(size);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">void</span>
operator <span class="enscript-function-name">delete</span>(<span class="enscript-type">void</span> * addr)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__cplusplus</span> &gt;= 201103L
								noexcept
#<span class="enscript-reference">endif</span>
{
    kern_os_free(addr);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> *
<span class="enscript-keyword">operator</span> <span class="enscript-keyword">new</span>[](<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> sz)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__cplusplus</span> &gt;= 201103L
								noexcept
#<span class="enscript-reference">endif</span>
{
    <span class="enscript-keyword">if</span> (sz == 0) sz = 1;
    <span class="enscript-keyword">return</span> kern_os_malloc(sz);
}

<span class="enscript-type">void</span>
<span class="enscript-keyword">operator</span> <span class="enscript-keyword">delete</span>[](<span class="enscript-type">void</span> * ptr)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__cplusplus</span> &gt;= 201103L
								noexcept
#<span class="enscript-reference">endif</span>
{
    <span class="enscript-keyword">if</span> (ptr) {
        kern_os_free(ptr);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* PR-6481964 - The compiler is going to check for size overflows in calls to
 * new[], and if there is an overflow, it will call __throw_length_error.
 * This is an unrecoverable error by the C++ standard, so we must panic here.
 *
 * We have to put the function inside the std namespace because of how the
 * compiler expects the name to be mangled.
 */</span>
namespace std {

<span class="enscript-type">void</span>
<span class="enscript-function-name">__throw_length_error</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg __unused)
{
    panic(<span class="enscript-string">&quot;Size of array created by new[] has overflowed&quot;</span>);
}

};

</pre>
<hr />
</body></html>