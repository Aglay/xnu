<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSObject.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSObject.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* OSObject.cpp created by gvdl on Fri 1998-11-17 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSObject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSString.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSArray.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSSerialize.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSCPPDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSCollection.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>

__BEGIN_DECLS
<span class="enscript-type">int</span> debug_ivars_size;
__END_DECLS


<span class="enscript-comment">// OSDefineMetaClassAndAbstractStructors(OSObject, 0);
</span><span class="enscript-comment">/* Class global data */</span>
OSObject::MetaClass OSObject::gMetaClass;
<span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> OSObject::metaClass = &amp;OSObject::gMetaClass;
<span class="enscript-type">const</span> OSMetaClass * <span class="enscript-type">const</span> OSObject::superClass = 0;

<span class="enscript-comment">/* Class member functions - Can't use defaults */</span>
<span class="enscript-function-name">OSObject::~OSObject</span>()			{ }
<span class="enscript-type">const</span> OSMetaClass * <span class="enscript-function-name">OSObject::getMetaClass</span>() <span class="enscript-type">const</span>
    { <span class="enscript-keyword">return</span> &amp;gMetaClass; }
OSObject *<span class="enscript-function-name">OSObject::MetaClass::alloc</span>() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> 0; }

<span class="enscript-comment">/* The OSObject::MetaClass constructor */</span>
<span class="enscript-function-name">OSObject::MetaClass::MetaClass</span>()
    : OSMetaClass(<span class="enscript-string">&quot;OSObject&quot;</span>, OSObject::superClass, <span class="enscript-keyword">sizeof</span>(OSObject))
    { }

<span class="enscript-comment">// Virtual Padding
</span><span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  0);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  5);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  6);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  7);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  8);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject,  9);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject, 10);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject, 11);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject, 12);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject, 13);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject, 14);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(OSObject, 15);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">getClassName</span>(<span class="enscript-type">const</span> OSObject *obj)
{
    <span class="enscript-type">const</span> OSMetaClass *meta = obj-&gt;getMetaClass();
    <span class="enscript-keyword">return</span> (meta) ? meta-&gt;getClassName() : <span class="enscript-string">&quot;unknown class?&quot;</span>;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">OSObject::getRetainCount</span>() <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) ((UInt16) retainCount);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::taggedRetain</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *tag) <span class="enscript-type">const</span>
{
    <span class="enscript-type">volatile</span> UInt32 *countP = (<span class="enscript-type">volatile</span> UInt32 *) &amp;retainCount;
    UInt32 inc = 1;
    UInt32 origCount;
    UInt32 newCount;

    <span class="enscript-comment">// Increment the collection bucket.
</span>    <span class="enscript-keyword">if</span> ((<span class="enscript-type">const</span> <span class="enscript-type">void</span> *) OSTypeID(OSCollection) == tag)
	inc |= (1UL&lt;&lt;16);

    <span class="enscript-keyword">do</span> {
	origCount = *countP;
        <span class="enscript-keyword">if</span> ( ((UInt16) origCount | 0x1) == 0xffff ) {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg;
            <span class="enscript-keyword">if</span> (origCount &amp; 0x1) {
                <span class="enscript-comment">// If count == 0xffff that means we are freeing now so we can
</span>                <span class="enscript-comment">// just return obviously somebody is cleaning up dangling
</span>                <span class="enscript-comment">// references.
</span>                msg = <span class="enscript-string">&quot;Attempting to retain a freed object&quot;</span>;
            }
            <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">// If count == 0xfffe then we have wrapped our reference count.
</span>                <span class="enscript-comment">// We should stop counting now as this reference must be
</span>                <span class="enscript-comment">// leaked rather than accidently wrapping around the clock and
</span>                <span class="enscript-comment">// freeing a very active object later.
</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">break</span>;	<span class="enscript-comment">// Break out of update loop which pegs the reference
</span>#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEBUG */</span>
                <span class="enscript-comment">// @@@ gvdl: eventually need to make this panic optional
</span>                <span class="enscript-comment">// based on a boot argument i.e. debug= boot flag
</span>                msg = <span class="enscript-string">&quot;About to wrap the reference count, reference leak?&quot;</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>
            }
            panic(<span class="enscript-string">&quot;OSObject::refcount: %s&quot;</span>, msg);
        }

	newCount = origCount + inc;
    } <span class="enscript-keyword">while</span> (!OSCompareAndSwap(origCount, newCount, const_cast&lt;UInt32 *&gt;(countP)));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::taggedRelease</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *tag) <span class="enscript-type">const</span>
{
    taggedRelease(tag, 1);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::taggedRelease</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *tag, <span class="enscript-type">const</span> <span class="enscript-type">int</span> when) <span class="enscript-type">const</span>
{
    <span class="enscript-type">volatile</span> UInt32 *countP = (<span class="enscript-type">volatile</span> UInt32 *) &amp;retainCount;
    UInt32 dec = 1;
    UInt32 origCount;
    UInt32 newCount;
    UInt32 actualCount;

    <span class="enscript-comment">// Increment the collection bucket.
</span>    <span class="enscript-keyword">if</span> ((<span class="enscript-type">const</span> <span class="enscript-type">void</span> *) OSTypeID(OSCollection) == tag)
	dec |= (1UL&lt;&lt;16);

    <span class="enscript-keyword">do</span> {
	origCount = *countP;
        
        <span class="enscript-keyword">if</span> ( ((UInt16) origCount | 0x1) == 0xffff ) {
            <span class="enscript-keyword">if</span> (origCount &amp; 0x1) {
                <span class="enscript-comment">// If count == 0xffff that means we are freeing now so we can
</span>                <span class="enscript-comment">// just return obviously somebody is cleaning up some dangling
</span>                <span class="enscript-comment">// references.  So we blow out immediately.
</span>                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">// If count == 0xfffe then we have wrapped our reference
</span>                <span class="enscript-comment">// count.  We should stop counting now as this reference must be
</span>                <span class="enscript-comment">// leaked rather than accidently freeing an active object later.
</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">return</span>;	<span class="enscript-comment">// return out of function which pegs the reference
</span>#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEBUG */</span>
                <span class="enscript-comment">// @@@ gvdl: eventually need to make this panic optional
</span>                <span class="enscript-comment">// based on a boot argument i.e. debug= boot flag
</span>                panic(<span class="enscript-string">&quot;OSObject::refcount: %s&quot;</span>,
                      <span class="enscript-string">&quot;About to unreference a pegged object, reference leak?&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>
            }
        }
	actualCount = origCount - dec;
        <span class="enscript-keyword">if</span> ((UInt16) actualCount &lt; when)
            newCount = 0xffff;
        <span class="enscript-keyword">else</span>
            newCount = actualCount;

    } <span class="enscript-keyword">while</span> (!OSCompareAndSwap(origCount, newCount, const_cast&lt;UInt32 *&gt;(countP)));

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// This panic means that we have just attempted to release an object
</span>    <span class="enscript-comment">// whose retain count has gone to less than the number of collections
</span>    <span class="enscript-comment">// it is a member off.  Take a panic immediately.
</span>    <span class="enscript-comment">// In fact the panic MAY not be a registry corruption but it is 
</span>    <span class="enscript-comment">// ALWAYS the wrong thing to do.  I call it a registry corruption 'cause
</span>    <span class="enscript-comment">// the registry is the biggest single use of a network of collections.
</span>    <span class="enscript-comment">//
</span><span class="enscript-comment">// xxx - this error message is overly-specific;
</span><span class="enscript-comment">// xxx - any code in the kernel could trip this,
</span><span class="enscript-comment">// xxx - and it applies as noted to all collections, not just the registry
</span>    <span class="enscript-keyword">if</span> ((UInt16) actualCount &lt; (actualCount &gt;&gt; 16)) {
        panic(<span class="enscript-string">&quot;A kext releasing a(n) %s has corrupted the registry.&quot;</span>,
            getClassName(<span class="enscript-keyword">this</span>));
    }

    <span class="enscript-comment">// Check for a 'free' condition and that if we are first through
</span>    <span class="enscript-keyword">if</span> (newCount == 0xffff) {
        (const_cast&lt;OSObject *&gt;(<span class="enscript-keyword">this</span>))-&gt;free();
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::release</span>() <span class="enscript-type">const</span>
{
    taggedRelease(0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::retain</span>() <span class="enscript-type">const</span>
{
    taggedRetain(0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::release</span>(<span class="enscript-type">int</span> when) <span class="enscript-type">const</span>
{
    taggedRelease(0, when);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">OSObject::serialize</span>(OSSerialize *s) <span class="enscript-type">const</span>
{
    <span class="enscript-type">char</span> cstr[128];
    <span class="enscript-type">bool</span> ok;

    snprintf(cstr, <span class="enscript-keyword">sizeof</span>(cstr), <span class="enscript-string">&quot;%s is not serializable&quot;</span>, getClassName(<span class="enscript-keyword">this</span>));

    OSString * str;
    str = OSString::withCStringNoCopy(cstr);
    <span class="enscript-keyword">if</span> (!str) <span class="enscript-keyword">return</span> false;

    ok = str-&gt;serialize(s);
    str-&gt;release();

    <span class="enscript-keyword">return</span> (ok);
}

<span class="enscript-type">void</span> *OSObject::<span class="enscript-keyword">operator</span> <span class="enscript-keyword">new</span>(size_t size)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    <span class="enscript-keyword">if</span> (kIOTracking &amp; gIOKitDebug) <span class="enscript-keyword">return</span> (OSMetaClass::trackedNew(size));
#<span class="enscript-reference">endif</span>

    <span class="enscript-type">void</span> * mem = kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN);
    assert(mem);
    bzero(mem, size);
    OSIVAR_ACCUMSIZE(size);

    <span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) mem;
}

<span class="enscript-type">void</span> OSObject::<span class="enscript-keyword">operator</span> <span class="enscript-keyword">delete</span>(<span class="enscript-type">void</span> * mem, size_t size)
{
    <span class="enscript-keyword">if</span> (!mem) <span class="enscript-keyword">return</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    <span class="enscript-keyword">if</span> (kIOTracking &amp; gIOKitDebug) <span class="enscript-keyword">return</span> (OSMetaClass::trackedDelete(mem, size));
#<span class="enscript-reference">endif</span>

    kfree(mem, size);
    OSIVAR_ACCUMSIZE(-size);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">OSObject::init</span>()
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    <span class="enscript-keyword">if</span> (kIOTracking &amp; gIOKitDebug) getMetaClass()-&gt;trackedInstance(<span class="enscript-keyword">this</span>);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::free</span>()
{
    <span class="enscript-type">const</span> OSMetaClass *meta = getMetaClass();

    <span class="enscript-keyword">if</span> (meta)
    {
	meta-&gt;instanceDestructed();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (kIOTracking &amp; gIOKitDebug) getMetaClass()-&gt;trackedFree(<span class="enscript-keyword">this</span>);
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">delete</span> <span class="enscript-keyword">this</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSObject::trackingAccumSize</span>(size_t size)
{
    <span class="enscript-keyword">if</span> (kIOTracking &amp; gIOKitDebug) getMetaClass()-&gt;trackedAccumSize(<span class="enscript-keyword">this</span>, size);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Class member functions - Can't use defaults */</span>
<span class="enscript-comment">/* During constructor vtable is always OSObject's - can't call any subclass */</span>

<span class="enscript-function-name">OSObject::OSObject</span>()
{
    retainCount = 1;
<span class="enscript-comment">//    if (kIOTracking &amp; gIOKitDebug) getMetaClass()-&gt;trackedInstance(this);
</span>}

<span class="enscript-function-name">OSObject::OSObject</span>(<span class="enscript-type">const</span> OSMetaClass *)
{
    retainCount = 1;
<span class="enscript-comment">//    if (kIOTracking &amp; gIOKitDebug) getMetaClass()-&gt;trackedInstance(this);
</span>}
</pre>
<hr />
</body></html>