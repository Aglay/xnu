<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSKext.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSKext.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kext_alloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kextd/kextd_mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kext_panic_report.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kext_request_keys.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/mkext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/prelink.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/version.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/zlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>
<span class="enscript-comment">// 04/18/11 - gab: &lt;rdar://problem/9236163&gt;
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pgo.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>
};

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSKextLibPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSLib.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCatalogue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IORegistryEntry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOStatisticsPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">External</span> &amp; <span class="enscript-variable-name">Internal</span> <span class="enscript-variable-name">Function</span> <span class="enscript-variable-name">Protos</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">IODTGetLoaderInfo</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, <span class="enscript-type">void</span> ** infoAddr, <span class="enscript-type">int</span> * infoSize);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IODTFreeLoaderInfo</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, <span class="enscript-type">void</span> * infoAddr, <span class="enscript-type">int</span> infoSize);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">OSRuntimeUnloadCPPForSegment</span>(kernel_segment_command_t * segment);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">OSRuntimeUnloadCPP</span>(kmod_info_t * ki, <span class="enscript-type">void</span> * data);

<span class="enscript-type">extern</span> ppnum_t <span class="enscript-function-name">pmap_find_phys</span>(pmap_t pmap, addr64_t va); <span class="enscript-comment">/* osfmk/machine/pmap.h */</span>
}

<span class="enscript-type">static</span> OSReturn <span class="enscript-function-name">_OSKextCreateRequest</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>    * predicate,
    OSDictionary ** requestP);
<span class="enscript-type">static</span> OSString * <span class="enscript-function-name">_OSKextGetRequestPredicate</span>(OSDictionary * requestDict);
<span class="enscript-type">static</span> OSObject * <span class="enscript-function-name">_OSKextGetRequestArgument</span>(
    OSDictionary * requestDict,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * argName);
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_OSKextSetRequestArgument</span>(
    OSDictionary * requestDict,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * argName,
    OSObject     * value);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">_OSKextExtractPointer</span>(OSData * wrapper);
<span class="enscript-type">static</span> OSReturn <span class="enscript-function-name">_OSDictionarySetCStringValue</span>(
    OSDictionary * dict,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * key,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * value);
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_OSKextInPrelinkRebuildWindow</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_OSKextInUnloadedPrelinkedKexts</span>(<span class="enscript-type">const</span> OSSymbol * theBundleID);
    
<span class="enscript-comment">// We really should add containsObject() &amp; containsCString to OSCollection &amp; subclasses.
</span><span class="enscript-comment">// So few pad slots, though....
</span><span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_OSArrayContainsCString</span>(OSArray * array, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * cString);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEC_FIPS</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">GetAppleTEXTHashForKext</span>(OSKext * theKext, OSDictionary *theInfoDict);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">CONFIG_KEC_FIPS</span>

<span class="enscript-comment">/* Prelinked arm kexts do not have VM entries because the method we use to
 * fake an entry (see libsa/bootstrap.cpp:readPrelinkedExtensions()) does
 * not work on ARM.  To get around that, we must free prelinked kext
 * executables with ml_static_mfree() instead of kext_free().
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KASLR_IOREG_DEBUG</span> 0
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unsupported</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Constants</span> &amp; <span class="enscript-variable-name">Macros</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Constants &amp; Macros
*********************************************************************/</span>

<span class="enscript-comment">/* Use this number to create containers.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kOSKextTypicalLoadCount</span>      (150)

<span class="enscript-comment">/* Any kext will have at least 1 retain for the internal lookup-by-ID dict.
 * A loaded kext will no dependents or external retains will have 2 retains.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kOSKextMinRetainCount</span>        (1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kOSKextMinLoadedRetainCount</span>  (2)

<span class="enscript-comment">/**********
 * Strings and substrings used in dependency resolution.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_KEXT_PREFIX</span>            <span class="enscript-string">&quot;com.apple.&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_LIB</span>                   <span class="enscript-string">&quot;com.apple.kernel&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PRIVATE_KPI</span>                  <span class="enscript-string">&quot;com.apple.kpi.private&quot;</span>

<span class="enscript-comment">/* Version for compatbility pseudokexts (com.apple.kernel.*),
 * compatible back to v6.0.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL6_LIB</span>                  <span class="enscript-string">&quot;com.apple.kernel.6.0&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL6_VERSION</span>              <span class="enscript-string">&quot;7.9.9&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_LIB_PREFIX</span>            <span class="enscript-string">&quot;com.apple.kernel.&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KPI_LIB_PREFIX</span>               <span class="enscript-string">&quot;com.apple.kpi.&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STRING_HAS_PREFIX</span>(s, p)      (strncmp((s), (p), strlen(p)) == 0)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REBUILD_MAX_TIME</span> (60 * 5) // 5 minutes
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MINIMUM_WAKEUP_SECONDS</span> (30)

<span class="enscript-comment">/*********************************************************************
* infoDict keys for internally-stored data. Saves on ivar slots for
* objects we don't keep around past boot time or during active load.
*********************************************************************/</span>

<span class="enscript-comment">/* A usable, uncompressed file is stored under this key.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_kOSKextExecutableKey</span>                <span class="enscript-string">&quot;_OSKextExecutable&quot;</span>

<span class="enscript-comment">/* An indirect reference to the executable file from an mkext
 * is stored under this key.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_kOSKextMkextExecutableReferenceKey</span>  <span class="enscript-string">&quot;_OSKextMkextExecutableReference&quot;</span>

<span class="enscript-comment">/* If the file is contained in a larger buffer laid down by the booter or
 * sent from user space, the OSKext stores that OSData under this key so that
 * references are properly tracked. This is always an mkext, right now.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_kOSKextExecutableExternalDataKey</span>    <span class="enscript-string">&quot;_OSKextExecutableExternalData&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Typedefs</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Typedefs
*********************************************************************/</span>

<span class="enscript-comment">/*********************************************************************
* MkextEntryRef describes the contents of an OSData object
* referencing a file entry from an mkext so that we can uncompress
* (if necessary) and extract it on demand.
*
* It contains the mkextVersion in case we ever wind up supporting
* multiple mkext formats. Mkext format 1 is officially retired as of
* Snow Leopard.
*********************************************************************/</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> MkextEntryRef {
    mkext_basic_header * mkext;     <span class="enscript-comment">// beginning of whole mkext file
</span>    <span class="enscript-type">void</span>               * fileinfo;  <span class="enscript-comment">// mkext2_file_entry or equiv; see mkext.h
</span>} MkextEntryRef;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Global</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">static</span> <span class="enscript-variable-name">Module</span> <span class="enscript-variable-name">Variables</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Global &amp; static variables, used to keep track of kexts.
*********************************************************************/</span>

<span class="enscript-type">static</span>  <span class="enscript-type">bool</span>                sPrelinkBoot               = false;
<span class="enscript-type">static</span>  <span class="enscript-type">bool</span>                sSafeBoot                  = false;
<span class="enscript-type">static</span>  <span class="enscript-type">bool</span>                sKeepSymbols               = false;

<span class="enscript-comment">/*********************************************************************
* sKextLock is the principal lock for OSKext, and guards all static
* and global variables not owned by other locks (declared further
* below). It must be taken by any entry-point method or function,
* including internal functions called on scheduled threads.
*
* sKextLock and sKextInnerLock are recursive due to multiple functions
* that are called both externally and internally. The other locks are
* nonrecursive.
*
* Which locks are taken depends on what they protect, but if more than
* one must be taken, they must always be locked in this order
* (and unlocked in reverse order) to prevent deadlocks:
*
*    1. sKextLock
*    2. sKextInnerLock
*    3. sKextSummariesLock
*    4. sKextLoggingLock
*/</span>
<span class="enscript-type">static</span> IORecursiveLock    * sKextLock                  = NULL;

<span class="enscript-type">static</span> OSDictionary       * sKextsByID                 = NULL;
<span class="enscript-type">static</span> OSDictionary       * sExcludeListByID           = NULL;
<span class="enscript-type">static</span> OSArray            * sLoadedKexts               = NULL;
<span class="enscript-type">static</span> OSArray            * sUnloadedPrelinkedKexts    = NULL;

<span class="enscript-comment">// Requests to kextd waiting to be picked up.
</span><span class="enscript-type">static</span> OSArray            * sKernelRequests            = NULL;
<span class="enscript-comment">// Identifier of kext load requests in sKernelRequests
</span><span class="enscript-type">static</span> OSSet              * sPostedKextLoadIdentifiers = NULL;
<span class="enscript-type">static</span> OSArray            * sRequestCallbackRecords    = NULL;

<span class="enscript-comment">// Identifiers of all kexts ever requested in kernel; used for prelinked kernel
</span><span class="enscript-type">static</span> OSSet              * sAllKextLoadIdentifiers    = NULL;
<span class="enscript-type">static</span> KXLDContext        * sKxldContext               = NULL;
<span class="enscript-type">static</span> uint32_t             sNextLoadTag               = 0;
<span class="enscript-type">static</span> uint32_t             sNextRequestTag            = 0;

<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sUserLoadsActive           = false;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sKextdActive               = false;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sDeferredLoadSucceeded     = false;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sConsiderUnloadsExecuted   = false;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NO_KEXTD</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sKernelRequestsEnabled     = false;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sKernelRequestsEnabled     = true;
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sLoadEnabled               = true;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sUnloadEnabled             = true;

<span class="enscript-comment">/*********************************************************************
* Stuff for the OSKext representing the kernel itself.
**********/</span>
<span class="enscript-type">static</span> OSKext          * sKernelKext             = NULL;

<span class="enscript-comment">/* Set up a fake kmod_info struct for the kernel.
 * It's used in OSRuntime.cpp to call OSRuntimeInitializeCPP()
 * before OSKext is initialized; that call only needs the name
 * and address to be set correctly.
 *
 * We don't do much else with the kerne's kmod_info; we never
 * put it into the kmod list, never adjust the reference count,
 * and never have kernel components reference it.
 * For that matter, we don't do much with kmod_info structs
 * at all anymore! We just keep them filled in for gdb and
 * binary compability.
 */</span>
kmod_info_t g_kernel_kmod_info = {
    <span class="enscript-comment">/* next            */</span> 0,
    <span class="enscript-comment">/* info_version    */</span> KMOD_INFO_VERSION,
    <span class="enscript-comment">/* id              */</span> 0,                 <span class="enscript-comment">// loadTag: kernel is always 0
</span>    <span class="enscript-comment">/* name            */</span> kOSKextKernelIdentifier,    <span class="enscript-comment">// bundle identifier
</span>    <span class="enscript-comment">/* version         */</span> <span class="enscript-string">&quot;0&quot;</span>,               <span class="enscript-comment">// filled in in OSKext::initialize()
</span>    <span class="enscript-comment">/* reference_count */</span> -1,                <span class="enscript-comment">// never adjusted; kernel never unloads
</span>    <span class="enscript-comment">/* reference_list  */</span> NULL,
    <span class="enscript-comment">/* address         */</span> NULL,
    <span class="enscript-comment">/* size            */</span> 0,                 <span class="enscript-comment">// filled in in OSKext::initialize()
</span>    <span class="enscript-comment">/* hdr_size        */</span> 0,
    <span class="enscript-comment">/* start           */</span> 0,
    <span class="enscript-comment">/* stop            */</span> 0
};

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
<span class="enscript-comment">// symbol 'kmod' referenced in: model_dep.c, db_trace.c, symbols.c, db_low_trace.c,
</span><span class="enscript-comment">// dtrace.c, dtrace_glue.h, OSKext.cpp, locore.s, lowmem_vectors.s,
</span><span class="enscript-comment">// misc_protos.h, db_low_trace.c, kgmacros
</span><span class="enscript-comment">// 'kmod' is a holdover from the old kmod system, we can't rename it.
</span>kmod_info_t * kmod = NULL;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEXT_PANICLIST_SIZE</span>  (2 * PAGE_SIZE)


<span class="enscript-type">static</span> <span class="enscript-type">char</span>     * loaded_kext_paniclist         = NULL;
<span class="enscript-type">static</span> uint32_t   loaded_kext_paniclist_size    = 0;
    
AbsoluteTime      last_loaded_timestamp;
<span class="enscript-type">static</span> <span class="enscript-type">char</span>       last_loaded_str_buf[2*KMOD_MAX_NAME];
<span class="enscript-type">static</span> u_long     last_loaded_strlen            = 0;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>     * last_loaded_address           = NULL;
<span class="enscript-type">static</span> u_long     last_loaded_size              = 0;

AbsoluteTime      last_unloaded_timestamp;
<span class="enscript-type">static</span> <span class="enscript-type">char</span>       last_unloaded_str_buf[2*KMOD_MAX_NAME];
<span class="enscript-type">static</span> u_long     last_unloaded_strlen          = 0;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>     * last_unloaded_address         = NULL;
<span class="enscript-type">static</span> u_long     last_unloaded_size            = 0;

<span class="enscript-comment">/*********************************************************************
* sKextInnerLock protects against cross-calls with IOService and
* IOCatalogue, and owns the variables declared immediately below.
*
* Note that sConsiderUnloadsExecuted above belongs to sKextLock!
*
* When both sKextLock and sKextInnerLock need to be taken,
* always lock sKextLock first and unlock it second. Never take both
* locks in an entry point to OSKext; if you need to do so, you must
* spawn an independent thread to avoid potential deadlocks for threads
* calling into OSKext.
**********/</span>
<span class="enscript-type">static</span> IORecursiveLock *    sKextInnerLock             = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sAutounloadEnabled         = true;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sConsiderUnloadsCalled     = false;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sConsiderUnloadsPending    = false;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>         sConsiderUnloadDelay       = 60;     <span class="enscript-comment">// seconds
</span><span class="enscript-type">static</span> thread_call_t        sUnloadCallout             = 0;
<span class="enscript-type">static</span> thread_call_t        sDestroyLinkContextThread  = 0;      <span class="enscript-comment">// one-shot, one-at-a-time thread
</span><span class="enscript-type">static</span> <span class="enscript-type">bool</span>                 sSystemSleep               = false;  <span class="enscript-comment">// true when system going to sleep
</span><span class="enscript-type">static</span> AbsoluteTime         sLastWakeTime;                       <span class="enscript-comment">// last time we woke up   
</span>
<span class="enscript-comment">/*********************************************************************
* Backtraces can be printed at various times so we need a tight lock
* on data used for that. sKextSummariesLock protects the variables
* declared immediately below.
*
* gLoadedKextSummaries is accessed by other modules, but only during
* a panic so the lock isn't needed then.
*
* gLoadedKextSummaries has the &quot;used&quot; attribute in order to ensure
* that it remains visible even when we are performing extremely
* aggressive optimizations, as it is needed to allow the debugger
* to automatically parse the list of loaded kexts.
**********/</span>
<span class="enscript-type">static</span> IOLock                 * sKextSummariesLock                = NULL;
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> lck_spin_t           vm_allocation_sites_lock;
<span class="enscript-type">static</span> IOSimpleLock           * sKextAccountsLock = &amp;vm_allocation_sites_lock;

<span class="enscript-function-name">void</span> (*sLoadedKextSummariesUpdated)(<span class="enscript-type">void</span>) = OSKextLoadedKextSummariesUpdated;
OSKextLoadedKextSummaryHeader * gLoadedKextSummaries <span class="enscript-function-name">__attribute__</span>((used)) = NULL;
<span class="enscript-type">static</span> size_t sLoadedKextSummariesAllocSize = 0;

<span class="enscript-type">static</span> OSKextActiveAccount    * sKextAccounts;
<span class="enscript-type">static</span> uint32_t                 sKextAccountsCount;
};

<span class="enscript-comment">/*********************************************************************
* sKextLoggingLock protects the logging variables declared immediately below.
**********/</span>
<span class="enscript-type">static</span> IOLock             * sKextLoggingLock           = NULL;

<span class="enscript-type">static</span>  <span class="enscript-type">const</span> OSKextLogSpec kDefaultKernelLogFilter    = kOSKextLogBasicLevel |
                                                         kOSKextLogVerboseFlagsMask;
<span class="enscript-type">static</span>  OSKextLogSpec       sKernelLogFilter           = kDefaultKernelLogFilter;
<span class="enscript-type">static</span>  <span class="enscript-type">bool</span>                sBootArgLogFilterFound     = false;
<span class="enscript-function-name">SYSCTL_UINT</span>(_debug, OID_AUTO, kextlog, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sKernelLogFilter,
    sKernelLogFilter, <span class="enscript-string">&quot;kernel kext logging&quot;</span>);

<span class="enscript-type">static</span>  OSKextLogSpec       sUserSpaceKextLogFilter    = kOSKextLogSilentFilter;
<span class="enscript-type">static</span>  OSArray           * sUserSpaceLogSpecArray     = NULL;
<span class="enscript-type">static</span>  OSArray           * sUserSpaceLogMessageArray  = NULL;

<span class="enscript-comment">/*********
* End scope for sKextInnerLock-protected variables.
*********************************************************************/</span>


<span class="enscript-comment">/*********************************************************************
 helper function used for collecting PGO data upon unload of a kext
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">OSKextGrabPgoDataLocked</span>(OSKext *kext,
                                   <span class="enscript-type">bool</span> metadata,
                                   uuid_t instance_uuid,
                                   uint64_t *pSize,
                                   <span class="enscript-type">char</span> *pBuffer,
                                   uint64_t bufferSize);

<span class="enscript-comment">/**********************************************************************/</span>



#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">OSData</span> <span class="enscript-variable-name">callbacks</span> (<span class="enscript-variable-name">need</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">move</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">OSData</span>)
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* C functions used for callbacks.
*********************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
<span class="enscript-type">void</span> <span class="enscript-function-name">osdata_kmem_free</span>(<span class="enscript-type">void</span> * ptr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> length) {
    kmem_free(kernel_map, (vm_address_t)ptr, length);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">osdata_phys_free</span>(<span class="enscript-type">void</span> * ptr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> length) {
    ml_static_mfree((vm_offset_t)ptr, length);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">osdata_vm_deallocate</span>(<span class="enscript-type">void</span> * ptr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> length)
{
    (<span class="enscript-type">void</span>)vm_deallocate(kernel_map, (vm_offset_t)ptr, length);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">osdata_kext_free</span>(<span class="enscript-type">void</span> * ptr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> length)
{
    (<span class="enscript-type">void</span>)kext_free((vm_offset_t)ptr, length);
}

};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">KXLD</span> <span class="enscript-variable-name">Allocation</span> <span class="enscript-variable-name">Callback</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* KXLD Allocation Callback
*********************************************************************/</span>
kxld_addr_t
<span class="enscript-function-name">kern_allocate</span>(
    u_long              size,
    KXLDAllocateFlags * flags,
    <span class="enscript-type">void</span>              * user_data)
{
    vm_address_t  result       = 0;     <span class="enscript-comment">// returned
</span>    kern_return_t mach_result  = KERN_FAILURE;
    <span class="enscript-type">bool</span>          success      = false;
    OSKext      * theKext      = (OSKext *)user_data;
    u_long        roundSize    = round_page(size);
    OSData      * linkBuffer   = NULL;  <span class="enscript-comment">// must release
</span>
    mach_result = kext_alloc(&amp;result, roundSize, <span class="enscript-comment">/* fixed */</span> FALSE);
    <span class="enscript-keyword">if</span> (mach_result != KERN_SUCCESS) {
        OSKextLog(theKext,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Can't allocate kernel memory to link %s.&quot;</span>,
            theKext-&gt;getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Create an OSData wrapper for the allocated buffer.
    */</span>
    linkBuffer = OSData::withBytesNoCopy((<span class="enscript-type">void</span> *)result, roundSize);
    <span class="enscript-keyword">if</span> (!linkBuffer) {
        OSKextLog(theKext,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Can't allocate linked executable wrapper for %s.&quot;</span>,
            theKext-&gt;getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    linkBuffer-&gt;setDeallocFunction(osdata_kext_free);
    OSKextLog(theKext,
        kOSKextLogProgressLevel |
        kOSKextLogLoadFlag | kOSKextLogLinkFlag,
        <span class="enscript-string">&quot;Allocated link buffer for kext %s at %p (%lu bytes).&quot;</span>,
        theKext-&gt;getIdentifierCString(),
        (<span class="enscript-type">void</span> *)result, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)roundSize);

    theKext-&gt;setLinkedExecutable(linkBuffer);

    *flags = kKxldAllocateWritable;
    success = true;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (!success &amp;&amp; result) {
        kext_free(result, roundSize);
        result = 0;
    }

    OSSafeRelease(linkBuffer);

    <span class="enscript-keyword">return</span> (kxld_addr_t)result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kxld_log_callback</span>(
    KXLDLogSubsystem    subsystem,
    KXLDLogLevel        level,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>        * format,
    va_list             argList,
    <span class="enscript-type">void</span>              * user_data)
{
    OSKext *theKext = (OSKext *) user_data;
    OSKextLogSpec logSpec = 0;

    <span class="enscript-keyword">switch</span> (subsystem) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogLinking</span>:
        logSpec |= kOSKextLogLinkFlag;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogPatching</span>:
        logSpec |= kOSKextLogPatchFlag;
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">switch</span> (level) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogExplicit</span>:
        logSpec |= kOSKextLogExplicitLevel;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogErr</span>:
        logSpec |= kOSKextLogErrorLevel;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogWarn</span>:
        logSpec |= kOSKextLogWarningLevel;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogBasic</span>:
        logSpec |= kOSKextLogProgressLevel;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogDetail</span>:
        logSpec |= kOSKextLogDetailLevel;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kKxldLogDebug</span>:
        logSpec |= kOSKextLogDebugLevel;
        <span class="enscript-keyword">break</span>;
    }

    OSKextVLog(theKext, logSpec, format, argList);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">IOStatistics</span> <span class="enscript-variable-name">defines</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOKITSTATS</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyKextLoadObservers</span>(kext, kmod_info) \
<span class="enscript-keyword">do</span> { \
    <span class="enscript-reference">IOStatistics</span>::onKextLoad(kext, kmod_info); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyKextUnloadObservers</span>(kext) \
<span class="enscript-keyword">do</span> { \
    <span class="enscript-reference">IOStatistics</span>::onKextUnload(kext); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyAddClassObservers</span>(kext, addedClass, flags) \
<span class="enscript-keyword">do</span> { \
    <span class="enscript-reference">IOStatistics</span>::onClassAdded(kext, addedClass); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyRemoveClassObservers</span>(kext, removedClass, flags) \
<span class="enscript-keyword">do</span> { \
    <span class="enscript-reference">IOStatistics</span>::onClassRemoved(kext, removedClass); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyKextLoadObservers</span>(kext, kmod_info)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyKextUnloadObservers</span>(kext)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyAddClassObservers</span>(kext, addedClass, flags)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">notifyRemoveClassObservers</span>(kext, removedClass, flags)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOKITSTATS */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Module</span> <span class="enscript-variable-name">Config</span> (<span class="enscript-variable-name">Startup</span> &amp; <span class="enscript-variable-name">Shutdown</span>)
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Module Config (Class Definition &amp; Class Methods)
*********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(OSKext, OSObject)

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::initialize</span>(<span class="enscript-type">void</span>)
{
    OSData          * kernelExecutable   = NULL;  <span class="enscript-comment">// do not release
</span>    u_char          * kernelStart        = NULL;  <span class="enscript-comment">// do not free
</span>    size_t            kernelLength       = 0;
    OSString        * scratchString      = NULL;  <span class="enscript-comment">// must release
</span>    IORegistryEntry * registryRoot       = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber        * kernelCPUType      = NULL;  <span class="enscript-comment">// must release
</span>    OSNumber        * kernelCPUSubtype   = NULL;  <span class="enscript-comment">// must release
</span>    OSKextLogSpec     bootLogFilter      = kOSKextLogSilentFilter;
    <span class="enscript-type">bool</span>              setResult          = false;
    uint64_t        * timestamp          = 0;
    <span class="enscript-type">char</span>              bootArgBuffer[16];  <span class="enscript-comment">// for PE_parse_boot_argn w/strings
</span>
   <span class="enscript-comment">/* This must be the first thing allocated. Everything else grabs this lock.
    */</span>
    sKextLock = IORecursiveLockAlloc();
    sKextInnerLock = IORecursiveLockAlloc();
    sKextSummariesLock = IOLockAlloc();
    sKextLoggingLock = IOLockAlloc();
    assert(sKextLock);
    assert(sKextInnerLock);
    assert(sKextSummariesLock);
    assert(sKextLoggingLock);

    sKextsByID = OSDictionary::withCapacity(kOSKextTypicalLoadCount);
    sLoadedKexts = OSArray::withCapacity(kOSKextTypicalLoadCount);
    sUnloadedPrelinkedKexts = OSArray::withCapacity(kOSKextTypicalLoadCount / 10);
    sKernelRequests = OSArray::withCapacity(0);
    sPostedKextLoadIdentifiers = OSSet::withCapacity(0);
    sAllKextLoadIdentifiers = OSSet::withCapacity(kOSKextTypicalLoadCount);
    sRequestCallbackRecords = OSArray::withCapacity(0);
    assert(sKextsByID &amp;&amp; sLoadedKexts &amp;&amp; sKernelRequests &amp;&amp;
        sPostedKextLoadIdentifiers &amp;&amp; sAllKextLoadIdentifiers &amp;&amp;
        sRequestCallbackRecords &amp;&amp; sUnloadedPrelinkedKexts);

   <span class="enscript-comment">/* Read the log flag boot-args and set the log flags.
    */</span>
    <span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;kextlog&quot;</span>, &amp;bootLogFilter, <span class="enscript-keyword">sizeof</span>(bootLogFilter))) {
        sBootArgLogFilterFound = true;
        sKernelLogFilter = bootLogFilter;
        <span class="enscript-comment">// log this if any flags are set
</span>        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogBasicLevel |
            kOSKextLogFlagsMask,
            <span class="enscript-string">&quot;Kernel kext log filter 0x%x per kextlog boot arg.&quot;</span>,
            (<span class="enscript-type">unsigned</span>)sKernelLogFilter);
    }

    sSafeBoot = PE_parse_boot_argn(<span class="enscript-string">&quot;-x&quot;</span>, bootArgBuffer,
        <span class="enscript-keyword">sizeof</span>(bootArgBuffer)) ? true : false;

    <span class="enscript-keyword">if</span> (sSafeBoot) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogWarningLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;SAFE BOOT DETECTED - &quot;</span>
            <span class="enscript-string">&quot;only valid OSBundleRequired kexts will be loaded.&quot;</span>);
    }

    PE_parse_boot_argn(<span class="enscript-string">&quot;keepsyms&quot;</span>, &amp;sKeepSymbols, <span class="enscript-keyword">sizeof</span>(sKeepSymbols));

   <span class="enscript-comment">/* Set up an OSKext instance to represent the kernel itself.
    */</span>
    sKernelKext = <span class="enscript-keyword">new</span> OSKext;
    assert(sKernelKext);

    kernelStart = (u_char *)&amp;_mh_execute_header;
    kernelLength = getlastaddr() - (vm_offset_t)kernelStart;
    kernelExecutable = OSData::withBytesNoCopy(
        kernelStart, kernelLength);
    assert(kernelExecutable);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span> 
    IOLog(<span class="enscript-string">&quot;kaslr: kernel start 0x%lx end 0x%lx length %lu \n&quot;</span>, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)kernelStart, 
          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)getlastaddr(),
          kernelLength);
#<span class="enscript-reference">endif</span>

    sKernelKext-&gt;loadTag = sNextLoadTag++;  <span class="enscript-comment">// the kernel is load tag 0
</span>    sKernelKext-&gt;bundleID = OSSymbol::withCString(kOSKextKernelIdentifier);
    
    sKernelKext-&gt;version = OSKextParseVersionString(osrelease);
    sKernelKext-&gt;compatibleVersion = sKernelKext-&gt;version;
    sKernelKext-&gt;linkedExecutable = kernelExecutable;
    
    sKernelKext-&gt;flags.hasAllDependencies = 1;
    sKernelKext-&gt;flags.kernelComponent = 1;
    sKernelKext-&gt;flags.prelinked = 0;
    sKernelKext-&gt;flags.loaded = 1;
    sKernelKext-&gt;flags.started = 1;
    sKernelKext-&gt;flags.CPPInitialized = 0;
    sKernelKext-&gt;flags.jettisonLinkeditSeg = 0;

    sKernelKext-&gt;kmod_info = &amp;g_kernel_kmod_info;
    strlcpy(g_kernel_kmod_info.version, osrelease,
        <span class="enscript-keyword">sizeof</span>(g_kernel_kmod_info.version));
    g_kernel_kmod_info.size = kernelLength;
    g_kernel_kmod_info.id = sKernelKext-&gt;loadTag;

   <span class="enscript-comment">/* Cons up an info dict, so we don't have to have special-case
    * checking all over.
    */</span>
    sKernelKext-&gt;infoDict = OSDictionary::withCapacity(5);
    assert(sKernelKext-&gt;infoDict);
    setResult = sKernelKext-&gt;infoDict-&gt;setObject(kCFBundleIdentifierKey,
        sKernelKext-&gt;bundleID);
    assert(setResult);
    setResult = sKernelKext-&gt;infoDict-&gt;setObject(kOSKernelResourceKey,
        kOSBooleanTrue);
    assert(setResult);
        
    scratchString = OSString::withCStringNoCopy(osrelease);
    assert(scratchString);
    setResult = sKernelKext-&gt;infoDict-&gt;setObject(kCFBundleVersionKey,
        scratchString);
    assert(setResult);
    OSSafeReleaseNULL(scratchString);

    scratchString = OSString::withCStringNoCopy(<span class="enscript-string">&quot;mach_kernel&quot;</span>);
    assert(scratchString);
    setResult = sKernelKext-&gt;infoDict-&gt;setObject(kCFBundleNameKey,
        scratchString);
    assert(setResult);
    OSSafeReleaseNULL(scratchString);

   <span class="enscript-comment">/* Add the kernel kext to the bookkeeping dictionaries. Note that
    * the kernel kext doesn't have a kmod_info struct. copyInfo()
    * gathers info from other places anyhow.
    */</span>
    setResult = sKextsByID-&gt;setObject(sKernelKext-&gt;bundleID, sKernelKext);
    assert(setResult);
    setResult = sLoadedKexts-&gt;setObject(sKernelKext);
    assert(setResult);
    sKernelKext-&gt;release();

    registryRoot = IORegistryEntry::getRegistryRoot();
    kernelCPUType = OSNumber::withNumber(
        (<span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)_mh_execute_header.cputype,
        8 * <span class="enscript-keyword">sizeof</span>(_mh_execute_header.cputype));
    kernelCPUSubtype = OSNumber::withNumber(
        (<span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)_mh_execute_header.cpusubtype,
        8 * <span class="enscript-keyword">sizeof</span>(_mh_execute_header.cpusubtype));
    assert(registryRoot &amp;&amp; kernelCPUSubtype &amp;&amp; kernelCPUType);
    
    registryRoot-&gt;setProperty(kOSKernelCPUTypeKey, kernelCPUType);
    registryRoot-&gt;setProperty(kOSKernelCPUSubtypeKey, kernelCPUSubtype);

    OSSafeRelease(kernelCPUType);
    OSSafeRelease(kernelCPUSubtype);

    timestamp = __OSAbsoluteTimePtr(&amp;last_loaded_timestamp);
    *timestamp = 0;
    timestamp = __OSAbsoluteTimePtr(&amp;last_unloaded_timestamp);
    *timestamp = 0;
    timestamp = __OSAbsoluteTimePtr(&amp;sLastWakeTime);
    *timestamp = 0;

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogGeneralFlag,
        <span class="enscript-string">&quot;Kext system initialized.&quot;</span>);

    notifyKextLoadObservers(sKernelKext, sKernelKext-&gt;kmod_info);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* This could be in OSKextLib.cpp but we need to hold a lock
* while removing all the segments and sKextLock will do.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::removeKextBootstrap</span>(<span class="enscript-type">void</span>)
{
    OSReturn                   result                = kOSReturnError;
    
    <span class="enscript-type">static</span> <span class="enscript-type">bool</span>                alreadyDone           = false;

    <span class="enscript-type">const</span> <span class="enscript-type">char</span>               * dt_kernel_header_name = <span class="enscript-string">&quot;Kernel-__HEADER&quot;</span>;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>               * dt_kernel_symtab_name = <span class="enscript-string">&quot;Kernel-__SYMTAB&quot;</span>;
    kernel_mach_header_t     * dt_mach_header        = NULL;
    <span class="enscript-type">int</span>                        dt_mach_header_size   = 0;
    <span class="enscript-type">struct</span> symtab_command    * dt_symtab             = NULL;
    <span class="enscript-type">int</span>                        dt_symtab_size        = 0;
    <span class="enscript-type">int</span>                        dt_result             = 0;

    kernel_segment_command_t * seg_to_remove         = NULL;


   <span class="enscript-comment">/* This must be the very first thing done by this function.
    */</span>
    IORecursiveLockLock(sKextLock);

   <span class="enscript-comment">/* If we already did this, it's a success.
    */</span>
    <span class="enscript-keyword">if</span> (alreadyDone) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogGeneralFlag,
        <span class="enscript-string">&quot;Jettisoning kext bootstrap segments.&quot;</span>);

   <span class="enscript-comment">/*****
    * Dispose of unnecessary stuff that the booter didn't need to load.
    */</span>
    dt_result = IODTGetLoaderInfo(dt_kernel_header_name,
        (<span class="enscript-type">void</span> **)&amp;dt_mach_header, &amp;dt_mach_header_size);
    <span class="enscript-keyword">if</span> (dt_result == 0 &amp;&amp; dt_mach_header) {
        IODTFreeLoaderInfo(dt_kernel_header_name, (<span class="enscript-type">void</span> *)dt_mach_header,
            round_page_32(dt_mach_header_size));
    }
    dt_result = IODTGetLoaderInfo(dt_kernel_symtab_name,
        (<span class="enscript-type">void</span> **)&amp;dt_symtab, &amp;dt_symtab_size);
    <span class="enscript-keyword">if</span> (dt_result == 0 &amp;&amp; dt_symtab) {
        IODTFreeLoaderInfo(dt_kernel_symtab_name, (<span class="enscript-type">void</span> *)dt_symtab,
            round_page_32(dt_symtab_size));
    }

   <span class="enscript-comment">/*****
    * KLD bootstrap segment.
    */</span>
    <span class="enscript-comment">// xxx - should rename KLD segment
</span>    seg_to_remove = getsegbyname(<span class="enscript-string">&quot;__KLD&quot;</span>);
    <span class="enscript-keyword">if</span> (seg_to_remove) {
        OSRuntimeUnloadCPPForSegment(seg_to_remove);
    }

#<span class="enscript-reference">if</span>   <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
   <span class="enscript-comment">/* On x86, use the mapping data from the segment load command to
    * unload KLD directly.
    * This may invalidate any assumptions about  &quot;avail_start&quot;
    * defining the lower bound for valid physical addresses.
    */</span>
    <span class="enscript-keyword">if</span> (seg_to_remove &amp;&amp; seg_to_remove-&gt;vmaddr &amp;&amp; seg_to_remove-&gt;vmsize) {
        <span class="enscript-comment">// 04/18/11 - gab: &lt;rdar://problem/9236163&gt;
</span>        <span class="enscript-comment">// overwrite memory occupied by KLD segment with random data before
</span>        <span class="enscript-comment">// releasing it.
</span>        read_frandom((<span class="enscript-type">void</span> *) seg_to_remove-&gt;vmaddr, seg_to_remove-&gt;vmsize);
        ml_static_mfree(seg_to_remove-&gt;vmaddr, seg_to_remove-&gt;vmsize);
    }
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">arch</span>
#<span class="enscript-reference">endif</span>

    seg_to_remove = NULL;

    <span class="enscript-comment">/*****
    * Prelinked kernel's symtab (if there is one).
    */</span>
    kernel_section_t * sect;
    sect = getsectbyname(<span class="enscript-string">&quot;__PRELINK&quot;</span>, <span class="enscript-string">&quot;__symtab&quot;</span>);
    <span class="enscript-keyword">if</span> (sect &amp;&amp; sect-&gt;addr &amp;&amp; sect-&gt;size) {
        ml_static_mfree(sect-&gt;addr, sect-&gt;size);
    }

    seg_to_remove = (kernel_segment_command_t *)getsegbyname(<span class="enscript-string">&quot;__LINKEDIT&quot;</span>);

    <span class="enscript-comment">/* kxld always needs the kernel's __LINKEDIT segment, but we can make it
     * pageable, unless keepsyms is set.  To do that, we have to copy it from
     * its booter-allocated memory, free the booter memory, reallocate proper
     * managed memory, then copy the segment back in.
     */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KXLD</span>
    <span class="enscript-keyword">if</span> (!sKeepSymbols) {
        kern_return_t mem_result;
        <span class="enscript-type">void</span> *seg_copy = NULL;
        <span class="enscript-type">void</span> *seg_data = NULL;
        vm_map_offset_t seg_offset = 0;
        vm_map_offset_t seg_copy_offset = 0;
        vm_map_size_t seg_length = 0;

        seg_data = (<span class="enscript-type">void</span> *) seg_to_remove-&gt;vmaddr;
        seg_offset = (vm_map_offset_t) seg_to_remove-&gt;vmaddr;
        seg_length = (vm_map_size_t) seg_to_remove-&gt;vmsize;

       <span class="enscript-comment">/* Allocate space for the LINKEDIT copy.
        */</span>
        mem_result = kmem_alloc(kernel_map, (vm_offset_t *) &amp;seg_copy,
            seg_length, VM_KERN_MEMORY_KEXT);
        <span class="enscript-keyword">if</span> (mem_result != KERN_SUCCESS) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag | kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Can't copy __LINKEDIT segment for VM reassign.&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        seg_copy_offset = (vm_map_offset_t) seg_copy;

       <span class="enscript-comment">/* Copy it out.
        */</span>
        memcpy(seg_copy, seg_data, seg_length);

       <span class="enscript-comment">/* Dump the booter memory.
        */</span>
        ml_static_mfree(seg_offset, seg_length);

       <span class="enscript-comment">/* Set up the VM region.
        */</span>
        mem_result = vm_map_enter_mem_object(
            kernel_map,
            &amp;seg_offset,
            seg_length, <span class="enscript-comment">/* mask */</span> 0, 
            VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE, 
            (ipc_port_t)NULL,
            (vm_object_offset_t) 0,
            <span class="enscript-comment">/* copy */</span> FALSE,
            <span class="enscript-comment">/* cur_protection */</span> VM_PROT_READ | VM_PROT_WRITE,
            <span class="enscript-comment">/* max_protection */</span> VM_PROT_ALL,
            <span class="enscript-comment">/* inheritance */</span> VM_INHERIT_DEFAULT);
        <span class="enscript-keyword">if</span> ((mem_result != KERN_SUCCESS) || 
            (seg_offset != (vm_map_offset_t) seg_data))
        {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag | kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Can't create __LINKEDIT VM entry at %p, length 0x%llx (error 0x%x).&quot;</span>,
                seg_data, seg_length, mem_result);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* And copy it back.
        */</span>
        memcpy(seg_data, seg_copy, seg_length);

       <span class="enscript-comment">/* Free the copy.
        */</span>
        kmem_free(kernel_map, seg_copy_offset, seg_length);
    }
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* we are not CONFIG_KXLD */</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">CONFIG_KXLD</span> <span class="enscript-variable-name">is</span> <span class="enscript-variable-name">expected</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">this</span> <span class="enscript-variable-name">arch</span>

    <span class="enscript-comment">/*****
    * Dump the LINKEDIT segment, unless keepsyms is set.
    */</span>
    <span class="enscript-keyword">if</span> (!sKeepSymbols) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dt_segment_name = <span class="enscript-string">&quot;Kernel-__LINKEDIT&quot;</span>;
        <span class="enscript-keyword">if</span> (0 == IODTGetLoaderInfo(dt_segment_name,
            &amp;segment_paddress, &amp;segment_size)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
            vm_offset_t vmaddr = ml_static_ptovirt((vm_offset_t)segment_paddress);
            bzero((<span class="enscript-type">void</span>*)vmaddr, segment_size);
#<span class="enscript-reference">endif</span>
            IODTFreeLoaderInfo(dt_segment_name, (<span class="enscript-type">void</span> *)segment_paddress,
                (<span class="enscript-type">int</span>)segment_size);
        }
    } <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
           kOSKextLogBasicLevel |
           kOSKextLogGeneralFlag,
           <span class="enscript-string">&quot;keepsyms boot arg specified; keeping linkedit segment for symbols.&quot;</span>);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_KXLD */</span>

    seg_to_remove = NULL;

    alreadyDone = true;
    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:

   <span class="enscript-comment">/* This must be the very last thing done before returning.
    */</span>
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::flushNonloadedKexts</span>(
    Boolean flushPrelinkedKexts)
{
    OSSet                * prelinkedKexts  = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * kextIterator    = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * prelinkIterator = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">const</span> OSSymbol       * thisID          = NULL;  <span class="enscript-comment">// do not release
</span>    OSKext               * thisKext        = NULL;  <span class="enscript-comment">// do not release
</span>    uint32_t               count, i;

    IORecursiveLockLock(sKextLock);

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogKextBookkeepingFlag,
        <span class="enscript-string">&quot;Flushing nonloaded kexts and other unused data.&quot;</span>);

    <span class="enscript-reference">OSKext</span>::considerDestroyingLinkContext();

   <span class="enscript-comment">/* If we aren't flushing unused prelinked kexts, we have to put them
    * aside while we flush everything else so make a container for them.
    */</span>
    <span class="enscript-keyword">if</span> (!flushPrelinkedKexts) {
        prelinkedKexts = OSSet::withCapacity(0);
        <span class="enscript-keyword">if</span> (!prelinkedKexts) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    
   <span class="enscript-comment">/* Set aside prelinked kexts (in-use or not) and break
    * any lingering inter-kext references for nonloaded kexts
    * so they have min. retain counts.
    */</span>
    kextIterator = OSCollectionIterator::withCollection(sKextsByID);
    <span class="enscript-keyword">if</span> (!kextIterator) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">while</span> ((thisID = OSDynamicCast(OSSymbol, 
            kextIterator-&gt;getNextObject()))) {

        thisKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(thisID));

        <span class="enscript-keyword">if</span> (thisKext) {
            <span class="enscript-keyword">if</span> (prelinkedKexts &amp;&amp; thisKext-&gt;isPrelinked()) {
                prelinkedKexts-&gt;setObject(thisKext);
            }
            thisKext-&gt;flushDependencies(<span class="enscript-comment">/* forceIfLoaded */</span> false);
        }
    }

   <span class="enscript-comment">/* Dump all the kexts in the ID dictionary; we'll repopulate it shortly.
    */</span>
    sKextsByID-&gt;flushCollection();

   <span class="enscript-comment">/* Now put the loaded kexts back into the ID dictionary.
    */</span>
    count = sLoadedKexts-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        sKextsByID-&gt;setObject(thisKext-&gt;getIdentifierCString(), thisKext);
    }

   <span class="enscript-comment">/* Finally, put back the prelinked kexts if we saved any.
    */</span>
    <span class="enscript-keyword">if</span> (prelinkedKexts) {
        prelinkIterator = OSCollectionIterator::withCollection(prelinkedKexts);
        <span class="enscript-keyword">if</span> (!prelinkIterator) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">while</span> ((thisKext = OSDynamicCast(OSKext,
            prelinkIterator-&gt;getNextObject()))) {

            sKextsByID-&gt;setObject(thisKext-&gt;getIdentifierCString(),
                thisKext);
        }
    }

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);

    OSSafeRelease(prelinkedKexts);
    OSSafeRelease(kextIterator);
    OSSafeRelease(prelinkIterator);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::setKextdActive</span>(Boolean active)
{
    IORecursiveLockLock(sKextLock);
    sKextdActive = active;
    <span class="enscript-keyword">if</span> (sKernelRequests-&gt;getCount()) {
        <span class="enscript-reference">OSKext</span>::pingKextd();
    }
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* OSKextLib.cpp might need access to this someday but for now it's
* private.
*********************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipc_port_release_send</span>(ipc_port_t);
};

<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::pingKextd</span>(<span class="enscript-type">void</span>)
{
    OSReturn    result     = kOSReturnError;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KEXTD</span>
    mach_port_t kextd_port = IPC_PORT_NULL;

    <span class="enscript-keyword">if</span> (!sKextdActive) {
        result = kOSKextReturnDisabled;  <span class="enscript-comment">// basically unavailable
</span>        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = host_get_kextd_port(host_priv_self(), &amp;kextd_port);
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS || !IPC_PORT_VALID(kextd_port)) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Can't get kextd port.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = kextd_ping(kextd_port);
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;kextd ping failed (0x%x).&quot;</span>, (<span class="enscript-type">int</span>)result);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (IPC_PORT_VALID(kextd_port)) {
        ipc_port_release_send(kextd_port);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::setDeferredLoadSucceeded</span>(Boolean succeeded)
{
    IORecursiveLockLock(sKextLock);
    sDeferredLoadSucceeded = succeeded;
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Called from IOSystemShutdownNotification.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::willShutdown</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KEXTD</span>
    OSReturn       checkResult = kOSReturnError;
#<span class="enscript-reference">endif</span>
    OSDictionary * exitRequest = NULL;  <span class="enscript-comment">// must release
</span>
    IORecursiveLockLock(sKextLock);

    <span class="enscript-reference">OSKext</span>::setLoadEnabled(false);
    <span class="enscript-reference">OSKext</span>::setUnloadEnabled(false);
    <span class="enscript-reference">OSKext</span>::setAutounloadsEnabled(false);
    <span class="enscript-reference">OSKext</span>::setKernelRequestsEnabled(false);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KEXTD</span>
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogGeneralFlag,
        <span class="enscript-string">&quot;System shutdown; requesting immediate kextd exit.&quot;</span>);

    checkResult = _OSKextCreateRequest(kKextRequestPredicateRequestKextdExit,
        &amp;exitRequest);
    <span class="enscript-keyword">if</span> (checkResult != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (!sKernelRequests-&gt;setObject(exitRequest)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-reference">OSKext</span>::pingKextd();

<span class="enscript-reference">finish</span>:
#<span class="enscript-reference">endif</span>

    IORecursiveLockUnlock(sKextLock);

    OSSafeRelease(exitRequest);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::getLoadEnabled</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextLock);
    result = sLoadEnabled;
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setLoadEnabled</span>(<span class="enscript-type">bool</span> flag)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextLock);
    result = sLoadEnabled;
    sLoadEnabled = (flag ? true : false);
    
    <span class="enscript-keyword">if</span> (sLoadEnabled != result) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogBasicLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext loading now %sabled.&quot;</span>, sLoadEnabled ? <span class="enscript-string">&quot;en&quot;</span> : <span class="enscript-string">&quot;dis&quot;</span>);
    }

    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::getUnloadEnabled</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextLock);
    result = sUnloadEnabled;
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setUnloadEnabled</span>(<span class="enscript-type">bool</span> flag)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextLock);
    result = sUnloadEnabled;
    sUnloadEnabled = (flag ? true : false);
    IORecursiveLockUnlock(sKextLock);
    
    <span class="enscript-keyword">if</span> (sUnloadEnabled != result) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogBasicLevel |
            kOSKextLogGeneralFlag | kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext unloading now %sabled.&quot;</span>, sUnloadEnabled ? <span class="enscript-string">&quot;en&quot;</span> : <span class="enscript-string">&quot;dis&quot;</span>);
    }

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::getAutounloadEnabled</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextInnerLock);
    result = sAutounloadEnabled ? true : false;
    IORecursiveLockUnlock(sKextInnerLock);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setAutounloadsEnabled</span>(<span class="enscript-type">bool</span> flag)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextInnerLock);

    result = sAutounloadEnabled;
    sAutounloadEnabled = (flag ? true : false);
    <span class="enscript-keyword">if</span> (!sAutounloadEnabled &amp;&amp; sUnloadCallout) {
        thread_call_cancel(sUnloadCallout);
    }
    
    <span class="enscript-keyword">if</span> (sAutounloadEnabled != result) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogBasicLevel |
            kOSKextLogGeneralFlag | kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext autounloading now %sabled.&quot;</span>,
            sAutounloadEnabled ? <span class="enscript-string">&quot;en&quot;</span> : <span class="enscript-string">&quot;dis&quot;</span>);
    }

    IORecursiveLockUnlock(sKextInnerLock);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* instance method operating on OSKext field */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setAutounloadEnabled</span>(<span class="enscript-type">bool</span> flag)
{
    <span class="enscript-type">bool</span> result = flags.autounloadEnabled ? true : false;
    flags.autounloadEnabled = flag ? 1 : 0;
    
    <span class="enscript-keyword">if</span> (result != (flag ? true : false)) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Autounloading for kext %s now %sabled.&quot;</span>,
            getIdentifierCString(),
            flags.autounloadEnabled ? <span class="enscript-string">&quot;en&quot;</span> : <span class="enscript-string">&quot;dis&quot;</span>);
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setKernelRequestsEnabled</span>(<span class="enscript-type">bool</span> flag)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextLock);
    result = sKernelRequestsEnabled;
    sKernelRequestsEnabled = flag ? true : false;
    
    <span class="enscript-keyword">if</span> (sKernelRequestsEnabled != result) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogBasicLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Kernel requests now %sabled.&quot;</span>,
            sKernelRequestsEnabled ? <span class="enscript-string">&quot;en&quot;</span> : <span class="enscript-string">&quot;dis&quot;</span>);
    }
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::getKernelRequestsEnabled</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span> result;

    IORecursiveLockLock(sKextLock);
    result = sKernelRequestsEnabled;
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Kext</span> <span class="enscript-variable-name">Life</span> <span class="enscript-variable-name">Cycle</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::withPrelinkedInfoDict</span>(
    OSDictionary * anInfoDict)
{
    OSKext * newKext = <span class="enscript-keyword">new</span> OSKext;

    <span class="enscript-keyword">if</span> (newKext &amp;&amp; !newKext-&gt;initWithPrelinkedInfoDict(anInfoDict)) {
        newKext-&gt;release();
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">return</span> newKext;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::initWithPrelinkedInfoDict</span>(
    OSDictionary * anInfoDict)
{
    <span class="enscript-type">bool</span>            result              = false;
    OSString      * kextPath            = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber      * addressNum          = NULL;  <span class="enscript-comment">// reused; do not release
</span>    OSNumber      * lengthNum           = NULL;  <span class="enscript-comment">// reused; do not release
</span>    <span class="enscript-type">void</span>          * data                = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">void</span>          * srcData             = NULL;  <span class="enscript-comment">// do not free
</span>    OSData        * prelinkedExecutable = NULL;  <span class="enscript-comment">// must release
</span>    uint32_t        length              = 0;     <span class="enscript-comment">// reused
</span>
    <span class="enscript-keyword">if</span> (!super::init()) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Get the path. Don't look for an arch-specific path property.
    */</span>
    kextPath = OSDynamicCast(OSString,
        anInfoDict-&gt;getObject(kPrelinkBundlePathKey));

    <span class="enscript-keyword">if</span> (!setInfoDictionaryAndPath(anInfoDict, kextPath)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
    IOLog(<span class="enscript-string">&quot;kaslr: kext %s \n&quot;</span>, getIdentifierCString());
#<span class="enscript-reference">endif</span>

   <span class="enscript-comment">/* Also get the executable's bundle-relative path if present.
    * Don't look for an arch-specific path property.
    */</span>
    executableRelPath = OSDynamicCast(OSString,
        anInfoDict-&gt;getObject(kPrelinkExecutableRelativePathKey));
    <span class="enscript-keyword">if</span> (executableRelPath) {
        executableRelPath-&gt;retain();
    }

   <span class="enscript-comment">/* Don't need the paths to be in the info dictionary any more.
    */</span>
    anInfoDict-&gt;removeObject(kPrelinkBundlePathKey);
    anInfoDict-&gt;removeObject(kPrelinkExecutableRelativePathKey);

   <span class="enscript-comment">/* Create an OSData wrapper around the linked executable.
    */</span>
    addressNum = OSDynamicCast(OSNumber,
        anInfoDict-&gt;getObject(kPrelinkExecutableLoadKey));
    <span class="enscript-keyword">if</span> (addressNum) {
        lengthNum = OSDynamicCast(OSNumber,
            anInfoDict-&gt;getObject(kPrelinkExecutableSizeKey));
        <span class="enscript-keyword">if</span> (!lengthNum) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Kext %s can't find prelinked kext executable size.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        data = (<span class="enscript-type">void</span> *) ((intptr_t) (addressNum-&gt;unsigned64BitValue()) + vm_kernel_slide);
        length = (uint32_t) (lengthNum-&gt;unsigned32BitValue());

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
        IOLog(<span class="enscript-string">&quot;kaslr: unslid 0x%lx slid 0x%lx length %u - prelink executable \n&quot;</span>, 
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(data), 
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)data,
              length);
#<span class="enscript-reference">endif</span>

        anInfoDict-&gt;removeObject(kPrelinkExecutableLoadKey);
        anInfoDict-&gt;removeObject(kPrelinkExecutableSizeKey);

       <span class="enscript-comment">/* If the kext's load address differs from its source address, allocate
        * space in the kext map at the load address and copy the kext over.
        */</span>
        addressNum = OSDynamicCast(OSNumber, anInfoDict-&gt;getObject(kPrelinkExecutableSourceKey));
        <span class="enscript-keyword">if</span> (addressNum) {
            srcData = (<span class="enscript-type">void</span> *) ((intptr_t) (addressNum-&gt;unsigned64BitValue()) + vm_kernel_slide);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
            IOLog(<span class="enscript-string">&quot;kaslr: unslid 0x%lx slid 0x%lx - prelink executable source \n&quot;</span>, 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(srcData), 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)srcData);
#<span class="enscript-reference">endif</span>

            <span class="enscript-keyword">if</span> (data != srcData) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
                kern_return_t alloc_result;

                alloc_result = kext_alloc((vm_offset_t *)&amp;data, length, <span class="enscript-comment">/* fixed */</span> TRUE);
                <span class="enscript-keyword">if</span> (alloc_result != KERN_SUCCESS) {
                    OSKextLog(<span class="enscript-keyword">this</span>,
                        kOSKextLogErrorLevel | kOSKextLogGeneralFlag,
                        <span class="enscript-string">&quot;Failed to allocate space for prelinked kext %s.&quot;</span>,
                        getIdentifierCString());
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                memcpy(data, srcData, length);
#<span class="enscript-reference">else</span>
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel | kOSKextLogGeneralFlag,
                    <span class="enscript-string">&quot;Error: prelinked kext %s - source and load addresses &quot;</span>
                    <span class="enscript-string">&quot;differ on ILP32 architecture.&quot;</span>,
                    getIdentifierCString());
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
            }

            anInfoDict-&gt;removeObject(kPrelinkExecutableSourceKey);
        }

        prelinkedExecutable = OSData::withBytesNoCopy(data, length);
        <span class="enscript-keyword">if</span> (!prelinkedExecutable) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag | kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Kext %s failed to create executable wrapper.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
        prelinkedExecutable-&gt;setDeallocFunction(osdata_kext_free);
#<span class="enscript-reference">else</span>
        prelinkedExecutable-&gt;setDeallocFunction(osdata_phys_free);
#<span class="enscript-reference">endif</span>
        setLinkedExecutable(prelinkedExecutable);
        addressNum = OSDynamicCast(OSNumber,
            anInfoDict-&gt;getObject(kPrelinkKmodInfoKey));
        <span class="enscript-keyword">if</span> (!addressNum) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag, 
                <span class="enscript-string">&quot;Kext %s can't find prelinked kext kmod_info address.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">if</span> (addressNum-&gt;unsigned64BitValue() != 0) {
            kmod_info = (kmod_info_t *) (intptr_t) (addressNum-&gt;unsigned64BitValue() + vm_kernel_slide);
            kmod_info-&gt;address += vm_kernel_slide;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
            IOLog(<span class="enscript-string">&quot;kaslr: unslid 0x%lx slid 0x%lx - kmod_info \n&quot;</span>, 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(kmod_info), 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)kmod_info);
            IOLog(<span class="enscript-string">&quot;kaslr: unslid 0x%lx slid 0x%lx - kmod_info-&gt;address \n&quot;</span>, 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(kmod_info-&gt;address), 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)kmod_info-&gt;address);
 #endif
        }

        anInfoDict-&gt;removeObject(kPrelinkKmodInfoKey);
    }

   <span class="enscript-comment">/* If the plist has a UUID for an interface, save that off.
    */</span>
    <span class="enscript-keyword">if</span> (isInterface()) {
        interfaceUUID = OSDynamicCast(OSData,
            anInfoDict-&gt;getObject(kPrelinkInterfaceUUIDKey));
        <span class="enscript-keyword">if</span> (interfaceUUID) {
            interfaceUUID-&gt;retain();
            anInfoDict-&gt;removeObject(kPrelinkInterfaceUUIDKey);
        }
    }

    result = slidePrelinkedExecutable();
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* set VM protections now, wire later at kext load */</span>
    result = setVMAttributes(true, false);
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    flags.prelinked = true;

   <span class="enscript-comment">/* If we created a kext from prelink info,
    * we must be booting from a prelinked kernel.
    */</span>
    sPrelinkBoot = true;

    result = registerIdentifier();

<span class="enscript-reference">finish</span>:
    OSSafeRelease(prelinkedExecutable);

    <span class="enscript-keyword">return</span> result;
}
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::withBooterData</span>(
    OSString * deviceTreeName,
    OSData   * booterData)
{
    OSKext * newKext = <span class="enscript-keyword">new</span> OSKext;

    <span class="enscript-keyword">if</span> (newKext &amp;&amp; !newKext-&gt;initWithBooterData(deviceTreeName, booterData)) {
        newKext-&gt;release();
        <span class="enscript-keyword">return</span> NULL;
    }
    
    <span class="enscript-keyword">return</span> newKext;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _BooterKextFileInfo {
    uint32_t  infoDictPhysAddr;
    uint32_t  infoDictLength;
    uint32_t  executablePhysAddr;
    uint32_t  executableLength;
    uint32_t  bundlePathPhysAddr;
    uint32_t  bundlePathLength;
} _BooterKextFileInfo;

<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::initWithBooterData</span>(
    OSString * deviceTreeName,
    OSData   * booterData)
{
    <span class="enscript-type">bool</span>                  result         = false;
    _BooterKextFileInfo * kextFileInfo   = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">char</span>                * infoDictAddr   = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">void</span>                * executableAddr = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">char</span>                * bundlePathAddr = NULL;  <span class="enscript-comment">// do not free
</span>
    OSObject            * parsedXML      = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary        * theInfoDict    = NULL;  <span class="enscript-comment">// do not release
</span>    OSString            * kextPath       = NULL;  <span class="enscript-comment">// must release
</span>    OSString            * errorString    = NULL;  <span class="enscript-comment">// must release
</span>    OSData              * executable     = NULL;  <span class="enscript-comment">// must release
</span>
    <span class="enscript-keyword">if</span> (!super::init()) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    kextFileInfo = (_BooterKextFileInfo *)booterData-&gt;getBytesNoCopy();
    <span class="enscript-keyword">if</span> (!kextFileInfo) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag, 
            <span class="enscript-string">&quot;No booter-provided data for kext device tree entry %s.&quot;</span>,
            deviceTreeName-&gt;getCStringNoCopy());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* The info plist must exist or we can't read the kext.
    */</span>
    <span class="enscript-keyword">if</span> (!kextFileInfo-&gt;infoDictPhysAddr || !kextFileInfo-&gt;infoDictLength) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag, 
            <span class="enscript-string">&quot;No kext info dictionary for booter device tree entry %s.&quot;</span>,
            deviceTreeName-&gt;getCStringNoCopy());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    infoDictAddr = (<span class="enscript-type">char</span> *)ml_static_ptovirt(kextFileInfo-&gt;infoDictPhysAddr);
    <span class="enscript-keyword">if</span> (!infoDictAddr) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag, 
            <span class="enscript-string">&quot;Can't translate physical address 0x%x of kext info dictionary &quot;</span>
            <span class="enscript-string">&quot;for device tree entry %s.&quot;</span>,
            (<span class="enscript-type">int</span>)kextFileInfo-&gt;infoDictPhysAddr,
            deviceTreeName-&gt;getCStringNoCopy());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    parsedXML = OSUnserializeXML(infoDictAddr, &amp;errorString);
    <span class="enscript-keyword">if</span> (parsedXML) {
        theInfoDict = OSDynamicCast(OSDictionary, parsedXML);
    }
    <span class="enscript-keyword">if</span> (!theInfoDict) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * errorCString = <span class="enscript-string">&quot;(unknown error)&quot;</span>;
        
        <span class="enscript-keyword">if</span> (errorString &amp;&amp; errorString-&gt;getCStringNoCopy()) {
            errorCString = errorString-&gt;getCStringNoCopy();
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parsedXML) {
            errorCString = <span class="enscript-string">&quot;not a dictionary&quot;</span>;
        }
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag, 
            <span class="enscript-string">&quot;Error unserializing info dictionary for device tree entry %s: %s.&quot;</span>,
            deviceTreeName-&gt;getCStringNoCopy(), errorCString);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* A bundle path is not mandatory.
    */</span>
    <span class="enscript-keyword">if</span> (kextFileInfo-&gt;bundlePathPhysAddr &amp;&amp; kextFileInfo-&gt;bundlePathLength) {
        bundlePathAddr = (<span class="enscript-type">char</span> *)ml_static_ptovirt(kextFileInfo-&gt;bundlePathPhysAddr);
        <span class="enscript-keyword">if</span> (!bundlePathAddr) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag, 
                <span class="enscript-string">&quot;Can't translate physical address 0x%x of kext bundle path &quot;</span>
                <span class="enscript-string">&quot;for device tree entry %s.&quot;</span>,
                (<span class="enscript-type">int</span>)kextFileInfo-&gt;bundlePathPhysAddr,
                deviceTreeName-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        bundlePathAddr[kextFileInfo-&gt;bundlePathLength-1] = <span class="enscript-string">'\0'</span>; <span class="enscript-comment">// just in case!
</span>        
        kextPath = OSString::withCString(bundlePathAddr);
        <span class="enscript-keyword">if</span> (!kextPath) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag, 
                <span class="enscript-string">&quot;Failed to create wrapper for device tree entry %s kext path %s.&quot;</span>,
                deviceTreeName-&gt;getCStringNoCopy(), bundlePathAddr);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    <span class="enscript-keyword">if</span> (!setInfoDictionaryAndPath(theInfoDict, kextPath)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* An executable is not mandatory.
    */</span>
    <span class="enscript-keyword">if</span> (kextFileInfo-&gt;executablePhysAddr &amp;&amp; kextFileInfo-&gt;executableLength) {
        executableAddr = (<span class="enscript-type">void</span> *)ml_static_ptovirt(kextFileInfo-&gt;executablePhysAddr);
        <span class="enscript-keyword">if</span> (!executableAddr) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag, 
                <span class="enscript-string">&quot;Can't translate physical address 0x%x of kext executable &quot;</span>
                <span class="enscript-string">&quot;for device tree entry %s.&quot;</span>,
                (<span class="enscript-type">int</span>)kextFileInfo-&gt;executablePhysAddr,
                deviceTreeName-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        executable = OSData::withBytesNoCopy(executableAddr,
            kextFileInfo-&gt;executableLength);
        <span class="enscript-keyword">if</span> (!executable) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag, 
                <span class="enscript-string">&quot;Failed to create executable wrapper for device tree entry %s.&quot;</span>,
                deviceTreeName-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* A kext with an executable needs to retain the whole booterData
        * object to keep the executable in memory.
        */</span>
        <span class="enscript-keyword">if</span> (!setExecutable(executable, booterData)) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag, 
                <span class="enscript-string">&quot;Failed to set kext executable for device tree entry %s.&quot;</span>,
                deviceTreeName-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    result = registerIdentifier();

<span class="enscript-reference">finish</span>:
    OSSafeRelease(parsedXML);
    OSSafeRelease(kextPath);
    OSSafeRelease(errorString);
    OSSafeRelease(executable);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::registerIdentifier</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span>            result              = false;
    OSKext        * existingKext        = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">bool</span>            existingIsLoaded    = false;
    <span class="enscript-type">bool</span>            existingIsPrelinked = false;
    OSKextVersion   newVersion          = -1;
    OSKextVersion   existingVersion     = -1;
    <span class="enscript-type">char</span>            newVersionCString[kOSKextVersionMaxLength];
    <span class="enscript-type">char</span>            existingVersionCString[kOSKextVersionMaxLength];
    OSData        * newUUID             = NULL;  <span class="enscript-comment">// must release
</span>    OSData        * existingUUID        = NULL;  <span class="enscript-comment">// must release
</span>
    IORecursiveLockLock(sKextLock);

   <span class="enscript-comment">/* Get the new kext's version for checks &amp; log messages.
    */</span>
    newVersion = getVersion();
    OSKextVersionGetString(newVersion, newVersionCString,
        kOSKextVersionMaxLength);

   <span class="enscript-comment">/* If we don't have an existing kext with this identifier,
    * just record the new kext and we're done!
    */</span>
    existingKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(bundleID));
    <span class="enscript-keyword">if</span> (!existingKext) {
        sKextsByID-&gt;setObject(bundleID, <span class="enscript-keyword">this</span>);
        result = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Get the existing kext's version for checks &amp; log messages.
    */</span>
    existingVersion = existingKext-&gt;getVersion();
    OSKextVersionGetString(existingVersion,
        existingVersionCString, kOSKextVersionMaxLength);

    existingIsLoaded = existingKext-&gt;isLoaded();
    existingIsPrelinked = existingKext-&gt;isPrelinked();

   <span class="enscript-comment">/* If we have a kext with this identifier that's already loaded/prelinked,
    * we can't use the new one, but let's be really thorough and check how
    * the two are related for a precise diagnostic log message.
    *
    * Note that user space can't find out about nonloaded prelinked kexts,
    * so in this case we log a message when new &amp; existing are equivalent
    * at the step rather than warning level, because we are always going
    * be getting a copy of the kext in the user load request mkext.
    */</span>
    <span class="enscript-keyword">if</span> (existingIsLoaded || existingIsPrelinked) {
        <span class="enscript-type">bool</span> sameVersion = (newVersion == existingVersion);
        <span class="enscript-type">bool</span> sameExecutable = true;  <span class="enscript-comment">// assume true unless we have UUIDs
</span>
       <span class="enscript-comment">/* Only get the UUID if the existing kext is loaded. Doing so
        * might have to uncompress an mkext executable and we shouldn't
        * take that hit when neither kext is loaded.
        */</span>
        newUUID = copyUUID();
        existingUUID = existingKext-&gt;copyUUID();

       <span class="enscript-comment">/* I'm entirely too paranoid about checking equivalence of executables,
        * but I remember nasty problems with it in the past.
        *
        * - If we have UUIDs for both kexts, compare them.
        * - If only one kext has a UUID, they're definitely different.
        */</span>
        <span class="enscript-keyword">if</span> (newUUID &amp;&amp; existingUUID) {
            sameExecutable = newUUID-&gt;isEqualTo(existingUUID);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newUUID || existingUUID) {
            sameExecutable = false;
        }
        
        <span class="enscript-keyword">if</span> (!newUUID &amp;&amp; !existingUUID) {

           <span class="enscript-comment">/* If there are no UUIDs, we can't really tell that the executables
            * are *different* without a lot of work; the loaded kext's
            * unrelocated executable is no longer around (and we never had it
            * in-kernel for a prelinked kext). We certainly don't want to do
            * a whole fake link for the new kext just to compare, either.
            */</span>

            OSKextVersionGetString(version, newVersionCString,
                <span class="enscript-keyword">sizeof</span>(newVersionCString));
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogWarningLevel |
                kOSKextLogKextBookkeepingFlag,
                <span class="enscript-string">&quot;Notice - new kext %s, v%s matches %s kext &quot;</span>
                <span class="enscript-string">&quot;but can't determine if executables are the same (no UUIDs).&quot;</span>,
                getIdentifierCString(),
                newVersionCString,
                (existingIsLoaded ? <span class="enscript-string">&quot;loaded&quot;</span> : <span class="enscript-string">&quot;prelinked&quot;</span>));
        }

        <span class="enscript-keyword">if</span> (sameVersion &amp;&amp; sameExecutable) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                (existingIsLoaded ? kOSKextLogWarningLevel : kOSKextLogStepLevel) |
                kOSKextLogKextBookkeepingFlag,
                <span class="enscript-string">&quot;Refusing new kext %s, v%s: a %s copy is already present &quot;</span>
                <span class="enscript-string">&quot;(same version and executable).&quot;</span>,
                getIdentifierCString(), newVersionCString,
                (existingIsLoaded ? <span class="enscript-string">&quot;loaded&quot;</span> : <span class="enscript-string">&quot;prelinked&quot;</span>));
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">if</span> (!sameVersion) {
               <span class="enscript-comment">/* This condition is significant so log it under warnings.
                */</span>
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogWarningLevel |
                    kOSKextLogKextBookkeepingFlag,
                    <span class="enscript-string">&quot;Refusing new kext %s, v%s: already have %s v%s.&quot;</span>,
                    getIdentifierCString(),
                    newVersionCString,
                    (existingIsLoaded ? <span class="enscript-string">&quot;loaded&quot;</span> : <span class="enscript-string">&quot;prelinked&quot;</span>),
                    existingVersionCString);
            } <span class="enscript-keyword">else</span> {
               <span class="enscript-comment">/* This condition is significant so log it under warnings.
                */</span>
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogWarningLevel | kOSKextLogKextBookkeepingFlag,
                    <span class="enscript-string">&quot;Refusing new kext %s, v%s: a %s copy with a different &quot;</span>
                    <span class="enscript-string">&quot;executable UUID is already present.&quot;</span>,
                    getIdentifierCString(), newVersionCString,
                    (existingIsLoaded ? <span class="enscript-string">&quot;loaded&quot;</span> : <span class="enscript-string">&quot;prelinked&quot;</span>));
            }
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    } <span class="enscript-comment">/* if (existingIsLoaded || existingIsPrelinked) */</span>

   <span class="enscript-comment">/* We have two nonloaded/nonprelinked kexts, so our decision depends on whether
    * user loads are happening or if we're still in early boot. User agents are
    * supposed to resolve dependencies topside and include only the exact
    * kexts needed; so we always accept the new kext (in fact we should never
    * see an older unloaded copy hanging around).
    */</span>
    <span class="enscript-keyword">if</span> (sUserLoadsActive) {
        sKextsByID-&gt;setObject(bundleID, <span class="enscript-keyword">this</span>);
        result = true;

        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Dropping old copy of kext %s (v%s) for newly-added (v%s).&quot;</span>,
            getIdentifierCString(),
            existingVersionCString,
            newVersionCString);

        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
   <span class="enscript-comment">/* During early boot, the kext with the highest version always wins out.
    * Prelinked kernels will never hit this, but mkexts and booter-read
    * kexts might have duplicates.
    */</span>
    <span class="enscript-keyword">if</span> (newVersion &gt; existingVersion) {
        sKextsByID-&gt;setObject(bundleID, <span class="enscript-keyword">this</span>);
        result = true;

        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Dropping lower version (v%s) of registered kext %s for higher (v%s).&quot;</span>,
            existingVersionCString,
            getIdentifierCString(),
            newVersionCString);

    } <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Kext %s is already registered with a higher/same version (v%s); &quot;</span>
            <span class="enscript-string">&quot;dropping newly-added (v%s).&quot;</span>,
            getIdentifierCString(),
            existingVersionCString,
            newVersionCString);
    }

   <span class="enscript-comment">/* result has been set appropriately by now. */</span>

<span class="enscript-reference">finish</span>:

    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">if</span> (result) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Kext %s, v%s registered and available for loading.&quot;</span>,
            getIdentifierCString(), newVersionCString);
    }

    OSSafeRelease(newUUID);
    OSSafeRelease(existingUUID);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Does the bare minimum validation to look up a kext.
* All other validation is done on the spot as needed.
**********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setInfoDictionaryAndPath</span>(
    OSDictionary * aDictionary,
    OSString     * aPath)
{
    <span class="enscript-type">bool</span>           result                   = false;
    OSString     * bundleIDString           = NULL;  <span class="enscript-comment">// do not release
</span>    OSString     * versionString            = NULL;  <span class="enscript-comment">// do not release
</span>    OSString     * compatibleVersionString  = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * versionCString           = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * compatibleVersionCString = NULL;  <span class="enscript-comment">// do not free
</span>    OSBoolean    * scratchBool              = NULL;  <span class="enscript-comment">// do not release
</span>    OSDictionary * scratchDict              = NULL;  <span class="enscript-comment">// do not release
</span>
    <span class="enscript-keyword">if</span> (infoDict) {
        panic(<span class="enscript-string">&quot;Attempt to set info dictionary on a kext &quot;</span>
            <span class="enscript-string">&quot;that already has one (%s).&quot;</span>,
            getIdentifierCString());
    }

    <span class="enscript-keyword">if</span> (!aDictionary || !OSDynamicCast(OSDictionary, aDictionary)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    infoDict = aDictionary;
    infoDict-&gt;retain();

   <span class="enscript-comment">/* Check right away if the info dictionary has any log flags.
    */</span>
    scratchBool = OSDynamicCast(OSBoolean,
        getPropertyForHostArch(kOSBundleEnableKextLoggingKey));
    <span class="enscript-keyword">if</span> (scratchBool == kOSBooleanTrue) {
        flags.loggingEnabled = 1;
    }

   <span class="enscript-comment">/* The very next thing to get is the bundle identifier. Unlike
    * in user space, a kext with no bundle identifier gets axed
    * immediately.
    */</span>
    bundleIDString = OSDynamicCast(OSString,
        getPropertyForHostArch(kCFBundleIdentifierKey));
    <span class="enscript-keyword">if</span> (!bundleIDString) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag,
            <span class="enscript-string">&quot;CFBundleIdentifier missing/invalid type in kext %s.&quot;</span>,
            aPath ? aPath-&gt;getCStringNoCopy() : <span class="enscript-string">&quot;(unknown)&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    bundleID = OSSymbol::withString(bundleIDString);
    <span class="enscript-keyword">if</span> (!bundleID) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag,
            <span class="enscript-string">&quot;Can't copy bundle identifier as symbol for kext %s.&quot;</span>,
            bundleIDString-&gt;getCStringNoCopy());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Save the path if we got one (it should always be available but it's
    * just something nice to have for bookkeeping).
    */</span>
    <span class="enscript-keyword">if</span> (aPath) {
        path = aPath;
        path-&gt;retain();
    }

   <span class="enscript-comment">/*****
    * Minimal validation to initialize. We'll do other validation on the spot.
    */</span>
    <span class="enscript-keyword">if</span> (bundleID-&gt;getLength() &gt;= KMOD_MAX_NAME) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag,
            <span class="enscript-string">&quot;Kext %s error - CFBundleIdentifier over max length %d.&quot;</span>,
            getIdentifierCString(), KMOD_MAX_NAME - 1);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    version = compatibleVersion = -1;

    versionString = OSDynamicCast(OSString,
        getPropertyForHostArch(kCFBundleVersionKey));
    <span class="enscript-keyword">if</span> (!versionString) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag,
            <span class="enscript-string">&quot;Kext %s error - CFBundleVersion missing/invalid type.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    versionCString = versionString-&gt;getCStringNoCopy();
    version = OSKextParseVersionString(versionCString);
    <span class="enscript-keyword">if</span> (version &lt; 0) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag,
            <span class="enscript-string">&quot;Kext %s error - CFBundleVersion bad value '%s'.&quot;</span>,
            getIdentifierCString(), versionCString);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    compatibleVersion = -1;  <span class="enscript-comment">// set to illegal value for kexts that don't have
</span>
    compatibleVersionString = OSDynamicCast(OSString,
        getPropertyForHostArch(kOSBundleCompatibleVersionKey));
    <span class="enscript-keyword">if</span> (compatibleVersionString) {
        compatibleVersionCString = compatibleVersionString-&gt;getCStringNoCopy();
        compatibleVersion = OSKextParseVersionString(compatibleVersionCString);
        <span class="enscript-keyword">if</span> (compatibleVersion &lt; 0) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogValidationFlag,
                <span class="enscript-string">&quot;Kext %s error - OSBundleCompatibleVersion bad value '%s'.&quot;</span>,
                getIdentifierCString(), compatibleVersionCString);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">if</span> (compatibleVersion &gt; version) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogValidationFlag,
                <span class="enscript-string">&quot;Kext %s error - %s %s &gt; %s %s (must be &lt;=).&quot;</span>,
                getIdentifierCString(),
                kOSBundleCompatibleVersionKey, compatibleVersionCString,
                kCFBundleVersionKey,  versionCString);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    
    <span class="enscript-comment">/* Check to see if this kext is in exclude list */</span>
    <span class="enscript-keyword">if</span> ( isInExcludeList() ) {
        OSKextLog(<span class="enscript-keyword">this</span>,
                  kOSKextLogErrorLevel | kOSKextLogGeneralFlag,
                  <span class="enscript-string">&quot;Kext %s is in exclude list, not loadable&quot;</span>,
                  getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Set flags for later use if the infoDict gets flushed. We only
    * check for true values, not false ones(!)
    */</span>
    scratchBool = OSDynamicCast(OSBoolean,
        getPropertyForHostArch(kOSBundleIsInterfaceKey));
    <span class="enscript-keyword">if</span> (scratchBool == kOSBooleanTrue) {
        flags.interface = 1;
    }
    
    scratchBool = OSDynamicCast(OSBoolean,
        getPropertyForHostArch(kOSKernelResourceKey));
    <span class="enscript-keyword">if</span> (scratchBool == kOSBooleanTrue) {
        flags.kernelComponent = 1;
        flags.interface = 1;  <span class="enscript-comment">// xxx - hm. the kernel itself isn't an interface...
</span>        flags.started = 1;
        
       <span class="enscript-comment">/* A kernel component has one implicit dependency on the kernel.
        */</span>
        flags.hasAllDependencies = 1;
    }

   <span class="enscript-comment">/* Make sure common string values in personalities are uniqued to OSSymbols.
    */</span>
    scratchDict = OSDynamicCast(OSDictionary, 
        getPropertyForHostArch(kIOKitPersonalitiesKey));
    <span class="enscript-keyword">if</span> (scratchDict) {
        uniquePersonalityProperties(scratchDict);
    }

    result = true;

<span class="enscript-reference">finish</span>:

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Not used for prelinked kernel boot as there is no unrelocated
* executable.
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::setExecutable</span>(
    OSData * anExecutable,
    OSData * externalData,
    <span class="enscript-type">bool</span>     externalDataIsMkext)
{
    <span class="enscript-type">bool</span>         result        = false;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * executableKey = NULL;  <span class="enscript-comment">// do not free
</span>
    <span class="enscript-keyword">if</span> (!anExecutable) {
        infoDict-&gt;removeObject(_kOSKextExecutableKey);
        infoDict-&gt;removeObject(_kOSKextMkextExecutableReferenceKey);
        infoDict-&gt;removeObject(_kOSKextExecutableExternalDataKey);
        result = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">if</span> (infoDict-&gt;getObject(_kOSKextExecutableKey) ||
        infoDict-&gt;getObject(_kOSKextMkextExecutableReferenceKey)) {

        panic(<span class="enscript-string">&quot;Attempt to set an executable on a kext &quot;</span>
            <span class="enscript-string">&quot;that already has one (%s).&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (externalDataIsMkext) {
        executableKey = _kOSKextMkextExecutableReferenceKey;
    } <span class="enscript-keyword">else</span> {
        executableKey = _kOSKextExecutableKey;
    }

    <span class="enscript-keyword">if</span> (anExecutable) {
        infoDict-&gt;setObject(executableKey, anExecutable);
        <span class="enscript-keyword">if</span> (externalData) {
            infoDict-&gt;setObject(_kOSKextExecutableExternalDataKey, externalData);
        }
    }

    result = true;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">uniqueStringPlistProperty</span>(OSDictionary * dict, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key)
{
    OSString       * stringValue = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">const</span> OSSymbol * symbolValue = NULL;  <span class="enscript-comment">// must release
</span>
    stringValue = OSDynamicCast(OSString, dict-&gt;getObject(key));
    <span class="enscript-keyword">if</span> (!stringValue) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    symbolValue = OSSymbol::withString(stringValue);
    <span class="enscript-keyword">if</span> (!symbolValue) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    dict-&gt;setObject(key, symbolValue);
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (symbolValue) symbolValue-&gt;release();

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">uniqueStringPlistProperty</span>(OSDictionary * dict, <span class="enscript-type">const</span> OSString * key)
{
    OSString       * stringValue = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">const</span> OSSymbol * symbolValue = NULL;  <span class="enscript-comment">// must release
</span>
    stringValue = OSDynamicCast(OSString, dict-&gt;getObject(key));
    <span class="enscript-keyword">if</span> (!stringValue) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    symbolValue = OSSymbol::withString(stringValue);
    <span class="enscript-keyword">if</span> (!symbolValue) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    dict-&gt;setObject(key, symbolValue);
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (symbolValue) symbolValue-&gt;release();

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Replace common personality property values with uniqued instances
* to save on wired memory.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::uniquePersonalityProperties</span>(OSDictionary * personalityDict)
{
   <span class="enscript-comment">/* Properties every personality has.
    */</span>
    uniqueStringPlistProperty(personalityDict, kCFBundleIdentifierKey);
    uniqueStringPlistProperty(personalityDict, kIOProviderClassKey);
    uniqueStringPlistProperty(personalityDict, gIOClassKey);
    
   <span class="enscript-comment">/* Other commonly used properties.
    */</span>
    uniqueStringPlistProperty(personalityDict, gIOMatchCategoryKey);
    uniqueStringPlistProperty(personalityDict, gIOResourceMatchKey);
    uniqueStringPlistProperty(personalityDict, gIOUserClientClassKey);

    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;HIDDefaultBehavior&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;HIDPointerAccelerationType&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;HIDRemoteControlType&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;HIDScrollAccelerationType&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;IOPersonalityPublisher&quot;</span>); 
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;Physical Interconnect&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;Physical Interconnect Location&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;Vendor&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;Vendor Identification&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;Vendor Name&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;bConfigurationValue&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;bInterfaceNumber&quot;</span>);
    uniqueStringPlistProperty(personalityDict, <span class="enscript-string">&quot;idProduct&quot;</span>);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::free</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (isLoaded()) {
        panic(<span class="enscript-string">&quot;Attempt to free loaded kext %s.&quot;</span>, getIdentifierCString());
    }

    OSSafeRelease(infoDict);
    OSSafeRelease(bundleID);
    OSSafeRelease(path);
    OSSafeRelease(executableRelPath);
    OSSafeRelease(dependencies);
    OSSafeRelease(linkedExecutable);
    OSSafeRelease(metaClasses);
    OSSafeRelease(interfaceUUID);

    <span class="enscript-keyword">if</span> (isInterface() &amp;&amp; kmod_info) {
        kfree(kmod_info, <span class="enscript-keyword">sizeof</span>(kmod_info_t));
    }

    <span class="enscript-reference">super</span>::free();
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Mkext</span> <span class="enscript-variable-name">files</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::readMkextArchive</span>(OSData * mkextData,
    uint32_t * checksumPtr)
{
    OSReturn       result       = kOSKextReturnBadData;
    uint32_t       mkextLength  = 0;
    mkext_header * mkextHeader  = 0;   <span class="enscript-comment">// do not free
</span>    uint32_t       mkextVersion = 0;

   <span class="enscript-comment">/* Note default return of kOSKextReturnBadData above.
    */</span>
    mkextLength = mkextData-&gt;getLength();
    <span class="enscript-keyword">if</span> (mkextLength &lt; <span class="enscript-keyword">sizeof</span>(mkext_basic_header)) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive too small to be valid.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    mkextHeader = (mkext_header *)mkextData-&gt;getBytesNoCopy();
    
    <span class="enscript-keyword">if</span> (MKEXT_GET_MAGIC(mkextHeader) != MKEXT_MAGIC ||
        MKEXT_GET_SIGNATURE(mkextHeader) != MKEXT_SIGN) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive has invalid magic or signature.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (MKEXT_GET_LENGTH(mkextHeader) != mkextLength) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive recorded length doesn't match actual file length.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    mkextVersion = MKEXT_GET_VERSION(mkextHeader);

    <span class="enscript-keyword">if</span> (mkextVersion == MKEXT_VERS_2) {
        result = OSKext::readMkext2Archive(mkextData, NULL, checksumPtr);
    } <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive of unsupported mkext version 0x%x.&quot;</span>, mkextVersion);
        result = kOSKextReturnUnsupported;
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Assumes magic, signature, version, length have been checked.
* xxx - need to add further bounds checking for each file entry
*
* Should keep track of all kexts created so far, and if we hit a
* fatal error halfway through, remove those kexts. If we've dropped
* an older version that had already been read, whoops! Might want to
* add a level of buffering?
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::readMkext2Archive</span>(
    OSData        * mkextData,
    OSDictionary ** mkextPlistOut,
    uint32_t      * checksumPtr)
{
    OSReturn        result                     = kOSReturnError;
    uint32_t        mkextLength;
    mkext2_header * mkextHeader                = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">void</span>          * mkextEnd                   = NULL;  <span class="enscript-comment">// do not free
</span>    uint32_t        mkextVersion;
    uint8_t       * crc_address                = NULL;
    uint32_t        checksum;
    uint32_t        mkextPlistOffset;
    uint32_t        mkextPlistCompressedSize;
    <span class="enscript-type">char</span>          * mkextPlistEnd              = NULL;  <span class="enscript-comment">// do not free
</span>    uint32_t        mkextPlistFullSize;
    OSString      * errorString                = NULL;  <span class="enscript-comment">// must release
</span>    OSData        * mkextPlistUncompressedData = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span>    * mkextPlistDataBuffer       = NULL;  <span class="enscript-comment">// do not free
</span>    OSObject      * parsedXML                  = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary  * mkextPlist                 = NULL;  <span class="enscript-comment">// do not release
</span>    OSArray       * mkextInfoDictArray         = NULL;  <span class="enscript-comment">// do not release
</span>    uint32_t        count, i;

    mkextLength = mkextData-&gt;getLength();
    mkextHeader = (mkext2_header *)mkextData-&gt;getBytesNoCopy();
    mkextEnd = (<span class="enscript-type">char</span> *)mkextHeader + mkextLength;
    mkextVersion = MKEXT_GET_VERSION(mkextHeader);

    crc_address = (u_int8_t *)&amp;mkextHeader-&gt;version;
    checksum = mkext_adler32(crc_address,
        (uintptr_t)mkextHeader +
        MKEXT_GET_LENGTH(mkextHeader) - (uintptr_t)crc_address);

    <span class="enscript-keyword">if</span> (MKEXT_GET_CHECKSUM(mkextHeader) != checksum) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive has bad checksum.&quot;</span>);
        result = kOSKextReturnBadData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (checksumPtr) {
        *checksumPtr = checksum;
    }

   <span class="enscript-comment">/* Check that the CPU type &amp; subtype match that of the running kernel. */</span>
    <span class="enscript-keyword">if</span> (MKEXT_GET_CPUTYPE(mkextHeader) == (UInt32)CPU_TYPE_ANY) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive must have a specific CPU type.&quot;</span>);
        result = kOSKextReturnBadData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> ((UInt32)_mh_execute_header.cputype !=
            MKEXT_GET_CPUTYPE(mkextHeader)) {

            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Mkext archive does not match the running kernel's CPU type.&quot;</span>);
            result = kOSKextReturnArchNotFound;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    mkextPlistOffset = MKEXT2_GET_PLIST(mkextHeader);
    mkextPlistCompressedSize = MKEXT2_GET_PLIST_COMPSIZE(mkextHeader);
    mkextPlistEnd = (<span class="enscript-type">char</span> *)mkextHeader + mkextPlistOffset +
        mkextPlistCompressedSize;
    <span class="enscript-keyword">if</span> (mkextPlistEnd &gt; mkextEnd) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive file overrun.&quot;</span>);
        result = kOSKextReturnBadData;
    }

    mkextPlistFullSize = MKEXT2_GET_PLIST_FULLSIZE(mkextHeader);
    <span class="enscript-keyword">if</span> (mkextPlistCompressedSize) {
        mkextPlistUncompressedData = sKernelKext-&gt;extractMkext2FileData(
            (UInt8 *)mkextHeader + mkextPlistOffset,
            <span class="enscript-string">&quot;plist&quot;</span>,
            mkextPlistCompressedSize, mkextPlistFullSize);
        <span class="enscript-keyword">if</span> (!mkextPlistUncompressedData) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        mkextPlistDataBuffer = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)
            mkextPlistUncompressedData-&gt;getBytesNoCopy();
    } <span class="enscript-keyword">else</span> {
        mkextPlistDataBuffer = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)mkextHeader + mkextPlistOffset;
    }

   <span class="enscript-comment">/* IOCFSerialize added a nul byte to the end of the string. Very nice of it.
    */</span>
    parsedXML = OSUnserializeXML(mkextPlistDataBuffer, &amp;errorString);
    <span class="enscript-keyword">if</span> (parsedXML) {
        mkextPlist = OSDynamicCast(OSDictionary, parsedXML);
    }
    <span class="enscript-keyword">if</span> (!mkextPlist) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * errorCString = <span class="enscript-string">&quot;(unknown error)&quot;</span>;
        
        <span class="enscript-keyword">if</span> (errorString &amp;&amp; errorString-&gt;getCStringNoCopy()) {
            errorCString = errorString-&gt;getCStringNoCopy();
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parsedXML) {
            errorCString = <span class="enscript-string">&quot;not a dictionary&quot;</span>;
        }
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Error unserializing mkext plist: %s.&quot;</span>, errorCString);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* If the caller needs the plist, hand it back and retain it.
    * (This function releases it at the end.)
    */</span>
    <span class="enscript-keyword">if</span> (mkextPlistOut) {
        *mkextPlistOut = mkextPlist;
        (*mkextPlistOut)-&gt;retain();
    }

    mkextInfoDictArray = OSDynamicCast(OSArray,
        mkextPlist-&gt;getObject(kMKEXTInfoDictionariesKey));
    <span class="enscript-keyword">if</span> (!mkextInfoDictArray) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Mkext archive contains no kext info dictionaries.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    count = mkextInfoDictArray-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSDictionary * infoDict;


        infoDict = OSDynamicCast(OSDictionary,
            mkextInfoDictArray-&gt;getObject(i));
        
       <span class="enscript-comment">/* Create the kext for the entry, then release it, because the
        * kext system keeps them around until explicitly removed.
        * Any creation/registration failures are already logged for us.
        */</span>
        OSKext * newKext = OSKext::withMkext2Info(infoDict, mkextData);
        OSSafeRelease(newKext);
    }

   <span class="enscript-comment">/* Even if we didn't keep any kexts from the mkext, we may have a load
    * request to process, so we are successful (no errors occurred).
    */</span>
    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:

    OSSafeRelease(parsedXML);
    OSSafeRelease(mkextPlistUncompressedData);
    OSSafeRelease(errorString);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSKext *
<span class="enscript-function-name">OSKext::withMkext2Info</span>(
    OSDictionary * anInfoDict,
    OSData       * mkextData)
{
    OSKext * newKext = <span class="enscript-keyword">new</span> OSKext;

    <span class="enscript-keyword">if</span> (newKext &amp;&amp; !newKext-&gt;initWithMkext2Info(anInfoDict, mkextData)) {
        newKext-&gt;release();
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">return</span> newKext;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::initWithMkext2Info</span>(
    OSDictionary * anInfoDict,
    OSData       * mkextData)
{
    <span class="enscript-type">bool</span>                   result              = false;
    OSString             * kextPath            = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber             * executableOffsetNum = NULL;  <span class="enscript-comment">// do not release
</span>    OSCollectionIterator * iterator            = NULL;  <span class="enscript-comment">// must release
</span>    OSData               * executable          = NULL;  <span class="enscript-comment">// must release
</span>
    <span class="enscript-keyword">if</span> (!super::init()) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Get the path. Don't look for an arch-specific path property.
    */</span>
    kextPath = OSDynamicCast(OSString,
        anInfoDict-&gt;getObject(kMKEXTBundlePathKey));

    <span class="enscript-keyword">if</span> (!setInfoDictionaryAndPath(anInfoDict, kextPath)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* If we have a path to the executable, save it.
    */</span>
    executableRelPath = OSDynamicCast(OSString,
        anInfoDict-&gt;getObject(kMKEXTExecutableRelativePathKey));
    <span class="enscript-keyword">if</span> (executableRelPath) {
        executableRelPath-&gt;retain();
    }

   <span class="enscript-comment">/* Don't need the paths to be in the info dictionary any more.
    */</span>
    anInfoDict-&gt;removeObject(kMKEXTBundlePathKey);
    anInfoDict-&gt;removeObject(kMKEXTExecutableRelativePathKey);

    executableOffsetNum = OSDynamicCast(OSNumber,
        infoDict-&gt;getObject(kMKEXTExecutableKey));
    <span class="enscript-keyword">if</span> (executableOffsetNum) {
        executable = createMkext2FileEntry(mkextData,
            executableOffsetNum, <span class="enscript-string">&quot;executable&quot;</span>);
        infoDict-&gt;removeObject(kMKEXTExecutableKey);
        <span class="enscript-keyword">if</span> (!executable) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        <span class="enscript-keyword">if</span> (!setExecutable(executable, mkextData, true)) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    result = registerIdentifier();

<span class="enscript-reference">finish</span>:

    OSSafeRelease(executable);
    OSSafeRelease(iterator);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSData *
<span class="enscript-function-name">OSKext::createMkext2FileEntry</span>(
    OSData     * mkextData,
    OSNumber   * offsetNum,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name)
{
    OSData        * result      = NULL;
    MkextEntryRef   entryRef;
    uint8_t       * mkextBuffer = (uint8_t *)mkextData-&gt;getBytesNoCopy();
    uint32_t        entryOffset = offsetNum-&gt;unsigned32BitValue();

    result = OSData::withCapacity(<span class="enscript-keyword">sizeof</span>(entryRef));
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    entryRef.mkext = (mkext_basic_header *)mkextBuffer;
    entryRef.fileinfo = mkextBuffer + entryOffset;
    <span class="enscript-keyword">if</span> (!result-&gt;appendBytes(&amp;entryRef, <span class="enscript-keyword">sizeof</span>(entryRef))) {
        OSSafeReleaseNULL(result);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (!result) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Can't create wrapper for mkext file entry '%s' of kext %s.&quot;</span>,
            name, getIdentifierCString());
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
<span class="enscript-type">static</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">z_alloc</span>(<span class="enscript-type">void</span> *, u_int items, u_int size);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>   <span class="enscript-function-name">z_free</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *ptr);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> z_mem {
    uint32_t alloc_size;
    uint8_t  data[0];
} z_mem;

<span class="enscript-comment">/*
 * Space allocation and freeing routines for use by zlib routines.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">z_alloc</span>(<span class="enscript-type">void</span> * notused __unused, u_int num_items, u_int size)
{
    <span class="enscript-type">void</span>     * result = NULL;
    z_mem    * zmem = NULL;

    uint64_t   total = ((uint64_t)num_items) * ((uint64_t)size);
    <span class="enscript-comment">//Check for overflow due to multiplication 
</span>    <span class="enscript-keyword">if</span> (total &gt; UINT32_MAX){
        panic(<span class="enscript-string">&quot;z_alloc(%p, %x, %x): overflow caused by %x * %x\n&quot;</span>,
               notused, num_items, size, num_items, size);
    }
    
    uint64_t   allocSize64 =  total + ((uint64_t)<span class="enscript-keyword">sizeof</span>(zmem));
    <span class="enscript-comment">//Check for overflow due to addition
</span>    <span class="enscript-keyword">if</span> (allocSize64 &gt; UINT32_MAX){
        panic(<span class="enscript-string">&quot;z_alloc(%p, %x, %x): overflow caused by %x + %lx\n&quot;</span>,
               notused, num_items, size, (uint32_t)total, <span class="enscript-keyword">sizeof</span>(zmem));
    }
    uint32_t allocSize = (uint32_t)allocSize64;

    zmem = (z_mem *)kalloc_tag(allocSize, VM_KERN_MEMORY_OSKEXT);
    <span class="enscript-keyword">if</span> (!zmem) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    zmem-&gt;alloc_size = allocSize;
    result = (<span class="enscript-type">void</span> *)&amp;(zmem-&gt;data);
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">z_free</span>(<span class="enscript-type">void</span> * notused __unused, <span class="enscript-type">void</span> * ptr)
{
    uint32_t * skipper = (uint32_t *)ptr - 1;
    z_mem    * zmem = (z_mem *)skipper;
    kfree((<span class="enscript-type">void</span> *)zmem, zmem-&gt;alloc_size);
    <span class="enscript-keyword">return</span>;
}
};

OSData *
<span class="enscript-function-name">OSKext::extractMkext2FileData</span>(
    UInt8      * data,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
    uint32_t     compressedSize,
    uint32_t     fullSize)
{
    OSData      * result = NULL;
    
    OSData      * uncompressedData = NULL;   <span class="enscript-comment">// release on error
</span>
    uint8_t     * uncompressedDataBuffer = 0;    <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> uncompressedSize;
    z_stream      zstream;
    <span class="enscript-type">bool</span>          zstream_inited = false;
    <span class="enscript-type">int</span>           zlib_result;

   <span class="enscript-comment">/* If the file isn't compressed, we want to make a copy
    * so that we don't have the tie to the larger mkext file buffer any more.
    */</span>
    <span class="enscript-keyword">if</span> (!compressedSize) {
        uncompressedData = OSData::withBytes(data, fullSize);
        <span class="enscript-comment">// xxx - no check for failure?
</span>        result = uncompressedData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (KERN_SUCCESS != kmem_alloc(kernel_map,
        (vm_offset_t*)&amp;uncompressedDataBuffer, fullSize, VM_KERN_MEMORY_OSKEXT)) {

       <span class="enscript-comment">/* How's this for cheesy? The kernel is only asked to extract
        * kext plists so we tailor the log messages.
        */</span>
        <span class="enscript-keyword">if</span> (isKernel()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Allocation failure extracting %s from mkext.&quot;</span>, name);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Allocation failure extracting %s from mkext for kext %s.&quot;</span>,
                name, getIdentifierCString());
        }

        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    uncompressedData = OSData::withBytesNoCopy(uncompressedDataBuffer, fullSize);
    <span class="enscript-keyword">if</span> (!uncompressedData) {
        <span class="enscript-keyword">if</span> (isKernel()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Allocation failure extracting %s from mkext.&quot;</span>, name);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Allocation failure extracting %s from mkext for kext %s.&quot;</span>,
                name, getIdentifierCString());
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    uncompressedData-&gt;setDeallocFunction(&amp;osdata_kmem_free);

    <span class="enscript-keyword">if</span> (isKernel()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogDetailLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Kernel extracted %s from mkext - compressed size %d, uncompressed size %d.&quot;</span>,
            name, compressedSize, fullSize);
    } <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogDetailLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Kext %s extracted %s from mkext - compressed size %d, uncompressed size %d.&quot;</span>,
            getIdentifierCString(), name, compressedSize, fullSize);
    }

    bzero(&amp;zstream, <span class="enscript-keyword">sizeof</span>(zstream));
    zstream.next_in   = (UInt8 *)data;
    zstream.avail_in  = compressedSize;

    zstream.next_out  = uncompressedDataBuffer;
    zstream.avail_out = fullSize;

    zstream.zalloc    = z_alloc;
    zstream.zfree     = z_free;

    zlib_result = inflateInit(&amp;zstream);
    <span class="enscript-keyword">if</span> (Z_OK != zlib_result) {
        <span class="enscript-keyword">if</span> (isKernel()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Mkext error; zlib inflateInit failed (%d) for %s.&quot;</span>,
                zlib_result, name);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Kext %s - mkext error; zlib inflateInit failed (%d) for %s .&quot;</span>,
                getIdentifierCString(), zlib_result, name);
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    } <span class="enscript-keyword">else</span> {
        zstream_inited = true;
    }

    zlib_result = inflate(&amp;zstream, Z_FINISH);

    <span class="enscript-keyword">if</span> (zlib_result == Z_STREAM_END || zlib_result == Z_OK) {
        uncompressedSize = zstream.total_out;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (isKernel()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Mkext error; zlib inflate failed (%d) for %s.&quot;</span>,
                zlib_result, name);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Kext %s - mkext error; zlib inflate failed (%d) for %s .&quot;</span>,
                getIdentifierCString(), zlib_result, name);
        }
        <span class="enscript-keyword">if</span> (zstream.msg) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;zlib error: %s.&quot;</span>, zstream.msg);
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (uncompressedSize != fullSize) {
        <span class="enscript-keyword">if</span> (isKernel()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Mkext error; zlib inflate discrepancy for %s, &quot;</span>
                <span class="enscript-string">&quot;uncompressed size != original size.&quot;</span>, name);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Kext %s - mkext error; zlib inflate discrepancy for %s, &quot;</span>
                <span class="enscript-string">&quot;uncompressed size != original size.&quot;</span>,
                getIdentifierCString(), name);
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = uncompressedData;

<span class="enscript-reference">finish</span>:
   <span class="enscript-comment">/* Don't bother checking return, nothing we can do on fail.
    */</span>
    <span class="enscript-keyword">if</span> (zstream_inited) inflateEnd(&amp;zstream);

    <span class="enscript-keyword">if</span> (!result) {
        OSSafeRelease(uncompressedData);
    }

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::loadFromMkext</span>(
    OSKextLogSpec   clientLogFilter,
    <span class="enscript-type">char</span>          * mkextBuffer,
    uint32_t        mkextBufferLength,
    <span class="enscript-type">char</span>         ** logInfoOut,
    uint32_t      * logInfoLengthOut)
{
    OSReturn         result                      = kOSReturnError;
    OSReturn         tempResult                  = kOSReturnError;

    OSData         * mkextData                   = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary   * mkextPlist                  = NULL;  <span class="enscript-comment">// must release
</span>
    OSArray        * logInfoArray                = NULL;  <span class="enscript-comment">// must release
</span>    OSSerialize    * serializer                  = NULL;  <span class="enscript-comment">// must release
</span>
    OSString       * predicate                   = NULL;  <span class="enscript-comment">// do not release
</span>    OSDictionary   * requestArgs                 = NULL;  <span class="enscript-comment">// do not release
</span>
    OSString       * kextIdentifier              = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber       * startKextExcludeNum         = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber       * startMatchingExcludeNum     = NULL;  <span class="enscript-comment">// do not release
</span>    OSBoolean      * delayAutounloadBool         = NULL;  <span class="enscript-comment">// do not release
</span>    OSArray        * personalityNames            = NULL;  <span class="enscript-comment">// do not release
</span>
   <span class="enscript-comment">/* Default values for these two options: regular autounload behavior,
    * load all kexts, send no personalities.
    */</span>
    Boolean            delayAutounload           = false;
    OSKextExcludeLevel startKextExcludeLevel     = kOSKextExcludeNone;
    OSKextExcludeLevel startMatchingExcludeLevel = kOSKextExcludeAll;
    
    IORecursiveLockLock(sKextLock);

    <span class="enscript-keyword">if</span> (logInfoOut) {
        *logInfoOut = NULL;
        *logInfoLengthOut = 0;
    }

    <span class="enscript-reference">OSKext</span>::setUserSpaceLogFilter(clientLogFilter, logInfoOut ? true : false);

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogDebugLevel |
        kOSKextLogIPCFlag,
        <span class="enscript-string">&quot;Received kext load request from user space.&quot;</span>);
    
   <span class="enscript-comment">/* Regardless of processing, the fact that we have gotten here means some
    * user-space program is up and talking to us, so we'll switch our kext
    * registration to reflect that.
    */</span>
    <span class="enscript-keyword">if</span> (!sUserLoadsActive) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogProgressLevel |
            kOSKextLogGeneralFlag | kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Switching to late startup (user-space) kext loading policy.&quot;</span>);

        sUserLoadsActive = true;
    }
  
    <span class="enscript-keyword">if</span> (!sLoadEnabled) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext loading is disabled.&quot;</span>);
        result = kOSKextReturnDisabled;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Note that we do not set a dealloc function on this OSData
    * object! No references to it can remain after the loadFromMkext()
    * call since we are in a MIG function, and will vm_deallocate()
    * the buffer.
    */</span>
    mkextData = OSData::withBytesNoCopy(mkextBuffer,
        mkextBufferLength);
    <span class="enscript-keyword">if</span> (!mkextData) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Failed to create wrapper for kext load request.&quot;</span>);
        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = readMkext2Archive(mkextData, &amp;mkextPlist, NULL);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Failed to read kext load request.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    predicate = _OSKextGetRequestPredicate(mkextPlist);
    <span class="enscript-keyword">if</span> (!predicate || !predicate-&gt;isEqualTo(kKextRequestPredicateLoad)) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Received kext load request with no predicate; skipping.&quot;</span>);
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    requestArgs = OSDynamicCast(OSDictionary,
        mkextPlist-&gt;getObject(kKextRequestArgumentsKey));
    <span class="enscript-keyword">if</span> (!requestArgs || !requestArgs-&gt;getCount()) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Received kext load request with no arguments.&quot;</span>);
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    kextIdentifier = OSDynamicCast(OSString,
        requestArgs-&gt;getObject(kKextRequestArgumentBundleIdentifierKey));
    <span class="enscript-keyword">if</span> (!kextIdentifier) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Received kext load request with no kext identifier.&quot;</span>);
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    startKextExcludeNum = OSDynamicCast(OSNumber,
        requestArgs-&gt;getObject(kKextRequestArgumentStartExcludeKey));
    startMatchingExcludeNum = OSDynamicCast(OSNumber,
        requestArgs-&gt;getObject(kKextRequestArgumentStartMatchingExcludeKey));
    delayAutounloadBool = OSDynamicCast(OSBoolean,
        requestArgs-&gt;getObject(kKextRequestArgumentDelayAutounloadKey));
    personalityNames = OSDynamicCast(OSArray,
        requestArgs-&gt;getObject(kKextRequestArgumentPersonalityNamesKey));

    <span class="enscript-keyword">if</span> (delayAutounloadBool) {
        delayAutounload = delayAutounloadBool-&gt;getValue();
    }
    <span class="enscript-keyword">if</span> (startKextExcludeNum) {
        startKextExcludeLevel = startKextExcludeNum-&gt;unsigned8BitValue();
    }
    <span class="enscript-keyword">if</span> (startMatchingExcludeNum) {
        startMatchingExcludeLevel = startMatchingExcludeNum-&gt;unsigned8BitValue();
    }
    
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogProgressLevel |
        kOSKextLogIPCFlag,
        <span class="enscript-string">&quot;Received request from user space to load kext %s.&quot;</span>,
        kextIdentifier-&gt;getCStringNoCopy());

   <span class="enscript-comment">/* Load the kext, with no deferral, since this is a load from outside
    * the kernel.
    * xxx - Would like a better way to handle the default values for the
    * xxx - start/match opt args.
    */</span>
    result = OSKext::loadKextWithIdentifier(
        kextIdentifier,
        <span class="enscript-comment">/* allowDefer */</span> false,
        delayAutounload,
        startKextExcludeLevel,
        startMatchingExcludeLevel,
        personalityNames);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
   <span class="enscript-comment">/* If the load came down from kextd, it will shortly inform IOCatalogue
    * for matching via a separate IOKit calldown.
    */</span>

<span class="enscript-reference">finish</span>:

   <span class="enscript-comment">/* Gather up the collected log messages for user space. Any
    * error messages past this call will not make it up as log messages
    * but will be in the system log.
    */</span>
    logInfoArray = OSKext::clearUserSpaceLogFilter();

    <span class="enscript-keyword">if</span> (logInfoArray &amp;&amp; logInfoOut &amp;&amp; logInfoLengthOut) {
        tempResult = OSKext::serializeLogInfo(logInfoArray,
            logInfoOut, logInfoLengthOut);
        <span class="enscript-keyword">if</span> (tempResult != kOSReturnSuccess) {
            result = tempResult;
        }
    }

    <span class="enscript-reference">OSKext</span>::flushNonloadedKexts(<span class="enscript-comment">/* flushPrelinkedKexts */</span> false);

   <span class="enscript-comment">/* Note: mkextDataObject will have been retained by every kext w/an
    * executable in it. That should all have been flushed out at the
    * and of the load operation, but you never know....
    */</span>
    <span class="enscript-keyword">if</span> (mkextData &amp;&amp; mkextData-&gt;getRetainCount() &gt; 1) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Kext load request buffer from user space still retained by a kext; &quot;</span>
            <span class="enscript-string">&quot;probable memory leak.&quot;</span>);
    }

    IORecursiveLockUnlock(sKextLock);

    OSSafeRelease(mkextData);
    OSSafeRelease(mkextPlist);
    OSSafeRelease(serializer);
    OSSafeRelease(logInfoArray);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::serializeLogInfo</span>(
    OSArray   * logInfoArray,
    <span class="enscript-type">char</span>     ** logInfoOut,
    uint32_t  * logInfoLengthOut)
{
    OSReturn        result      = kOSReturnError;
    <span class="enscript-type">char</span>          * buffer      = NULL;
    kern_return_t   kmem_result = KERN_FAILURE;
    OSSerialize  * serializer   = NULL;  <span class="enscript-comment">// must release; reused
</span>    <span class="enscript-type">char</span>         * logInfo            = NULL;  <span class="enscript-comment">// returned by reference
</span>    uint32_t       logInfoLength      = 0;

    <span class="enscript-keyword">if</span> (!logInfoArray || !logInfoOut || !logInfoLengthOut) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Internal error; invalid arguments to OSKext::serializeLogInfo().&quot;</span>);
       <span class="enscript-comment">/* Bad programmer. */</span>
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    serializer = OSSerialize::withCapacity(0);
    <span class="enscript-keyword">if</span> (!serializer) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Failed to create serializer on log info for request from user space.&quot;</span>);
       <span class="enscript-comment">/* Incidental error; we're going to (try to) allow the request
        * itself to succeed. */</span>
    }

    <span class="enscript-keyword">if</span> (!logInfoArray-&gt;serialize(serializer)) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Failed to serialize log info for request from user space.&quot;</span>);
       <span class="enscript-comment">/* Incidental error; we're going to (try to) allow the request
        * itself to succeed. */</span>
    } <span class="enscript-keyword">else</span> {
        logInfo = serializer-&gt;text();
        logInfoLength = serializer-&gt;getLength();

        kmem_result = kmem_alloc(kernel_map, (vm_offset_t *)&amp;buffer, round_page(logInfoLength), VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (kmem_result != KERN_SUCCESS) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Failed to copy log info for request from user space.&quot;</span>);
           <span class="enscript-comment">/* Incidental error; we're going to (try to) allow the request
            * to succeed. */</span>
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* 11981737 - clear uninitialized data in last page */</span>
            bzero((<span class="enscript-type">void</span> *)(buffer + logInfoLength),
                  (round_page(logInfoLength) - logInfoLength));
            memcpy(buffer, logInfo, logInfoLength);
            *logInfoOut = buffer;
            *logInfoLengthOut = logInfoLength;
        }
    }
    
    result = kOSReturnSuccess;
<span class="enscript-reference">finish</span>:
    OSSafeRelease(serializer);
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Instance</span> <span class="enscript-variable-name">Management</span> <span class="enscript-variable-name">Methods</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::lookupKextWithIdentifier</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kextIdentifier)
{
    OSKext * foundKext = NULL;

    IORecursiveLockLock(sKextLock);
    foundKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(kextIdentifier));
    <span class="enscript-keyword">if</span> (foundKext) {
        foundKext-&gt;retain();
    }
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> foundKext;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::lookupKextWithIdentifier</span>(OSString * kextIdentifier)
{
    <span class="enscript-keyword">return</span> OSKext::lookupKextWithIdentifier(kextIdentifier-&gt;getCStringNoCopy());
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::lookupKextWithLoadTag</span>(uint32_t aTag)
{
    OSKext * foundKext = NULL;                 <span class="enscript-comment">// returned
</span>    uint32_t count, i;

    IORecursiveLockLock(sKextLock);
    
    count = sLoadedKexts-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext * thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (thisKext-&gt;getLoadTag() == aTag) {
            foundKext = thisKext;
            foundKext-&gt;retain();
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    
<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> foundKext;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::lookupKextWithAddress</span>(vm_address_t address)
{
    OSKext * foundKext = NULL;                 <span class="enscript-comment">// returned
</span>    uint32_t count, i;

    IORecursiveLockLock(sKextLock);
    
    count = sLoadedKexts-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext * thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (thisKext-&gt;linkedExecutable) {
            vm_address_t kext_start =
                (vm_address_t)thisKext-&gt;linkedExecutable-&gt;getBytesNoCopy();
            vm_address_t kext_end = kext_start +
                thisKext-&gt;linkedExecutable-&gt;getLength();
            
            <span class="enscript-keyword">if</span> ((kext_start &lt;= address) &amp;&amp; (address &lt; kext_end)) {
                foundKext = thisKext;
                foundKext-&gt;retain();
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
        }
    }
    
<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> foundKext;
}


<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKext *
<span class="enscript-function-name">OSKext::lookupKextWithUUID</span>(uuid_t wanted)
{
    OSKext * foundKext = NULL;                 <span class="enscript-comment">// returned
</span>    uint32_t count, i;

    IORecursiveLockLock(sKextLock);

    count = sLoadedKexts-&gt;getCount();

    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext   * thisKext     = NULL;

        thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!thisKext) {
            <span class="enscript-keyword">continue</span>;
        }

        OSData *uuid_data = thisKext-&gt;copyUUID();
        <span class="enscript-keyword">if</span> (!uuid_data) {
            <span class="enscript-keyword">continue</span>;
        }

        uuid_t uuid;
        memcpy(&amp;uuid, uuid_data-&gt;getBytesNoCopy(), <span class="enscript-keyword">sizeof</span>(uuid));
        uuid_data-&gt;release();

        <span class="enscript-keyword">if</span> (0 == uuid_compare(wanted, uuid)) {
            foundKext = thisKext;
            foundKext-&gt;retain();
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

    }

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> foundKext;
}




<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">OSKext::isKextWithIdentifierLoaded</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kextIdentifier)
{
    <span class="enscript-type">bool</span> result = false;
    OSKext * foundKext = NULL;                 <span class="enscript-comment">// returned
</span>
    IORecursiveLockLock(sKextLock);

    foundKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(kextIdentifier));
    <span class="enscript-keyword">if</span> (foundKext &amp;&amp; foundKext-&gt;isLoaded()) {
        result = true;
    }

    IORecursiveLockUnlock(sKextLock);
    
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* xxx - should spawn a separate thread so a kext can safely have
* xxx - itself unloaded.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::removeKext</span>(
    OSKext * aKext,
    <span class="enscript-type">bool</span>     terminateServicesAndRemovePersonalitiesFlag)
 {
    OSReturn result    = kOSKextReturnInUse;
    OSKext * checkKext = NULL;   <span class="enscript-comment">// do not release
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-type">int</span> macCheckResult = 0;
    kauth_cred_t cred  = NULL;
#<span class="enscript-reference">endif</span>

    IORecursiveLockLock(sKextLock);

   <span class="enscript-comment">/* If the kext has no identifier, it failed to init
    * so isn't in sKextsByID and it isn't loaded.
    */</span>
    <span class="enscript-keyword">if</span> (!aKext-&gt;getIdentifier()) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    checkKext = OSDynamicCast(OSKext,
        sKextsByID-&gt;getObject(aKext-&gt;getIdentifier()));
    <span class="enscript-keyword">if</span> (checkKext != aKext) {
        result = kOSKextReturnNotFound;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (aKext-&gt;isLoaded()) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
        <span class="enscript-keyword">if</span> (current_task() != kernel_task) {
            cred = kauth_cred_get_with_ref();
            macCheckResult = mac_kext_check_unload(cred, aKext-&gt;getIdentifierCString());
            kauth_cred_unref(&amp;cred);
        }

        <span class="enscript-keyword">if</span> (macCheckResult != 0) {
            result = kOSReturnError;
            OSKextLog(aKext,
                kOSKextLogErrorLevel |
                kOSKextLogKextBookkeepingFlag,
                <span class="enscript-string">&quot;Failed to remove kext %s (MAC policy error 0x%x).&quot;</span>,
                aKext-&gt;getIdentifierCString(), macCheckResult);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
#<span class="enscript-reference">endif</span>

        <span class="enscript-comment">/* make sure there are no resource requests in flight - 17187548 */</span>
        <span class="enscript-keyword">if</span> (aKext-&gt;countRequestCallbacks()) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* If we are terminating, send the request to the IOCatalogue
        * (which will actually call us right back but that's ok we have
        * a recursive lock don't you know) but do not ask the IOCatalogue
        * to call back with an unload, we'll do that right here.
        */</span>
        <span class="enscript-keyword">if</span> (terminateServicesAndRemovePersonalitiesFlag) {
            result = gIOCatalogue-&gt;terminateDriversForModule(
                aKext-&gt;getIdentifierCString(), <span class="enscript-comment">/* unload */</span> false);
            <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
                OSKextLog(aKext,
                    kOSKextLogErrorLevel |
                    kOSKextLogKextBookkeepingFlag,
                    <span class="enscript-string">&quot;Can't remove kext %s; services failed to terminate - 0x%x.&quot;</span>,
                    aKext-&gt;getIdentifierCString(), result);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
        }

        result = aKext-&gt;unload();
        <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    
   <span class="enscript-comment">/* Remove personalities as requested. This is a bit redundant for a loaded
    * kext as IOCatalogue::terminateDriversForModule() removes driver
    * personalities, but it doesn't restart matching, which we always want
    * coming from here, and OSKext::removePersonalitiesFromCatalog() ensures
    * that happens.
    */</span>
    <span class="enscript-keyword">if</span> (terminateServicesAndRemovePersonalitiesFlag) {
        aKext-&gt;removePersonalitiesFromCatalog();
    }

    OSKextLog(aKext,
              kOSKextLogProgressLevel |
              kOSKextLogKextBookkeepingFlag,
              <span class="enscript-string">&quot;Removing kext %s.&quot;</span>,
              aKext-&gt;getIdentifierCString());
          
    sKextsByID-&gt;removeObject(aKext-&gt;getIdentifier());
    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span> result;
 }

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::removeKextWithIdentifier</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * kextIdentifier,
    <span class="enscript-type">bool</span>         terminateServicesAndRemovePersonalitiesFlag)
{
    OSReturn result = kOSReturnError;

    IORecursiveLockLock(sKextLock);
    
    OSKext * aKext = OSDynamicCast(OSKext,
        sKextsByID-&gt;getObject(kextIdentifier));
    <span class="enscript-keyword">if</span> (!aKext) {
        result = kOSKextReturnNotFound;
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Can't remove kext %s - not found.&quot;</span>,
            kextIdentifier);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = OSKext::removeKext(aKext,
        terminateServicesAndRemovePersonalitiesFlag);

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);
    
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::removeKextWithLoadTag</span>(
    OSKextLoadTag loadTag,
    <span class="enscript-type">bool</span>          terminateServicesAndRemovePersonalitiesFlag)
{
    OSReturn result    = kOSReturnError;
    OSKext * foundKext = NULL;
    uint32_t count, i;

    IORecursiveLockLock(sKextLock);

    count = sLoadedKexts-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext * thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (thisKext-&gt;loadTag == loadTag) {
            foundKext = thisKext;
            <span class="enscript-keyword">break</span>;
        }
    }
    
    <span class="enscript-keyword">if</span> (!foundKext) {
        result = kOSKextReturnNotFound;
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Can't remove kext with load tag %d - not found.&quot;</span>,
            loadTag);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = OSKext::removeKext(foundKext,
        terminateServicesAndRemovePersonalitiesFlag);

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);
    
    <span class="enscript-keyword">return</span> result;
 }

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSDictionary *
<span class="enscript-function-name">OSKext::copyKexts</span>(<span class="enscript-type">void</span>)
{
    OSDictionary * result;

    IORecursiveLockLock(sKextLock);
    result = OSDynamicCast(OSDictionary, sKextsByID-&gt;copyCollection());
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
 *********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOOTER_KEXT_PREFIX</span>   <span class="enscript-string">&quot;Driver-&quot;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _DeviceTreeBuffer {
    uint32_t paddr;
    uint32_t length;
} _DeviceTreeBuffer;

<span class="enscript-comment">/*********************************************************************
 * Create a dictionary of excluded kexts from the given booter data.
 *********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::createExcludeListFromBooterData</span>(
                                        OSDictionary *          theDictionary,
                                        OSCollectionIterator *  theIterator )
{
    OSString                  * deviceTreeName      = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">const</span> _DeviceTreeBuffer   * deviceTreeBuffer    = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">char</span>                      * booterDataPtr       = NULL;  <span class="enscript-comment">// do not release
</span>    _BooterKextFileInfo       * kextFileInfo        = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">char</span>                      * infoDictAddr        = NULL;  <span class="enscript-comment">// do not release
</span>    OSObject                  * parsedXML           = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary              * theInfoDict         = NULL;  <span class="enscript-comment">// do not release
</span>    
    theIterator-&gt;reset();
    
    <span class="enscript-comment">/* look for AppleKextExcludeList.kext */</span>
    <span class="enscript-keyword">while</span> ( (deviceTreeName =
             OSDynamicCast(OSString, theIterator-&gt;getNextObject())) ) {
        
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *    devTreeNameCString;
        OSData *        deviceTreeEntry;
        OSString *      myBundleID;    <span class="enscript-comment">// do not release
</span>        
        OSSafeReleaseNULL(parsedXML);
        
        deviceTreeEntry = 
        OSDynamicCast(OSData, theDictionary-&gt;getObject(deviceTreeName));
        <span class="enscript-keyword">if</span> (!deviceTreeEntry) {
            <span class="enscript-keyword">continue</span>;
        }
        
        <span class="enscript-comment">/* Make sure it is a kext */</span>
        devTreeNameCString = deviceTreeName-&gt;getCStringNoCopy();
        <span class="enscript-keyword">if</span> (strncmp(devTreeNameCString, BOOTER_KEXT_PREFIX,
                    (<span class="enscript-keyword">sizeof</span>(BOOTER_KEXT_PREFIX) - 1)) != 0) {
            OSKextLog(NULL,
                      kOSKextLogErrorLevel | kOSKextLogGeneralFlag, 
                      <span class="enscript-string">&quot;\&quot;%s\&quot; not a kext&quot;</span>,
                      devTreeNameCString);
            <span class="enscript-keyword">continue</span>;
        }
        
        deviceTreeBuffer = (<span class="enscript-type">const</span> _DeviceTreeBuffer *)
        deviceTreeEntry-&gt;getBytesNoCopy(0, <span class="enscript-keyword">sizeof</span>(deviceTreeBuffer));
        <span class="enscript-keyword">if</span> (!deviceTreeBuffer) {
            <span class="enscript-keyword">continue</span>;
        }
        
        booterDataPtr = (<span class="enscript-type">char</span> *)ml_static_ptovirt(deviceTreeBuffer-&gt;paddr);
        <span class="enscript-keyword">if</span> (!booterDataPtr) {
            <span class="enscript-keyword">continue</span>;
        }
        
        kextFileInfo = (_BooterKextFileInfo *) booterDataPtr;
        <span class="enscript-keyword">if</span> (!kextFileInfo-&gt;infoDictPhysAddr || 
            !kextFileInfo-&gt;infoDictLength)       {
            <span class="enscript-keyword">continue</span>;
        }
        
        infoDictAddr = (<span class="enscript-type">char</span> *)
        ml_static_ptovirt(kextFileInfo-&gt;infoDictPhysAddr);
        <span class="enscript-keyword">if</span> (!infoDictAddr) {
            <span class="enscript-keyword">continue</span>;
        }
        
        parsedXML = OSUnserializeXML(infoDictAddr);
        <span class="enscript-keyword">if</span> (!parsedXML) {
            <span class="enscript-keyword">continue</span>;
        }
        
        theInfoDict = OSDynamicCast(OSDictionary, parsedXML);
        <span class="enscript-keyword">if</span> (!theInfoDict) {
            <span class="enscript-keyword">continue</span>;
        }
        
        myBundleID = 
        OSDynamicCast(OSString, 
                      theInfoDict-&gt;getObject(kCFBundleIdentifierKey));
        <span class="enscript-keyword">if</span> ( myBundleID &amp;&amp; 
            strcmp( myBundleID-&gt;getCStringNoCopy(), <span class="enscript-string">&quot;com.apple.driver.KextExcludeList&quot;</span> ) == 0 ) {
            
            <span class="enscript-comment">/* get copy of exclusion list dictionary */</span>
            OSDictionary *      myTempDict;     <span class="enscript-comment">// do not free
</span>            
            myTempDict = OSDynamicCast(
                                       OSDictionary,
                                       theInfoDict-&gt;getObject(<span class="enscript-string">&quot;OSKextExcludeList&quot;</span>));
            <span class="enscript-keyword">if</span> ( myTempDict ) {
                IORecursiveLockLock(sKextLock);
                
                <span class="enscript-comment">/* get rid of old exclusion list */</span>
                <span class="enscript-keyword">if</span> (sExcludeListByID) {
                    sExcludeListByID-&gt;flushCollection();
                    OSSafeRelease(sExcludeListByID);
                }
                sExcludeListByID = OSDictionary::withDictionary(myTempDict, 0);
                IORecursiveLockUnlock(sKextLock);
            }
            <span class="enscript-keyword">break</span>;
        }
        
    } <span class="enscript-comment">// while ( (deviceTreeName = ...) )
</span>    
    OSSafeReleaseNULL(parsedXML);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
 * Create a dictionary of excluded kexts from the given prelink 
 * info (kernelcache).
 *********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::createExcludeListFromPrelinkInfo</span>( OSArray * theInfoArray )
{
    OSDictionary *  myInfoDict = NULL;  <span class="enscript-comment">// do not release
</span>    OSString *      myBundleID;         <span class="enscript-comment">// do not release
</span>    u_int           i;
    
    <span class="enscript-comment">/* Find com.apple.driver.KextExcludeList. */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; theInfoArray-&gt;getCount(); i++) {
        myInfoDict = OSDynamicCast(OSDictionary, theInfoArray-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!myInfoDict) {
            <span class="enscript-keyword">continue</span>;
        }
        myBundleID = 
        OSDynamicCast(OSString, 
                      myInfoDict-&gt;getObject(kCFBundleIdentifierKey));
        <span class="enscript-keyword">if</span> ( myBundleID &amp;&amp; 
            strcmp( myBundleID-&gt;getCStringNoCopy(), <span class="enscript-string">&quot;com.apple.driver.KextExcludeList&quot;</span> ) == 0 ) {
            <span class="enscript-comment">// get copy of exclude list dictionary
</span>            OSDictionary *      myTempDict;     <span class="enscript-comment">// do not free
</span>            myTempDict = OSDynamicCast(OSDictionary,
                                       myInfoDict-&gt;getObject(<span class="enscript-string">&quot;OSKextExcludeList&quot;</span>));
            <span class="enscript-keyword">if</span> ( myTempDict ) {
                IORecursiveLockLock(sKextLock);
                <span class="enscript-comment">// get rid of old exclude list
</span>                <span class="enscript-keyword">if</span> (sExcludeListByID) {
                    sExcludeListByID-&gt;flushCollection();
                    OSSafeRelease(sExcludeListByID);
                }
                
                sExcludeListByID = OSDictionary::withDictionary(myTempDict, 0);
                IORecursiveLockUnlock(sKextLock);
            }
            <span class="enscript-keyword">break</span>;
        }
    } <span class="enscript-comment">// for (i = 0; i &lt; theInfoArray-&gt;getCount()...
</span>    
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Accessors</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">const</span> OSSymbol *
<span class="enscript-function-name">OSKext::getIdentifier</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> bundleID;
}

<span class="enscript-comment">/*********************************************************************
* A kext must have a bundle identifier to even survive initialization;
* this is guaranteed to exist past then.
*********************************************************************/</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">OSKext::getIdentifierCString</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> bundleID-&gt;getCStringNoCopy();
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKextVersion
<span class="enscript-function-name">OSKext::getVersion</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> version;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSKextVersion
<span class="enscript-function-name">OSKext::getCompatibleVersion</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> compatibleVersion;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isLibrary</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (getCompatibleVersion() &gt; 0);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isCompatibleWithVersion</span>(OSKextVersion aVersion)
{
    <span class="enscript-keyword">if</span> ((compatibleVersion &gt; -1 &amp;&amp; version &gt; -1) &amp;&amp;
        (compatibleVersion &lt;= version &amp;&amp; aVersion &lt;= version)) {
        <span class="enscript-keyword">return</span> true;
    }
    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::declaresExecutable</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (getPropertyForHostArch(kCFBundleExecutableKey) != NULL);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSData *
<span class="enscript-function-name">OSKext::getExecutable</span>(<span class="enscript-type">void</span>)
{
    OSData * result              = NULL;
    OSData * extractedExecutable = NULL;  <span class="enscript-comment">// must release
</span>    OSData * mkextExecutableRef  = NULL;  <span class="enscript-comment">// do not release
</span>
    result = OSDynamicCast(OSData, infoDict-&gt;getObject(_kOSKextExecutableKey));
    <span class="enscript-keyword">if</span> (result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    mkextExecutableRef = OSDynamicCast(OSData,
        getPropertyForHostArch(_kOSKextMkextExecutableReferenceKey));

    <span class="enscript-keyword">if</span> (mkextExecutableRef) {

        MkextEntryRef * mkextEntryRef = (MkextEntryRef *)
            mkextExecutableRef-&gt;getBytesNoCopy();
        uint32_t mkextVersion = MKEXT_GET_VERSION(mkextEntryRef-&gt;mkext);
        <span class="enscript-keyword">if</span> (mkextVersion == MKEXT_VERS_2) {
            mkext2_file_entry * fileinfo =
                (mkext2_file_entry *)mkextEntryRef-&gt;fileinfo;
            uint32_t compressedSize = MKEXT2_GET_ENTRY_COMPSIZE(fileinfo);
            uint32_t fullSize = MKEXT2_GET_ENTRY_FULLSIZE(fileinfo);
            extractedExecutable = extractMkext2FileData(
                MKEXT2_GET_ENTRY_DATA(fileinfo), <span class="enscript-string">&quot;executable&quot;</span>,
                compressedSize, fullSize);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>, kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Kext %s - unknown mkext version 0x%x for executable.&quot;</span>,
                getIdentifierCString(), mkextVersion);
        }

       <span class="enscript-comment">/* Regardless of success, remove the mkext executable,
        * and drop one reference on the mkext.  (setExecutable() does not
        * replace, it removes, or panics if asked to replace.)
        */</span>        
        infoDict-&gt;removeObject(_kOSKextMkextExecutableReferenceKey);
        infoDict-&gt;removeObject(_kOSKextExecutableExternalDataKey);

        <span class="enscript-keyword">if</span> (extractedExecutable &amp;&amp; extractedExecutable-&gt;getLength()) {
            <span class="enscript-keyword">if</span> (!setExecutable(extractedExecutable)) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            result = extractedExecutable;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

<span class="enscript-reference">finish</span>:

    OSSafeRelease(extractedExecutable);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isInterface</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> flags.interface;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isKernel</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (<span class="enscript-keyword">this</span> == sKernelKext);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isKernelComponent</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> flags.kernelComponent ? true : false;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isExecutable</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (!isKernel() &amp;&amp; !isInterface() &amp;&amp; declaresExecutable());
}

<span class="enscript-comment">/*********************************************************************
* We might want to check this recursively for all dependencies,
* since a subtree of dependencies could get loaded before we hit
* a dependency that isn't safe-boot-loadable.
*
* xxx - Might want to return false if OSBundleEnableKextLogging or
* OSBundleDebugLevel
* or IOKitDebug is nonzero too (we used to do that, but I don't see
* the point except it's usually development drivers, which might
* cause panics on startup, that have those properties). Heh; could
* use a &quot;kx&quot; boot-arg!
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isLoadableInSafeBoot</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span>       result   = false;
    OSString * required = NULL;  <span class="enscript-comment">// do not release
</span>    
    <span class="enscript-keyword">if</span> (isKernel()) {
        result = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    required = OSDynamicCast(OSString,
        getPropertyForHostArch(kOSBundleRequiredKey));
    <span class="enscript-keyword">if</span> (!required) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (required-&gt;isEqualTo(kOSBundleRequiredRoot)        ||
        required-&gt;isEqualTo(kOSBundleRequiredLocalRoot)   ||
        required-&gt;isEqualTo(kOSBundleRequiredNetworkRoot) ||
        required-&gt;isEqualTo(kOSBundleRequiredSafeBoot)    ||
        required-&gt;isEqualTo(kOSBundleRequiredConsole)) {
        
        result = true;
    }
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isPrelinked</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> flags.prelinked ? true : false;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">OSKext::isLoaded</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> flags.loaded ? true : false;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isStarted</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> flags.started ? true : false;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::isCPPInitialized</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> flags.CPPInitialized;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::setCPPInitialized</span>(<span class="enscript-type">bool</span> initialized)
{
    flags.CPPInitialized = initialized;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
uint32_t
<span class="enscript-function-name">OSKext::getLoadTag</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> loadTag;
}

<span class="enscript-comment">/*********************************************************************
 *********************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSKext::getSizeInfo</span>(uint32_t *loadSize, uint32_t *wiredSize)
{
    <span class="enscript-keyword">if</span> (linkedExecutable) {
        *loadSize = linkedExecutable-&gt;getLength();
           
        <span class="enscript-comment">/* If we have a kmod_info struct, calculated the wired size
         * from that. Otherwise it's the full load size.
         */</span>
        <span class="enscript-keyword">if</span> (kmod_info) {
            *wiredSize = *loadSize - kmod_info-&gt;hdr_size;
        } <span class="enscript-keyword">else</span> {
            *wiredSize = *loadSize;
        }
    }
    <span class="enscript-keyword">else</span> {
        *wiredSize = 0;
        *loadSize = 0;
    }
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSData *
<span class="enscript-function-name">OSKext::copyUUID</span>(<span class="enscript-type">void</span>)
{
    OSData                     * result        = NULL;
    OSData                     * theExecutable = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">const</span> kernel_mach_header_t * header        = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> load_command  * load_cmd      = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> uuid_command  * uuid_cmd      = NULL;
    uint32_t                     i;

   <span class="enscript-comment">/* An interface kext doesn't have a linked executable with an LC_UUID,
    * we create one when it's linked.
    */</span>
    <span class="enscript-keyword">if</span> (interfaceUUID) {
        result = interfaceUUID;
        result-&gt;retain();
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* For real kexts, try to get the UUID from the linked executable,
    * or if is hasn't been linked yet, the unrelocated executable.
    */</span>
    theExecutable = linkedExecutable;
    <span class="enscript-keyword">if</span> (!theExecutable) {
        theExecutable = getExecutable();
    }
    <span class="enscript-keyword">if</span> (!theExecutable) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    header = (<span class="enscript-type">const</span> kernel_mach_header_t *)theExecutable-&gt;getBytesNoCopy();
    load_cmd = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> load_command *)&amp;header[1];
        
    <span class="enscript-keyword">if</span> (header-&gt;magic != MH_MAGIC_KERNEL) {
        OSKextLog(NULL,
                  kOSKextLogErrorLevel | kOSKextLogGeneralFlag,
                  <span class="enscript-string">&quot;%s: bad header %p&quot;</span>,
                  __func__,
                  header);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;ncmds; i++) {
        <span class="enscript-keyword">if</span> (load_cmd-&gt;cmd == LC_UUID) {
            uuid_cmd = (<span class="enscript-type">struct</span> uuid_command *)load_cmd;
            result = OSData::withBytes(uuid_cmd-&gt;uuid, <span class="enscript-keyword">sizeof</span>(uuid_cmd-&gt;uuid));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        load_cmd = (<span class="enscript-type">struct</span> load_command *)((caddr_t)load_cmd + load_cmd-&gt;cmdsize);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>

#<span class="enscript-reference">if</span>   <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ARCHNAME</span> <span class="enscript-string">&quot;x86_64&quot;</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">architecture</span> <span class="enscript-variable-name">not</span> <span class="enscript-variable-name">supported</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ARCH_SEPARATOR_CHAR</span>  <span class="enscript-string">'_'</span>

<span class="enscript-type">static</span> <span class="enscript-type">char</span> * <span class="enscript-function-name">makeHostArchKey</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, uint32_t * keySizeOut)
{
    <span class="enscript-type">char</span>     * result = NULL;
    uint32_t   keyLength = strlen(key);
    uint32_t   keySize;

   <span class="enscript-comment">/* Add 1 for the ARCH_SEPARATOR_CHAR, and 1 for the '\0'.
    */</span>
    keySize = 1 + 1 + strlen(key) + strlen(ARCHNAME);
    result = (<span class="enscript-type">char</span> *)kalloc_tag(keySize, VM_KERN_MEMORY_OSKEXT);
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    strlcpy(result, key, keySize);
    result[keyLength++] = ARCH_SEPARATOR_CHAR;
    result[keyLength] = <span class="enscript-string">'\0'</span>;
    strlcat(result, ARCHNAME, keySize);
    *keySizeOut = keySize;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSObject *
<span class="enscript-function-name">OSKext::getPropertyForHostArch</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * key)
{
    OSObject * result           = NULL;  <span class="enscript-comment">// do not release
</span>    uint32_t   hostArchKeySize  = 0;
    <span class="enscript-type">char</span>     * hostArchKey      = NULL;  <span class="enscript-comment">// must kfree
</span>    
    <span class="enscript-keyword">if</span> (!key || !infoDict) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
   <span class="enscript-comment">/* Some properties are not allowed to be arch-variant:
    * - Any CFBundle... property.
    * - OSBundleIsInterface.
    * - OSKernelResource.
    */</span>
    <span class="enscript-keyword">if</span> (STRING_HAS_PREFIX(key, <span class="enscript-string">&quot;OS&quot;</span>) ||
        STRING_HAS_PREFIX(key, <span class="enscript-string">&quot;IO&quot;</span>)) {

        hostArchKey = makeHostArchKey(key, &amp;hostArchKeySize);
        <span class="enscript-keyword">if</span> (!hostArchKey) {
            OSKextLog(<span class="enscript-comment">/* kext (this isn't about a kext) */</span> NULL,
                kOSKextLogErrorLevel | kOSKextLogGeneralFlag,
                <span class="enscript-string">&quot;Allocation failure.&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        result = infoDict-&gt;getObject(hostArchKey);
    }
    
    <span class="enscript-keyword">if</span> (!result) {
        result = infoDict-&gt;getObject(key);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (hostArchKey) kfree(hostArchKey, hostArchKeySize);
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Load</span>/<span class="enscript-variable-name">Start</span>/<span class="enscript-variable-name">Stop</span>/<span class="enscript-variable-name">Unload</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">isWhiteSpace</span>(c)	((c) == <span class="enscript-string">' '</span> || (c) == <span class="enscript-string">'\t'</span> || (c) == <span class="enscript-string">'\r'</span> || (c) == <span class="enscript-string">','</span> || (c) == <span class="enscript-string">'\n'</span>)

<span class="enscript-comment">/*********************************************************************
 * sExcludeListByID is a dictionary with keys / values of:
 *  key = bundleID string of kext we will not allow to load
 *  value = version string(s) of the kext that is to be denied loading.
 *      The version strings can be comma delimited.  For example if kext
 *      com.foocompany.fookext has two versions that we want to deny
 *      loading then the version strings might look like:
 *      1.0.0, 1.0.1
 *      If the current fookext has a version of 1.0.0 OR 1.0.1 we will
 *      not load the kext.
 *
 *      Value may also be in the form of &quot;LE 2.0.0&quot; (version numbers
 *      less than or equal to 2.0.0 will not load) or &quot;LT 2.0.0&quot; (version 
 *      number less than 2.0.0 will not load)
 *
 *      NOTE - we cannot use the characters &quot;&lt;=&quot; or &quot;&lt;&quot; because we have code 
 *      that serializes plists and treats '&lt;' as a special character.
 *********************************************************************/</span>
<span class="enscript-type">bool</span> 
<span class="enscript-function-name">OSKext::isInExcludeList</span>(<span class="enscript-type">void</span>)
{
    OSString *      versionString           = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">char</span> *          versionCString          = NULL;  <span class="enscript-comment">// do not free
</span>    size_t          i;
    boolean_t       wantLessThan = false;
    boolean_t       wantLessThanEqualTo = false;
    <span class="enscript-type">char</span>            myBuffer[32];
    
    <span class="enscript-keyword">if</span> (!sExcludeListByID) {
        <span class="enscript-keyword">return</span>(false);
    }
    <span class="enscript-comment">/* look up by bundleID in our exclude list and if found get version
     * string (or strings) that we will not allow to load
     */</span>
    versionString = OSDynamicCast(OSString, sExcludeListByID-&gt;getObject(bundleID));
    <span class="enscript-keyword">if</span> (versionString == NULL || versionString-&gt;getLength() &gt; (<span class="enscript-keyword">sizeof</span>(myBuffer) - 1)) {
        <span class="enscript-keyword">return</span>(false);
    }
    
    <span class="enscript-comment">/* parse version strings */</span>
    versionCString = (<span class="enscript-type">char</span> *) versionString-&gt;getCStringNoCopy();
    
    <span class="enscript-comment">/* look for &quot;LT&quot; or &quot;LE&quot; form of version string, must be in first two
     * positions.
     */</span>
    <span class="enscript-keyword">if</span> (*versionCString == <span class="enscript-string">'L'</span> &amp;&amp; *(versionCString + 1) == <span class="enscript-string">'T'</span>) {
        wantLessThan = true;
        versionCString +=2; 
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*versionCString == <span class="enscript-string">'L'</span> &amp;&amp; *(versionCString + 1) == <span class="enscript-string">'E'</span>) {
        wantLessThanEqualTo = true;
        versionCString +=2;
    }

    <span class="enscript-keyword">for</span> (i = 0; *versionCString != 0x00; versionCString++) {
        <span class="enscript-comment">/* skip whitespace */</span>
        <span class="enscript-keyword">if</span> (isWhiteSpace(*versionCString)) {
            <span class="enscript-keyword">continue</span>;
        }
        
        <span class="enscript-comment">/* peek ahead for version string separator or null terminator */</span>
        <span class="enscript-keyword">if</span> (*(versionCString + 1) == <span class="enscript-string">','</span> || *(versionCString + 1) == 0x00) {
            
            <span class="enscript-comment">/* OK, we have a version string */</span>
            myBuffer[i++] = *versionCString;
            myBuffer[i] = 0x00;

            OSKextVersion excludeVers;
            excludeVers = OSKextParseVersionString(myBuffer);
                
            <span class="enscript-keyword">if</span> (wantLessThanEqualTo) {
                <span class="enscript-keyword">if</span> (version &lt;= excludeVers) {
                    <span class="enscript-keyword">return</span>(true);
                }
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wantLessThan) {
                <span class="enscript-keyword">if</span> (version &lt; excludeVers) {
                    <span class="enscript-keyword">return</span>(true);
                }
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( version == excludeVers )  {
                <span class="enscript-keyword">return</span>(true);
            }
            
            <span class="enscript-comment">/* reset for the next (if any) version string */</span>
            i = 0;
            wantLessThan = false;
            wantLessThanEqualTo = false;
        }
        <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* save valid version character */</span>
            myBuffer[i++] = *versionCString;
            
            <span class="enscript-comment">/* make sure bogus version string doesn't overrun local buffer */</span>
            <span class="enscript-keyword">if</span> ( i &gt;= <span class="enscript-keyword">sizeof</span>(myBuffer) ) {
                <span class="enscript-keyword">break</span>;
            }
        }
    }
    
    <span class="enscript-keyword">return</span>(false);
} 

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::loadKextWithIdentifier</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>       * kextIdentifierCString,
    Boolean            allowDeferFlag,
    Boolean            delayAutounloadFlag,
    OSKextExcludeLevel startOpt,
    OSKextExcludeLevel startMatchingOpt,
    OSArray          * personalityNames)
{
    OSReturn   result         = kOSReturnError;
    OSString * kextIdentifier = NULL;  <span class="enscript-comment">// must release
</span>
    kextIdentifier = OSString::withCString(kextIdentifierCString);
    <span class="enscript-keyword">if</span> (!kextIdentifier) {
        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    result = OSKext::loadKextWithIdentifier(kextIdentifier,
        allowDeferFlag, delayAutounloadFlag,
        startOpt, startMatchingOpt, personalityNames);
        
<span class="enscript-reference">finish</span>:
    OSSafeRelease(kextIdentifier);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::loadKextWithIdentifier</span>(
    OSString          * kextIdentifier,
    Boolean             allowDeferFlag,
    Boolean             delayAutounloadFlag,
    OSKextExcludeLevel  startOpt,
    OSKextExcludeLevel  startMatchingOpt,
    OSArray           * personalityNames)
{
    OSReturn          result               = kOSReturnError;
    OSReturn          pingResult           = kOSReturnError;
    OSKext          * theKext              = NULL;  <span class="enscript-comment">// do not release
</span>    OSDictionary    * loadRequest          = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">const</span> OSSymbol  * kextIdentifierSymbol = NULL;  <span class="enscript-comment">// must release
</span>
    IORecursiveLockLock(sKextLock);

    <span class="enscript-keyword">if</span> (!kextIdentifier) {
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-reference">OSKext</span>::recordIdentifierRequest(kextIdentifier);

    theKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(kextIdentifier));
    <span class="enscript-keyword">if</span> (!theKext) {
        <span class="enscript-keyword">if</span> (!allowDeferFlag) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Can't load kext %s - not found.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
             <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
        <span class="enscript-keyword">if</span> (!sKernelRequestsEnabled) {
            OSKextLog(theKext,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Can't load kext %s - requests to user space are disabled.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
            result = kOSKextReturnDisabled;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* Create a new request unless one is already sitting
        * in sKernelRequests for this bundle identifier
        */</span>
        kextIdentifierSymbol = OSSymbol::withString(kextIdentifier);
        <span class="enscript-keyword">if</span> (!sPostedKextLoadIdentifiers-&gt;containsObject(kextIdentifierSymbol)) {
            result = _OSKextCreateRequest(kKextRequestPredicateRequestLoad,
                &amp;loadRequest);
            <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            <span class="enscript-keyword">if</span> (!_OSKextSetRequestArgument(loadRequest,
                kKextRequestArgumentBundleIdentifierKey, kextIdentifier)) {
                
                result = kOSKextReturnNoMemory;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            <span class="enscript-keyword">if</span> (!sKernelRequests-&gt;setObject(loadRequest)) {
                result = kOSKextReturnNoMemory;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            
            <span class="enscript-keyword">if</span> (!sPostedKextLoadIdentifiers-&gt;setObject(kextIdentifierSymbol)) {
                result = kOSKextReturnNoMemory;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            OSKextLog(theKext,
                kOSKextLogDebugLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s not found; queued load request to user space.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
        }

        pingResult = OSKext::pingKextd();
        <span class="enscript-keyword">if</span> (pingResult == kOSKextReturnDisabled) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                ((sPrelinkBoot) ? kOSKextLogDebugLevel : kOSKextLogErrorLevel) |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s might not load - kextd is currently unavailable.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
        }

        result = kOSKextReturnDeferred;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = theKext-&gt;load(startOpt, startMatchingOpt, personalityNames);

    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        OSKextLog(theKext,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Failed to load kext %s (error 0x%x).&quot;</span>,
            kextIdentifier-&gt;getCStringNoCopy(), (<span class="enscript-type">int</span>)result);

        <span class="enscript-reference">OSKext</span>::removeKext(theKext,
            <span class="enscript-comment">/* terminateService/removePersonalities */</span> true);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (delayAutounloadFlag) {
        OSKextLog(theKext,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Setting delayed autounload for %s.&quot;</span>,
            kextIdentifier-&gt;getCStringNoCopy());
        theKext-&gt;flags.delayAutounload = 1;
    }

<span class="enscript-reference">finish</span>:
    OSSafeRelease(loadRequest);
    OSSafeRelease(kextIdentifierSymbol);
    
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::recordIdentifierRequest</span>(
    OSString * kextIdentifier)
{
    <span class="enscript-type">const</span> OSSymbol * kextIdentifierSymbol = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">bool</span>             fail                 = false;

    <span class="enscript-keyword">if</span> (!sAllKextLoadIdentifiers || !kextIdentifier) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    kextIdentifierSymbol = OSSymbol::withString(kextIdentifier);
    <span class="enscript-keyword">if</span> (!kextIdentifierSymbol) {
        <span class="enscript-comment">// xxx - this is really a basic alloc failure
</span>        fail = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!sAllKextLoadIdentifiers-&gt;containsObject(kextIdentifierSymbol)) {
        <span class="enscript-keyword">if</span> (!sAllKextLoadIdentifiers-&gt;setObject(kextIdentifierSymbol)) {
            fail = true;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// xxx - need to find a way to associate this whole func w/the kext
</span>            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                <span class="enscript-comment">// xxx - check level
</span>                kOSKextLogStepLevel |
                kOSKextLogArchiveFlag,
                <span class="enscript-string">&quot;Recorded kext %s as a candidate for inclusion in prelinked kernel.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
        }
    }
<span class="enscript-reference">finish</span>:

    <span class="enscript-keyword">if</span> (fail) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogArchiveFlag,
            <span class="enscript-string">&quot;Failed to record kext %s as a candidate for inclusion in prelinked kernel.&quot;</span>,
            kextIdentifier-&gt;getCStringNoCopy());
    }
    OSSafeRelease(kextIdentifierSymbol);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::load</span>(
    OSKextExcludeLevel   startOpt,
    OSKextExcludeLevel   startMatchingOpt,
    OSArray            * personalityNames)
{
    OSReturn             result                       = kOSReturnError;
    kern_return_t        kxldResult;
    OSKextExcludeLevel   dependenciesStartOpt         = startOpt;
    OSKextExcludeLevel   dependenciesStartMatchingOpt = startMatchingOpt;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>         i, count;
    Boolean              alreadyLoaded                = false;
    OSKext             * lastLoadedKext               = NULL;

    <span class="enscript-keyword">if</span> (isInExcludeList()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
                  kOSKextLogErrorLevel | kOSKextLogGeneralFlag |
                  kOSKextLogLoadFlag,
                  <span class="enscript-string">&quot;Kext %s is in exclude list, not loadable&quot;</span>,
                  getIdentifierCString());
        
        result = kOSKextReturnNotLoadable;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (isLoaded()) {
        alreadyLoaded = true;
        result = kOSReturnSuccess;

        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogDebugLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Kext %s is already loaded.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">loaded</span>;
    }
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-keyword">if</span> (current_task() != kernel_task) {
        <span class="enscript-type">int</span>                 macCheckResult      = 0;
        kauth_cred_t        cred                = NULL;

        cred = kauth_cred_get_with_ref();
        macCheckResult = mac_kext_check_load(cred, getIdentifierCString());
        kauth_cred_unref(&amp;cred);
        
        <span class="enscript-keyword">if</span> (macCheckResult != 0) {
            result = kOSReturnError;
            OSKextLog(<span class="enscript-keyword">this</span>,
                      kOSKextLogErrorLevel | kOSKextLogLoadFlag,
                      <span class="enscript-string">&quot;Failed to load kext %s (MAC policy error 0x%x).&quot;</span>,
                      getIdentifierCString(), macCheckResult);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
   }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (!sLoadEnabled) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext loading is disabled (attempt to load kext %s).&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnDisabled;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* If we've pushed the next available load tag to the invalid value,
    * we can't load any more kexts.
    */</span>
    <span class="enscript-keyword">if</span> (sNextLoadTag == kOSKextInvalidLoadTag) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Can't load kext %s - no more load tags to assign.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnNoResources;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* This is a bit of a hack, because we shouldn't be handling 
    * personalities within the load function.
    */</span>
    <span class="enscript-keyword">if</span> (!declaresExecutable()) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">loaded</span>;
    }

   <span class="enscript-comment">/* Are we in safe boot?
    */</span>
    <span class="enscript-keyword">if</span> (sSafeBoot &amp;&amp; !isLoadableInSafeBoot()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Can't load kext %s - not loadable during safe boot.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnBootLevel;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogProgressLevel | kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Loading kext %s.&quot;</span>,
        getIdentifierCString());
    
    <span class="enscript-keyword">if</span> (!sKxldContext) {
        kxldResult = kxld_create_context(&amp;sKxldContext, &amp;kern_allocate, 
            &amp;kxld_log_callback, <span class="enscript-comment">/* Flags */</span> (KXLDFlags) 0, 
            <span class="enscript-comment">/* cputype */</span> 0, <span class="enscript-comment">/* cpusubtype */</span> 0, <span class="enscript-comment">/* page size */</span> 0);
        <span class="enscript-keyword">if</span> (kxldResult) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag | kOSKextLogLinkFlag,
                <span class="enscript-string">&quot;Can't load kext %s - failed to create link context.&quot;</span>,
                getIdentifierCString());
            result = kOSKextReturnNoMemory;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    
    <span class="enscript-comment">/* We only need to resolve dependencies once for the whole graph, but
     * resolveDependencies will just return if there's no work to do, so it's
     * safe to call it more than once.
     */</span>
    <span class="enscript-keyword">if</span> (!resolveDependencies()) {
        <span class="enscript-comment">// xxx - check resolveDependencies() for log msg
</span>        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Can't load kext %s - failed to resolve library dependencies.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnDependencies;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* If we are excluding just the kext being loaded now (and not its
    * dependencies), drop the exclusion level to none so dependencies
    * start and/or add their personalities.
    */</span>
    <span class="enscript-keyword">if</span> (dependenciesStartOpt == kOSKextExcludeKext) {
        dependenciesStartOpt = kOSKextExcludeNone;
    }

    <span class="enscript-keyword">if</span> (dependenciesStartMatchingOpt == kOSKextExcludeKext) {
        dependenciesStartMatchingOpt = kOSKextExcludeNone;
    }

   <span class="enscript-comment">/* Load the dependencies, recursively.
    */</span>
    count = getNumDependencies();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext * dependency = OSDynamicCast(OSKext,
            dependencies-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (dependency == NULL) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag | kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Internal error loading kext %s; dependency disappeared.&quot;</span>,
                getIdentifierCString());
            result = kOSKextReturnInternalError;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
       <span class="enscript-comment">/* Dependencies must be started accorting to the opt,
        * but not given the personality names of the main kext.
        */</span>
        result = dependency-&gt;load(dependenciesStartOpt,
            dependenciesStartMatchingOpt,
            <span class="enscript-comment">/* personalityNames */</span> NULL);
        <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag | kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Dependency %s of kext %s failed to load.&quot;</span>,
                dependency-&gt;getIdentifierCString(),
                getIdentifierCString());

            <span class="enscript-reference">OSKext</span>::removeKext(dependency,
                <span class="enscript-comment">/* terminateService/removePersonalities */</span> true);
            result = kOSKextReturnDependencyLoadError;

            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    result = loadExecutable();
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    pendingPgoHead.next = &amp;pendingPgoHead;
    pendingPgoHead.prev = &amp;pendingPgoHead;

    uuid_generate(instance_uuid);
    account = IONew(OSKextAccount, 1);
    <span class="enscript-keyword">if</span> (!account) {
    	result = KERN_MEMORY_ERROR;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    bzero(account, <span class="enscript-keyword">sizeof</span>(*account));
    account-&gt;loadTag = kmod_info-&gt;id;
    account-&gt;site.flags = VM_TAG_KMOD;

    flags.loaded = true;

   <span class="enscript-comment">/* Add the kext to the list of loaded kexts and update the kmod_info
    * struct to point to that of the last loaded kext (which is the way
    * it's always been done, though I'd rather do them in order now).
    */</span>
    lastLoadedKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getLastObject());
    sLoadedKexts-&gt;setObject(<span class="enscript-keyword">this</span>);

   <span class="enscript-comment">/* Keep the kernel itself out of the kmod list.
    */</span>
    <span class="enscript-keyword">if</span> (lastLoadedKext-&gt;isKernel()) {
        lastLoadedKext = NULL;
    }

    <span class="enscript-keyword">if</span> (lastLoadedKext) {
        kmod_info-&gt;next = lastLoadedKext-&gt;kmod_info;
    }

    notifyKextLoadObservers(<span class="enscript-keyword">this</span>, kmod_info);

   <span class="enscript-comment">/* Make the global kmod list point at the just-loaded kext. Note that the
    * __kernel__ kext isn't in this list, as it wasn't before SnowLeopard,
    * although we do report it in kextstat these days by using the newer
    * OSArray of loaded kexts, which does contain it.
    *
    * (The OSKext object representing the kernel doesn't even have a kmod_info
    * struct, though I suppose we could stick a pointer to it from the
    * static struct in OSRuntime.cpp.)
    */</span>
    kmod = kmod_info;

   <span class="enscript-comment">/* Save the list of loaded kexts in case we panic.
    */</span>
    <span class="enscript-reference">OSKext</span>::saveLoadedKextPanicList();

    <span class="enscript-keyword">if</span> (isExecutable()) {
        <span class="enscript-reference">OSKext</span>::updateLoadedKextSummaries();
        savePanicString(<span class="enscript-comment">/* isLoading */</span> true);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
        registerWithDTrace();
#<span class="enscript-reference">else</span>
        jettisonLinkeditSegment();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
        <span class="enscript-comment">/* If there is a page (or more) worth of padding after the end
         * of the last data section but before the end of the data segment
         * then free it in the same manner the LinkeditSegment is freed
         */</span>
        jettisonDATASegmentPadding();
#<span class="enscript-reference">endif</span>
    }

<span class="enscript-reference">loaded</span>:
    <span class="enscript-keyword">if</span> (isExecutable() &amp;&amp; !flags.started) {
        <span class="enscript-keyword">if</span> (startOpt == kOSKextExcludeNone) {
            result = start();
            <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel | kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Kext %s start failed (result 0x%x).&quot;</span>,
                    getIdentifierCString(), result);
                result = kOSKextReturnStartStopError;
            }
        }
    }
    
   <span class="enscript-comment">/* If not excluding matching, send the personalities to the kernel.
    * This never affects the result of the load operation.
    * This is a bit of a hack, because we shouldn't be handling 
    * personalities within the load function.
    */</span>
    <span class="enscript-keyword">if</span> (result == kOSReturnSuccess &amp;&amp; startMatchingOpt == kOSKextExcludeNone) {
        result = sendPersonalitiesToCatalog(true, personalityNames);
    }

<span class="enscript-reference">finish</span>:

   <span class="enscript-comment">/* More hack! If the kext doesn't declare an executable, even if we
    * &quot;loaded&quot; it, we have to remove any personalities naming it, or we'll
    * never see the registry go quiet. Errors here do not count for the
    * load operation itself.
    *
    * Note that in every other regard it's perfectly ok for a kext to
    * not declare an executable and serve only as a package for personalities
    * naming another kext, so we do have to allow such kexts to be &quot;loaded&quot;
    * so that those other personalities get added &amp; matched.
    */</span>
    <span class="enscript-keyword">if</span> (!declaresExecutable()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel | kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s has no executable; removing any personalities naming it.&quot;</span>,
            getIdentifierCString());
        removePersonalitiesFromCatalog();
    }

    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s failed to load (0x%x).&quot;</span>,
            getIdentifierCString(), (<span class="enscript-type">int</span>)result);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!alreadyLoaded) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s loaded.&quot;</span>,
            getIdentifierCString());

        queueKextNotification(kKextRequestPredicateLoadNotification,
            OSDynamicCast(OSString, bundleID));
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* 
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> * <span class="enscript-function-name">strdup</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * string)
{
    <span class="enscript-type">char</span> * result = NULL;
    size_t size;
    
    <span class="enscript-keyword">if</span> (!string) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    size = 1 + strlen(string);
    result = (<span class="enscript-type">char</span> *)kalloc_tag(size, VM_KERN_MEMORY_OSKEXT);
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    memcpy(result, string, size);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* 
*********************************************************************/</span>

kernel_section_t *
<span class="enscript-function-name">OSKext::lookupSection</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *secname)
{
    kernel_section_t         * found_section = NULL;
    kernel_mach_header_t     * mh            = NULL;
    kernel_segment_command_t * seg           = NULL;
    kernel_section_t         * sec           = NULL;

    mh = (kernel_mach_header_t *)linkedExecutable-&gt;getBytesNoCopy();

    <span class="enscript-keyword">for</span> (seg = firstsegfromheader(mh); seg != NULL; seg = nextsegfromheader(mh, seg)) {

        <span class="enscript-keyword">if</span> (0 != strcmp(seg-&gt;segname, segname)) {
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">for</span> (sec = firstsect(seg); sec != NULL; sec = nextsect(seg, sec)) {

            <span class="enscript-keyword">if</span> (0 == strcmp(sec-&gt;sectname, secname)) {
                found_section = sec;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
            }
        }
    }

 <span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> found_section;
}

<span class="enscript-comment">/*********************************************************************
*
*********************************************************************/</span>

OSReturn
<span class="enscript-function-name">OSKext::slidePrelinkedExecutable</span>()
{
    OSReturn                   result           = kOSKextReturnBadData;
    kernel_mach_header_t     * mh               = NULL;
    kernel_segment_command_t * seg              = NULL;
    kernel_segment_command_t * linkeditSeg      = NULL;
    kernel_section_t         * sec              = NULL;
    <span class="enscript-type">char</span>                     * linkeditBase     = NULL;
    <span class="enscript-type">bool</span>                       haveLinkeditBase = false;
    <span class="enscript-type">char</span>                     * relocBase        = NULL;
    <span class="enscript-type">bool</span>                       haveRelocBase    = false;
    <span class="enscript-type">struct</span> dysymtab_command  * dysymtab         = NULL;
    <span class="enscript-type">struct</span> symtab_command    * symtab           = NULL;
    kernel_nlist_t           * sym              = NULL;
    <span class="enscript-type">struct</span> relocation_info   * reloc            = NULL;
    uint32_t                   i                = 0; 
    <span class="enscript-type">int</span>                        reloc_size;
    vm_offset_t                new_kextsize;

    <span class="enscript-keyword">if</span> (linkedExecutable == NULL || vm_kernel_slide == 0) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    mh = (kernel_mach_header_t *)linkedExecutable-&gt;getBytesNoCopy();

    <span class="enscript-keyword">for</span> (seg = firstsegfromheader(mh); seg != NULL; seg = nextsegfromheader(mh, seg)) {
        <span class="enscript-keyword">if</span> (!seg-&gt;vmaddr) {
            <span class="enscript-keyword">continue</span>;
        }
        seg-&gt;vmaddr += vm_kernel_slide;
                
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
        IOLog(<span class="enscript-string">&quot;kaslr: segname %s unslid 0x%lx slid 0x%lx \n&quot;</span>, 
              seg-&gt;segname,
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(seg-&gt;vmaddr), 
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)seg-&gt;vmaddr);
#<span class="enscript-reference">endif</span>
       
        <span class="enscript-keyword">if</span> (!haveRelocBase) {
            relocBase = (<span class="enscript-type">char</span> *) seg-&gt;vmaddr;
            haveRelocBase = true;
        }
        <span class="enscript-keyword">if</span> (!strcmp(seg-&gt;segname, <span class="enscript-string">&quot;__LINKEDIT&quot;</span>)) {
            linkeditBase = (<span class="enscript-type">char</span> *) seg-&gt;vmaddr - seg-&gt;fileoff;
            haveLinkeditBase = true;
            linkeditSeg = seg;
        }
        <span class="enscript-keyword">for</span> (sec = firstsect(seg); sec != NULL; sec = nextsect(seg, sec)) {
            sec-&gt;addr += vm_kernel_slide;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
            IOLog(<span class="enscript-string">&quot;kaslr: sectname %s unslid 0x%lx slid 0x%lx \n&quot;</span>, 
                  sec-&gt;sectname,
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(sec-&gt;addr), 
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)sec-&gt;addr);
#<span class="enscript-reference">endif</span>
        }
    }

    dysymtab = (<span class="enscript-type">struct</span> dysymtab_command *) getcommandfromheader(mh, LC_DYSYMTAB);

    symtab = (<span class="enscript-type">struct</span> symtab_command *) getcommandfromheader(mh, LC_SYMTAB);

    <span class="enscript-keyword">if</span> (symtab != NULL) {
      <span class="enscript-comment">/* Some pseudo-kexts have symbol tables without segments.
       * Ignore them. */</span>
        <span class="enscript-keyword">if</span> (symtab-&gt;nsyms &gt; 0 &amp;&amp; haveLinkeditBase) {
            sym = (kernel_nlist_t *) (linkeditBase + symtab-&gt;symoff);
            <span class="enscript-keyword">for</span> (i = 0; i &lt; symtab-&gt;nsyms; i++) {
                <span class="enscript-keyword">if</span> (sym[i].n_type &amp; N_STAB) {
                    <span class="enscript-keyword">continue</span>;
                }
                sym[i].n_value += vm_kernel_slide;
                
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SYMS_TO_LOG</span> 5
                <span class="enscript-keyword">if</span> ( i &lt; MAX_SYMS_TO_LOG ) {
                    IOLog(<span class="enscript-string">&quot;kaslr: LC_SYMTAB unslid 0x%lx slid 0x%lx \n&quot;</span>, 
                          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(sym[i].n_value), 
                          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)sym[i].n_value);
                }
#<span class="enscript-reference">endif</span>
            }
        }
    }

    <span class="enscript-keyword">if</span> (dysymtab != NULL) {
        <span class="enscript-keyword">if</span> (dysymtab-&gt;nextrel &gt; 0) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel | kOSKextLogLoadFlag |
                kOSKextLogLinkFlag,
                <span class="enscript-string">&quot;Sliding kext %s: External relocations found.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">if</span> (dysymtab-&gt;nlocrel &gt; 0) {
            <span class="enscript-keyword">if</span> (!haveLinkeditBase) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel | kOSKextLogLoadFlag |
                    kOSKextLogLinkFlag,
                    <span class="enscript-string">&quot;Sliding kext %s: No linkedit segment.&quot;</span>,
                    getIdentifierCString());
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            <span class="enscript-keyword">if</span> (!haveRelocBase) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel | kOSKextLogLoadFlag |
                    kOSKextLogLinkFlag,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
                    <span class="enscript-string">&quot;Sliding kext %s: No writable segments.&quot;</span>,
#<span class="enscript-reference">else</span>
                    <span class="enscript-string">&quot;Sliding kext %s: No segments.&quot;</span>,
#<span class="enscript-reference">endif</span>
                    getIdentifierCString());
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            reloc = (<span class="enscript-type">struct</span> relocation_info *) (linkeditBase + dysymtab-&gt;locreloff);
            reloc_size = dysymtab-&gt;nlocrel * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> relocation_info);
            
            <span class="enscript-keyword">for</span> (i = 0; i &lt; dysymtab-&gt;nlocrel; i++) {
                <span class="enscript-keyword">if</span> (   reloc[i].r_extern != 0
                    || reloc[i].r_type != 0
                    || reloc[i].r_length != (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *) == 8 ? 3 : 2)
                    ) {
                    OSKextLog(<span class="enscript-keyword">this</span>,
                        kOSKextLogErrorLevel | kOSKextLogLoadFlag |
                        kOSKextLogLinkFlag,
                        <span class="enscript-string">&quot;Sliding kext %s: Unexpected relocation found.&quot;</span>,
                        getIdentifierCString());
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                <span class="enscript-keyword">if</span> (reloc[i].r_pcrel != 0) {
                    <span class="enscript-keyword">continue</span>;
                }
                *((uintptr_t *)(relocBase + reloc[i].r_address)) += vm_kernel_slide;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_DYSYMS_TO_LOG</span> 5
                <span class="enscript-keyword">if</span> ( i &lt; MAX_DYSYMS_TO_LOG ) {
                    IOLog(<span class="enscript-string">&quot;kaslr: LC_DYSYMTAB unslid 0x%lx slid 0x%lx \n&quot;</span>, 
                          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(*((uintptr_t *)(relocBase + reloc[i].r_address))), 
                          (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)*((uintptr_t *)(relocBase + reloc[i].r_address)));
                }
#<span class="enscript-reference">endif</span>
            }

            <span class="enscript-comment">/* We should free these relocations, not just delete the reference to them.
             * &lt;rdar://problem/10535549&gt; Free relocations from PIE kexts.
             */</span>
            new_kextsize = round_page(kmod_info-&gt;size - reloc_size);
            
            <span class="enscript-keyword">if</span> ((kmod_info-&gt;size - new_kextsize) &gt; PAGE_SIZE) {
                vm_offset_t     endofkext = kmod_info-&gt;address + kmod_info-&gt;size;
                vm_offset_t     new_endofkext = kmod_info-&gt;address + new_kextsize;
                vm_offset_t     endofrelocInfo = (vm_offset_t) (((uint8_t *)reloc) + reloc_size);
                <span class="enscript-type">int</span>             bytes_remaining = endofkext - endofrelocInfo;
                OSData *        new_osdata = NULL;

                <span class="enscript-comment">/* fix up symbol offsets if they are after the dsymtab local relocs */</span>
                <span class="enscript-keyword">if</span> (symtab) {
                    <span class="enscript-keyword">if</span> (dysymtab-&gt;locreloff &lt; symtab-&gt;symoff){
                        symtab-&gt;symoff -= reloc_size;
                    }
                    <span class="enscript-keyword">if</span> (dysymtab-&gt;locreloff &lt; symtab-&gt;stroff) {
                        symtab-&gt;stroff -= reloc_size;
                    }
                }
                <span class="enscript-keyword">if</span> (dysymtab-&gt;locreloff &lt; dysymtab-&gt;extreloff) {
                    dysymtab-&gt;extreloff -= reloc_size;
                }
                
                <span class="enscript-comment">/* move data behind reloc info down to new offset */</span>
                <span class="enscript-keyword">if</span> (endofrelocInfo &lt; endofkext) {
                   memcpy(reloc, (<span class="enscript-type">void</span> *)endofrelocInfo, bytes_remaining);
                }
                               
                <span class="enscript-comment">/* Create a new OSData for the smaller kext object and reflect 
                 * new linkedit segment size.
                 */</span>
                linkeditSeg-&gt;vmsize = round_page(linkeditSeg-&gt;vmsize - reloc_size);
                linkeditSeg-&gt;filesize = linkeditSeg-&gt;vmsize;
                
                new_osdata = OSData::withBytesNoCopy((<span class="enscript-type">void</span> *)kmod_info-&gt;address, new_kextsize);
                <span class="enscript-keyword">if</span> (new_osdata) {
                    <span class="enscript-comment">/* Fix up kmod info and linkedExecutable.
                     */</span>
                    kmod_info-&gt;size = new_kextsize;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
                    new_osdata-&gt;setDeallocFunction(osdata_kext_free);
#<span class="enscript-reference">else</span>
                    new_osdata-&gt;setDeallocFunction(osdata_phys_free);
#<span class="enscript-reference">endif</span>
                    linkedExecutable-&gt;setDeallocFunction(NULL);
                    linkedExecutable-&gt;release();
                    linkedExecutable = new_osdata;
                    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
                    kext_free(new_endofkext, (endofkext - new_endofkext));
#<span class="enscript-reference">else</span>
                    ml_static_mfree(new_endofkext, (endofkext - new_endofkext));
#<span class="enscript-reference">endif</span>
                }
            }
            dysymtab-&gt;nlocrel = 0;
            dysymtab-&gt;locreloff = 0;
        }
    }
                
    result = kOSReturnSuccess;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* called only by load()
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::loadExecutable</span>()
{
    OSReturn              result             = kOSReturnError;
    kern_return_t         kxldResult;
    KXLDDependency     *  kxlddeps           = NULL;  <span class="enscript-comment">// must kfree
</span>    uint32_t              num_kxlddeps       = 0;
    OSArray            *  linkDependencies   = NULL;  <span class="enscript-comment">// must release
</span>    uint32_t              numDirectDependencies   = 0;
    uint32_t              num_kmod_refs      = 0;
    <span class="enscript-type">struct</span> mach_header ** kxldHeaderPtr      = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">struct</span> mach_header  * kxld_header        = NULL;  <span class="enscript-comment">// xxx - need to free here?
</span>    OSData              * theExecutable      = NULL;  <span class="enscript-comment">// do not release
</span>    OSString            * versString         = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span>          * versCString        = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span>          * string             = NULL;  <span class="enscript-comment">// do not free
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>          i;

   <span class="enscript-comment">/* We need the version string for a variety of bits below.
    */</span>
    versString = OSDynamicCast(OSString,
        getPropertyForHostArch(kCFBundleVersionKey));
    <span class="enscript-keyword">if</span> (!versString) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    versCString = versString-&gt;getCStringNoCopy();

    <span class="enscript-keyword">if</span> (isKernelComponent()) {
       <span class="enscript-keyword">if</span> (STRING_HAS_PREFIX(versCString, KERNEL_LIB_PREFIX)) {

           <span class="enscript-keyword">if</span> (strncmp(versCString, KERNEL6_VERSION, strlen(KERNEL6_VERSION))) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Kernel component %s has incorrect version %s; &quot;</span>
                    <span class="enscript-string">&quot;expected %s.&quot;</span>,
                    getIdentifierCString(),
                    versCString, KERNEL6_VERSION);
               result = kOSKextReturnInternalError;
               <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
           } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(versCString, osrelease)) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Kernel component %s has incorrect version %s; &quot;</span>
                    <span class="enscript-string">&quot;expected %s.&quot;</span>,
                    getIdentifierCString(),
                    versCString, osrelease);
               result = kOSKextReturnInternalError;
               <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
           }
       }
    }

    <span class="enscript-keyword">if</span> (isPrelinked()) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">register_kmod</span>;
    }

    <span class="enscript-comment">/* &lt;rdar://problem/21444003&gt; all callers must be entitled */</span>
    <span class="enscript-keyword">if</span> (FALSE == IOTaskHasEntitlement(current_task(), <span class="enscript-string">&quot;com.apple.rootless.kext-management&quot;</span>)) {
        OSKextLog(<span class="enscript-keyword">this</span>,
                  kOSKextLogErrorLevel | kOSKextLogLoadFlag,
                  <span class="enscript-string">&quot;Not entitled to link kext '%s'&quot;</span>,
                  getIdentifierCString());
        result = kOSKextReturnNotPrivileged;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    theExecutable = getExecutable();
    <span class="enscript-keyword">if</span> (!theExecutable) {
        <span class="enscript-keyword">if</span> (declaresExecutable()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Can't load kext %s - executable is missing.&quot;</span>,
                getIdentifierCString());
            result = kOSKextReturnValidation;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">register_kmod</span>;
    }

    <span class="enscript-keyword">if</span> (isInterface()) {
        OSData *executableCopy = OSData::withData(theExecutable);
        setLinkedExecutable(executableCopy);
        executableCopy-&gt;release();
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">register_kmod</span>;
    }

    numDirectDependencies = getNumDependencies();

    <span class="enscript-keyword">if</span> (flags.hasBleedthrough) {
        linkDependencies = dependencies;
        linkDependencies-&gt;retain();
    } <span class="enscript-keyword">else</span> {
        linkDependencies = OSArray::withArray(dependencies);
        <span class="enscript-keyword">if</span> (!linkDependencies) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag | kOSKextLogLinkFlag,
                <span class="enscript-string">&quot;Can't allocate link dependencies to load kext %s.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">for</span> (i = 0; i &lt; numDirectDependencies; ++i) {
            OSKext * dependencyKext = OSDynamicCast(OSKext,
                dependencies-&gt;getObject(i));
            dependencyKext-&gt;addBleedthroughDependencies(linkDependencies);
        }
    } 

    num_kxlddeps = linkDependencies-&gt;getCount();
    <span class="enscript-keyword">if</span> (!num_kxlddeps) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Can't load kext %s - it has no library dependencies.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    kxlddeps = (KXLDDependency *)kalloc_tag(num_kxlddeps * <span class="enscript-keyword">sizeof</span>(*kxlddeps), VM_KERN_MEMORY_OSKEXT);
    <span class="enscript-keyword">if</span> (!kxlddeps) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogLinkFlag,
            <span class="enscript-string">&quot;Can't allocate link context to load kext %s.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    bzero(kxlddeps, num_kxlddeps * <span class="enscript-keyword">sizeof</span>(*kxlddeps));

    <span class="enscript-keyword">for</span> (i = 0; i &lt; num_kxlddeps; ++i ) {
        OSKext * dependency = OSDynamicCast(OSKext, linkDependencies-&gt;getObject(i));

        <span class="enscript-keyword">if</span> (dependency-&gt;isInterface()) {
            OSKext *interfaceTargetKext = NULL;
            OSData * interfaceTarget = NULL;

            <span class="enscript-keyword">if</span> (dependency-&gt;isKernelComponent()) {
                interfaceTargetKext = sKernelKext;
                interfaceTarget = sKernelKext-&gt;linkedExecutable;
            } <span class="enscript-keyword">else</span> {
                interfaceTargetKext = OSDynamicCast(OSKext, 
                    dependency-&gt;dependencies-&gt;getObject(0));

                interfaceTarget = interfaceTargetKext-&gt;linkedExecutable;
            }

            <span class="enscript-keyword">if</span> (!interfaceTarget) {
                <span class="enscript-comment">// panic?
</span>                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

           <span class="enscript-comment">/* The names set here aren't actually logged yet &lt;rdar://problem/7941514&gt;,
            * it will be useful to have them in the debugger.
            * strdup() failing isn't critical right here so we don't check that.
            */</span>
            kxlddeps[i].kext = (u_char *) interfaceTarget-&gt;getBytesNoCopy();
            kxlddeps[i].kext_size = interfaceTarget-&gt;getLength();
            kxlddeps[i].kext_name = strdup(interfaceTargetKext-&gt;getIdentifierCString());

            kxlddeps[i].interface = (u_char *) dependency-&gt;linkedExecutable-&gt;getBytesNoCopy();
            kxlddeps[i].interface_size = dependency-&gt;linkedExecutable-&gt;getLength();
            kxlddeps[i].interface_name = strdup(dependency-&gt;getIdentifierCString());
        } <span class="enscript-keyword">else</span> {
            kxlddeps[i].kext = (u_char *) dependency-&gt;linkedExecutable-&gt;getBytesNoCopy();
            kxlddeps[i].kext_size = dependency-&gt;linkedExecutable-&gt;getLength();
            kxlddeps[i].kext_name = strdup(dependency-&gt;getIdentifierCString());
        }

        kxlddeps[i].is_direct_dependency = (i &lt; numDirectDependencies);
    }

    kxldHeaderPtr = &amp;kxld_header;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogExplicitLevel |
        kOSKextLogLoadFlag | kOSKextLogLinkFlag,
        <span class="enscript-string">&quot;Kext %s - calling kxld_link_file:\n&quot;</span>
        <span class="enscript-string">&quot;    kxld_context: %p\n&quot;</span>
        <span class="enscript-string">&quot;    executable: %p    executable_length: %d\n&quot;</span>
        <span class="enscript-string">&quot;    user_data: %p\n&quot;</span>
        <span class="enscript-string">&quot;    kxld_dependencies: %p    num_dependencies: %d\n&quot;</span>
        <span class="enscript-string">&quot;    kxld_header_ptr: %p    kmod_info_ptr: %p\n&quot;</span>,
        getIdentifierCString(), sKxldContext,
        theExecutable-&gt;getBytesNoCopy(), theExecutable-&gt;getLength(),
        <span class="enscript-keyword">this</span>, kxlddeps, num_kxlddeps,
        kxldHeaderPtr, &amp;kmod_info);
#<span class="enscript-reference">endif</span>

   <span class="enscript-comment">/* After this call, the linkedExecutable instance variable
    * should exist.
    */</span>
    kxldResult = kxld_link_file(sKxldContext,
        (u_char *)theExecutable-&gt;getBytesNoCopy(),
        theExecutable-&gt;getLength(),
        getIdentifierCString(), <span class="enscript-keyword">this</span>, kxlddeps, num_kxlddeps,
        (u_char **)kxldHeaderPtr, (kxld_addr_t *)&amp;kmod_info);

    <span class="enscript-keyword">if</span> (kxldResult != KERN_SUCCESS) {
        <span class="enscript-comment">// xxx - add kxldResult here?
</span>        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Can't load kext %s - link failed.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnLinkError;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
   <span class="enscript-comment">/* We've written data &amp; instructions into kernel memory, so flush the data
    * cache and invalidate the instruction cache.
    * I/D caches are coherent on x86
    */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    flush_dcache(kmod_info-&gt;address, kmod_info-&gt;size, false);
    invalidate_icache(kmod_info-&gt;address, kmod_info-&gt;size, false);
#<span class="enscript-reference">endif</span>
<span class="enscript-reference">register_kmod</span>:

    <span class="enscript-keyword">if</span> (isInterface()) {

       <span class="enscript-comment">/* Whip up a fake kmod_info entry for the interface kext.
        */</span>
        kmod_info = (kmod_info_t *)kalloc_tag(<span class="enscript-keyword">sizeof</span>(kmod_info_t), VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (!kmod_info) {
            result = KERN_MEMORY_ERROR;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* A pseudokext has almost nothing in its kmod_info struct.
        */</span>
        bzero(kmod_info, <span class="enscript-keyword">sizeof</span>(kmod_info_t));

        kmod_info-&gt;info_version = KMOD_INFO_VERSION;

       <span class="enscript-comment">/* An interface kext doesn't have a linkedExecutable, so save a
        * copy of the UUID out of the original executable via copyUUID()
        * while we still have the original executable.
        */</span>
        interfaceUUID = copyUUID();
    }

    kmod_info-&gt;id = loadTag = sNextLoadTag++;
    kmod_info-&gt;reference_count = 0;  <span class="enscript-comment">// KMOD_DECL... sets it to -1 (invalid).
</span>
   <span class="enscript-comment">/* Stamp the bundle ID and version from the OSKext over anything
    * resident inside the kmod_info.
    */</span>
    string = getIdentifierCString();
    strlcpy(kmod_info-&gt;name, string, <span class="enscript-keyword">sizeof</span>(kmod_info-&gt;name));

    string = versCString;
    strlcpy(kmod_info-&gt;version, string, <span class="enscript-keyword">sizeof</span>(kmod_info-&gt;version));

   <span class="enscript-comment">/* Add the dependencies' kmod_info structs as kmod_references.
    */</span>
    num_kmod_refs = getNumDependencies();
    <span class="enscript-keyword">if</span> (num_kmod_refs) {
        kmod_info-&gt;reference_list = (kmod_reference_t *)kalloc_tag(
            num_kmod_refs * <span class="enscript-keyword">sizeof</span>(kmod_reference_t), VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (!kmod_info-&gt;reference_list) {
            result = KERN_MEMORY_ERROR;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        bzero(kmod_info-&gt;reference_list,
            num_kmod_refs * <span class="enscript-keyword">sizeof</span>(kmod_reference_t));
        <span class="enscript-keyword">for</span> (uint32_t refIndex = 0; refIndex &lt; num_kmod_refs; refIndex++) {
            kmod_reference_t * ref = &amp;(kmod_info-&gt;reference_list[refIndex]);
            OSKext * refKext = OSDynamicCast(OSKext, dependencies-&gt;getObject(refIndex));
            ref-&gt;info = refKext-&gt;kmod_info;
            ref-&gt;info-&gt;reference_count++;

            <span class="enscript-keyword">if</span> (refIndex + 1 &lt; num_kmod_refs) {
                ref-&gt;next = kmod_info-&gt;reference_list + refIndex + 1;
            }
        }
    }

    <span class="enscript-keyword">if</span> (!isInterface() &amp;&amp; linkedExecutable) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s executable loaded; %u pages at 0x%lx (load tag %u).&quot;</span>, 
            kmod_info-&gt;name,
            (<span class="enscript-type">unsigned</span>)kmod_info-&gt;size / PAGE_SIZE,
            (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)VM_KERNEL_UNSLIDE(kmod_info-&gt;address),
            (<span class="enscript-type">unsigned</span>)kmod_info-&gt;id);
    }

    <span class="enscript-comment">/* if prelinked, VM protections are already set */</span>
    result = setVMAttributes(!isPrelinked(), true);
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    OSSafeRelease(linkDependencies);

   <span class="enscript-comment">/* Clear up locally allocated dependency info.
    */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; num_kxlddeps; ++i ) {
        size_t size;

        <span class="enscript-keyword">if</span> (kxlddeps[i].kext_name) {
            size = 1 + strlen(kxlddeps[i].kext_name);
            kfree(kxlddeps[i].kext_name, size);
        }
        <span class="enscript-keyword">if</span> (kxlddeps[i].interface_name) {
            size = 1 + strlen(kxlddeps[i].interface_name);
            kfree(kxlddeps[i].interface_name, size);
        }
    }
    <span class="enscript-keyword">if</span> (kxlddeps) kfree(kxlddeps, (num_kxlddeps * <span class="enscript-keyword">sizeof</span>(*kxlddeps)));

   <span class="enscript-comment">/* We no longer need the unrelocated executable (which the linker
    * has altered anyhow).
    */</span>
    setExecutable(NULL);

    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Failed to load executable for kext %s.&quot;</span>,
            getIdentifierCString());

        <span class="enscript-keyword">if</span> (kmod_info &amp;&amp; kmod_info-&gt;reference_list) {
            kfree(kmod_info-&gt;reference_list,
                num_kmod_refs * <span class="enscript-keyword">sizeof</span>(kmod_reference_t));
        }
        <span class="enscript-keyword">if</span> (isInterface()) {
            kfree(kmod_info, <span class="enscript-keyword">sizeof</span>(kmod_info_t));
        }
        kmod_info = NULL;
        <span class="enscript-keyword">if</span> (linkedExecutable) {
            linkedExecutable-&gt;release();
            linkedExecutable = NULL;
        }
    }

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* The linkedit segment is used by the kext linker for dependency
* resolution, and by dtrace for probe initialization. We can free it
* for non-library kexts, since no kexts depend on non-library kexts
* by definition, once dtrace has been initialized.
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::jettisonLinkeditSegment</span>(<span class="enscript-type">void</span>)
{
    kernel_mach_header_t     * machhdr = (kernel_mach_header_t *)kmod_info-&gt;address;
    kernel_segment_command_t * linkedit = NULL;
    vm_offset_t                start;
    vm_size_t                  linkeditsize, kextsize;
    OSData                   * data = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NO_KEXTD</span>
    <span class="enscript-comment">/* We can free symbol tables for all embedded kexts because we don't
     * support runtime kext linking.
     */</span>
    <span class="enscript-keyword">if</span> (sKeepSymbols || !isExecutable() || !linkedExecutable || flags.jettisonLinkeditSeg) {
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">if</span> (sKeepSymbols || isLibrary() || !isExecutable() || !linkedExecutable || flags.jettisonLinkeditSeg) {
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Find the linkedit segment.  If it's not the last segment, then freeing
    * it will fragment the kext into multiple VM regions, which OSKext is not
    * designed to handle, so we'll have to skip it.
    */</span>
    linkedit = getsegbynamefromheader(machhdr, SEG_LINKEDIT);
    <span class="enscript-keyword">if</span> (!linkedit) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (round_page(kmod_info-&gt;address + kmod_info-&gt;size) !=
        round_page(linkedit-&gt;vmaddr + linkedit-&gt;vmsize))
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Create a new OSData for the smaller kext object.
    */</span>
    linkeditsize = round_page(linkedit-&gt;vmsize);
    kextsize = kmod_info-&gt;size - linkeditsize;
    start = linkedit-&gt;vmaddr;

    data = OSData::withBytesNoCopy((<span class="enscript-type">void</span> *)kmod_info-&gt;address, kextsize);
    <span class="enscript-keyword">if</span> (!data) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Fix the kmod info and linkedExecutable.
    */</span>
    kmod_info-&gt;size = kextsize;
        
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
    data-&gt;setDeallocFunction(osdata_kext_free);
#<span class="enscript-reference">else</span>
    data-&gt;setDeallocFunction(osdata_phys_free);
#<span class="enscript-reference">endif</span>
    linkedExecutable-&gt;setDeallocFunction(NULL);
    linkedExecutable-&gt;release();
    linkedExecutable = data;
    flags.jettisonLinkeditSeg = 1;
        
   <span class="enscript-comment">/* Free the linkedit segment.
    */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
    kext_free(start, linkeditsize);
#<span class="enscript-reference">else</span>
    ml_static_mfree(start, linkeditsize);
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* If there are whole pages that are unused betweem the last section
* of the DATA segment and the end of the DATA segment then we can free
* them
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::jettisonDATASegmentPadding</span>(<span class="enscript-type">void</span>)
{
    kernel_mach_header_t * mh;
    kernel_segment_command_t * dataSeg;
    kernel_section_t * sec, * lastSec;
    vm_offset_t dataSegEnd, lastSecEnd;
    vm_size_t padSize;

    mh = (kernel_mach_header_t *)kmod_info-&gt;address;

    dataSeg = getsegbynamefromheader(mh, SEG_DATA);
    <span class="enscript-keyword">if</span> (dataSeg == NULL) {
        <span class="enscript-keyword">return</span>;
    }

    lastSec = NULL;
    sec = firstsect(dataSeg);
    <span class="enscript-keyword">while</span> (sec != NULL) {
        lastSec = sec;
        sec = nextsect(dataSeg, sec);
    } 

    <span class="enscript-keyword">if</span> (lastSec == NULL) {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> ((dataSeg-&gt;vmaddr != round_page(dataSeg-&gt;vmaddr)) ||
        (dataSeg-&gt;vmsize != round_page(dataSeg-&gt;vmsize))) {
        <span class="enscript-keyword">return</span>;
    }

    dataSegEnd = dataSeg-&gt;vmaddr + dataSeg-&gt;vmsize;
    lastSecEnd = round_page(lastSec-&gt;addr + lastSec-&gt;size);

    <span class="enscript-keyword">if</span> (dataSegEnd &lt;= lastSecEnd) {
        <span class="enscript-keyword">return</span>;
    }

    padSize = dataSegEnd - lastSecEnd;

    <span class="enscript-keyword">if</span> (padSize &gt;= PAGE_SIZE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
        kext_free(lastSecEnd, padSize);
#<span class="enscript-reference">else</span>
        ml_static_mfree(lastSecEnd, padSize);
#<span class="enscript-reference">endif</span>
    }
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::setLinkedExecutable</span>(OSData * anExecutable)
{
    <span class="enscript-keyword">if</span> (linkedExecutable) {
        panic(<span class="enscript-string">&quot;Attempt to set linked executable on kext &quot;</span>
            <span class="enscript-string">&quot;that already has one (%s).\n&quot;</span>,
            getIdentifierCString());
    }
    linkedExecutable = anExecutable;
    linkedExecutable-&gt;retain();
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-comment">/*********************************************************************
* Go through all loaded kexts and tell them to register with dtrace.
* The instance method only registers if necessary.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::registerKextsWithDTrace</span>(<span class="enscript-type">void</span>)
{
    uint32_t count = sLoadedKexts-&gt;getCount();
    uint32_t i;

    IORecursiveLockLock(sKextLock);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext   * thisKext     = NULL;  <span class="enscript-comment">// do not release
</span>
        thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!thisKext || !thisKext-&gt;isExecutable()) {
            <span class="enscript-keyword">continue</span>;
        }

        thisKext-&gt;registerWithDTrace();
    }

    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
    <span class="enscript-type">extern</span> <span class="enscript-type">int</span> (*dtrace_modload)(<span class="enscript-type">struct</span> kmod_info *, uint32_t);
    <span class="enscript-type">extern</span> <span class="enscript-type">int</span> (*dtrace_modunload)(<span class="enscript-type">struct</span> kmod_info *);
};

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::registerWithDTrace</span>(<span class="enscript-type">void</span>)
{
   <span class="enscript-comment">/* Register kext with dtrace. A dtrace_modload failure should not
    * prevent a kext from loading, so we ignore the return code.
    */</span>
    <span class="enscript-keyword">if</span> (!flags.dtraceInitialized &amp;&amp; (dtrace_modload != NULL)) {
        uint32_t modflag = 0;
        OSObject * forceInit = getPropertyForHostArch(<span class="enscript-string">&quot;OSBundleForceDTraceInit&quot;</span>);
        <span class="enscript-keyword">if</span> (forceInit == kOSBooleanTrue) {
            modflag |= KMOD_DTRACE_FORCE_INIT;
        }

        (<span class="enscript-type">void</span>)(*dtrace_modload)(kmod_info, modflag);
        flags.dtraceInitialized = true;
        jettisonLinkeditSegment();
    }
    <span class="enscript-keyword">return</span>;
}
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::unregisterWithDTrace</span>(<span class="enscript-type">void</span>)
{
   <span class="enscript-comment">/* Unregister kext with dtrace. A dtrace_modunload failure should not
    * prevent a kext from loading, so we ignore the return code.
    */</span>
    <span class="enscript-keyword">if</span> (flags.dtraceInitialized &amp;&amp; (dtrace_modunload != NULL)) {
        (<span class="enscript-type">void</span>)(*dtrace_modunload)(kmod_info);
        flags.dtraceInitialized = false;
    }
    <span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>


<span class="enscript-comment">/*********************************************************************
* called only by loadExecutable()
*********************************************************************/</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unrecognized</span> <span class="enscript-variable-name">architecture</span> 
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">inline</span> kern_return_t
<span class="enscript-function-name">OSKext_protect</span>(
    vm_map_t   map,
    vm_map_offset_t    start,
    vm_map_offset_t    end,
    vm_prot_t  new_prot,
    boolean_t  set_max)
{
    <span class="enscript-keyword">if</span> (start == end) { <span class="enscript-comment">// 10538581
</span>        <span class="enscript-keyword">return</span>(KERN_SUCCESS);
    }
    <span class="enscript-keyword">return</span> vm_map_protect(map, start, end, new_prot, set_max);
}

<span class="enscript-type">static</span> <span class="enscript-type">inline</span> kern_return_t
<span class="enscript-function-name">OSKext_wire</span>(
    vm_map_t   map,
    vm_map_offset_t    start,
    vm_map_offset_t    end,
    vm_prot_t  access_type,
    boolean_t       user_wire)
{
	<span class="enscript-keyword">return</span> vm_map_wire(map, start, end, access_type | VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_KEXT), user_wire);
}
#<span class="enscript-reference">endif</span>

OSReturn
<span class="enscript-function-name">OSKext::setVMAttributes</span>(<span class="enscript-type">bool</span> protect, <span class="enscript-type">bool</span> wire)
{
    vm_map_t                    kext_map        = NULL;
    kernel_segment_command_t  * seg             = NULL;
    vm_map_offset_t             start           = 0;
    vm_map_offset_t             end             = 0;
    OSReturn                    result          = kOSReturnError;

    <span class="enscript-keyword">if</span> (isInterface() || !declaresExecutable()) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Get the kext's vm map */</span>
    kext_map = kext_get_vm_map(kmod_info);
    <span class="enscript-keyword">if</span> (!kext_map) {
        result = KERN_MEMORY_ERROR;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Protect the headers as read-only; they do not need to be wired */</span>
    result = (protect) ? OSKext_protect(kext_map, kmod_info-&gt;address, 
        kmod_info-&gt;address + kmod_info-&gt;hdr_size, VM_PROT_READ, TRUE)
            : KERN_SUCCESS;
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">/* Set the VM protections and wire down each of the segments */</span>
    seg = firstsegfromheader((kernel_mach_header_t *)kmod_info-&gt;address);
    <span class="enscript-keyword">while</span> (seg) {


        start = round_page(seg-&gt;vmaddr);
        end = trunc_page(seg-&gt;vmaddr + seg-&gt;vmsize);

        <span class="enscript-keyword">if</span> (protect) {
            result = OSKext_protect(kext_map, start, end, seg-&gt;maxprot, TRUE);
            <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Kext %s failed to set maximum VM protections &quot;</span>
                    <span class="enscript-string">&quot;for segment %s - 0x%x.&quot;</span>,
                    getIdentifierCString(), seg-&gt;segname, (<span class="enscript-type">int</span>)result);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            result = OSKext_protect(kext_map, start, end, seg-&gt;initprot, FALSE);
            <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Kext %s failed to set initial VM protections &quot;</span>
                    <span class="enscript-string">&quot;for segment %s - 0x%x.&quot;</span>,
                    getIdentifierCString(), seg-&gt;segname, (<span class="enscript-type">int</span>)result);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
        }

        <span class="enscript-keyword">if</span> (segmentShouldBeWired(seg) &amp;&amp; wire) {
            result = OSKext_wire(kext_map, start, end, seg-&gt;initprot, FALSE);
            <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
        }

        seg = nextsegfromheader((kernel_mach_header_t *) kmod_info-&gt;address, seg);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
boolean_t 
<span class="enscript-function-name">OSKext::segmentShouldBeWired</span>(kernel_segment_command_t *seg)
{
    <span class="enscript-keyword">return</span> (sKeepSymbols || strncmp(seg-&gt;segname, SEG_LINKEDIT, <span class="enscript-keyword">sizeof</span>(seg-&gt;segname)));
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::validateKextMapping</span>(<span class="enscript-type">bool</span> startFlag)
{
    OSReturn                              result      = kOSReturnError;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>                          * whichOp = startFlag ? <span class="enscript-string">&quot;start&quot;</span> : <span class="enscript-string">&quot;stop&quot;</span>;
    kern_return_t                         kern_result = 0;
    vm_map_t                              kext_map    = NULL;
    kernel_segment_command_t            * seg         = NULL;
    mach_vm_address_t                     address     = 0;
    mach_vm_size_t                        size        = 0;
    uint32_t                              depth       = 0;
    mach_msg_type_number_t                count;
    vm_region_submap_short_info_data_64_t info;

    count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
    bzero(&amp;info, <span class="enscript-keyword">sizeof</span>(info));

   <span class="enscript-comment">// xxx - do we need a distinct OSReturn value for these or is &quot;bad data&quot;
</span>   <span class="enscript-comment">// xxx - sufficient?
</span>
   <span class="enscript-comment">/* Verify that the kmod_info and start/stop pointers are non-NULL.
    */</span>
    <span class="enscript-keyword">if</span> (!kmod_info) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s - NULL kmod_info pointer.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnBadData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (startFlag) {
        address = (mach_vm_address_t)kmod_info-&gt;start;
    } <span class="enscript-keyword">else</span> {
        address = (mach_vm_address_t)kmod_info-&gt;stop;
    }

    <span class="enscript-keyword">if</span> (!address) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s - NULL module %s pointer.&quot;</span>,
            getIdentifierCString(), whichOp);
        result = kOSKextReturnBadData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    kext_map = kext_get_vm_map(kmod_info);
    depth = (kernel_map == kext_map) ? 1 : 2;

   <span class="enscript-comment">/* Verify that the start/stop function lies within the kext's address range.
    */</span>
    <span class="enscript-keyword">if</span> (address &lt; kmod_info-&gt;address + kmod_info-&gt;hdr_size ||
        kmod_info-&gt;address + kmod_info-&gt;size &lt;= address)
    {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s module %s pointer is outside of kext range &quot;</span>
            <span class="enscript-string">&quot;(%s %p - kext at %p-%p)..&quot;</span>,
            getIdentifierCString(),
            whichOp,
            whichOp,
            (<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE(address),
            (<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE(kmod_info-&gt;address),
            (<span class="enscript-type">void</span> *)(VM_KERNEL_UNSLIDE(kmod_info-&gt;address) + kmod_info-&gt;size));
        result = kOSKextReturnBadData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Only do these checks before calling the start function;
    * If anything goes wrong with the mapping while the kext is running,
    * we'll likely have panicked well before any attempt to stop the kext.
    */</span>
    <span class="enscript-keyword">if</span> (startFlag) {

       <span class="enscript-comment">/* Verify that the start/stop function is executable.
        */</span>
        kern_result = mach_vm_region_recurse(kernel_map, &amp;address, &amp;size, &amp;depth,
            (vm_region_recurse_info_t)&amp;info, &amp;count);
        <span class="enscript-keyword">if</span> (kern_result != KERN_SUCCESS) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s - bad %s pointer %p.&quot;</span>,
                getIdentifierCString(),
                whichOp, (<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE(address)); 
            result = kOSKextReturnBadData;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
        <span class="enscript-keyword">if</span> (!(info.protection &amp; VM_PROT_EXECUTE)) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s - memory region containing module %s function &quot;</span>
                <span class="enscript-string">&quot;is not executable.&quot;</span>,
                getIdentifierCString(), whichOp);
            result = kOSKextReturnBadData;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
#<span class="enscript-reference">endif</span>

       <span class="enscript-comment">/* Verify that the kext's segments are backed by physical memory.
        */</span>
        seg = firstsegfromheader((kernel_mach_header_t *)kmod_info-&gt;address);
        <span class="enscript-keyword">while</span> (seg) {
            <span class="enscript-keyword">if</span> (!verifySegmentMapping(seg)) {
                result = kOSKextReturnBadData;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            seg = nextsegfromheader((kernel_mach_header_t *) kmod_info-&gt;address, seg);
        }

    }

    result = kOSReturnSuccess;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
boolean_t
<span class="enscript-function-name">OSKext::verifySegmentMapping</span>(kernel_segment_command_t *seg)
{
    mach_vm_address_t address = 0;

    <span class="enscript-keyword">if</span> (!segmentShouldBeWired(seg)) <span class="enscript-keyword">return</span> true;

    <span class="enscript-keyword">for</span> (address = seg-&gt;vmaddr;
         address &lt; round_page(seg-&gt;vmaddr + seg-&gt;vmsize);
         address += PAGE_SIZE)
    {
        <span class="enscript-keyword">if</span> (!pmap_find_phys(kernel_pmap, (vm_offset_t)address)) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s - page %p is not backed by physical memory.&quot;</span>,
                getIdentifierCString(), 
                (<span class="enscript-type">void</span> *)address);
            <span class="enscript-keyword">return</span> false;
        }
    }

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::start</span>(<span class="enscript-type">bool</span> startDependenciesFlag)
{
    OSReturn                            result = kOSReturnError;
    kern_return_t                       (* startfunc)(kmod_info_t *, <span class="enscript-type">void</span> *);
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>                        i, count;
    <span class="enscript-type">void</span>                              * kmodStartData = NULL; 

    <span class="enscript-keyword">if</span> (isStarted() || isInterface() || isKernelComponent()) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!isLoaded()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Attempt to start nonloaded kext %s.&quot;</span>,
            getIdentifierCString()); 
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!sLoadEnabled) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext loading is disabled (attempt to start kext %s).&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnDisabled;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = validateKextMapping(<span class="enscript-comment">/* start? */</span> true);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    startfunc = kmod_info-&gt;start;

    count = getNumDependencies();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext * dependency = OSDynamicCast(OSKext, dependencies-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (dependency == NULL) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s start - internal error, dependency disappeared.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        <span class="enscript-keyword">if</span> (!dependency-&gt;isStarted()) {
            <span class="enscript-keyword">if</span> (startDependenciesFlag) {
                OSReturn dependencyResult =
                    dependency-&gt;start(startDependenciesFlag);
                <span class="enscript-keyword">if</span> (dependencyResult != KERN_SUCCESS) {
                    OSKextLog(<span class="enscript-keyword">this</span>,
                        kOSKextLogErrorLevel |
                        kOSKextLogLoadFlag,
                        <span class="enscript-string">&quot;Kext %s start - dependency %s failed to start (error 0x%x).&quot;</span>,
                        getIdentifierCString(),
                        dependency-&gt;getIdentifierCString(),
                        dependencyResult);
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
            } <span class="enscript-keyword">else</span> {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Not starting %s - dependency %s not started yet.&quot;</span>,
                    getIdentifierCString(),
                    dependency-&gt;getIdentifierCString());
                result = kOSKextReturnStartStopError;  <span class="enscript-comment">// xxx - make new return?
</span>                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
        }
    }

    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogDetailLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Kext %s calling module start function.&quot;</span>,
        getIdentifierCString()); 

    flags.starting = 1;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_STATIC_CPPINIT</span>
    result = OSRuntimeInitializeCPP(kmod_info, NULL);
    <span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEC_FIPS</span>
        kmodStartData = GetAppleTEXTHashForKext(<span class="enscript-keyword">this</span>, <span class="enscript-keyword">this</span>-&gt;infoDict);
        
#<span class="enscript-reference">if</span> 0
        <span class="enscript-keyword">if</span> (kmodStartData) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                      kOSKextLogErrorLevel |
                      kOSKextLogGeneralFlag,
                      <span class="enscript-string">&quot;Kext %s calling module start function. kmodStartData %p. arch %s&quot;</span>,
                      getIdentifierCString(), kmodStartData, ARCHNAME); 
        }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">CONFIG_KEC_FIPS</span> 

        result = startfunc(kmod_info, kmodStartData);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_STATIC_CPPINIT</span>
        <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
            (<span class="enscript-type">void</span>) OSRuntimeFinalizeCPP(kmod_info, NULL);
        }
    }
#<span class="enscript-reference">endif</span>

    flags.starting = 0;

   <span class="enscript-comment">/* On success overlap the setting of started/starting. On failure just
    * clear starting.
    */</span>
    <span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
        flags.started = 1;

        <span class="enscript-comment">// xxx - log start error from kernel?
</span>        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s is now started.&quot;</span>,
            getIdentifierCString()); 
    } <span class="enscript-keyword">else</span> {
        invokeOrCancelRequestCallbacks(
            <span class="enscript-comment">/* result not actually used */</span> kOSKextReturnStartStopError,
            <span class="enscript-comment">/* invokeFlag */</span> false);
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s did not start (return code 0x%x).&quot;</span>,
            getIdentifierCString(), result); 
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">OSKext::canUnloadKextWithIdentifier</span>(
    OSString * kextIdentifier,
    <span class="enscript-type">bool</span>       checkClassesFlag)
{
    <span class="enscript-type">bool</span>     result = false;
    OSKext * aKext  = NULL;  <span class="enscript-comment">// do not release
</span>
    IORecursiveLockLock(sKextLock);

    aKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(kextIdentifier));

    <span class="enscript-keyword">if</span> (!aKext) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;  <span class="enscript-comment">// can't unload what's not loaded
</span>    }

    <span class="enscript-keyword">if</span> (aKext-&gt;isLoaded()) {
        <span class="enscript-keyword">if</span> (aKext-&gt;getRetainCount() &gt; kOSKextMinLoadedRetainCount) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        <span class="enscript-keyword">if</span> (checkClassesFlag &amp;&amp; aKext-&gt;hasOSMetaClassInstances()) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    result = true;

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::stop</span>(<span class="enscript-type">void</span>)
{
    OSReturn result = kOSReturnError;
    kern_return_t (*stopfunc)(kmod_info_t *, <span class="enscript-type">void</span> *);
    
    <span class="enscript-keyword">if</span> (!isStarted() || isInterface()) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!isLoaded()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Attempt to stop nonloaded kext %s.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Refuse to stop if we have clients or instances. It is up to
    * the caller to make sure those aren't true.
    */</span>
    <span class="enscript-keyword">if</span> (getRetainCount() &gt; kOSKextMinLoadedRetainCount) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s - C++ instances; can't stop.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnInUse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (getRetainCount() &gt; kOSKextMinLoadedRetainCount) {

        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s - has references (linkage or tracking object); &quot;</span>
            <span class="enscript-string">&quot;can't stop.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnInUse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Note: If validateKextMapping fails on the stop &amp; unload path,
    * we are in serious trouble and a kernel panic is likely whether
    * we stop &amp; unload the kext or not.
    */</span>
    result = validateKextMapping(<span class="enscript-comment">/* start? */</span> false);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    stopfunc = kmod_info-&gt;stop;
    <span class="enscript-keyword">if</span> (stopfunc) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogDetailLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s calling module stop function.&quot;</span>,
            getIdentifierCString()); 

        flags.stopping = 1;

        result = stopfunc(kmod_info, <span class="enscript-comment">/* userData */</span> NULL);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_STATIC_CPPINIT</span>
        <span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
            result = OSRuntimeFinalizeCPP(kmod_info, NULL);
        }
#<span class="enscript-reference">endif</span>

        flags.stopping = 0;

        <span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
            flags.started = 0;

            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogDetailLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s is now stopped and ready to unload.&quot;</span>,
                getIdentifierCString()); 
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s did not stop (return code 0x%x).&quot;</span>,
                getIdentifierCString(), result); 
            result = kOSKextReturnStartStopError;
        }
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::unload</span>(<span class="enscript-type">void</span>)
{
    OSReturn        result = kOSReturnError;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    index;
    uint32_t        num_kmod_refs = 0;
    OSKextAccount * freeAccount;

    <span class="enscript-keyword">if</span> (!sUnloadEnabled) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext unloading is disabled (%s).&quot;</span>,
            <span class="enscript-keyword">this</span>-&gt;getIdentifierCString());

        result = kOSKextReturnDisabled;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Refuse to unload if we have clients or instances. It is up to
    * the caller to make sure those aren't true.
    */</span>
    <span class="enscript-keyword">if</span> (getRetainCount() &gt; kOSKextMinLoadedRetainCount) {
        <span class="enscript-comment">// xxx - Don't log under errors? this is more of an info thing
</span>        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Can't unload kext %s; outstanding references (linkage or tracking object).&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnInUse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (hasOSMetaClassInstances()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Can't unload kext %s; classes have instances:&quot;</span>,
            getIdentifierCString());
        reportOSMetaClassInstances(kOSKextLogErrorLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag);
        result = kOSKextReturnInUse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!isLoaded()) {
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (isKernelComponent()) {
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
   <span class="enscript-comment">/* Note that the kext is unloading before running any code that
    * might be in the kext (request callbacks, module stop function).
    * We will deny certain requests made against a kext in the process
    * of unloading.
    */</span>
    flags.unloading = 1;

   <span class="enscript-comment">/* Update the string describing the last kext to unload in case we panic.
    */</span>
    savePanicString(<span class="enscript-comment">/* isLoading */</span> false);
    
    <span class="enscript-keyword">if</span> (isStarted()) {
        result = stop();
        <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s can't unload - module stop returned 0x%x.&quot;</span>,
                getIdentifierCString(), (<span class="enscript-type">unsigned</span>)result);
            result = kOSKextReturnStartStopError;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogProgressLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Kext %s unloading.&quot;</span>,
        getIdentifierCString());

    {
        <span class="enscript-type">struct</span> list_head *p;
        <span class="enscript-type">struct</span> list_head *prev;
        <span class="enscript-type">struct</span> list_head *next;
        <span class="enscript-keyword">for</span> (p = pendingPgoHead.next; p != &amp;pendingPgoHead; p = next) {
            OSKextGrabPgoStruct *s = container_of(p, OSKextGrabPgoStruct, list_head);
            s-&gt;err = OSKextGrabPgoDataLocked(<span class="enscript-keyword">this</span>, s-&gt;metadata, instance_uuid, s-&gt;pSize, s-&gt;pBuffer, s-&gt;bufferSize);
            prev = p-&gt;prev;
            next = p-&gt;next;
            prev-&gt;next = next;
            next-&gt;prev = prev;
            p-&gt;prev = p;
            p-&gt;next = p;
            IORecursiveLockWakeup(sKextLock, s, false);
        }
    }


   <span class="enscript-comment">/* Even if we don't call the stop function, we want to be sure we
    * have no OSMetaClass references before unloading the kext executable
    * from memory. OSMetaClasses may have pointers into the kext executable
    * and that would cause a panic on OSKext::free() when metaClasses is freed.
    */</span>
    <span class="enscript-keyword">if</span> (metaClasses) {
        metaClasses-&gt;flushCollection();
    }

   <span class="enscript-comment">/* Remove the kext from the list of loaded kexts, patch the gap
    * in the kmod_info_t linked list, and reset &quot;kmod&quot; to point to the
    * last loaded kext that isn't the fake kernel kext (sKernelKext).
    */</span>
    index = sLoadedKexts-&gt;getNextIndexOfObject(<span class="enscript-keyword">this</span>, 0);
    <span class="enscript-keyword">if</span> (index != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1) {

        sLoadedKexts-&gt;removeObject(index);

        OSKext * nextKext = OSDynamicCast(OSKext,
            sLoadedKexts-&gt;getObject(index));

        <span class="enscript-keyword">if</span> (nextKext) {
            <span class="enscript-keyword">if</span> (index &gt; 0) {
                OSKext * gapKext = OSDynamicCast(OSKext,
                    sLoadedKexts-&gt;getObject(index - 1));
                
                nextKext-&gt;kmod_info-&gt;next = gapKext-&gt;kmod_info;

            } <span class="enscript-keyword">else</span> <span class="enscript-comment">/* index == 0 */</span> {
                nextKext-&gt;kmod_info-&gt;next = NULL;
            }
        }

        OSKext * lastKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getLastObject());
        <span class="enscript-keyword">if</span> (lastKext &amp;&amp; !lastKext-&gt;isKernel()) {
            kmod = lastKext-&gt;kmod_info;
        } <span class="enscript-keyword">else</span> {
            kmod = NULL;  <span class="enscript-comment">// clear the global kmod variable
</span>        }
    }

   <span class="enscript-comment">/* Clear out the kmod references that we're keeping for compatibility
    * with current panic backtrace code &amp; kgmacros.
    * xxx - will want to update those bits sometime and remove this.
    */</span>
    num_kmod_refs = getNumDependencies();
    <span class="enscript-keyword">if</span> (num_kmod_refs &amp;&amp; kmod_info &amp;&amp; kmod_info-&gt;reference_list) {
        <span class="enscript-keyword">for</span> (uint32_t refIndex = 0; refIndex &lt; num_kmod_refs; refIndex++) {
            kmod_reference_t * ref = &amp;(kmod_info-&gt;reference_list[refIndex]);
            ref-&gt;info-&gt;reference_count--;
        }
        kfree(kmod_info-&gt;reference_list,
            num_kmod_refs * <span class="enscript-keyword">sizeof</span>(kmod_reference_t));
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
    unregisterWithDTrace();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

    notifyKextUnloadObservers(<span class="enscript-keyword">this</span>);

    freeAccount = NULL;
    IOSimpleLockLock(sKextAccountsLock);
    <span class="enscript-keyword">if</span> (account-&gt;site.tag) account-&gt;site.flags |= VM_TAG_UNLOAD;
    <span class="enscript-keyword">else</span>                   freeAccount = account;
    IOSimpleLockUnlock(sKextAccountsLock);
    <span class="enscript-keyword">if</span> (freeAccount) IODelete(freeAccount, OSKextAccount, 1);

    <span class="enscript-comment">/* Unwire and free the linked executable.
     */</span>
    <span class="enscript-keyword">if</span> (linkedExecutable) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_MAPPED_KEXTS</span>
        <span class="enscript-keyword">if</span> (!isInterface()) {
            kernel_segment_command_t *seg = NULL;
            vm_map_t kext_map = kext_get_vm_map(kmod_info);

            <span class="enscript-keyword">if</span> (!kext_map) {
                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogErrorLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Failed to free kext %s; couldn't find the kext map.&quot;</span>,
                    getIdentifierCString());
                result = kOSKextReturnInternalError;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogProgressLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s unwiring and unmapping linked executable.&quot;</span>,
                getIdentifierCString());

            seg = firstsegfromheader((kernel_mach_header_t *)kmod_info-&gt;address);
            <span class="enscript-keyword">while</span> (seg) {
                <span class="enscript-keyword">if</span> (segmentShouldBeWired(seg)) {
                    result = vm_map_unwire(kext_map, seg-&gt;vmaddr, 
                        seg-&gt;vmaddr + seg-&gt;vmsize, FALSE);
                    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
                        OSKextLog(<span class="enscript-keyword">this</span>,
                            kOSKextLogErrorLevel |
                            kOSKextLogLoadFlag,
                            <span class="enscript-string">&quot;Failed to unwire kext %s.&quot;</span>,
                            getIdentifierCString());
                        result = kOSKextReturnInternalError;
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                    }
                }

                seg = nextsegfromheader((kernel_mach_header_t *) kmod_info-&gt;address, seg);
            }
        }
#<span class="enscript-reference">endif</span>
        OSSafeReleaseNULL(linkedExecutable);
    }

   <span class="enscript-comment">/* An interface kext has a fake kmod_info that was allocated,
    * so we have to free it.
    */</span>
    <span class="enscript-keyword">if</span> (isInterface()) {
        kfree(kmod_info, <span class="enscript-keyword">sizeof</span>(kmod_info_t));
    }

    kmod_info = NULL;

    flags.loaded = false;
    flushDependencies();

    <span class="enscript-comment">/* save a copy of the bundle ID for us to check when deciding to 
     * rebuild the kernel cache file.  If a kext was already in the kernel 
     * cache and unloaded then later loaded we do not need to rebuild the 
     * kernel cache.  9055303
     */</span>
    <span class="enscript-keyword">if</span> (isPrelinked()) {
        <span class="enscript-keyword">if</span> (!_OSKextInUnloadedPrelinkedKexts(bundleID)) {
            IORecursiveLockLock(sKextLock);
            <span class="enscript-keyword">if</span> (sUnloadedPrelinkedKexts) {
                sUnloadedPrelinkedKexts-&gt;setObject(bundleID);
            }
            IORecursiveLockUnlock(sKextLock);
        }
    }

    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogProgressLevel | kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Kext %s unloaded.&quot;</span>, getIdentifierCString());

    queueKextNotification(kKextRequestPredicateUnloadNotification,
        OSDynamicCast(OSString, bundleID));

<span class="enscript-reference">finish</span>:
    <span class="enscript-reference">OSKext</span>::saveLoadedKextPanicList();
    <span class="enscript-reference">OSKext</span>::updateLoadedKextSummaries();

    flags.unloading = 0;
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::queueKextNotification</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * notificationName,
    OSString   * kextIdentifier)
{
    OSReturn          result               = kOSReturnError;
    OSDictionary    * loadRequest          = NULL;  <span class="enscript-comment">// must release
</span>
    <span class="enscript-keyword">if</span> (!kextIdentifier) {
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Create a new request unless one is already sitting
    * in sKernelRequests for this bundle identifier
    */</span>
    result = _OSKextCreateRequest(notificationName, &amp;loadRequest);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (!_OSKextSetRequestArgument(loadRequest,
        kKextRequestArgumentBundleIdentifierKey, kextIdentifier)) {
        
        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (!sKernelRequests-&gt;setObject(loadRequest)) {
        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* We might want to only queue the notification if kextd is active,
    * but that wouldn't work for embedded. Note that we don't care if
    * the ping immediately succeeds here so don't do anything with the
    * result of this call.
    */</span>
    <span class="enscript-reference">OSKext</span>::pingKextd();

    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    OSSafeRelease(loadRequest);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_OSKextConsiderDestroyingLinkContext</span>(
    __unused thread_call_param_t p0,
    __unused thread_call_param_t p1)
{
   <span class="enscript-comment">/* Take multiple locks in the correct order.
    */</span>
    IORecursiveLockLock(sKextLock);
    IORecursiveLockLock(sKextInnerLock);

   <span class="enscript-comment">/* The first time we destroy the kxldContext is in the first 
    * OSKext::considerUnloads() call, which sets sConsiderUnloadsCalled
    * before calling this function. Thereafter any call to this function
    * will actually destroy the context.
    */</span>
    <span class="enscript-keyword">if</span> (sConsiderUnloadsCalled &amp;&amp; sKxldContext) {
        kxld_destroy_context(sKxldContext);
        sKxldContext = NULL;
    }

   <span class="enscript-comment">/* Free the thread_call that was allocated to execute this function.
    */</span>
    <span class="enscript-keyword">if</span> (sDestroyLinkContextThread) {
        <span class="enscript-keyword">if</span> (!thread_call_free(sDestroyLinkContextThread)) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogGeneralFlag,
                <span class="enscript-string">&quot;thread_call_free() failed for kext link context.&quot;</span>);
        }
        sDestroyLinkContextThread = 0;
    }

    IORecursiveLockUnlock(sKextInnerLock);
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Destroying the kxldContext requires checking variables under both
* sKextInnerLock and sKextLock, so we do it on a separate thread
* to avoid deadlocks with IOService, with which OSKext has a reciprocal
* call relationship.
*
* This function must be invoked with sKextInnerLock held.
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::considerDestroyingLinkContext</span>(<span class="enscript-type">void</span>)
{
    IORecursiveLockLock(sKextInnerLock);

   <span class="enscript-comment">/* If we have already queued a thread to destroy the link context,
    * don't bother resetting; that thread will take care of it.
    */</span>
    <span class="enscript-keyword">if</span> (sDestroyLinkContextThread) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* The function to be invoked in the thread will deallocate
    * this thread_call, so don't share it around.
    */</span>
    sDestroyLinkContextThread = thread_call_allocate(
        &amp;_OSKextConsiderDestroyingLinkContext, 0);
    <span class="enscript-keyword">if</span> (!sDestroyLinkContextThread) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel | kOSKextLogGeneralFlag | kOSKextLogLinkFlag,
            <span class="enscript-string">&quot;Can't create thread to destroy kext link context.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    thread_call_enter(sDestroyLinkContextThread);

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextInnerLock);
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Autounload</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* This is a static method because the kext will be deallocated if it
* does unload!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::autounloadKext</span>(OSKext * aKext)
{
    OSReturn result = kOSKextReturnInUse;

   <span class="enscript-comment">/* Check for external references to this kext (usu. dependents),
    * instances of defined classes (or classes derived from them),
    * outstanding requests.
    */</span>
    <span class="enscript-keyword">if</span> ((aKext-&gt;getRetainCount() &gt; kOSKextMinLoadedRetainCount) ||
        !aKext-&gt;flags.autounloadEnabled ||
        aKext-&gt;isKernelComponent()) {

        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Skip a delay-autounload kext, once.
    */</span>
    <span class="enscript-keyword">if</span> (aKext-&gt;flags.delayAutounload) {
        OSKextLog(aKext,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag | kOSKextLogKextBookkeepingFlag,
            <span class="enscript-string">&quot;Kext %s has delayed autounload set; skipping and clearing flag.&quot;</span>,
            aKext-&gt;getIdentifierCString());
        aKext-&gt;flags.delayAutounload = 0;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (aKext-&gt;hasOSMetaClassInstances() ||
        aKext-&gt;countRequestCallbacks()) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = OSKext::removeKext(aKext);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}
    
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_OSKextConsiderUnloads</span>(
    __unused thread_call_param_t p0,
    __unused thread_call_param_t p1)
{
    <span class="enscript-type">bool</span>         didUnload = false;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count, i;

   <span class="enscript-comment">/* Take multiple locks in the correct order
    * (note also sKextSummaries lock further down).
    */</span>
    IORecursiveLockLock(sKextLock);
    IORecursiveLockLock(sKextInnerLock);

    <span class="enscript-reference">OSKext</span>::flushNonloadedKexts(<span class="enscript-comment">/* flushPrelinkedKexts */</span> true);
    
   <span class="enscript-comment">/* If the system is powering down, don't try to unload anything.
    */</span>
    <span class="enscript-keyword">if</span> (sSystemSleep) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogProgressLevel | kOSKextLogLoadFlag,
              <span class="enscript-string">&quot;Checking for unused kexts to autounload.&quot;</span>);

   <span class="enscript-comment">/*****
    * Remove any request callbacks marked as stale,
    * and mark as stale any currently in flight.
    */</span>
    count = sRequestCallbackRecords-&gt;getCount();
    <span class="enscript-keyword">if</span> (count) {
        i = count - 1;
        <span class="enscript-keyword">do</span> {
            OSDictionary * callbackRecord = OSDynamicCast(OSDictionary,
                sRequestCallbackRecords-&gt;getObject(i));
            OSBoolean * stale = OSDynamicCast(OSBoolean,
                callbackRecord-&gt;getObject(kKextRequestStaleKey));
            
            <span class="enscript-keyword">if</span> (stale == kOSBooleanTrue) {
                <span class="enscript-reference">OSKext</span>::invokeRequestCallback(callbackRecord,
                    kOSKextReturnTimeout);
            } <span class="enscript-keyword">else</span> {
                callbackRecord-&gt;setObject(kKextRequestStaleKey,
                    kOSBooleanTrue);
            }
        } <span class="enscript-keyword">while</span> (i--);
    }

   <span class="enscript-comment">/*****
    * Make multiple passes through the array of loaded kexts until
    * we don't unload any. This handles unwinding of dependency
    * chains. We have to go *backwards* through the array because
    * kexts are removed from it when unloaded, and we cannot make
    * a copy or we'll mess up the retain counts we rely on to
    * check whether a kext will unload. If only we could have
    * nonretaining collections like CF has....
    */</span>
    <span class="enscript-keyword">do</span> {
        didUnload = false;
        
        count = sLoadedKexts-&gt;getCount();
        <span class="enscript-keyword">if</span> (count) {
            i = count - 1;
            <span class="enscript-keyword">do</span> {
                OSKext * thisKext = OSDynamicCast(OSKext,
                                                  sLoadedKexts-&gt;getObject(i));
                didUnload |= (kOSReturnSuccess == OSKext::autounloadKext(thisKext));
            } <span class="enscript-keyword">while</span> (i--);
        }
    } <span class="enscript-keyword">while</span> (didUnload);

<span class="enscript-reference">finish</span>:
    sConsiderUnloadsPending = false;
    sConsiderUnloadsExecuted = true;

    (<span class="enscript-type">void</span>) OSKext::considerRebuildOfPrelinkedKernel();
    
    IORecursiveLockUnlock(sKextInnerLock);
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSKext::considerUnloads</span>(Boolean rescheduleOnlyFlag)
{
    AbsoluteTime when;

    IORecursiveLockLock(sKextInnerLock);

    <span class="enscript-keyword">if</span> (!sUnloadCallout) {
        sUnloadCallout = thread_call_allocate(&amp;_OSKextConsiderUnloads, 0);
    }

    <span class="enscript-comment">/* we only reset delay value for unloading if we already have something
     * pending.  rescheduleOnlyFlag should not start the count down.
     */</span>
    <span class="enscript-keyword">if</span> (rescheduleOnlyFlag &amp;&amp; !sConsiderUnloadsPending) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    thread_call_cancel(sUnloadCallout);
    <span class="enscript-keyword">if</span> (OSKext::getAutounloadEnabled() &amp;&amp; !sSystemSleep) {
        clock_interval_to_deadline(sConsiderUnloadDelay,
            1000 * 1000 * 1000, &amp;when);

        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogProgressLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;%scheduling %sscan for unused kexts in %lu seconds.&quot;</span>,
            sConsiderUnloadsPending ? <span class="enscript-string">&quot;Res&quot;</span> : <span class="enscript-string">&quot;S&quot;</span>,
            sConsiderUnloadsCalled ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;initial &quot;</span>,
            (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)sConsiderUnloadDelay);

        sConsiderUnloadsPending = true;
        thread_call_enter_delayed(sUnloadCallout, when);
    }

<span class="enscript-reference">finish</span>:
   <span class="enscript-comment">/* The kxld context should be reused throughout boot.  We mark the end of
    * period as the first time considerUnloads() is called, and we destroy
    * the first kxld context in that function.  Afterwards, it will be
    * destroyed in flushNonloadedKexts.
    */</span>
    <span class="enscript-keyword">if</span> (!sConsiderUnloadsCalled) {
        sConsiderUnloadsCalled = true;
        <span class="enscript-reference">OSKext</span>::considerDestroyingLinkContext();
    }

    IORecursiveLockUnlock(sKextInnerLock);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

IOReturn <span class="enscript-function-name">OSKextSystemSleepOrWake</span>(UInt32 messageType)
{
    IORecursiveLockLock(sKextInnerLock);

   <span class="enscript-comment">/* If the system is going to sleep, cancel the reaper thread timer,
    * and note that we're in a sleep state in case it just fired but hasn't
    * taken the lock yet. If we are coming back from sleep, just
    * clear the sleep flag; IOService's normal operation will cause
    * unloads to be considered soon enough.
    */</span>
    <span class="enscript-keyword">if</span> (messageType == kIOMessageSystemWillSleep) {
        <span class="enscript-keyword">if</span> (sUnloadCallout) {
            thread_call_cancel(sUnloadCallout);
        }
        sSystemSleep = true;
        AbsoluteTime_to_scalar(&amp;sLastWakeTime) = 0;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (messageType == kIOMessageSystemHasPoweredOn) {
        sSystemSleep = false;
        clock_get_uptime(&amp;sLastWakeTime);
   }
    IORecursiveLockUnlock(sKextInnerLock);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

};


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Prelinked</span> <span class="enscript-variable-name">Kernel</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Do not access sConsiderUnloads... variables other than
* sConsiderUnloadsExecuted in this function. They are guarded by a
* different lock.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::considerRebuildOfPrelinkedKernel</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">static</span> <span class="enscript-type">bool</span>     requestedPrelink        = false;
    OSReturn        checkResult             = kOSReturnError;
    OSDictionary *  prelinkRequest          = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * kextIterator     = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">const</span> OSSymbol * thisID                 = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">bool</span>            doRebuild               = false;
    AbsoluteTime    my_abstime;
    UInt64          my_ns;
    SInt32          delta_secs;
    
    <span class="enscript-comment">/* Only one auto rebuild per boot and only on boot from prelinked kernel */</span>
    <span class="enscript-keyword">if</span> (requestedPrelink || !sPrelinkBoot) {
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-comment">/* no direct return from this point */</span>
    IORecursiveLockLock(sKextLock);
    
    <span class="enscript-comment">/* We need to wait for kextd to get up and running with unloads already done
     * and any new startup kexts loaded.   
     */</span>
    <span class="enscript-keyword">if</span> (!sConsiderUnloadsExecuted ||
        !sDeferredLoadSucceeded) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">/* we really only care about boot / system start up related kexts so bail 
     * if we're here after REBUILD_MAX_TIME.
     */</span>
    <span class="enscript-keyword">if</span> (!_OSKextInPrelinkRebuildWindow()) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                  kOSKextLogArchiveFlag,
                  <span class="enscript-string">&quot;%s prebuild rebuild has expired&quot;</span>,
                  __FUNCTION__);
        requestedPrelink = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">/* we do not want to trigger a rebuild if we get here too close to waking
     * up.  (see radar 10233768)
     */</span>
    IORecursiveLockLock(sKextInnerLock);
    
    clock_get_uptime(&amp;my_abstime);
    delta_secs = MINIMUM_WAKEUP_SECONDS + 1;
    <span class="enscript-keyword">if</span> (AbsoluteTime_to_scalar(&amp;sLastWakeTime) != 0) {
        SUB_ABSOLUTETIME(&amp;my_abstime, &amp;sLastWakeTime);
        absolutetime_to_nanoseconds(my_abstime, &amp;my_ns);
        delta_secs = (SInt32)(my_ns / NSEC_PER_SEC);
    }
    IORecursiveLockUnlock(sKextInnerLock);
    
    <span class="enscript-keyword">if</span> (delta_secs &lt; MINIMUM_WAKEUP_SECONDS) {
        <span class="enscript-comment">/* too close to time of last wake from sleep */</span>
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    requestedPrelink = true;
    
    <span class="enscript-comment">/* Now it's time to see if we have a reason to rebuild.  We may have done 
     * some loads and unloads but the kernel cache didn't actually change.
     * We will rebuild if any kext is not marked prelinked AND is not in our
     * list of prelinked kexts that got unloaded.  (see radar 9055303)
     */</span>
    kextIterator = OSCollectionIterator::withCollection(sKextsByID);
    <span class="enscript-keyword">if</span> (!kextIterator) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">while</span> ((thisID = OSDynamicCast(OSSymbol, kextIterator-&gt;getNextObject()))) {
        OSKext *    thisKext;  <span class="enscript-comment">// do not release
</span>        
        thisKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(thisID));
        <span class="enscript-keyword">if</span> (!thisKext || thisKext-&gt;isPrelinked() || thisKext-&gt;isKernel()) {
            <span class="enscript-keyword">continue</span>;
        }
        
        <span class="enscript-keyword">if</span> (_OSKextInUnloadedPrelinkedKexts(thisKext-&gt;bundleID)) {
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-comment">/* kext is loaded and was not in current kernel cache so let's rebuild
         */</span>
        doRebuild = true;
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                  kOSKextLogArchiveFlag,
                  <span class="enscript-string">&quot;considerRebuildOfPrelinkedKernel %s triggered rebuild&quot;</span>,
                  thisKext-&gt;bundleID-&gt;getCStringNoCopy());
        <span class="enscript-keyword">break</span>;
    }
    sUnloadedPrelinkedKexts-&gt;flushCollection();
    
    <span class="enscript-keyword">if</span> (!doRebuild) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    checkResult = _OSKextCreateRequest(kKextRequestPredicateRequestPrelink,
                                       &amp;prelinkRequest);
    <span class="enscript-keyword">if</span> (checkResult != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">if</span> (!sKernelRequests-&gt;setObject(prelinkRequest)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-reference">OSKext</span>::pingKextd();
    
<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);
    OSSafeRelease(prelinkRequest);
    OSSafeRelease(kextIterator);
    
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Dependencies</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::resolveDependencies</span>(
    OSArray * loopStack)
{
    <span class="enscript-type">bool</span>                   result                   = false;
    OSArray              * localLoopStack           = NULL;   <span class="enscript-comment">// must release
</span>    <span class="enscript-type">bool</span>                   addedToLoopStack         = false;
    OSDictionary         * libraries                = NULL;   <span class="enscript-comment">// do not release
</span>    OSCollectionIterator * libraryIterator          = NULL;   <span class="enscript-comment">// must release
</span>    OSString             * libraryID                = NULL;   <span class="enscript-comment">// do not release
</span>    OSString             * infoString               = NULL;   <span class="enscript-comment">// do not release
</span>    OSString             * readableString           = NULL;   <span class="enscript-comment">// do not release
</span>    OSKext               * libraryKext              = NULL;   <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">bool</span>                   hasRawKernelDependency   = false;
    <span class="enscript-type">bool</span>                   hasKernelDependency      = false;
    <span class="enscript-type">bool</span>                   hasKPIDependency         = false;
    <span class="enscript-type">bool</span>                   hasPrivateKPIDependency  = false;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>           count;

   <span class="enscript-comment">/* A kernel component will automatically have this flag set,
    * and a loaded kext should also have it set (as should all its
    * loaded dependencies).
    */</span>
    <span class="enscript-keyword">if</span> (flags.hasAllDependencies) {
        result = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Check for loops in the dependency graph.
    */</span>
    <span class="enscript-keyword">if</span> (loopStack) {
        <span class="enscript-keyword">if</span> (loopStack-&gt;getNextIndexOfObject(<span class="enscript-keyword">this</span>, 0) != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s has a dependency loop; can't resolve dependencies.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    } <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s resolving dependencies.&quot;</span>,
            getIdentifierCString());

        loopStack = OSArray::withCapacity(6);  <span class="enscript-comment">// any small capacity will do
</span>        <span class="enscript-keyword">if</span> (!loopStack) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s can't create bookkeeping stack to resolve dependencies.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        localLoopStack = loopStack;
    }
    <span class="enscript-keyword">if</span> (!loopStack-&gt;setObject(<span class="enscript-keyword">this</span>)) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s - internal error resolving dependencies.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    addedToLoopStack = true;

   <span class="enscript-comment">/* Purge any existing kexts in the dependency list and start over.
    */</span>
    flushDependencies();
    <span class="enscript-keyword">if</span> (dependencies) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s - internal error resolving dependencies.&quot;</span>,
            getIdentifierCString());
    }

    libraries = OSDynamicCast(OSDictionary,
        getPropertyForHostArch(kOSBundleLibrariesKey));
    <span class="enscript-keyword">if</span> (libraries == NULL || libraries-&gt;getCount() == 0) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag | kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s - can't resolve dependencies; %s missing/invalid type.&quot;</span>,
            getIdentifierCString(), kOSBundleLibrariesKey);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Make a new array to hold the dependencies (flush freed the old one).
    */</span>
    dependencies = OSArray::withCapacity(libraries-&gt;getCount());
    <span class="enscript-keyword">if</span> (!dependencies) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s - can't allocate dependencies array.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">// xxx - compat: We used to add an implicit dependency on kernel 6.0
</span>    <span class="enscript-comment">// xxx - compat: if none were declared.
</span>
    libraryIterator = OSCollectionIterator::withCollection(libraries);
    <span class="enscript-keyword">if</span> (!libraryIterator) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s - can't allocate dependencies iterator.&quot;</span>,
            getIdentifierCString());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">while</span> ((libraryID = OSDynamicCast(OSString,
           libraryIterator-&gt;getNextObject()))) {
           
       <span class="enscript-type">const</span> <span class="enscript-type">char</span> * library_id = libraryID-&gt;getCStringNoCopy();

        OSString * libraryVersion = OSDynamicCast(OSString,
            libraries-&gt;getObject(libraryID));
        <span class="enscript-keyword">if</span> (libraryVersion == NULL) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogValidationFlag | kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s - illegal type in OSBundleLibraries.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
        OSKextVersion libraryVers =
            OSKextParseVersionString(libraryVersion-&gt;getCStringNoCopy());
        <span class="enscript-keyword">if</span> (libraryVers == -1) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogValidationFlag | kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s - invalid library version %s.&quot;</span>,
                getIdentifierCString(),
                libraryVersion-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        libraryKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(libraryID));
        <span class="enscript-keyword">if</span> (libraryKext == NULL) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s - library kext %s not found.&quot;</span>,
                getIdentifierCString(), library_id);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
        <span class="enscript-keyword">if</span> (!libraryKext-&gt;isCompatibleWithVersion(libraryVers)) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s - library kext %s not compatible &quot;</span>
                <span class="enscript-string">&quot;with requested version %s.&quot;</span>,
                getIdentifierCString(), library_id,
                libraryVersion-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* If a nonprelinked library somehow got into the mix for a
        * prelinked kext, at any point in the chain, we must fail
        * because the prelinked relocs for the library will be all wrong.
        */</span>
        <span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span>-&gt;isPrelinked() &amp;&amp;
            libraryKext-&gt;declaresExecutable() &amp;&amp;
            !libraryKext-&gt;isPrelinked()) {

            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s (prelinked) - library kext %s (v%s) not prelinked.&quot;</span>,
                getIdentifierCString(), library_id,
                libraryVersion-&gt;getCStringNoCopy());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">if</span> (!libraryKext-&gt;resolveDependencies(loopStack)) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* Add the library directly only if it has an executable to link.
        * Otherwise it's just used to collect other dependencies, so put
        * *its* dependencies on the list for this kext.
        */</span>
        <span class="enscript-comment">// xxx - We are losing info here; would like to make fake entries or
</span>        <span class="enscript-comment">// xxx - keep these in the dependency graph for loaded kexts.
</span>        <span class="enscript-comment">// xxx - I really want to make kernel components not a special case!
</span>        <span class="enscript-keyword">if</span> (libraryKext-&gt;declaresExecutable() ||
            libraryKext-&gt;isInterface()) {

            <span class="enscript-keyword">if</span> (dependencies-&gt;getNextIndexOfObject(libraryKext, 0) == (<span class="enscript-type">unsigned</span>)-1) {
                dependencies-&gt;setObject(libraryKext);

                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogDetailLevel |
                    kOSKextLogDependenciesFlag,
                    <span class="enscript-string">&quot;Kext %s added dependency %s.&quot;</span>,
                    getIdentifierCString(),
                    libraryKext-&gt;getIdentifierCString());
            }
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-type">int</span>       numLibDependencies  = libraryKext-&gt;getNumDependencies();
            OSArray * libraryDependencies = libraryKext-&gt;getDependencies();
            <span class="enscript-type">int</span>       index;

            <span class="enscript-keyword">if</span> (numLibDependencies) {
                <span class="enscript-comment">// xxx - this msg level should be 1 lower than the per-kext one
</span>                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogDetailLevel |
                    kOSKextLogDependenciesFlag,
                    <span class="enscript-string">&quot;Kext %s pulling %d dependencies from codeless library %s.&quot;</span>,
                    getIdentifierCString(),
                    numLibDependencies,
                    libraryKext-&gt;getIdentifierCString());
            }
            <span class="enscript-keyword">for</span> (index = 0; index &lt; numLibDependencies; index++) {
                OSKext * thisLibDependency = OSDynamicCast(OSKext,
                    libraryDependencies-&gt;getObject(index));
                <span class="enscript-keyword">if</span> (dependencies-&gt;getNextIndexOfObject(thisLibDependency, 0) == (<span class="enscript-type">unsigned</span>)-1) {
                    dependencies-&gt;setObject(thisLibDependency);
                    OSKextLog(<span class="enscript-keyword">this</span>,
                        kOSKextLogDetailLevel |
                        kOSKextLogDependenciesFlag,
                        <span class="enscript-string">&quot;Kext %s added dependency %s from codeless library %s.&quot;</span>,
                        getIdentifierCString(),
                        thisLibDependency-&gt;getIdentifierCString(),
                        libraryKext-&gt;getIdentifierCString());
                }
            }
        }

        <span class="enscript-keyword">if</span> ((strlen(library_id) == strlen(KERNEL_LIB)) &amp;&amp;
            0 == strncmp(library_id, KERNEL_LIB, <span class="enscript-keyword">sizeof</span>(KERNEL_LIB)-1)) {

            hasRawKernelDependency = true;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STRING_HAS_PREFIX(library_id, KERNEL_LIB_PREFIX)) {
            hasKernelDependency = true;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STRING_HAS_PREFIX(library_id, KPI_LIB_PREFIX)) {
            hasKPIDependency = true;
            <span class="enscript-keyword">if</span> (!strncmp(library_id, PRIVATE_KPI, <span class="enscript-keyword">sizeof</span>(PRIVATE_KPI)-1)) {
                hasPrivateKPIDependency = true;
            }
        }
    }
    
    <span class="enscript-keyword">if</span> (hasRawKernelDependency) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag | kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Error - kext %s declares a dependency on %s, which is not permitted.&quot;</span>,
            getIdentifierCString(), KERNEL_LIB);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">if</span> (hasKernelDependency) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogValidationFlag | kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Error - kext %s declares %s dependencies. &quot;</span>
            <span class="enscript-string">&quot;Only %s* dependencies are supported for 64-bit kexts.&quot;</span>,
            getIdentifierCString(), KERNEL_LIB, KPI_LIB_PREFIX);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (!hasKPIDependency) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogWarningLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Warning - kext %s declares no %s* dependencies. &quot;</span>
            <span class="enscript-string">&quot;If it uses any KPIs, the link may fail with undefined symbols.&quot;</span>,
            getIdentifierCString(), KPI_LIB_PREFIX);
    }
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* __LP64__ */</span>
    <span class="enscript-comment">// xxx - will change to flatly disallow &quot;kernel&quot; dependencies at some point
</span>    <span class="enscript-comment">// xxx - is it invalid to do both &quot;com.apple.kernel&quot; and any
</span>    <span class="enscript-comment">// xxx - &quot;com.apple.kernel.*&quot;?
</span>
    <span class="enscript-keyword">if</span> (hasKernelDependency &amp;&amp; hasKPIDependency) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogWarningLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Warning - kext %s has immediate dependencies on both &quot;</span>
            <span class="enscript-string">&quot;%s* and %s* components; use only one style.&quot;</span>,
            getIdentifierCString(), KERNEL_LIB, KPI_LIB_PREFIX);
    }

    <span class="enscript-keyword">if</span> (!hasKernelDependency &amp;&amp; !hasKPIDependency) {
        <span class="enscript-comment">// xxx - do we want to use validation flag for these too?
</span>        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogWarningLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Warning - %s declares no kernel dependencies; using %s.&quot;</span>,
            getIdentifierCString(), KERNEL6_LIB);
        OSKext * kernelKext = OSDynamicCast(OSKext,
            sKextsByID-&gt;getObject(KERNEL6_LIB));
        <span class="enscript-keyword">if</span> (kernelKext) {
            dependencies-&gt;setObject(kernelKext);
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Error - Library %s not found for %s.&quot;</span>,
                KERNEL6_LIB, getIdentifierCString());
        }
    }

   <span class="enscript-comment">/* If the kext doesn't have a raw kernel or KPI dependency, then add all of
    * its indirect dependencies to simulate old-style linking.  XXX - Should
    * check for duplicates.
    */</span>
    <span class="enscript-keyword">if</span> (!hasKPIDependency) {
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

        flags.hasBleedthrough = true;

        count = getNumDependencies();
        
       <span class="enscript-comment">/* We add to the dependencies array in this loop, but do not iterate
        * past its original count.
        */</span>
        <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
            OSKext * dependencyKext = OSDynamicCast(OSKext,
                dependencies-&gt;getObject(i));
            dependencyKext-&gt;addBleedthroughDependencies(dependencies);
        }
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>

    <span class="enscript-keyword">if</span> (hasPrivateKPIDependency) {
        <span class="enscript-type">bool</span> hasApplePrefix = false;
        <span class="enscript-type">bool</span> infoCopyrightIsValid = false;
        <span class="enscript-type">bool</span> readableCopyrightIsValid = false;
        
        hasApplePrefix = STRING_HAS_PREFIX(getIdentifierCString(), 
            APPLE_KEXT_PREFIX);

        infoString = OSDynamicCast(OSString,  
            getPropertyForHostArch(<span class="enscript-string">&quot;CFBundleGetInfoString&quot;</span>));
        <span class="enscript-keyword">if</span> (infoString) {
            infoCopyrightIsValid = 
                kxld_validate_copyright_string(infoString-&gt;getCStringNoCopy());
        }

        readableString = OSDynamicCast(OSString,
            getPropertyForHostArch(<span class="enscript-string">&quot;NSHumanReadableCopyright&quot;</span>));
        <span class="enscript-keyword">if</span> (readableString) {
            readableCopyrightIsValid = 
                kxld_validate_copyright_string(readableString-&gt;getCStringNoCopy());
        }

        <span class="enscript-keyword">if</span> (!hasApplePrefix || (!infoCopyrightIsValid &amp;&amp; !readableCopyrightIsValid)) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Error - kext %s declares a dependency on %s. &quot;</span>
                  <span class="enscript-string">&quot;Only Apple kexts may declare a dependency on %s.&quot;</span>,
                  getIdentifierCString(), PRIVATE_KPI, PRIVATE_KPI);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    result = true;
    flags.hasAllDependencies = 1;

<span class="enscript-reference">finish</span>:

    <span class="enscript-keyword">if</span> (addedToLoopStack) {
        count = loopStack-&gt;getCount();
        <span class="enscript-keyword">if</span> (count &gt; 0 &amp;&amp; (<span class="enscript-keyword">this</span> == loopStack-&gt;getObject(count - 1))) {
            loopStack-&gt;removeObject(count - 1);            
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s - internal error resolving dependencies.&quot;</span>,
                getIdentifierCString());
        }
    }
    
    <span class="enscript-keyword">if</span> (result &amp;&amp; localLoopStack) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogDependenciesFlag,
            <span class="enscript-string">&quot;Kext %s successfully resolved dependencies.&quot;</span>,
            getIdentifierCString());
    }

    OSSafeRelease(localLoopStack);
    OSSafeRelease(libraryIterator);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::addBleedthroughDependencies</span>(OSArray * anArray)
{
    <span class="enscript-type">bool</span> result = false;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dependencyIndex, dependencyCount;
    
    dependencyCount = getNumDependencies();

    <span class="enscript-keyword">for</span> (dependencyIndex = 0;
         dependencyIndex &lt; dependencyCount;
         dependencyIndex++) {

        OSKext * dependency = OSDynamicCast(OSKext,
            dependencies-&gt;getObject(dependencyIndex));
        <span class="enscript-keyword">if</span> (!dependency) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogErrorLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s - internal error propagating compatibility dependencies.&quot;</span>,
                getIdentifierCString());
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        <span class="enscript-keyword">if</span> (anArray-&gt;getNextIndexOfObject(dependency, 0) == (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1) {
            anArray-&gt;setObject(dependency);
        }
        dependency-&gt;addBleedthroughDependencies(anArray);
    }

    result = true;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::flushDependencies</span>(<span class="enscript-type">bool</span> forceFlag)
{
    <span class="enscript-type">bool</span> result = false;

   <span class="enscript-comment">/* Only clear the dependencies if the kext isn't loaded;
    * we need the info for loaded kexts to track references.
    */</span>
    <span class="enscript-keyword">if</span> (!isLoaded() || forceFlag) {
        <span class="enscript-keyword">if</span> (dependencies) {
            <span class="enscript-comment">// xxx - check level
</span>            OSKextLog(<span class="enscript-keyword">this</span>,
                kOSKextLogProgressLevel |
                kOSKextLogDependenciesFlag,
                <span class="enscript-string">&quot;Kext %s flushing dependencies.&quot;</span>,
                getIdentifierCString());
            OSSafeReleaseNULL(dependencies);

        }
        <span class="enscript-keyword">if</span> (!isKernelComponent()) {
            flags.hasAllDependencies = 0;
        }
        result = true;
    }

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
uint32_t
<span class="enscript-function-name">OSKext::getNumDependencies</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (!dependencies) {
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">return</span> dependencies-&gt;getCount();
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSArray *
<span class="enscript-function-name">OSKext::getDependencies</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> dependencies;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">OSMetaClass</span> <span class="enscript-variable-name">Support</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::addClass</span>(
    OSMetaClass * aClass,
    uint32_t      numClasses)
{
    OSReturn result = kOSMetaClassNoInsKModSet;

    <span class="enscript-keyword">if</span> (!metaClasses) {
        metaClasses = OSSet::withCapacity(numClasses);
        <span class="enscript-keyword">if</span> (!metaClasses) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    <span class="enscript-keyword">if</span> (metaClasses-&gt;containsObject(aClass)) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogWarningLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Notice - kext %s has already registered class %s.&quot;</span>,
            getIdentifierCString(),
            aClass-&gt;getClassName());
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!metaClasses-&gt;setObject(aClass)) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    } <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogDetailLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s registered class %s.&quot;</span>,
            getIdentifierCString(),
            aClass-&gt;getClassName());
    }

    <span class="enscript-keyword">if</span> (!flags.autounloadEnabled) {
        <span class="enscript-type">const</span> OSMetaClass * metaScan  = NULL;  <span class="enscript-comment">// do not release
</span>
        <span class="enscript-keyword">for</span> (metaScan = aClass; metaScan; metaScan = metaScan-&gt;getSuperClass()) {
            <span class="enscript-keyword">if</span> (metaScan == OSTypeID(IOService)) {

                OSKextLog(<span class="enscript-keyword">this</span>,
                    kOSKextLogProgressLevel |
                    kOSKextLogLoadFlag,
                    <span class="enscript-string">&quot;Kext %s has IOService subclass %s; enabling autounload.&quot;</span>,
                    getIdentifierCString(),
                    aClass-&gt;getClassName());

                flags.autounloadEnabled = 1;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    notifyAddClassObservers(<span class="enscript-keyword">this</span>, aClass, flags);

    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s failed to register class %s.&quot;</span>,
            getIdentifierCString(),
            aClass-&gt;getClassName());
    }

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::removeClass</span>(
    OSMetaClass * aClass)
{
    OSReturn result = kOSMetaClassNoKModSet;

    <span class="enscript-keyword">if</span> (!metaClasses) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!metaClasses-&gt;containsObject(aClass)) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogWarningLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Notice - kext %s asked to unregister unknown class %s.&quot;</span>,
            getIdentifierCString(),
            aClass-&gt;getClassName());
        result = kOSReturnSuccess;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogDetailLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Kext %s unregistering class %s.&quot;</span>,
        getIdentifierCString(),
        aClass-&gt;getClassName());

    metaClasses-&gt;removeObject(aClass);
    
    notifyRemoveClassObservers(<span class="enscript-keyword">this</span>, aClass, flags);

    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Failed to unregister kext %s class %s.&quot;</span>,
            getIdentifierCString(),
            aClass-&gt;getClassName());
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSSet *
<span class="enscript-function-name">OSKext::getMetaClasses</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> metaClasses;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">OSKext::hasOSMetaClassInstances</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span>                   result        = false;
    OSCollectionIterator * classIterator = NULL;  <span class="enscript-comment">// must release
</span>    OSMetaClass          * checkClass    = NULL;  <span class="enscript-comment">// do not release
</span>
    <span class="enscript-keyword">if</span> (!metaClasses) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    classIterator = OSCollectionIterator::withCollection(metaClasses);
    <span class="enscript-keyword">if</span> (!classIterator) {
        <span class="enscript-comment">// xxx - log alloc failure?
</span>        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">while</span> ((checkClass = (OSMetaClass *)classIterator-&gt;getNextObject())) {
        <span class="enscript-keyword">if</span> (checkClass-&gt;getInstanceCount()) {
            result = true;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

<span class="enscript-reference">finish</span>:
    
    OSSafeRelease(classIterator);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::reportOSMetaClassInstances</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>     * kextIdentifier,
    OSKextLogSpec    msgLogSpec)
{
    OSKext * theKext = NULL; <span class="enscript-comment">// must release
</span>    
    theKext = OSKext::lookupKextWithIdentifier(kextIdentifier);
    <span class="enscript-keyword">if</span> (!theKext) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    theKext-&gt;reportOSMetaClassInstances(msgLogSpec);
<span class="enscript-reference">finish</span>:
    OSSafeRelease(theKext);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::reportOSMetaClassInstances</span>(OSKextLogSpec msgLogSpec)
{
    OSCollectionIterator * classIterator = NULL;  <span class="enscript-comment">// must release
</span>    OSMetaClass          * checkClass    = NULL;  <span class="enscript-comment">// do not release
</span>
    <span class="enscript-keyword">if</span> (!metaClasses) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    classIterator = OSCollectionIterator::withCollection(metaClasses);
    <span class="enscript-keyword">if</span> (!classIterator) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">while</span> ((checkClass = (OSMetaClass *)classIterator-&gt;getNextObject())) {
        <span class="enscript-keyword">if</span> (checkClass-&gt;getInstanceCount()) {
            OSKextLog(<span class="enscript-keyword">this</span>,
                msgLogSpec,
                <span class="enscript-string">&quot;    Kext %s class %s has %d instance%s.&quot;</span>,
                getIdentifierCString(),
                checkClass-&gt;getClassName(),
                checkClass-&gt;getInstanceCount(),
                checkClass-&gt;getInstanceCount() == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>);
        }
    }

<span class="enscript-reference">finish</span>:
    OSSafeRelease(classIterator);
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">User</span>-<span class="enscript-variable-name">Space</span> <span class="enscript-variable-name">Requests</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* XXX - this function is a big ugly mess
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::handleRequest</span>(
    host_priv_t     hostPriv,
    OSKextLogSpec   clientLogFilter,
    <span class="enscript-type">char</span>          * requestBuffer,
    uint32_t        requestLength,
    <span class="enscript-type">char</span>         ** responseOut,
    uint32_t      * responseLengthOut,
    <span class="enscript-type">char</span>         ** logInfoOut,
    uint32_t      * logInfoLengthOut)
{
    OSReturn       result             = kOSReturnError;
    kern_return_t  kmem_result        = KERN_FAILURE;

    <span class="enscript-type">char</span>         * response           = NULL;  <span class="enscript-comment">// returned by reference
</span>    uint32_t       responseLength     = 0;

    OSObject     * parsedXML          = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary * requestDict        = NULL;  <span class="enscript-comment">// do not release
</span>    OSString     * errorString        = NULL;  <span class="enscript-comment">// must release
</span>
    OSObject     * responseObject     = NULL;  <span class="enscript-comment">// must release
</span>    
    OSSerialize  * serializer         = NULL;  <span class="enscript-comment">// must release
</span>
    OSArray      * logInfoArray       = NULL;  <span class="enscript-comment">// must release
</span>
    OSString     * predicate          = NULL;  <span class="enscript-comment">// do not release
</span>    OSString     * kextIdentifier     = NULL;  <span class="enscript-comment">// do not release
</span>    OSArray      * kextIdentifiers    = NULL;  <span class="enscript-comment">// do not release
</span>    OSKext       * theKext            = NULL;  <span class="enscript-comment">// do not release
</span>    OSBoolean    * boolArg            = NULL;  <span class="enscript-comment">// do not release
</span>
    IORecursiveLockLock(sKextLock);

    <span class="enscript-keyword">if</span> (responseOut) {
        *responseOut = NULL;
        *responseLengthOut = 0;
    }
    <span class="enscript-keyword">if</span> (logInfoOut) {
        *logInfoOut = NULL;
        *logInfoLengthOut = 0;
    }

    <span class="enscript-reference">OSKext</span>::setUserSpaceLogFilter(clientLogFilter, logInfoOut ? true : false);

   <span class="enscript-comment">/* XML must be nul-terminated.
    */</span>
    <span class="enscript-keyword">if</span> (requestBuffer[requestLength - 1] != <span class="enscript-string">'\0'</span>) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Invalid request from user space (not nul-terminated).&quot;</span>);
        result = kOSKextReturnBadData;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    parsedXML = OSUnserializeXML((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)requestBuffer, &amp;errorString);
    <span class="enscript-keyword">if</span> (parsedXML) {
        requestDict = OSDynamicCast(OSDictionary, parsedXML);
    }
    <span class="enscript-keyword">if</span> (!requestDict) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * errorCString = <span class="enscript-string">&quot;(unknown error)&quot;</span>;
        
        <span class="enscript-keyword">if</span> (errorString &amp;&amp; errorString-&gt;getCStringNoCopy()) {
            errorCString = errorString-&gt;getCStringNoCopy();
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parsedXML) {
            errorCString = <span class="enscript-string">&quot;not a dictionary&quot;</span>;
        }
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Error unserializing request from user space: %s.&quot;</span>,
            errorCString);
        result = kOSKextReturnSerialization;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    predicate = _OSKextGetRequestPredicate(requestDict);
    <span class="enscript-keyword">if</span> (!predicate) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Recieved kext request from user space with no predicate.&quot;</span>);
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogDebugLevel |
        kOSKextLogIPCFlag,
        <span class="enscript-string">&quot;Received '%s' request from user space.&quot;</span>,
        predicate-&gt;getCStringNoCopy());
      
    result = kOSKextReturnNotPrivileged;
    <span class="enscript-keyword">if</span> (hostPriv == HOST_PRIV_NULL) {
        <span class="enscript-comment">/* must be root to use these kext requests */</span>
        <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateUnload) ||
            predicate-&gt;isEqualTo(kKextRequestPredicateStart) ||
            predicate-&gt;isEqualTo(kKextRequestPredicateStop) ||
            predicate-&gt;isEqualTo(kKextRequestPredicateGetKernelRequests) ||
            predicate-&gt;isEqualTo(kKextRequestPredicateSendResource) ) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                      kOSKextLogErrorLevel |
                      kOSKextLogIPCFlag,
                      <span class="enscript-string">&quot;Access Failure - must be root user.&quot;</span>);
           <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

   <span class="enscript-comment">/* Get common args in anticipation of use.
    */</span>
    kextIdentifier = OSDynamicCast(OSString, _OSKextGetRequestArgument(
        requestDict, kKextRequestArgumentBundleIdentifierKey));
    kextIdentifiers = OSDynamicCast(OSArray, _OSKextGetRequestArgument(
        requestDict, kKextRequestArgumentBundleIdentifierKey));
    <span class="enscript-keyword">if</span> (kextIdentifier) {
        theKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(kextIdentifier));
    }
    boolArg = OSDynamicCast(OSBoolean, _OSKextGetRequestArgument(
        requestDict, kKextRequestArgumentValueKey));

    result = kOSKextReturnInvalidArgument;

    <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateStart)) {
        <span class="enscript-keyword">if</span> (!kextIdentifier) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Invalid arguments to kext start request.&quot;</span>);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!theKext) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Kext %s not found for start request.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
            result = kOSKextReturnNotFound;
        } <span class="enscript-keyword">else</span> {
            result = theKext-&gt;start();
        }

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateStop)) {
        <span class="enscript-keyword">if</span> (!kextIdentifier) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Invalid arguments to kext stop request.&quot;</span>);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!theKext) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Kext %s not found for stop request.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
            result = kOSKextReturnNotFound;
        } <span class="enscript-keyword">else</span> {
            result = theKext-&gt;stop();
        }

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateUnload)) {
        <span class="enscript-keyword">if</span> (!kextIdentifier) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Invalid arguments to kext unload request.&quot;</span>);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!theKext) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Kext %s not found for unload request.&quot;</span>,
                kextIdentifier-&gt;getCStringNoCopy());
            result = kOSKextReturnNotFound;
        } <span class="enscript-keyword">else</span> {
            OSBoolean * terminateFlag = OSDynamicCast(OSBoolean,
                _OSKextGetRequestArgument(requestDict,
                    kKextRequestArgumentTerminateIOServicesKey));
            result = OSKext::removeKext(theKext, terminateFlag == kOSBooleanTrue);
        }

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateSendResource)) {
        result = OSKext::dispatchResource(requestDict);

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateGetLoaded)) {
        OSBoolean    * delayAutounloadBool = NULL;
        OSObject     * infoKeysRaw         = NULL;
        OSArray      * infoKeys            = NULL;
        uint32_t       infoKeysCount       = 0;
        
        delayAutounloadBool = OSDynamicCast(OSBoolean,
            _OSKextGetRequestArgument(requestDict,
                kKextRequestArgumentDelayAutounloadKey));

       <span class="enscript-comment">/* If asked to delay autounload, reset the timer if it's currently set.
        * (That is, don't schedule an unload if one isn't already pending.
        */</span>
        <span class="enscript-keyword">if</span> (delayAutounloadBool == kOSBooleanTrue) {
            <span class="enscript-reference">OSKext</span>::considerUnloads(<span class="enscript-comment">/* rescheduleOnly? */</span> true);
        }

        infoKeysRaw = _OSKextGetRequestArgument(requestDict,
                kKextRequestArgumentInfoKeysKey);
        infoKeys = OSDynamicCast(OSArray, infoKeysRaw);
        <span class="enscript-keyword">if</span> (infoKeysRaw &amp;&amp; !infoKeys) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Invalid arguments to kext info request.&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
        <span class="enscript-keyword">if</span> (infoKeys) {
            infoKeysCount = infoKeys-&gt;getCount();
            <span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; infoKeysCount; i++) {
                <span class="enscript-keyword">if</span> (!OSDynamicCast(OSString, infoKeys-&gt;getObject(i))) {
                    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                        kOSKextLogErrorLevel |
                        kOSKextLogIPCFlag,
                        <span class="enscript-string">&quot;Invalid arguments to kext info request.&quot;</span>);
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
            }
        }

        responseObject = OSKext::copyLoadedKextInfo(kextIdentifiers, infoKeys);
        <span class="enscript-keyword">if</span> (!responseObject) {
            result = kOSKextReturnInternalError;
        } <span class="enscript-keyword">else</span> {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogDebugLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Returning loaded kext info.&quot;</span>);
            result = kOSReturnSuccess;
        }
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateGetKernelRequests)) {

       <span class="enscript-comment">/* Hand the current sKernelRequests array to the caller
        * (who must release it), and make a new one.
        */</span>
        responseObject = sKernelRequests;
        sKernelRequests = OSArray::withCapacity(0);
        sPostedKextLoadIdentifiers-&gt;flushCollection();
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogDebugLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Returning kernel requests.&quot;</span>);
        result = kOSReturnSuccess;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateGetAllLoadRequests)) {
        
        <span class="enscript-comment">/* Return the set of all requested bundle identifiers */</span>
        responseObject = sAllKextLoadIdentifiers;
        responseObject-&gt;retain();
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogDebugLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Returning load requests.&quot;</span>);
        result = kOSReturnSuccess;
    }
    <span class="enscript-keyword">else</span> {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                  kOSKextLogDebugLevel |
                  kOSKextLogIPCFlag,
                  <span class="enscript-string">&quot;Received '%s' invalid request from user space.&quot;</span>,
                  predicate-&gt;getCStringNoCopy());
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/**********
    * Now we have handle the request, or not. Gather up the response &amp; logging
    * info to ship to user space.
    *********/</span>
    
   <span class="enscript-comment">/* Note: Nothing in OSKext is supposed to retain requestDict,
    * but you never know....
    */</span>
    <span class="enscript-keyword">if</span> (requestDict-&gt;getRetainCount() &gt; 1) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogWarningLevel |
            kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Request from user space still retained by a kext; &quot;</span>
            <span class="enscript-string">&quot;probable memory leak.&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (responseOut &amp;&amp; responseObject) {
        serializer = OSSerialize::withCapacity(0);
        <span class="enscript-keyword">if</span> (!serializer) {
            result = kOSKextReturnNoMemory;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-keyword">if</span> (!responseObject-&gt;serialize(serializer)) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogGeneralFlag | kOSKextLogErrorLevel,
                <span class="enscript-string">&quot;Failed to serialize response to request from user space.&quot;</span>);
            result = kOSKextReturnSerialization;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        response = (<span class="enscript-type">char</span> *)serializer-&gt;text();
        responseLength = serializer-&gt;getLength();
    }
    
    <span class="enscript-keyword">if</span> (responseOut &amp;&amp; response) {
        <span class="enscript-type">char</span> * buffer;

       <span class="enscript-comment">/* This kmem_alloc sets the return value of the function.
        */</span>
        kmem_result = kmem_alloc(kernel_map, (vm_offset_t *)&amp;buffer,
            round_page(responseLength), VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (kmem_result != KERN_SUCCESS) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                kOSKextLogErrorLevel |
                kOSKextLogIPCFlag,
                <span class="enscript-string">&quot;Failed to copy response to request from user space.&quot;</span>);
            result = kmem_result;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* 11981737 - clear uninitialized data in last page */</span>
            bzero((<span class="enscript-type">void</span> *)(buffer + responseLength),
                  (round_page(responseLength) - responseLength));
            memcpy(buffer, response, responseLength);
            *responseOut = buffer;
            *responseLengthOut = responseLength;
        }
    }

<span class="enscript-reference">finish</span>:

   <span class="enscript-comment">/* Gather up the collected log messages for user space. Any messages
    * messages past this call will not make it up as log messages but
    * will be in the system log. Note that we ignore the return of the
    * serialize; it has no bearing on the operation at hand even if we
    * fail to get the log messages.
    */</span>
    logInfoArray = OSKext::clearUserSpaceLogFilter();

    <span class="enscript-keyword">if</span> (logInfoArray &amp;&amp; logInfoOut &amp;&amp; logInfoLengthOut) {
        (<span class="enscript-type">void</span>)OSKext::serializeLogInfo(logInfoArray,
            logInfoOut, logInfoLengthOut);
    }

    IORecursiveLockUnlock(sKextLock);

    OSSafeRelease(parsedXML);
    OSSafeRelease(errorString);
    OSSafeRelease(responseObject);
    OSSafeRelease(serializer);
    OSSafeRelease(logInfoArray);

    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">// #include &lt;InstrProfiling.h&gt;
</span><span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

    uint64_t __llvm_profile_get_size_for_buffer_internal(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *DataBegin,
                                                         <span class="enscript-type">const</span> <span class="enscript-type">char</span> *DataEnd,
                                                         <span class="enscript-type">const</span> <span class="enscript-type">char</span> *CountersBegin,
                                                         <span class="enscript-type">const</span> <span class="enscript-type">char</span> *CountersEnd ,
                                                         <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NamesBegin,
                                                         <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NamesEnd);
    <span class="enscript-type">int</span> __llvm_profile_write_buffer_internal(<span class="enscript-type">char</span> *Buffer,
                                             <span class="enscript-type">const</span> <span class="enscript-type">char</span> *DataBegin,
                                             <span class="enscript-type">const</span> <span class="enscript-type">char</span> *DataEnd,
                                             <span class="enscript-type">const</span> <span class="enscript-type">char</span> *CountersBegin,
                                             <span class="enscript-type">const</span> <span class="enscript-type">char</span> *CountersEnd ,
                                             <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NamesBegin,
                                             <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NamesEnd);
}


<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSKextPgoMetadataPut</span>(<span class="enscript-type">char</span> *pBuffer,
                          size_t *position,
                          size_t bufferSize,
                          uint32_t *num_pairs,
                          <span class="enscript-type">const</span> <span class="enscript-type">char</span> *key,
                          <span class="enscript-type">const</span> <span class="enscript-type">char</span> *value)
{
    size_t strlen_key = strlen(key);
    size_t strlen_value = strlen(value);
    size_t len = strlen(key) + 1 + strlen(value) + 1;
    <span class="enscript-type">char</span> *pos = pBuffer + *position;
    *position += len;
    <span class="enscript-keyword">if</span> (pBuffer &amp;&amp; bufferSize &amp;&amp; *position &lt;= bufferSize) {
        memcpy(pos, key, strlen_key); pos += strlen_key;
        *(pos++) = <span class="enscript-string">'='</span>;
        memcpy(pos, value, strlen_value); pos += strlen_value;
        *(pos++) = 0;
        <span class="enscript-keyword">if</span> (num_pairs) {
            (*num_pairs)++;
        }
    }
}


<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSKextPgoMetadataPutMax</span>(size_t *position, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *key, size_t value_max)
{
    *position += strlen(key) + 1 + value_max + 1;
}


<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSKextPgoMetadataPutAll</span>(OSKext *kext,
                             uuid_t instance_uuid,
                             <span class="enscript-type">char</span> *pBuffer,
                             size_t *position,
                             size_t bufferSize,
                             uint32_t *num_pairs)
{
    assert_static(<span class="enscript-keyword">sizeof</span>(clock_sec_t) % 2 == 0);
    <span class="enscript-comment">//log_10 2^16 ≈ 4.82
</span>    <span class="enscript-type">const</span> size_t max_secs_string_size = 5 * <span class="enscript-keyword">sizeof</span>(clock_sec_t)/2;
    <span class="enscript-type">const</span> size_t max_timestamp_string_size = max_secs_string_size + 1 + 6;

    <span class="enscript-keyword">if</span> (!pBuffer) {
        OSKextPgoMetadataPutMax(position, <span class="enscript-string">&quot;INSTANCE&quot;</span>, 36);
        OSKextPgoMetadataPutMax(position, <span class="enscript-string">&quot;UUID&quot;</span>, 36);
        OSKextPgoMetadataPutMax(position, <span class="enscript-string">&quot;TIMESTAMP&quot;</span>, max_timestamp_string_size);
    } <span class="enscript-keyword">else</span> {
        uuid_string_t instance_uuid_string;
        uuid_unparse(instance_uuid, instance_uuid_string);
        OSKextPgoMetadataPut(pBuffer, position, bufferSize, num_pairs,
                             <span class="enscript-string">&quot;INSTANCE&quot;</span>, instance_uuid_string);

        OSData *uuid_data;
        uuid_t uuid;
        uuid_string_t uuid_string;
        uuid_data = kext-&gt;copyUUID();
        <span class="enscript-keyword">if</span> (uuid_data) {
            memcpy(uuid, uuid_data-&gt;getBytesNoCopy(), <span class="enscript-keyword">sizeof</span>(uuid));
            OSSafeRelease(uuid_data);
            uuid_unparse(uuid, uuid_string);
            OSKextPgoMetadataPut(pBuffer, position, bufferSize, num_pairs,
                                 <span class="enscript-string">&quot;UUID&quot;</span>, uuid_string);
        }

        clock_sec_t secs;
        clock_usec_t usecs;
        clock_get_calendar_microtime(&amp;secs, &amp;usecs);
        assert(usecs &lt; 1000000);
        <span class="enscript-type">char</span> timestamp[max_timestamp_string_size + 1];
        assert_static(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">long</span>) &gt;= <span class="enscript-keyword">sizeof</span>(clock_sec_t));
        snprintf(timestamp, <span class="enscript-keyword">sizeof</span>(timestamp), <span class="enscript-string">&quot;%lu.%06d&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)secs, (<span class="enscript-type">int</span>)usecs);
        OSKextPgoMetadataPut(pBuffer, position, bufferSize, num_pairs,
                             <span class="enscript-string">&quot;TIMESTAMP&quot;</span>, timestamp);
    }

    OSKextPgoMetadataPut(pBuffer, position, bufferSize, num_pairs,
                         <span class="enscript-string">&quot;NAME&quot;</span>, kext-&gt;getIdentifierCString());

    <span class="enscript-type">char</span> versionCString[kOSKextVersionMaxLength];
    OSKextVersionGetString(kext-&gt;getVersion(), versionCString, kOSKextVersionMaxLength);
    OSKextPgoMetadataPut(pBuffer, position, bufferSize, num_pairs,
                         <span class="enscript-string">&quot;VERSION&quot;</span>, versionCString);

}

<span class="enscript-type">static</span>
size_t <span class="enscript-function-name">OSKextPgoMetadataSize</span>(OSKext *kext)
{
    size_t position = 0;
    uuid_t fakeuuid = {};
    OSKextPgoMetadataPutAll(kext, fakeuuid, NULL, &amp;position, 0, NULL);
    <span class="enscript-keyword">return</span> position;
}


<span class="enscript-type">int</span> <span class="enscript-function-name">OSKextGrabPgoDataLocked</span>(OSKext *kext,
                            <span class="enscript-type">bool</span> metadata,
                            uuid_t instance_uuid,
                            uint64_t *pSize,
                            <span class="enscript-type">char</span> *pBuffer,
                            uint64_t bufferSize)
{

    <span class="enscript-type">int</span> err = 0;

    kernel_section_t *sect_prf_data = NULL;
    kernel_section_t *sect_prf_name = NULL;
    kernel_section_t *sect_prf_cnts = NULL;
    uint64_t size;
    size_t metadata_size = 0;

    sect_prf_data = kext-&gt;lookupSection(<span class="enscript-string">&quot;__DATA&quot;</span>, <span class="enscript-string">&quot;__llvm_prf_data&quot;</span>);
    sect_prf_name = kext-&gt;lookupSection(<span class="enscript-string">&quot;__DATA&quot;</span>, <span class="enscript-string">&quot;__llvm_prf_name&quot;</span>);
    sect_prf_cnts = kext-&gt;lookupSection(<span class="enscript-string">&quot;__DATA&quot;</span>, <span class="enscript-string">&quot;__llvm_prf_cnts&quot;</span>);

    <span class="enscript-keyword">if</span> (!sect_prf_data || !sect_prf_name || !sect_prf_cnts) {
        err = ENOTSUP;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    size = __llvm_profile_get_size_for_buffer_internal(
                         (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_data-&gt;addr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_data-&gt;addr + sect_prf_data-&gt;size,
                         (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_cnts-&gt;addr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_cnts-&gt;addr + sect_prf_cnts-&gt;size,
                         (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_name-&gt;addr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_name-&gt;addr + sect_prf_name-&gt;size);

    <span class="enscript-keyword">if</span> (metadata) {
        metadata_size = OSKextPgoMetadataSize(kext);
        size += metadata_size;
        size += <span class="enscript-keyword">sizeof</span>(pgo_metadata_footer);
    }


    <span class="enscript-keyword">if</span> (pSize) {
        *pSize = size;
    }

    <span class="enscript-keyword">if</span> (pBuffer &amp;&amp; bufferSize) {
        <span class="enscript-keyword">if</span> (bufferSize &lt; size) {
            err = ERANGE;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }

        err = __llvm_profile_write_buffer_internal(
                    pBuffer,
                    (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_data-&gt;addr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_data-&gt;addr + sect_prf_data-&gt;size,
                    (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_cnts-&gt;addr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_cnts-&gt;addr + sect_prf_cnts-&gt;size,
                    (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_name-&gt;addr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) sect_prf_name-&gt;addr + sect_prf_name-&gt;size);

        <span class="enscript-keyword">if</span> (err) {
            err = EIO;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }

        <span class="enscript-keyword">if</span> (metadata) {
            <span class="enscript-type">char</span> *end_of_buffer = pBuffer + size;
            <span class="enscript-type">struct</span> pgo_metadata_footer *footerp = (<span class="enscript-type">struct</span> pgo_metadata_footer *) (end_of_buffer - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pgo_metadata_footer));
            <span class="enscript-type">char</span> *metadata_buffer = end_of_buffer - (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pgo_metadata_footer) + metadata_size);

            size_t metadata_position = 0;
            uint32_t num_pairs = 0;
            OSKextPgoMetadataPutAll(kext, instance_uuid, metadata_buffer, &amp;metadata_position, metadata_size, &amp;num_pairs);
            <span class="enscript-keyword">while</span> (metadata_position &lt; metadata_size) {
                metadata_buffer[metadata_position++] = 0;
            }

            <span class="enscript-type">struct</span> pgo_metadata_footer footer;
            footer.magic = htonl(0x6d657461);
            footer.number_of_pairs = htonl( num_pairs );
            footer.offset_to_pairs = htonl( <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pgo_metadata_footer) + metadata_size );
            memcpy(footerp, &amp;footer, <span class="enscript-keyword">sizeof</span>(footer));
        }

    }

<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> err;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">OSKextGrabPgoData</span>(uuid_t uuid,
                  uint64_t *pSize,
                  <span class="enscript-type">char</span> *pBuffer,
                  uint64_t bufferSize,
                  <span class="enscript-type">int</span> wait_for_unload,
                  <span class="enscript-type">int</span> metadata)
{
    <span class="enscript-type">int</span> err = 0;
    OSKext *kext = NULL;


    IORecursiveLockLock(sKextLock);

    kext = OSKext::lookupKextWithUUID(uuid);
    <span class="enscript-keyword">if</span> (!kext)  {
        err = ENOENT;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-keyword">if</span> (wait_for_unload) {
        OSKextGrabPgoStruct s;

        s.metadata = metadata;
        s.pSize = pSize;
        s.pBuffer = pBuffer;
        s.bufferSize = bufferSize;
        s.err = EINTR;

        <span class="enscript-type">struct</span> list_head *prev = &amp;kext-&gt;pendingPgoHead;
        <span class="enscript-type">struct</span> list_head *next = kext-&gt;pendingPgoHead.next;

        s.list_head.prev = prev;
        s.list_head.next = next;

        prev-&gt;next = &amp;s.list_head;
        next-&gt;prev = &amp;s.list_head;

        kext-&gt;release();
        kext = NULL;

        IORecursiveLockSleep(sKextLock, &amp;s, THREAD_ABORTSAFE);

        prev = s.list_head.prev;
        next = s.list_head.next;

        prev-&gt;next = next;
        next-&gt;prev = prev;

        err = s.err;

    } <span class="enscript-keyword">else</span> {
        err = OSKextGrabPgoDataLocked(kext, metadata, kext-&gt;instance_uuid, pSize, pBuffer, bufferSize);
    }

 <span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (kext) {
        kext-&gt;release();
    }

    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSDictionary *
<span class="enscript-function-name">OSKext::copyLoadedKextInfo</span>(
    OSArray * kextIdentifiers,
    OSArray * infoKeys) 
{
    OSDictionary * result = NULL;
    OSDictionary * kextInfo = NULL;  <span class="enscript-comment">// must release
</span>    uint32_t       count, i;
    uint32_t       idCount = 0;
    uint32_t       idIndex = 0;

    IORecursiveLockLock(sKextLock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-comment">/* Is the calling process allowed to query kext info? */</span>
    <span class="enscript-keyword">if</span> (current_task() != kernel_task) {
        <span class="enscript-type">int</span>                 macCheckResult      = 0;
        kauth_cred_t        cred                = NULL;

        cred = kauth_cred_get_with_ref();
        macCheckResult = mac_kext_check_query(cred);
        kauth_cred_unref(&amp;cred);

        <span class="enscript-keyword">if</span> (macCheckResult != 0) {
            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                      kOSKextLogErrorLevel | kOSKextLogLoadFlag,
                      <span class="enscript-string">&quot;Failed to query kext info (MAC policy error 0x%x).&quot;</span>,
                      macCheckResult);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
   }
#<span class="enscript-reference">endif</span>

   <span class="enscript-comment">/* Empty list of bundle ids is equivalent to no list (get all).
    */</span>
    <span class="enscript-keyword">if</span> (kextIdentifiers &amp;&amp; !kextIdentifiers-&gt;getCount()) {
        kextIdentifiers = NULL;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kextIdentifiers) {
        idCount = kextIdentifiers-&gt;getCount();
    }

   <span class="enscript-comment">/* Same for keys.
    */</span>
    <span class="enscript-keyword">if</span> (infoKeys &amp;&amp; !infoKeys-&gt;getCount()) {
        infoKeys = NULL;
    }

    count = sLoadedKexts-&gt;getCount();
    result = OSDictionary::withCapacity(count);
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

#<span class="enscript-reference">if</span> 0
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_kernel_slide 0x%lx \n&quot;</span>,
              vm_kernel_slide);
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_kernel_stext 0x%lx vm_kernel_etext 0x%lx \n&quot;</span>,
              vm_kernel_stext, vm_kernel_etext);
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_kernel_base 0x%lx vm_kernel_top 0x%lx \n&quot;</span>,
              vm_kernel_base, vm_kernel_top);
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_kext_base 0x%lx vm_kext_top 0x%lx \n&quot;</span>,
              vm_kext_base, vm_kext_top);
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_prelink_stext 0x%lx vm_prelink_etext 0x%lx \n&quot;</span>,
              vm_prelink_stext, vm_prelink_etext);
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_prelink_sinfo 0x%lx vm_prelink_einfo 0x%lx \n&quot;</span>,
              vm_prelink_sinfo, vm_prelink_einfo);
    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;kaslr: vm_slinkedit 0x%lx vm_elinkedit 0x%lx \n&quot;</span>,
              vm_slinkedit, vm_elinkedit);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSKext   * thisKext     = NULL;  <span class="enscript-comment">// do not release
</span>        Boolean    includeThis  = true;

        <span class="enscript-keyword">if</span> (kextInfo) {
            kextInfo-&gt;release();
            kextInfo = NULL;
        }
        thisKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!thisKext) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Skip current kext if we have a list of bundle IDs and
        * it isn't in the list.
        */</span>
        <span class="enscript-keyword">if</span> (kextIdentifiers) {
            <span class="enscript-type">const</span> OSString * thisKextID = thisKext-&gt;getIdentifier();

            includeThis = false;

            <span class="enscript-keyword">for</span> (idIndex = 0; idIndex &lt; idCount; idIndex++) {
                <span class="enscript-type">const</span> OSString * thisRequestID = OSDynamicCast(OSString,
                    kextIdentifiers-&gt;getObject(idIndex));
                <span class="enscript-keyword">if</span> (thisKextID-&gt;isEqualTo(thisRequestID)) {
                    includeThis = true;
                    <span class="enscript-keyword">break</span>;
                }
            }
        }
        
        <span class="enscript-keyword">if</span> (!includeThis) {
            <span class="enscript-keyword">continue</span>;
        }

        kextInfo = thisKext-&gt;copyInfo(infoKeys);
        <span class="enscript-keyword">if</span> (kextInfo) {
            result-&gt;setObject(thisKext-&gt;getIdentifier(), kextInfo);
        }
    }
    
<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">if</span> (kextInfo) kextInfo-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Any info that needs to do allocations must goto finish on alloc
* failure. Info that is just a lookup should just not set the object
* if the info does not exist.
*********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_OSKextLoadInfoDictCapacity</span>   (12)

OSDictionary *
<span class="enscript-function-name">OSKext::copyInfo</span>(OSArray * infoKeys)
{
    OSDictionary         * result                      = NULL;
    <span class="enscript-type">bool</span>                   success                     = false;
    OSData               * headerData                  = NULL;  <span class="enscript-comment">// must release
</span>    OSNumber             * cpuTypeNumber               = NULL;  <span class="enscript-comment">// must release
</span>    OSNumber             * cpuSubtypeNumber            = NULL;  <span class="enscript-comment">// must release
</span>    OSString             * versionString               = NULL;  <span class="enscript-comment">// do not release
</span>    uint32_t               executablePathCStringSize = 0;
    <span class="enscript-type">char</span>                 * executablePathCString       = NULL;  <span class="enscript-comment">// must release
</span>    OSString             * executablePathString        = NULL;  <span class="enscript-comment">// must release
</span>    OSData               * uuid                        = NULL;  <span class="enscript-comment">// must release
</span>    OSNumber             * scratchNumber               = NULL;  <span class="enscript-comment">// must release
</span>    OSArray              * dependencyLoadTags          = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * metaClassIterator           = NULL;  <span class="enscript-comment">// must release
</span>    OSArray              * metaClassInfo               = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary         * metaClassDict               = NULL;  <span class="enscript-comment">// must release
</span>    OSMetaClass          * thisMetaClass               = NULL;  <span class="enscript-comment">// do not release
</span>    OSString             * metaClassName               = NULL;  <span class="enscript-comment">// must release
</span>    OSString             * superclassName              = NULL;  <span class="enscript-comment">// must release
</span>    uint32_t               count, i;

    result = OSDictionary::withCapacity(_OSKextLoadInfoDictCapacity);
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    
   <span class="enscript-comment">/* Empty keys means no keys, but NULL is quicker to check.
    */</span>
    <span class="enscript-keyword">if</span> (infoKeys &amp;&amp; !infoKeys-&gt;getCount()) {
        infoKeys = NULL;
    }

   <span class="enscript-comment">/* Headers, CPU type, and CPU subtype.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys ||
        _OSArrayContainsCString(infoKeys, kOSBundleMachOHeadersKey) ||
        _OSArrayContainsCString(infoKeys, kOSBundleCPUTypeKey) ||
        _OSArrayContainsCString(infoKeys, kOSBundleCPUSubtypeKey))
    {

        <span class="enscript-keyword">if</span> (linkedExecutable &amp;&amp; !isInterface()) {

            kernel_mach_header_t *kext_mach_hdr = (kernel_mach_header_t *)
                linkedExecutable-&gt;getBytesNoCopy();

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
            <span class="enscript-comment">// do not return macho header info on shipping iOS - 19095897
</span>            <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleMachOHeadersKey)) {
                kernel_mach_header_t *  temp_kext_mach_hdr;
                <span class="enscript-type">struct</span> load_command *   lcp;

                headerData = OSData::withBytes(kext_mach_hdr,
                    (u_int) (<span class="enscript-keyword">sizeof</span>(*kext_mach_hdr) + kext_mach_hdr-&gt;sizeofcmds));
                <span class="enscript-keyword">if</span> (!headerData) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }

                <span class="enscript-comment">// unslide any vmaddrs we return to userspace - 10726716
</span>               temp_kext_mach_hdr = (kernel_mach_header_t *)
                    headerData-&gt;getBytesNoCopy();
                <span class="enscript-keyword">if</span> (temp_kext_mach_hdr == NULL) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }

                lcp = (<span class="enscript-type">struct</span> load_command *) (temp_kext_mach_hdr + 1);
                <span class="enscript-keyword">for</span> (i = 0; i &lt; temp_kext_mach_hdr-&gt;ncmds; i++) {
                    <span class="enscript-keyword">if</span> (lcp-&gt;cmd == LC_SEGMENT_KERNEL) {
                        kernel_segment_command_t *  segp;
                        kernel_section_t *          secp;
                        
                        segp = (kernel_segment_command_t *) lcp;
                        <span class="enscript-comment">// 10543468 - if we jettisoned __LINKEDIT clear size info
</span>                        <span class="enscript-keyword">if</span> (flags.jettisonLinkeditSeg) {
                            <span class="enscript-keyword">if</span> (strncmp(segp-&gt;segname, SEG_LINKEDIT, <span class="enscript-keyword">sizeof</span>(segp-&gt;segname)) == 0) {
                                segp-&gt;vmsize = 0;
                                segp-&gt;fileoff = 0;
                                segp-&gt;filesize = 0;
                            }
                        }
#<span class="enscript-reference">if</span> 0
                        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                                  kOSKextLogErrorLevel |
                                  kOSKextLogGeneralFlag,
                                  <span class="enscript-string">&quot;%s: LC_SEGMENT_KERNEL segname '%s' vmaddr 0x%llX 0x%lX vmsize %llu nsects %u&quot;</span>,
                                  __FUNCTION__, segp-&gt;segname, segp-&gt;vmaddr,
                                  VM_KERNEL_UNSLIDE(segp-&gt;vmaddr),
                                  segp-&gt;vmsize, segp-&gt;nsects);
                        <span class="enscript-keyword">if</span> ( (VM_KERNEL_IS_SLID(segp-&gt;vmaddr) == false) &amp;&amp;
                            (VM_KERNEL_IS_KEXT(segp-&gt;vmaddr) == false) &amp;&amp;
                            (VM_KERNEL_IS_PRELINKTEXT(segp-&gt;vmaddr) == false) &amp;&amp;
                            (VM_KERNEL_IS_PRELINKINFO(segp-&gt;vmaddr) == false) &amp;&amp;
                            (VM_KERNEL_IS_KEXT_LINKEDIT(segp-&gt;vmaddr) == false) ) {
                            OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                                      kOSKextLogErrorLevel |
                                      kOSKextLogGeneralFlag,
                                      <span class="enscript-string">&quot;%s: not in kext range - vmaddr 0x%llX vm_kext_base 0x%lX vm_kext_top 0x%lX&quot;</span>,
                                      __FUNCTION__, segp-&gt;vmaddr, vm_kext_base, vm_kext_top);
                        }
#<span class="enscript-reference">endif</span>
                        segp-&gt;vmaddr = VM_KERNEL_UNSLIDE(segp-&gt;vmaddr);
                        
                        <span class="enscript-keyword">for</span> (secp = firstsect(segp); secp != NULL; secp = nextsect(segp, secp)) {
                            secp-&gt;addr = VM_KERNEL_UNSLIDE(secp-&gt;addr);
                        }
                    }
                    lcp = (<span class="enscript-type">struct</span> load_command *)((caddr_t)lcp + lcp-&gt;cmdsize);
                }
                result-&gt;setObject(kOSBundleMachOHeadersKey, headerData);
            }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SECURE_KERNEL</span>

            <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleCPUTypeKey)) {
                cpuTypeNumber = OSNumber::withNumber(
                    (uint64_t) kext_mach_hdr-&gt;cputype,
                    8 * <span class="enscript-keyword">sizeof</span>(kext_mach_hdr-&gt;cputype));
                <span class="enscript-keyword">if</span> (!cpuTypeNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                result-&gt;setObject(kOSBundleCPUTypeKey, cpuTypeNumber);
            }

            <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleCPUSubtypeKey)) {
                cpuSubtypeNumber = OSNumber::withNumber(
                    (uint64_t) kext_mach_hdr-&gt;cpusubtype,
                    8 * <span class="enscript-keyword">sizeof</span>(kext_mach_hdr-&gt;cpusubtype));
                <span class="enscript-keyword">if</span> (!cpuSubtypeNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                result-&gt;setObject(kOSBundleCPUSubtypeKey, cpuSubtypeNumber);
            }
        }
    }
    
   <span class="enscript-comment">/* CFBundleIdentifier. We set this regardless because it's just stupid not to.
    */</span>
    result-&gt;setObject(kCFBundleIdentifierKey, bundleID);

   <span class="enscript-comment">/* CFBundleVersion.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kCFBundleVersionKey)) {
        versionString = OSDynamicCast(OSString,
            getPropertyForHostArch(kCFBundleVersionKey));
        <span class="enscript-keyword">if</span> (versionString) {
            result-&gt;setObject(kCFBundleVersionKey, versionString);
        }
    }

   <span class="enscript-comment">/* OSBundleCompatibleVersion.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleCompatibleVersionKey)) {
        versionString = OSDynamicCast(OSString,
            getPropertyForHostArch(kOSBundleCompatibleVersionKey));
        <span class="enscript-keyword">if</span> (versionString) {
            result-&gt;setObject(kOSBundleCompatibleVersionKey, versionString);
        }
    }

   <span class="enscript-comment">/* Path.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundlePathKey)) {
        <span class="enscript-keyword">if</span> (path) {
            result-&gt;setObject(kOSBundlePathKey, path);
        }
    }


   <span class="enscript-comment">/* OSBundleExecutablePath.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleExecutablePathKey)) {
         <span class="enscript-keyword">if</span> (path &amp;&amp; executableRelPath) {

            uint32_t pathLength = path-&gt;getLength();  <span class="enscript-comment">// gets incremented below
</span>
            <span class="enscript-comment">// +1 for slash, +1 for \0
</span>            executablePathCStringSize = pathLength + executableRelPath-&gt;getLength() + 2;

            executablePathCString = (<span class="enscript-type">char</span> *)kalloc_tag((executablePathCStringSize) *
                <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>), VM_KERN_MEMORY_OSKEXT); <span class="enscript-comment">// +1 for \0
</span>            <span class="enscript-keyword">if</span> (!executablePathCString) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            strlcpy(executablePathCString, path-&gt;getCStringNoCopy(),
                executablePathCStringSize);
            executablePathCString[pathLength++] = <span class="enscript-string">'/'</span>;
            executablePathCString[pathLength++] = <span class="enscript-string">'\0'</span>;
            strlcat(executablePathCString, executableRelPath-&gt;getCStringNoCopy(),
                executablePathCStringSize);

            executablePathString = OSString::withCString(executablePathCString);

            <span class="enscript-keyword">if</span> (!executablePathCString) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }

            result-&gt;setObject(kOSBundleExecutablePathKey, executablePathString);
        }
    }

   <span class="enscript-comment">/* UUID, if the kext has one.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleUUIDKey)) {
        uuid = copyUUID();
        <span class="enscript-keyword">if</span> (uuid) {
            result-&gt;setObject(kOSBundleUUIDKey, uuid);
        }
    }
    
   <span class="enscript-comment">/*****
    * OSKernelResource, OSBundleIsInterface, OSBundlePrelinked, OSBundleStarted.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSKernelResourceKey)) {
        result-&gt;setObject(kOSKernelResourceKey,
            isKernelComponent() ? kOSBooleanTrue : kOSBooleanFalse);
    }
    
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleIsInterfaceKey)) {
        result-&gt;setObject(kOSBundleIsInterfaceKey,
            isInterface() ? kOSBooleanTrue : kOSBooleanFalse);
    }
    
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundlePrelinkedKey)) {
        result-&gt;setObject(kOSBundlePrelinkedKey,
            isPrelinked() ? kOSBooleanTrue : kOSBooleanFalse);
    }
    
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleStartedKey)) {
        result-&gt;setObject(kOSBundleStartedKey,
            isStarted() ? kOSBooleanTrue : kOSBooleanFalse);
    }

   <span class="enscript-comment">/* LoadTag (Index).
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleLoadTagKey)) {
        scratchNumber = OSNumber::withNumber((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)loadTag,
            <span class="enscript-comment">/* numBits */</span> 8 * <span class="enscript-keyword">sizeof</span>(loadTag));
        <span class="enscript-keyword">if</span> (!scratchNumber) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        result-&gt;setObject(kOSBundleLoadTagKey, scratchNumber);
        OSSafeReleaseNULL(scratchNumber);
    }
    
   <span class="enscript-comment">/* LoadAddress, LoadSize.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys ||
        _OSArrayContainsCString(infoKeys, kOSBundleLoadAddressKey) ||
        _OSArrayContainsCString(infoKeys, kOSBundleLoadSizeKey) ||
        _OSArrayContainsCString(infoKeys, kOSBundleWiredSizeKey))
    {
        <span class="enscript-keyword">if</span> (isInterface() || linkedExecutable) {
           <span class="enscript-comment">/* These go to userspace via serialization, so we don't want any doubts
            * about their size.
            */</span>
            uint64_t    loadAddress = 0;
            uint32_t    loadSize    = 0;
            uint32_t    wiredSize   = 0;

           <span class="enscript-comment">/* Interfaces always report 0 load address &amp; size.
            * Just the way they roll.
            *
            * xxx - leaving in # when we have a linkedExecutable...a kernelcomp
            * xxx - shouldn't have one!
            */</span>
            <span class="enscript-keyword">if</span> (linkedExecutable <span class="enscript-comment">/* &amp;&amp; !isInterface() */</span>) {
                loadAddress = (uint64_t)linkedExecutable-&gt;getBytesNoCopy();
                loadAddress = VM_KERNEL_UNSLIDE(loadAddress);
                loadSize = linkedExecutable-&gt;getLength();
                
               <span class="enscript-comment">/* If we have a kmod_info struct, calculated the wired size
                * from that. Otherwise it's the full load size.
                */</span>
                <span class="enscript-keyword">if</span> (kmod_info) {
                    wiredSize = loadSize - kmod_info-&gt;hdr_size;
                } <span class="enscript-keyword">else</span> {
                    wiredSize = loadSize;
                }
            }

            <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleLoadAddressKey)) {
                scratchNumber = OSNumber::withNumber(
                    (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)(loadAddress),
                    <span class="enscript-comment">/* numBits */</span> 8 * <span class="enscript-keyword">sizeof</span>(loadAddress));
                <span class="enscript-keyword">if</span> (!scratchNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                result-&gt;setObject(kOSBundleLoadAddressKey, scratchNumber);
                OSSafeReleaseNULL(scratchNumber);
            }
            <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleLoadSizeKey)) {
                scratchNumber = OSNumber::withNumber(
                    (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)(loadSize),
                    <span class="enscript-comment">/* numBits */</span> 8 * <span class="enscript-keyword">sizeof</span>(loadSize));
                <span class="enscript-keyword">if</span> (!scratchNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                result-&gt;setObject(kOSBundleLoadSizeKey, scratchNumber);
                OSSafeReleaseNULL(scratchNumber);
            }
            <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleWiredSizeKey)) {
                scratchNumber = OSNumber::withNumber(
                    (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)(wiredSize),
                    <span class="enscript-comment">/* numBits */</span> 8 * <span class="enscript-keyword">sizeof</span>(wiredSize));
                <span class="enscript-keyword">if</span> (!scratchNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                result-&gt;setObject(kOSBundleWiredSizeKey, scratchNumber);
                OSSafeReleaseNULL(scratchNumber);
            }
        }
    }

   <span class="enscript-comment">/* OSBundleDependencies. In descending order for
    * easy compatibility with kextstat(8).
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleDependenciesKey)) {
        <span class="enscript-keyword">if</span> ((count = getNumDependencies())) {
            dependencyLoadTags = OSArray::withCapacity(count);
            result-&gt;setObject(kOSBundleDependenciesKey, dependencyLoadTags);

            i = count - 1;
            <span class="enscript-keyword">do</span> {
                OSKext * dependency = OSDynamicCast(OSKext,
                    dependencies-&gt;getObject(i));

                OSSafeReleaseNULL(scratchNumber);
                
                <span class="enscript-keyword">if</span> (!dependency) {
                    <span class="enscript-keyword">continue</span>;
                }
                scratchNumber = OSNumber::withNumber(
                    (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)dependency-&gt;getLoadTag(),
                    <span class="enscript-comment">/* numBits*/</span> 8 * <span class="enscript-keyword">sizeof</span>(loadTag));
                <span class="enscript-keyword">if</span> (!scratchNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }
                dependencyLoadTags-&gt;setObject(scratchNumber);
            } <span class="enscript-keyword">while</span> (i--);
        }
    }

    OSSafeReleaseNULL(scratchNumber);

   <span class="enscript-comment">/* OSBundleMetaClasses.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleClassesKey)) {
        <span class="enscript-keyword">if</span> (metaClasses &amp;&amp; metaClasses-&gt;getCount()) {
            metaClassIterator = OSCollectionIterator::withCollection(metaClasses);
            metaClassInfo = OSArray::withCapacity(metaClasses-&gt;getCount());
            <span class="enscript-keyword">if</span> (!metaClassIterator || !metaClassInfo) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            result-&gt;setObject(kOSBundleClassesKey, metaClassInfo);

            <span class="enscript-keyword">while</span> ( (thisMetaClass = OSDynamicCast(OSMetaClass,
                metaClassIterator-&gt;getNextObject())) ) {

                OSSafeReleaseNULL(metaClassDict);
                OSSafeReleaseNULL(scratchNumber);
                OSSafeReleaseNULL(metaClassName);
                OSSafeReleaseNULL(superclassName);

                metaClassDict = OSDictionary::withCapacity(3);
                <span class="enscript-keyword">if</span> (!metaClassDict) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }

                metaClassName = OSString::withCString(thisMetaClass-&gt;getClassName());
                <span class="enscript-keyword">if</span> (thisMetaClass-&gt;getSuperClass()) {
                    superclassName = OSString::withCString(
                        thisMetaClass-&gt;getSuperClass()-&gt;getClassName());
                }
                scratchNumber = OSNumber::withNumber(thisMetaClass-&gt;getInstanceCount(),
                    8 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>));
                    
               <span class="enscript-comment">/* Bail if any of the essentials is missing. The root class lacks a superclass,
                * of course.
                */</span>
                <span class="enscript-keyword">if</span> (!metaClassDict || !metaClassName || !scratchNumber) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
                }

                metaClassInfo-&gt;setObject(metaClassDict);
                metaClassDict-&gt;setObject(kOSMetaClassNameKey, metaClassName);
                <span class="enscript-keyword">if</span> (superclassName) {
                    metaClassDict-&gt;setObject(kOSMetaClassSuperclassNameKey, superclassName);
                }
                metaClassDict-&gt;setObject(kOSMetaClassTrackingCountKey, scratchNumber);
            }
        }
    }
    
   <span class="enscript-comment">/* OSBundleRetainCount.
    */</span>
    <span class="enscript-keyword">if</span> (!infoKeys || _OSArrayContainsCString(infoKeys, kOSBundleRetainCountKey)) {
        OSSafeReleaseNULL(scratchNumber);
        {
            <span class="enscript-type">int</span> kextRetainCount = getRetainCount() - 1;
            <span class="enscript-keyword">if</span> (isLoaded()) {
                kextRetainCount--;
            }
            scratchNumber = OSNumber::withNumber(
                (<span class="enscript-type">int</span>)kextRetainCount,
                <span class="enscript-comment">/* numBits*/</span> 8 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
            <span class="enscript-keyword">if</span> (scratchNumber) {
                result-&gt;setObject(kOSBundleRetainCountKey, scratchNumber);
            }
        }
    }

    success = true;

<span class="enscript-reference">finish</span>:
    OSSafeRelease(headerData);
    OSSafeRelease(cpuTypeNumber);
    OSSafeRelease(cpuSubtypeNumber);
    OSSafeRelease(executablePathString);
    <span class="enscript-keyword">if</span> (executablePathString) kfree(executablePathCString, executablePathCStringSize);
    OSSafeRelease(uuid);
    OSSafeRelease(scratchNumber);
    OSSafeRelease(dependencyLoadTags);
    OSSafeRelease(metaClassIterator);
    OSSafeRelease(metaClassInfo);
    OSSafeRelease(metaClassDict);
    OSSafeRelease(metaClassName);
    OSSafeRelease(superclassName);
    <span class="enscript-keyword">if</span> (!success) {
        OSSafeReleaseNULL(result);
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
 *********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::requestResource</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>                    * kextIdentifierCString,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>                    * resourceNameCString,
    OSKextRequestResourceCallback   callback,
    <span class="enscript-type">void</span>                          * context,
    OSKextRequestTag              * requestTagOut)
{
    OSReturn           result          = kOSReturnError;
    OSKext           * callbackKext    = NULL;  <span class="enscript-comment">// must release (looked up)
</span>
    OSKextRequestTag   requestTag      = -1;
    OSNumber         * requestTagNum   = NULL;  <span class="enscript-comment">// must release
</span>
    OSDictionary     * requestDict     = NULL;  <span class="enscript-comment">// must release
</span>    OSString         * kextIdentifier  = NULL;  <span class="enscript-comment">// must release
</span>    OSString         * resourceName    = NULL;  <span class="enscript-comment">// must release
</span>
    OSDictionary     * callbackRecord  = NULL;  <span class="enscript-comment">// must release
</span>    OSData           * callbackWrapper = NULL;  <span class="enscript-comment">// must release
</span>
    OSData           * contextWrapper  = NULL;  <span class="enscript-comment">// must release
</span>            
    IORecursiveLockLock(sKextLock);

    <span class="enscript-keyword">if</span> (requestTagOut) {
        *requestTagOut = kOSKextRequestTagInvalid;
    }

    <span class="enscript-comment">/* If requests to user space are disabled, don't go any further */</span>
    <span class="enscript-keyword">if</span> (!sKernelRequestsEnabled) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL, 
            kOSKextLogErrorLevel | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Can't request resource %s for %s - requests to user space are disabled.&quot;</span>,
            resourceNameCString,
            kextIdentifierCString);
        result = kOSKextReturnDisabled;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!kextIdentifierCString || !resourceNameCString || !callback) {
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    callbackKext = OSKext::lookupKextWithAddress((vm_address_t)callback);
    <span class="enscript-keyword">if</span> (!callbackKext) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Resource request has bad callback address.&quot;</span>);
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (!callbackKext-&gt;flags.starting &amp;&amp; !callbackKext-&gt;flags.started) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Resource request callback is in a kext that is not started.&quot;</span>);
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Do not allow any new requests to be made on a kext that is unloading.
    */</span>
    <span class="enscript-keyword">if</span> (callbackKext-&gt;flags.stopping) {
        result = kOSKextReturnStopping;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* If we're wrapped the next available request tag around to the negative
    * numbers, we can't service any more requests.
    */</span>
    <span class="enscript-keyword">if</span> (sNextRequestTag == kOSKextRequestTagInvalid) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;No more request tags available; restart required.&quot;</span>);
        result = kOSKextReturnNoResources;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    requestTag = sNextRequestTag++;

    result = _OSKextCreateRequest(kKextRequestPredicateRequestResource,
        &amp;requestDict);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    kextIdentifier = OSString::withCString(kextIdentifierCString);
    resourceName   = OSString::withCString(resourceNameCString);
    requestTagNum  = OSNumber::withNumber((<span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)requestTag,
        8 * <span class="enscript-keyword">sizeof</span>(requestTag));
    <span class="enscript-keyword">if</span> (!kextIdentifier ||
        !resourceName   ||
        !requestTagNum  ||
        !_OSKextSetRequestArgument(requestDict,
            kKextRequestArgumentBundleIdentifierKey, kextIdentifier) ||
        !_OSKextSetRequestArgument(requestDict,
            kKextRequestArgumentNameKey, resourceName) ||
        !_OSKextSetRequestArgument(requestDict,
            kKextRequestArgumentRequestTagKey, requestTagNum)) {

        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    callbackRecord = OSDynamicCast(OSDictionary, requestDict-&gt;copyCollection());
    <span class="enscript-keyword">if</span> (!callbackRecord) {
        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-comment">// we validate callback address at call time
</span>    callbackWrapper = OSData::withBytes((<span class="enscript-type">void</span> *)&amp;callback, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *));
    <span class="enscript-keyword">if</span> (context) {
        contextWrapper = OSData::withBytes((<span class="enscript-type">void</span> *)&amp;context, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *));
    }
    <span class="enscript-keyword">if</span> (!callbackWrapper || !_OSKextSetRequestArgument(callbackRecord,
            kKextRequestArgumentCallbackKey, callbackWrapper)) {

        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (context) {
        <span class="enscript-keyword">if</span> (!contextWrapper || !_OSKextSetRequestArgument(callbackRecord,
            kKextRequestArgumentContextKey, contextWrapper)) {

            result = kOSKextReturnNoMemory;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

   <span class="enscript-comment">/* Only post the requests after all the other potential failure points
    * have been passed.
    */</span>
    <span class="enscript-keyword">if</span> (!sKernelRequests-&gt;setObject(requestDict) ||
        !sRequestCallbackRecords-&gt;setObject(callbackRecord)) {

        result = kOSKextReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-reference">OSKext</span>::pingKextd();

    result = kOSReturnSuccess;
    <span class="enscript-keyword">if</span> (requestTagOut) {
        *requestTagOut = requestTag;
    }

<span class="enscript-reference">finish</span>:

   <span class="enscript-comment">/* If we didn't succeed, yank the request &amp; callback
    * from their holding arrays.
    */</span>
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index;
        
        index = sKernelRequests-&gt;getNextIndexOfObject(requestDict, 0);
        <span class="enscript-keyword">if</span> (index != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1) {
            sKernelRequests-&gt;removeObject(index);
        }
        index = sRequestCallbackRecords-&gt;getNextIndexOfObject(callbackRecord, 0);
        <span class="enscript-keyword">if</span> (index != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1) {
            sRequestCallbackRecords-&gt;removeObject(index);
        }
    }

    <span class="enscript-reference">OSKext</span>::considerUnloads(<span class="enscript-comment">/* rescheduleOnly? */</span> true);

    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">if</span> (callbackKext)    callbackKext-&gt;release();
    <span class="enscript-keyword">if</span> (requestTagNum)   requestTagNum-&gt;release();

    <span class="enscript-keyword">if</span> (requestDict)     requestDict-&gt;release();
    <span class="enscript-keyword">if</span> (kextIdentifier)  kextIdentifier-&gt;release();
    <span class="enscript-keyword">if</span> (resourceName)    resourceName-&gt;release();

    <span class="enscript-keyword">if</span> (callbackRecord)  callbackRecord-&gt;release();
    <span class="enscript-keyword">if</span> (callbackWrapper) callbackWrapper-&gt;release();
    <span class="enscript-keyword">if</span> (contextWrapper)  contextWrapper-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::dequeueCallbackForRequestTag</span>(
    OSKextRequestTag    requestTag,
    OSDictionary     ** callbackRecordOut)
{
    OSReturn   result = kOSReturnError;
    OSNumber * requestTagNum  = NULL;  <span class="enscript-comment">// must release
</span>
    requestTagNum  = OSNumber::withNumber((<span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)requestTag,
        8 * <span class="enscript-keyword">sizeof</span>(requestTag));
    <span class="enscript-keyword">if</span> (!requestTagNum) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = OSKext::dequeueCallbackForRequestTag(requestTagNum,
        callbackRecordOut);

<span class="enscript-reference">finish</span>:
    OSSafeRelease(requestTagNum);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::dequeueCallbackForRequestTag</span>(
    OSNumber     *    requestTagNum,
    OSDictionary ** callbackRecordOut)
{
    OSReturn        result          = kOSKextReturnInvalidArgument;
    OSDictionary  * callbackRecord  = NULL;  <span class="enscript-comment">// retain if matched!
</span>    OSNumber      * callbackTagNum  = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    count, i;

    result = kOSReturnError;
    count = sRequestCallbackRecords-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        callbackRecord = OSDynamicCast(OSDictionary,
            sRequestCallbackRecords-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!callbackRecord) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* If we don't find a tag, we basically have a leak here. Maybe
        * we should just remove it.
        */</span>
        callbackTagNum = OSDynamicCast(OSNumber, _OSKextGetRequestArgument(
            callbackRecord, kKextRequestArgumentRequestTagKey));
        <span class="enscript-keyword">if</span> (!callbackTagNum) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* We could be even more paranoid and check that all the incoming
        * args match what's in the callback record.
        */</span>
        <span class="enscript-keyword">if</span> (callbackTagNum-&gt;isEqualTo(requestTagNum)) {
            <span class="enscript-keyword">if</span> (callbackRecordOut) {
                *callbackRecordOut = callbackRecord;
                callbackRecord-&gt;retain();
            }
            sRequestCallbackRecords-&gt;removeObject(i);
            result = kOSReturnSuccess;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    result = kOSKextReturnNotFound;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::dispatchResource</span>(OSDictionary * requestDict)
{
    OSReturn                        result          = kOSReturnError;
    OSDictionary                  * callbackRecord  = NULL;  <span class="enscript-comment">// must release
</span>    OSNumber                      * requestTag      = NULL;  <span class="enscript-comment">// do not release
</span>    OSNumber                      * requestResult   = NULL;  <span class="enscript-comment">// do not release
</span>    OSData                        * dataObj         = NULL;  <span class="enscript-comment">// do not release
</span>    uint32_t                        dataLength      = 0;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>                    * dataPtr         = NULL;  <span class="enscript-comment">// do not free
</span>    OSData                        * callbackWrapper = NULL;  <span class="enscript-comment">// do not release
</span>    OSKextRequestResourceCallback   callback        = NULL;
    OSData                        * contextWrapper  = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">void</span>                          * context         = NULL;  <span class="enscript-comment">// do not free
</span>    OSKext                        * callbackKext    = NULL;  <span class="enscript-comment">// must release (looked up)
</span>
   <span class="enscript-comment">/* Get the args from the request. Right now we need the tag
    * to look up the callback record, and the result for invoking the callback.
    */</span>
    requestTag = OSDynamicCast(OSNumber, _OSKextGetRequestArgument(requestDict,
        kKextRequestArgumentRequestTagKey));
    requestResult = OSDynamicCast(OSNumber, _OSKextGetRequestArgument(requestDict,
        kKextRequestArgumentResultKey));
    <span class="enscript-keyword">if</span> (!requestTag || !requestResult) {
        result = kOSKextReturnInvalidArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Look for a callback record matching this request's tag.
    */</span>
    result = dequeueCallbackForRequestTag(requestTag, &amp;callbackRecord);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/*****
    * Get the context pointer of the callback record (if there is one).
    */</span>
    contextWrapper = OSDynamicCast(OSData, _OSKextGetRequestArgument(callbackRecord,
        kKextRequestArgumentContextKey));
    context = _OSKextExtractPointer(contextWrapper);
    <span class="enscript-keyword">if</span> (contextWrapper &amp;&amp; !context) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    callbackWrapper = OSDynamicCast(OSData,
        _OSKextGetRequestArgument(callbackRecord,
            kKextRequestArgumentCallbackKey));
    callback = (OSKextRequestResourceCallback)
        _OSKextExtractPointer(callbackWrapper);
    <span class="enscript-keyword">if</span> (!callback) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Check for a data obj. We might not have one and that's ok, that means
    * we didn't find the requested resource, and we still have to tell the
    * caller that via the callback.
    */</span>
    dataObj = OSDynamicCast(OSData, _OSKextGetRequestArgument(requestDict,
        kKextRequestArgumentValueKey));
    <span class="enscript-keyword">if</span> (dataObj) {
        dataPtr = dataObj-&gt;getBytesNoCopy();
        dataLength = dataObj-&gt;getLength();
    }
    
    callbackKext = OSKext::lookupKextWithAddress((vm_address_t)callback);
    <span class="enscript-keyword">if</span> (!callbackKext) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Can't invoke callback for resource request; &quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (!callbackKext-&gt;flags.starting &amp;&amp; !callbackKext-&gt;flags.started) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel | kOSKextLogIPCFlag,
            <span class="enscript-string">&quot;Can't invoke kext resource callback; &quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    (<span class="enscript-type">void</span>)callback(requestTag-&gt;unsigned32BitValue(),
        (OSReturn)requestResult-&gt;unsigned32BitValue(),
        dataPtr, dataLength, context);
        
    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (callbackKext)   callbackKext-&gt;release();
    <span class="enscript-keyword">if</span> (callbackRecord) callbackRecord-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::invokeRequestCallback</span>(
    OSDictionary * callbackRecord,
    OSReturn       callbackResult)
{
    OSString * predicate  = _OSKextGetRequestPredicate(callbackRecord);
    OSNumber * resultNum  = NULL;  <span class="enscript-comment">// must release
</span>
    <span class="enscript-keyword">if</span> (!predicate) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    resultNum  = OSNumber::withNumber((<span class="enscript-type">long</span> <span class="enscript-type">long</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)callbackResult,
        8 * <span class="enscript-keyword">sizeof</span>(callbackResult));
    <span class="enscript-keyword">if</span> (!resultNum) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
   <span class="enscript-comment">/* Insert the result into the callback record and dispatch it as if it
    * were the reply coming down from user space.
    */</span>
    _OSKextSetRequestArgument(callbackRecord, kKextRequestArgumentResultKey,
        resultNum);

    <span class="enscript-keyword">if</span> (predicate-&gt;isEqualTo(kKextRequestPredicateRequestResource)) {
       <span class="enscript-comment">/* This removes the pending callback record.
        */</span>
        <span class="enscript-reference">OSKext</span>::dispatchResource(callbackRecord);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (resultNum) resultNum-&gt;release();
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSReturn
<span class="enscript-function-name">OSKext::cancelRequest</span>(
    OSKextRequestTag    requestTag,
    <span class="enscript-type">void</span>             ** contextOut)
{
    OSReturn       result         = kOSKextReturnNoMemory;
    OSDictionary * callbackRecord = NULL;  <span class="enscript-comment">// must release
</span>    OSData       * contextWrapper = NULL;  <span class="enscript-comment">// do not release
</span>
    IORecursiveLockLock(sKextLock);
    result = OSKext::dequeueCallbackForRequestTag(requestTag,
        &amp;callbackRecord);
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">if</span> (result == kOSReturnSuccess &amp;&amp; contextOut) {
        contextWrapper = OSDynamicCast(OSData,
            _OSKextGetRequestArgument(callbackRecord,
                kKextRequestArgumentContextKey));
        *contextOut = _OSKextExtractPointer(contextWrapper);
    }
        
    <span class="enscript-keyword">if</span> (callbackRecord) callbackRecord-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::invokeOrCancelRequestCallbacks</span>(
    OSReturn callbackResult,
    <span class="enscript-type">bool</span>     invokeFlag)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count, i;
    
    count = sRequestCallbackRecords-&gt;getCount();
    <span class="enscript-keyword">if</span> (!count) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    i = count - 1;
    <span class="enscript-keyword">do</span> {
        OSDictionary * request = OSDynamicCast(OSDictionary,
            sRequestCallbackRecords-&gt;getObject(i));

        <span class="enscript-keyword">if</span> (!request) {
            <span class="enscript-keyword">continue</span>;
        }
        OSData * callbackWrapper = OSDynamicCast(OSData,
            _OSKextGetRequestArgument(request,
                kKextRequestArgumentCallbackKey));
            
        <span class="enscript-keyword">if</span> (!callbackWrapper) {
            sRequestCallbackRecords-&gt;removeObject(i);
            <span class="enscript-keyword">continue</span>;
        }

        vm_address_t callbackAddress = (vm_address_t)
            _OSKextExtractPointer(callbackWrapper);

        <span class="enscript-keyword">if</span> ((kmod_info-&gt;address &lt;= callbackAddress) &amp;&amp;
            (callbackAddress &lt; (kmod_info-&gt;address + kmod_info-&gt;size))) {

            <span class="enscript-keyword">if</span> (invokeFlag) {
               <span class="enscript-comment">/* This removes the callback record.
                */</span>
                invokeRequestCallback(request, callbackResult);
            } <span class="enscript-keyword">else</span> {
                sRequestCallbackRecords-&gt;removeObject(i);
            }
        }
    } <span class="enscript-keyword">while</span> (i--);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
uint32_t
<span class="enscript-function-name">OSKext::countRequestCallbacks</span>(<span class="enscript-type">void</span>)
{
    uint32_t     result = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count, i;
    
    count = sRequestCallbackRecords-&gt;getCount();
    <span class="enscript-keyword">if</span> (!count) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    i = count - 1;
    <span class="enscript-keyword">do</span> {
        OSDictionary * request = OSDynamicCast(OSDictionary,
            sRequestCallbackRecords-&gt;getObject(i));

        <span class="enscript-keyword">if</span> (!request) {
            <span class="enscript-keyword">continue</span>;
        }
        OSData * callbackWrapper = OSDynamicCast(OSData,
            _OSKextGetRequestArgument(request,
                kKextRequestArgumentCallbackKey));
            
        <span class="enscript-keyword">if</span> (!callbackWrapper) {
            <span class="enscript-keyword">continue</span>;
        }

        vm_address_t callbackAddress = (vm_address_t)
            _OSKextExtractPointer(callbackWrapper);

        <span class="enscript-keyword">if</span> ((kmod_info-&gt;address &lt;= callbackAddress) &amp;&amp;
            (callbackAddress &lt; (kmod_info-&gt;address + kmod_info-&gt;size))) {

            result++;
        }
    } <span class="enscript-keyword">while</span> (i--);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> OSReturn <span class="enscript-function-name">_OSKextCreateRequest</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>    * predicate,
    OSDictionary ** requestP)
{
    OSReturn result = kOSKextReturnNoMemory;
    OSDictionary * request = NULL;  <span class="enscript-comment">// must release on error
</span>    
    request = OSDictionary::withCapacity(2);
    <span class="enscript-keyword">if</span> (!request) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    result = _OSDictionarySetCStringValue(request,
        kKextRequestPredicateKey, predicate);
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    result = kOSReturnSuccess;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (result != kOSReturnSuccess) {
        <span class="enscript-keyword">if</span> (request) request-&gt;release();
    } <span class="enscript-keyword">else</span> {
        *requestP = request;
    }

    <span class="enscript-keyword">return</span> result;
}
    
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> OSString * <span class="enscript-function-name">_OSKextGetRequestPredicate</span>(OSDictionary * requestDict)
{
    <span class="enscript-keyword">return</span> OSDynamicCast(OSString,
        requestDict-&gt;getObject(kKextRequestPredicateKey));
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> OSObject * <span class="enscript-function-name">_OSKextGetRequestArgument</span>(
    OSDictionary * requestDict,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * argName)
{
    OSDictionary * args = OSDynamicCast(OSDictionary,
        requestDict-&gt;getObject(kKextRequestArgumentsKey));
    <span class="enscript-keyword">if</span> (args) {
        <span class="enscript-keyword">return</span> args-&gt;getObject(argName);
    }
    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_OSKextSetRequestArgument</span>(
    OSDictionary * requestDict,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * argName,
    OSObject     * value)
{
    OSDictionary * args = OSDynamicCast(OSDictionary,
        requestDict-&gt;getObject(kKextRequestArgumentsKey));
    <span class="enscript-keyword">if</span> (!args) {
        args = OSDictionary::withCapacity(2);
        <span class="enscript-keyword">if</span> (!args) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        requestDict-&gt;setObject(kKextRequestArgumentsKey, args);
        args-&gt;release();
    }
    <span class="enscript-keyword">if</span> (args) {
        <span class="enscript-keyword">return</span> args-&gt;setObject(argName, value);
    }
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">_OSKextExtractPointer</span>(OSData * wrapper)
{
    <span class="enscript-type">void</span>       * result = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * resultPtr = NULL;
    
    <span class="enscript-keyword">if</span> (!wrapper) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    resultPtr = wrapper-&gt;getBytesNoCopy();
    result = *(<span class="enscript-type">void</span> **)resultPtr;
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> OSReturn <span class="enscript-function-name">_OSDictionarySetCStringValue</span>(
    OSDictionary * dict,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * cKey,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * cValue)
{
    OSReturn result = kOSKextReturnNoMemory;
    <span class="enscript-type">const</span> OSSymbol * key = NULL;  <span class="enscript-comment">// must release
</span>    OSString * value = NULL;  <span class="enscript-comment">// must release
</span>    
    key = OSSymbol::withCString(cKey);
    value = OSString::withCString(cValue);
    <span class="enscript-keyword">if</span> (!key || !value) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">if</span> (dict-&gt;setObject(key, value)) {
        result = kOSReturnSuccess;
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (key)   key-&gt;release();
    <span class="enscript-keyword">if</span> (value) value-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_OSArrayContainsCString</span>(
    OSArray    * array,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * cString)
{
    <span class="enscript-type">bool</span>             result = false;
    <span class="enscript-type">const</span> OSSymbol * symbol = NULL;
    uint32_t         count, i;
    
    <span class="enscript-keyword">if</span> (!array || !cString) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    symbol = OSSymbol::withCStringNoCopy(cString);
    <span class="enscript-keyword">if</span> (!symbol) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    count = array-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
        OSObject * thisObject = array-&gt;getObject(i);
        <span class="enscript-keyword">if</span> (symbol-&gt;isEqualTo(thisObject)) {
            result = true;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (symbol) symbol-&gt;release();
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
 * We really only care about boot / system start up related kexts. 
 * We return true if we're less than REBUILD_MAX_TIME since start up,
 * otherwise return false.
 *********************************************************************/</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">_OSKextInPrelinkRebuildWindow</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">static</span> <span class="enscript-type">bool</span>     outside_the_window = false;
    AbsoluteTime    my_abstime;
    UInt64          my_ns;
    SInt32          my_secs;
    
    <span class="enscript-keyword">if</span> (outside_the_window) {
        <span class="enscript-keyword">return</span>(false);
    }
    clock_get_uptime(&amp;my_abstime);
    absolutetime_to_nanoseconds(my_abstime, &amp;my_ns);
    my_secs = (SInt32)(my_ns / NSEC_PER_SEC);
    <span class="enscript-keyword">if</span> (my_secs &gt; REBUILD_MAX_TIME) {
        outside_the_window = true;
        <span class="enscript-keyword">return</span>(false);
    }
    <span class="enscript-keyword">return</span>(true);
}

<span class="enscript-comment">/*********************************************************************
 *********************************************************************/</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">_OSKextInUnloadedPrelinkedKexts</span>( <span class="enscript-type">const</span> OSSymbol * theBundleID )
{
    <span class="enscript-type">int</span> unLoadedCount, i;
    <span class="enscript-type">bool</span> result = false;
    
    IORecursiveLockLock(sKextLock);
    
    <span class="enscript-keyword">if</span> (sUnloadedPrelinkedKexts == NULL) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    unLoadedCount = sUnloadedPrelinkedKexts-&gt;getCount();
    <span class="enscript-keyword">if</span> (unLoadedCount == 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">for</span> (i = 0; i &lt; unLoadedCount; i++) {
        <span class="enscript-type">const</span> OSSymbol *    myBundleID;     <span class="enscript-comment">// do not release
</span>        
        myBundleID = OSDynamicCast(OSSymbol, sUnloadedPrelinkedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!myBundleID) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (theBundleID-&gt;isEqualTo(myBundleID-&gt;getCStringNoCopy())) {
            result = true;
            <span class="enscript-keyword">break</span>;
        }
    }
<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);
    <span class="enscript-keyword">return</span>(result);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Personalities</span> (<span class="enscript-variable-name">IOKit</span> <span class="enscript-variable-name">Drivers</span>)
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSArray *
<span class="enscript-function-name">OSKext::copyAllKextPersonalities</span>(<span class="enscript-type">bool</span> filterSafeBootFlag)
{
    OSArray              * result                = NULL;  <span class="enscript-comment">// returned
</span>    OSCollectionIterator * kextIterator          = NULL;  <span class="enscript-comment">// must release
</span>    OSArray              * personalities         = NULL;  <span class="enscript-comment">// must release
</span>    OSCollectionIterator * personalitiesIterator = NULL;  <span class="enscript-comment">// must release
</span>
    OSString             * kextID                = NULL;  <span class="enscript-comment">// do not release
</span>    OSKext               * theKext               = NULL;  <span class="enscript-comment">// do not release
</span>    
    IORecursiveLockLock(sKextLock);

   <span class="enscript-comment">/* Let's conservatively guess that any given kext has around 3
    * personalities for now.
    */</span>
    result = OSArray::withCapacity(sKextsByID-&gt;getCount() * 3);
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    kextIterator = OSCollectionIterator::withCollection(sKextsByID);
    <span class="enscript-keyword">if</span> (!kextIterator) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">while</span> ((kextID = OSDynamicCast(OSString, kextIterator-&gt;getNextObject()))) {
        <span class="enscript-keyword">if</span> (personalitiesIterator) {
            personalitiesIterator-&gt;release();
            personalitiesIterator = NULL;
        }
        <span class="enscript-keyword">if</span> (personalities) {
            personalities-&gt;release();
            personalities = NULL;
        }
        
        theKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(kextID));
        <span class="enscript-keyword">if</span> (!sSafeBoot || !filterSafeBootFlag || theKext-&gt;isLoadableInSafeBoot()) {
            personalities = theKext-&gt;copyPersonalitiesArray();
            <span class="enscript-keyword">if</span> (!personalities) {
                <span class="enscript-keyword">continue</span>;
            }
            result-&gt;merge(personalities);
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// xxx - check for better place to put this log msg
</span>            OSKextLog(theKext,
                kOSKextLogWarningLevel |
                kOSKextLogLoadFlag,
                <span class="enscript-string">&quot;Kext %s is not loadable during safe boot; &quot;</span>
                <span class="enscript-string">&quot;omitting its personalities.&quot;</span>,
                theKext-&gt;getIdentifierCString());
        }

    }

<span class="enscript-reference">finish</span>:
    IORecursiveLockUnlock(sKextLock);

    <span class="enscript-keyword">if</span> (kextIterator)          kextIterator-&gt;release();
    <span class="enscript-keyword">if</span> (personalitiesIterator) personalitiesIterator-&gt;release();
    <span class="enscript-keyword">if</span> (personalities)         personalities-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::sendAllKextPersonalitiesToCatalog</span>(<span class="enscript-type">bool</span> startMatching)
{
    <span class="enscript-type">int</span> numPersonalities = 0;

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogStepLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Sending all eligible registered kexts' personalities &quot;</span>
        <span class="enscript-string">&quot;to the IOCatalogue %s.&quot;</span>,
        startMatching ? <span class="enscript-string">&quot;and starting matching&quot;</span> : <span class="enscript-string">&quot;but not starting matching&quot;</span>);

    OSArray * personalities = OSKext::copyAllKextPersonalities(
        <span class="enscript-comment">/* filterSafeBootFlag */</span> true);

    <span class="enscript-keyword">if</span> (personalities) {
        gIOCatalogue-&gt;addDrivers(personalities, startMatching);
        numPersonalities = personalities-&gt;getCount();
        personalities-&gt;release();
    }

    OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
        kOSKextLogStepLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;%d kext personalit%s sent to the IOCatalogue; %s.&quot;</span>,
        numPersonalities, numPersonalities &gt; 0 ? <span class="enscript-string">&quot;ies&quot;</span> : <span class="enscript-string">&quot;y&quot;</span>,
        startMatching ? <span class="enscript-string">&quot;matching started&quot;</span> : <span class="enscript-string">&quot;matching not started&quot;</span>);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Do not make a deep copy, just convert the IOKitPersonalities dict
* to an array for sending to the IOCatalogue.
*********************************************************************/</span>
OSArray *
<span class="enscript-function-name">OSKext::copyPersonalitiesArray</span>(<span class="enscript-type">void</span>)
{
    OSArray              * result                      = NULL;
    OSDictionary         * personalities               = NULL;  <span class="enscript-comment">// do not release
</span>    OSCollectionIterator * personalitiesIterator       = NULL;  <span class="enscript-comment">// must release
</span>
    OSString             * personalityName             = NULL;  <span class="enscript-comment">// do not release    
</span>    OSString             * personalityBundleIdentifier = NULL;  <span class="enscript-comment">// do not release
</span>
    personalities = OSDynamicCast(OSDictionary,
        getPropertyForHostArch(kIOKitPersonalitiesKey));
    <span class="enscript-keyword">if</span> (!personalities) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    result = OSArray::withCapacity(personalities-&gt;getCount());
    <span class="enscript-keyword">if</span> (!result) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    personalitiesIterator =
        <span class="enscript-reference">OSCollectionIterator</span>::withCollection(personalities);
    <span class="enscript-keyword">if</span> (!personalitiesIterator) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-keyword">while</span> ((personalityName = OSDynamicCast(OSString,
            personalitiesIterator-&gt;getNextObject()))) {
                
        OSDictionary * personality = OSDynamicCast(OSDictionary,
            personalities-&gt;getObject(personalityName));

       <span class="enscript-comment">/******
        * If the personality doesn't have a CFBundleIdentifier, or if it
        * differs from the kext's, insert the kext's ID so we can find it.
        * The publisher ID is used to remove personalities from bundles
        * correctly.
        */</span>
        personalityBundleIdentifier = OSDynamicCast(OSString,
            personality-&gt;getObject(kCFBundleIdentifierKey));

        <span class="enscript-keyword">if</span> (!personalityBundleIdentifier) {
            personality-&gt;setObject(kCFBundleIdentifierKey, bundleID);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!personalityBundleIdentifier-&gt;isEqualTo(bundleID)) {
            personality-&gt;setObject(kIOPersonalityPublisherKey, bundleID);
        }

        result-&gt;setObject(personality);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (personalitiesIterator) personalitiesIterator-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
Might want to change this to a bool return?
*********************************************************************/</span>
OSReturn
<span class="enscript-function-name">OSKext::sendPersonalitiesToCatalog</span>(
    <span class="enscript-type">bool</span>      startMatching,
    OSArray * personalityNames)
{
    OSReturn       result              = kOSReturnSuccess;
    OSArray      * personalitiesToSend = NULL;  <span class="enscript-comment">// must release
</span>    OSDictionary * kextPersonalities   = NULL;  <span class="enscript-comment">// do not release
</span>    <span class="enscript-type">int</span>            count, i;

    <span class="enscript-keyword">if</span> (!sLoadEnabled) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext loading is disabled (attempt to start matching for kext %s).&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnDisabled;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (sSafeBoot &amp;&amp; !isLoadableInSafeBoot()) {
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogErrorLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s is not loadable during safe boot; &quot;</span>
            <span class="enscript-string">&quot;not sending personalities to the IOCatalogue.&quot;</span>,
            getIdentifierCString());
        result = kOSKextReturnNotLoadable;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (!personalityNames || !personalityNames-&gt;getCount()) {
        personalitiesToSend = copyPersonalitiesArray();
    } <span class="enscript-keyword">else</span> {
        kextPersonalities = OSDynamicCast(OSDictionary,
            getPropertyForHostArch(kIOKitPersonalitiesKey));
        <span class="enscript-keyword">if</span> (!kextPersonalities || !kextPersonalities-&gt;getCount()) {
            <span class="enscript-comment">// not an error
</span>            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        personalitiesToSend = OSArray::withCapacity(0);
        <span class="enscript-keyword">if</span> (!personalitiesToSend) {
            result = kOSKextReturnNoMemory;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        count = personalityNames-&gt;getCount();
        <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
            OSString * name = OSDynamicCast(OSString,
                personalityNames-&gt;getObject(i));
            <span class="enscript-keyword">if</span> (!name) {
                <span class="enscript-keyword">continue</span>;
            }
            OSDictionary * personality = OSDynamicCast(OSDictionary,
                kextPersonalities-&gt;getObject(name));
            <span class="enscript-keyword">if</span> (personality) {
                personalitiesToSend-&gt;setObject(personality);
            }
        }
    }
    <span class="enscript-keyword">if</span> (personalitiesToSend) {
        <span class="enscript-type">unsigned</span> numPersonalities = personalitiesToSend-&gt;getCount();
        OSKextLog(<span class="enscript-keyword">this</span>,
            kOSKextLogStepLevel |
            kOSKextLogLoadFlag,
            <span class="enscript-string">&quot;Kext %s sending %d personalit%s to the IOCatalogue%s.&quot;</span>,
            getIdentifierCString(),
            numPersonalities,
            numPersonalities &gt; 1 ? <span class="enscript-string">&quot;ies&quot;</span> : <span class="enscript-string">&quot;y&quot;</span>,
            startMatching ? <span class="enscript-string">&quot; and starting matching&quot;</span> : <span class="enscript-string">&quot; but not starting matching&quot;</span>);
        gIOCatalogue-&gt;addDrivers(personalitiesToSend, startMatching);
    }
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (personalitiesToSend) {
        personalitiesToSend-&gt;release();
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* xxx - We should allow removing the kext's declared personalities,
* xxx - even with other bundle identifiers.
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::removePersonalitiesFromCatalog</span>(<span class="enscript-type">void</span>)
{
    OSDictionary * personality = NULL;   <span class="enscript-comment">// do not release
</span>
    personality = OSDictionary::withCapacity(1);
    <span class="enscript-keyword">if</span> (!personality) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    personality-&gt;setObject(kCFBundleIdentifierKey, getIdentifier());

    OSKextLog(<span class="enscript-keyword">this</span>,
        kOSKextLogStepLevel |
        kOSKextLogLoadFlag,
        <span class="enscript-string">&quot;Kext %s removing all personalities naming it from the IOCatalogue.&quot;</span>,
        getIdentifierCString());

   <span class="enscript-comment">/* Have the IOCatalog remove all personalities matching this kext's
    * bundle ID and trigger matching anew.
    */</span>
    gIOCatalogue-&gt;removeDrivers(personality, <span class="enscript-comment">/* startMatching */</span> true);

 <span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (personality) personality-&gt;release();

    <span class="enscript-keyword">return</span>;
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Logging</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSKextLogSpec
<span class="enscript-function-name">OSKext::setUserSpaceLogFilter</span>(
    OSKextLogSpec   newUserLogFilter,
    <span class="enscript-type">bool</span>            captureFlag)
{
    OSKextLogSpec result;
    <span class="enscript-type">bool</span>          allocError = false;

   <span class="enscript-comment">/* Do not call any function that takes sKextLoggingLock during
    * this critical block. That means do logging after.
    */</span>
    IOLockLock(sKextLoggingLock);

    result = sUserSpaceKextLogFilter;
    sUserSpaceKextLogFilter = newUserLogFilter;

    <span class="enscript-keyword">if</span> (newUserLogFilter &amp;&amp; captureFlag &amp;&amp;
        !sUserSpaceLogSpecArray &amp;&amp; !sUserSpaceLogMessageArray) {

        <span class="enscript-comment">// xxx - do some measurements for a good initial capacity?
</span>        sUserSpaceLogSpecArray = OSArray::withCapacity(0);
        sUserSpaceLogMessageArray = OSArray::withCapacity(0);
        
        <span class="enscript-keyword">if</span> (!sUserSpaceLogSpecArray || !sUserSpaceLogMessageArray) {
            OSSafeReleaseNULL(sUserSpaceLogSpecArray);
            OSSafeReleaseNULL(sUserSpaceLogMessageArray);
            allocError = true;
        }
    }

    IOLockUnlock(sKextLoggingLock);

   <span class="enscript-comment">/* If the config flag itself is changing, log the state change
    * going both ways, before setting up the user-space log arrays,
    * so that this is only logged in the kernel.
    */</span>
    <span class="enscript-keyword">if</span> (result != newUserLogFilter) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogDebugLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;User-space log flags changed from 0x%x to 0x%x.&quot;</span>,
            result, newUserLogFilter);
    }
    <span class="enscript-keyword">if</span> (allocError) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogErrorLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;Failed to allocate user-space log message arrays.&quot;</span>);
    }

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSArray *
<span class="enscript-function-name">OSKext::clearUserSpaceLogFilter</span>(<span class="enscript-type">void</span>)
{
    OSArray       * result       = NULL;
    OSKextLogSpec   oldLogFilter;
    OSKextLogSpec   newLogFilter = kOSKextLogSilentFilter;

   <span class="enscript-comment">/* Do not call any function that takes sKextLoggingLock during
    * this critical block. That means do logging after.
    */</span>
    IOLockLock(sKextLoggingLock);

    result = OSArray::withCapacity(2);
    <span class="enscript-keyword">if</span> (result) {
        result-&gt;setObject(sUserSpaceLogSpecArray);
        result-&gt;setObject(sUserSpaceLogMessageArray);
    }
    OSSafeReleaseNULL(sUserSpaceLogSpecArray);
    OSSafeReleaseNULL(sUserSpaceLogMessageArray);

    oldLogFilter = sUserSpaceKextLogFilter;
    sUserSpaceKextLogFilter = newLogFilter;

    IOLockUnlock(sKextLoggingLock);

   <span class="enscript-comment">/* If the config flag itself is changing, log the state change
    * going both ways, after tearing down the user-space log
    * arrays, so this is only logged within the kernel.
    */</span>
    <span class="enscript-keyword">if</span> (oldLogFilter != newLogFilter) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
            kOSKextLogDebugLevel |
            kOSKextLogGeneralFlag,
            <span class="enscript-string">&quot;User-space log flags changed from 0x%x to 0x%x.&quot;</span>,
            oldLogFilter, newLogFilter);
    }

    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">/*********************************************************************
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
OSKextLogSpec
<span class="enscript-function-name">OSKext::getUserSpaceLogFilter</span>(<span class="enscript-type">void</span>)
{
    OSKextLogSpec result;

    IOLockLock(sKextLoggingLock);
    result = sUserSpaceKextLogFilter;
    IOLockUnlock(sKextLoggingLock);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* This function is called by OSMetaClass during kernel C++ setup.
* Be careful what you access here; assume only OSKext::initialize()
* has been called.
*
* Do not call any function that takes sKextLock here!
*********************************************************************/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTRESET</span>   <span class="enscript-string">&quot;\033[0m&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTBOLD</span>    <span class="enscript-string">&quot;\033[1m&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTUNDER</span>   <span class="enscript-string">&quot;\033[4m&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTRED</span>     <span class="enscript-string">&quot;\033[31m&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTGREEN</span>   <span class="enscript-string">&quot;\033[32m&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTYELLOW</span>  <span class="enscript-string">&quot;\033[33m&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTBLUE</span>    <span class="enscript-string">&quot;\033[34m&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTMAGENTA</span> <span class="enscript-string">&quot;\033[35m&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VTCYAN</span>    <span class="enscript-string">&quot;\033[36m&quot;</span>

<span class="enscript-type">inline</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-function-name">colorForFlags</span>(OSKextLogSpec flags)
{
    OSKextLogSpec logLevel = flags &amp; kOSKextLogLevelMask;

    <span class="enscript-keyword">switch</span> (logLevel) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogErrorLevel</span>:
        <span class="enscript-keyword">return</span> VTRED VTBOLD;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogWarningLevel</span>:
        <span class="enscript-keyword">return</span> VTRED;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogBasicLevel</span>:
        <span class="enscript-keyword">return</span> VTYELLOW VTUNDER;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogProgressLevel</span>:
        <span class="enscript-keyword">return</span> VTYELLOW;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogStepLevel</span>:
        <span class="enscript-keyword">return</span> VTGREEN;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogDetailLevel</span>:
        <span class="enscript-keyword">return</span> VTCYAN;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kOSKextLogDebugLevel</span>:
        <span class="enscript-keyword">return</span> VTMAGENTA;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;&quot;</span>;  <span class="enscript-comment">// white
</span>        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;&quot;</span>;
}

<span class="enscript-type">inline</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">logSpecMatch</span>(
    OSKextLogSpec msgLogSpec,
    OSKextLogSpec logFilter)
{
    OSKextLogSpec filterKextGlobal  = logFilter &amp; kOSKextLogKextOrGlobalMask;
    OSKextLogSpec filterLevel       = logFilter &amp; kOSKextLogLevelMask;
    OSKextLogSpec filterFlags       = logFilter &amp; kOSKextLogFlagsMask;

    OSKextLogSpec msgKextGlobal    = msgLogSpec &amp; kOSKextLogKextOrGlobalMask;
    OSKextLogSpec msgLevel         = msgLogSpec &amp; kOSKextLogLevelMask;
    OSKextLogSpec msgFlags         = msgLogSpec &amp; kOSKextLogFlagsMask;

   <span class="enscript-comment">/* Explicit messages always get logged.
    */</span>
    <span class="enscript-keyword">if</span> (msgLevel == kOSKextLogExplicitLevel) {
        <span class="enscript-keyword">return</span> true;
    }

   <span class="enscript-comment">/* Warnings and errors are logged regardless of the flags.
    */</span>
    <span class="enscript-keyword">if</span> (msgLevel &lt;= kOSKextLogBasicLevel &amp;&amp; (msgLevel &lt;= filterLevel)) {
        <span class="enscript-keyword">return</span> true;
    }

   <span class="enscript-comment">/* A verbose message that isn't for a logging-enabled kext and isn't global
    * does *not* get logged.
    */</span>
    <span class="enscript-keyword">if</span> (!msgKextGlobal &amp;&amp; !filterKextGlobal) {
        <span class="enscript-keyword">return</span> false;
    }

   <span class="enscript-comment">/* Warnings and errors are logged regardless of the flags.
    * All other messages must fit the flags and
    * have a level at or below the filter.
    *
    */</span>
    <span class="enscript-keyword">if</span> ((msgFlags &amp; filterFlags) &amp;&amp; (msgLevel &lt;= filterLevel)) {
        <span class="enscript-keyword">return</span> true;
    }
    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKextLog</span>(
    OSKext         * aKext,
    OSKextLogSpec    msgLogSpec,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>     * format, ...)
{
    va_list argList;

    va_start(argList, format);
    OSKextVLog(aKext, msgLogSpec, format, argList);
    va_end(argList);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKextVLog</span>(
    OSKext         * aKext,
    OSKextLogSpec    msgLogSpec,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>     * format,
    va_list          srcArgList)
{
    <span class="enscript-type">extern</span> <span class="enscript-type">int</span>       disableConsoleOutput;

    <span class="enscript-type">bool</span>             logForKernel       = false;
    <span class="enscript-type">bool</span>             logForUser         = false;
    va_list          argList;
    <span class="enscript-type">char</span>             stackBuffer[120];
    uint32_t         length            = 0;
    <span class="enscript-type">char</span>           * allocBuffer       = NULL;         <span class="enscript-comment">// must kfree
</span>    OSNumber       * logSpecNum        = NULL;         <span class="enscript-comment">// must release
</span>    OSString       * logString         = NULL;         <span class="enscript-comment">// must release
</span>    <span class="enscript-type">char</span>           * buffer            = stackBuffer;  <span class="enscript-comment">// do not free
</span>
    IOLockLock(sKextLoggingLock);

   <span class="enscript-comment">/* Set the kext/global bit in the message spec if we have no
    * kext or if the kext requests logging.
    */</span>
    <span class="enscript-keyword">if</span> (!aKext || aKext-&gt;flags.loggingEnabled) {
        msgLogSpec = msgLogSpec | kOSKextLogKextOrGlobalMask;
    }

    logForKernel = logSpecMatch(msgLogSpec, sKernelLogFilter);
    <span class="enscript-keyword">if</span> (sUserSpaceLogSpecArray &amp;&amp; sUserSpaceLogMessageArray) {
        logForUser = logSpecMatch(msgLogSpec, sUserSpaceKextLogFilter);
    }

    <span class="enscript-keyword">if</span> (! (logForKernel || logForUser) ) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
   <span class="enscript-comment">/* No goto from here until past va_end()!
    */</span>    
    va_copy(argList, srcArgList);
    length = vsnprintf(stackBuffer, <span class="enscript-keyword">sizeof</span>(stackBuffer), format, argList);
    va_end(argList);

    <span class="enscript-keyword">if</span> (length + 1 &gt;= <span class="enscript-keyword">sizeof</span>(stackBuffer)) {
        allocBuffer = (<span class="enscript-type">char</span> *)kalloc_tag((length + 1) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>), VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (!allocBuffer) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

       <span class="enscript-comment">/* No goto from here until past va_end()!
        */</span>    
        va_copy(argList, srcArgList);
        vsnprintf(allocBuffer, length + 1, format, argList);
        va_end(argList);

        buffer = allocBuffer;
    }

   <span class="enscript-comment">/* If user space wants the log message, queue it up.
    */</span>
    <span class="enscript-keyword">if</span> (logForUser &amp;&amp; sUserSpaceLogSpecArray &amp;&amp; sUserSpaceLogMessageArray) {
        logSpecNum = OSNumber::withNumber(msgLogSpec, 8 * <span class="enscript-keyword">sizeof</span>(msgLogSpec));
        logString = OSString::withCString(buffer);
        <span class="enscript-keyword">if</span> (logSpecNum &amp;&amp; logString) {
            sUserSpaceLogSpecArray-&gt;setObject(logSpecNum);
            sUserSpaceLogMessageArray-&gt;setObject(logString);
        }
    }

   <span class="enscript-comment">/* Always log messages from the kernel according to the kernel's
    * log flags.
    */</span>
    <span class="enscript-keyword">if</span> (logForKernel) {

       <span class="enscript-comment">/* If we are in console mode and have a custom log filter,
        * colorize the log message.
        */</span>
        <span class="enscript-keyword">if</span> (!disableConsoleOutput &amp;&amp; sBootArgLogFilterFound) {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> * color = <span class="enscript-string">&quot;&quot;</span>;  <span class="enscript-comment">// do not free
</span>            color = colorForFlags(msgLogSpec);
            printf(<span class="enscript-string">&quot;%s%s%s\n&quot;</span>, colorForFlags(msgLogSpec),
                buffer, color[0] ? VTRESET : <span class="enscript-string">&quot;&quot;</span>);
        } <span class="enscript-keyword">else</span> {
            printf(<span class="enscript-string">&quot;%s\n&quot;</span>, buffer);
        }
    }

<span class="enscript-reference">finish</span>:
    IOLockUnlock(sKextLoggingLock);

    <span class="enscript-keyword">if</span> (allocBuffer) {
        kfree(allocBuffer, (length + 1) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
    }
    OSSafeRelease(logString);
    OSSafeRelease(logSpecNum);
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_IOREG_DEBUG</span>
    
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOLOG_INDENT</span>( the_indention ) \
{ \
    <span class="enscript-type">int</span>     i; \
    <span class="enscript-keyword">for</span> ( i = 0; i &lt; (the_indention); i++ ) { \
        IOLog(<span class="enscript-string">&quot; &quot;</span>); \
    } \
}
    
<span class="enscript-type">extern</span> vm_offset_t	 vm_kernel_stext;
<span class="enscript-type">extern</span> vm_offset_t	 vm_kernel_etext;
<span class="enscript-type">extern</span> mach_vm_offset_t kext_alloc_base; 
<span class="enscript-type">extern</span> mach_vm_offset_t kext_alloc_max;
    
<span class="enscript-type">bool</span> <span class="enscript-function-name">ScanForAddrInObject</span>(OSObject * theObject, 
                         <span class="enscript-type">int</span> indent );

<span class="enscript-type">bool</span> <span class="enscript-function-name">ScanForAddrInObject</span>(OSObject * theObject, 
                         <span class="enscript-type">int</span> indent)
{
    <span class="enscript-type">const</span> OSMetaClass *     myTypeID;
    OSCollectionIterator *  myIter;
    OSSymbol *              myKey;
    OSObject *              myValue;
    <span class="enscript-type">bool</span>                    myResult = false;
    
    <span class="enscript-keyword">if</span> ( theObject == NULL ) {
        IOLog(<span class="enscript-string">&quot;%s: theObject is NULL \n&quot;</span>, 
              __FUNCTION__);
        <span class="enscript-keyword">return</span> myResult;
    }
    
    myTypeID = OSTypeIDInst(theObject);
    
    <span class="enscript-keyword">if</span> ( myTypeID == OSTypeID(OSDictionary) ) {
        OSDictionary *      myDictionary;
        
        myDictionary = OSDynamicCast(OSDictionary, theObject);
        myIter = OSCollectionIterator::withCollection( myDictionary );
        <span class="enscript-keyword">if</span> ( myIter == NULL ) 
            <span class="enscript-keyword">return</span> myResult;
        myIter-&gt;reset();
        
        <span class="enscript-keyword">while</span> ( (myKey = OSDynamicCast(OSSymbol, myIter-&gt;getNextObject())) ) {
            <span class="enscript-type">bool</span>    myTempResult;
            
            myValue = myDictionary-&gt;getObject(myKey);
            myTempResult = ScanForAddrInObject(myValue, (indent + 4));
            <span class="enscript-keyword">if</span> (myTempResult) {
                <span class="enscript-comment">// if we ever get a true result return true
</span>                myResult = true;
                IOLOG_INDENT(indent);
                IOLog(<span class="enscript-string">&quot;OSDictionary key \&quot;%s\&quot; \n&quot;</span>, myKey-&gt;getCStringNoCopy());
            }
        }
        myIter-&gt;release();
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( myTypeID == OSTypeID(OSArray) ) {
        OSArray *   myArray;
        
        myArray = OSDynamicCast(OSArray, theObject);
        myIter = OSCollectionIterator::withCollection(myArray);
        <span class="enscript-keyword">if</span> ( myIter == NULL ) 
            <span class="enscript-keyword">return</span> myResult;
        myIter-&gt;reset();
        
        <span class="enscript-keyword">while</span> ( (myValue = myIter-&gt;getNextObject()) ) {
            <span class="enscript-type">bool</span>        myTempResult;
            myTempResult = ScanForAddrInObject(myValue, (indent + 4));
            <span class="enscript-keyword">if</span> (myTempResult) {
                <span class="enscript-comment">// if we ever get a true result return true
</span>                myResult = true;
                IOLOG_INDENT(indent);
                IOLog(<span class="enscript-string">&quot;OSArray: \n&quot;</span>);
            }
        }
        myIter-&gt;release();
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( myTypeID == OSTypeID(OSString) || myTypeID == OSTypeID(OSSymbol) ) {
        
        <span class="enscript-comment">// should we look for addresses in strings?
</span>    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( myTypeID == OSTypeID(OSData) ) {
        
        <span class="enscript-type">void</span> * *        myPtrPtr;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    myLen;
        OSData *        myDataObj;
        
        myDataObj =    OSDynamicCast(OSData, theObject);
        myPtrPtr = (<span class="enscript-type">void</span> * *) myDataObj-&gt;getBytesNoCopy();
        myLen = myDataObj-&gt;getLength();
        
        <span class="enscript-keyword">if</span> (myPtrPtr &amp;&amp; myLen &amp;&amp; myLen &gt; 7) {
            <span class="enscript-type">int</span>     i;
            <span class="enscript-type">int</span>     myPtrCount = (myLen / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *));
            
            <span class="enscript-keyword">for</span> (i = 0; i &lt; myPtrCount; i++) {
                UInt64 numberValue = (UInt64) *(myPtrPtr);
                
                <span class="enscript-keyword">if</span> ( kext_alloc_max != 0 &amp;&amp;
                    numberValue &gt;= kext_alloc_base &amp;&amp; 
                    numberValue &lt; kext_alloc_max ) {
                    
                    OSKext * myKext    = NULL;  <span class="enscript-comment">// must release (looked up)
</span>                                                <span class="enscript-comment">// IOLog(&quot;found OSData %p in kext map %p to %p  \n&quot;,
</span>                                                <span class="enscript-comment">//       *(myPtrPtr),
</span>                                                <span class="enscript-comment">//       (void *) kext_alloc_base,
</span>                                                <span class="enscript-comment">//       (void *) kext_alloc_max);
</span>                    
                    myKext = OSKext::lookupKextWithAddress( (vm_address_t) *(myPtrPtr) );
                    <span class="enscript-keyword">if</span> (myKext) {
                        IOLog(<span class="enscript-string">&quot;found addr %p from an OSData obj within kext \&quot;%s\&quot;  \n&quot;</span>,
                              *(myPtrPtr),
                              myKext-&gt;getIdentifierCString());
                        myKext-&gt;release();
                    }
                    myResult = true;
                }
                <span class="enscript-keyword">if</span> ( vm_kernel_etext != 0 &amp;&amp;
                    numberValue &gt;= vm_kernel_stext &amp;&amp; 
                    numberValue &lt; vm_kernel_etext ) {
                    IOLog(<span class="enscript-string">&quot;found addr %p from an OSData obj within kernel text segment %p to %p  \n&quot;</span>,
                          *(myPtrPtr),
                          (<span class="enscript-type">void</span> *) vm_kernel_stext,
                          (<span class="enscript-type">void</span> *) vm_kernel_etext);
                    myResult = true;
                }
                myPtrPtr++;
            }
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( myTypeID == OSTypeID(OSBoolean) ) {
        
        <span class="enscript-comment">// do nothing here...
</span>    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( myTypeID == OSTypeID(OSNumber) ) {
        
        OSNumber * number = OSDynamicCast(OSNumber, theObject);
        
        UInt64 numberValue = number-&gt;unsigned64BitValue();
        
        <span class="enscript-keyword">if</span> ( kext_alloc_max != 0 &amp;&amp;
            numberValue &gt;= kext_alloc_base &amp;&amp; 
            numberValue &lt; kext_alloc_max ) {
            
            OSKext * myKext    = NULL;  <span class="enscript-comment">// must release (looked up)
</span>            IOLog(<span class="enscript-string">&quot;found OSNumber in kext map %p to %p  \n&quot;</span>,
                  (<span class="enscript-type">void</span> *) kext_alloc_base,
                  (<span class="enscript-type">void</span> *) kext_alloc_max);
            IOLog(<span class="enscript-string">&quot;OSNumber 0x%08llx (%llu) \n&quot;</span>, numberValue, numberValue);
            
            myKext = OSKext::lookupKextWithAddress( (vm_address_t) numberValue );
            <span class="enscript-keyword">if</span> (myKext) {
                IOLog(<span class="enscript-string">&quot;found in kext \&quot;%s\&quot;  \n&quot;</span>,
                      myKext-&gt;getIdentifierCString());
                myKext-&gt;release();
            }
            
            myResult = true;
        }
        <span class="enscript-keyword">if</span> ( vm_kernel_etext != 0 &amp;&amp;
            numberValue &gt;= vm_kernel_stext &amp;&amp; 
            numberValue &lt; vm_kernel_etext ) {
            IOLog(<span class="enscript-string">&quot;found OSNumber in kernel text segment %p to %p  \n&quot;</span>,
                  (<span class="enscript-type">void</span> *) vm_kernel_stext,
                  (<span class="enscript-type">void</span> *) vm_kernel_etext);
            IOLog(<span class="enscript-string">&quot;OSNumber 0x%08llx (%llu) \n&quot;</span>, numberValue, numberValue);
            myResult = true;
        }
    }
#<span class="enscript-reference">if</span> 0
    <span class="enscript-keyword">else</span> {
        <span class="enscript-type">const</span> OSMetaClass* myMetaClass = NULL;
        
        myMetaClass = theObject-&gt;getMetaClass();
        <span class="enscript-keyword">if</span> ( myMetaClass ) {
            IOLog(<span class="enscript-string">&quot;class %s \n&quot;</span>, myMetaClass-&gt;getClassName() );
        }
        <span class="enscript-keyword">else</span> {
            IOLog(<span class="enscript-string">&quot;Unknown object \n&quot;</span> );
        }
    }
#<span class="enscript-reference">endif</span>
    
    <span class="enscript-keyword">return</span> myResult;
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">KASLR_KEXT_DEBUG</span> 

}; <span class="enscript-comment">/* extern &quot;C&quot; */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Backtrace</span> <span class="enscript-variable-name">Dump</span> &amp; <span class="enscript-variable-name">kmod_get_info</span>() <span class="enscript-variable-name">support</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
* This function must be safe to call in panic context.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::printKextsInBacktrace</span>(
    vm_offset_t  * addr,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>   cnt,
    <span class="enscript-type">int</span>         (* printf_func)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...),
    <span class="enscript-type">bool</span>           lockFlag,
    <span class="enscript-type">bool</span>           doUnslide)
{
    addr64_t    summary_page = 0;
    addr64_t    last_summary_page = 0;
    <span class="enscript-type">bool</span>        found_kmod = false;
    u_int       i = 0;

    <span class="enscript-keyword">if</span> (lockFlag) {
        <span class="enscript-keyword">if</span> (!sKextSummariesLock) <span class="enscript-keyword">return</span>;
        IOLockLock(sKextSummariesLock);
    }

    <span class="enscript-keyword">if</span> (!gLoadedKextSummaries) {
        (*printf_func)(<span class="enscript-string">&quot;         can't perform kext scan: no kext summary&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    summary_page = trunc_page((addr64_t)(uintptr_t)gLoadedKextSummaries);
    last_summary_page = round_page(summary_page + sLoadedKextSummariesAllocSize);
    <span class="enscript-keyword">for</span> (; summary_page &lt; last_summary_page; summary_page += PAGE_SIZE) {
        <span class="enscript-keyword">if</span> (pmap_find_phys(kernel_pmap, summary_page) == 0) {
            (*printf_func)(<span class="enscript-string">&quot;         can't perform kext scan: &quot;</span>
                <span class="enscript-string">&quot;missing kext summary page %p&quot;</span>, summary_page);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; gLoadedKextSummaries-&gt;numSummaries; ++i) {
        OSKextLoadedKextSummary * summary;
        
        summary = gLoadedKextSummaries-&gt;summaries + i;
        <span class="enscript-keyword">if</span> (!summary-&gt;address) {
            <span class="enscript-keyword">continue</span>;
        }
        
        <span class="enscript-keyword">if</span> (!summaryIsInBacktrace(summary, addr, cnt)) {
            <span class="enscript-keyword">continue</span>;
        }
        
        <span class="enscript-keyword">if</span> (!found_kmod) {
            (*printf_func)(<span class="enscript-string">&quot;      Kernel Extensions in backtrace:\n&quot;</span>);
            found_kmod = true;
        }

        printSummary(summary, printf_func, doUnslide);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (lockFlag) {
        IOLockUnlock(sKextSummariesLock);
    }

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* This function must be safe to call in panic context.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
boolean_t
<span class="enscript-function-name">OSKext::summaryIsInBacktrace</span>(
    OSKextLoadedKextSummary   * summary,
    vm_offset_t               * addr,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>                cnt)
{
    u_int i = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; cnt; i++) {
        vm_offset_t kscan_addr = addr[i];
        <span class="enscript-keyword">if</span> ((kscan_addr &gt;= summary-&gt;address) &amp;&amp;
            (kscan_addr &lt; (summary-&gt;address + summary-&gt;size))) 
        {
            <span class="enscript-keyword">return</span> TRUE;
        }
    }

    <span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*********************************************************************
 * scan list of loaded kext summaries looking for a load address match and if
 * found return the UUID C string.  If not found then set empty string.
 *********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">findSummaryUUID</span>(
                            uint32_t        tag_ID,
                            uuid_string_t   uuid);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">findSummaryUUID</span>(
                            uint32_t        tag_ID, 
                            uuid_string_t   uuid)
{
    u_int     i;
    
    uuid[0] = 0x00; <span class="enscript-comment">// default to no UUID
</span>    
    <span class="enscript-keyword">for</span> (i = 0; i &lt; gLoadedKextSummaries-&gt;numSummaries; ++i) {
        OSKextLoadedKextSummary * summary;
        
        summary = gLoadedKextSummaries-&gt;summaries + i;
        
        <span class="enscript-keyword">if</span> (summary-&gt;loadTag == tag_ID) {
            (<span class="enscript-type">void</span>) uuid_unparse(summary-&gt;uuid, uuid);
            <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* This function must be safe to call in panic context.
*********************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSKext::printSummary</span>(
    OSKextLoadedKextSummary * summary,
    <span class="enscript-type">int</span>                    (* printf_func)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...),
    <span class="enscript-type">bool</span>                      doUnslide)
{
    kmod_reference_t * kmod_ref = NULL;
    uuid_string_t uuid;
    <span class="enscript-type">char</span> version[kOSKextVersionMaxLength];
    uint64_t tmpAddr;

    <span class="enscript-keyword">if</span> (!OSKextVersionGetString(summary-&gt;version, version, <span class="enscript-keyword">sizeof</span>(version))) {
        strlcpy(version, <span class="enscript-string">&quot;unknown version&quot;</span>, <span class="enscript-keyword">sizeof</span>(version));
    }
    (<span class="enscript-type">void</span>) uuid_unparse(summary-&gt;uuid, uuid);
    
    <span class="enscript-keyword">if</span> (doUnslide) {
        tmpAddr = VM_KERNEL_UNSLIDE(summary-&gt;address);
    }
    <span class="enscript-keyword">else</span> {
        tmpAddr = summary-&gt;address;
    }
    (*printf_func)(<span class="enscript-string">&quot;         %s(%s)[%s]@0x%llx-&gt;0x%llx\n&quot;</span>,
        summary-&gt;name, version, uuid,
        tmpAddr, tmpAddr + summary-&gt;size - 1);
    
    <span class="enscript-comment">/* print dependency info */</span>
    <span class="enscript-keyword">for</span> (kmod_ref = (kmod_reference_t *) summary-&gt;reference_list; 
         kmod_ref; 
         kmod_ref = kmod_ref-&gt;next) {
        kmod_info_t * rinfo;
        
        <span class="enscript-keyword">if</span> (pmap_find_phys(kernel_pmap, (addr64_t)((uintptr_t)kmod_ref)) == 0) {
            (*printf_func)(<span class="enscript-string">&quot;            kmod dependency scan stopped &quot;</span>
                           <span class="enscript-string">&quot;due to missing dependency page: %p\n&quot;</span>, kmod_ref);
            <span class="enscript-keyword">break</span>;
        }
        rinfo = kmod_ref-&gt;info;
        
        <span class="enscript-keyword">if</span> (pmap_find_phys(kernel_pmap, (addr64_t)((uintptr_t)rinfo)) == 0) {
            (*printf_func)(<span class="enscript-string">&quot;            kmod dependency scan stopped &quot;</span>
                           <span class="enscript-string">&quot;due to missing kmod page: %p\n&quot;</span>, rinfo);
            <span class="enscript-keyword">break</span>;
        }
        
        <span class="enscript-keyword">if</span> (!rinfo-&gt;address) {
            <span class="enscript-keyword">continue</span>; <span class="enscript-comment">// skip fake entries for built-ins
</span>        }
        
        <span class="enscript-comment">/* locate UUID in gLoadedKextSummaries */</span>
        findSummaryUUID(rinfo-&gt;id, uuid);
        
        <span class="enscript-keyword">if</span> (doUnslide) {
            tmpAddr = VM_KERNEL_UNSLIDE(rinfo-&gt;address);
        }
        <span class="enscript-keyword">else</span> {
            tmpAddr = rinfo-&gt;address;
        }
        (*printf_func)(<span class="enscript-string">&quot;            dependency: %s(%s)[%s]@%p\n&quot;</span>,
                       rinfo-&gt;name, rinfo-&gt;version, uuid, tmpAddr);
    }
    <span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*******************************************************************************
* substitute() looks at an input string (a pointer within a larger buffer)
* for a match to a substring, and on match it writes the marker &amp; substitution
* character to an output string, updating the scan (from) and
* output (to) indexes as appropriate.
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">substitute</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * scan_string,
    <span class="enscript-type">char</span>       * string_out,
    uint32_t   * to_index,
    uint32_t   * from_index,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * substring,
    <span class="enscript-type">char</span>         marker,
    <span class="enscript-type">char</span>         substitution);

<span class="enscript-comment">/* string_out must be at least KMOD_MAX_NAME bytes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">substitute</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * scan_string,
    <span class="enscript-type">char</span>       * string_out,
    uint32_t   * to_index,
    uint32_t   * from_index,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * substring,
    <span class="enscript-type">char</span>         marker,
    <span class="enscript-type">char</span>         substitution)
{
    uint32_t substring_length = strnlen(substring, KMOD_MAX_NAME - 1);

   <span class="enscript-comment">/* On a substring match, append the marker (if there is one) and then
    * the substitution character, updating the output (to) index accordingly.
    * Then update the input (from) length by the length of the substring
    * that got replaced.
    */</span>
    <span class="enscript-keyword">if</span> (!strncmp(scan_string, substring, substring_length)) {
        <span class="enscript-keyword">if</span> (marker) {
            string_out[(*to_index)++] = marker;
        }
        string_out[(*to_index)++] = substitution;
        (*from_index) += substring_length;
        <span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*******************************************************************************
* compactIdentifier() takes a CFBundleIdentifier in a buffer of at least
* KMOD_MAX_NAME characters and performs various substitutions of common
* prefixes &amp; substrings as defined by tables in kext_panic_report.h.
*******************************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">compactIdentifier</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * identifier,
    <span class="enscript-type">char</span>       * identifier_out,
    <span class="enscript-type">char</span>      ** identifier_out_end);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">compactIdentifier</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * identifier,
    <span class="enscript-type">char</span>       * identifier_out,
    <span class="enscript-type">char</span>      ** identifier_out_end)
{
    uint32_t       from_index, to_index;
    uint32_t       scan_from_index = 0;
    uint32_t       scan_to_index   = 0;
    subs_entry_t * subs_entry    = NULL;
    <span class="enscript-type">int</span>            did_sub       = 0;

    from_index = to_index = 0;
    identifier_out[0] = <span class="enscript-string">'\0'</span>;

   <span class="enscript-comment">/* Replace certain identifier prefixes with shorter @+character sequences.
    * Check the return value of substitute() so we only replace the prefix.
    */</span>
    <span class="enscript-keyword">for</span> (subs_entry = &amp;kext_identifier_prefix_subs[0];
         subs_entry-&gt;substring &amp;&amp; !did_sub;
         subs_entry++) {

        did_sub = substitute(identifier, identifier_out,
            &amp;scan_to_index, &amp;scan_from_index,
            subs_entry-&gt;substring, <span class="enscript-comment">/* marker */</span> <span class="enscript-string">'\0'</span>, subs_entry-&gt;substitute);
    }
    did_sub = 0;

   <span class="enscript-comment">/* Now scan through the identifier looking for the common substrings
    * and replacing them with shorter !+character sequences via substitute().
    */</span>
    <span class="enscript-keyword">for</span> (<span class="enscript-comment">/* see above */</span>;
         scan_from_index &lt; KMOD_MAX_NAME - 1 &amp;&amp; identifier[scan_from_index];
         <span class="enscript-comment">/* see loop */</span>) {
         
        <span class="enscript-type">const</span> <span class="enscript-type">char</span>   * scan_string = &amp;identifier[scan_from_index];

        did_sub = 0;

        <span class="enscript-keyword">if</span> (scan_from_index) {
            <span class="enscript-keyword">for</span> (subs_entry = &amp;kext_identifier_substring_subs[0];
                 subs_entry-&gt;substring &amp;&amp; !did_sub;
                 subs_entry++) {

                did_sub = substitute(scan_string, identifier_out,
                    &amp;scan_to_index, &amp;scan_from_index,
                    subs_entry-&gt;substring, <span class="enscript-string">'!'</span>, subs_entry-&gt;substitute);
            }
        }

       <span class="enscript-comment">/* If we didn't substitute, copy the input character to the output.
        */</span>
        <span class="enscript-keyword">if</span> (!did_sub) {
            identifier_out[scan_to_index++] = identifier[scan_from_index++];
        }
    }
    
    identifier_out[scan_to_index] = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">if</span> (identifier_out_end) {
        *identifier_out_end = &amp;identifier_out[scan_to_index];
    }
    
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*******************************************************************************
* assemble_identifier_and_version() adds to a string buffer a compacted
* bundle identifier followed by a version string.
*******************************************************************************/</span>

<span class="enscript-comment">/* identPlusVers must be at least 2*KMOD_MAX_NAME in length.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">assemble_identifier_and_version</span>(
                                           kmod_info_t * kmod_info,
                                           <span class="enscript-type">char</span>        * identPlusVers,
                                           <span class="enscript-type">int</span>           bufSize);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">assemble_identifier_and_version</span>(
                                kmod_info_t * kmod_info, 
                                <span class="enscript-type">char</span>        * identPlusVers,
                                <span class="enscript-type">int</span>           bufSize)
{
    <span class="enscript-type">int</span> result = 0;

    compactIdentifier(kmod_info-&gt;name, identPlusVers, NULL);
    result = strnlen(identPlusVers, KMOD_MAX_NAME - 1);
    identPlusVers[result++] = <span class="enscript-string">'\t'</span>;  <span class="enscript-comment">// increment for real char
</span>    identPlusVers[result] = <span class="enscript-string">'\0'</span>;    <span class="enscript-comment">// don't increment for nul char
</span>    result = strlcat(identPlusVers, kmod_info-&gt;version, bufSize);
    <span class="enscript-keyword">if</span> (result &gt;= bufSize) {
        identPlusVers[bufSize - 1] = <span class="enscript-string">'\0'</span>;
        result = bufSize - 1;
    }
    
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*******************************************************************************
* Assumes sKextLock is held.
*******************************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">OSKext::saveLoadedKextPanicListTyped</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * prefix,
    <span class="enscript-type">int</span>          invertFlag,
    <span class="enscript-type">int</span>          libsFlag,
    <span class="enscript-type">char</span>       * paniclist,
    uint32_t     list_size)
{
    <span class="enscript-type">int</span>             result = -1;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    count, i;

    count = sLoadedKexts-&gt;getCount();
    <span class="enscript-keyword">if</span> (!count) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    i = count - 1;
    <span class="enscript-keyword">do</span> {
        OSObject    * rawKext = sLoadedKexts-&gt;getObject(i);
        OSKext      * theKext = OSDynamicCast(OSKext, rawKext);
        <span class="enscript-type">int</span>           match;
        uint32_t      identPlusVersLength;
        uint32_t      tempLen;
        <span class="enscript-type">char</span>          identPlusVers[2*KMOD_MAX_NAME];
        
        <span class="enscript-keyword">if</span> (!rawKext) {
            printf(<span class="enscript-string">&quot;OSKext::saveLoadedKextPanicListTyped - &quot;</span>
                <span class="enscript-string">&quot;NULL kext in loaded kext list; continuing\n&quot;</span>);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">if</span> (!theKext) {
            printf(<span class="enscript-string">&quot;OSKext::saveLoadedKextPanicListTyped - &quot;</span>
                <span class="enscript-string">&quot;Kext type cast failed in loaded kext list; continuing\n&quot;</span>);
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Skip all built-in kexts.
        */</span>
        <span class="enscript-keyword">if</span> (theKext-&gt;isKernelComponent()) {
            <span class="enscript-keyword">continue</span>;
        }

        kmod_info_t * kmod_info = theKext-&gt;kmod_info;

       <span class="enscript-comment">/* Filter for kmod name (bundle identifier).
        */</span>
        match = !strncmp(kmod_info-&gt;name, prefix, strnlen(prefix, KMOD_MAX_NAME));
        <span class="enscript-keyword">if</span> ((match &amp;&amp; invertFlag) || (!match &amp;&amp; !invertFlag)) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Filter for libraries (kexts that have a compatible version).
        */</span>
        <span class="enscript-keyword">if</span> ((libsFlag == 0 &amp;&amp; theKext-&gt;getCompatibleVersion() &gt; 1) ||
            (libsFlag == 1 &amp;&amp; theKext-&gt;getCompatibleVersion() &lt; 1)) {

            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">if</span> (!kmod_info ||
            !pmap_find_phys(kernel_pmap, (addr64_t)((uintptr_t)kmod_info))) {

            printf(<span class="enscript-string">&quot;kext scan stopped due to missing kmod_info page: %p\n&quot;</span>,
                   kmod_info);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        identPlusVersLength = assemble_identifier_and_version(kmod_info,
                                                              identPlusVers,
                                                              <span class="enscript-keyword">sizeof</span>(identPlusVers));
        <span class="enscript-keyword">if</span> (!identPlusVersLength) {
            printf(<span class="enscript-string">&quot;error saving loaded kext info\n&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-comment">/* make sure everything fits and we null terminate.
         */</span>
        tempLen = strlcat(paniclist, identPlusVers, list_size);
        <span class="enscript-keyword">if</span> (tempLen &gt;= list_size) {
            <span class="enscript-comment">// panic list is full, keep it and null terminate
</span>            paniclist[list_size - 1] = 0x00;
            result = 0;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        tempLen = strlcat(paniclist, <span class="enscript-string">&quot;\n&quot;</span>, list_size);
        <span class="enscript-keyword">if</span> (tempLen &gt;= list_size) {
            <span class="enscript-comment">// panic list is full, keep it and null terminate
</span>            paniclist[list_size - 1] = 0x00;
            result = 0;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    } <span class="enscript-keyword">while</span> (i--);
    
    result = 0;
<span class="enscript-reference">finish</span>:
    
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::saveLoadedKextPanicList</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">char</span>     * newlist        = NULL;
    uint32_t   newlist_size   = 0;
    
    newlist_size = KEXT_PANICLIST_SIZE;
    newlist = (<span class="enscript-type">char</span> *)kalloc_tag(newlist_size, VM_KERN_MEMORY_OSKEXT);
    
    <span class="enscript-keyword">if</span> (!newlist) {
        OSKextLog(<span class="enscript-comment">/* kext */</span> NULL,
                  kOSKextLogErrorLevel | kOSKextLogGeneralFlag,
                  <span class="enscript-string">&quot;Couldn't allocate kext panic log buffer.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    newlist[0] = <span class="enscript-string">'\0'</span>;
    
    <span class="enscript-comment">// non-&quot;com.apple.&quot; kexts
</span>    <span class="enscript-keyword">if</span> (OSKext::saveLoadedKextPanicListTyped(<span class="enscript-string">&quot;com.apple.&quot;</span>, <span class="enscript-comment">/* invert? */</span> 1,
                                             <span class="enscript-comment">/* libs? */</span> -1, newlist, newlist_size) != 0) {
        
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-comment">// &quot;com.apple.&quot; nonlibrary kexts
</span>    <span class="enscript-keyword">if</span> (OSKext::saveLoadedKextPanicListTyped(<span class="enscript-string">&quot;com.apple.&quot;</span>, <span class="enscript-comment">/* invert? */</span> 0,
                                             <span class="enscript-comment">/* libs? */</span> 0, newlist, newlist_size) != 0) {
        
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    <span class="enscript-comment">// &quot;com.apple.&quot; library kexts
</span>    <span class="enscript-keyword">if</span> (OSKext::saveLoadedKextPanicListTyped(<span class="enscript-string">&quot;com.apple.&quot;</span>, <span class="enscript-comment">/* invert? */</span> 0,
                                             <span class="enscript-comment">/* libs? */</span> 1, newlist, newlist_size) != 0) {
        
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-keyword">if</span> (loaded_kext_paniclist) {
        kfree(loaded_kext_paniclist, loaded_kext_paniclist_size);
    }
    loaded_kext_paniclist = newlist;
    newlist = NULL;
    loaded_kext_paniclist_size = newlist_size;
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (newlist) {
        kfree(newlist, newlist_size);
    }
    <span class="enscript-keyword">return</span>;
}
    
<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::savePanicString</span>(<span class="enscript-type">bool</span> isLoading)
{
    u_long len;

    <span class="enscript-keyword">if</span> (!kmod_info) {
        <span class="enscript-keyword">return</span>;  <span class="enscript-comment">// do not goto finish here b/c of lock
</span>    }

    len = assemble_identifier_and_version( kmod_info,
        (isLoading) ? last_loaded_str_buf : last_unloaded_str_buf,
        (isLoading) ? <span class="enscript-keyword">sizeof</span>(last_loaded_str_buf) : <span class="enscript-keyword">sizeof</span>(last_unloaded_str_buf) );
    <span class="enscript-keyword">if</span> (!len) {
        printf(<span class="enscript-string">&quot;error saving unloaded kext info\n&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-keyword">if</span> (isLoading) {
        last_loaded_strlen = len;
        last_loaded_address = (<span class="enscript-type">void</span> *)kmod_info-&gt;address;
        last_loaded_size = kmod_info-&gt;size;
        clock_get_uptime(&amp;last_loaded_timestamp);
    } <span class="enscript-keyword">else</span> {
        last_unloaded_strlen = len;
        last_unloaded_address = (<span class="enscript-type">void</span> *)kmod_info-&gt;address;
        last_unloaded_size = kmod_info-&gt;size;
        clock_get_uptime(&amp;last_unloaded_timestamp);
    }

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::printKextPanicLists</span>(<span class="enscript-type">int</span> (*printf_func)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...))
{
    <span class="enscript-keyword">if</span> (last_loaded_strlen) {
        printf_func(<span class="enscript-string">&quot;last loaded kext at %llu: %.*s (addr %p, size %lu)\n&quot;</span>,
            AbsoluteTime_to_scalar(&amp;last_loaded_timestamp),
            last_loaded_strlen, last_loaded_str_buf,
            last_loaded_address, last_loaded_size);
    }

    <span class="enscript-keyword">if</span> (last_unloaded_strlen) {
        printf_func(<span class="enscript-string">&quot;last unloaded kext at %llu: %.*s (addr %p, size %lu)\n&quot;</span>,
            AbsoluteTime_to_scalar(&amp;last_unloaded_timestamp),
            last_unloaded_strlen, last_unloaded_str_buf,
            last_unloaded_address, last_unloaded_size);
    }

    printf_func(<span class="enscript-string">&quot;loaded kexts:\n&quot;</span>);
    <span class="enscript-keyword">if</span> (loaded_kext_paniclist &amp;&amp;
        pmap_find_phys(kernel_pmap, (addr64_t) (uintptr_t) loaded_kext_paniclist) &amp;&amp;
        loaded_kext_paniclist[0]) {

        printf_func(<span class="enscript-string">&quot;%.*s&quot;</span>,
                    strnlen(loaded_kext_paniclist, loaded_kext_paniclist_size),
                    loaded_kext_paniclist);
    } <span class="enscript-keyword">else</span> {
        printf_func(<span class="enscript-string">&quot;(none)\n&quot;</span>);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
* Assumes sKextLock is held.
*********************************************************************/</span>
<span class="enscript-comment">/* static */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::updateLoadedKextSummaries</span>(<span class="enscript-type">void</span>)
{
    kern_return_t result = KERN_FAILURE;
    OSKextLoadedKextSummaryHeader *summaryHeader = NULL;
    OSKextLoadedKextSummaryHeader *summaryHeaderAlloc = NULL;
    OSKext *aKext;
    vm_map_offset_t start, end;
    size_t summarySize = 0;
    size_t size;
    u_int count;
    u_int maxKexts;
    u_int i, j;
    OSKextActiveAccount * accountingList;
    OSKextActiveAccount * prevAccountingList;
    uint32_t idx, accountingListAlloc, accountingListCount, prevAccountingListCount;
    
    prevAccountingList = NULL;
    prevAccountingListCount = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-keyword">if</span> (IORecursiveLockHaveLock(sKextLock) == false) {
        panic(<span class="enscript-string">&quot;sKextLock must be held&quot;</span>);
    }
#<span class="enscript-reference">endif</span>
    
    IOLockLock(sKextSummariesLock);
    
    count = sLoadedKexts-&gt;getCount();
    <span class="enscript-keyword">for</span> (i = 0, maxKexts = 0; i &lt; count; ++i) {
        aKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        maxKexts += (aKext &amp;&amp; aKext-&gt;isExecutable());
    }
    
    <span class="enscript-keyword">if</span> (!maxKexts) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    <span class="enscript-keyword">if</span> (maxKexts &lt; kOSKextTypicalLoadCount) maxKexts = kOSKextTypicalLoadCount;
    
    <span class="enscript-comment">/* Calculate the size needed for the new summary headers.
     */</span>
    
    size = <span class="enscript-keyword">sizeof</span>(*gLoadedKextSummaries);
    size += maxKexts * <span class="enscript-keyword">sizeof</span>(*gLoadedKextSummaries-&gt;summaries);
    size = round_page(size);
    
    <span class="enscript-keyword">if</span> (gLoadedKextSummaries == NULL || sLoadedKextSummariesAllocSize &lt; size) {
        <span class="enscript-keyword">if</span> (gLoadedKextSummaries) {
            kmem_free(kernel_map,
                      (vm_offset_t)gLoadedKextSummaries,
                      sLoadedKextSummariesAllocSize);
            gLoadedKextSummaries = NULL;
            sLoadedKextSummariesAllocSize = 0;
        }
        result = kmem_alloc(kernel_map,
                            (vm_offset_t*)&amp;summaryHeaderAlloc,
                            size, VM_KERN_MEMORY_OSKEXT);
        <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        summaryHeader = summaryHeaderAlloc;
        summarySize = size;
    }
    <span class="enscript-keyword">else</span> {
        summaryHeader = gLoadedKextSummaries;
        summarySize = sLoadedKextSummariesAllocSize;
        
        start = (vm_map_offset_t) summaryHeader;
        end = start + summarySize;
        result = vm_map_protect(kernel_map,
                                start,
                                end,
                                VM_PROT_DEFAULT,
                                FALSE);
        <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">/* Populate the summary header.
     */</span>
    
    bzero(summaryHeader, summarySize);
    summaryHeader-&gt;version = kOSKextLoadedKextSummaryVersion;
    summaryHeader-&gt;entry_size = <span class="enscript-keyword">sizeof</span>(OSKextLoadedKextSummary);

    <span class="enscript-comment">/* Populate each kext summary.
     */</span>
    
    count = sLoadedKexts-&gt;getCount();
    accountingListAlloc = 0;
    <span class="enscript-keyword">for</span> (i = 0, j = 0; i &lt; count &amp;&amp; j &lt; maxKexts; ++i) {
        aKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!aKext || !aKext-&gt;isExecutable()) {
            <span class="enscript-keyword">continue</span>;
        }
        
        aKext-&gt;updateLoadedKextSummary(&amp;summaryHeader-&gt;summaries[j++]);
        summaryHeader-&gt;numSummaries++;
	accountingListAlloc++;
    }

    accountingList = IONew(typeof(accountingList[0]), accountingListAlloc);
    accountingListCount = 0;
    <span class="enscript-keyword">for</span> (i = 0, j = 0; i &lt; count &amp;&amp; j &lt; maxKexts; ++i) {
        aKext = OSDynamicCast(OSKext, sLoadedKexts-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (!aKext || !aKext-&gt;isExecutable()) {
            <span class="enscript-keyword">continue</span>;
        }

	OSKextActiveAccount activeAccount;
	aKext-&gt;updateActiveAccount(&amp;activeAccount);
	<span class="enscript-comment">// order by address
</span>	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; accountingListCount; idx++)
	{
	    <span class="enscript-keyword">if</span> (activeAccount.address &lt; accountingList[idx].address) <span class="enscript-keyword">break</span>;
	}
	bcopy(&amp;accountingList[idx], &amp;accountingList[idx + 1], (accountingListCount - idx) * <span class="enscript-keyword">sizeof</span>(accountingList[0]));
	accountingList[idx] = activeAccount;
	accountingListCount++;
    }
    assert(accountingListCount == accountingListAlloc);
    <span class="enscript-comment">/* Write protect the buffer and move it into place.
     */</span>
    
    start = (vm_map_offset_t) summaryHeader;
    end = start + summarySize;
    
    result = vm_map_protect(kernel_map, start, end, VM_PROT_READ, FALSE);
    <span class="enscript-keyword">if</span> (result != KERN_SUCCESS) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    
    gLoadedKextSummaries = summaryHeader;
    sLoadedKextSummariesAllocSize = summarySize;
    summaryHeaderAlloc = NULL;
    
   <span class="enscript-comment">/* Call the magic breakpoint function through a static function pointer so
    * the compiler can't optimize the function away.
    */</span>
    <span class="enscript-keyword">if</span> (sLoadedKextSummariesUpdated) (*sLoadedKextSummariesUpdated)();

    IOSimpleLockLock(sKextAccountsLock);
    prevAccountingList      = sKextAccounts;
    prevAccountingListCount = sKextAccountsCount;
    sKextAccounts           = accountingList;
    sKextAccountsCount      = accountingListCount;
    IOSimpleLockUnlock(sKextAccountsLock);

<span class="enscript-reference">finish</span>:
    IOLockUnlock(sKextSummariesLock);

   <span class="enscript-comment">/* If we had to allocate a new buffer but failed to generate the summaries,
    * free that now.
    */</span>
    <span class="enscript-keyword">if</span> (summaryHeaderAlloc) {
        kmem_free(kernel_map, (vm_offset_t)summaryHeaderAlloc, summarySize);
    }
    <span class="enscript-keyword">if</span> (prevAccountingList) {
        IODelete(prevAccountingList, typeof(accountingList[0]), prevAccountingListCount);
    }

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::updateLoadedKextSummary</span>(OSKextLoadedKextSummary *summary)
{
    OSData *uuid;

    strlcpy(summary-&gt;name, getIdentifierCString(), 
        <span class="enscript-keyword">sizeof</span>(summary-&gt;name));

    uuid = copyUUID();
    <span class="enscript-keyword">if</span> (uuid) {
        memcpy(summary-&gt;uuid, uuid-&gt;getBytesNoCopy(), <span class="enscript-keyword">sizeof</span>(summary-&gt;uuid));
        OSSafeRelease(uuid);
    }

    summary-&gt;address = kmod_info-&gt;address;
    summary-&gt;size = kmod_info-&gt;size;
    summary-&gt;version = getVersion();
    summary-&gt;loadTag = kmod_info-&gt;id;
    summary-&gt;flags = 0;
    summary-&gt;reference_list = (uint64_t) kmod_info-&gt;reference_list;

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSKext::updateActiveAccount</span>(OSKextActiveAccount *account)
{
    bzero(account, <span class="enscript-keyword">sizeof</span>(*account));
    account-&gt;address = kmod_info-&gt;address;
    <span class="enscript-keyword">if</span> (account-&gt;address) {
        account-&gt;address_end = kmod_info-&gt;address + kmod_info-&gt;size;
    }
    account-&gt;account = <span class="enscript-keyword">this</span>-&gt;account;
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">const</span> vm_allocation_site_t * 
<span class="enscript-function-name">OSKextGetAllocationSiteForCaller</span>(uintptr_t address)
{
    OSKextActiveAccount *  active;
    vm_allocation_site_t * site;
    uint32_t baseIdx;
    uint32_t lim;

    IOSimpleLockLock(sKextAccountsLock);
    site = NULL;
    <span class="enscript-comment">// bsearch sKextAccounts list
</span>    <span class="enscript-keyword">for</span> (baseIdx = 0, lim = sKextAccountsCount; lim; lim &gt;&gt;= 1)
    {
	active = &amp;sKextAccounts[baseIdx + (lim &gt;&gt; 1)];
	<span class="enscript-keyword">if</span> ((address &gt;= active-&gt;address) &amp;&amp; (address &lt; active-&gt;address_end))
	{
	    site = &amp;active-&gt;account-&gt;site;
	    <span class="enscript-keyword">if</span> (!site-&gt;tag) vm_tag_alloc_locked(site);
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (address &gt; active-&gt;address) 
	{	
	    <span class="enscript-comment">// move right
</span>	    baseIdx += (lim &gt;&gt; 1) + 1;
	    lim--;
	}
	<span class="enscript-comment">// else move left
</span>    }
    IOSimpleLockUnlock(sKextAccountsLock);

    <span class="enscript-keyword">return</span> (site);
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> uint32_t 
<span class="enscript-function-name">OSKextGetKmodIDForSite</span>(vm_allocation_site_t * site)
{
    OSKextAccount * account = (typeof(account)) site;
    <span class="enscript-keyword">return</span> (account-&gt;loadTag);
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">OSKextFreeSite</span>(vm_allocation_site_t * site)
{
    OSKextAccount * freeAccount = (typeof(freeAccount)) site;
    IODelete(freeAccount, OSKextAccount, 1);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEC_FIPS</span>
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Kernel</span> <span class="enscript-variable-name">External</span> <span class="enscript-variable-name">Components</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">FIPS</span> <span class="enscript-variable-name">compliance</span>
#<span class="enscript-reference">endif</span>
    
<span class="enscript-comment">/*********************************************************************
 * Kernel External Components for FIPS compliance (KEC_FIPS)
 *********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> * 
<span class="enscript-function-name">GetAppleTEXTHashForKext</span>(OSKext * theKext, OSDictionary *theInfoDict)
{
    AppleTEXTHash_t         my_ath = {1, 0, NULL};
    AppleTEXTHash_t *       my_athp = NULL;         <span class="enscript-comment">// do not release
</span>    OSDictionary *          textHashDict = NULL;    <span class="enscript-comment">// do not release
</span>    OSData *                segmentHash = NULL;     <span class="enscript-comment">// do not release
</span>    
    <span class="enscript-keyword">if</span> (theKext == NULL || theInfoDict == NULL) {
        <span class="enscript-keyword">return</span>(NULL);
    }
    
    textHashDict = OSDynamicCast(OSDictionary, theInfoDict-&gt;getObject(kAppleTextHashesKey));
    <span class="enscript-keyword">if</span> (textHashDict == NULL) {
        <span class="enscript-keyword">return</span>(NULL);
    }
    
    segmentHash = OSDynamicCast(OSData,
                                textHashDict-&gt;getObject(ARCHNAME));
    <span class="enscript-keyword">if</span> (segmentHash == NULL) {
        <span class="enscript-keyword">return</span>(NULL);
    }
    
    <span class="enscript-comment">// KEC_FIPS type kexts never unload so we don't have to clean up our 
</span>    <span class="enscript-comment">// AppleTEXTHash_t
</span>    <span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *) &amp;my_athp, 
                   <span class="enscript-keyword">sizeof</span>(AppleTEXTHash_t), VM_KERN_MEMORY_OSKEXT) != KERN_SUCCESS) {
        <span class="enscript-keyword">return</span>(NULL);
    }
    
    memcpy(my_athp, &amp;my_ath, <span class="enscript-keyword">sizeof</span>(my_ath));
    my_athp-&gt;ath_length = segmentHash-&gt;getLength();
    <span class="enscript-keyword">if</span> (my_athp-&gt;ath_length &gt; 0) {
        my_athp-&gt;ath_hash = (<span class="enscript-type">void</span> *)segmentHash-&gt;getBytesNoCopy();
    }
        
#<span class="enscript-reference">if</span> 0
    OSKextLog(theKext,
              kOSKextLogErrorLevel |
              kOSKextLogGeneralFlag,
              <span class="enscript-string">&quot;Kext %s ath_version %d ath_length %d ath_hash %p&quot;</span>,
              theKext-&gt;getIdentifierCString(), 
              my_athp-&gt;ath_version,
              my_athp-&gt;ath_length,
              my_athp-&gt;ath_hash); 
#<span class="enscript-reference">endif</span>
        
    <span class="enscript-keyword">return</span>( (<span class="enscript-type">void</span> *) my_athp );
}
    
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">CONFIG_KEC_FIPS</span>

</pre>
<hr />
</body></html>