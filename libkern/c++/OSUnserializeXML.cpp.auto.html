<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>OSUnserializeXML.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">OSUnserializeXML.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * HISTORY
 *
 * OSUnserializeXML.y created by rsulack on Tue Oct 12 1999
 */</span>

<span class="enscript-comment">// parser for unserializing OSContainer objects serialized to XML
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// to build :
</span><span class="enscript-comment">//	bison -p OSUnserializeXML OSUnserializeXML.y
</span><span class="enscript-comment">//	head -50 OSUnserializeXML.y &gt; OSUnserializeXML.cpp
</span><span class="enscript-comment">//	sed -e &quot;s/#include &lt;stdio.h&gt;//&quot; &lt; OSUnserializeXML.tab.c &gt;&gt; OSUnserializeXML.cpp
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	when changing code check in both OSUnserializeXML.y and OSUnserializeXML.cpp
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//		 DO NOT EDIT OSUnserializeXML.cpp!
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//			this means you!
</span><span class="enscript-comment">/* A Bison parser, made by GNU Bison 2.3.  */</span>

<span class="enscript-comment">/* Skeleton implementation for Bison's Yacc-like parsers in C

   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */</span>

<span class="enscript-comment">/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */</span>

<span class="enscript-comment">/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called &quot;semantic&quot; parser.  */</span>

<span class="enscript-comment">/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted &quot;INFRINGES ON
   USER NAME SPACE&quot; below.  */</span>

<span class="enscript-comment">/* Identify Bison output.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYBISON</span> 1

<span class="enscript-comment">/* Bison version.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYBISON_VERSION</span> <span class="enscript-string">&quot;2.3&quot;</span>

<span class="enscript-comment">/* Skeleton name.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSKELETON_NAME</span> <span class="enscript-string">&quot;yacc.c&quot;</span>

<span class="enscript-comment">/* Pure parsers.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYPURE</span> 1

<span class="enscript-comment">/* Using locations.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYLSP_NEEDED</span> 0

<span class="enscript-comment">/* Substitute the variable and function names.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yyparse</span> OSUnserializeXMLparse
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yylex</span>   OSUnserializeXMLlex
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yyerror</span> OSUnserializeXMLerror
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yylval</span>  OSUnserializeXMLlval
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yychar</span>  OSUnserializeXMLchar
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yydebug</span> OSUnserializeXMLdebug
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yynerrs</span> OSUnserializeXMLnerrs


<span class="enscript-comment">/* Tokens.  */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYTOKENTYPE</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYTOKENTYPE</span>
   <span class="enscript-comment">/* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */</span>
   <span class="enscript-type">enum</span> yytokentype {
     ARRAY = 258,
     BOOLEAN = 259,
     DATA = 260,
     DICTIONARY = 261,
     IDREF = 262,
     KEY = 263,
     NUMBER = 264,
     SET = 265,
     STRING = 266,
     SYNTAX_ERROR = 267
   };
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/* Tokens.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ARRAY</span> 258
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOOLEAN</span> 259
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DATA</span> 260
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DICTIONARY</span> 261
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IDREF</span> 262
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEY</span> 263
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NUMBER</span> 264
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SET</span> 265
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STRING</span> 266
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SYNTAX_ERROR</span> 267




<span class="enscript-comment">/* Copy the first part of user declarations.  */</span>
#<span class="enscript-reference">line</span> 61 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSMetaClass.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSLib.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_OBJECTS</span>	65535

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTYPE</span> object_t *
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYPARSE_PARAM</span>	state
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYLEX_PARAM</span>	(parser_state_t *)state

<span class="enscript-comment">// this is the internal struct used to hold objects on parser stack
</span><span class="enscript-comment">// it represents objects both before and after they have been created
</span><span class="enscript-type">typedef</span>	<span class="enscript-type">struct</span> object {
	<span class="enscript-type">struct</span> object	*next;
	<span class="enscript-type">struct</span> object	*free;
	<span class="enscript-type">struct</span> object	*elements;
	OSObject	*object;
	OSSymbol	*key;			<span class="enscript-comment">// for dictionary
</span>	<span class="enscript-type">int</span>		size;
	<span class="enscript-type">void</span>		*data;			<span class="enscript-comment">// for data
</span>	<span class="enscript-type">char</span>		*string;		<span class="enscript-comment">// for string &amp; symbol
</span>	<span class="enscript-type">long</span> <span class="enscript-type">long</span> 	number;			<span class="enscript-comment">// for number
</span>	<span class="enscript-type">int</span>		idref;
} object_t;

<span class="enscript-comment">// this code is reentrant, this structure contains all
</span><span class="enscript-comment">// state information for the parsing of a single buffer
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> parser_state {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*parseBuffer;		<span class="enscript-comment">// start of text to be parsed
</span>	<span class="enscript-type">int</span>		parseBufferIndex;	<span class="enscript-comment">// current index into text
</span>	<span class="enscript-type">int</span>		lineNumber;		<span class="enscript-comment">// current line number
</span>	object_t	*objects;		<span class="enscript-comment">// internal objects in use
</span>	object_t	*freeObjects;		<span class="enscript-comment">// internal objects that are free
</span>	OSDictionary	*tags;			<span class="enscript-comment">// used to remember &quot;ID&quot; tags
</span>	OSString	**errorString;		<span class="enscript-comment">// parse error with line
</span>	OSObject	*parsedObject;		<span class="enscript-comment">// resultant object of parsed text
</span>	<span class="enscript-type">int</span>		parsedObjectCount;
} parser_state_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STATE</span>		((parser_state_t *)state)

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">yyerror</span> 	
#<span class="enscript-reference">define</span> <span class="enscript-function-name">yyerror</span>(s)	OSUnserializeerror(STATE, (s))
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		OSUnserializeerror(parser_state_t *state, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		yylex(YYSTYPE *lvalp, parser_state_t *state);

<span class="enscript-type">static</span> object_t 	*newObject(parser_state_t *state);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		freeObject(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		rememberObject(parser_state_t *state, <span class="enscript-type">int</span> tag, OSObject *o);
<span class="enscript-type">static</span> object_t		*retrieveObject(parser_state_t *state, <span class="enscript-type">int</span> tag);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		cleanupObjects(parser_state_t *state);

<span class="enscript-type">static</span> object_t		*buildDictionary(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildArray(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildSet(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildString(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildSymbol(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildData(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildNumber(parser_state_t *state, object_t *o);
<span class="enscript-type">static</span> object_t		*buildBoolean(parser_state_t *state, object_t *o);

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		*kern_os_malloc(size_t size);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		*kern_os_realloc(<span class="enscript-type">void</span> * addr, size_t size);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		kern_os_free(<span class="enscript-type">void</span> * addr);

} <span class="enscript-comment">/* extern &quot;C&quot; */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">malloc</span>(s) kern_os_malloc(s)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">realloc</span>(a, s) kern_os_realloc(a, s)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">free</span>(a) kern_os_free((void *)a)



<span class="enscript-comment">/* Enabling traces.  */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYDEBUG</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYDEBUG</span> 0
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Enabling verbose error messages.  */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span>
# <span class="enscript-reference">undef</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span> 1
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span> 0
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Enabling the token table.  */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYTOKEN_TABLE</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYTOKEN_TABLE</span> 0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">YYSTYPE</span> &amp;&amp; ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">YYSTYPE_IS_DECLARED</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> YYSTYPE;
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">yystype</span> YYSTYPE <span class="enscript-comment">/* obsolescent; will be withdrawn */</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTYPE_IS_DECLARED</span> 1
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTYPE_IS_TRIVIAL</span> 1
#<span class="enscript-reference">endif</span>



<span class="enscript-comment">/* Copy the second part of user declarations.  */</span>


<span class="enscript-comment">/* Line 216 of yacc.c.  */</span>
#<span class="enscript-reference">line</span> 215 <span class="enscript-string">&quot;OSUnserializeXML.tab.c&quot;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">short</span>
# <span class="enscript-reference">undef</span> <span class="enscript-variable-name">short</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYTYPE_UINT8</span>
<span class="enscript-type">typedef</span> YYTYPE_UINT8 yytype_uint8;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> yytype_uint8;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYTYPE_INT8</span>
<span class="enscript-type">typedef</span> YYTYPE_INT8 yytype_int8;
#<span class="enscript-reference">elif</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">typedef</span> <span class="enscript-type">signed</span> <span class="enscript-type">char</span> yytype_int8;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">short</span> <span class="enscript-type">int</span> yytype_int8;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYTYPE_UINT16</span>
<span class="enscript-type">typedef</span> YYTYPE_UINT16 yytype_uint16;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> <span class="enscript-type">int</span> yytype_uint16;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYTYPE_INT16</span>
<span class="enscript-type">typedef</span> YYTYPE_INT16 yytype_int16;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">short</span> <span class="enscript-type">int</span> yytype_int16;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYSIZE_T</span>
# <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__SIZE_TYPE__</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSIZE_T</span> __SIZE_TYPE__
# <span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">size_t</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSIZE_T</span> size_t
# <span class="enscript-reference">elif</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">YYSIZE_T</span> &amp;&amp; (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
#  <span class="enscript-reference">include</span> <span class="enscript-string">&lt;stddef.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSIZE_T</span> size_t
# <span class="enscript-reference">else</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSIZE_T</span> unsigned int
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSIZE_MAXIMUM</span> ((YYSIZE_T) -1)

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YY_</span>
# <span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">YYENABLE_NLS</span> &amp;&amp; <span class="enscript-variable-name">YYENABLE_NLS</span>
#  <span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_NLS</span>
#   <span class="enscript-reference">include</span> <span class="enscript-string">&lt;libintl.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_</span>(msgid) dgettext (<span class="enscript-string">&quot;bison-runtime&quot;</span>, msgid)
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>
# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YY_</span>
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_</span>(msgid) msgid
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Suppress unused-variable warnings by &quot;using&quot; E.  */</span>
#<span class="enscript-reference">if</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">lint</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__GNUC__</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYUSE</span>(e) ((void) (e))
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYUSE</span>(e) <span class="enscript-comment">/* empty */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Identity function, used to suppress warnings about constant conditions.  */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">lint</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYID</span>(n) (n)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">YYID</span> (<span class="enscript-type">int</span> i)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">YYID</span> (i)
    <span class="enscript-type">int</span> i;
#<span class="enscript-reference">endif</span>
{
  <span class="enscript-keyword">return</span> i;
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">yyoverflow</span> || <span class="enscript-variable-name">YYERROR_VERBOSE</span>

<span class="enscript-comment">/* The parser invokes alloca or malloc; define the necessary symbols.  */</span>

# <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYSTACK_USE_ALLOCA</span>
#  <span class="enscript-reference">if</span> <span class="enscript-variable-name">YYSTACK_USE_ALLOCA</span>
#   <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__GNUC__</span>
#    <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_ALLOC</span> __builtin_alloca
#   <span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__BUILTIN_VA_ARG_INCR</span>
#    <span class="enscript-reference">include</span> <span class="enscript-string">&lt;alloca.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#   <span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_AIX</span>
#    <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_ALLOC</span> __alloca
#   <span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_MSC_VER</span>
#    <span class="enscript-reference">include</span> <span class="enscript-string">&lt;malloc.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#    <span class="enscript-reference">define</span> <span class="enscript-variable-name">alloca</span> _alloca
#   <span class="enscript-reference">else</span>
#    <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_ALLOC</span> alloca
#    <span class="enscript-reference">if</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_ALLOCA_H</span> &amp;&amp; ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_STDLIB_H</span> &amp;&amp; (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
#     <span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#     <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_STDLIB_H</span>
#      <span class="enscript-reference">define</span> <span class="enscript-variable-name">_STDLIB_H</span> 1
#     <span class="enscript-reference">endif</span>
#    <span class="enscript-reference">endif</span>
#   <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>

# <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYSTACK_ALLOC</span>
   <span class="enscript-comment">/* Pacify GCC's `empty if-body' warning.  */</span>
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">YYSTACK_FREE</span>(Ptr) do { <span class="enscript-comment">/* empty */</span>; } while (YYID (0))
#  <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYSTACK_ALLOC_MAXIMUM</span>
    <span class="enscript-comment">/* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_ALLOC_MAXIMUM</span> 4032 <span class="enscript-comment">/* reasonable circa 2006 */</span>
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">else</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_ALLOC</span> YYMALLOC
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_FREE</span> YYFREE
#  <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYSTACK_ALLOC_MAXIMUM</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_ALLOC_MAXIMUM</span> YYSIZE_MAXIMUM
#  <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__cplusplus</span> &amp;&amp; ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_STDLIB_H</span> \
       &amp;&amp; ! ((defined YYMALLOC || defined malloc) \
	     &amp;&amp; (defined YYFREE || defined free)))
#   <span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#   <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_STDLIB_H</span>
#    <span class="enscript-reference">define</span> <span class="enscript-variable-name">_STDLIB_H</span> 1
#   <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYMALLOC</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYMALLOC</span> malloc
#   <span class="enscript-reference">if</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">malloc</span> &amp;&amp; ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_STDLIB_H</span> &amp;&amp; (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">void</span> *<span class="enscript-function-name">malloc</span> (YYSIZE_T); <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#   <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYFREE</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYFREE</span> free
#   <span class="enscript-reference">if</span> ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">free</span> &amp;&amp; ! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_STDLIB_H</span> &amp;&amp; (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">void</span> <span class="enscript-function-name">free</span> (<span class="enscript-type">void</span> *); <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#   <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! defined yyoverflow || YYERROR_VERBOSE */</span>


#<span class="enscript-reference">if</span> (! <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">yyoverflow</span> \
     &amp;&amp; (! defined __cplusplus \
	 || (defined YYSTYPE_IS_TRIVIAL &amp;&amp; YYSTYPE_IS_TRIVIAL)))

<span class="enscript-comment">/* A type that is properly aligned for any stack member.  */</span>
<span class="enscript-type">union</span> yyalloc
{
  yytype_int16 yyss;
  YYSTYPE yyvs;
  };

<span class="enscript-comment">/* The size of the maximum gap between one aligned stack and the next.  */</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYSTACK_GAP_MAXIMUM</span> (sizeof (union yyalloc) - 1)

<span class="enscript-comment">/* The size of an array large to enough to hold all stacks, each with
   N elements.  */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYSTACK_BYTES</span>(N) \
     ((N) * (<span class="enscript-keyword">sizeof</span> (yytype_int16) + <span class="enscript-keyword">sizeof</span> (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

<span class="enscript-comment">/* Copy COUNT objects from FROM to TO.  The source and destination do
   not overlap.  */</span>
# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYCOPY</span>
#  <span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__GNUC__</span> &amp;&amp; 1 &lt; <span class="enscript-variable-name">__GNUC__</span>
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">YYCOPY</span>(To, From, Count) \
      __builtin_memcpy (To, From, (Count) * <span class="enscript-keyword">sizeof</span> (*(From)))
#  <span class="enscript-reference">else</span>
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">YYCOPY</span>(To, From, Count)		\
      <span class="enscript-keyword">do</span>					\
	{					\
	  YYSIZE_T yyi;				\
	  <span class="enscript-keyword">for</span> (yyi = 0; yyi &lt; (Count); yyi++)	\
	    (To)[yyi] = (From)[yyi];		\
	}					\
      <span class="enscript-keyword">while</span> (YYID (0))
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYSTACK_RELOCATE</span>(Stack)					\
    <span class="enscript-keyword">do</span>									\
      {									\
	YYSIZE_T yynewbytes;						\
	YYCOPY (&amp;yyptr-&gt;Stack, Stack, yysize);				\
	Stack = &amp;yyptr-&gt;Stack;						\
	yynewbytes = yystacksize * <span class="enscript-keyword">sizeof</span> (*Stack) + YYSTACK_GAP_MAXIMUM; \
	yyptr += yynewbytes / <span class="enscript-keyword">sizeof</span> (*yyptr);				\
      }									\
    <span class="enscript-keyword">while</span> (YYID (0))

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* YYFINAL -- State number of the termination state.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYFINAL</span>  33
<span class="enscript-comment">/* YYLAST -- Last index in YYTABLE.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYLAST</span>   108

<span class="enscript-comment">/* YYNTOKENS -- Number of terminals.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYNTOKENS</span>  19
<span class="enscript-comment">/* YYNNTS -- Number of nonterminals.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYNNTS</span>  15
<span class="enscript-comment">/* YYNRULES -- Number of rules.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYNRULES</span>  32
<span class="enscript-comment">/* YYNRULES -- Number of states.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYNSTATES</span>  40

<span class="enscript-comment">/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYUNDEFTOK</span>  2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYMAXUTOK</span>   267

#<span class="enscript-reference">define</span> <span class="enscript-function-name">YYTRANSLATE</span>(YYX)						\
  ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (YYX) &lt;= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)

<span class="enscript-comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      15,    16,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    17,     2,    18,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    13,     2,    14,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">YYDEBUG</span>
<span class="enscript-comment">/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
   YYRHS.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yyprhs[] =
{
       0,     0,     3,     4,     6,     8,    10,    12,    14,    16,
      18,    20,    22,    24,    27,    31,    33,    35,    38,    41,
      43,    46,    50,    52,    55,    59,    61,    63,    66,    68,
      70,    72,    74
};

<span class="enscript-comment">/* YYRHS -- A `-1'-separated list of the rules' RHS.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_int8 yyrhs[] =
{
      20,     0,    -1,    -1,    21,    -1,    12,    -1,    22,    -1,
      26,    -1,    27,    -1,    33,    -1,    30,    -1,    32,    -1,
      29,    -1,    31,    -1,    13,    14,    -1,    13,    23,    14,
      -1,     6,    -1,    24,    -1,    23,    24,    -1,    25,    21,
      -1,     8,    -1,    15,    16,    -1,    15,    28,    16,    -1,
       3,    -1,    17,    18,    -1,    17,    28,    18,    -1,    10,
      -1,    21,    -1,    28,    21,    -1,     4,    -1,     5,    -1,
       7,    -1,     9,    -1,    11,    -1
};

<span class="enscript-comment">/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint16 yyrline[] =
{
       0,   149,   149,   152,   157,   162,   170,   178,   186,   194,
     202,   210,   218,   237,   240,   243,   246,   247,   262,   271,
     283,   286,   289,   292,   295,   298,   301,   304,   311,   314,
     317,   320,   323
};
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">YYDEBUG</span> || <span class="enscript-variable-name">YYERROR_VERBOSE</span> || <span class="enscript-variable-name">YYTOKEN_TABLE</span>
<span class="enscript-comment">/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> yytname[] =
{
  <span class="enscript-string">&quot;$end&quot;</span>, <span class="enscript-string">&quot;error&quot;</span>, <span class="enscript-string">&quot;$undefined&quot;</span>, <span class="enscript-string">&quot;ARRAY&quot;</span>, <span class="enscript-string">&quot;BOOLEAN&quot;</span>, <span class="enscript-string">&quot;DATA&quot;</span>, <span class="enscript-string">&quot;DICTIONARY&quot;</span>,
  <span class="enscript-string">&quot;IDREF&quot;</span>, <span class="enscript-string">&quot;KEY&quot;</span>, <span class="enscript-string">&quot;NUMBER&quot;</span>, <span class="enscript-string">&quot;SET&quot;</span>, <span class="enscript-string">&quot;STRING&quot;</span>, <span class="enscript-string">&quot;SYNTAX_ERROR&quot;</span>, <span class="enscript-string">&quot;'{'&quot;</span>, <span class="enscript-string">&quot;'}'&quot;</span>,
  <span class="enscript-string">&quot;'('&quot;</span>, <span class="enscript-string">&quot;')'&quot;</span>, <span class="enscript-string">&quot;'['&quot;</span>, <span class="enscript-string">&quot;']'&quot;</span>, <span class="enscript-string">&quot;$accept&quot;</span>, <span class="enscript-string">&quot;input&quot;</span>, <span class="enscript-string">&quot;object&quot;</span>, <span class="enscript-string">&quot;dict&quot;</span>,
  <span class="enscript-string">&quot;pairs&quot;</span>, <span class="enscript-string">&quot;pair&quot;</span>, <span class="enscript-string">&quot;key&quot;</span>, <span class="enscript-string">&quot;array&quot;</span>, <span class="enscript-string">&quot;set&quot;</span>, <span class="enscript-string">&quot;elements&quot;</span>, <span class="enscript-string">&quot;boolean&quot;</span>, <span class="enscript-string">&quot;data&quot;</span>,
  <span class="enscript-string">&quot;idref&quot;</span>, <span class="enscript-string">&quot;number&quot;</span>, <span class="enscript-string">&quot;string&quot;</span>, 0
};
#<span class="enscript-reference">endif</span>

# <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYPRINT</span>
<span class="enscript-comment">/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
   token YYLEX-NUM.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
     265,   266,   267,   123,   125,    40,    41,    91,    93
};
# <span class="enscript-reference">endif</span>

<span class="enscript-comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yyr1[] =
{
       0,    19,    20,    20,    20,    21,    21,    21,    21,    21,
      21,    21,    21,    22,    22,    22,    23,    23,    24,    25,
      26,    26,    26,    27,    27,    27,    28,    28,    29,    30,
      31,    32,    33
};

<span class="enscript-comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yyr2[] =
{
       0,     2,     0,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     2,     3,     1,     1,     2,     2,     1,
       2,     3,     1,     2,     3,     1,     1,     2,     1,     1,
       1,     1,     1
};

<span class="enscript-comment">/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
   means the default is an error.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yydefact[] =
{
       2,    22,    28,    29,    15,    30,    31,    25,    32,     4,
       0,     0,     0,     0,     3,     5,     6,     7,    11,     9,
      12,    10,     8,    19,    13,     0,    16,     0,    20,    26,
       0,    23,     0,     1,    14,    17,    18,    21,    27,    24
};

<span class="enscript-comment">/* YYDEFGOTO[NTERM-NUM].  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_int8 yydefgoto[] =
{
      -1,    13,    29,    15,    25,    26,    27,    16,    17,    30,
      18,    19,    20,    21,    22
};

<span class="enscript-comment">/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYPACT_NINF</span> -20
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_int8 yypact[] =
{
      46,   -20,   -20,   -20,   -20,   -20,   -20,   -20,   -20,   -20,
       4,    61,    -2,    10,   -20,   -20,   -20,   -20,   -20,   -20,
     -20,   -20,   -20,   -20,   -20,     6,   -20,    91,   -20,   -20,
      76,   -20,    30,   -20,   -20,   -20,   -20,   -20,   -20,   -20
};

<span class="enscript-comment">/* YYPGOTO[NTERM-NUM].  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_int8 yypgoto[] =
{
     -20,   -20,     0,   -20,   -20,   -19,   -20,   -20,   -20,     5,
     -20,   -20,   -20,   -20,   -20
};

<span class="enscript-comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule which
   number is the opposite.  If zero, do what YYDEFACT says.
   If YYTABLE_NINF, syntax error.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYTABLE_NINF</span> -1
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yytable[] =
{
      14,     1,     2,     3,     4,     5,    35,     6,     7,     8,
      33,    10,    23,    11,    23,    12,    31,    32,    24,     0,
      34,     0,     0,     0,     0,     0,     0,    36,     0,     0,
      38,     0,    38,     1,     2,     3,     4,     5,     0,     6,
       7,     8,     0,    10,     0,    11,     0,    12,    39,     1,
       2,     3,     4,     5,     0,     6,     7,     8,     9,    10,
       0,    11,     0,    12,     1,     2,     3,     4,     5,     0,
       6,     7,     8,     0,    10,     0,    11,    28,    12,     1,
       2,     3,     4,     5,     0,     6,     7,     8,     0,    10,
       0,    11,    37,    12,     1,     2,     3,     4,     5,     0,
       6,     7,     8,     0,    10,     0,    11,     0,    12
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_int8 yycheck[] =
{
       0,     3,     4,     5,     6,     7,    25,     9,    10,    11,
       0,    13,     8,    15,     8,    17,    18,    12,    14,    -1,
      14,    -1,    -1,    -1,    -1,    -1,    -1,    27,    -1,    -1,
      30,    -1,    32,     3,     4,     5,     6,     7,    -1,     9,
      10,    11,    -1,    13,    -1,    15,    -1,    17,    18,     3,
       4,     5,     6,     7,    -1,     9,    10,    11,    12,    13,
      -1,    15,    -1,    17,     3,     4,     5,     6,     7,    -1,
       9,    10,    11,    -1,    13,    -1,    15,    16,    17,     3,
       4,     5,     6,     7,    -1,     9,    10,    11,    -1,    13,
      -1,    15,    16,    17,     3,     4,     5,     6,     7,    -1,
       9,    10,    11,    -1,    13,    -1,    15,    -1,    17
};

<span class="enscript-comment">/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
   symbol of state STATE-NUM.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> yytype_uint8 yystos[] =
{
       0,     3,     4,     5,     6,     7,     9,    10,    11,    12,
      13,    15,    17,    20,    21,    22,    26,    27,    29,    30,
      31,    32,    33,     8,    14,    23,    24,    25,    16,    21,
      28,    18,    28,     0,    14,    24,    21,    16,    21,    18
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yyerrok</span>		(yyerrstatus = 0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">yyclearin</span>	(yychar = YYEMPTY)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYEMPTY</span>		(-2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYEOF</span>		0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYACCEPT</span>	goto yyacceptlab
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYABORT</span>		goto yyabortlab
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYERROR</span>		goto yyerrorlab


<span class="enscript-comment">/* Like YYERROR except do call yyerror.  This remains here temporarily
   to ease the transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYFAIL</span>		goto yyerrlab

#<span class="enscript-reference">define</span> <span class="enscript-function-name">YYRECOVERING</span>()  (!!yyerrstatus)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">YYBACKUP</span>(Token, Value)					\
<span class="enscript-keyword">do</span>								\
  <span class="enscript-keyword">if</span> (yychar == YYEMPTY &amp;&amp; yylen == 1)				\
    {								\
      yychar = (Token);						\
      yylval = (Value);						\
      yytoken = YYTRANSLATE (yychar);				\
      YYPOPSTACK (1);						\
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">yybackup</span>;						\
    }								\
  <span class="enscript-keyword">else</span>								\
    {								\
      yyerror (YY_(<span class="enscript-string">&quot;syntax error: cannot back up&quot;</span>)); \
      YYERROR;							\
    }								\
<span class="enscript-function-name">while</span> (YYID (0))


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYTERROR</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YYERRCODE</span>	256


<span class="enscript-comment">/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">YYRHSLOC</span>(Rhs, K) ((Rhs)[K])
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYLLOC_DEFAULT</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYLLOC_DEFAULT</span>(Current, Rhs, N)				\
    <span class="enscript-keyword">do</span>									\
      <span class="enscript-keyword">if</span> (YYID (N))                                                    \
	{								\
	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
	}								\
      <span class="enscript-keyword">else</span>								\
	{								\
	  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).last_column;				\
	}								\
    <span class="enscript-keyword">while</span> (YYID (0))
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* YY_LOCATION_PRINT -- Print the location on the stream.
   This macro was not mandated originally: define only if we know
   we won't break user code: when these are the locations we know.  */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YY_LOCATION_PRINT</span>
# <span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">YYLTYPE_IS_TRIVIAL</span> &amp;&amp; <span class="enscript-variable-name">YYLTYPE_IS_TRIVIAL</span>
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_LOCATION_PRINT</span>(File, Loc)			\
     fprintf (File, <span class="enscript-string">&quot;%d.%d-%d.%d&quot;</span>,			\
	      (Loc).first_line, (Loc).first_column,	\
	      (Loc).last_line,  (Loc).last_column)
# <span class="enscript-reference">else</span>
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_LOCATION_PRINT</span>(File, Loc) ((void) 0)
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* YYLEX -- calling `yylex' with the right arguments.  */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYLEX_PARAM</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYLEX</span> yylex (&amp;yylval, YYLEX_PARAM)
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYLEX</span> yylex (&amp;yylval)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Enable debugging if requested.  */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">YYDEBUG</span>

# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYFPRINTF</span>
#  <span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span> <span class="enscript-comment">/* INFRINGES ON USER NAME SPACE */</span>
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYFPRINTF</span> fprintf
# <span class="enscript-reference">endif</span>

# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYDPRINTF</span>(Args)			\
<span class="enscript-keyword">do</span> {						\
  <span class="enscript-keyword">if</span> (yydebug)					\
    YYFPRINTF Args;				\
} <span class="enscript-keyword">while</span> (YYID (0))

# <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_SYMBOL_PRINT</span>(Title, Type, Value, Location)			  \
<span class="enscript-keyword">do</span> {									  \
  <span class="enscript-keyword">if</span> (yydebug)								  \
    {									  \
      YYFPRINTF (stderr, <span class="enscript-string">&quot;%s &quot;</span>, Title);					  \
      yy_symbol_print (stderr,						  \
		  Type, Value); \
      YYFPRINTF (stderr, <span class="enscript-string">&quot;\n&quot;</span>);						  \
    }									  \
} <span class="enscript-keyword">while</span> (YYID (0))


<span class="enscript-comment">/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_symbol_value_print</span> (FILE *yyoutput, <span class="enscript-type">int</span> yytype, YYSTYPE <span class="enscript-type">const</span> * <span class="enscript-type">const</span> yyvaluep)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_symbol_value_print</span> (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    <span class="enscript-type">int</span> yytype;
    YYSTYPE <span class="enscript-type">const</span> * <span class="enscript-type">const</span> yyvaluep;
#<span class="enscript-reference">endif</span>
{
  <span class="enscript-keyword">if</span> (!yyvaluep)
    <span class="enscript-keyword">return</span>;
# <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYPRINT</span>
  <span class="enscript-keyword">if</span> (yytype &lt; YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# <span class="enscript-reference">else</span>
  YYUSE (yyoutput);
# <span class="enscript-reference">endif</span>
  <span class="enscript-keyword">switch</span> (yytype)
    {
      <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
}


<span class="enscript-comment">/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/</span>

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_symbol_print</span> (FILE *yyoutput, <span class="enscript-type">int</span> yytype, YYSTYPE <span class="enscript-type">const</span> * <span class="enscript-type">const</span> yyvaluep)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_symbol_print</span> (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    <span class="enscript-type">int</span> yytype;
    YYSTYPE <span class="enscript-type">const</span> * <span class="enscript-type">const</span> yyvaluep;
#<span class="enscript-reference">endif</span>
{
  <span class="enscript-keyword">if</span> (yytype &lt; YYNTOKENS)
    YYFPRINTF (yyoutput, <span class="enscript-string">&quot;token %s (&quot;</span>, yytname[yytype]);
  <span class="enscript-keyword">else</span>
    YYFPRINTF (yyoutput, <span class="enscript-string">&quot;nterm %s (&quot;</span>, yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
  YYFPRINTF (yyoutput, <span class="enscript-string">&quot;)&quot;</span>);
}

<span class="enscript-comment">/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/</span>

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_stack_print</span> (yytype_int16 *bottom, yytype_int16 *top)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_stack_print</span> (bottom, top)
    yytype_int16 *bottom;
    yytype_int16 *top;
#<span class="enscript-reference">endif</span>
{
  YYFPRINTF (stderr, <span class="enscript-string">&quot;Stack now&quot;</span>);
  <span class="enscript-keyword">for</span> (; bottom &lt;= top; ++bottom)
    YYFPRINTF (stderr, <span class="enscript-string">&quot; %d&quot;</span>, *bottom);
  YYFPRINTF (stderr, <span class="enscript-string">&quot;\n&quot;</span>);
}

# <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_STACK_PRINT</span>(Bottom, Top)				\
<span class="enscript-keyword">do</span> {								\
  <span class="enscript-keyword">if</span> (yydebug)							\
    yy_stack_print ((Bottom), (Top));				\
} <span class="enscript-keyword">while</span> (YYID (0))


<span class="enscript-comment">/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/</span>

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_reduce_print</span> (YYSTYPE *yyvsp, <span class="enscript-type">int</span> yyrule)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yy_reduce_print</span> (yyvsp, yyrule)
    YYSTYPE *yyvsp;
    <span class="enscript-type">int</span> yyrule;
#<span class="enscript-reference">endif</span>
{
  <span class="enscript-type">int</span> yynrhs = yyr2[yyrule];
  <span class="enscript-type">int</span> yyi;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">int</span> yylno = yyrline[yyrule];
  YYFPRINTF (stderr, <span class="enscript-string">&quot;Reducing stack by rule %d (line %lu):\n&quot;</span>,
	     yyrule - 1, yylno);
  <span class="enscript-comment">/* The symbols being reduced.  */</span>
  <span class="enscript-keyword">for</span> (yyi = 0; yyi &lt; yynrhs; yyi++)
    {
      fprintf (stderr, <span class="enscript-string">&quot;   $%d = &quot;</span>, yyi + 1);
      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
		       &amp;(yyvsp[(yyi + 1) - (yynrhs)])
		       		       );
      fprintf (stderr, <span class="enscript-string">&quot;\n&quot;</span>);
    }
}

# <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_REDUCE_PRINT</span>(Rule)		\
<span class="enscript-keyword">do</span> {					\
  <span class="enscript-keyword">if</span> (yydebug)				\
    yy_reduce_print (yyvsp, Rule); \
} <span class="enscript-keyword">while</span> (YYID (0))

<span class="enscript-comment">/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */</span>
<span class="enscript-type">int</span> yydebug;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !YYDEBUG */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YYDPRINTF</span>(Args)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_SYMBOL_PRINT</span>(Title, Type, Value, Location)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_STACK_PRINT</span>(Bottom, Top)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">YY_REDUCE_PRINT</span>(Rule)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !YYDEBUG */</span>


<span class="enscript-comment">/* YYINITDEPTH -- initial size of the parser's stacks.  */</span>
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">YYINITDEPTH</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYINITDEPTH</span> 200
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM &lt; YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYMAXDEPTH</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">YYMAXDEPTH</span> 10000
#<span class="enscript-reference">endif</span>



#<span class="enscript-reference">if</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span>

# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">yystrlen</span>
#  <span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__GLIBC__</span> &amp;&amp; <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_STRING_H</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">yystrlen</span> strlen
#  <span class="enscript-reference">else</span>
<span class="enscript-comment">/* Return the length of YYSTR.  */</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> YYSIZE_T
<span class="enscript-function-name">yystrlen</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *yystr)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> YYSIZE_T
<span class="enscript-function-name">yystrlen</span> (yystr)
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *yystr;
#<span class="enscript-reference">endif</span>
{
  YYSIZE_T yylen;
  <span class="enscript-keyword">for</span> (yylen = 0; yystr[yylen]; yylen++)
    <span class="enscript-keyword">continue</span>;
  <span class="enscript-keyword">return</span> yylen;
}
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>

# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">yystpcpy</span>
#  <span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__GLIBC__</span> &amp;&amp; <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_STRING_H</span> &amp;&amp; <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_GNU_SOURCE</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">yystpcpy</span> stpcpy
#  <span class="enscript-reference">else</span>
<span class="enscript-comment">/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">yystpcpy</span> (<span class="enscript-type">char</span> *yydest, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *yysrc)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">yystpcpy</span> (yydest, yysrc)
    <span class="enscript-type">char</span> *yydest;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *yysrc;
#<span class="enscript-reference">endif</span>
{
  <span class="enscript-type">char</span> *yyd = yydest;
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *yys = yysrc;

  <span class="enscript-keyword">while</span> ((*yyd++ = *yys++) != <span class="enscript-string">'\0'</span>)
    <span class="enscript-keyword">continue</span>;

  <span class="enscript-keyword">return</span> yyd - 1;
}
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>

# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">yytnamerr</span>
<span class="enscript-comment">/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */</span>
<span class="enscript-type">static</span> YYSIZE_T
<span class="enscript-function-name">yytnamerr</span> (<span class="enscript-type">char</span> *yyres, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *yystr)
{
  <span class="enscript-keyword">if</span> (*yystr == <span class="enscript-string">'&quot;'</span>)
    {
      YYSIZE_T yyn = 0;
      <span class="enscript-type">char</span> <span class="enscript-type">const</span> *yyp = yystr;

      <span class="enscript-keyword">for</span> (;;)
	<span class="enscript-keyword">switch</span> (*++yyp)
	  {
	  <span class="enscript-keyword">case</span> <span class="enscript-string">'\''</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-string">','</span>:
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">do_not_strip_quotes</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-string">'\\'</span>:
	    <span class="enscript-keyword">if</span> (*++yyp != <span class="enscript-string">'\\'</span>)
	      <span class="enscript-keyword">goto</span> <span class="enscript-reference">do_not_strip_quotes</span>;
	    <span class="enscript-comment">/* Fall through.  */</span>
	  <span class="enscript-reference">default</span>:
	    <span class="enscript-keyword">if</span> (yyres)
	      yyres[yyn] = *yyp;
	    yyn++;
	    <span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-string">'&quot;'</span>:
	    <span class="enscript-keyword">if</span> (yyres)
	      yyres[yyn] = <span class="enscript-string">'\0'</span>;
	    <span class="enscript-keyword">return</span> yyn;
	  }
    <span class="enscript-reference">do_not_strip_quotes</span>: ;
    }

  <span class="enscript-keyword">if</span> (! yyres)
    <span class="enscript-keyword">return</span> yystrlen (yystr);

  <span class="enscript-keyword">return</span> yystpcpy (yyres, yystr) - yyres;
}
# <span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Copy into YYRESULT an error message about the unexpected token
   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
   including the terminating null byte.  If YYRESULT is null, do not
   copy anything; just return the number of bytes that would be
   copied.  As a special case, return 0 if an ordinary &quot;syntax error&quot;
   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
   size calculation.  */</span>
<span class="enscript-type">static</span> YYSIZE_T
<span class="enscript-function-name">yysyntax_error</span> (<span class="enscript-type">char</span> *yyresult, <span class="enscript-type">int</span> yystate, <span class="enscript-type">int</span> yychar)
{
  <span class="enscript-type">int</span> yyn = yypact[yystate];

  <span class="enscript-keyword">if</span> (! (YYPACT_NINF &lt; yyn &amp;&amp; yyn &lt;= YYLAST))
    <span class="enscript-keyword">return</span> 0;
  <span class="enscript-keyword">else</span>
    {
      <span class="enscript-type">int</span> yytype = YYTRANSLATE (yychar);
      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
      YYSIZE_T yysize = yysize0;
      YYSIZE_T yysize1;
      <span class="enscript-type">int</span> yysize_overflow = 0;
      <span class="enscript-type">enum</span> { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
      <span class="enscript-type">char</span> <span class="enscript-type">const</span> *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
      <span class="enscript-type">int</span> yyx;

# <span class="enscript-reference">if</span> 0
      <span class="enscript-comment">/* This is so xgettext sees the translatable formats that are
	 constructed on the fly.  */</span>
      YY_(<span class="enscript-string">&quot;syntax error, unexpected %s&quot;</span>);
      YY_(<span class="enscript-string">&quot;syntax error, unexpected %s, expecting %s&quot;</span>);
      YY_(<span class="enscript-string">&quot;syntax error, unexpected %s, expecting %s or %s&quot;</span>);
      YY_(<span class="enscript-string">&quot;syntax error, unexpected %s, expecting %s or %s or %s&quot;</span>);
      YY_(<span class="enscript-string">&quot;syntax error, unexpected %s, expecting %s or %s or %s or %s&quot;</span>);
# <span class="enscript-reference">endif</span>
      <span class="enscript-type">char</span> *yyfmt;
      <span class="enscript-type">char</span> <span class="enscript-type">const</span> *yyf;
      <span class="enscript-type">static</span> <span class="enscript-type">char</span> <span class="enscript-type">const</span> yyunexpected[] = <span class="enscript-string">&quot;syntax error, unexpected %s&quot;</span>;
      <span class="enscript-type">static</span> <span class="enscript-type">char</span> <span class="enscript-type">const</span> yyexpecting[] = <span class="enscript-string">&quot;, expecting %s&quot;</span>;
      <span class="enscript-type">static</span> <span class="enscript-type">char</span> <span class="enscript-type">const</span> yyor[] = <span class="enscript-string">&quot; or %s&quot;</span>;
      <span class="enscript-type">char</span> yyformat[<span class="enscript-keyword">sizeof</span> yyunexpected
		    + <span class="enscript-keyword">sizeof</span> yyexpecting - 1
		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
		       * (<span class="enscript-keyword">sizeof</span> yyor - 1))];
      <span class="enscript-type">char</span> <span class="enscript-type">const</span> *yyprefix = yyexpecting;

      <span class="enscript-comment">/* Start YYX at -YYN if negative to avoid negative indexes in
	 YYCHECK.  */</span>
      <span class="enscript-type">int</span> yyxbegin = yyn &lt; 0 ? -yyn : 0;

      <span class="enscript-comment">/* Stay within bounds of both yycheck and yytname.  */</span>
      <span class="enscript-type">int</span> yychecklim = YYLAST - yyn + 1;
      <span class="enscript-type">int</span> yyxend = yychecklim &lt; YYNTOKENS ? yychecklim : YYNTOKENS;
      <span class="enscript-type">int</span> yycount = 1;

      yyarg[0] = yytname[yytype];
      yyfmt = yystpcpy (yyformat, yyunexpected);

      <span class="enscript-keyword">for</span> (yyx = yyxbegin; yyx &lt; yyxend; ++yyx)
	<span class="enscript-keyword">if</span> (yycheck[yyx + yyn] == yyx &amp;&amp; yyx != YYTERROR)
	  {
	    <span class="enscript-keyword">if</span> (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
	      {
		yycount = 1;
		yysize = yysize0;
		yyformat[<span class="enscript-keyword">sizeof</span> yyunexpected - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">break</span>;
	      }
	    yyarg[yycount++] = yytname[yyx];
	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
	    yysize_overflow |= (yysize1 &lt; yysize);
	    yysize = yysize1;
	    yyfmt = yystpcpy (yyfmt, yyprefix);
	    yyprefix = yyor;
	  }

      yyf = YY_(yyformat);
      yysize1 = yysize + yystrlen (yyf);
      yysize_overflow |= (yysize1 &lt; yysize);
      yysize = yysize1;

      <span class="enscript-keyword">if</span> (yysize_overflow)
	<span class="enscript-keyword">return</span> YYSIZE_MAXIMUM;

      <span class="enscript-keyword">if</span> (yyresult)
	{
	  <span class="enscript-comment">/* Avoid sprintf, as that infringes on the user's name space.
	     Don't have undefined behavior even if the translation
	     produced a string with the wrong number of &quot;%s&quot;s.  */</span>
	  <span class="enscript-type">char</span> *yyp = yyresult;
	  <span class="enscript-type">int</span> yyi = 0;
	  <span class="enscript-keyword">while</span> ((*yyp = *yyf) != <span class="enscript-string">'\0'</span>)
	    {
	      <span class="enscript-keyword">if</span> (*yyp == <span class="enscript-string">'%'</span> &amp;&amp; yyf[1] == <span class="enscript-string">'s'</span> &amp;&amp; yyi &lt; yycount)
		{
		  yyp += yytnamerr (yyp, yyarg[yyi++]);
		  yyf += 2;
		}
	      <span class="enscript-keyword">else</span>
		{
		  yyp++;
		  yyf++;
		}
	    }
	}
      <span class="enscript-keyword">return</span> yysize;
    }
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* YYERROR_VERBOSE */</span>


<span class="enscript-comment">/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yydestruct</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *yymsg, <span class="enscript-type">int</span> yytype, YYSTYPE *yyvaluep)
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">yydestruct</span> (yymsg, yytype, yyvaluep)
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *yymsg;
    <span class="enscript-type">int</span> yytype;
    YYSTYPE *yyvaluep;
#<span class="enscript-reference">endif</span>
{
  YYUSE (yyvaluep);

  <span class="enscript-keyword">if</span> (!yymsg)
    yymsg = <span class="enscript-string">&quot;Deleting&quot;</span>;
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  <span class="enscript-keyword">switch</span> (yytype)
    {

      <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
}


<span class="enscript-comment">/* Prevent warnings from -Wmissing-prototypes.  */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYPARSE_PARAM</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">yyparse</span> (<span class="enscript-type">void</span> *YYPARSE_PARAM);
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">yyparse</span> ();
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* ! YYPARSE_PARAM */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">yyparse</span> (<span class="enscript-type">void</span>);
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">yyparse</span> ();
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! YYPARSE_PARAM */</span>






<span class="enscript-comment">/*----------.
| yyparse.  |
`----------*/</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">YYPARSE_PARAM</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">int</span>
<span class="enscript-function-name">yyparse</span> (<span class="enscript-type">void</span> *YYPARSE_PARAM)
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">yyparse</span> (YYPARSE_PARAM)
    <span class="enscript-type">void</span> *YYPARSE_PARAM;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* ! YYPARSE_PARAM */</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__STDC__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__C99__FUNC__</span> \
     || defined __cplusplus || defined _MSC_VER)
<span class="enscript-type">int</span>
<span class="enscript-function-name">yyparse</span> (<span class="enscript-type">void</span>)
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">yyparse</span> ()

#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
{
  <span class="enscript-comment">/* The look-ahead symbol.  */</span>
<span class="enscript-type">int</span> yychar;

<span class="enscript-comment">/* The semantic value of the look-ahead symbol.  */</span>
YYSTYPE yylval;

<span class="enscript-comment">/* Number of syntax errors so far.  */</span>
<span class="enscript-type">int</span> yynerrs;

  <span class="enscript-type">int</span> yystate;
  <span class="enscript-type">int</span> yyn;
  <span class="enscript-type">int</span> yyresult;
  <span class="enscript-comment">/* Number of tokens to shift before error messages enabled.  */</span>
  <span class="enscript-type">int</span> yyerrstatus;
  <span class="enscript-comment">/* Look-ahead token as an internal (translated) token number.  */</span>
  <span class="enscript-type">int</span> yytoken = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span>
  <span class="enscript-comment">/* Buffer for error messages, and its allocated size.  */</span>
  <span class="enscript-type">char</span> yymsgbuf[128];
  <span class="enscript-type">char</span> *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = <span class="enscript-keyword">sizeof</span> yymsgbuf;
#<span class="enscript-reference">endif</span>

  <span class="enscript-comment">/* Three stacks and their tools:
     `yyss': related to states,
     `yyvs': related to semantic values,
     `yyls': related to locations.

     Refer to the stacks thru separate pointers, to allow yyoverflow
     to reallocate them elsewhere.  */</span>

  <span class="enscript-comment">/* The state stack.  */</span>
  yytype_int16 yyssa[YYINITDEPTH];
  yytype_int16 *yyss = yyssa;
  yytype_int16 *yyssp;

  <span class="enscript-comment">/* The semantic value stack.  */</span>
  YYSTYPE yyvsa[YYINITDEPTH];
  YYSTYPE *yyvs = yyvsa;
  YYSTYPE *yyvsp;



#<span class="enscript-reference">define</span> <span class="enscript-function-name">YYPOPSTACK</span>(N)   (yyvsp -= (N), yyssp -= (N))

  YYSIZE_T yystacksize = YYINITDEPTH;

  <span class="enscript-comment">/* The variables used to return semantic value and location from the
     action routines.  */</span>
  YYSTYPE yyval;


  <span class="enscript-comment">/* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */</span>
  <span class="enscript-type">int</span> yylen = 0;

  YYDPRINTF ((stderr, <span class="enscript-string">&quot;Starting parse\n&quot;</span>));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		<span class="enscript-comment">/* Cause a token to be read.  */</span>

  <span class="enscript-comment">/* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */</span>

  yyssp = yyss;
  yyvsp = yyvs;

  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yysetstate</span>;

<span class="enscript-comment">/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/</span>
 <span class="enscript-reference">yynewstate</span>:
  <span class="enscript-comment">/* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */</span>
  yyssp++;

 <span class="enscript-reference">yysetstate</span>:
  *yyssp = yystate;

  <span class="enscript-keyword">if</span> (yyss + yystacksize - 1 &lt;= yyssp)
    {
      <span class="enscript-comment">/* Get the current used size of the three stacks, in elements.  */</span>
      YYSIZE_T yysize = yyssp - yyss + 1;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">yyoverflow</span>
      {
	<span class="enscript-comment">/* Give user a chance to reallocate the stack.  Use copies of
	   these so that the &amp;'s don't force the real ones into
	   memory.  */</span>
	YYSTYPE *yyvs1 = yyvs;
	yytype_int16 *yyss1 = yyss;


	<span class="enscript-comment">/* Each stack pointer address is followed by the size of the
	   data in use in that stack, in bytes.  This used to be a
	   conditional around just the two extra args, but that might
	   be undefined if yyoverflow is a macro.  */</span>
	yyoverflow (YY_(<span class="enscript-string">&quot;memory exhausted&quot;</span>),
		    &amp;yyss1, yysize * <span class="enscript-keyword">sizeof</span> (*yyssp),
		    &amp;yyvs1, yysize * <span class="enscript-keyword">sizeof</span> (*yyvsp),

		    &amp;yystacksize);

	yyss = yyss1;
	yyvs = yyvs1;
      }
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* no yyoverflow */</span>
# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YYSTACK_RELOCATE</span>
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyexhaustedlab</span>;
# <span class="enscript-reference">else</span>
      <span class="enscript-comment">/* Extend the stack our own way.  */</span>
      <span class="enscript-keyword">if</span> (YYMAXDEPTH &lt;= yystacksize)
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">yyexhaustedlab</span>;
      yystacksize *= 2;
      <span class="enscript-keyword">if</span> (YYMAXDEPTH &lt; yystacksize)
	yystacksize = YYMAXDEPTH;

      {
	yytype_int16 *yyss1 = yyss;
	<span class="enscript-type">union</span> yyalloc *yyptr =
	  (<span class="enscript-type">union</span> yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
	<span class="enscript-keyword">if</span> (! yyptr)
	  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyexhaustedlab</span>;
	YYSTACK_RELOCATE (yyss);
	YYSTACK_RELOCATE (yyvs);

#  <span class="enscript-reference">undef</span> <span class="enscript-variable-name">YYSTACK_RELOCATE</span>
	<span class="enscript-keyword">if</span> (yyss1 != yyssa)
	  YYSTACK_FREE (yyss1);
      }
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* no yyoverflow */</span>

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;


      YYDPRINTF ((stderr, <span class="enscript-string">&quot;Stack size increased to %lu\n&quot;</span>,
		  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">int</span>) yystacksize));

      <span class="enscript-keyword">if</span> (yyss + yystacksize - 1 &lt;= yyssp)
	YYABORT;
    }

  YYDPRINTF ((stderr, <span class="enscript-string">&quot;Entering state %d\n&quot;</span>, yystate));

  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yybackup</span>;

<span class="enscript-comment">/*-----------.
| yybackup.  |
`-----------*/</span>
<span class="enscript-reference">yybackup</span>:

  <span class="enscript-comment">/* Do appropriate processing given the current state.  Read a
     look-ahead token if we need one and don't already have one.  */</span>

  <span class="enscript-comment">/* First try to decide what to do without reference to look-ahead token.  */</span>
  yyn = yypact[yystate];
  <span class="enscript-keyword">if</span> (yyn == YYPACT_NINF)
    <span class="enscript-keyword">goto</span> <span class="enscript-reference">yydefault</span>;

  <span class="enscript-comment">/* Not known =&gt; get a look-ahead token if don't already have one.  */</span>

  <span class="enscript-comment">/* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */</span>
  <span class="enscript-keyword">if</span> (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, <span class="enscript-string">&quot;Reading a token: &quot;</span>));
      yychar = YYLEX;
    }

  <span class="enscript-keyword">if</span> (yychar &lt;= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, <span class="enscript-string">&quot;Now at end of input.\n&quot;</span>));
    }
  <span class="enscript-keyword">else</span>
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (<span class="enscript-string">&quot;Next token is&quot;</span>, yytoken, &amp;yylval, &amp;yylloc);
    }

  <span class="enscript-comment">/* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */</span>
  yyn += yytoken;
  <span class="enscript-keyword">if</span> (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken)
    <span class="enscript-keyword">goto</span> <span class="enscript-reference">yydefault</span>;
  yyn = yytable[yyn];
  <span class="enscript-keyword">if</span> (yyn &lt;= 0)
    {
      <span class="enscript-keyword">if</span> (yyn == 0 || yyn == YYTABLE_NINF)
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">yyerrlab</span>;
      yyn = -yyn;
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyreduce</span>;
    }

  <span class="enscript-keyword">if</span> (yyn == YYFINAL)
    YYACCEPT;

  <span class="enscript-comment">/* Count tokens shifted since error; after three, turn off error
     status.  */</span>
  <span class="enscript-keyword">if</span> (yyerrstatus)
    yyerrstatus--;

  <span class="enscript-comment">/* Shift the look-ahead token.  */</span>
  YY_SYMBOL_PRINT (<span class="enscript-string">&quot;Shifting&quot;</span>, yytoken, &amp;yylval, &amp;yylloc);

  <span class="enscript-comment">/* Discard the shifted token unless it is eof.  */</span>
  <span class="enscript-keyword">if</span> (yychar != YYEOF)
    yychar = YYEMPTY;

  yystate = yyn;
  *++yyvsp = yylval;

  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yynewstate</span>;


<span class="enscript-comment">/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/</span>
<span class="enscript-reference">yydefault</span>:
  yyn = yydefact[yystate];
  <span class="enscript-keyword">if</span> (yyn == 0)
    <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyerrlab</span>;
  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyreduce</span>;


<span class="enscript-comment">/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/</span>
<span class="enscript-reference">yyreduce</span>:
  <span class="enscript-comment">/* yyn is the number of a rule to reduce with.  */</span>
  yylen = yyr2[yyn];

  <span class="enscript-comment">/* If YYLEN is nonzero, implement the default value of the action:
     `$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */</span>
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  <span class="enscript-keyword">switch</span> (yyn)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
#<span class="enscript-reference">line</span> 149 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { yyerror(<span class="enscript-string">&quot;unexpected end of buffer&quot;</span>);
				  YYERROR;
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
#<span class="enscript-reference">line</span> 152 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { STATE-&gt;parsedObject = (yyvsp[(1) - (1)])-&gt;object;
				  (yyvsp[(1) - (1)])-&gt;object = 0;
				  freeObject(STATE, (yyvsp[(1) - (1)]));
				  YYACCEPT;
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
#<span class="enscript-reference">line</span> 157 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { yyerror(<span class="enscript-string">&quot;syntax error&quot;</span>);
				  YYERROR;
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
#<span class="enscript-reference">line</span> 162 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildDictionary(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
#<span class="enscript-reference">line</span> 170 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildArray(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
#<span class="enscript-reference">line</span> 178 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildSet(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
#<span class="enscript-reference">line</span> 186 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildString(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
#<span class="enscript-reference">line</span> 194 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildData(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
#<span class="enscript-reference">line</span> 202 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildNumber(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
#<span class="enscript-reference">line</span> 210 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildBoolean(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
#<span class="enscript-reference">line</span> 218 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = retrieveObject(STATE, (yyvsp[(1) - (1)])-&gt;idref);
				  <span class="enscript-keyword">if</span> ((yyval)) {
				    (yyval)-&gt;object-&gt;retain();
				  } <span class="enscript-keyword">else</span> { 
				    yyerror(<span class="enscript-string">&quot;forward reference detected&quot;</span>);
				    YYERROR;
				  }
				  freeObject(STATE, (yyvsp[(1) - (1)]));

				  STATE-&gt;parsedObjectCount++;
				  <span class="enscript-keyword">if</span> (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
				    yyerror(<span class="enscript-string">&quot;maximum object count&quot;</span>);
				    YYERROR;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">13</span>:
#<span class="enscript-reference">line</span> 237 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (2)]);
				  (yyval)-&gt;elements = NULL;
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">14</span>:
#<span class="enscript-reference">line</span> 240 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (3)]);
				  (yyval)-&gt;elements = (yyvsp[(2) - (3)]);
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">17</span>:
#<span class="enscript-reference">line</span> 247 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(2) - (2)]);
				  (yyval)-&gt;next = (yyvsp[(1) - (2)]);

				  object_t *o;
				  o = (yyval)-&gt;next;
				  <span class="enscript-keyword">while</span> (o) {
				    <span class="enscript-keyword">if</span> (o-&gt;key == (yyval)-&gt;key) {
				      yyerror(<span class="enscript-string">&quot;duplicate dictionary key&quot;</span>);
				      YYERROR;
				    }
				    o = o-&gt;next;
				  }
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">18</span>:
#<span class="enscript-reference">line</span> 262 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (2)]);
				  (yyval)-&gt;key = (OSSymbol *)(yyval)-&gt;object;
				  (yyval)-&gt;object = (yyvsp[(2) - (2)])-&gt;object;
				  (yyval)-&gt;next = NULL; 
				  (yyvsp[(2) - (2)])-&gt;object = 0;
				  freeObject(STATE, (yyvsp[(2) - (2)]));
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">19</span>:
#<span class="enscript-reference">line</span> 271 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = buildSymbol(STATE, (yyvsp[(1) - (1)]));

<span class="enscript-comment">//				  STATE-&gt;parsedObjectCount++;
</span><span class="enscript-comment">//				  if (STATE-&gt;parsedObjectCount &gt; MAX_OBJECTS) {
</span><span class="enscript-comment">//				    yyerror(&quot;maximum object count&quot;);
</span><span class="enscript-comment">//				    YYERROR;
</span><span class="enscript-comment">//				  }
</span>				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">20</span>:
#<span class="enscript-reference">line</span> 283 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (2)]);
				  (yyval)-&gt;elements = NULL;
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">21</span>:
#<span class="enscript-reference">line</span> 286 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (3)]);
				  (yyval)-&gt;elements = (yyvsp[(2) - (3)]);
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">23</span>:
#<span class="enscript-reference">line</span> 292 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (2)]);
				  (yyval)-&gt;elements = NULL;
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">24</span>:
#<span class="enscript-reference">line</span> 295 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (3)]);
				  (yyval)-&gt;elements = (yyvsp[(2) - (3)]);
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">26</span>:
#<span class="enscript-reference">line</span> 301 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(1) - (1)]); 
				  (yyval)-&gt;next = NULL; 
				;}
    <span class="enscript-keyword">break</span>;

  <span class="enscript-keyword">case</span> <span class="enscript-reference">27</span>:
#<span class="enscript-reference">line</span> 304 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>
    { (yyval) = (yyvsp[(2) - (2)]);
				  (yyval)-&gt;next = (yyvsp[(1) - (2)]);
				;}
    <span class="enscript-keyword">break</span>;


<span class="enscript-comment">/* Line 1267 of yacc.c.  */</span>
#<span class="enscript-reference">line</span> 1671 <span class="enscript-string">&quot;OSUnserializeXML.tab.c&quot;</span>
      <span class="enscript-reference">default</span>: <span class="enscript-keyword">break</span>;
    }
  YY_SYMBOL_PRINT (<span class="enscript-string">&quot;-&gt; $$ =&quot;</span>, yyr1[yyn], &amp;yyval, &amp;yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;


  <span class="enscript-comment">/* Now `shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */</span>

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  <span class="enscript-keyword">if</span> (0 &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  <span class="enscript-keyword">else</span>
    yystate = yydefgoto[yyn - YYNTOKENS];

  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yynewstate</span>;


<span class="enscript-comment">/*------------------------------------.
| yyerrlab -- here on detecting error |
`------------------------------------*/</span>
<span class="enscript-reference">yyerrlab</span>:
  <span class="enscript-comment">/* If not already recovering from an error, report this error.  */</span>
  <span class="enscript-keyword">if</span> (!yyerrstatus)
    {
      ++yynerrs;
#<span class="enscript-reference">if</span> ! <span class="enscript-variable-name">YYERROR_VERBOSE</span>
      yyerror (YY_(<span class="enscript-string">&quot;syntax error&quot;</span>));
#<span class="enscript-reference">else</span>
      {
	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
	<span class="enscript-keyword">if</span> (yymsg_alloc &lt; yysize &amp;&amp; yymsg_alloc &lt; YYSTACK_ALLOC_MAXIMUM)
	  {
	    YYSIZE_T yyalloc = 2 * yysize;
	    <span class="enscript-keyword">if</span> (! (yysize &lt;= yyalloc &amp;&amp; yyalloc &lt;= YYSTACK_ALLOC_MAXIMUM))
	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
	    <span class="enscript-keyword">if</span> (yymsg != yymsgbuf)
	      YYSTACK_FREE (yymsg);
	    yymsg = (<span class="enscript-type">char</span> *) YYSTACK_ALLOC (yyalloc);
	    <span class="enscript-keyword">if</span> (yymsg)
	      yymsg_alloc = yyalloc;
	    <span class="enscript-keyword">else</span>
	      {
		yymsg = yymsgbuf;
		yymsg_alloc = <span class="enscript-keyword">sizeof</span> yymsgbuf;
	      }
	  }

	<span class="enscript-keyword">if</span> (0 &lt; yysize &amp;&amp; yysize &lt;= yymsg_alloc)
	  {
	    (<span class="enscript-type">void</span>) yysyntax_error (yymsg, yystate, yychar);
	    yyerror (yymsg);
	  }
	<span class="enscript-keyword">else</span>
	  {
	    yyerror (YY_(<span class="enscript-string">&quot;syntax error&quot;</span>));
	    <span class="enscript-keyword">if</span> (yysize != 0)
	      <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyexhaustedlab</span>;
	  }
      }
#<span class="enscript-reference">endif</span>
    }



  <span class="enscript-keyword">if</span> (yyerrstatus == 3)
    {
      <span class="enscript-comment">/* If just tried and failed to reuse look-ahead token after an
	 error, discard it.  */</span>

      <span class="enscript-keyword">if</span> (yychar &lt;= YYEOF)
	{
	  <span class="enscript-comment">/* Return failure if at end of input.  */</span>
	  <span class="enscript-keyword">if</span> (yychar == YYEOF)
	    YYABORT;
	}
      <span class="enscript-keyword">else</span>
	{
	  yydestruct (<span class="enscript-string">&quot;Error: discarding&quot;</span>,
		      yytoken, &amp;yylval);
	  yychar = YYEMPTY;
	}
    }

  <span class="enscript-comment">/* Else will try to reuse look-ahead token after shifting the error
     token.  */</span>
  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyerrlab1</span>;


<span class="enscript-comment">/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/</span>
<span class="enscript-reference">yyerrorlab</span>:

  <span class="enscript-comment">/* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */</span>
  <span class="enscript-keyword">if</span> (<span class="enscript-comment">/*CONSTCOND*/</span> 0)
     <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyerrorlab</span>;

  <span class="enscript-comment">/* Do not reclaim the symbols of the rule which action triggered
     this YYERROR.  */</span>
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyerrlab1</span>;


<span class="enscript-comment">/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/</span>
<span class="enscript-reference">yyerrlab1</span>:
  yyerrstatus = 3;	<span class="enscript-comment">/* Each real token shifted decrements this.  */</span>

  <span class="enscript-keyword">for</span> (;;)
    {
      yyn = yypact[yystate];
      <span class="enscript-keyword">if</span> (yyn != YYPACT_NINF)
	{
	  yyn += YYTERROR;
	  <span class="enscript-keyword">if</span> (0 &lt;= yyn &amp;&amp; yyn &lt;= YYLAST &amp;&amp; yycheck[yyn] == YYTERROR)
	    {
	      yyn = yytable[yyn];
	      <span class="enscript-keyword">if</span> (0 &lt; yyn)
		<span class="enscript-keyword">break</span>;
	    }
	}

      <span class="enscript-comment">/* Pop the current state because it cannot handle the error token.  */</span>
      <span class="enscript-keyword">if</span> (yyssp == yyss)
	YYABORT;


      yydestruct (<span class="enscript-string">&quot;Error: popping&quot;</span>,
		  yystos[yystate], yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  <span class="enscript-keyword">if</span> (yyn == YYFINAL)
    YYACCEPT;

  *++yyvsp = yylval;


  <span class="enscript-comment">/* Shift the error token.  */</span>
  YY_SYMBOL_PRINT (<span class="enscript-string">&quot;Shifting&quot;</span>, yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yynewstate</span>;


<span class="enscript-comment">/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/</span>
<span class="enscript-reference">yyacceptlab</span>:
  yyresult = 0;
  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyreturn</span>;

<span class="enscript-comment">/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/</span>
<span class="enscript-reference">yyabortlab</span>:
  yyresult = 1;
  <span class="enscript-keyword">goto</span> <span class="enscript-reference">yyreturn</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">yyoverflow</span>
<span class="enscript-comment">/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/</span>
<span class="enscript-reference">yyexhaustedlab</span>:
  yyerror (YY_(<span class="enscript-string">&quot;memory exhausted&quot;</span>));
  yyresult = 2;
  <span class="enscript-comment">/* Fall through.  */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">yyreturn</span>:
  <span class="enscript-keyword">if</span> (yychar != YYEOF &amp;&amp; yychar != YYEMPTY)
     yydestruct (<span class="enscript-string">&quot;Cleanup: discarding lookahead&quot;</span>,
		 yytoken, &amp;yylval);
  <span class="enscript-comment">/* Do not reclaim the symbols of the rule which action triggered
     this YYABORT or YYACCEPT.  */</span>
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  <span class="enscript-keyword">while</span> (yyssp != yyss)
    {
      yydestruct (<span class="enscript-string">&quot;Cleanup: popping&quot;</span>,
		  yystos[*yyssp], yyvsp);
      YYPOPSTACK (1);
    }
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">yyoverflow</span>
  <span class="enscript-keyword">if</span> (yyss != yyssa)
    YYSTACK_FREE (yyss);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">YYERROR_VERBOSE</span>
  <span class="enscript-keyword">if</span> (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#<span class="enscript-reference">endif</span>
  <span class="enscript-comment">/* Make sure YYID is used.  */</span>
  <span class="enscript-keyword">return</span> YYID (yyresult);
}


#<span class="enscript-reference">line</span> 326 <span class="enscript-string">&quot;OSUnserializeXML.y&quot;</span>


<span class="enscript-type">int</span>
<span class="enscript-function-name">OSUnserializeerror</span>(parser_state_t * state, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s)  <span class="enscript-comment">/* Called by yyparse on errors */</span>
{
    <span class="enscript-keyword">if</span> (state-&gt;errorString) {
	<span class="enscript-type">char</span> tempString[128];
	snprintf(tempString, 128, <span class="enscript-string">&quot;OSUnserializeXML: %s near line %d\n&quot;</span>, s, state-&gt;lineNumber);
	*(state-&gt;errorString) = OSString::withCString(tempString);
    }
    
    <span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_MAX_LENGTH</span>		32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_MAX_ATTRIBUTES</span>	32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_BAD</span>			0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_START</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_END</span>			2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_EMPTY</span>		3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TAG_IGNORE</span>		4

#<span class="enscript-reference">define</span> <span class="enscript-function-name">currentChar</span>()	(state-&gt;parseBuffer[state-&gt;parseBufferIndex])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nextChar</span>()	(state-&gt;parseBuffer[++state-&gt;parseBufferIndex])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">prevChar</span>()	(state-&gt;parseBuffer[state-&gt;parseBufferIndex - 1])

#<span class="enscript-reference">define</span> <span class="enscript-function-name">isSpace</span>(c)	((c) == <span class="enscript-string">' '</span> || (c) == <span class="enscript-string">'\t'</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isAlpha</span>(c)	(((c) &gt;= <span class="enscript-string">'A'</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'Z'</span>) || ((c) &gt;= <span class="enscript-string">'a'</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'z'</span>))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isDigit</span>(c)	((c) &gt;= <span class="enscript-string">'0'</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'9'</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isAlphaDigit</span>(c)	((c) &gt;= <span class="enscript-string">'a'</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'f'</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isHexDigit</span>(c)	(isDigit(c) || isAlphaDigit(c))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isAlphaNumeric</span>(c) (isAlpha(c) || isDigit(c) || ((c) == <span class="enscript-string">'-'</span>)) 

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getTag</span>(parser_state_t *state,
       <span class="enscript-type">char</span> tag[TAG_MAX_LENGTH],
       <span class="enscript-type">int</span> *attributeCount, 
       <span class="enscript-type">char</span> attributes[TAG_MAX_ATTRIBUTES][TAG_MAX_LENGTH],
       <span class="enscript-type">char</span> values[TAG_MAX_ATTRIBUTES][TAG_MAX_LENGTH] )
{
	<span class="enscript-type">int</span> length = 0;
	<span class="enscript-type">int</span> c = currentChar();
	<span class="enscript-type">int</span> tagType = TAG_START;

	*attributeCount = 0;

	<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'&lt;'</span>) <span class="enscript-keyword">return</span> TAG_BAD;
        c = nextChar();		<span class="enscript-comment">// skip '&lt;'
</span>

	<span class="enscript-comment">// &lt;!TAG   declarations     &gt;
</span>	<span class="enscript-comment">// &lt;!--     comments      --&gt;
</span>        <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'!'</span>) {
	    c = nextChar();  
	    <span class="enscript-type">bool</span> isComment = (c == <span class="enscript-string">'-'</span>) &amp;&amp; ((c = nextChar()) != 0) &amp;&amp; (c == <span class="enscript-string">'-'</span>);
	    <span class="enscript-keyword">if</span> (!isComment &amp;&amp; !isAlpha(c)) <span class="enscript-keyword">return</span> TAG_BAD;   <span class="enscript-comment">// &lt;!1, &lt;!-A, &lt;!eos
</span>
	    <span class="enscript-keyword">while</span> (c &amp;&amp; (c = nextChar()) != 0) {
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span>) state-&gt;lineNumber++;
		<span class="enscript-keyword">if</span> (isComment) {
		    <span class="enscript-keyword">if</span> (c != <span class="enscript-string">'-'</span>) <span class="enscript-keyword">continue</span>;
		    c = nextChar();
		    <span class="enscript-keyword">if</span> (c != <span class="enscript-string">'-'</span>) <span class="enscript-keyword">continue</span>;
		    c = nextChar();
		}
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'&gt;'</span>) {
		    (<span class="enscript-type">void</span>)nextChar();
		    <span class="enscript-keyword">return</span> TAG_IGNORE;
		}
		<span class="enscript-keyword">if</span> (isComment) <span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">return</span> TAG_BAD;
	}

	<span class="enscript-keyword">else</span>

	<span class="enscript-comment">// &lt;? Processing Instructions  ?&gt;
</span>        <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'?'</span>) {
	    <span class="enscript-keyword">while</span> ((c = nextChar()) != 0) {
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span>) state-&gt;lineNumber++;
		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'?'</span>) <span class="enscript-keyword">continue</span>;
		c = nextChar();
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'&gt;'</span>) {
		    (<span class="enscript-type">void</span>)nextChar();
		    <span class="enscript-keyword">return</span> TAG_IGNORE;
		}
	    }
	    <span class="enscript-keyword">return</span> TAG_BAD;
	}

	<span class="enscript-keyword">else</span>

	<span class="enscript-comment">// &lt;/ end tag &gt;    
</span>	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'/'</span>) {
		c = nextChar();		<span class="enscript-comment">// skip '/'
</span>		tagType = TAG_END;
	}
        <span class="enscript-keyword">if</span> (!isAlpha(c)) <span class="enscript-keyword">return</span> TAG_BAD;

	<span class="enscript-comment">/* find end of tag while copying it */</span>
	<span class="enscript-keyword">while</span> (isAlphaNumeric(c)) {
		tag[length++] = c;
		c = nextChar();
		<span class="enscript-keyword">if</span> (length &gt;= (TAG_MAX_LENGTH - 1)) <span class="enscript-keyword">return</span> TAG_BAD;
	}

	tag[length] = 0;

<span class="enscript-comment">//	printf(&quot;tag %s, type %d\n&quot;, tag, tagType);
</span>	
	<span class="enscript-comment">// look for attributes of the form attribute = &quot;value&quot; ...
</span>	<span class="enscript-keyword">while</span> ((c != <span class="enscript-string">'&gt;'</span>) &amp;&amp; (c != <span class="enscript-string">'/'</span>)) {
		<span class="enscript-keyword">while</span> (isSpace(c)) c = nextChar();

		length = 0;
		<span class="enscript-keyword">while</span> (isAlphaNumeric(c)) {
			attributes[*attributeCount][length++] = c;
			<span class="enscript-keyword">if</span> (length &gt;= (TAG_MAX_LENGTH - 1)) <span class="enscript-keyword">return</span> TAG_BAD;
			c = nextChar();
		}
		attributes[*attributeCount][length] = 0;

		<span class="enscript-keyword">while</span> (isSpace(c)) c = nextChar();
		
		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'='</span>) <span class="enscript-keyword">return</span> TAG_BAD;
		c = nextChar();
		
		<span class="enscript-keyword">while</span> (isSpace(c)) c = nextChar();

		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'&quot;'</span>) <span class="enscript-keyword">return</span> TAG_BAD;
		c = nextChar();
		length = 0;
		<span class="enscript-keyword">while</span> (c != <span class="enscript-string">'&quot;'</span>) {
			values[*attributeCount][length++] = c;
			<span class="enscript-keyword">if</span> (length &gt;= (TAG_MAX_LENGTH - 1)) <span class="enscript-keyword">return</span> TAG_BAD;
			c = nextChar();
		}
		values[*attributeCount][length] = 0;

		c = nextChar(); <span class="enscript-comment">// skip closing quote
</span>
<span class="enscript-comment">//		printf(&quot;	attribute '%s' = '%s', nextchar = '%c'\n&quot;, 
</span><span class="enscript-comment">//		       attributes[*attributeCount], values[*attributeCount], c);
</span>
		(*attributeCount)++;
		<span class="enscript-keyword">if</span> (*attributeCount &gt;= TAG_MAX_ATTRIBUTES) <span class="enscript-keyword">return</span> TAG_BAD;
	}

	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'/'</span>) {
		c = nextChar();		<span class="enscript-comment">// skip '/'
</span>		tagType = TAG_EMPTY;
	}
	<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'&gt;'</span>) <span class="enscript-keyword">return</span> TAG_BAD;
	c = nextChar();		<span class="enscript-comment">// skip '&gt;'
</span>
	<span class="enscript-keyword">return</span> tagType;
}

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">getString</span>(parser_state_t *state)
{
	<span class="enscript-type">int</span> c = currentChar();
	<span class="enscript-type">int</span> start, length, i, j;
	<span class="enscript-type">char</span> * tempString;

	start = state-&gt;parseBufferIndex;
	<span class="enscript-comment">/* find end of string */</span>

	<span class="enscript-keyword">while</span> (c != 0) {
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span>) state-&gt;lineNumber++;
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'&lt;'</span>) {
			<span class="enscript-keyword">break</span>;
		}
		c = nextChar();
	}

	<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'&lt;'</span>) <span class="enscript-keyword">return</span> 0;

	length = state-&gt;parseBufferIndex - start;

	<span class="enscript-comment">/* copy to null terminated buffer */</span>
	tempString = (<span class="enscript-type">char</span> *)malloc(length + 1);
	<span class="enscript-keyword">if</span> (tempString == 0) {
		printf(<span class="enscript-string">&quot;OSUnserializeXML: can't alloc temp memory\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	}

	<span class="enscript-comment">// copy out string in tempString
</span>	<span class="enscript-comment">// &quot;&amp;amp;&quot; -&gt; '&amp;', &quot;&amp;lt;&quot; -&gt; '&lt;', &quot;&amp;gt;&quot; -&gt; '&gt;'
</span>
	i = j = 0;
	<span class="enscript-keyword">while</span> (i &lt; length) {
		c = state-&gt;parseBuffer[start + i++];
		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'&amp;'</span>) {
			tempString[j++] = c;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((i+3) &gt; length) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
			c = state-&gt;parseBuffer[start + i++];
			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'l'</span>) {
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">'t'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">';'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				tempString[j++] = <span class="enscript-string">'&lt;'</span>;
				<span class="enscript-keyword">continue</span>;
			}	
			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'g'</span>) {
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">'t'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">';'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				tempString[j++] = <span class="enscript-string">'&gt;'</span>;
				<span class="enscript-keyword">continue</span>;
			}	
			<span class="enscript-keyword">if</span> ((i+3) &gt; length) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'a'</span>) {
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">'m'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">'p'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				<span class="enscript-keyword">if</span> (state-&gt;parseBuffer[start + i++] != <span class="enscript-string">';'</span>) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
				tempString[j++] = <span class="enscript-string">'&amp;'</span>;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
		}	
	}
	tempString[j] = 0;

<span class="enscript-comment">//	printf(&quot;string %s\n&quot;, tempString);
</span>
	<span class="enscript-keyword">return</span> tempString;

<span class="enscript-reference">error</span>:
	<span class="enscript-keyword">if</span> (tempString) free(tempString);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getNumber</span>(parser_state_t *state)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> n = 0;
	<span class="enscript-type">int</span> base = 10;
	<span class="enscript-type">bool</span> negate = false;
	<span class="enscript-type">int</span> c = currentChar();

	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'0'</span>) {
		c = nextChar();
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'x'</span>) {
			base = 16;
			c = nextChar();
		}
	}
	<span class="enscript-keyword">if</span> (base == 10) {
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'-'</span>) {
			negate = true;
			c = nextChar();
		}
		<span class="enscript-keyword">while</span>(isDigit(c)) {
			n = (n * base + c - <span class="enscript-string">'0'</span>);
			c = nextChar();
		}
		<span class="enscript-keyword">if</span> (negate) {
			n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)n * (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)-1);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span>(isHexDigit(c)) {
			<span class="enscript-keyword">if</span> (isDigit(c)) {
				n = (n * base + c - <span class="enscript-string">'0'</span>);
			} <span class="enscript-keyword">else</span> {
				n = (n * base + 0xa + c - <span class="enscript-string">'a'</span>);
			}
			c = nextChar();
		}
	}
<span class="enscript-comment">//	printf(&quot;number 0x%x\n&quot;, (unsigned long)n);
</span>	<span class="enscript-keyword">return</span> n;
}

<span class="enscript-comment">// taken from CFXMLParsing/CFPropertyList.c
</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">signed</span> <span class="enscript-type">char</span> __CFPLDataDecodeTable[128] = {
    <span class="enscript-comment">/* 000 */</span> -1, -1, -1, -1, -1, -1, -1, -1,
    <span class="enscript-comment">/* 010 */</span> -1, -1, -1, -1, -1, -1, -1, -1,
    <span class="enscript-comment">/* 020 */</span> -1, -1, -1, -1, -1, -1, -1, -1,
    <span class="enscript-comment">/* 030 */</span> -1, -1, -1, -1, -1, -1, -1, -1,
    <span class="enscript-comment">/* ' ' */</span> -1, -1, -1, -1, -1, -1, -1, -1,
    <span class="enscript-comment">/* '(' */</span> -1, -1, -1, 62, -1, -1, -1, 63,
    <span class="enscript-comment">/* '0' */</span> 52, 53, 54, 55, 56, 57, 58, 59,
    <span class="enscript-comment">/* '8' */</span> 60, 61, -1, -1, -1,  0, -1, -1,
    <span class="enscript-comment">/* '@' */</span> -1,  0,  1,  2,  3,  4,  5,  6,
    <span class="enscript-comment">/* 'H' */</span>  7,  8,  9, 10, 11, 12, 13, 14,
    <span class="enscript-comment">/* 'P' */</span> 15, 16, 17, 18, 19, 20, 21, 22,
    <span class="enscript-comment">/* 'X' */</span> 23, 24, 25, -1, -1, -1, -1, -1,
    <span class="enscript-comment">/* '`' */</span> -1, 26, 27, 28, 29, 30, 31, 32,
    <span class="enscript-comment">/* 'h' */</span> 33, 34, 35, 36, 37, 38, 39, 40,
    <span class="enscript-comment">/* 'p' */</span> 41, 42, 43, 44, 45, 46, 47, 48,
    <span class="enscript-comment">/* 'x' */</span> 49, 50, 51, -1, -1, -1, -1, -1
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DATA_ALLOC_SIZE</span> 4096

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">getCFEncodedData</span>(parser_state_t *state, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *size)
{
    <span class="enscript-type">int</span> numeq = 0, acc = 0, cntr = 0;
    <span class="enscript-type">int</span> tmpbufpos = 0, tmpbuflen = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *tmpbuf = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)malloc(DATA_ALLOC_SIZE);

    <span class="enscript-type">int</span> c = currentChar();
    *size = 0;
	
    <span class="enscript-keyword">while</span> (c != <span class="enscript-string">'&lt;'</span>) {
        c &amp;= 0x7f;
	<span class="enscript-keyword">if</span> (c == 0) {
		free(tmpbuf);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'='</span>) numeq++; <span class="enscript-keyword">else</span> numeq = 0;
	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span>) state-&gt;lineNumber++;
        <span class="enscript-keyword">if</span> (__CFPLDataDecodeTable[c] &lt; 0) {
	    c = nextChar();
            <span class="enscript-keyword">continue</span>;
	}
        cntr++;
        acc &lt;&lt;= 6;
        acc += __CFPLDataDecodeTable[c];
        <span class="enscript-keyword">if</span> (0 == (cntr &amp; 0x3)) {
            <span class="enscript-keyword">if</span> (tmpbuflen &lt;= tmpbufpos + 2) {
                tmpbuflen += DATA_ALLOC_SIZE;
		tmpbuf = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)realloc(tmpbuf, tmpbuflen);
            }
            tmpbuf[tmpbufpos++] = (acc &gt;&gt; 16) &amp; 0xff;
            <span class="enscript-keyword">if</span> (numeq &lt; 2)
                tmpbuf[tmpbufpos++] = (acc &gt;&gt; 8) &amp; 0xff;
            <span class="enscript-keyword">if</span> (numeq &lt; 1)
                tmpbuf[tmpbufpos++] = acc &amp; 0xff;
        }
	c = nextChar();
    }
    *size = tmpbufpos;
    <span class="enscript-keyword">if</span> (*size == 0) {
	free(tmpbuf);
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">return</span> tmpbuf;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">getHexData</span>(parser_state_t *state, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *size)
{
    <span class="enscript-type">int</span> c;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *d, *start, *lastStart;

    start = lastStart = d = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)malloc(DATA_ALLOC_SIZE);
    c = currentChar();

    <span class="enscript-keyword">while</span> (c != <span class="enscript-string">'&lt;'</span>) {

	<span class="enscript-keyword">if</span> (isSpace(c)) <span class="enscript-keyword">while</span> ((c = nextChar()) != 0 &amp;&amp; isSpace(c)) {};
	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span>) {
	    state-&gt;lineNumber++;
	    c = nextChar();
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">// get high nibble
</span>	<span class="enscript-keyword">if</span> (isDigit(c)) {
	    *d = (c - <span class="enscript-string">'0'</span>) &lt;&lt; 4;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (isAlphaDigit(c)) {
	    *d =  (0xa + (c - <span class="enscript-string">'a'</span>)) &lt;&lt; 4;
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	}

	<span class="enscript-comment">// get low nibble
</span>	c = nextChar();
	<span class="enscript-keyword">if</span> (isDigit(c)) {
	    *d |= c - <span class="enscript-string">'0'</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (isAlphaDigit(c)) {
	    *d |= 0xa + (c - <span class="enscript-string">'a'</span>);
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	}
	
	d++;
	<span class="enscript-keyword">if</span> ((d - lastStart) &gt;= DATA_ALLOC_SIZE) {
	    <span class="enscript-type">int</span> oldsize = d - start;
	    start = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)realloc(start, oldsize + DATA_ALLOC_SIZE);
	    d = lastStart = start + oldsize;
	}
	c = nextChar();
    }

    *size = d - start;
    <span class="enscript-keyword">return</span> start;

 <span class="enscript-reference">error</span>:

    *size = 0;
    free(start);
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">yylex</span>(YYSTYPE *lvalp, parser_state_t *state)
{
	<span class="enscript-type">int</span> c, i;
	<span class="enscript-type">int</span> tagType;
	<span class="enscript-type">char</span> tag[TAG_MAX_LENGTH];
	<span class="enscript-type">int</span> attributeCount;
	<span class="enscript-type">char</span> attributes[TAG_MAX_ATTRIBUTES][TAG_MAX_LENGTH];
	<span class="enscript-type">char</span> values[TAG_MAX_ATTRIBUTES][TAG_MAX_LENGTH];
	object_t *object;

 <span class="enscript-reference">top</span>:
	c = currentChar();

	<span class="enscript-comment">/* skip white space  */</span>
	<span class="enscript-keyword">if</span> (isSpace(c)) <span class="enscript-keyword">while</span> ((c = nextChar()) != 0 &amp;&amp; isSpace(c)) {};

	<span class="enscript-comment">/* keep track of line number, don't return \n's */</span>
	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span>) {
		STATE-&gt;lineNumber++;
		(<span class="enscript-type">void</span>)nextChar();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
	}

	<span class="enscript-comment">// end of the buffer?
</span>	<span class="enscript-keyword">if</span> (!c)	<span class="enscript-keyword">return</span> 0;

	tagType = getTag(STATE, tag, &amp;attributeCount, attributes, values);
	<span class="enscript-keyword">if</span> (tagType == TAG_BAD) <span class="enscript-keyword">return</span> SYNTAX_ERROR;
	<span class="enscript-keyword">if</span> (tagType == TAG_IGNORE) <span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;

	<span class="enscript-comment">// handle allocation and check for &quot;ID&quot; and &quot;IDREF&quot; tags up front
</span>	*lvalp = object = newObject(STATE);
	object-&gt;idref = -1;
	<span class="enscript-keyword">for</span> (i=0; i &lt; attributeCount; i++) {
	    <span class="enscript-keyword">if</span> (attributes[i][0] == <span class="enscript-string">'I'</span> &amp;&amp; attributes[i][1] == <span class="enscript-string">'D'</span>) {
		<span class="enscript-comment">// check for idref's, note: we ignore the tag, for
</span>		<span class="enscript-comment">// this to work correctly, all idrefs must be unique
</span>		<span class="enscript-comment">// across the whole serialization
</span>		<span class="enscript-keyword">if</span> (attributes[i][2] == <span class="enscript-string">'R'</span> &amp;&amp; attributes[i][3] == <span class="enscript-string">'E'</span> &amp;&amp;
		    attributes[i][4] == <span class="enscript-string">'F'</span> &amp;&amp; !attributes[i][5]) {
		    <span class="enscript-keyword">if</span> (tagType != TAG_EMPTY) <span class="enscript-keyword">return</span> SYNTAX_ERROR;
		    object-&gt;idref = strtol(values[i], NULL, 0);
		    <span class="enscript-keyword">return</span> IDREF;
		}
		<span class="enscript-comment">// check for id's
</span>		<span class="enscript-keyword">if</span> (!attributes[i][2]) {
		    object-&gt;idref = strtol(values[i], NULL, 0);
		} <span class="enscript-keyword">else</span> {
		    <span class="enscript-keyword">return</span> SYNTAX_ERROR;
		}
	    }
	}

	<span class="enscript-keyword">switch</span> (*tag) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'a'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;array&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;elements = NULL;
				<span class="enscript-keyword">return</span> ARRAY;
			}
			<span class="enscript-keyword">return</span> (tagType == TAG_START) ? <span class="enscript-string">'('</span> : <span class="enscript-string">')'</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;dict&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;elements = NULL;
				<span class="enscript-keyword">return</span> DICTIONARY;
			}
			<span class="enscript-keyword">return</span> (tagType == TAG_START) ? <span class="enscript-string">'{'</span> : <span class="enscript-string">'}'</span>;
		}
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;data&quot;</span>)) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> size;
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;data = NULL;
				object-&gt;size = 0;
				<span class="enscript-keyword">return</span> DATA;
			}

			<span class="enscript-type">bool</span> isHexFormat = false;
			<span class="enscript-keyword">for</span> (i=0; i &lt; attributeCount; i++) {
				<span class="enscript-keyword">if</span> (!strcmp(attributes[i], <span class="enscript-string">&quot;format&quot;</span>) &amp;&amp; !strcmp(values[i], <span class="enscript-string">&quot;hex&quot;</span>)) {
					isHexFormat = true;
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-comment">// CF encoded is the default form
</span>			<span class="enscript-keyword">if</span> (isHexFormat) {
			    object-&gt;data = getHexData(STATE, &amp;size);
			} <span class="enscript-keyword">else</span> {
			    object-&gt;data = getCFEncodedData(STATE, &amp;size);
			}
			object-&gt;size = size;
			<span class="enscript-keyword">if</span> ((getTag(STATE, tag, &amp;attributeCount, attributes, values) != TAG_END) || strcmp(tag, <span class="enscript-string">&quot;data&quot;</span>)) {
				<span class="enscript-keyword">return</span> SYNTAX_ERROR;
			}
			<span class="enscript-keyword">return</span> DATA;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'f'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;false&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;number = 0;
				<span class="enscript-keyword">return</span> BOOLEAN;
			}
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'i'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;integer&quot;</span>)) {
			object-&gt;size = 64;	<span class="enscript-comment">// default
</span>			<span class="enscript-keyword">for</span> (i=0; i &lt; attributeCount; i++) {
				<span class="enscript-keyword">if</span> (!strcmp(attributes[i], <span class="enscript-string">&quot;size&quot;</span>)) {
					object-&gt;size = strtoul(values[i], NULL, 0);
				}
			}
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;number = 0;
				<span class="enscript-keyword">return</span> NUMBER;
			}
			object-&gt;number = getNumber(STATE);
			<span class="enscript-keyword">if</span> ((getTag(STATE, tag, &amp;attributeCount, attributes, values) != TAG_END) || strcmp(tag, <span class="enscript-string">&quot;integer&quot;</span>)) {
				<span class="enscript-keyword">return</span> SYNTAX_ERROR;
			}
			<span class="enscript-keyword">return</span> NUMBER;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'k'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;key&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) <span class="enscript-keyword">return</span> SYNTAX_ERROR;
			object-&gt;string = getString(STATE);
			<span class="enscript-keyword">if</span> (!object-&gt;string) {
				<span class="enscript-keyword">return</span> SYNTAX_ERROR;
			}
			<span class="enscript-keyword">if</span> ((getTag(STATE, tag, &amp;attributeCount, attributes, values) != TAG_END)
			   || strcmp(tag, <span class="enscript-string">&quot;key&quot;</span>)) {
				<span class="enscript-keyword">return</span> SYNTAX_ERROR;
			}
			<span class="enscript-keyword">return</span> KEY;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;plist&quot;</span>)) {
			freeObject(STATE, object);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;string&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
			    	object-&gt;string = (<span class="enscript-type">char</span> *)malloc(1);
			    	object-&gt;string[0] = 0;
				<span class="enscript-keyword">return</span> STRING;
			}
			object-&gt;string = getString(STATE);
			<span class="enscript-keyword">if</span> (!object-&gt;string) {
				<span class="enscript-keyword">return</span> SYNTAX_ERROR;
			}
			<span class="enscript-keyword">if</span> ((getTag(STATE, tag, &amp;attributeCount, attributes, values) != TAG_END)
			   || strcmp(tag, <span class="enscript-string">&quot;string&quot;</span>)) {
				<span class="enscript-keyword">return</span> SYNTAX_ERROR;
			}
			<span class="enscript-keyword">return</span> STRING;
		}
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;set&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;elements = NULL;
				<span class="enscript-keyword">return</span> SET;;
			}
			<span class="enscript-keyword">if</span> (tagType == TAG_START) {
				<span class="enscript-keyword">return</span> <span class="enscript-string">'['</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> <span class="enscript-string">']'</span>;
			}
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
		<span class="enscript-keyword">if</span> (!strcmp(tag, <span class="enscript-string">&quot;true&quot;</span>)) {
			<span class="enscript-keyword">if</span> (tagType == TAG_EMPTY) {
				object-&gt;number = 1;
				<span class="enscript-keyword">return</span> BOOLEAN;
			}
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> SYNTAX_ERROR;
}

<span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span><span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span><span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span>
<span class="enscript-comment">// &quot;java&quot; like allocation, if this code hits a syntax error in the
</span><span class="enscript-comment">// the middle of the parsed string we just bail with pointers hanging
</span><span class="enscript-comment">// all over place, this code helps keeps it all together
</span>
<span class="enscript-comment">//static int object_count = 0;
</span>
object_t *
<span class="enscript-function-name">newObject</span>(parser_state_t *state)
{
	object_t *o;

	<span class="enscript-keyword">if</span> (state-&gt;freeObjects) {
		o = state-&gt;freeObjects;
		state-&gt;freeObjects = state-&gt;freeObjects-&gt;next;
	} <span class="enscript-keyword">else</span> {
		o = (object_t *)malloc(<span class="enscript-keyword">sizeof</span>(object_t));
<span class="enscript-comment">//		object_count++;
</span>		bzero(o, <span class="enscript-keyword">sizeof</span>(object_t));
		o-&gt;free = state-&gt;objects;
		state-&gt;objects = o;
	}
	
	<span class="enscript-keyword">return</span> o;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">freeObject</span>(parser_state_t * state, object_t *o)
{
	o-&gt;next = state-&gt;freeObjects;
	state-&gt;freeObjects = o;	
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cleanupObjects</span>(parser_state_t *state)
{
	object_t *t, *o = state-&gt;objects;

	<span class="enscript-keyword">while</span> (o) {
		<span class="enscript-keyword">if</span> (o-&gt;object) {
<span class="enscript-comment">//			printf(&quot;OSUnserializeXML: releasing object o=%x object=%x\n&quot;, (int)o, (int)o-&gt;object);
</span>			o-&gt;object-&gt;release();
		}
		<span class="enscript-keyword">if</span> (o-&gt;data) {
<span class="enscript-comment">//			printf(&quot;OSUnserializeXML: freeing   object o=%x data=%x\n&quot;, (int)o, (int)o-&gt;data);
</span>			free(o-&gt;data);
		}
		<span class="enscript-keyword">if</span> (o-&gt;key) {
<span class="enscript-comment">//			printf(&quot;OSUnserializeXML: releasing object o=%x key=%x\n&quot;, (int)o, (int)o-&gt;key);
</span>			o-&gt;key-&gt;release();
		}
		<span class="enscript-keyword">if</span> (o-&gt;string) {
<span class="enscript-comment">//			printf(&quot;OSUnserializeXML: freeing   object o=%x string=%x\n&quot;, (int)o, (int)o-&gt;string);
</span>			free(o-&gt;string);
		}

		t = o;
		o = o-&gt;free;
		free(t);
<span class="enscript-comment">//		object_count--;
</span>	}
<span class="enscript-comment">//	printf(&quot;object_count = %d\n&quot;, object_count);
</span>}

<span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span><span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span><span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">rememberObject</span>(parser_state_t *state, <span class="enscript-type">int</span> tag, OSObject *o)
{
	<span class="enscript-type">char</span> key[16];
	snprintf(key, 16, <span class="enscript-string">&quot;%u&quot;</span>, tag);

<span class="enscript-comment">//	printf(&quot;remember key %s\n&quot;, key);
</span>
	state-&gt;tags-&gt;setObject(key, o);
}

<span class="enscript-type">static</span> object_t *
<span class="enscript-function-name">retrieveObject</span>(parser_state_t *state, <span class="enscript-type">int</span> tag)
{
	OSObject *ref;
	object_t *o;
	<span class="enscript-type">char</span> key[16];
	snprintf(key, 16, <span class="enscript-string">&quot;%u&quot;</span>, tag);

<span class="enscript-comment">//	printf(&quot;retrieve key '%s'\n&quot;, key);
</span>
	ref = state-&gt;tags-&gt;getObject(key);
	<span class="enscript-keyword">if</span> (!ref) <span class="enscript-keyword">return</span> 0;

	o = newObject(state);
	o-&gt;object = ref;
	<span class="enscript-keyword">return</span> o;
}

<span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span><span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span><span class="enscript-comment">// !@$&amp;)(^Q$&amp;*^!$(*!@$_(^%_(*Q#$(_*&amp;!$_(*&amp;!$_(*&amp;!#$(*!@&amp;^!@#%!_!#
</span>
object_t *
<span class="enscript-function-name">buildDictionary</span>(parser_state_t *state, object_t * header)
{
	object_t *o, *t;
	<span class="enscript-type">int</span> count = 0;
	OSDictionary *dict;

	<span class="enscript-comment">// get count and reverse order
</span>	o = header-&gt;elements;
	header-&gt;elements = 0;
	<span class="enscript-keyword">while</span> (o) {
		count++;
		t = o;
		o = o-&gt;next;

		t-&gt;next = header-&gt;elements;
		header-&gt;elements = t;
	}

	dict = OSDictionary::withCapacity(count);
	<span class="enscript-keyword">if</span> (header-&gt;idref &gt;= 0) rememberObject(state, header-&gt;idref, dict);

	o = header-&gt;elements;
	<span class="enscript-keyword">while</span> (o) {
		dict-&gt;setObject(o-&gt;key, o-&gt;object);

		o-&gt;key-&gt;release();
		o-&gt;object-&gt;release();
		o-&gt;key = 0;
		o-&gt;object = 0;

		t = o;
		o = o-&gt;next;
		freeObject(state, t);
	}
	o = header;
	o-&gt;object = dict;
	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildArray</span>(parser_state_t *state, object_t * header)
{
	object_t *o, *t;
	<span class="enscript-type">int</span> count = 0;
	OSArray *array;

	<span class="enscript-comment">// get count and reverse order
</span>	o = header-&gt;elements;
	header-&gt;elements = 0;
	<span class="enscript-keyword">while</span> (o) {
		count++;
		t = o;
		o = o-&gt;next;

		t-&gt;next = header-&gt;elements;
		header-&gt;elements = t;
	}

	array = OSArray::withCapacity(count);
	<span class="enscript-keyword">if</span> (header-&gt;idref &gt;= 0) rememberObject(state, header-&gt;idref, array);

	o = header-&gt;elements;
	<span class="enscript-keyword">while</span> (o) {
		array-&gt;setObject(o-&gt;object);

		o-&gt;object-&gt;release();
		o-&gt;object = 0;

		t = o;
		o = o-&gt;next;
		freeObject(state, t);
	}
	o = header;
	o-&gt;object = array;
	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildSet</span>(parser_state_t *state, object_t *header)
{
	object_t *o = buildArray(state, header);

	OSArray *array = (OSArray *)o-&gt;object;
	OSSet *set = OSSet::withArray(array, array-&gt;getCapacity());

	<span class="enscript-comment">// write over the reference created in buildArray
</span>	<span class="enscript-keyword">if</span> (header-&gt;idref &gt;= 0) rememberObject(state, header-&gt;idref, set);

	array-&gt;release();
	o-&gt;object = set;
	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildString</span>(parser_state_t *state, object_t *o)
{
	OSString *string;

	string = OSString::withCString(o-&gt;string);
	<span class="enscript-keyword">if</span> (o-&gt;idref &gt;= 0) rememberObject(state, o-&gt;idref, string);

	free(o-&gt;string);
	o-&gt;string = 0;
	o-&gt;object = string;

	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildSymbol</span>(parser_state_t *state, object_t *o)
{
	OSSymbol *symbol;

	symbol = (OSSymbol *)OSSymbol::withCString(o-&gt;string);
	<span class="enscript-keyword">if</span> (o-&gt;idref &gt;= 0) rememberObject(state, o-&gt;idref, symbol);

	free(o-&gt;string);
	o-&gt;string = 0;
	o-&gt;object = symbol;

	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildData</span>(parser_state_t *state, object_t *o)
{
	OSData *data;

	<span class="enscript-keyword">if</span> (o-&gt;size) {
		data = OSData::withBytes(o-&gt;data, o-&gt;size);
	} <span class="enscript-keyword">else</span> {
		data = OSData::withCapacity(0);
	}
	<span class="enscript-keyword">if</span> (o-&gt;idref &gt;= 0) rememberObject(state, o-&gt;idref, data);

	<span class="enscript-keyword">if</span> (o-&gt;size) free(o-&gt;data);
	o-&gt;data = 0;
	o-&gt;object = data;
	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildNumber</span>(parser_state_t *state, object_t *o)
{
	OSNumber *number = OSNumber::withNumber(o-&gt;number, o-&gt;size);

	<span class="enscript-keyword">if</span> (o-&gt;idref &gt;= 0) rememberObject(state, o-&gt;idref, number);

	o-&gt;object = number;
	<span class="enscript-keyword">return</span> o;
};

object_t *
<span class="enscript-function-name">buildBoolean</span>(parser_state_t *state __unused, object_t *o)
{
	o-&gt;object = ((o-&gt;number == 0) ? kOSBooleanFalse : kOSBooleanTrue);
	o-&gt;object-&gt;retain();
	<span class="enscript-keyword">return</span> o;
};

OSObject*
<span class="enscript-function-name">OSUnserializeXML</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buffer, OSString **errorString)
{
	OSObject *object;

	<span class="enscript-keyword">if</span> (!buffer) <span class="enscript-keyword">return</span> 0;
	parser_state_t *state = (parser_state_t *)malloc(<span class="enscript-keyword">sizeof</span>(parser_state_t));
	<span class="enscript-keyword">if</span> (!state) <span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">// just in case
</span>	<span class="enscript-keyword">if</span> (errorString) *errorString = NULL;

	state-&gt;parseBuffer = buffer;
	state-&gt;parseBufferIndex = 0;
	state-&gt;lineNumber = 1;
	state-&gt;objects = 0;
	state-&gt;freeObjects = 0;
	state-&gt;tags = OSDictionary::withCapacity(128);
	state-&gt;errorString = errorString;
	state-&gt;parsedObject = 0;
	state-&gt;parsedObjectCount = 0;

	(<span class="enscript-type">void</span>)yyparse((<span class="enscript-type">void</span> *)state);

	object = state-&gt;parsedObject;

	cleanupObjects(state);
	state-&gt;tags-&gt;release();
	free(state);

	<span class="enscript-keyword">return</span> object;
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSSerializeBinary.h&gt;</span>

OSObject*
<span class="enscript-function-name">OSUnserializeXML</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buffer, size_t bufferSize, OSString **errorString)
{
	<span class="enscript-keyword">if</span> (!buffer) <span class="enscript-keyword">return</span> (0);
    <span class="enscript-keyword">if</span> (bufferSize &lt; <span class="enscript-keyword">sizeof</span>(kOSSerializeBinarySignature)) <span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (!strcmp(kOSSerializeBinarySignature, buffer)) <span class="enscript-keyword">return</span> OSUnserializeBinary(buffer, bufferSize, errorString);

	<span class="enscript-comment">// XML must be null terminated
</span>	<span class="enscript-keyword">if</span> (buffer[bufferSize - 1]) <span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">return</span> OSUnserializeXML(buffer, errorString);
}


<span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//		 DO NOT EDIT OSUnserializeXML.cpp!
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//			this means you!
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span>
</pre>
<hr />
</body></html>