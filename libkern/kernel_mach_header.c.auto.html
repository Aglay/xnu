<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kernel_mach_header.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kernel_mach_header.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 *	File: libkern/kernel_mach_header.c
 *
 *	Functions for accessing mach-o headers.
 *
 * NOTE:	This file supports only kernel mach headers at the present
 *		time; it's primary use is by kld, and all externally
 *		referenced routines at the present time operate against
 *		the kernel mach header _mh_execute_header, which is the
 *		header for the currently executing kernel. 
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>		// from libsa

<span class="enscript-comment">/*
 * return the last address (first avail)
 *
 * This routine operates against the currently executing kernel only
 */</span>
vm_offset_t
<span class="enscript-function-name">getlastaddr</span>(<span class="enscript-type">void</span>)
{
	kernel_segment_command_t	*sgp;
	vm_offset_t		last_addr = 0;
	kernel_mach_header_t *header = &amp;_mh_execute_header;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i;

	sgp = (kernel_segment_command_t *)
		((uintptr_t)header + <span class="enscript-keyword">sizeof</span>(kernel_mach_header_t));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;ncmds; i++){
		<span class="enscript-keyword">if</span> (sgp-&gt;cmd == LC_SEGMENT_KERNEL) {
			<span class="enscript-keyword">if</span> (sgp-&gt;vmaddr + sgp-&gt;vmsize &gt; last_addr)
				last_addr = sgp-&gt;vmaddr + sgp-&gt;vmsize;
		}
		sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);
	}
	<span class="enscript-keyword">return</span> last_addr;
}

<span class="enscript-comment">/*
 * Find the specified load command in the Mach-O headers, and return
 * the command. If there is no such load command, NULL is returned.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">getcommandfromheader</span>(kernel_mach_header_t *mhp, uint32_t cmd) {
	<span class="enscript-type">struct</span> load_command *lcp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i;

	lcp = (<span class="enscript-type">struct</span> load_command *) (mhp + 1);
	<span class="enscript-keyword">for</span>(i = 0; i &lt; mhp-&gt;ncmds; i++){
		<span class="enscript-keyword">if</span>(lcp-&gt;cmd == cmd) {
			<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *)lcp;
		}

		lcp = (<span class="enscript-type">struct</span> load_command *)((uintptr_t)lcp + lcp-&gt;cmdsize);
	}

	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * Find the UUID load command in the Mach-O headers, and return
 * the address of the UUID blob and size in &quot;*size&quot;. If the
 * Mach-O image is missing a UUID, NULL is returned.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">getuuidfromheader</span>(kernel_mach_header_t *mhp, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *size)
{
    <span class="enscript-type">struct</span> uuid_command *cmd = (<span class="enscript-type">struct</span> uuid_command *)
        getcommandfromheader(mhp, LC_UUID);

    <span class="enscript-keyword">if</span> (cmd != NULL) {
        <span class="enscript-keyword">if</span> (size) {
            *size = <span class="enscript-keyword">sizeof</span>(cmd-&gt;uuid);
        }
        <span class="enscript-keyword">return</span> cmd-&gt;uuid;
    }

    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * This routine returns the a pointer to the data for the named section in the
 * named segment if it exist in the mach header passed to it.  Also it returns
 * the size of the section data indirectly through the pointer size.  Otherwise
 *  it returns zero for the pointer and the size.
 *
 * This routine can operate against any kernel mach header.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">getsectdatafromheader</span>(
    kernel_mach_header_t *mhp,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sectname,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *size)
{		
	<span class="enscript-type">const</span> kernel_section_t *sp;
	<span class="enscript-type">void</span> *result;

	sp = getsectbynamefromheader(mhp, segname, sectname);
	<span class="enscript-keyword">if</span>(sp == (kernel_section_t *)0){
	    *size = 0;
	    <span class="enscript-keyword">return</span>((<span class="enscript-type">char</span> *)0);
	}
	*size = sp-&gt;size;
	result = (<span class="enscript-type">void</span> *)sp-&gt;addr; 
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*
 * This routine returns the a pointer to the data for the named segment
 * if it exist in the mach header passed to it.  Also it returns
 * the size of the segment data indirectly through the pointer size.
 * Otherwise it returns zero for the pointer and the size.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">getsegdatafromheader</span>(
    kernel_mach_header_t *mhp,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *size)
{
	<span class="enscript-type">const</span> kernel_segment_command_t *sc;
	<span class="enscript-type">void</span> *result;

	sc = getsegbynamefromheader(mhp, segname);
	<span class="enscript-keyword">if</span>(sc == (kernel_segment_command_t *)0){
	    *size = 0;
	    <span class="enscript-keyword">return</span>((<span class="enscript-type">char</span> *)0);
	}
	*size = sc-&gt;vmsize;
	result = (<span class="enscript-type">void</span> *)sc-&gt;vmaddr;
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*
 * This routine returns the section structure for the named section in the
 * named segment for the mach_header pointer passed to it if it exist.
 * Otherwise it returns zero.
 *
 * This routine can operate against any kernel mach header.
 */</span>
kernel_section_t *
<span class="enscript-function-name">getsectbynamefromheader</span>(
    kernel_mach_header_t *mhp,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sectname)
{
	kernel_segment_command_t *sgp;
	kernel_section_t *sp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i, j;

	sgp = (kernel_segment_command_t *)
	      ((uintptr_t)mhp + <span class="enscript-keyword">sizeof</span>(kernel_mach_header_t));
	<span class="enscript-keyword">for</span>(i = 0; i &lt; mhp-&gt;ncmds; i++){
	    <span class="enscript-keyword">if</span>(sgp-&gt;cmd == LC_SEGMENT_KERNEL)
		<span class="enscript-keyword">if</span>(strncmp(sgp-&gt;segname, segname, <span class="enscript-keyword">sizeof</span>(sgp-&gt;segname)) == 0 ||
		   mhp-&gt;filetype == MH_OBJECT){
		    sp = (kernel_section_t *)((uintptr_t)sgp +
			 <span class="enscript-keyword">sizeof</span>(kernel_segment_command_t));
		    <span class="enscript-keyword">for</span>(j = 0; j &lt; sgp-&gt;nsects; j++){
			<span class="enscript-keyword">if</span>(strncmp(sp-&gt;sectname, sectname,
			   <span class="enscript-keyword">sizeof</span>(sp-&gt;sectname)) == 0 &amp;&amp;
			   strncmp(sp-&gt;segname, segname,
			   <span class="enscript-keyword">sizeof</span>(sp-&gt;segname)) == 0)
			    <span class="enscript-keyword">return</span>(sp);
			sp = (kernel_section_t *)((uintptr_t)sp +
			     <span class="enscript-keyword">sizeof</span>(kernel_section_t));
		    }
		}
	    sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);
	}
	<span class="enscript-keyword">return</span>((kernel_section_t *)NULL);
}

<span class="enscript-comment">/*
 * This routine can operate against any kernel mach header.
 */</span>
kernel_segment_command_t *
<span class="enscript-function-name">getsegbynamefromheader</span>(
	kernel_mach_header_t	*header,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*seg_name)
{
	kernel_segment_command_t *sgp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i;

	sgp = (kernel_segment_command_t *)
		((uintptr_t)header + <span class="enscript-keyword">sizeof</span>(kernel_mach_header_t));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;ncmds; i++){
		<span class="enscript-keyword">if</span> (   sgp-&gt;cmd == LC_SEGMENT_KERNEL
		    &amp;&amp; !strncmp(sgp-&gt;segname, seg_name, <span class="enscript-keyword">sizeof</span>(sgp-&gt;segname)))
			<span class="enscript-keyword">return</span> sgp;
		sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);
	}
	<span class="enscript-keyword">return</span> (kernel_segment_command_t *)NULL;
}

<span class="enscript-comment">/*
 * Return the first segment_command in the header.
 */</span>
kernel_segment_command_t *
<span class="enscript-function-name">firstseg</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> firstsegfromheader(&amp;_mh_execute_header);
}

kernel_segment_command_t *
<span class="enscript-function-name">firstsegfromheader</span>(kernel_mach_header_t *header)
{
    u_int i = 0;
    kernel_segment_command_t *sgp = (kernel_segment_command_t *)
        ((uintptr_t)header + <span class="enscript-keyword">sizeof</span>(*header));

    <span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;ncmds; i++){
        <span class="enscript-keyword">if</span> (sgp-&gt;cmd == LC_SEGMENT_KERNEL)
            <span class="enscript-keyword">return</span> sgp;
        sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);
    }
    <span class="enscript-keyword">return</span> (kernel_segment_command_t *)NULL;
}

<span class="enscript-comment">/*
 * This routine operates against any kernel mach segment_command structure
 * pointer and the provided kernel header, to obtain the sequentially next
 * segment_command structure in that header.
 */</span>
kernel_segment_command_t *
<span class="enscript-function-name">nextsegfromheader</span>(
        kernel_mach_header_t	*header,
        kernel_segment_command_t	*seg)
{
    u_int i = 0;
    kernel_segment_command_t *sgp = (kernel_segment_command_t *)
        ((uintptr_t)header + <span class="enscript-keyword">sizeof</span>(*header));

    <span class="enscript-comment">/* Find the index of the passed-in segment */</span>
    <span class="enscript-keyword">for</span> (i = 0; sgp != seg &amp;&amp; i &lt; header-&gt;ncmds; i++) {
        sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);
    }

    <span class="enscript-comment">/* Increment to the next load command */</span>
    i++;
    sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);

    <span class="enscript-comment">/* Return the next segment command, if any */</span>
    <span class="enscript-keyword">for</span> (; i &lt; header-&gt;ncmds; i++) {
        <span class="enscript-keyword">if</span> (sgp-&gt;cmd == LC_SEGMENT_KERNEL) <span class="enscript-keyword">return</span> sgp;

        sgp = (kernel_segment_command_t *)((uintptr_t)sgp + sgp-&gt;cmdsize);
    }

    <span class="enscript-keyword">return</span> (kernel_segment_command_t *)NULL;
}


<span class="enscript-comment">/*
 * Return the address of the named Mach-O segment from the currently
 * executing kernel kernel, or NULL.
 */</span>
kernel_segment_command_t *
<span class="enscript-function-name">getsegbyname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *seg_name)
{
	<span class="enscript-keyword">return</span>(getsegbynamefromheader(&amp;_mh_execute_header, seg_name));
}

<span class="enscript-comment">/*
 * This routine returns the a pointer the section structure of the named
 * section in the named segment if it exists in the currently executing
 * kernel, which it is presumed to be linked into.  Otherwise it returns NULL.
 */</span>
kernel_section_t *
<span class="enscript-function-name">getsectbyname</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sectname)
{
	<span class="enscript-keyword">return</span>(getsectbynamefromheader(
		(kernel_mach_header_t *)&amp;_mh_execute_header, segname, sectname));
}

<span class="enscript-comment">/*
 * This routine can operate against any kernel segment_command structure to
 * return the first kernel section immediately following that structure.  If
 * there are no sections associated with the segment_command structure, it
 * returns NULL.
 */</span>
kernel_section_t *
<span class="enscript-function-name">firstsect</span>(kernel_segment_command_t *sgp)
{
	<span class="enscript-keyword">if</span> (!sgp || sgp-&gt;nsects == 0)
		<span class="enscript-keyword">return</span> (kernel_section_t *)NULL;

	<span class="enscript-keyword">return</span> (kernel_section_t *)(sgp+1);
}

<span class="enscript-comment">/*
 * This routine can operate against any kernel segment_command structure and
 * kernel section to return the next consecutive  kernel section immediately
 * following the kernel section provided.  If there are no sections following
 * the provided section, it returns NULL.
 */</span>
kernel_section_t *
<span class="enscript-function-name">nextsect</span>(kernel_segment_command_t *sgp, kernel_section_t *sp)
{
	kernel_section_t *fsp = firstsect(sgp);

	<span class="enscript-keyword">if</span> (((uintptr_t)(sp - fsp) + 1) &gt;= sgp-&gt;nsects)
		<span class="enscript-keyword">return</span> (kernel_section_t *)NULL;

	<span class="enscript-keyword">return</span> sp+1;
}
</pre>
<hr />
</body></html>